{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { mat4, mat3 } from 'gl-matrix';\nimport Constants from '../Core/ImageMapper/Constants.js';\nimport { n as newInstance$1, e as setGet, o as obj, r as vtkErrorMacro$1, c as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport vtkHelper from './Helper.js';\nimport { u as uninitializeBounds } from '../../Common/Core/Math/index.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { Filter, Wrap } from './Texture/Constants.js';\nimport { InterpolationType } from '../Core/ImageProperty/Constants.js';\nimport { v as vtkPolyDataVS } from './glsl/vtkPolyDataVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport vtkReplacementShaderMapper from './ReplacementShaderMapper.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nconst {\n  vtkErrorMacro\n} = macro;\nconst {\n  SlicingMode\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n\nfunction computeFnToString(property, pwfun, numberOfComponents) {\n  if (pwfun) {\n    const iComps = property.getIndependentComponents();\n    return `${pwfun.getMTime()}-${iComps}-${numberOfComponents}`;\n  }\n  return '0';\n}\nfunction splitStringOnEnter(inputString) {\n  // Split the input string into an array of lines based on \"Enter\" (newline) characters\n  // Remove any leading or trailing whitespace from each line and filter out empty lines\n  const lines = inputString.split('\\n');\n  const trimmedLines = [];\n  for (let i = 0; i < lines.length; ++i) {\n    const trimmedLine = lines[i].trim();\n    if (trimmedLine.length > 0) {\n      trimmedLines.push(trimmedLine);\n    }\n  }\n  return trimmedLines;\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLImageMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLImageMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLImageMapper');\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model.openGLImageSlice = publicAPI.getFirstAncestorOfType('vtkOpenGLImageSlice');\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      const ren = model._openGLRenderer.getRenderable();\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());\n      // is slice set by the camera\n      if (model.renderable.isA('vtkImageMapper') && model.renderable.getSliceAtFocalPoint()) {\n        model.renderable.setSliceFromCamera(ren.getActiveCamera());\n      }\n    }\n  };\n  publicAPI.translucentPass = (prepass, renderPass) => {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n  publicAPI.zBufferPass = prepass => {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n  publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);\n  publicAPI.opaquePass = prepass => {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n  publicAPI.getCoincidentParameters = (ren, actor) => {\n    if (model.renderable.getResolveCoincidentTopology()) {\n      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n    }\n    return null;\n  };\n\n  // Renders myself\n  publicAPI.render = () => {\n    const actor = model.openGLImageSlice.getRenderable();\n    const ren = model._openGLRenderer.getRenderable();\n    publicAPI.renderPiece(ren, actor);\n  };\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkPolyDataVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', 'tcoordVCVSOutput = tcoordMC;').result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;').result;\n    const tNumComp = model.openGLTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n    let tcoordDec = ['varying vec2 tcoordVCVSOutput;',\n    // color shift and scale\n    'uniform float cshift0;', 'uniform float cscale0;',\n    // pwf shift and scale\n    'uniform float pwfshift0;', 'uniform float pwfscale0;', 'uniform sampler2D texture1;', 'uniform sampler2D colorTexture1;', 'uniform sampler2D pwfTexture1;', 'uniform sampler2D labelOutlineTexture1;', 'uniform float opacity;', 'uniform float outlineOpacity;'];\n    if (iComps) {\n      for (let comp = 1; comp < tNumComp; comp++) {\n        tcoordDec = tcoordDec.concat([\n        // color shift and scale\n        `uniform float cshift${comp};`, `uniform float cscale${comp};`,\n        // weighting shift and scale\n        `uniform float pwfshift${comp};`, `uniform float pwfscale${comp};`]);\n      }\n      // the heights defined below are the locations\n      // for the up to four components of the tfuns\n      // the tfuns have a height of 2XnumComps pixels so the\n      // values are computed to hit the middle of the two rows\n      // for that component\n      switch (tNumComp) {\n        case 1:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', '#define height0 0.5']);\n          break;\n        case 2:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', '#define height0 0.25', '#define height1 0.75']);\n          break;\n        case 3:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', '#define height0 0.17', '#define height1 0.5', '#define height2 0.83']);\n          break;\n        case 4:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', 'uniform float mix3;', '#define height0 0.125', '#define height1 0.375', '#define height2 0.625', '#define height3 0.875']);\n          break;\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', tcoordDec).result;\n\n    // check for the outline thickness and opacity\n    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();\n    if (vtkImageLabelOutline === true) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::LabelOutline::Dec', ['uniform int outlineThickness;', 'uniform float vpWidth;', 'uniform float vpHeight;', 'uniform float vpOffsetX;', 'uniform float vpOffsetY;', 'uniform mat4 PCWCMatrix;', 'uniform mat4 vWCtoIDX;', 'uniform ivec3 imageDimensions;']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ImageLabelOutlineOn', '#define vtkImageLabelOutlineOn').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::LabelOutlineHelperFunction', ['#ifdef vtkImageLabelOutlineOn', 'vec3 fragCoordToIndexSpace(vec4 fragCoord) {', '  vec4 pcPos = vec4(', '    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,', '    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,', '    (fragCoord.z - 0.5) * 2.0,', '    1.0);', '', '  vec4 worldCoord = PCWCMatrix * pcPos;', '  vec4 vertex = (worldCoord/worldCoord.w);', '', '  vec3 index = (vWCtoIDX * vertex).xyz;', '', '  // half voxel fix for labelmapOutline', '  return (index + vec3(0.5)) / vec3(imageDimensions);', '}', '#endif']).result;\n    }\n    if (iComps) {\n      const rgba = ['r', 'g', 'b', 'a'];\n      let tcoordImpl = ['vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);'];\n      for (let comp = 0; comp < tNumComp; comp++) {\n        tcoordImpl = tcoordImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);\n      }\n      switch (tNumComp) {\n        case 1:\n          tcoordImpl = tcoordImpl.concat(['gl_FragData[0] = vec4(tcolor0.rgb, opacity);']);\n          break;\n        case 2:\n          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);']);\n          break;\n        case 3:\n          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);']);\n          break;\n        case 4:\n          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);']);\n          break;\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', tcoordImpl).result;\n    } else {\n      // dependent components\n      switch (tNumComp) {\n        case 1:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', [...splitStringOnEnter(`\n                #ifdef vtkImageLabelOutlineOn\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); \n                  float centerValue = texture2D(texture1, centerPosIS.xy).r;\n                  bool pixelOnBorder = false;\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\n                  float opacityToUse = scalarOpacity * opacity;\n                  int segmentIndex = int(centerValue * 255.0);\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\n                  int actualThickness = int(textureValue * 255.0);\n\n                  if (actualThickness == 0) {\n                    gl_FragData[0] = vec4(0.0, 0.0, 1.0, 1.0);\n                    return;\n                  }\n                  if (opacityToUse > 0.01) {\n                    for (int i = -actualThickness; i <= actualThickness; i++) {\n                      for (int j = -actualThickness; j <= actualThickness; j++) {\n                        if (i == 0 || j == 0) {\n                          continue;\n                        }\n                        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n                          gl_FragCoord.y + float(j),\n                          gl_FragCoord.z, gl_FragCoord.w);\n                        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n                        float value = texture2D(texture1, neighborPosIS.xy).r;\n                        if (value != centerValue) {\n                          pixelOnBorder = true;\n                          break;\n                        }\n                      }\n                      if (pixelOnBorder == true) {\n                        break;\n                      }\n                    }\n                    if (pixelOnBorder == true) {\n                      gl_FragData[0] = vec4(tColor, outlineOpacity);\n                    }\n                    else {\n                      gl_FragData[0] = vec4(tColor, opacityToUse);\n                    }\n                  }\n                #else\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\n                #endif\n                `)]).result;\n          break;\n        case 2:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', 'float intensity = tcolor.r*cscale0 + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);']).result;\n          break;\n        case 3:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);']).result;\n          break;\n        default:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);']).result;\n      }\n    }\n    if (model.haveSeenDepthRequest) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    publicAPI.replaceShaderClip(shaders, ren, actor);\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n  };\n  publicAPI.replaceShaderClip = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      if (numClipPlanes > 6) {\n        vtkErrorMacro$1('OpenGL has a limit of 6 clipping planes');\n        numClipPlanes = 6;\n      }\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'uniform vec4 clipPlanes[6];', 'varying float clipDistancesVSOutput[6];']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'varying float clipDistancesVSOutput[6];']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    // render pass shader replacement changed\n\n    const tNumComp = model.openGLTexture.getComponents();\n    const iComp = actor.getProperty().getIndependentComponents();\n\n    // has the render pass shader replacement changed? Two options\n    let needRebuild = false;\n    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {\n      needRebuild = true;\n    }\n    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram()?.getHandle() === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      model.lastTextureComponents = tNumComp;\n      model.lastIndependentComponents = iComp;\n      return true;\n    }\n    return false;\n  };\n  publicAPI.updateShaders = (cellBO, ren, actor) => {\n    model.lastBoundBO = cellBO;\n\n    // has something changed that would require us to recreate the shader?\n    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {\n      const shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      publicAPI.buildShaders(shaders, ren, actor);\n\n      // compile and bind the program if needed\n      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);\n\n      // if the shader changed reinitialize the VAO\n      if (newShader !== cellBO.getProgram()) {\n        cellBO.setProgram(newShader);\n        // reset the VAO as the shader has changed\n        cellBO.getVAO().releaseGraphicsResources();\n      }\n      cellBO.getShaderSourceTime().modified();\n    } else {\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());\n    }\n    cellBO.getVAO().bind();\n    publicAPI.setMapperShaderParameters(cellBO, ren, actor);\n    publicAPI.setCameraShaderParameters(cellBO, ren, actor);\n    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    // Now to update the VAO too, if necessary.\n\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexMC in shader VAO.');\n        }\n      }\n      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), model.context.FALSE)) {\n          vtkErrorMacro('Error setting tcoordMC in shader VAO.');\n        }\n      }\n      cellBO.getAttributeUpdateTime().modified();\n    }\n    const texUnit = model.openGLTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('texture1', texUnit);\n    const numComp = model.openGLTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n    if (iComps) {\n      for (let i = 0; i < numComp; i++) {\n        cellBO.getProgram().setUniformf(`mix${i}`, actor.getProperty().getComponentWeight(i));\n      }\n    }\n    const oglShiftScale = model.openGLTexture.getShiftAndScale();\n\n    // three levels of shift scale combined into one\n    // for performance in the fragment shader\n    for (let i = 0; i < numComp; i++) {\n      let cw = actor.getProperty().getColorWindow();\n      let cl = actor.getProperty().getColorLevel();\n      const target = iComps ? i : 0;\n      const cfun = actor.getProperty().getRGBTransferFunction(target);\n      if (cfun && actor.getProperty().getUseLookupTableScalarRange()) {\n        const cRange = cfun.getRange();\n        cw = cRange[1] - cRange[0];\n        cl = 0.5 * (cRange[1] + cRange[0]);\n      }\n      const scale = oglShiftScale.scale / cw;\n      const shift = (oglShiftScale.shift - cl) / cw + 0.5;\n      cellBO.getProgram().setUniformf(`cshift${i}`, shift);\n      cellBO.getProgram().setUniformf(`cscale${i}`, scale);\n    }\n\n    // pwf shift/scale\n    for (let i = 0; i < numComp; i++) {\n      let pwfScale = 1.0;\n      let pwfShift = 0.0;\n      const target = iComps ? i : 0;\n      const pwfun = actor.getProperty().getPiecewiseFunction(target);\n      if (pwfun) {\n        const pwfRange = pwfun.getRange();\n        const length = pwfRange[1] - pwfRange[0];\n        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);\n        pwfScale = oglShiftScale.scale / length;\n        pwfShift = (oglShiftScale.shift - mid) / length + 0.5;\n      }\n      cellBO.getProgram().setUniformf(`pwfshift${i}`, pwfShift);\n      cellBO.getProgram().setUniformf(`pwfscale${i}`, pwfScale);\n    }\n    if (model.haveSeenDepthRequest) {\n      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    }\n\n    // handle coincident\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      const cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset);\n      // cfactor isn't always used when coffset is.\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    }\n    const texColorUnit = model.colorTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('colorTexture1', texColorUnit);\n    const texOpacityUnit = model.pwfTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('pwfTexture1', texOpacityUnit);\n    const outlineThicknessUnit = model.labelOutlineThicknessTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('labelOutlineTexture1', outlineThicknessUnit);\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      // add all the clipping planes\n      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      if (numClipPlanes > 6) {\n        vtkErrorMacro$1('OpenGL has a limit of 6 clipping planes');\n        numClipPlanes = 6;\n      }\n      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n      const mat = inverseShiftScaleMatrix ? mat4.copy(model.imagematinv, actor.getMatrix()) : actor.getMatrix();\n      if (inverseShiftScaleMatrix) {\n        mat4.transpose(mat, mat);\n        mat4.multiply(mat, mat, inverseShiftScaleMatrix);\n        mat4.transpose(mat, mat);\n      }\n\n      // transform crop plane normal with transpose(inverse(worldToIndex))\n      mat4.transpose(model.imagemat, model.currentInput.getIndexToWorld());\n      mat4.multiply(model.imagematinv, mat, model.imagemat);\n      const planeEquations = [];\n      for (let i = 0; i < numClipPlanes; i++) {\n        const planeEquation = [];\n        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, i, planeEquation);\n        for (let j = 0; j < 4; j++) {\n          planeEquations.push(planeEquation[j]);\n        }\n      }\n      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);\n      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);\n    }\n\n    // outline thickness and opacity\n    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();\n    if (vtkImageLabelOutline === true) {\n      const outlineOpacity = actor.getProperty().getLabelOutlineOpacity();\n      cellBO.getProgram().setUniformf('outlineOpacity', outlineOpacity);\n    }\n  };\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    const actMats = model.openGLImageSlice.getKeyMatrices();\n    const image = model.currentInput;\n    const i2wmat4 = image.getIndexToWorld();\n    mat4.multiply(model.imagemat, actMats.mcwc, i2wmat4);\n    const keyMats = model.openGLCamera.getKeyMatrices(ren);\n    mat4.multiply(model.imagemat, keyMats.wcpc, model.imagemat);\n    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {\n      const inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();\n      mat4.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);\n    }\n    program.setUniformMatrix('MCPCMatrix', model.imagemat);\n    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();\n    if (vtkImageLabelOutline === true) {\n      const worldToIndex = image.getWorldToIndex();\n      const imageDimensions = image.getDimensions();\n      program.setUniform3i('imageDimensions', imageDimensions[0], imageDimensions[1], 1);\n      program.setUniformMatrix('vWCtoIDX', worldToIndex);\n      const labelOutlineKeyMats = model.openGLCamera.getKeyMatrices(ren);\n\n      // Get the projection coordinate to world coordinate transformation matrix.\n      mat4.invert(model.projectionToWorld, labelOutlineKeyMats.wcpc);\n      model.openGLCamera.getKeyMatrices(ren);\n      program.setUniformMatrix('PCWCMatrix', model.projectionToWorld);\n      const size = publicAPI.getRenderTargetSize();\n      program.setUniformf('vpWidth', size[0]);\n      program.setUniformf('vpHeight', size[1]);\n      const offset = publicAPI.getRenderTargetOffset();\n      program.setUniformf('vpOffsetX', offset[0] / size[0]);\n      program.setUniformf('vpOffsetY', offset[1] / size[1]);\n    }\n  };\n  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    const ppty = actor.getProperty();\n    const opacity = ppty.getOpacity();\n    program.setUniformf('opacity', opacity);\n  };\n  publicAPI.renderPieceStart = (ren, actor) => {\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor);\n\n    // Bind the OpenGL, this is shared between the different primitive/cell types.\n    model.lastBoundBO = null;\n  };\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const gl = model.context;\n\n    // activate the texture\n    model.openGLTexture.activate();\n    model.colorTexture.activate();\n    model.labelOutlineThicknessTexture.activate();\n    model.pwfTexture.activate();\n\n    // draw polygons\n    if (model.tris.getCABO().getElementCount()) {\n      // First we do the triangles, update the shader, set uniforms, etc.\n      publicAPI.updateShaders(model.tris, ren, actor);\n      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n      model.tris.getVAO().release();\n    }\n    model.openGLTexture.deactivate();\n    model.colorTexture.deactivate();\n    model.labelOutlineThicknessTexture.deactivate();\n    model.pwfTexture.deactivate();\n  };\n  publicAPI.renderPieceFinish = (ren, actor) => {};\n  publicAPI.renderPiece = (ren, actor) => {\n    // Make sure that we have been properly initialized.\n    // if (ren.getRenderWindow().checkAbortStatus()) {\n    //   return;\n    // }\n\n    publicAPI.invokeEvent({\n      type: 'StartEvent'\n    });\n    model.renderable.update();\n    model.currentInput = model.renderable.getCurrentImage();\n    publicAPI.invokeEvent({\n      type: 'EndEvent'\n    });\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n  publicAPI.computeBounds = (ren, actor) => {\n    if (!publicAPI.getInput()) {\n      uninitializeBounds(model.bounds);\n      return;\n    }\n    model.bounds = publicAPI.getInput().getBounds();\n  };\n  publicAPI.updateBufferObjects = (ren, actor) => {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {\n    // first do a coarse check\n    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const image = model.currentInput;\n    if (!image) {\n      return;\n    }\n    const imgScalars = image.getPointData() && image.getPointData().getScalars();\n    if (!imgScalars) {\n      return;\n    }\n    const dataType = imgScalars.getDataType();\n    const numComp = imgScalars.getNumberOfComponents();\n    const actorProperty = actor.getProperty();\n    const iType = actorProperty.getInterpolationType();\n    const iComps = actorProperty.getIndependentComponents();\n    const numIComps = iComps ? numComp : 1;\n    const textureHeight = iComps ? 2 * numIComps : 1;\n    const colorTransferFunc = actorProperty.getRGBTransferFunction();\n    const cfunToString = computeFnToString(actorProperty, colorTransferFunc, numIComps);\n    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);\n    const reBuildC = !cTex?.vtkObj || cTex?.hash !== cfunToString || model.colorTextureString !== cfunToString;\n    if (reBuildC) {\n      const cWidth = 1024;\n      const cSize = cWidth * textureHeight * 3;\n      const cTable = new Uint8Array(cSize);\n      if (!model.colorTexture) {\n        model.colorTexture = vtkOpenGLTexture.newInstance({\n          resizable: true\n        });\n        model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n      // set interpolation on the texture based on property setting\n      if (iType === InterpolationType.NEAREST) {\n        model.colorTexture.setMinificationFilter(Filter.NEAREST);\n        model.colorTexture.setMagnificationFilter(Filter.NEAREST);\n      } else {\n        model.colorTexture.setMinificationFilter(Filter.LINEAR);\n        model.colorTexture.setMagnificationFilter(Filter.LINEAR);\n      }\n      if (colorTransferFunc) {\n        const tmpTable = new Float32Array(cWidth * 3);\n        for (let c = 0; c < numIComps; c++) {\n          const cfun = actorProperty.getRGBTransferFunction(c);\n          const cRange = cfun.getRange();\n          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);\n          if (iComps) {\n            for (let i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];\n            }\n          } else {\n            for (let i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n            }\n          }\n        }\n        model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);\n        model.colorTexture.resetFormatAndType();\n        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      } else {\n        for (let i = 0; i < cWidth * 3; ++i) {\n          cTable[i] = 255.0 * i / ((cWidth - 1) * 3);\n          cTable[i + 1] = 255.0 * i / ((cWidth - 1) * 3);\n          cTable[i + 2] = 255.0 * i / ((cWidth - 1) * 3);\n        }\n        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      }\n      model.colorTextureString = cfunToString;\n      if (colorTransferFunc) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, model.colorTextureString);\n      }\n    } else {\n      model.colorTexture = cTex.vtkObj;\n      model.colorTextureString = cTex.hash;\n    }\n\n    // Build piecewise function buffer.  This buffer is used either\n    // for component weighting or opacity, depending on whether we're\n    // rendering components independently or not.\n    const pwFunc = actorProperty.getPiecewiseFunction();\n    const pwfunToString = computeFnToString(actorProperty, pwFunc, numIComps);\n    const pwfTex = model._openGLRenderWindow.getGraphicsResourceForObject(pwFunc);\n    // rebuild opacity tfun?\n    const reBuildPwf = !pwfTex?.vtkObj || pwfTex?.hash !== pwfunToString || model.pwfTextureString !== pwfunToString;\n    if (reBuildPwf) {\n      const pwfWidth = 1024;\n      const pwfSize = pwfWidth * textureHeight;\n      const pwfTable = new Uint8Array(pwfSize);\n      if (!model.pwfTexture) {\n        model.pwfTexture = vtkOpenGLTexture.newInstance({\n          resizable: true\n        });\n        model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n      // set interpolation on the texture based on property setting\n      if (iType === InterpolationType.NEAREST) {\n        model.pwfTexture.setMinificationFilter(Filter.NEAREST);\n        model.pwfTexture.setMagnificationFilter(Filter.NEAREST);\n      } else {\n        model.pwfTexture.setMinificationFilter(Filter.LINEAR);\n        model.pwfTexture.setMagnificationFilter(Filter.LINEAR);\n      }\n      if (pwFunc) {\n        const pwfFloatTable = new Float32Array(pwfSize);\n        const tmpTable = new Float32Array(pwfWidth);\n        for (let c = 0; c < numIComps; ++c) {\n          const pwfun = actorProperty.getPiecewiseFunction(c);\n          if (pwfun === null) {\n            // Piecewise constant max if no function supplied for this component\n            pwfFloatTable.fill(1.0);\n          } else {\n            const pwfRange = pwfun.getRange();\n            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);\n            // adjust for sample distance etc\n            if (iComps) {\n              for (let i = 0; i < pwfWidth; i++) {\n                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];\n                pwfFloatTable[c * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];\n              }\n            } else {\n              for (let i = 0; i < pwfWidth; i++) {\n                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];\n              }\n            }\n          }\n        }\n        model.pwfTexture.releaseGraphicsResources(model._openGLRenderWindow);\n        model.pwfTexture.resetFormatAndType();\n        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);\n      } else {\n        // default is opaque\n        pwfTable.fill(255.0);\n        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);\n      }\n      model.pwfTextureString = pwfunToString;\n      if (pwFunc) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(pwFunc, model.pwfTexture, model.pwfTextureString);\n      }\n    } else {\n      model.pwfTexture = pwfTex.vtkObj;\n      model.pwfTextureString = pwfTex.hash;\n    }\n\n    // Build outline thickness buffer\n    publicAPI.updatelabelOutlineThicknessTexture(actor);\n\n    // Find what IJK axis and what direction to slice along\n    const {\n      ijkMode\n    } = model.renderable.getClosestIJKAxis();\n\n    // Find the IJK slice\n    let slice = model.renderable.getSlice();\n    if (ijkMode !== model.renderable.getSlicingMode()) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      slice = model.renderable.getSliceAtPosition(slice);\n    }\n\n    // Use sub-Slice number/offset if mapper being used is vtkImageArrayMapper,\n    // since this mapper uses a collection of vtkImageData (and not just a single vtkImageData).\n    const nSlice = model.renderable.isA('vtkImageArrayMapper') ? model.renderable.getSubSlice() // get subSlice of the current (possibly multi-frame) image\n    : Math.round(slice);\n\n    // Find sliceOffset\n    const ext = image.getExtent();\n    let sliceOffset;\n    if (ijkMode === SlicingMode.I) {\n      sliceOffset = nSlice - ext[0];\n    }\n    if (ijkMode === SlicingMode.J) {\n      sliceOffset = nSlice - ext[2];\n    }\n    if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {\n      sliceOffset = nSlice - ext[4];\n    }\n\n    // rebuild the VBO if the data has changed\n    const toString = `${slice}A${image.getMTime()}A${imgScalars.getMTime()}B${publicAPI.getMTime()}C${model.renderable.getSlicingMode()}D${actor.getProperty().getInterpolationType()}`;\n    if (model.VBOBuildString !== toString) {\n      // Build the VBOs\n      const dims = image.getDimensions();\n      if (!model.openGLTexture) {\n        model.openGLTexture = vtkOpenGLTexture.newInstance({\n          resizable: true\n        });\n        model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n      if (iType === InterpolationType.NEAREST) {\n        if (new Set([1, 3, 4]).has(numComp) && dataType === VtkDataTypes.UNSIGNED_CHAR && !iComps) {\n          model.openGLTexture.setGenerateMipmap(true);\n          model.openGLTexture.setMinificationFilter(Filter.NEAREST);\n        } else {\n          model.openGLTexture.setMinificationFilter(Filter.NEAREST);\n        }\n        model.openGLTexture.setMagnificationFilter(Filter.NEAREST);\n      } else {\n        if (numComp === 4 && dataType === VtkDataTypes.UNSIGNED_CHAR && !iComps) {\n          model.openGLTexture.setGenerateMipmap(true);\n          model.openGLTexture.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        } else {\n          model.openGLTexture.setMinificationFilter(Filter.LINEAR);\n        }\n        model.openGLTexture.setMagnificationFilter(Filter.LINEAR);\n      }\n      model.openGLTexture.setWrapS(Wrap.CLAMP_TO_EDGE);\n      model.openGLTexture.setWrapT(Wrap.CLAMP_TO_EDGE);\n      const sliceSize = dims[0] * dims[1] * numComp;\n      const ptsArray = new Float32Array(12);\n      const tcoordArray = new Float32Array(8);\n      for (let i = 0; i < 4; i++) {\n        tcoordArray[i * 2] = i % 2 ? 1.0 : 0.0;\n        tcoordArray[i * 2 + 1] = i > 1 ? 1.0 : 0.0;\n      }\n\n      // Determine depth position of the slicing plane in the scene.\n      // Slicing modes X, Y, and Z use a continuous axis position, whereas\n      // slicing modes I, J, and K should use discrete positions.\n      const sliceDepth = [SlicingMode.X, SlicingMode.Y, SlicingMode.Z].includes(model.renderable.getSlicingMode()) ? slice : nSlice;\n      const spatialExt = image.getSpatialExtent();\n      const basicScalars = imgScalars.getData();\n      let scalars = null;\n      // Get right scalars according to slicing mode\n      if (ijkMode === SlicingMode.I) {\n        scalars = new basicScalars.constructor(dims[2] * dims[1] * numComp);\n        let id = 0;\n        for (let k = 0; k < dims[2]; k++) {\n          for (let j = 0; j < dims[1]; j++) {\n            let bsIdx = (sliceOffset + j * dims[0] + k * dims[0] * dims[1]) * numComp;\n            id = (k * dims[1] + j) * numComp;\n            const end = bsIdx + numComp;\n            while (bsIdx < end) {\n              scalars[id++] = basicScalars[bsIdx++];\n            }\n          }\n        }\n        dims[0] = dims[1];\n        dims[1] = dims[2];\n        ptsArray[0] = sliceDepth;\n        ptsArray[1] = spatialExt[2];\n        ptsArray[2] = spatialExt[4];\n        ptsArray[3] = sliceDepth;\n        ptsArray[4] = spatialExt[3];\n        ptsArray[5] = spatialExt[4];\n        ptsArray[6] = sliceDepth;\n        ptsArray[7] = spatialExt[2];\n        ptsArray[8] = spatialExt[5];\n        ptsArray[9] = sliceDepth;\n        ptsArray[10] = spatialExt[3];\n        ptsArray[11] = spatialExt[5];\n      } else if (ijkMode === SlicingMode.J) {\n        scalars = new basicScalars.constructor(dims[2] * dims[0] * numComp);\n        let id = 0;\n        for (let k = 0; k < dims[2]; k++) {\n          for (let i = 0; i < dims[0]; i++) {\n            let bsIdx = (i + sliceOffset * dims[0] + k * dims[0] * dims[1]) * numComp;\n            id = (k * dims[0] + i) * numComp;\n            const end = bsIdx + numComp;\n            while (bsIdx < end) {\n              scalars[id++] = basicScalars[bsIdx++];\n            }\n          }\n        }\n        dims[1] = dims[2];\n        ptsArray[0] = spatialExt[0];\n        ptsArray[1] = sliceDepth;\n        ptsArray[2] = spatialExt[4];\n        ptsArray[3] = spatialExt[1];\n        ptsArray[4] = sliceDepth;\n        ptsArray[5] = spatialExt[4];\n        ptsArray[6] = spatialExt[0];\n        ptsArray[7] = sliceDepth;\n        ptsArray[8] = spatialExt[5];\n        ptsArray[9] = spatialExt[1];\n        ptsArray[10] = sliceDepth;\n        ptsArray[11] = spatialExt[5];\n      } else if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {\n        scalars = basicScalars.subarray(sliceOffset * sliceSize, (sliceOffset + 1) * sliceSize);\n        ptsArray[0] = spatialExt[0];\n        ptsArray[1] = spatialExt[2];\n        ptsArray[2] = sliceDepth;\n        ptsArray[3] = spatialExt[1];\n        ptsArray[4] = spatialExt[2];\n        ptsArray[5] = sliceDepth;\n        ptsArray[6] = spatialExt[0];\n        ptsArray[7] = spatialExt[3];\n        ptsArray[8] = sliceDepth;\n        ptsArray[9] = spatialExt[1];\n        ptsArray[10] = spatialExt[3];\n        ptsArray[11] = sliceDepth;\n      } else {\n        vtkErrorMacro('Reformat slicing not yet supported.');\n      }\n      const tex = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);\n      if (!tex?.vtkObj) {\n        if (model._scalars !== scalars) {\n          model._openGLRenderWindow.releaseGraphicsResourcesForObject(model._scalars);\n          model._scalars = scalars;\n        }\n        model.openGLTexture.resetFormatAndType();\n        model.openGLTexture.create2DFilterableFromRaw(dims[0], dims[1], numComp, imgScalars.getDataType(), scalars, model.renderable.getPreferSizeOverAccuracy?.());\n        model._openGLRenderWindow.setGraphicsResourceForObject(scalars, model.openGLTexture, model.VBOBuildString);\n      } else {\n        model.openGLTexture = tex.vtkObj;\n        model.VBOBuildString = tex.hash;\n      }\n      model.openGLTexture.activate();\n      model.openGLTexture.sendParameters();\n      model.openGLTexture.deactivate();\n      const points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: ptsArray\n      });\n      points.setName('points');\n      const tcoords = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        values: tcoordArray\n      });\n      tcoords.setName('tcoords');\n      const cellArray = new Uint16Array(8);\n      cellArray[0] = 3;\n      cellArray[1] = 0;\n      cellArray[2] = 1;\n      cellArray[3] = 3;\n      cellArray[4] = 3;\n      cellArray[5] = 0;\n      cellArray[6] = 3;\n      cellArray[7] = 2;\n      const cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: cellArray\n      });\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n        points,\n        tcoords,\n        cellOffset: 0\n      });\n      model.VBOBuildTime.modified();\n      model.VBOBuildString = toString;\n    }\n  };\n  publicAPI.updatelabelOutlineThicknessTexture = image => {\n    if (!model.labelOutlineThicknessTexture) {\n      model.labelOutlineThicknessTexture = vtkOpenGLTexture.newInstance({\n        resizable: false\n      });\n      model.labelOutlineThicknessTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n    }\n    const labelOutlineThicknessArray = image.getProperty().getLabelOutlineThickness();\n    const lTex = model._openGLRenderWindow.getGraphicsResourceForObject(labelOutlineThicknessArray);\n\n    // compute the join of the labelOutlineThicknessArray so that\n    // we can use it to decide whether to rebuild the labelOutlineThicknessTexture\n    // or not\n    const toString = `${labelOutlineThicknessArray.join('-')}`;\n    const reBuildL = !lTex?.vtkObj || lTex?.hash !== toString || model.labelOutlineThicknessTextureString !== toString;\n    if (reBuildL) {\n      const lWidth = 1024;\n      const lHeight = 1;\n      const lSize = lWidth * lHeight;\n      const lTable = new Uint8Array(lSize);\n\n      // Assuming labelOutlineThicknessArray contains the thickness for each segment\n      for (let i = 0; i < lWidth; ++i) {\n        // Retrieve the thickness value for the current segment index.\n        // If the value is undefined, null, or 0, use the first element's value as a default.\n        const thickness = labelOutlineThicknessArray[i] || labelOutlineThicknessArray[0];\n        lTable[i] = thickness;\n      }\n      model.labelOutlineThicknessTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.labelOutlineThicknessTexture.resetFormatAndType();\n      model.labelOutlineThicknessTexture.setMinificationFilter(Filter.NEAREST);\n      model.labelOutlineThicknessTexture.setMagnificationFilter(Filter.NEAREST);\n\n      // Create a 2D texture (acting as 1D) from the raw data\n      model.labelOutlineThicknessTexture.create2DFromRaw(lWidth, lHeight, 1, VtkDataTypes.UNSIGNED_CHAR, lTable);\n      model.labelOutlineThicknessTextureString = toString;\n      if (labelOutlineThicknessArray) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(labelOutlineThicknessArray, model.labelOutlineThicknessTexture, model.labelOutlineThicknessTextureString);\n      }\n    } else {\n      model.labelOutlineThicknessTexture = lTex.vtkObj;\n      model.labelOutlineThicknessTextureString = lTex.hash;\n    }\n  };\n  publicAPI.getRenderTargetSize = () => {\n    if (model._useSmallViewport) {\n      return [model._smallViewportWidth, model._smallViewportHeight];\n    }\n    const {\n      usize,\n      vsize\n    } = model._openGLRenderer.getTiledSizeAndOrigin();\n    return [usize, vsize];\n  };\n  publicAPI.getRenderTargetOffset = () => {\n    const {\n      lowerLeftU,\n      lowerLeftV\n    } = model._openGLRenderer.getTiledSizeAndOrigin();\n    return [lowerLeftU, lowerLeftV];\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  VBOBuildTime: 0,\n  VBOBuildString: null,\n  openGLTexture: null,\n  tris: null,\n  imagemat: null,\n  imagematinv: null,\n  colorTexture: null,\n  pwfTexture: null,\n  labelOutlineThicknessTexture: null,\n  labelOutlineThicknessTextureString: null,\n  lastHaveSeenDepthRequest: false,\n  haveSeenDepthRequest: false,\n  lastTextureComponents: 0,\n  _scalars: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);\n  model.tris = vtkHelper.newInstance();\n  model.imagemat = mat4.identity(new Float64Array(16));\n  model.imagematinv = mat4.identity(new Float64Array(16));\n  model.projectionToWorld = mat4.identity(new Float64Array(16));\n  model.idxToView = mat4.identity(new Float64Array(16));\n  model.idxNormalMatrix = mat3.identity(new Float64Array(9));\n  model.modelToView = mat4.identity(new Float64Array(16));\n  model.projectionToView = mat4.identity(new Float64Array(16));\n\n  // Build VTK API\n  setGet(publicAPI, model, []);\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime);\n\n  // Object methods\n  vtkOpenGLImageMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLImageMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMapper = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkAbstractImageMapper', newInstance);\nexport { vtkImageMapper as default, extend, newInstance };","map":{"version":3,"names":["mat4","mat3","Constants","n","newInstance$1","e","setGet","o","obj","r","vtkErrorMacro$1","c","macro","vtkDataArray","VtkDataTypes","vtkHelper","u","uninitializeBounds","vtkOpenGLTexture","vtkShaderProgram","vtkViewNode","Representation","Filter","Wrap","InterpolationType","v","vtkPolyDataVS","vtkPolyDataFS","vtkReplacementShaderMapper","registerOverride","vtkErrorMacro","SlicingMode","computeFnToString","property","pwfun","numberOfComponents","iComps","getIndependentComponents","getMTime","splitStringOnEnter","inputString","lines","split","trimmedLines","i","length","trimmedLine","trim","push","vtkOpenGLImageMapper","publicAPI","model","classHierarchy","buildPass","prepass","currentRenderPass","openGLImageSlice","getFirstAncestorOfType","_openGLRenderer","_openGLRenderWindow","getParent","context","getContext","tris","setOpenGLRenderWindow","ren","getRenderable","openGLCamera","getViewNodeFor","getActiveCamera","renderable","isA","getSliceAtFocalPoint","setSliceFromCamera","translucentPass","renderPass","render","zBufferPass","haveSeenDepthRequest","renderDepth","opaqueZBufferPass","opaquePass","getCoincidentParameters","actor","getResolveCoincidentTopology","getCoincidentTopologyPolygonOffsetParameters","renderPiece","getShaderTemplate","shaders","Vertex","Fragment","Geometry","replaceShaderValues","VSSource","FSSource","substitute","result","tNumComp","openGLTexture","getComponents","getProperty","tcoordDec","comp","concat","vtkImageLabelOutline","getUseLabelOutline","rgba","tcoordImpl","replaceShaderClip","replaceShaderCoincidentOffset","getNumberOfClippingPlanes","numClipPlanes","getNeedToRebuildShaders","cellBO","iComp","needRebuild","lastRenderPassShaderReplacement","getShaderReplacement","lastHaveSeenDepthRequest","getProgram","getHandle","lastTextureComponents","lastIndependentComponents","updateShaders","lastBoundBO","buildShaders","newShader","getShaderCache","readyShaderProgramArray","setProgram","getVAO","releaseGraphicsResources","getShaderSourceTime","modified","readyShaderProgram","bind","setMapperShaderParameters","setCameraShaderParameters","setPropertyShaderParameters","getCABO","getElementCount","VBOBuildTime","getAttributeUpdateTime","isAttributeUsed","addAttributeArray","getVertexOffset","getStride","FLOAT","FALSE","getTCoordOffset","getTCoordComponents","texUnit","getTextureUnit","setUniformi","numComp","setUniformf","getComponentWeight","oglShiftScale","getShiftAndScale","cw","getColorWindow","cl","getColorLevel","target","cfun","getRGBTransferFunction","getUseLookupTableScalarRange","cRange","getRange","scale","shift","pwfScale","pwfShift","getPiecewiseFunction","pwfRange","mid","isUniformUsed","cp","offset","factor","texColorUnit","colorTexture","texOpacityUnit","pwfTexture","outlineThicknessUnit","labelOutlineThicknessTexture","shiftScaleEnabled","getCoordShiftAndScaleEnabled","inverseShiftScaleMatrix","getInverseShiftAndScaleMatrix","mat","copy","imagematinv","getMatrix","transpose","multiply","imagemat","currentInput","getIndexToWorld","planeEquations","planeEquation","getClippingPlaneInDataCoords","j","setUniform4fv","outlineOpacity","getLabelOutlineOpacity","program","actMats","getKeyMatrices","image","i2wmat4","mcwc","keyMats","wcpc","inverseShiftScaleMat","setUniformMatrix","worldToIndex","getWorldToIndex","imageDimensions","getDimensions","setUniform3i","labelOutlineKeyMats","invert","projectionToWorld","size","getRenderTargetSize","getRenderTargetOffset","ppty","opacity","getOpacity","renderPieceStart","updateBufferObjects","renderPieceDraw","gl","activate","drawArrays","TRIANGLES","release","deactivate","renderPieceFinish","invokeEvent","type","update","getCurrentImage","computeBounds","getInput","bounds","getBounds","getNeedToRebuildBufferObjects","buildBufferObjects","imgScalars","getPointData","getScalars","dataType","getDataType","getNumberOfComponents","actorProperty","iType","getInterpolationType","numIComps","textureHeight","colorTransferFunc","cfunToString","cTex","getGraphicsResourceForObject","reBuildC","vtkObj","hash","colorTextureString","cWidth","cSize","cTable","Uint8Array","newInstance","resizable","NEAREST","setMinificationFilter","setMagnificationFilter","LINEAR","tmpTable","Float32Array","getTable","resetFormatAndType","create2DFromRaw","UNSIGNED_CHAR","setGraphicsResourceForObject","pwFunc","pwfunToString","pwfTex","reBuildPwf","pwfTextureString","pwfWidth","pwfSize","pwfTable","pwfFloatTable","fill","updatelabelOutlineThicknessTexture","ijkMode","getClosestIJKAxis","slice","getSlice","getSlicingMode","getSliceAtPosition","nSlice","getSubSlice","Math","round","ext","getExtent","sliceOffset","I","J","K","NONE","toString","VBOBuildString","dims","Set","has","setGenerateMipmap","LINEAR_MIPMAP_LINEAR","setWrapS","CLAMP_TO_EDGE","setWrapT","sliceSize","ptsArray","tcoordArray","sliceDepth","X","Y","Z","includes","spatialExt","getSpatialExtent","basicScalars","getData","scalars","constructor","id","k","bsIdx","end","subarray","tex","_scalars","releaseGraphicsResourcesForObject","create2DFilterableFromRaw","getPreferSizeOverAccuracy","sendParameters","points","values","setName","tcoords","cellArray","Uint16Array","cells","createVBO","SURFACE","cellOffset","labelOutlineThicknessArray","getLabelOutlineThickness","lTex","join","reBuildL","labelOutlineThicknessTextureString","lWidth","lHeight","lSize","lTable","thickness","_useSmallViewport","_smallViewportWidth","_smallViewportHeight","usize","vsize","getTiledSizeAndOrigin","lowerLeftU","lowerLeftV","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","implementReplaceShaderCoincidentOffset","implementBuildShadersWithReplacements","identity","Float64Array","idxToView","idxNormalMatrix","modelToView","projectionToView","vtkImageMapper","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageMapper.js"],"sourcesContent":["import { mat4, mat3 } from 'gl-matrix';\nimport Constants from '../Core/ImageMapper/Constants.js';\nimport { n as newInstance$1, e as setGet, o as obj, r as vtkErrorMacro$1, c as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport vtkHelper from './Helper.js';\nimport { u as uninitializeBounds } from '../../Common/Core/Math/index.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { Filter, Wrap } from './Texture/Constants.js';\nimport { InterpolationType } from '../Core/ImageProperty/Constants.js';\nimport { v as vtkPolyDataVS } from './glsl/vtkPolyDataVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport vtkReplacementShaderMapper from './ReplacementShaderMapper.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nconst {\n  SlicingMode\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n\nfunction computeFnToString(property, pwfun, numberOfComponents) {\n  if (pwfun) {\n    const iComps = property.getIndependentComponents();\n    return `${pwfun.getMTime()}-${iComps}-${numberOfComponents}`;\n  }\n  return '0';\n}\nfunction splitStringOnEnter(inputString) {\n  // Split the input string into an array of lines based on \"Enter\" (newline) characters\n  // Remove any leading or trailing whitespace from each line and filter out empty lines\n  const lines = inputString.split('\\n');\n  const trimmedLines = [];\n  for (let i = 0; i < lines.length; ++i) {\n    const trimmedLine = lines[i].trim();\n    if (trimmedLine.length > 0) {\n      trimmedLines.push(trimmedLine);\n    }\n  }\n  return trimmedLines;\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLImageMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLImageMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLImageMapper');\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model.openGLImageSlice = publicAPI.getFirstAncestorOfType('vtkOpenGLImageSlice');\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      const ren = model._openGLRenderer.getRenderable();\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());\n      // is slice set by the camera\n      if (model.renderable.isA('vtkImageMapper') && model.renderable.getSliceAtFocalPoint()) {\n        model.renderable.setSliceFromCamera(ren.getActiveCamera());\n      }\n    }\n  };\n  publicAPI.translucentPass = (prepass, renderPass) => {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n  publicAPI.zBufferPass = prepass => {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n  publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);\n  publicAPI.opaquePass = prepass => {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n  publicAPI.getCoincidentParameters = (ren, actor) => {\n    if (model.renderable.getResolveCoincidentTopology()) {\n      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n    }\n    return null;\n  };\n\n  // Renders myself\n  publicAPI.render = () => {\n    const actor = model.openGLImageSlice.getRenderable();\n    const ren = model._openGLRenderer.getRenderable();\n    publicAPI.renderPiece(ren, actor);\n  };\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkPolyDataVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', 'tcoordVCVSOutput = tcoordMC;').result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;').result;\n    const tNumComp = model.openGLTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n    let tcoordDec = ['varying vec2 tcoordVCVSOutput;',\n    // color shift and scale\n    'uniform float cshift0;', 'uniform float cscale0;',\n    // pwf shift and scale\n    'uniform float pwfshift0;', 'uniform float pwfscale0;', 'uniform sampler2D texture1;', 'uniform sampler2D colorTexture1;', 'uniform sampler2D pwfTexture1;', 'uniform sampler2D labelOutlineTexture1;', 'uniform float opacity;', 'uniform float outlineOpacity;'];\n    if (iComps) {\n      for (let comp = 1; comp < tNumComp; comp++) {\n        tcoordDec = tcoordDec.concat([\n        // color shift and scale\n        `uniform float cshift${comp};`, `uniform float cscale${comp};`,\n        // weighting shift and scale\n        `uniform float pwfshift${comp};`, `uniform float pwfscale${comp};`]);\n      }\n      // the heights defined below are the locations\n      // for the up to four components of the tfuns\n      // the tfuns have a height of 2XnumComps pixels so the\n      // values are computed to hit the middle of the two rows\n      // for that component\n      switch (tNumComp) {\n        case 1:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', '#define height0 0.5']);\n          break;\n        case 2:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', '#define height0 0.25', '#define height1 0.75']);\n          break;\n        case 3:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', '#define height0 0.17', '#define height1 0.5', '#define height2 0.83']);\n          break;\n        case 4:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', 'uniform float mix3;', '#define height0 0.125', '#define height1 0.375', '#define height2 0.625', '#define height3 0.875']);\n          break;\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', tcoordDec).result;\n\n    // check for the outline thickness and opacity\n    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();\n    if (vtkImageLabelOutline === true) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::LabelOutline::Dec', ['uniform int outlineThickness;', 'uniform float vpWidth;', 'uniform float vpHeight;', 'uniform float vpOffsetX;', 'uniform float vpOffsetY;', 'uniform mat4 PCWCMatrix;', 'uniform mat4 vWCtoIDX;', 'uniform ivec3 imageDimensions;']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ImageLabelOutlineOn', '#define vtkImageLabelOutlineOn').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::LabelOutlineHelperFunction', ['#ifdef vtkImageLabelOutlineOn', 'vec3 fragCoordToIndexSpace(vec4 fragCoord) {', '  vec4 pcPos = vec4(', '    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,', '    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,', '    (fragCoord.z - 0.5) * 2.0,', '    1.0);', '', '  vec4 worldCoord = PCWCMatrix * pcPos;', '  vec4 vertex = (worldCoord/worldCoord.w);', '', '  vec3 index = (vWCtoIDX * vertex).xyz;', '', '  // half voxel fix for labelmapOutline', '  return (index + vec3(0.5)) / vec3(imageDimensions);', '}', '#endif']).result;\n    }\n    if (iComps) {\n      const rgba = ['r', 'g', 'b', 'a'];\n      let tcoordImpl = ['vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);'];\n      for (let comp = 0; comp < tNumComp; comp++) {\n        tcoordImpl = tcoordImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);\n      }\n      switch (tNumComp) {\n        case 1:\n          tcoordImpl = tcoordImpl.concat(['gl_FragData[0] = vec4(tcolor0.rgb, opacity);']);\n          break;\n        case 2:\n          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);']);\n          break;\n        case 3:\n          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);']);\n          break;\n        case 4:\n          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);']);\n          break;\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', tcoordImpl).result;\n    } else {\n      // dependent components\n      switch (tNumComp) {\n        case 1:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', [...splitStringOnEnter(`\n                #ifdef vtkImageLabelOutlineOn\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); \n                  float centerValue = texture2D(texture1, centerPosIS.xy).r;\n                  bool pixelOnBorder = false;\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\n                  float opacityToUse = scalarOpacity * opacity;\n                  int segmentIndex = int(centerValue * 255.0);\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\n                  int actualThickness = int(textureValue * 255.0);\n\n                  if (actualThickness == 0) {\n                    gl_FragData[0] = vec4(0.0, 0.0, 1.0, 1.0);\n                    return;\n                  }\n                  if (opacityToUse > 0.01) {\n                    for (int i = -actualThickness; i <= actualThickness; i++) {\n                      for (int j = -actualThickness; j <= actualThickness; j++) {\n                        if (i == 0 || j == 0) {\n                          continue;\n                        }\n                        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n                          gl_FragCoord.y + float(j),\n                          gl_FragCoord.z, gl_FragCoord.w);\n                        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n                        float value = texture2D(texture1, neighborPosIS.xy).r;\n                        if (value != centerValue) {\n                          pixelOnBorder = true;\n                          break;\n                        }\n                      }\n                      if (pixelOnBorder == true) {\n                        break;\n                      }\n                    }\n                    if (pixelOnBorder == true) {\n                      gl_FragData[0] = vec4(tColor, outlineOpacity);\n                    }\n                    else {\n                      gl_FragData[0] = vec4(tColor, opacityToUse);\n                    }\n                  }\n                #else\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\n                #endif\n                `)]).result;\n          break;\n        case 2:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', 'float intensity = tcolor.r*cscale0 + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);']).result;\n          break;\n        case 3:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);']).result;\n          break;\n        default:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);']).result;\n      }\n    }\n    if (model.haveSeenDepthRequest) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    publicAPI.replaceShaderClip(shaders, ren, actor);\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n  };\n  publicAPI.replaceShaderClip = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      if (numClipPlanes > 6) {\n        vtkErrorMacro$1('OpenGL has a limit of 6 clipping planes');\n        numClipPlanes = 6;\n      }\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'uniform vec4 clipPlanes[6];', 'varying float clipDistancesVSOutput[6];']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'varying float clipDistancesVSOutput[6];']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    // render pass shader replacement changed\n\n    const tNumComp = model.openGLTexture.getComponents();\n    const iComp = actor.getProperty().getIndependentComponents();\n\n    // has the render pass shader replacement changed? Two options\n    let needRebuild = false;\n    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {\n      needRebuild = true;\n    }\n    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram()?.getHandle() === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      model.lastTextureComponents = tNumComp;\n      model.lastIndependentComponents = iComp;\n      return true;\n    }\n    return false;\n  };\n  publicAPI.updateShaders = (cellBO, ren, actor) => {\n    model.lastBoundBO = cellBO;\n\n    // has something changed that would require us to recreate the shader?\n    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {\n      const shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      publicAPI.buildShaders(shaders, ren, actor);\n\n      // compile and bind the program if needed\n      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);\n\n      // if the shader changed reinitialize the VAO\n      if (newShader !== cellBO.getProgram()) {\n        cellBO.setProgram(newShader);\n        // reset the VAO as the shader has changed\n        cellBO.getVAO().releaseGraphicsResources();\n      }\n      cellBO.getShaderSourceTime().modified();\n    } else {\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());\n    }\n    cellBO.getVAO().bind();\n    publicAPI.setMapperShaderParameters(cellBO, ren, actor);\n    publicAPI.setCameraShaderParameters(cellBO, ren, actor);\n    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    // Now to update the VAO too, if necessary.\n\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexMC in shader VAO.');\n        }\n      }\n      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), model.context.FALSE)) {\n          vtkErrorMacro('Error setting tcoordMC in shader VAO.');\n        }\n      }\n      cellBO.getAttributeUpdateTime().modified();\n    }\n    const texUnit = model.openGLTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('texture1', texUnit);\n    const numComp = model.openGLTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n    if (iComps) {\n      for (let i = 0; i < numComp; i++) {\n        cellBO.getProgram().setUniformf(`mix${i}`, actor.getProperty().getComponentWeight(i));\n      }\n    }\n    const oglShiftScale = model.openGLTexture.getShiftAndScale();\n\n    // three levels of shift scale combined into one\n    // for performance in the fragment shader\n    for (let i = 0; i < numComp; i++) {\n      let cw = actor.getProperty().getColorWindow();\n      let cl = actor.getProperty().getColorLevel();\n      const target = iComps ? i : 0;\n      const cfun = actor.getProperty().getRGBTransferFunction(target);\n      if (cfun && actor.getProperty().getUseLookupTableScalarRange()) {\n        const cRange = cfun.getRange();\n        cw = cRange[1] - cRange[0];\n        cl = 0.5 * (cRange[1] + cRange[0]);\n      }\n      const scale = oglShiftScale.scale / cw;\n      const shift = (oglShiftScale.shift - cl) / cw + 0.5;\n      cellBO.getProgram().setUniformf(`cshift${i}`, shift);\n      cellBO.getProgram().setUniformf(`cscale${i}`, scale);\n    }\n\n    // pwf shift/scale\n    for (let i = 0; i < numComp; i++) {\n      let pwfScale = 1.0;\n      let pwfShift = 0.0;\n      const target = iComps ? i : 0;\n      const pwfun = actor.getProperty().getPiecewiseFunction(target);\n      if (pwfun) {\n        const pwfRange = pwfun.getRange();\n        const length = pwfRange[1] - pwfRange[0];\n        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);\n        pwfScale = oglShiftScale.scale / length;\n        pwfShift = (oglShiftScale.shift - mid) / length + 0.5;\n      }\n      cellBO.getProgram().setUniformf(`pwfshift${i}`, pwfShift);\n      cellBO.getProgram().setUniformf(`pwfscale${i}`, pwfScale);\n    }\n    if (model.haveSeenDepthRequest) {\n      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    }\n\n    // handle coincident\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      const cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset);\n      // cfactor isn't always used when coffset is.\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    }\n    const texColorUnit = model.colorTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('colorTexture1', texColorUnit);\n    const texOpacityUnit = model.pwfTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('pwfTexture1', texOpacityUnit);\n    const outlineThicknessUnit = model.labelOutlineThicknessTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('labelOutlineTexture1', outlineThicknessUnit);\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      // add all the clipping planes\n      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      if (numClipPlanes > 6) {\n        vtkErrorMacro$1('OpenGL has a limit of 6 clipping planes');\n        numClipPlanes = 6;\n      }\n      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n      const mat = inverseShiftScaleMatrix ? mat4.copy(model.imagematinv, actor.getMatrix()) : actor.getMatrix();\n      if (inverseShiftScaleMatrix) {\n        mat4.transpose(mat, mat);\n        mat4.multiply(mat, mat, inverseShiftScaleMatrix);\n        mat4.transpose(mat, mat);\n      }\n\n      // transform crop plane normal with transpose(inverse(worldToIndex))\n      mat4.transpose(model.imagemat, model.currentInput.getIndexToWorld());\n      mat4.multiply(model.imagematinv, mat, model.imagemat);\n      const planeEquations = [];\n      for (let i = 0; i < numClipPlanes; i++) {\n        const planeEquation = [];\n        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, i, planeEquation);\n        for (let j = 0; j < 4; j++) {\n          planeEquations.push(planeEquation[j]);\n        }\n      }\n      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);\n      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);\n    }\n\n    // outline thickness and opacity\n    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();\n    if (vtkImageLabelOutline === true) {\n      const outlineOpacity = actor.getProperty().getLabelOutlineOpacity();\n      cellBO.getProgram().setUniformf('outlineOpacity', outlineOpacity);\n    }\n  };\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    const actMats = model.openGLImageSlice.getKeyMatrices();\n    const image = model.currentInput;\n    const i2wmat4 = image.getIndexToWorld();\n    mat4.multiply(model.imagemat, actMats.mcwc, i2wmat4);\n    const keyMats = model.openGLCamera.getKeyMatrices(ren);\n    mat4.multiply(model.imagemat, keyMats.wcpc, model.imagemat);\n    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {\n      const inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();\n      mat4.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);\n    }\n    program.setUniformMatrix('MCPCMatrix', model.imagemat);\n    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();\n    if (vtkImageLabelOutline === true) {\n      const worldToIndex = image.getWorldToIndex();\n      const imageDimensions = image.getDimensions();\n      program.setUniform3i('imageDimensions', imageDimensions[0], imageDimensions[1], 1);\n      program.setUniformMatrix('vWCtoIDX', worldToIndex);\n      const labelOutlineKeyMats = model.openGLCamera.getKeyMatrices(ren);\n\n      // Get the projection coordinate to world coordinate transformation matrix.\n      mat4.invert(model.projectionToWorld, labelOutlineKeyMats.wcpc);\n      model.openGLCamera.getKeyMatrices(ren);\n      program.setUniformMatrix('PCWCMatrix', model.projectionToWorld);\n      const size = publicAPI.getRenderTargetSize();\n      program.setUniformf('vpWidth', size[0]);\n      program.setUniformf('vpHeight', size[1]);\n      const offset = publicAPI.getRenderTargetOffset();\n      program.setUniformf('vpOffsetX', offset[0] / size[0]);\n      program.setUniformf('vpOffsetY', offset[1] / size[1]);\n    }\n  };\n  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    const ppty = actor.getProperty();\n    const opacity = ppty.getOpacity();\n    program.setUniformf('opacity', opacity);\n  };\n  publicAPI.renderPieceStart = (ren, actor) => {\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor);\n\n    // Bind the OpenGL, this is shared between the different primitive/cell types.\n    model.lastBoundBO = null;\n  };\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const gl = model.context;\n\n    // activate the texture\n    model.openGLTexture.activate();\n    model.colorTexture.activate();\n    model.labelOutlineThicknessTexture.activate();\n    model.pwfTexture.activate();\n\n    // draw polygons\n    if (model.tris.getCABO().getElementCount()) {\n      // First we do the triangles, update the shader, set uniforms, etc.\n      publicAPI.updateShaders(model.tris, ren, actor);\n      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n      model.tris.getVAO().release();\n    }\n    model.openGLTexture.deactivate();\n    model.colorTexture.deactivate();\n    model.labelOutlineThicknessTexture.deactivate();\n    model.pwfTexture.deactivate();\n  };\n  publicAPI.renderPieceFinish = (ren, actor) => {};\n  publicAPI.renderPiece = (ren, actor) => {\n    // Make sure that we have been properly initialized.\n    // if (ren.getRenderWindow().checkAbortStatus()) {\n    //   return;\n    // }\n\n    publicAPI.invokeEvent({\n      type: 'StartEvent'\n    });\n    model.renderable.update();\n    model.currentInput = model.renderable.getCurrentImage();\n    publicAPI.invokeEvent({\n      type: 'EndEvent'\n    });\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n  publicAPI.computeBounds = (ren, actor) => {\n    if (!publicAPI.getInput()) {\n      uninitializeBounds(model.bounds);\n      return;\n    }\n    model.bounds = publicAPI.getInput().getBounds();\n  };\n  publicAPI.updateBufferObjects = (ren, actor) => {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {\n    // first do a coarse check\n    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const image = model.currentInput;\n    if (!image) {\n      return;\n    }\n    const imgScalars = image.getPointData() && image.getPointData().getScalars();\n    if (!imgScalars) {\n      return;\n    }\n    const dataType = imgScalars.getDataType();\n    const numComp = imgScalars.getNumberOfComponents();\n    const actorProperty = actor.getProperty();\n    const iType = actorProperty.getInterpolationType();\n    const iComps = actorProperty.getIndependentComponents();\n    const numIComps = iComps ? numComp : 1;\n    const textureHeight = iComps ? 2 * numIComps : 1;\n    const colorTransferFunc = actorProperty.getRGBTransferFunction();\n    const cfunToString = computeFnToString(actorProperty, colorTransferFunc, numIComps);\n    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);\n    const reBuildC = !cTex?.vtkObj || cTex?.hash !== cfunToString || model.colorTextureString !== cfunToString;\n    if (reBuildC) {\n      const cWidth = 1024;\n      const cSize = cWidth * textureHeight * 3;\n      const cTable = new Uint8Array(cSize);\n      if (!model.colorTexture) {\n        model.colorTexture = vtkOpenGLTexture.newInstance({\n          resizable: true\n        });\n        model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n      // set interpolation on the texture based on property setting\n      if (iType === InterpolationType.NEAREST) {\n        model.colorTexture.setMinificationFilter(Filter.NEAREST);\n        model.colorTexture.setMagnificationFilter(Filter.NEAREST);\n      } else {\n        model.colorTexture.setMinificationFilter(Filter.LINEAR);\n        model.colorTexture.setMagnificationFilter(Filter.LINEAR);\n      }\n      if (colorTransferFunc) {\n        const tmpTable = new Float32Array(cWidth * 3);\n        for (let c = 0; c < numIComps; c++) {\n          const cfun = actorProperty.getRGBTransferFunction(c);\n          const cRange = cfun.getRange();\n          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);\n          if (iComps) {\n            for (let i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];\n            }\n          } else {\n            for (let i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n            }\n          }\n        }\n        model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);\n        model.colorTexture.resetFormatAndType();\n        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      } else {\n        for (let i = 0; i < cWidth * 3; ++i) {\n          cTable[i] = 255.0 * i / ((cWidth - 1) * 3);\n          cTable[i + 1] = 255.0 * i / ((cWidth - 1) * 3);\n          cTable[i + 2] = 255.0 * i / ((cWidth - 1) * 3);\n        }\n        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      }\n      model.colorTextureString = cfunToString;\n      if (colorTransferFunc) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, model.colorTextureString);\n      }\n    } else {\n      model.colorTexture = cTex.vtkObj;\n      model.colorTextureString = cTex.hash;\n    }\n\n    // Build piecewise function buffer.  This buffer is used either\n    // for component weighting or opacity, depending on whether we're\n    // rendering components independently or not.\n    const pwFunc = actorProperty.getPiecewiseFunction();\n    const pwfunToString = computeFnToString(actorProperty, pwFunc, numIComps);\n    const pwfTex = model._openGLRenderWindow.getGraphicsResourceForObject(pwFunc);\n    // rebuild opacity tfun?\n    const reBuildPwf = !pwfTex?.vtkObj || pwfTex?.hash !== pwfunToString || model.pwfTextureString !== pwfunToString;\n    if (reBuildPwf) {\n      const pwfWidth = 1024;\n      const pwfSize = pwfWidth * textureHeight;\n      const pwfTable = new Uint8Array(pwfSize);\n      if (!model.pwfTexture) {\n        model.pwfTexture = vtkOpenGLTexture.newInstance({\n          resizable: true\n        });\n        model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n      // set interpolation on the texture based on property setting\n      if (iType === InterpolationType.NEAREST) {\n        model.pwfTexture.setMinificationFilter(Filter.NEAREST);\n        model.pwfTexture.setMagnificationFilter(Filter.NEAREST);\n      } else {\n        model.pwfTexture.setMinificationFilter(Filter.LINEAR);\n        model.pwfTexture.setMagnificationFilter(Filter.LINEAR);\n      }\n      if (pwFunc) {\n        const pwfFloatTable = new Float32Array(pwfSize);\n        const tmpTable = new Float32Array(pwfWidth);\n        for (let c = 0; c < numIComps; ++c) {\n          const pwfun = actorProperty.getPiecewiseFunction(c);\n          if (pwfun === null) {\n            // Piecewise constant max if no function supplied for this component\n            pwfFloatTable.fill(1.0);\n          } else {\n            const pwfRange = pwfun.getRange();\n            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);\n            // adjust for sample distance etc\n            if (iComps) {\n              for (let i = 0; i < pwfWidth; i++) {\n                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];\n                pwfFloatTable[c * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];\n              }\n            } else {\n              for (let i = 0; i < pwfWidth; i++) {\n                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];\n              }\n            }\n          }\n        }\n        model.pwfTexture.releaseGraphicsResources(model._openGLRenderWindow);\n        model.pwfTexture.resetFormatAndType();\n        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);\n      } else {\n        // default is opaque\n        pwfTable.fill(255.0);\n        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);\n      }\n      model.pwfTextureString = pwfunToString;\n      if (pwFunc) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(pwFunc, model.pwfTexture, model.pwfTextureString);\n      }\n    } else {\n      model.pwfTexture = pwfTex.vtkObj;\n      model.pwfTextureString = pwfTex.hash;\n    }\n\n    // Build outline thickness buffer\n    publicAPI.updatelabelOutlineThicknessTexture(actor);\n\n    // Find what IJK axis and what direction to slice along\n    const {\n      ijkMode\n    } = model.renderable.getClosestIJKAxis();\n\n    // Find the IJK slice\n    let slice = model.renderable.getSlice();\n    if (ijkMode !== model.renderable.getSlicingMode()) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      slice = model.renderable.getSliceAtPosition(slice);\n    }\n\n    // Use sub-Slice number/offset if mapper being used is vtkImageArrayMapper,\n    // since this mapper uses a collection of vtkImageData (and not just a single vtkImageData).\n    const nSlice = model.renderable.isA('vtkImageArrayMapper') ? model.renderable.getSubSlice() // get subSlice of the current (possibly multi-frame) image\n    : Math.round(slice);\n\n    // Find sliceOffset\n    const ext = image.getExtent();\n    let sliceOffset;\n    if (ijkMode === SlicingMode.I) {\n      sliceOffset = nSlice - ext[0];\n    }\n    if (ijkMode === SlicingMode.J) {\n      sliceOffset = nSlice - ext[2];\n    }\n    if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {\n      sliceOffset = nSlice - ext[4];\n    }\n\n    // rebuild the VBO if the data has changed\n    const toString = `${slice}A${image.getMTime()}A${imgScalars.getMTime()}B${publicAPI.getMTime()}C${model.renderable.getSlicingMode()}D${actor.getProperty().getInterpolationType()}`;\n    if (model.VBOBuildString !== toString) {\n      // Build the VBOs\n      const dims = image.getDimensions();\n      if (!model.openGLTexture) {\n        model.openGLTexture = vtkOpenGLTexture.newInstance({\n          resizable: true\n        });\n        model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n      if (iType === InterpolationType.NEAREST) {\n        if (new Set([1, 3, 4]).has(numComp) && dataType === VtkDataTypes.UNSIGNED_CHAR && !iComps) {\n          model.openGLTexture.setGenerateMipmap(true);\n          model.openGLTexture.setMinificationFilter(Filter.NEAREST);\n        } else {\n          model.openGLTexture.setMinificationFilter(Filter.NEAREST);\n        }\n        model.openGLTexture.setMagnificationFilter(Filter.NEAREST);\n      } else {\n        if (numComp === 4 && dataType === VtkDataTypes.UNSIGNED_CHAR && !iComps) {\n          model.openGLTexture.setGenerateMipmap(true);\n          model.openGLTexture.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        } else {\n          model.openGLTexture.setMinificationFilter(Filter.LINEAR);\n        }\n        model.openGLTexture.setMagnificationFilter(Filter.LINEAR);\n      }\n      model.openGLTexture.setWrapS(Wrap.CLAMP_TO_EDGE);\n      model.openGLTexture.setWrapT(Wrap.CLAMP_TO_EDGE);\n      const sliceSize = dims[0] * dims[1] * numComp;\n      const ptsArray = new Float32Array(12);\n      const tcoordArray = new Float32Array(8);\n      for (let i = 0; i < 4; i++) {\n        tcoordArray[i * 2] = i % 2 ? 1.0 : 0.0;\n        tcoordArray[i * 2 + 1] = i > 1 ? 1.0 : 0.0;\n      }\n\n      // Determine depth position of the slicing plane in the scene.\n      // Slicing modes X, Y, and Z use a continuous axis position, whereas\n      // slicing modes I, J, and K should use discrete positions.\n      const sliceDepth = [SlicingMode.X, SlicingMode.Y, SlicingMode.Z].includes(model.renderable.getSlicingMode()) ? slice : nSlice;\n      const spatialExt = image.getSpatialExtent();\n      const basicScalars = imgScalars.getData();\n      let scalars = null;\n      // Get right scalars according to slicing mode\n      if (ijkMode === SlicingMode.I) {\n        scalars = new basicScalars.constructor(dims[2] * dims[1] * numComp);\n        let id = 0;\n        for (let k = 0; k < dims[2]; k++) {\n          for (let j = 0; j < dims[1]; j++) {\n            let bsIdx = (sliceOffset + j * dims[0] + k * dims[0] * dims[1]) * numComp;\n            id = (k * dims[1] + j) * numComp;\n            const end = bsIdx + numComp;\n            while (bsIdx < end) {\n              scalars[id++] = basicScalars[bsIdx++];\n            }\n          }\n        }\n        dims[0] = dims[1];\n        dims[1] = dims[2];\n        ptsArray[0] = sliceDepth;\n        ptsArray[1] = spatialExt[2];\n        ptsArray[2] = spatialExt[4];\n        ptsArray[3] = sliceDepth;\n        ptsArray[4] = spatialExt[3];\n        ptsArray[5] = spatialExt[4];\n        ptsArray[6] = sliceDepth;\n        ptsArray[7] = spatialExt[2];\n        ptsArray[8] = spatialExt[5];\n        ptsArray[9] = sliceDepth;\n        ptsArray[10] = spatialExt[3];\n        ptsArray[11] = spatialExt[5];\n      } else if (ijkMode === SlicingMode.J) {\n        scalars = new basicScalars.constructor(dims[2] * dims[0] * numComp);\n        let id = 0;\n        for (let k = 0; k < dims[2]; k++) {\n          for (let i = 0; i < dims[0]; i++) {\n            let bsIdx = (i + sliceOffset * dims[0] + k * dims[0] * dims[1]) * numComp;\n            id = (k * dims[0] + i) * numComp;\n            const end = bsIdx + numComp;\n            while (bsIdx < end) {\n              scalars[id++] = basicScalars[bsIdx++];\n            }\n          }\n        }\n        dims[1] = dims[2];\n        ptsArray[0] = spatialExt[0];\n        ptsArray[1] = sliceDepth;\n        ptsArray[2] = spatialExt[4];\n        ptsArray[3] = spatialExt[1];\n        ptsArray[4] = sliceDepth;\n        ptsArray[5] = spatialExt[4];\n        ptsArray[6] = spatialExt[0];\n        ptsArray[7] = sliceDepth;\n        ptsArray[8] = spatialExt[5];\n        ptsArray[9] = spatialExt[1];\n        ptsArray[10] = sliceDepth;\n        ptsArray[11] = spatialExt[5];\n      } else if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {\n        scalars = basicScalars.subarray(sliceOffset * sliceSize, (sliceOffset + 1) * sliceSize);\n        ptsArray[0] = spatialExt[0];\n        ptsArray[1] = spatialExt[2];\n        ptsArray[2] = sliceDepth;\n        ptsArray[3] = spatialExt[1];\n        ptsArray[4] = spatialExt[2];\n        ptsArray[5] = sliceDepth;\n        ptsArray[6] = spatialExt[0];\n        ptsArray[7] = spatialExt[3];\n        ptsArray[8] = sliceDepth;\n        ptsArray[9] = spatialExt[1];\n        ptsArray[10] = spatialExt[3];\n        ptsArray[11] = sliceDepth;\n      } else {\n        vtkErrorMacro('Reformat slicing not yet supported.');\n      }\n      const tex = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);\n      if (!tex?.vtkObj) {\n        if (model._scalars !== scalars) {\n          model._openGLRenderWindow.releaseGraphicsResourcesForObject(model._scalars);\n          model._scalars = scalars;\n        }\n        model.openGLTexture.resetFormatAndType();\n        model.openGLTexture.create2DFilterableFromRaw(dims[0], dims[1], numComp, imgScalars.getDataType(), scalars, model.renderable.getPreferSizeOverAccuracy?.());\n        model._openGLRenderWindow.setGraphicsResourceForObject(scalars, model.openGLTexture, model.VBOBuildString);\n      } else {\n        model.openGLTexture = tex.vtkObj;\n        model.VBOBuildString = tex.hash;\n      }\n      model.openGLTexture.activate();\n      model.openGLTexture.sendParameters();\n      model.openGLTexture.deactivate();\n      const points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: ptsArray\n      });\n      points.setName('points');\n      const tcoords = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        values: tcoordArray\n      });\n      tcoords.setName('tcoords');\n      const cellArray = new Uint16Array(8);\n      cellArray[0] = 3;\n      cellArray[1] = 0;\n      cellArray[2] = 1;\n      cellArray[3] = 3;\n      cellArray[4] = 3;\n      cellArray[5] = 0;\n      cellArray[6] = 3;\n      cellArray[7] = 2;\n      const cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: cellArray\n      });\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n        points,\n        tcoords,\n        cellOffset: 0\n      });\n      model.VBOBuildTime.modified();\n      model.VBOBuildString = toString;\n    }\n  };\n  publicAPI.updatelabelOutlineThicknessTexture = image => {\n    if (!model.labelOutlineThicknessTexture) {\n      model.labelOutlineThicknessTexture = vtkOpenGLTexture.newInstance({\n        resizable: false\n      });\n      model.labelOutlineThicknessTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n    }\n    const labelOutlineThicknessArray = image.getProperty().getLabelOutlineThickness();\n    const lTex = model._openGLRenderWindow.getGraphicsResourceForObject(labelOutlineThicknessArray);\n\n    // compute the join of the labelOutlineThicknessArray so that\n    // we can use it to decide whether to rebuild the labelOutlineThicknessTexture\n    // or not\n    const toString = `${labelOutlineThicknessArray.join('-')}`;\n    const reBuildL = !lTex?.vtkObj || lTex?.hash !== toString || model.labelOutlineThicknessTextureString !== toString;\n    if (reBuildL) {\n      const lWidth = 1024;\n      const lHeight = 1;\n      const lSize = lWidth * lHeight;\n      const lTable = new Uint8Array(lSize);\n\n      // Assuming labelOutlineThicknessArray contains the thickness for each segment\n      for (let i = 0; i < lWidth; ++i) {\n        // Retrieve the thickness value for the current segment index.\n        // If the value is undefined, null, or 0, use the first element's value as a default.\n        const thickness = labelOutlineThicknessArray[i] || labelOutlineThicknessArray[0];\n        lTable[i] = thickness;\n      }\n      model.labelOutlineThicknessTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.labelOutlineThicknessTexture.resetFormatAndType();\n      model.labelOutlineThicknessTexture.setMinificationFilter(Filter.NEAREST);\n      model.labelOutlineThicknessTexture.setMagnificationFilter(Filter.NEAREST);\n\n      // Create a 2D texture (acting as 1D) from the raw data\n      model.labelOutlineThicknessTexture.create2DFromRaw(lWidth, lHeight, 1, VtkDataTypes.UNSIGNED_CHAR, lTable);\n      model.labelOutlineThicknessTextureString = toString;\n      if (labelOutlineThicknessArray) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(labelOutlineThicknessArray, model.labelOutlineThicknessTexture, model.labelOutlineThicknessTextureString);\n      }\n    } else {\n      model.labelOutlineThicknessTexture = lTex.vtkObj;\n      model.labelOutlineThicknessTextureString = lTex.hash;\n    }\n  };\n  publicAPI.getRenderTargetSize = () => {\n    if (model._useSmallViewport) {\n      return [model._smallViewportWidth, model._smallViewportHeight];\n    }\n    const {\n      usize,\n      vsize\n    } = model._openGLRenderer.getTiledSizeAndOrigin();\n    return [usize, vsize];\n  };\n  publicAPI.getRenderTargetOffset = () => {\n    const {\n      lowerLeftU,\n      lowerLeftV\n    } = model._openGLRenderer.getTiledSizeAndOrigin();\n    return [lowerLeftU, lowerLeftV];\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  VBOBuildTime: 0,\n  VBOBuildString: null,\n  openGLTexture: null,\n  tris: null,\n  imagemat: null,\n  imagematinv: null,\n  colorTexture: null,\n  pwfTexture: null,\n  labelOutlineThicknessTexture: null,\n  labelOutlineThicknessTextureString: null,\n  lastHaveSeenDepthRequest: false,\n  haveSeenDepthRequest: false,\n  lastTextureComponents: 0,\n  _scalars: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);\n  model.tris = vtkHelper.newInstance();\n  model.imagemat = mat4.identity(new Float64Array(16));\n  model.imagematinv = mat4.identity(new Float64Array(16));\n  model.projectionToWorld = mat4.identity(new Float64Array(16));\n  model.idxToView = mat4.identity(new Float64Array(16));\n  model.idxNormalMatrix = mat3.identity(new Float64Array(9));\n  model.modelToView = mat4.identity(new Float64Array(16));\n  model.projectionToView = mat4.identity(new Float64Array(16));\n\n  // Build VTK API\n  setGet(publicAPI, model, []);\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime);\n\n  // Object methods\n  vtkOpenGLImageMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLImageMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMapper = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkAbstractImageMapper', newInstance);\n\nexport { vtkImageMapper as default, extend, newInstance };\n"],"mappings":";;;;AAAA,SAASA,IAAI,EAAEC,IAAI,QAAQ,WAAW;AACtC,OAAOC,SAAS,MAAM,kCAAkC;AACxD,SAASC,CAAC,IAAIC,aAAa,EAAEC,CAAC,IAAIC,MAAM,EAAEC,CAAC,IAAIC,GAAG,EAAEC,CAAC,IAAIC,eAAe,EAAEC,CAAC,IAAIC,KAAK,QAAQ,kBAAkB;AAC9G,OAAOC,YAAY,MAAM,gCAAgC;AACzD,SAASC,YAAY,QAAQ,0CAA0C;AACvE,OAAOC,SAAS,MAAM,aAAa;AACnC,SAASC,CAAC,IAAIC,kBAAkB,QAAQ,iCAAiC;AACzE,OAAOC,gBAAgB,MAAM,cAAc;AAC3C,OAAOC,gBAAgB,MAAM,oBAAoB;AACjD,OAAOC,WAAW,MAAM,2BAA2B;AACnD,SAASC,cAAc,QAAQ,+BAA+B;AAC9D,SAASC,MAAM,EAAEC,IAAI,QAAQ,wBAAwB;AACrD,SAASC,iBAAiB,QAAQ,oCAAoC;AACtE,SAASC,CAAC,IAAIC,aAAa,QAAQ,8BAA8B;AACjE,SAASD,CAAC,IAAIE,aAAa,QAAQ,8BAA8B;AACjE,OAAOC,0BAA0B,MAAM,8BAA8B;AACrE,SAASC,gBAAgB,QAAQ,sBAAsB;AAEvD,MAAM;EACJC;AACF,CAAC,GAAGlB,KAAK;AACT,MAAM;EACJmB;AACF,CAAC,GAAG7B,SAAS;;AAEb;AACA;AACA;;AAEA,SAAS8B,iBAAiBA,CAACC,QAAQ,EAAEC,KAAK,EAAEC,kBAAkB,EAAE;EAC9D,IAAID,KAAK,EAAE;IACT,MAAME,MAAM,GAAGH,QAAQ,CAACI,wBAAwB,CAAC,CAAC;IAClD,OAAQ,GAAEH,KAAK,CAACI,QAAQ,CAAC,CAAE,IAAGF,MAAO,IAAGD,kBAAmB,EAAC;EAC9D;EACA,OAAO,GAAG;AACZ;AACA,SAASI,kBAAkBA,CAACC,WAAW,EAAE;EACvC;EACA;EACA,MAAMC,KAAK,GAAGD,WAAW,CAACE,KAAK,CAAC,IAAI,CAAC;EACrC,MAAMC,YAAY,GAAG,EAAE;EACvB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAACI,MAAM,EAAE,EAAED,CAAC,EAAE;IACrC,MAAME,WAAW,GAAGL,KAAK,CAACG,CAAC,CAAC,CAACG,IAAI,CAAC,CAAC;IACnC,IAAID,WAAW,CAACD,MAAM,GAAG,CAAC,EAAE;MAC1BF,YAAY,CAACK,IAAI,CAACF,WAAW,CAAC;IAChC;EACF;EACA,OAAOH,YAAY;AACrB;;AAEA;AACA;AACA;;AAEA,SAASM,oBAAoBA,CAACC,SAAS,EAAEC,KAAK,EAAE;EAC9C;EACAA,KAAK,CAACC,cAAc,CAACJ,IAAI,CAAC,sBAAsB,CAAC;EACjDE,SAAS,CAACG,SAAS,GAAGC,OAAO,IAAI;IAC/B,IAAIA,OAAO,EAAE;MACXH,KAAK,CAACI,iBAAiB,GAAG,IAAI;MAC9BJ,KAAK,CAACK,gBAAgB,GAAGN,SAAS,CAACO,sBAAsB,CAAC,qBAAqB,CAAC;MAChFN,KAAK,CAACO,eAAe,GAAGR,SAAS,CAACO,sBAAsB,CAAC,mBAAmB,CAAC;MAC7EN,KAAK,CAACQ,mBAAmB,GAAGR,KAAK,CAACO,eAAe,CAACE,SAAS,CAAC,CAAC;MAC7DT,KAAK,CAACU,OAAO,GAAGV,KAAK,CAACQ,mBAAmB,CAACG,UAAU,CAAC,CAAC;MACtDX,KAAK,CAACY,IAAI,CAACC,qBAAqB,CAACb,KAAK,CAACQ,mBAAmB,CAAC;MAC3D,MAAMM,GAAG,GAAGd,KAAK,CAACO,eAAe,CAACQ,aAAa,CAAC,CAAC;MACjDf,KAAK,CAACgB,YAAY,GAAGhB,KAAK,CAACO,eAAe,CAACU,cAAc,CAACH,GAAG,CAACI,eAAe,CAAC,CAAC,CAAC;MAChF;MACA,IAAIlB,KAAK,CAACmB,UAAU,CAACC,GAAG,CAAC,gBAAgB,CAAC,IAAIpB,KAAK,CAACmB,UAAU,CAACE,oBAAoB,CAAC,CAAC,EAAE;QACrFrB,KAAK,CAACmB,UAAU,CAACG,kBAAkB,CAACR,GAAG,CAACI,eAAe,CAAC,CAAC,CAAC;MAC5D;IACF;EACF,CAAC;EACDnB,SAAS,CAACwB,eAAe,GAAG,CAACpB,OAAO,EAAEqB,UAAU,KAAK;IACnD,IAAIrB,OAAO,EAAE;MACXH,KAAK,CAACI,iBAAiB,GAAGoB,UAAU;MACpCzB,SAAS,CAAC0B,MAAM,CAAC,CAAC;IACpB;EACF,CAAC;EACD1B,SAAS,CAAC2B,WAAW,GAAGvB,OAAO,IAAI;IACjC,IAAIA,OAAO,EAAE;MACXH,KAAK,CAAC2B,oBAAoB,GAAG,IAAI;MACjC3B,KAAK,CAAC4B,WAAW,GAAG,IAAI;MACxB7B,SAAS,CAAC0B,MAAM,CAAC,CAAC;MAClBzB,KAAK,CAAC4B,WAAW,GAAG,KAAK;IAC3B;EACF,CAAC;EACD7B,SAAS,CAAC8B,iBAAiB,GAAG1B,OAAO,IAAIJ,SAAS,CAAC2B,WAAW,CAACvB,OAAO,CAAC;EACvEJ,SAAS,CAAC+B,UAAU,GAAG3B,OAAO,IAAI;IAChC,IAAIA,OAAO,EAAE;MACXJ,SAAS,CAAC0B,MAAM,CAAC,CAAC;IACpB;EACF,CAAC;EACD1B,SAAS,CAACgC,uBAAuB,GAAG,CAACjB,GAAG,EAAEkB,KAAK,KAAK;IAClD,IAAIhC,KAAK,CAACmB,UAAU,CAACc,4BAA4B,CAAC,CAAC,EAAE;MACnD,OAAOjC,KAAK,CAACmB,UAAU,CAACe,4CAA4C,CAAC,CAAC;IACxE;IACA,OAAO,IAAI;EACb,CAAC;;EAED;EACAnC,SAAS,CAAC0B,MAAM,GAAG,MAAM;IACvB,MAAMO,KAAK,GAAGhC,KAAK,CAACK,gBAAgB,CAACU,aAAa,CAAC,CAAC;IACpD,MAAMD,GAAG,GAAGd,KAAK,CAACO,eAAe,CAACQ,aAAa,CAAC,CAAC;IACjDhB,SAAS,CAACoC,WAAW,CAACrB,GAAG,EAAEkB,KAAK,CAAC;EACnC,CAAC;EACDjC,SAAS,CAACqC,iBAAiB,GAAG,CAACC,OAAO,EAAEvB,GAAG,EAAEkB,KAAK,KAAK;IACrDK,OAAO,CAACC,MAAM,GAAG/D,aAAa;IAC9B8D,OAAO,CAACE,QAAQ,GAAG/D,aAAa;IAChC6D,OAAO,CAACG,QAAQ,GAAG,EAAE;EACvB,CAAC;EACDzC,SAAS,CAAC0C,mBAAmB,GAAG,CAACJ,OAAO,EAAEvB,GAAG,EAAEkB,KAAK,KAAK;IACvD,IAAIU,QAAQ,GAAGL,OAAO,CAACC,MAAM;IAC7B,IAAIK,QAAQ,GAAGN,OAAO,CAACE,QAAQ;IAC/BG,QAAQ,GAAG1E,gBAAgB,CAAC4E,UAAU,CAACF,QAAQ,EAAE,oBAAoB,EAAE,CAAC,0BAA0B,CAAC,CAAC,CAACG,MAAM;IAC3GH,QAAQ,GAAG1E,gBAAgB,CAAC4E,UAAU,CAACF,QAAQ,EAAE,yBAAyB,EAAE,CAAC,wCAAwC,CAAC,CAAC,CAACG,MAAM;IAC9HH,QAAQ,GAAG1E,gBAAgB,CAAC4E,UAAU,CAACF,QAAQ,EAAE,qBAAqB,EAAE,8BAA8B,CAAC,CAACG,MAAM;IAC9GH,QAAQ,GAAG1E,gBAAgB,CAAC4E,UAAU,CAACF,QAAQ,EAAE,oBAAoB,EAAE,yDAAyD,CAAC,CAACG,MAAM;IACxI,MAAMC,QAAQ,GAAG9C,KAAK,CAAC+C,aAAa,CAACC,aAAa,CAAC,CAAC;IACpD,MAAM/D,MAAM,GAAG+C,KAAK,CAACiB,WAAW,CAAC,CAAC,CAAC/D,wBAAwB,CAAC,CAAC;IAC7D,IAAIgE,SAAS,GAAG,CAAC,gCAAgC;IACjD;IACA,wBAAwB,EAAE,wBAAwB;IAClD;IACA,0BAA0B,EAAE,0BAA0B,EAAE,6BAA6B,EAAE,kCAAkC,EAAE,gCAAgC,EAAE,yCAAyC,EAAE,wBAAwB,EAAE,+BAA+B,CAAC;IAClQ,IAAIjE,MAAM,EAAE;MACV,KAAK,IAAIkE,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGL,QAAQ,EAAEK,IAAI,EAAE,EAAE;QAC1CD,SAAS,GAAGA,SAAS,CAACE,MAAM,CAAC;QAC7B;QACC,uBAAsBD,IAAK,GAAE,EAAG,uBAAsBA,IAAK,GAAE;QAC9D;QACC,yBAAwBA,IAAK,GAAE,EAAG,yBAAwBA,IAAK,GAAE,CAAC,CAAC;MACtE;MACA;MACA;MACA;MACA;MACA;MACA,QAAQL,QAAQ;QACd,KAAK,CAAC;UACJI,SAAS,GAAGA,SAAS,CAACE,MAAM,CAAC,CAAC,qBAAqB,EAAE,qBAAqB,CAAC,CAAC;UAC5E;QACF,KAAK,CAAC;UACJF,SAAS,GAAGA,SAAS,CAACE,MAAM,CAAC,CAAC,qBAAqB,EAAE,qBAAqB,EAAE,sBAAsB,EAAE,sBAAsB,CAAC,CAAC;UAC5H;QACF,KAAK,CAAC;UACJF,SAAS,GAAGA,SAAS,CAACE,MAAM,CAAC,CAAC,qBAAqB,EAAE,qBAAqB,EAAE,qBAAqB,EAAE,sBAAsB,EAAE,qBAAqB,EAAE,sBAAsB,CAAC,CAAC;UAC1K;QACF,KAAK,CAAC;UACJF,SAAS,GAAGA,SAAS,CAACE,MAAM,CAAC,CAAC,qBAAqB,EAAE,qBAAqB,EAAE,qBAAqB,EAAE,qBAAqB,EAAE,uBAAuB,EAAE,uBAAuB,EAAE,uBAAuB,EAAE,uBAAuB,CAAC,CAAC;UAC9N;QACF;UACEzE,aAAa,CAAC,gDAAgD,CAAC;MACnE;IACF;IACAgE,QAAQ,GAAG3E,gBAAgB,CAAC4E,UAAU,CAACD,QAAQ,EAAE,oBAAoB,EAAEO,SAAS,CAAC,CAACL,MAAM;;IAExF;IACA,MAAMQ,oBAAoB,GAAGrB,KAAK,CAACiB,WAAW,CAAC,CAAC,CAACK,kBAAkB,CAAC,CAAC;IACrE,IAAID,oBAAoB,KAAK,IAAI,EAAE;MACjCV,QAAQ,GAAG3E,gBAAgB,CAAC4E,UAAU,CAACD,QAAQ,EAAE,0BAA0B,EAAE,CAAC,+BAA+B,EAAE,wBAAwB,EAAE,yBAAyB,EAAE,0BAA0B,EAAE,0BAA0B,EAAE,0BAA0B,EAAE,wBAAwB,EAAE,gCAAgC,CAAC,CAAC,CAACE,MAAM;MAC3TF,QAAQ,GAAG3E,gBAAgB,CAAC4E,UAAU,CAACD,QAAQ,EAAE,4BAA4B,EAAE,gCAAgC,CAAC,CAACE,MAAM;MACvHF,QAAQ,GAAG3E,gBAAgB,CAAC4E,UAAU,CAACD,QAAQ,EAAE,mCAAmC,EAAE,CAAC,+BAA+B,EAAE,8CAA8C,EAAE,sBAAsB,EAAE,sDAAsD,EAAE,uDAAuD,EAAE,gCAAgC,EAAE,WAAW,EAAE,EAAE,EAAE,yCAAyC,EAAE,4CAA4C,EAAE,EAAE,EAAE,yCAAyC,EAAE,EAAE,EAAE,yCAAyC,EAAE,uDAAuD,EAAE,GAAG,EAAE,QAAQ,CAAC,CAAC,CAACE,MAAM;IAC5mB;IACA,IAAI5D,MAAM,EAAE;MACV,MAAMsE,IAAI,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;MACjC,IAAIC,UAAU,GAAG,CAAC,sDAAsD,CAAC;MACzE,KAAK,IAAIL,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGL,QAAQ,EAAEK,IAAI,EAAE,EAAE;QAC1CK,UAAU,GAAGA,UAAU,CAACJ,MAAM,CAAC,CAAE,cAAaD,IAAK,SAAQA,IAAK,2CAA0CI,IAAI,CAACJ,IAAI,CAAE,YAAWA,IAAK,YAAWA,IAAK,WAAUA,IAAK,SAAQ,EAAG,mBAAkBA,IAAK,SAAQA,IAAK,yCAAwCI,IAAI,CAACJ,IAAI,CAAE,cAAaA,IAAK,cAAaA,IAAK,WAAUA,IAAK,OAAM,CAAC,CAAC;MACnU;MACA,QAAQL,QAAQ;QACd,KAAK,CAAC;UACJU,UAAU,GAAGA,UAAU,CAACJ,MAAM,CAAC,CAAC,8CAA8C,CAAC,CAAC;UAChF;QACF,KAAK,CAAC;UACJI,UAAU,GAAGA,UAAU,CAACJ,MAAM,CAAC,CAAC,8CAA8C,EAAE,8HAA8H,CAAC,CAAC;UAChN;QACF,KAAK,CAAC;UACJI,UAAU,GAAGA,UAAU,CAACJ,MAAM,CAAC,CAAC,4DAA4D,EAAE,0KAA0K,CAAC,CAAC;UAC1Q;QACF,KAAK,CAAC;UACJI,UAAU,GAAGA,UAAU,CAACJ,MAAM,CAAC,CAAC,0EAA0E,EAAE,sNAAsN,CAAC,CAAC;UACpU;QACF;UACEzE,aAAa,CAAC,gDAAgD,CAAC;MACnE;MACAgE,QAAQ,GAAG3E,gBAAgB,CAAC4E,UAAU,CAACD,QAAQ,EAAE,qBAAqB,EAAEa,UAAU,CAAC,CAACX,MAAM;IAC5F,CAAC,MAAM;MACL;MACA,QAAQC,QAAQ;QACd,KAAK,CAAC;UACJH,QAAQ,GAAG3E,gBAAgB,CAAC4E,UAAU,CAACD,QAAQ,EAAE,qBAAqB,EAAE,CAAC,GAAGvD,kBAAkB,CAAE;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,CAAC,CAAC,CAAC,CAACyD,MAAM;UACjB;QACF,KAAK,CAAC;UACJF,QAAQ,GAAG3E,gBAAgB,CAAC4E,UAAU,CAACD,QAAQ,EAAE,qBAAqB,EAAE,CAAC,sDAAsD,EAAE,+CAA+C,EAAE,4GAA4G,CAAC,CAAC,CAACE,MAAM;UACvS;QACF,KAAK,CAAC;UACJF,QAAQ,GAAG3E,gBAAgB,CAAC4E,UAAU,CAACD,QAAQ,EAAE,qBAAqB,EAAE,CAAC,2EAA2E,EAAE,uEAAuE,EAAE,mDAAmD,EAAE,6DAA6D,CAAC,CAAC,CAACE,MAAM;UAC1V;QACF;UACEF,QAAQ,GAAG3E,gBAAgB,CAAC4E,UAAU,CAACD,QAAQ,EAAE,qBAAqB,EAAE,CAAC,2EAA2E,EAAE,uEAAuE,EAAE,mDAAmD,EAAE,8DAA8D,CAAC,CAAC,CAACE,MAAM;MAC/V;IACF;IACA,IAAI7C,KAAK,CAAC2B,oBAAoB,EAAE;MAC9BgB,QAAQ,GAAG3E,gBAAgB,CAAC4E,UAAU,CAACD,QAAQ,EAAE,qBAAqB,EAAE,2BAA2B,CAAC,CAACE,MAAM;MAC3GF,QAAQ,GAAG3E,gBAAgB,CAAC4E,UAAU,CAACD,QAAQ,EAAE,sBAAsB,EAAE,CAAC,0BAA0B,EAAE,iDAAiD,EAAE,mCAAmC,EAAE,iCAAiC,EAAE,4CAA4C,CAAC,CAAC,CAACE,MAAM;IACxR;IACAR,OAAO,CAACC,MAAM,GAAGI,QAAQ;IACzBL,OAAO,CAACE,QAAQ,GAAGI,QAAQ;IAC3B5C,SAAS,CAAC0D,iBAAiB,CAACpB,OAAO,EAAEvB,GAAG,EAAEkB,KAAK,CAAC;IAChDjC,SAAS,CAAC2D,6BAA6B,CAACrB,OAAO,EAAEvB,GAAG,EAAEkB,KAAK,CAAC;EAC9D,CAAC;EACDjC,SAAS,CAAC0D,iBAAiB,GAAG,CAACpB,OAAO,EAAEvB,GAAG,EAAEkB,KAAK,KAAK;IACrD,IAAIU,QAAQ,GAAGL,OAAO,CAACC,MAAM;IAC7B,IAAIK,QAAQ,GAAGN,OAAO,CAACE,QAAQ;IAC/B,IAAIvC,KAAK,CAACmB,UAAU,CAACwC,yBAAyB,CAAC,CAAC,EAAE;MAChD,IAAIC,aAAa,GAAG5D,KAAK,CAACmB,UAAU,CAACwC,yBAAyB,CAAC,CAAC;MAChE,IAAIC,aAAa,GAAG,CAAC,EAAE;QACrBrG,eAAe,CAAC,yCAAyC,CAAC;QAC1DqG,aAAa,GAAG,CAAC;MACnB;MACAlB,QAAQ,GAAG1E,gBAAgB,CAAC4E,UAAU,CAACF,QAAQ,EAAE,kBAAkB,EAAE,CAAC,4BAA4B,EAAE,6BAA6B,EAAE,yCAAyC,CAAC,CAAC,CAACG,MAAM;MACrLH,QAAQ,GAAG1E,gBAAgB,CAAC4E,UAAU,CAACF,QAAQ,EAAE,mBAAmB,EAAE,CAAC,kDAAkD,EAAE,OAAO,EAAE,oCAAoC,EAAE,WAAW,EAAE,gBAAgB,EAAE,WAAW,EAAE,4EAA4E,EAAE,OAAO,CAAC,CAAC,CAACG,MAAM;MACpTF,QAAQ,GAAG3E,gBAAgB,CAAC4E,UAAU,CAACD,QAAQ,EAAE,kBAAkB,EAAE,CAAC,4BAA4B,EAAE,yCAAyC,CAAC,CAAC,CAACE,MAAM;MACtJF,QAAQ,GAAG3E,gBAAgB,CAAC4E,UAAU,CAACD,QAAQ,EAAE,mBAAmB,EAAE,CAAC,kDAAkD,EAAE,OAAO,EAAE,oCAAoC,EAAE,WAAW,EAAE,gBAAgB,EAAE,WAAW,EAAE,yDAAyD,EAAE,OAAO,CAAC,CAAC,CAACE,MAAM;IACnS;IACAR,OAAO,CAACC,MAAM,GAAGI,QAAQ;IACzBL,OAAO,CAACE,QAAQ,GAAGI,QAAQ;EAC7B,CAAC;EACD5C,SAAS,CAAC8D,uBAAuB,GAAG,CAACC,MAAM,EAAEhD,GAAG,EAAEkB,KAAK,KAAK;IAC1D;IACA;IACA;IACA;IACA;IACA;;IAEA,MAAMc,QAAQ,GAAG9C,KAAK,CAAC+C,aAAa,CAACC,aAAa,CAAC,CAAC;IACpD,MAAMe,KAAK,GAAG/B,KAAK,CAACiB,WAAW,CAAC,CAAC,CAAC/D,wBAAwB,CAAC,CAAC;;IAE5D;IACA,IAAI8E,WAAW,GAAG,KAAK;IACvB,IAAI,CAAChE,KAAK,CAACI,iBAAiB,IAAIJ,KAAK,CAACiE,+BAA+B,IAAIjE,KAAK,CAACI,iBAAiB,IAAIJ,KAAK,CAACI,iBAAiB,CAAC8D,oBAAoB,CAAC,CAAC,KAAKlE,KAAK,CAACiE,+BAA+B,EAAE;MAC5LD,WAAW,GAAG,IAAI;IACpB;IACA,IAAIA,WAAW,IAAIhE,KAAK,CAACmE,wBAAwB,KAAKnE,KAAK,CAAC2B,oBAAoB,IAAImC,MAAM,CAACM,UAAU,CAAC,CAAC,EAAEC,SAAS,CAAC,CAAC,KAAK,CAAC,IAAIrE,KAAK,CAACsE,qBAAqB,KAAKxB,QAAQ,IAAI9C,KAAK,CAACuE,yBAAyB,KAAKR,KAAK,EAAE;MACnN/D,KAAK,CAACmE,wBAAwB,GAAGnE,KAAK,CAAC2B,oBAAoB;MAC3D3B,KAAK,CAACsE,qBAAqB,GAAGxB,QAAQ;MACtC9C,KAAK,CAACuE,yBAAyB,GAAGR,KAAK;MACvC,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd,CAAC;EACDhE,SAAS,CAACyE,aAAa,GAAG,CAACV,MAAM,EAAEhD,GAAG,EAAEkB,KAAK,KAAK;IAChDhC,KAAK,CAACyE,WAAW,GAAGX,MAAM;;IAE1B;IACA,IAAI/D,SAAS,CAAC8D,uBAAuB,CAACC,MAAM,EAAEhD,GAAG,EAAEkB,KAAK,CAAC,EAAE;MACzD,MAAMK,OAAO,GAAG;QACdC,MAAM,EAAE,IAAI;QACZC,QAAQ,EAAE,IAAI;QACdC,QAAQ,EAAE;MACZ,CAAC;MACDzC,SAAS,CAAC2E,YAAY,CAACrC,OAAO,EAAEvB,GAAG,EAAEkB,KAAK,CAAC;;MAE3C;MACA,MAAM2C,SAAS,GAAG3E,KAAK,CAACQ,mBAAmB,CAACoE,cAAc,CAAC,CAAC,CAACC,uBAAuB,CAACxC,OAAO,CAACC,MAAM,EAAED,OAAO,CAACE,QAAQ,EAAEF,OAAO,CAACG,QAAQ,CAAC;;MAExI;MACA,IAAImC,SAAS,KAAKb,MAAM,CAACM,UAAU,CAAC,CAAC,EAAE;QACrCN,MAAM,CAACgB,UAAU,CAACH,SAAS,CAAC;QAC5B;QACAb,MAAM,CAACiB,MAAM,CAAC,CAAC,CAACC,wBAAwB,CAAC,CAAC;MAC5C;MACAlB,MAAM,CAACmB,mBAAmB,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC;IACzC,CAAC,MAAM;MACLlF,KAAK,CAACQ,mBAAmB,CAACoE,cAAc,CAAC,CAAC,CAACO,kBAAkB,CAACrB,MAAM,CAACM,UAAU,CAAC,CAAC,CAAC;IACpF;IACAN,MAAM,CAACiB,MAAM,CAAC,CAAC,CAACK,IAAI,CAAC,CAAC;IACtBrF,SAAS,CAACsF,yBAAyB,CAACvB,MAAM,EAAEhD,GAAG,EAAEkB,KAAK,CAAC;IACvDjC,SAAS,CAACuF,yBAAyB,CAACxB,MAAM,EAAEhD,GAAG,EAAEkB,KAAK,CAAC;IACvDjC,SAAS,CAACwF,2BAA2B,CAACzB,MAAM,EAAEhD,GAAG,EAAEkB,KAAK,CAAC;EAC3D,CAAC;EACDjC,SAAS,CAACsF,yBAAyB,GAAG,CAACvB,MAAM,EAAEhD,GAAG,EAAEkB,KAAK,KAAK;IAC5D;;IAEA,IAAI8B,MAAM,CAAC0B,OAAO,CAAC,CAAC,CAACC,eAAe,CAAC,CAAC,KAAKzF,KAAK,CAAC0F,YAAY,GAAG5B,MAAM,CAAC6B,sBAAsB,CAAC,CAAC,CAACxG,QAAQ,CAAC,CAAC,IAAI2E,MAAM,CAACmB,mBAAmB,CAAC,CAAC,CAAC9F,QAAQ,CAAC,CAAC,GAAG2E,MAAM,CAAC6B,sBAAsB,CAAC,CAAC,CAACxG,QAAQ,CAAC,CAAC,CAAC,EAAE;MACnM,IAAI2E,MAAM,CAACM,UAAU,CAAC,CAAC,CAACwB,eAAe,CAAC,UAAU,CAAC,EAAE;QACnD,IAAI,CAAC9B,MAAM,CAACiB,MAAM,CAAC,CAAC,CAACc,iBAAiB,CAAC/B,MAAM,CAACM,UAAU,CAAC,CAAC,EAAEN,MAAM,CAAC0B,OAAO,CAAC,CAAC,EAAE,UAAU,EAAE1B,MAAM,CAAC0B,OAAO,CAAC,CAAC,CAACM,eAAe,CAAC,CAAC,EAAEhC,MAAM,CAAC0B,OAAO,CAAC,CAAC,CAACO,SAAS,CAAC,CAAC,EAAE/F,KAAK,CAACU,OAAO,CAACsF,KAAK,EAAE,CAAC,EAAEhG,KAAK,CAACU,OAAO,CAACuF,KAAK,CAAC,EAAE;UACxMtH,aAAa,CAAC,uCAAuC,CAAC;QACxD;MACF;MACA,IAAImF,MAAM,CAACM,UAAU,CAAC,CAAC,CAACwB,eAAe,CAAC,UAAU,CAAC,IAAI9B,MAAM,CAAC0B,OAAO,CAAC,CAAC,CAACU,eAAe,CAAC,CAAC,EAAE;QACzF,IAAI,CAACpC,MAAM,CAACiB,MAAM,CAAC,CAAC,CAACc,iBAAiB,CAAC/B,MAAM,CAACM,UAAU,CAAC,CAAC,EAAEN,MAAM,CAAC0B,OAAO,CAAC,CAAC,EAAE,UAAU,EAAE1B,MAAM,CAAC0B,OAAO,CAAC,CAAC,CAACU,eAAe,CAAC,CAAC,EAAEpC,MAAM,CAAC0B,OAAO,CAAC,CAAC,CAACO,SAAS,CAAC,CAAC,EAAE/F,KAAK,CAACU,OAAO,CAACsF,KAAK,EAAElC,MAAM,CAAC0B,OAAO,CAAC,CAAC,CAACW,mBAAmB,CAAC,CAAC,EAAEnG,KAAK,CAACU,OAAO,CAACuF,KAAK,CAAC,EAAE;UAC7OtH,aAAa,CAAC,uCAAuC,CAAC;QACxD;MACF;MACAmF,MAAM,CAAC6B,sBAAsB,CAAC,CAAC,CAACT,QAAQ,CAAC,CAAC;IAC5C;IACA,MAAMkB,OAAO,GAAGpG,KAAK,CAAC+C,aAAa,CAACsD,cAAc,CAAC,CAAC;IACpDvC,MAAM,CAACM,UAAU,CAAC,CAAC,CAACkC,WAAW,CAAC,UAAU,EAAEF,OAAO,CAAC;IACpD,MAAMG,OAAO,GAAGvG,KAAK,CAAC+C,aAAa,CAACC,aAAa,CAAC,CAAC;IACnD,MAAM/D,MAAM,GAAG+C,KAAK,CAACiB,WAAW,CAAC,CAAC,CAAC/D,wBAAwB,CAAC,CAAC;IAC7D,IAAID,MAAM,EAAE;MACV,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8G,OAAO,EAAE9G,CAAC,EAAE,EAAE;QAChCqE,MAAM,CAACM,UAAU,CAAC,CAAC,CAACoC,WAAW,CAAE,MAAK/G,CAAE,EAAC,EAAEuC,KAAK,CAACiB,WAAW,CAAC,CAAC,CAACwD,kBAAkB,CAAChH,CAAC,CAAC,CAAC;MACvF;IACF;IACA,MAAMiH,aAAa,GAAG1G,KAAK,CAAC+C,aAAa,CAAC4D,gBAAgB,CAAC,CAAC;;IAE5D;IACA;IACA,KAAK,IAAIlH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8G,OAAO,EAAE9G,CAAC,EAAE,EAAE;MAChC,IAAImH,EAAE,GAAG5E,KAAK,CAACiB,WAAW,CAAC,CAAC,CAAC4D,cAAc,CAAC,CAAC;MAC7C,IAAIC,EAAE,GAAG9E,KAAK,CAACiB,WAAW,CAAC,CAAC,CAAC8D,aAAa,CAAC,CAAC;MAC5C,MAAMC,MAAM,GAAG/H,MAAM,GAAGQ,CAAC,GAAG,CAAC;MAC7B,MAAMwH,IAAI,GAAGjF,KAAK,CAACiB,WAAW,CAAC,CAAC,CAACiE,sBAAsB,CAACF,MAAM,CAAC;MAC/D,IAAIC,IAAI,IAAIjF,KAAK,CAACiB,WAAW,CAAC,CAAC,CAACkE,4BAA4B,CAAC,CAAC,EAAE;QAC9D,MAAMC,MAAM,GAAGH,IAAI,CAACI,QAAQ,CAAC,CAAC;QAC9BT,EAAE,GAAGQ,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC;QAC1BN,EAAE,GAAG,GAAG,IAAIM,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,CAAC;MACpC;MACA,MAAME,KAAK,GAAGZ,aAAa,CAACY,KAAK,GAAGV,EAAE;MACtC,MAAMW,KAAK,GAAG,CAACb,aAAa,CAACa,KAAK,GAAGT,EAAE,IAAIF,EAAE,GAAG,GAAG;MACnD9C,MAAM,CAACM,UAAU,CAAC,CAAC,CAACoC,WAAW,CAAE,SAAQ/G,CAAE,EAAC,EAAE8H,KAAK,CAAC;MACpDzD,MAAM,CAACM,UAAU,CAAC,CAAC,CAACoC,WAAW,CAAE,SAAQ/G,CAAE,EAAC,EAAE6H,KAAK,CAAC;IACtD;;IAEA;IACA,KAAK,IAAI7H,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8G,OAAO,EAAE9G,CAAC,EAAE,EAAE;MAChC,IAAI+H,QAAQ,GAAG,GAAG;MAClB,IAAIC,QAAQ,GAAG,GAAG;MAClB,MAAMT,MAAM,GAAG/H,MAAM,GAAGQ,CAAC,GAAG,CAAC;MAC7B,MAAMV,KAAK,GAAGiD,KAAK,CAACiB,WAAW,CAAC,CAAC,CAACyE,oBAAoB,CAACV,MAAM,CAAC;MAC9D,IAAIjI,KAAK,EAAE;QACT,MAAM4I,QAAQ,GAAG5I,KAAK,CAACsI,QAAQ,CAAC,CAAC;QACjC,MAAM3H,MAAM,GAAGiI,QAAQ,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC;QACxC,MAAMC,GAAG,GAAG,GAAG,IAAID,QAAQ,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC,CAAC;QAC7CH,QAAQ,GAAGd,aAAa,CAACY,KAAK,GAAG5H,MAAM;QACvC+H,QAAQ,GAAG,CAACf,aAAa,CAACa,KAAK,GAAGK,GAAG,IAAIlI,MAAM,GAAG,GAAG;MACvD;MACAoE,MAAM,CAACM,UAAU,CAAC,CAAC,CAACoC,WAAW,CAAE,WAAU/G,CAAE,EAAC,EAAEgI,QAAQ,CAAC;MACzD3D,MAAM,CAACM,UAAU,CAAC,CAAC,CAACoC,WAAW,CAAE,WAAU/G,CAAE,EAAC,EAAE+H,QAAQ,CAAC;IAC3D;IACA,IAAIxH,KAAK,CAAC2B,oBAAoB,EAAE;MAC9BmC,MAAM,CAACM,UAAU,CAAC,CAAC,CAACkC,WAAW,CAAC,cAAc,EAAEtG,KAAK,CAAC4B,WAAW,GAAG,CAAC,GAAG,CAAC,CAAC;IAC5E;;IAEA;IACA,IAAIkC,MAAM,CAACM,UAAU,CAAC,CAAC,CAACyD,aAAa,CAAC,SAAS,CAAC,EAAE;MAChD,MAAMC,EAAE,GAAG/H,SAAS,CAACgC,uBAAuB,CAACjB,GAAG,EAAEkB,KAAK,CAAC;MACxD8B,MAAM,CAACM,UAAU,CAAC,CAAC,CAACoC,WAAW,CAAC,SAAS,EAAEsB,EAAE,CAACC,MAAM,CAAC;MACrD;MACA,IAAIjE,MAAM,CAACM,UAAU,CAAC,CAAC,CAACyD,aAAa,CAAC,SAAS,CAAC,EAAE;QAChD/D,MAAM,CAACM,UAAU,CAAC,CAAC,CAACoC,WAAW,CAAC,SAAS,EAAEsB,EAAE,CAACE,MAAM,CAAC;MACvD;IACF;IACA,MAAMC,YAAY,GAAGjI,KAAK,CAACkI,YAAY,CAAC7B,cAAc,CAAC,CAAC;IACxDvC,MAAM,CAACM,UAAU,CAAC,CAAC,CAACkC,WAAW,CAAC,eAAe,EAAE2B,YAAY,CAAC;IAC9D,MAAME,cAAc,GAAGnI,KAAK,CAACoI,UAAU,CAAC/B,cAAc,CAAC,CAAC;IACxDvC,MAAM,CAACM,UAAU,CAAC,CAAC,CAACkC,WAAW,CAAC,aAAa,EAAE6B,cAAc,CAAC;IAC9D,MAAME,oBAAoB,GAAGrI,KAAK,CAACsI,4BAA4B,CAACjC,cAAc,CAAC,CAAC;IAChFvC,MAAM,CAACM,UAAU,CAAC,CAAC,CAACkC,WAAW,CAAC,sBAAsB,EAAE+B,oBAAoB,CAAC;IAC7E,IAAIrI,KAAK,CAACmB,UAAU,CAACwC,yBAAyB,CAAC,CAAC,EAAE;MAChD;MACA,IAAIC,aAAa,GAAG5D,KAAK,CAACmB,UAAU,CAACwC,yBAAyB,CAAC,CAAC;MAChE,IAAIC,aAAa,GAAG,CAAC,EAAE;QACrBrG,eAAe,CAAC,yCAAyC,CAAC;QAC1DqG,aAAa,GAAG,CAAC;MACnB;MACA,MAAM2E,iBAAiB,GAAGzE,MAAM,CAAC0B,OAAO,CAAC,CAAC,CAACgD,4BAA4B,CAAC,CAAC;MACzE,MAAMC,uBAAuB,GAAGF,iBAAiB,GAAGzE,MAAM,CAAC0B,OAAO,CAAC,CAAC,CAACkD,6BAA6B,CAAC,CAAC,GAAG,IAAI;MAC3G,MAAMC,GAAG,GAAGF,uBAAuB,GAAG5L,IAAI,CAAC+L,IAAI,CAAC5I,KAAK,CAAC6I,WAAW,EAAE7G,KAAK,CAAC8G,SAAS,CAAC,CAAC,CAAC,GAAG9G,KAAK,CAAC8G,SAAS,CAAC,CAAC;MACzG,IAAIL,uBAAuB,EAAE;QAC3B5L,IAAI,CAACkM,SAAS,CAACJ,GAAG,EAAEA,GAAG,CAAC;QACxB9L,IAAI,CAACmM,QAAQ,CAACL,GAAG,EAAEA,GAAG,EAAEF,uBAAuB,CAAC;QAChD5L,IAAI,CAACkM,SAAS,CAACJ,GAAG,EAAEA,GAAG,CAAC;MAC1B;;MAEA;MACA9L,IAAI,CAACkM,SAAS,CAAC/I,KAAK,CAACiJ,QAAQ,EAAEjJ,KAAK,CAACkJ,YAAY,CAACC,eAAe,CAAC,CAAC,CAAC;MACpEtM,IAAI,CAACmM,QAAQ,CAAChJ,KAAK,CAAC6I,WAAW,EAAEF,GAAG,EAAE3I,KAAK,CAACiJ,QAAQ,CAAC;MACrD,MAAMG,cAAc,GAAG,EAAE;MACzB,KAAK,IAAI3J,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmE,aAAa,EAAEnE,CAAC,EAAE,EAAE;QACtC,MAAM4J,aAAa,GAAG,EAAE;QACxBrJ,KAAK,CAACmB,UAAU,CAACmI,4BAA4B,CAACtJ,KAAK,CAAC6I,WAAW,EAAEpJ,CAAC,EAAE4J,aAAa,CAAC;QAClF,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;UAC1BH,cAAc,CAACvJ,IAAI,CAACwJ,aAAa,CAACE,CAAC,CAAC,CAAC;QACvC;MACF;MACAzF,MAAM,CAACM,UAAU,CAAC,CAAC,CAACkC,WAAW,CAAC,eAAe,EAAE1C,aAAa,CAAC;MAC/DE,MAAM,CAACM,UAAU,CAAC,CAAC,CAACoF,aAAa,CAAC,YAAY,EAAEJ,cAAc,CAAC;IACjE;;IAEA;IACA,MAAM/F,oBAAoB,GAAGrB,KAAK,CAACiB,WAAW,CAAC,CAAC,CAACK,kBAAkB,CAAC,CAAC;IACrE,IAAID,oBAAoB,KAAK,IAAI,EAAE;MACjC,MAAMoG,cAAc,GAAGzH,KAAK,CAACiB,WAAW,CAAC,CAAC,CAACyG,sBAAsB,CAAC,CAAC;MACnE5F,MAAM,CAACM,UAAU,CAAC,CAAC,CAACoC,WAAW,CAAC,gBAAgB,EAAEiD,cAAc,CAAC;IACnE;EACF,CAAC;EACD1J,SAAS,CAACuF,yBAAyB,GAAG,CAACxB,MAAM,EAAEhD,GAAG,EAAEkB,KAAK,KAAK;IAC5D,MAAM2H,OAAO,GAAG7F,MAAM,CAACM,UAAU,CAAC,CAAC;IACnC,MAAMwF,OAAO,GAAG5J,KAAK,CAACK,gBAAgB,CAACwJ,cAAc,CAAC,CAAC;IACvD,MAAMC,KAAK,GAAG9J,KAAK,CAACkJ,YAAY;IAChC,MAAMa,OAAO,GAAGD,KAAK,CAACX,eAAe,CAAC,CAAC;IACvCtM,IAAI,CAACmM,QAAQ,CAAChJ,KAAK,CAACiJ,QAAQ,EAAEW,OAAO,CAACI,IAAI,EAAED,OAAO,CAAC;IACpD,MAAME,OAAO,GAAGjK,KAAK,CAACgB,YAAY,CAAC6I,cAAc,CAAC/I,GAAG,CAAC;IACtDjE,IAAI,CAACmM,QAAQ,CAAChJ,KAAK,CAACiJ,QAAQ,EAAEgB,OAAO,CAACC,IAAI,EAAElK,KAAK,CAACiJ,QAAQ,CAAC;IAC3D,IAAInF,MAAM,CAAC0B,OAAO,CAAC,CAAC,CAACgD,4BAA4B,CAAC,CAAC,EAAE;MACnD,MAAM2B,oBAAoB,GAAGrG,MAAM,CAAC0B,OAAO,CAAC,CAAC,CAACkD,6BAA6B,CAAC,CAAC;MAC7E7L,IAAI,CAACmM,QAAQ,CAAChJ,KAAK,CAACiJ,QAAQ,EAAEjJ,KAAK,CAACiJ,QAAQ,EAAEkB,oBAAoB,CAAC;IACrE;IACAR,OAAO,CAACS,gBAAgB,CAAC,YAAY,EAAEpK,KAAK,CAACiJ,QAAQ,CAAC;IACtD,MAAM5F,oBAAoB,GAAGrB,KAAK,CAACiB,WAAW,CAAC,CAAC,CAACK,kBAAkB,CAAC,CAAC;IACrE,IAAID,oBAAoB,KAAK,IAAI,EAAE;MACjC,MAAMgH,YAAY,GAAGP,KAAK,CAACQ,eAAe,CAAC,CAAC;MAC5C,MAAMC,eAAe,GAAGT,KAAK,CAACU,aAAa,CAAC,CAAC;MAC7Cb,OAAO,CAACc,YAAY,CAAC,iBAAiB,EAAEF,eAAe,CAAC,CAAC,CAAC,EAAEA,eAAe,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;MAClFZ,OAAO,CAACS,gBAAgB,CAAC,UAAU,EAAEC,YAAY,CAAC;MAClD,MAAMK,mBAAmB,GAAG1K,KAAK,CAACgB,YAAY,CAAC6I,cAAc,CAAC/I,GAAG,CAAC;;MAElE;MACAjE,IAAI,CAAC8N,MAAM,CAAC3K,KAAK,CAAC4K,iBAAiB,EAAEF,mBAAmB,CAACR,IAAI,CAAC;MAC9DlK,KAAK,CAACgB,YAAY,CAAC6I,cAAc,CAAC/I,GAAG,CAAC;MACtC6I,OAAO,CAACS,gBAAgB,CAAC,YAAY,EAAEpK,KAAK,CAAC4K,iBAAiB,CAAC;MAC/D,MAAMC,IAAI,GAAG9K,SAAS,CAAC+K,mBAAmB,CAAC,CAAC;MAC5CnB,OAAO,CAACnD,WAAW,CAAC,SAAS,EAAEqE,IAAI,CAAC,CAAC,CAAC,CAAC;MACvClB,OAAO,CAACnD,WAAW,CAAC,UAAU,EAAEqE,IAAI,CAAC,CAAC,CAAC,CAAC;MACxC,MAAM9C,MAAM,GAAGhI,SAAS,CAACgL,qBAAqB,CAAC,CAAC;MAChDpB,OAAO,CAACnD,WAAW,CAAC,WAAW,EAAEuB,MAAM,CAAC,CAAC,CAAC,GAAG8C,IAAI,CAAC,CAAC,CAAC,CAAC;MACrDlB,OAAO,CAACnD,WAAW,CAAC,WAAW,EAAEuB,MAAM,CAAC,CAAC,CAAC,GAAG8C,IAAI,CAAC,CAAC,CAAC,CAAC;IACvD;EACF,CAAC;EACD9K,SAAS,CAACwF,2BAA2B,GAAG,CAACzB,MAAM,EAAEhD,GAAG,EAAEkB,KAAK,KAAK;IAC9D,MAAM2H,OAAO,GAAG7F,MAAM,CAACM,UAAU,CAAC,CAAC;IACnC,MAAM4G,IAAI,GAAGhJ,KAAK,CAACiB,WAAW,CAAC,CAAC;IAChC,MAAMgI,OAAO,GAAGD,IAAI,CAACE,UAAU,CAAC,CAAC;IACjCvB,OAAO,CAACnD,WAAW,CAAC,SAAS,EAAEyE,OAAO,CAAC;EACzC,CAAC;EACDlL,SAAS,CAACoL,gBAAgB,GAAG,CAACrK,GAAG,EAAEkB,KAAK,KAAK;IAC3C;IACAjC,SAAS,CAACqL,mBAAmB,CAACtK,GAAG,EAAEkB,KAAK,CAAC;;IAEzC;IACAhC,KAAK,CAACyE,WAAW,GAAG,IAAI;EAC1B,CAAC;EACD1E,SAAS,CAACsL,eAAe,GAAG,CAACvK,GAAG,EAAEkB,KAAK,KAAK;IAC1C,MAAMsJ,EAAE,GAAGtL,KAAK,CAACU,OAAO;;IAExB;IACAV,KAAK,CAAC+C,aAAa,CAACwI,QAAQ,CAAC,CAAC;IAC9BvL,KAAK,CAACkI,YAAY,CAACqD,QAAQ,CAAC,CAAC;IAC7BvL,KAAK,CAACsI,4BAA4B,CAACiD,QAAQ,CAAC,CAAC;IAC7CvL,KAAK,CAACoI,UAAU,CAACmD,QAAQ,CAAC,CAAC;;IAE3B;IACA,IAAIvL,KAAK,CAACY,IAAI,CAAC4E,OAAO,CAAC,CAAC,CAACC,eAAe,CAAC,CAAC,EAAE;MAC1C;MACA1F,SAAS,CAACyE,aAAa,CAACxE,KAAK,CAACY,IAAI,EAAEE,GAAG,EAAEkB,KAAK,CAAC;MAC/CsJ,EAAE,CAACE,UAAU,CAACF,EAAE,CAACG,SAAS,EAAE,CAAC,EAAEzL,KAAK,CAACY,IAAI,CAAC4E,OAAO,CAAC,CAAC,CAACC,eAAe,CAAC,CAAC,CAAC;MACtEzF,KAAK,CAACY,IAAI,CAACmE,MAAM,CAAC,CAAC,CAAC2G,OAAO,CAAC,CAAC;IAC/B;IACA1L,KAAK,CAAC+C,aAAa,CAAC4I,UAAU,CAAC,CAAC;IAChC3L,KAAK,CAACkI,YAAY,CAACyD,UAAU,CAAC,CAAC;IAC/B3L,KAAK,CAACsI,4BAA4B,CAACqD,UAAU,CAAC,CAAC;IAC/C3L,KAAK,CAACoI,UAAU,CAACuD,UAAU,CAAC,CAAC;EAC/B,CAAC;EACD5L,SAAS,CAAC6L,iBAAiB,GAAG,CAAC9K,GAAG,EAAEkB,KAAK,KAAK,CAAC,CAAC;EAChDjC,SAAS,CAACoC,WAAW,GAAG,CAACrB,GAAG,EAAEkB,KAAK,KAAK;IACtC;IACA;IACA;IACA;;IAEAjC,SAAS,CAAC8L,WAAW,CAAC;MACpBC,IAAI,EAAE;IACR,CAAC,CAAC;IACF9L,KAAK,CAACmB,UAAU,CAAC4K,MAAM,CAAC,CAAC;IACzB/L,KAAK,CAACkJ,YAAY,GAAGlJ,KAAK,CAACmB,UAAU,CAAC6K,eAAe,CAAC,CAAC;IACvDjM,SAAS,CAAC8L,WAAW,CAAC;MACpBC,IAAI,EAAE;IACR,CAAC,CAAC;IACF,IAAI,CAAC9L,KAAK,CAACkJ,YAAY,EAAE;MACvBvK,aAAa,CAAC,WAAW,CAAC;MAC1B;IACF;IACAoB,SAAS,CAACoL,gBAAgB,CAACrK,GAAG,EAAEkB,KAAK,CAAC;IACtCjC,SAAS,CAACsL,eAAe,CAACvK,GAAG,EAAEkB,KAAK,CAAC;IACrCjC,SAAS,CAAC6L,iBAAiB,CAAC9K,GAAG,EAAEkB,KAAK,CAAC;EACzC,CAAC;EACDjC,SAAS,CAACkM,aAAa,GAAG,CAACnL,GAAG,EAAEkB,KAAK,KAAK;IACxC,IAAI,CAACjC,SAAS,CAACmM,QAAQ,CAAC,CAAC,EAAE;MACzBpO,kBAAkB,CAACkC,KAAK,CAACmM,MAAM,CAAC;MAChC;IACF;IACAnM,KAAK,CAACmM,MAAM,GAAGpM,SAAS,CAACmM,QAAQ,CAAC,CAAC,CAACE,SAAS,CAAC,CAAC;EACjD,CAAC;EACDrM,SAAS,CAACqL,mBAAmB,GAAG,CAACtK,GAAG,EAAEkB,KAAK,KAAK;IAC9C;IACA,IAAIjC,SAAS,CAACsM,6BAA6B,CAACvL,GAAG,EAAEkB,KAAK,CAAC,EAAE;MACvDjC,SAAS,CAACuM,kBAAkB,CAACxL,GAAG,EAAEkB,KAAK,CAAC;IAC1C;EACF,CAAC;EACDjC,SAAS,CAACsM,6BAA6B,GAAG,CAACvL,GAAG,EAAEkB,KAAK,KAAK;IACxD;IACA,IAAIhC,KAAK,CAAC0F,YAAY,CAACvG,QAAQ,CAAC,CAAC,GAAGY,SAAS,CAACZ,QAAQ,CAAC,CAAC,IAAIa,KAAK,CAAC0F,YAAY,CAACvG,QAAQ,CAAC,CAAC,GAAG6C,KAAK,CAAC7C,QAAQ,CAAC,CAAC,IAAIa,KAAK,CAAC0F,YAAY,CAACvG,QAAQ,CAAC,CAAC,GAAGa,KAAK,CAACmB,UAAU,CAAChC,QAAQ,CAAC,CAAC,IAAIa,KAAK,CAAC0F,YAAY,CAACvG,QAAQ,CAAC,CAAC,GAAG6C,KAAK,CAACiB,WAAW,CAAC,CAAC,CAAC9D,QAAQ,CAAC,CAAC,IAAIa,KAAK,CAAC0F,YAAY,CAACvG,QAAQ,CAAC,CAAC,GAAGa,KAAK,CAACkJ,YAAY,CAAC/J,QAAQ,CAAC,CAAC,EAAE;MAC9S,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd,CAAC;EACDY,SAAS,CAACuM,kBAAkB,GAAG,CAACxL,GAAG,EAAEkB,KAAK,KAAK;IAC7C,MAAM8H,KAAK,GAAG9J,KAAK,CAACkJ,YAAY;IAChC,IAAI,CAACY,KAAK,EAAE;MACV;IACF;IACA,MAAMyC,UAAU,GAAGzC,KAAK,CAAC0C,YAAY,CAAC,CAAC,IAAI1C,KAAK,CAAC0C,YAAY,CAAC,CAAC,CAACC,UAAU,CAAC,CAAC;IAC5E,IAAI,CAACF,UAAU,EAAE;MACf;IACF;IACA,MAAMG,QAAQ,GAAGH,UAAU,CAACI,WAAW,CAAC,CAAC;IACzC,MAAMpG,OAAO,GAAGgG,UAAU,CAACK,qBAAqB,CAAC,CAAC;IAClD,MAAMC,aAAa,GAAG7K,KAAK,CAACiB,WAAW,CAAC,CAAC;IACzC,MAAM6J,KAAK,GAAGD,aAAa,CAACE,oBAAoB,CAAC,CAAC;IAClD,MAAM9N,MAAM,GAAG4N,aAAa,CAAC3N,wBAAwB,CAAC,CAAC;IACvD,MAAM8N,SAAS,GAAG/N,MAAM,GAAGsH,OAAO,GAAG,CAAC;IACtC,MAAM0G,aAAa,GAAGhO,MAAM,GAAG,CAAC,GAAG+N,SAAS,GAAG,CAAC;IAChD,MAAME,iBAAiB,GAAGL,aAAa,CAAC3F,sBAAsB,CAAC,CAAC;IAChE,MAAMiG,YAAY,GAAGtO,iBAAiB,CAACgO,aAAa,EAAEK,iBAAiB,EAAEF,SAAS,CAAC;IACnF,MAAMI,IAAI,GAAGpN,KAAK,CAACQ,mBAAmB,CAAC6M,4BAA4B,CAACH,iBAAiB,CAAC;IACtF,MAAMI,QAAQ,GAAG,CAACF,IAAI,EAAEG,MAAM,IAAIH,IAAI,EAAEI,IAAI,KAAKL,YAAY,IAAInN,KAAK,CAACyN,kBAAkB,KAAKN,YAAY;IAC1G,IAAIG,QAAQ,EAAE;MACZ,MAAMI,MAAM,GAAG,IAAI;MACnB,MAAMC,KAAK,GAAGD,MAAM,GAAGT,aAAa,GAAG,CAAC;MACxC,MAAMW,MAAM,GAAG,IAAIC,UAAU,CAACF,KAAK,CAAC;MACpC,IAAI,CAAC3N,KAAK,CAACkI,YAAY,EAAE;QACvBlI,KAAK,CAACkI,YAAY,GAAGnK,gBAAgB,CAAC+P,WAAW,CAAC;UAChDC,SAAS,EAAE;QACb,CAAC,CAAC;QACF/N,KAAK,CAACkI,YAAY,CAACrH,qBAAqB,CAACb,KAAK,CAACQ,mBAAmB,CAAC;MACrE;MACA;MACA,IAAIsM,KAAK,KAAKzO,iBAAiB,CAAC2P,OAAO,EAAE;QACvChO,KAAK,CAACkI,YAAY,CAAC+F,qBAAqB,CAAC9P,MAAM,CAAC6P,OAAO,CAAC;QACxDhO,KAAK,CAACkI,YAAY,CAACgG,sBAAsB,CAAC/P,MAAM,CAAC6P,OAAO,CAAC;MAC3D,CAAC,MAAM;QACLhO,KAAK,CAACkI,YAAY,CAAC+F,qBAAqB,CAAC9P,MAAM,CAACgQ,MAAM,CAAC;QACvDnO,KAAK,CAACkI,YAAY,CAACgG,sBAAsB,CAAC/P,MAAM,CAACgQ,MAAM,CAAC;MAC1D;MACA,IAAIjB,iBAAiB,EAAE;QACrB,MAAMkB,QAAQ,GAAG,IAAIC,YAAY,CAACX,MAAM,GAAG,CAAC,CAAC;QAC7C,KAAK,IAAIlQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwP,SAAS,EAAExP,CAAC,EAAE,EAAE;UAClC,MAAMyJ,IAAI,GAAG4F,aAAa,CAAC3F,sBAAsB,CAAC1J,CAAC,CAAC;UACpD,MAAM4J,MAAM,GAAGH,IAAI,CAACI,QAAQ,CAAC,CAAC;UAC9BJ,IAAI,CAACqH,QAAQ,CAAClH,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,EAAEsG,MAAM,EAAEU,QAAQ,EAAE,CAAC,CAAC;UACxD,IAAInP,MAAM,EAAE;YACV,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiO,MAAM,GAAG,CAAC,EAAEjO,CAAC,EAAE,EAAE;cACnCmO,MAAM,CAACpQ,CAAC,GAAGkQ,MAAM,GAAG,CAAC,GAAGjO,CAAC,CAAC,GAAG,KAAK,GAAG2O,QAAQ,CAAC3O,CAAC,CAAC;cAChDmO,MAAM,CAACpQ,CAAC,GAAGkQ,MAAM,GAAG,CAAC,GAAGjO,CAAC,GAAGiO,MAAM,GAAG,CAAC,CAAC,GAAG,KAAK,GAAGU,QAAQ,CAAC3O,CAAC,CAAC;YAC/D;UACF,CAAC,MAAM;YACL,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiO,MAAM,GAAG,CAAC,EAAEjO,CAAC,EAAE,EAAE;cACnCmO,MAAM,CAACpQ,CAAC,GAAGkQ,MAAM,GAAG,CAAC,GAAGjO,CAAC,CAAC,GAAG,KAAK,GAAG2O,QAAQ,CAAC3O,CAAC,CAAC;YAClD;UACF;QACF;QACAO,KAAK,CAACkI,YAAY,CAAClD,wBAAwB,CAAChF,KAAK,CAACQ,mBAAmB,CAAC;QACtER,KAAK,CAACkI,YAAY,CAACqG,kBAAkB,CAAC,CAAC;QACvCvO,KAAK,CAACkI,YAAY,CAACsG,eAAe,CAACd,MAAM,EAAET,aAAa,EAAE,CAAC,EAAEtP,YAAY,CAAC8Q,aAAa,EAAEb,MAAM,CAAC;MAClG,CAAC,MAAM;QACL,KAAK,IAAInO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiO,MAAM,GAAG,CAAC,EAAE,EAAEjO,CAAC,EAAE;UACnCmO,MAAM,CAACnO,CAAC,CAAC,GAAG,KAAK,GAAGA,CAAC,IAAI,CAACiO,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC;UAC1CE,MAAM,CAACnO,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,GAAGA,CAAC,IAAI,CAACiO,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC;UAC9CE,MAAM,CAACnO,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,GAAGA,CAAC,IAAI,CAACiO,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC;QAChD;QACA1N,KAAK,CAACkI,YAAY,CAACsG,eAAe,CAACd,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE/P,YAAY,CAAC8Q,aAAa,EAAEb,MAAM,CAAC;MACtF;MACA5N,KAAK,CAACyN,kBAAkB,GAAGN,YAAY;MACvC,IAAID,iBAAiB,EAAE;QACrBlN,KAAK,CAACQ,mBAAmB,CAACkO,4BAA4B,CAACxB,iBAAiB,EAAElN,KAAK,CAACkI,YAAY,EAAElI,KAAK,CAACyN,kBAAkB,CAAC;MACzH;IACF,CAAC,MAAM;MACLzN,KAAK,CAACkI,YAAY,GAAGkF,IAAI,CAACG,MAAM;MAChCvN,KAAK,CAACyN,kBAAkB,GAAGL,IAAI,CAACI,IAAI;IACtC;;IAEA;IACA;IACA;IACA,MAAMmB,MAAM,GAAG9B,aAAa,CAACnF,oBAAoB,CAAC,CAAC;IACnD,MAAMkH,aAAa,GAAG/P,iBAAiB,CAACgO,aAAa,EAAE8B,MAAM,EAAE3B,SAAS,CAAC;IACzE,MAAM6B,MAAM,GAAG7O,KAAK,CAACQ,mBAAmB,CAAC6M,4BAA4B,CAACsB,MAAM,CAAC;IAC7E;IACA,MAAMG,UAAU,GAAG,CAACD,MAAM,EAAEtB,MAAM,IAAIsB,MAAM,EAAErB,IAAI,KAAKoB,aAAa,IAAI5O,KAAK,CAAC+O,gBAAgB,KAAKH,aAAa;IAChH,IAAIE,UAAU,EAAE;MACd,MAAME,QAAQ,GAAG,IAAI;MACrB,MAAMC,OAAO,GAAGD,QAAQ,GAAG/B,aAAa;MACxC,MAAMiC,QAAQ,GAAG,IAAIrB,UAAU,CAACoB,OAAO,CAAC;MACxC,IAAI,CAACjP,KAAK,CAACoI,UAAU,EAAE;QACrBpI,KAAK,CAACoI,UAAU,GAAGrK,gBAAgB,CAAC+P,WAAW,CAAC;UAC9CC,SAAS,EAAE;QACb,CAAC,CAAC;QACF/N,KAAK,CAACoI,UAAU,CAACvH,qBAAqB,CAACb,KAAK,CAACQ,mBAAmB,CAAC;MACnE;MACA;MACA,IAAIsM,KAAK,KAAKzO,iBAAiB,CAAC2P,OAAO,EAAE;QACvChO,KAAK,CAACoI,UAAU,CAAC6F,qBAAqB,CAAC9P,MAAM,CAAC6P,OAAO,CAAC;QACtDhO,KAAK,CAACoI,UAAU,CAAC8F,sBAAsB,CAAC/P,MAAM,CAAC6P,OAAO,CAAC;MACzD,CAAC,MAAM;QACLhO,KAAK,CAACoI,UAAU,CAAC6F,qBAAqB,CAAC9P,MAAM,CAACgQ,MAAM,CAAC;QACrDnO,KAAK,CAACoI,UAAU,CAAC8F,sBAAsB,CAAC/P,MAAM,CAACgQ,MAAM,CAAC;MACxD;MACA,IAAIQ,MAAM,EAAE;QACV,MAAMQ,aAAa,GAAG,IAAId,YAAY,CAACY,OAAO,CAAC;QAC/C,MAAMb,QAAQ,GAAG,IAAIC,YAAY,CAACW,QAAQ,CAAC;QAC3C,KAAK,IAAIxR,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwP,SAAS,EAAE,EAAExP,CAAC,EAAE;UAClC,MAAMuB,KAAK,GAAG8N,aAAa,CAACnF,oBAAoB,CAAClK,CAAC,CAAC;UACnD,IAAIuB,KAAK,KAAK,IAAI,EAAE;YAClB;YACAoQ,aAAa,CAACC,IAAI,CAAC,GAAG,CAAC;UACzB,CAAC,MAAM;YACL,MAAMzH,QAAQ,GAAG5I,KAAK,CAACsI,QAAQ,CAAC,CAAC;YACjCtI,KAAK,CAACuP,QAAQ,CAAC3G,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,EAAEqH,QAAQ,EAAEZ,QAAQ,EAAE,CAAC,CAAC;YAC/D;YACA,IAAInP,MAAM,EAAE;cACV,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuP,QAAQ,EAAEvP,CAAC,EAAE,EAAE;gBACjC0P,aAAa,CAAC3R,CAAC,GAAGwR,QAAQ,GAAG,CAAC,GAAGvP,CAAC,CAAC,GAAG2O,QAAQ,CAAC3O,CAAC,CAAC;gBACjD0P,aAAa,CAAC3R,CAAC,GAAGwR,QAAQ,GAAG,CAAC,GAAGvP,CAAC,GAAGuP,QAAQ,CAAC,GAAGZ,QAAQ,CAAC3O,CAAC,CAAC;cAC9D;YACF,CAAC,MAAM;cACL,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuP,QAAQ,EAAEvP,CAAC,EAAE,EAAE;gBACjC0P,aAAa,CAAC3R,CAAC,GAAGwR,QAAQ,GAAG,CAAC,GAAGvP,CAAC,CAAC,GAAG2O,QAAQ,CAAC3O,CAAC,CAAC;cACnD;YACF;UACF;QACF;QACAO,KAAK,CAACoI,UAAU,CAACpD,wBAAwB,CAAChF,KAAK,CAACQ,mBAAmB,CAAC;QACpER,KAAK,CAACoI,UAAU,CAACmG,kBAAkB,CAAC,CAAC;QACrCvO,KAAK,CAACoI,UAAU,CAACoG,eAAe,CAACQ,QAAQ,EAAE/B,aAAa,EAAE,CAAC,EAAEtP,YAAY,CAACqI,KAAK,EAAEmJ,aAAa,CAAC;MACjG,CAAC,MAAM;QACL;QACAD,QAAQ,CAACE,IAAI,CAAC,KAAK,CAAC;QACpBpP,KAAK,CAACoI,UAAU,CAACoG,eAAe,CAACQ,QAAQ,EAAE,CAAC,EAAE,CAAC,EAAErR,YAAY,CAAC8Q,aAAa,EAAES,QAAQ,CAAC;MACxF;MACAlP,KAAK,CAAC+O,gBAAgB,GAAGH,aAAa;MACtC,IAAID,MAAM,EAAE;QACV3O,KAAK,CAACQ,mBAAmB,CAACkO,4BAA4B,CAACC,MAAM,EAAE3O,KAAK,CAACoI,UAAU,EAAEpI,KAAK,CAAC+O,gBAAgB,CAAC;MAC1G;IACF,CAAC,MAAM;MACL/O,KAAK,CAACoI,UAAU,GAAGyG,MAAM,CAACtB,MAAM;MAChCvN,KAAK,CAAC+O,gBAAgB,GAAGF,MAAM,CAACrB,IAAI;IACtC;;IAEA;IACAzN,SAAS,CAACsP,kCAAkC,CAACrN,KAAK,CAAC;;IAEnD;IACA,MAAM;MACJsN;IACF,CAAC,GAAGtP,KAAK,CAACmB,UAAU,CAACoO,iBAAiB,CAAC,CAAC;;IAExC;IACA,IAAIC,KAAK,GAAGxP,KAAK,CAACmB,UAAU,CAACsO,QAAQ,CAAC,CAAC;IACvC,IAAIH,OAAO,KAAKtP,KAAK,CAACmB,UAAU,CAACuO,cAAc,CAAC,CAAC,EAAE;MACjD;MACAF,KAAK,GAAGxP,KAAK,CAACmB,UAAU,CAACwO,kBAAkB,CAACH,KAAK,CAAC;IACpD;;IAEA;IACA;IACA,MAAMI,MAAM,GAAG5P,KAAK,CAACmB,UAAU,CAACC,GAAG,CAAC,qBAAqB,CAAC,GAAGpB,KAAK,CAACmB,UAAU,CAAC0O,WAAW,CAAC,CAAC,CAAC;IAAA,EAC1FC,IAAI,CAACC,KAAK,CAACP,KAAK,CAAC;;IAEnB;IACA,MAAMQ,GAAG,GAAGlG,KAAK,CAACmG,SAAS,CAAC,CAAC;IAC7B,IAAIC,WAAW;IACf,IAAIZ,OAAO,KAAK1Q,WAAW,CAACuR,CAAC,EAAE;MAC7BD,WAAW,GAAGN,MAAM,GAAGI,GAAG,CAAC,CAAC,CAAC;IAC/B;IACA,IAAIV,OAAO,KAAK1Q,WAAW,CAACwR,CAAC,EAAE;MAC7BF,WAAW,GAAGN,MAAM,GAAGI,GAAG,CAAC,CAAC,CAAC;IAC/B;IACA,IAAIV,OAAO,KAAK1Q,WAAW,CAACyR,CAAC,IAAIf,OAAO,KAAK1Q,WAAW,CAAC0R,IAAI,EAAE;MAC7DJ,WAAW,GAAGN,MAAM,GAAGI,GAAG,CAAC,CAAC,CAAC;IAC/B;;IAEA;IACA,MAAMO,QAAQ,GAAI,GAAEf,KAAM,IAAG1F,KAAK,CAAC3K,QAAQ,CAAC,CAAE,IAAGoN,UAAU,CAACpN,QAAQ,CAAC,CAAE,IAAGY,SAAS,CAACZ,QAAQ,CAAC,CAAE,IAAGa,KAAK,CAACmB,UAAU,CAACuO,cAAc,CAAC,CAAE,IAAG1N,KAAK,CAACiB,WAAW,CAAC,CAAC,CAAC8J,oBAAoB,CAAC,CAAE,EAAC;IACnL,IAAI/M,KAAK,CAACwQ,cAAc,KAAKD,QAAQ,EAAE;MACrC;MACA,MAAME,IAAI,GAAG3G,KAAK,CAACU,aAAa,CAAC,CAAC;MAClC,IAAI,CAACxK,KAAK,CAAC+C,aAAa,EAAE;QACxB/C,KAAK,CAAC+C,aAAa,GAAGhF,gBAAgB,CAAC+P,WAAW,CAAC;UACjDC,SAAS,EAAE;QACb,CAAC,CAAC;QACF/N,KAAK,CAAC+C,aAAa,CAAClC,qBAAqB,CAACb,KAAK,CAACQ,mBAAmB,CAAC;MACtE;MACA,IAAIsM,KAAK,KAAKzO,iBAAiB,CAAC2P,OAAO,EAAE;QACvC,IAAI,IAAI0C,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAACC,GAAG,CAACpK,OAAO,CAAC,IAAImG,QAAQ,KAAK/O,YAAY,CAAC8Q,aAAa,IAAI,CAACxP,MAAM,EAAE;UACzFe,KAAK,CAAC+C,aAAa,CAAC6N,iBAAiB,CAAC,IAAI,CAAC;UAC3C5Q,KAAK,CAAC+C,aAAa,CAACkL,qBAAqB,CAAC9P,MAAM,CAAC6P,OAAO,CAAC;QAC3D,CAAC,MAAM;UACLhO,KAAK,CAAC+C,aAAa,CAACkL,qBAAqB,CAAC9P,MAAM,CAAC6P,OAAO,CAAC;QAC3D;QACAhO,KAAK,CAAC+C,aAAa,CAACmL,sBAAsB,CAAC/P,MAAM,CAAC6P,OAAO,CAAC;MAC5D,CAAC,MAAM;QACL,IAAIzH,OAAO,KAAK,CAAC,IAAImG,QAAQ,KAAK/O,YAAY,CAAC8Q,aAAa,IAAI,CAACxP,MAAM,EAAE;UACvEe,KAAK,CAAC+C,aAAa,CAAC6N,iBAAiB,CAAC,IAAI,CAAC;UAC3C5Q,KAAK,CAAC+C,aAAa,CAACkL,qBAAqB,CAAC9P,MAAM,CAAC0S,oBAAoB,CAAC;QACxE,CAAC,MAAM;UACL7Q,KAAK,CAAC+C,aAAa,CAACkL,qBAAqB,CAAC9P,MAAM,CAACgQ,MAAM,CAAC;QAC1D;QACAnO,KAAK,CAAC+C,aAAa,CAACmL,sBAAsB,CAAC/P,MAAM,CAACgQ,MAAM,CAAC;MAC3D;MACAnO,KAAK,CAAC+C,aAAa,CAAC+N,QAAQ,CAAC1S,IAAI,CAAC2S,aAAa,CAAC;MAChD/Q,KAAK,CAAC+C,aAAa,CAACiO,QAAQ,CAAC5S,IAAI,CAAC2S,aAAa,CAAC;MAChD,MAAME,SAAS,GAAGR,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,GAAGlK,OAAO;MAC7C,MAAM2K,QAAQ,GAAG,IAAI7C,YAAY,CAAC,EAAE,CAAC;MACrC,MAAM8C,WAAW,GAAG,IAAI9C,YAAY,CAAC,CAAC,CAAC;MACvC,KAAK,IAAI5O,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QAC1B0R,WAAW,CAAC1R,CAAC,GAAG,CAAC,CAAC,GAAGA,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,GAAG;QACtC0R,WAAW,CAAC1R,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGA,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,GAAG;MAC5C;;MAEA;MACA;MACA;MACA,MAAM2R,UAAU,GAAG,CAACxS,WAAW,CAACyS,CAAC,EAAEzS,WAAW,CAAC0S,CAAC,EAAE1S,WAAW,CAAC2S,CAAC,CAAC,CAACC,QAAQ,CAACxR,KAAK,CAACmB,UAAU,CAACuO,cAAc,CAAC,CAAC,CAAC,GAAGF,KAAK,GAAGI,MAAM;MAC7H,MAAM6B,UAAU,GAAG3H,KAAK,CAAC4H,gBAAgB,CAAC,CAAC;MAC3C,MAAMC,YAAY,GAAGpF,UAAU,CAACqF,OAAO,CAAC,CAAC;MACzC,IAAIC,OAAO,GAAG,IAAI;MAClB;MACA,IAAIvC,OAAO,KAAK1Q,WAAW,CAACuR,CAAC,EAAE;QAC7B0B,OAAO,GAAG,IAAIF,YAAY,CAACG,WAAW,CAACrB,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,GAAGlK,OAAO,CAAC;QACnE,IAAIwL,EAAE,GAAG,CAAC;QACV,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvB,IAAI,CAAC,CAAC,CAAC,EAAEuB,CAAC,EAAE,EAAE;UAChC,KAAK,IAAIzI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkH,IAAI,CAAC,CAAC,CAAC,EAAElH,CAAC,EAAE,EAAE;YAChC,IAAI0I,KAAK,GAAG,CAAC/B,WAAW,GAAG3G,CAAC,GAAGkH,IAAI,CAAC,CAAC,CAAC,GAAGuB,CAAC,GAAGvB,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,IAAIlK,OAAO;YACzEwL,EAAE,GAAG,CAACC,CAAC,GAAGvB,IAAI,CAAC,CAAC,CAAC,GAAGlH,CAAC,IAAIhD,OAAO;YAChC,MAAM2L,GAAG,GAAGD,KAAK,GAAG1L,OAAO;YAC3B,OAAO0L,KAAK,GAAGC,GAAG,EAAE;cAClBL,OAAO,CAACE,EAAE,EAAE,CAAC,GAAGJ,YAAY,CAACM,KAAK,EAAE,CAAC;YACvC;UACF;QACF;QACAxB,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;QACjBA,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;QACjBS,QAAQ,CAAC,CAAC,CAAC,GAAGE,UAAU;QACxBF,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,CAAC,CAAC,GAAGE,UAAU;QACxBF,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,CAAC,CAAC,GAAGE,UAAU;QACxBF,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,CAAC,CAAC,GAAGE,UAAU;QACxBF,QAAQ,CAAC,EAAE,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC5BP,QAAQ,CAAC,EAAE,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;MAC9B,CAAC,MAAM,IAAInC,OAAO,KAAK1Q,WAAW,CAACwR,CAAC,EAAE;QACpCyB,OAAO,GAAG,IAAIF,YAAY,CAACG,WAAW,CAACrB,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,GAAGlK,OAAO,CAAC;QACnE,IAAIwL,EAAE,GAAG,CAAC;QACV,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvB,IAAI,CAAC,CAAC,CAAC,EAAEuB,CAAC,EAAE,EAAE;UAChC,KAAK,IAAIvS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgR,IAAI,CAAC,CAAC,CAAC,EAAEhR,CAAC,EAAE,EAAE;YAChC,IAAIwS,KAAK,GAAG,CAACxS,CAAC,GAAGyQ,WAAW,GAAGO,IAAI,CAAC,CAAC,CAAC,GAAGuB,CAAC,GAAGvB,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,IAAIlK,OAAO;YACzEwL,EAAE,GAAG,CAACC,CAAC,GAAGvB,IAAI,CAAC,CAAC,CAAC,GAAGhR,CAAC,IAAI8G,OAAO;YAChC,MAAM2L,GAAG,GAAGD,KAAK,GAAG1L,OAAO;YAC3B,OAAO0L,KAAK,GAAGC,GAAG,EAAE;cAClBL,OAAO,CAACE,EAAE,EAAE,CAAC,GAAGJ,YAAY,CAACM,KAAK,EAAE,CAAC;YACvC;UACF;QACF;QACAxB,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;QACjBS,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,CAAC,CAAC,GAAGE,UAAU;QACxBF,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,CAAC,CAAC,GAAGE,UAAU;QACxBF,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,CAAC,CAAC,GAAGE,UAAU;QACxBF,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,EAAE,CAAC,GAAGE,UAAU;QACzBF,QAAQ,CAAC,EAAE,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;MAC9B,CAAC,MAAM,IAAInC,OAAO,KAAK1Q,WAAW,CAACyR,CAAC,IAAIf,OAAO,KAAK1Q,WAAW,CAAC0R,IAAI,EAAE;QACpEuB,OAAO,GAAGF,YAAY,CAACQ,QAAQ,CAACjC,WAAW,GAAGe,SAAS,EAAE,CAACf,WAAW,GAAG,CAAC,IAAIe,SAAS,CAAC;QACvFC,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,CAAC,CAAC,GAAGE,UAAU;QACxBF,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,CAAC,CAAC,GAAGE,UAAU;QACxBF,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,CAAC,CAAC,GAAGE,UAAU;QACxBF,QAAQ,CAAC,CAAC,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC3BP,QAAQ,CAAC,EAAE,CAAC,GAAGO,UAAU,CAAC,CAAC,CAAC;QAC5BP,QAAQ,CAAC,EAAE,CAAC,GAAGE,UAAU;MAC3B,CAAC,MAAM;QACLzS,aAAa,CAAC,qCAAqC,CAAC;MACtD;MACA,MAAMyT,GAAG,GAAGpS,KAAK,CAACQ,mBAAmB,CAAC6M,4BAA4B,CAACwE,OAAO,CAAC;MAC3E,IAAI,CAACO,GAAG,EAAE7E,MAAM,EAAE;QAChB,IAAIvN,KAAK,CAACqS,QAAQ,KAAKR,OAAO,EAAE;UAC9B7R,KAAK,CAACQ,mBAAmB,CAAC8R,iCAAiC,CAACtS,KAAK,CAACqS,QAAQ,CAAC;UAC3ErS,KAAK,CAACqS,QAAQ,GAAGR,OAAO;QAC1B;QACA7R,KAAK,CAAC+C,aAAa,CAACwL,kBAAkB,CAAC,CAAC;QACxCvO,KAAK,CAAC+C,aAAa,CAACwP,yBAAyB,CAAC9B,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,EAAElK,OAAO,EAAEgG,UAAU,CAACI,WAAW,CAAC,CAAC,EAAEkF,OAAO,EAAE7R,KAAK,CAACmB,UAAU,CAACqR,yBAAyB,GAAG,CAAC,CAAC;QAC3JxS,KAAK,CAACQ,mBAAmB,CAACkO,4BAA4B,CAACmD,OAAO,EAAE7R,KAAK,CAAC+C,aAAa,EAAE/C,KAAK,CAACwQ,cAAc,CAAC;MAC5G,CAAC,MAAM;QACLxQ,KAAK,CAAC+C,aAAa,GAAGqP,GAAG,CAAC7E,MAAM;QAChCvN,KAAK,CAACwQ,cAAc,GAAG4B,GAAG,CAAC5E,IAAI;MACjC;MACAxN,KAAK,CAAC+C,aAAa,CAACwI,QAAQ,CAAC,CAAC;MAC9BvL,KAAK,CAAC+C,aAAa,CAAC0P,cAAc,CAAC,CAAC;MACpCzS,KAAK,CAAC+C,aAAa,CAAC4I,UAAU,CAAC,CAAC;MAChC,MAAM+G,MAAM,GAAGhV,YAAY,CAACoQ,WAAW,CAAC;QACtC9O,kBAAkB,EAAE,CAAC;QACrB2T,MAAM,EAAEzB;MACV,CAAC,CAAC;MACFwB,MAAM,CAACE,OAAO,CAAC,QAAQ,CAAC;MACxB,MAAMC,OAAO,GAAGnV,YAAY,CAACoQ,WAAW,CAAC;QACvC9O,kBAAkB,EAAE,CAAC;QACrB2T,MAAM,EAAExB;MACV,CAAC,CAAC;MACF0B,OAAO,CAACD,OAAO,CAAC,SAAS,CAAC;MAC1B,MAAME,SAAS,GAAG,IAAIC,WAAW,CAAC,CAAC,CAAC;MACpCD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;MAChBA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;MAChBA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;MAChBA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;MAChBA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;MAChBA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;MAChBA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;MAChBA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;MAChB,MAAME,KAAK,GAAGtV,YAAY,CAACoQ,WAAW,CAAC;QACrC9O,kBAAkB,EAAE,CAAC;QACrB2T,MAAM,EAAEG;MACV,CAAC,CAAC;MACF9S,KAAK,CAACY,IAAI,CAAC4E,OAAO,CAAC,CAAC,CAACyN,SAAS,CAACD,KAAK,EAAE,OAAO,EAAE9U,cAAc,CAACgV,OAAO,EAAE;QACrER,MAAM;QACNG,OAAO;QACPM,UAAU,EAAE;MACd,CAAC,CAAC;MACFnT,KAAK,CAAC0F,YAAY,CAACR,QAAQ,CAAC,CAAC;MAC7BlF,KAAK,CAACwQ,cAAc,GAAGD,QAAQ;IACjC;EACF,CAAC;EACDxQ,SAAS,CAACsP,kCAAkC,GAAGvF,KAAK,IAAI;IACtD,IAAI,CAAC9J,KAAK,CAACsI,4BAA4B,EAAE;MACvCtI,KAAK,CAACsI,4BAA4B,GAAGvK,gBAAgB,CAAC+P,WAAW,CAAC;QAChEC,SAAS,EAAE;MACb,CAAC,CAAC;MACF/N,KAAK,CAACsI,4BAA4B,CAACzH,qBAAqB,CAACb,KAAK,CAACQ,mBAAmB,CAAC;IACrF;IACA,MAAM4S,0BAA0B,GAAGtJ,KAAK,CAAC7G,WAAW,CAAC,CAAC,CAACoQ,wBAAwB,CAAC,CAAC;IACjF,MAAMC,IAAI,GAAGtT,KAAK,CAACQ,mBAAmB,CAAC6M,4BAA4B,CAAC+F,0BAA0B,CAAC;;IAE/F;IACA;IACA;IACA,MAAM7C,QAAQ,GAAI,GAAE6C,0BAA0B,CAACG,IAAI,CAAC,GAAG,CAAE,EAAC;IAC1D,MAAMC,QAAQ,GAAG,CAACF,IAAI,EAAE/F,MAAM,IAAI+F,IAAI,EAAE9F,IAAI,KAAK+C,QAAQ,IAAIvQ,KAAK,CAACyT,kCAAkC,KAAKlD,QAAQ;IAClH,IAAIiD,QAAQ,EAAE;MACZ,MAAME,MAAM,GAAG,IAAI;MACnB,MAAMC,OAAO,GAAG,CAAC;MACjB,MAAMC,KAAK,GAAGF,MAAM,GAAGC,OAAO;MAC9B,MAAME,MAAM,GAAG,IAAIhG,UAAU,CAAC+F,KAAK,CAAC;;MAEpC;MACA,KAAK,IAAInU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiU,MAAM,EAAE,EAAEjU,CAAC,EAAE;QAC/B;QACA;QACA,MAAMqU,SAAS,GAAGV,0BAA0B,CAAC3T,CAAC,CAAC,IAAI2T,0BAA0B,CAAC,CAAC,CAAC;QAChFS,MAAM,CAACpU,CAAC,CAAC,GAAGqU,SAAS;MACvB;MACA9T,KAAK,CAACsI,4BAA4B,CAACtD,wBAAwB,CAAChF,KAAK,CAACQ,mBAAmB,CAAC;MACtFR,KAAK,CAACsI,4BAA4B,CAACiG,kBAAkB,CAAC,CAAC;MACvDvO,KAAK,CAACsI,4BAA4B,CAAC2F,qBAAqB,CAAC9P,MAAM,CAAC6P,OAAO,CAAC;MACxEhO,KAAK,CAACsI,4BAA4B,CAAC4F,sBAAsB,CAAC/P,MAAM,CAAC6P,OAAO,CAAC;;MAEzE;MACAhO,KAAK,CAACsI,4BAA4B,CAACkG,eAAe,CAACkF,MAAM,EAAEC,OAAO,EAAE,CAAC,EAAEhW,YAAY,CAAC8Q,aAAa,EAAEoF,MAAM,CAAC;MAC1G7T,KAAK,CAACyT,kCAAkC,GAAGlD,QAAQ;MACnD,IAAI6C,0BAA0B,EAAE;QAC9BpT,KAAK,CAACQ,mBAAmB,CAACkO,4BAA4B,CAAC0E,0BAA0B,EAAEpT,KAAK,CAACsI,4BAA4B,EAAEtI,KAAK,CAACyT,kCAAkC,CAAC;MAClK;IACF,CAAC,MAAM;MACLzT,KAAK,CAACsI,4BAA4B,GAAGgL,IAAI,CAAC/F,MAAM;MAChDvN,KAAK,CAACyT,kCAAkC,GAAGH,IAAI,CAAC9F,IAAI;IACtD;EACF,CAAC;EACDzN,SAAS,CAAC+K,mBAAmB,GAAG,MAAM;IACpC,IAAI9K,KAAK,CAAC+T,iBAAiB,EAAE;MAC3B,OAAO,CAAC/T,KAAK,CAACgU,mBAAmB,EAAEhU,KAAK,CAACiU,oBAAoB,CAAC;IAChE;IACA,MAAM;MACJC,KAAK;MACLC;IACF,CAAC,GAAGnU,KAAK,CAACO,eAAe,CAAC6T,qBAAqB,CAAC,CAAC;IACjD,OAAO,CAACF,KAAK,EAAEC,KAAK,CAAC;EACvB,CAAC;EACDpU,SAAS,CAACgL,qBAAqB,GAAG,MAAM;IACtC,MAAM;MACJsJ,UAAU;MACVC;IACF,CAAC,GAAGtU,KAAK,CAACO,eAAe,CAAC6T,qBAAqB,CAAC,CAAC;IACjD,OAAO,CAACC,UAAU,EAAEC,UAAU,CAAC;EACjC,CAAC;AACH;;AAEA;AACA;AACA;;AAEA,MAAMC,cAAc,GAAG;EACrB7O,YAAY,EAAE,CAAC;EACf8K,cAAc,EAAE,IAAI;EACpBzN,aAAa,EAAE,IAAI;EACnBnC,IAAI,EAAE,IAAI;EACVqI,QAAQ,EAAE,IAAI;EACdJ,WAAW,EAAE,IAAI;EACjBX,YAAY,EAAE,IAAI;EAClBE,UAAU,EAAE,IAAI;EAChBE,4BAA4B,EAAE,IAAI;EAClCmL,kCAAkC,EAAE,IAAI;EACxCtP,wBAAwB,EAAE,KAAK;EAC/BxC,oBAAoB,EAAE,KAAK;EAC3B2C,qBAAqB,EAAE,CAAC;EACxB+N,QAAQ,EAAE;AACZ,CAAC;;AAED;;AAEA,SAASmC,MAAMA,CAACzU,SAAS,EAAEC,KAAK,EAAE;EAChC,IAAIyU,aAAa,GAAGC,SAAS,CAAChV,MAAM,GAAG,CAAC,IAAIgV,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;EAC1FE,MAAM,CAACC,MAAM,CAAC7U,KAAK,EAAEuU,cAAc,EAAEE,aAAa,CAAC;;EAEnD;EACAxW,WAAW,CAACuW,MAAM,CAACzU,SAAS,EAAEC,KAAK,EAAEyU,aAAa,CAAC;EACnDhW,0BAA0B,CAACqW,sCAAsC,CAAC/U,SAAS,EAAEC,KAAK,EAAEyU,aAAa,CAAC;EAClGhW,0BAA0B,CAACsW,qCAAqC,CAAChV,SAAS,EAAEC,KAAK,EAAEyU,aAAa,CAAC;EACjGzU,KAAK,CAACY,IAAI,GAAGhD,SAAS,CAACkQ,WAAW,CAAC,CAAC;EACpC9N,KAAK,CAACiJ,QAAQ,GAAGpM,IAAI,CAACmY,QAAQ,CAAC,IAAIC,YAAY,CAAC,EAAE,CAAC,CAAC;EACpDjV,KAAK,CAAC6I,WAAW,GAAGhM,IAAI,CAACmY,QAAQ,CAAC,IAAIC,YAAY,CAAC,EAAE,CAAC,CAAC;EACvDjV,KAAK,CAAC4K,iBAAiB,GAAG/N,IAAI,CAACmY,QAAQ,CAAC,IAAIC,YAAY,CAAC,EAAE,CAAC,CAAC;EAC7DjV,KAAK,CAACkV,SAAS,GAAGrY,IAAI,CAACmY,QAAQ,CAAC,IAAIC,YAAY,CAAC,EAAE,CAAC,CAAC;EACrDjV,KAAK,CAACmV,eAAe,GAAGrY,IAAI,CAACkY,QAAQ,CAAC,IAAIC,YAAY,CAAC,CAAC,CAAC,CAAC;EAC1DjV,KAAK,CAACoV,WAAW,GAAGvY,IAAI,CAACmY,QAAQ,CAAC,IAAIC,YAAY,CAAC,EAAE,CAAC,CAAC;EACvDjV,KAAK,CAACqV,gBAAgB,GAAGxY,IAAI,CAACmY,QAAQ,CAAC,IAAIC,YAAY,CAAC,EAAE,CAAC,CAAC;;EAE5D;EACA9X,MAAM,CAAC4C,SAAS,EAAEC,KAAK,EAAE,EAAE,CAAC;EAC5BA,KAAK,CAAC0F,YAAY,GAAG,CAAC,CAAC;EACvBrI,GAAG,CAAC2C,KAAK,CAAC0F,YAAY,CAAC;;EAEvB;EACA5F,oBAAoB,CAACC,SAAS,EAAEC,KAAK,CAAC;AACxC;;AAEA;;AAEA,MAAM8N,WAAW,GAAG7Q,aAAa,CAACuX,MAAM,EAAE,sBAAsB,CAAC;;AAEjE;;AAEA,IAAIc,cAAc,GAAG;EACnBxH,WAAW;EACX0G;AACF,CAAC;;AAED;AACA9V,gBAAgB,CAAC,wBAAwB,EAAEoP,WAAW,CAAC;AAEvD,SAASwH,cAAc,IAAIC,OAAO,EAAEf,MAAM,EAAE1G,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}