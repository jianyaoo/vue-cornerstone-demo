{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { mat3, mat4 } from 'gl-matrix';\nimport { n as newInstance$1, o as obj, c as macro } from '../../macros2.js';\nimport vtkBufferObject from './BufferObject.js';\nimport vtkHardwareSelector from './HardwareSelector.js';\nimport vtkProperty from '../Core/Property.js';\nimport vtkOpenGLPolyDataMapper from './PolyDataMapper.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nconst {\n  vtkErrorMacro\n} = macro;\nconst {\n  Representation\n} = vtkProperty;\nconst {\n  ObjectType\n} = vtkBufferObject;\nconst {\n  PassTypes\n} = vtkHardwareSelector;\nconst StartEvent = {\n  type: 'StartEvent'\n};\nconst EndEvent = {\n  type: 'EndEvent'\n};\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLSphereMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLGlyph3DMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLGlyph3DMapper');\n\n  // Capture 'parentClass' api for internal use\n  const superClass = {\n    ...publicAPI\n  };\n  publicAPI.renderPiece = (ren, actor) => {\n    publicAPI.invokeEvent(StartEvent);\n    if (!model.renderable.getStatic()) {\n      model.renderable.update();\n    }\n    model.currentInput = model.renderable.getInputData(1);\n    publicAPI.invokeEvent(EndEvent);\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n\n    // if there are no points then we are done\n    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {\n      return;\n    }\n\n    // apply faceCulling\n    const gl = model.context;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.hardwareSupport = true;\n      model.extension = null;\n    } else if (!model.extension) {\n      model.extension = model.context.getExtension('ANGLE_instanced_arrays');\n      model.hardwareSupport = !!model.extension;\n    }\n    // to test without extension support uncomment the next two lines\n    // model.extension = null;\n    // model.hardwareSupport = !!model.extension;\n\n    const backfaceCulling = actor.getProperty().getBackfaceCulling();\n    const frontfaceCulling = actor.getProperty().getFrontfaceCulling();\n    if (!backfaceCulling && !frontfaceCulling) {\n      model._openGLRenderWindow.disableCullFace();\n    } else if (frontfaceCulling) {\n      model._openGLRenderWindow.enableCullFace();\n      gl.cullFace(gl.FRONT);\n    } else {\n      model._openGLRenderWindow.enableCullFace();\n      gl.cullFace(gl.BACK);\n    }\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n  publicAPI.multiply4x4WithOffset = (out, a, b, off) => {\n    const a00 = a[0];\n    const a01 = a[1];\n    const a02 = a[2];\n    const a03 = a[3];\n    const a10 = a[4];\n    const a11 = a[5];\n    const a12 = a[6];\n    const a13 = a[7];\n    const a20 = a[8];\n    const a21 = a[9];\n    const a22 = a[10];\n    const a23 = a[11];\n    const a30 = a[12];\n    const a31 = a[13];\n    const a32 = a[14];\n    const a33 = a[15];\n\n    // Cache only the current line of the second matrix\n    let b0 = b[off];\n    let b1 = b[off + 1];\n    let b2 = b[off + 2];\n    let b3 = b[off + 3];\n    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    b0 = b[off + 4];\n    b1 = b[off + 5];\n    b2 = b[off + 6];\n    b3 = b[off + 7];\n    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    b0 = b[off + 8];\n    b1 = b[off + 9];\n    b2 = b[off + 10];\n    b3 = b[off + 11];\n    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    b0 = b[off + 12];\n    b1 = b[off + 13];\n    b2 = b[off + 14];\n    b3 = b[off + 15];\n    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  };\n  publicAPI.replaceShaderNormal = (shaders, ren, actor) => {\n    if (model.hardwareSupport) {\n      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n      if (lastLightComplexity > 0) {\n        let VSSource = shaders.Vertex;\n        if (model.lastBoundBO.getCABO().getNormalOffset()) {\n          VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Normal::Dec', ['attribute vec3 normalMC;', 'attribute mat3 gNormal;', 'uniform mat3 normalMatrix;', 'varying vec3 normalVCVSOutput;']).result;\n          VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Normal::Impl', ['normalVCVSOutput = normalMatrix * gNormal * normalMC;']).result;\n        }\n        shaders.Vertex = VSSource;\n      }\n    }\n    superClass.replaceShaderNormal(shaders, ren, actor);\n  };\n  publicAPI.replaceShaderColor = (shaders, ren, actor) => {\n    if (model.hardwareSupport && model.renderable.getColorArray()) {\n      let VSSource = shaders.Vertex;\n      let GSSource = shaders.Geometry;\n      let FSSource = shaders.Fragment;\n      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n\n      // create the material/color property declarations, and VS implementation\n      // these are always defined\n      let colorDec = ['uniform float ambient;', 'uniform float diffuse;', 'uniform float specular;', 'uniform float opacityUniform; // the fragment opacity'];\n      // add more for specular\n      if (lastLightComplexity) {\n        colorDec = colorDec.concat(['uniform vec3 specularColorUniform;', 'uniform float specularPowerUniform;']);\n      }\n\n      // now handle the more complex fragment shader implementation\n      // the following are always defined variables.  We start\n      // by assigning a default value from the uniform\n      let colorImpl = ['vec3 ambientColor;', '  vec3 diffuseColor;', '  float opacity;'];\n      if (lastLightComplexity) {\n        colorImpl = colorImpl.concat(['  vec3 specularColor;', '  float specularPower;']);\n      }\n      colorImpl = colorImpl.concat(['  opacity = opacityUniform;']);\n      if (lastLightComplexity) {\n        colorImpl = colorImpl.concat(['  specularColor = specularColorUniform;', '  specularPower = specularPowerUniform;']);\n      }\n      if (!model.drawingEdges) {\n        colorDec = colorDec.concat(['varying vec4 vertexColorVSOutput;']);\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Dec', ['attribute vec4 gColor;', 'varying vec4 vertexColorVSOutput;']).result;\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Impl', ['vertexColorVSOutput = gColor;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Dec', ['in vec4 vertexColorVSOutput[];', 'out vec4 vertexColorGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Impl', ['vertexColorGSOutput = vertexColorVSOutput[i];']).result;\n        colorImpl = colorImpl.concat(['  diffuseColor = vertexColorVSOutput.rgb;', '  ambientColor = vertexColorVSOutput.rgb;', '  opacity = opacity*vertexColorVSOutput.a;']);\n      }\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Dec', colorDec).result;\n      shaders.Vertex = VSSource;\n      shaders.Geometry = GSSource;\n      shaders.Fragment = FSSource;\n    }\n    superClass.replaceShaderColor(shaders, ren, actor);\n  };\n  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {\n    if (model.hardwareSupport) {\n      let VSSource = shaders.Vertex;\n\n      // do we need the vertex in the shader in View Coordinates\n      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n      if (lastLightComplexity > 0) {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['vec4 gVertexMC = gMatrix * vertexMC;', 'vertexVCVSOutput = MCVCMatrix * gVertexMC;', '  gl_Position = MCPCMatrix * gVertexMC;']).result;\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['attribute mat4 gMatrix;', 'uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;\n      } else {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['attribute mat4 gMatrix;', 'uniform mat4 MCPCMatrix;']).result;\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['vec4 gVertexMC = gMatrix * vertexMC;', '  gl_Position = MCPCMatrix * gVertexMC;']).result;\n      }\n      shaders.Vertex = VSSource;\n    }\n    superClass.replaceShaderPositionVC(shaders, ren, actor);\n  };\n  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {\n    if (model.hardwareSupport) {\n      let FSSource = shaders.Fragment;\n      let VSSource = shaders.Vertex;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Picking::Dec', ['attribute vec3 mapperIndexVS;', 'varying vec3 mapperIndexVSOutput;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Picking::Impl', '  mapperIndexVSOutput = mapperIndexVS;').result;\n      shaders.Vertex = VSSource;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', ['varying vec3 mapperIndexVSOutput;', 'uniform vec3 mapperIndex;', 'uniform int picking;']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', ['  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);', '  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];']).result;\n      shaders.Fragment = FSSource;\n    } else {\n      superClass.replaceShaderPicking(shaders, ren, actor);\n    }\n  };\n  publicAPI.updateGlyphShaderParameters = (normalMatrixUsed, mcvcMatrixUsed, cellBO, carray, garray, narray, p, selector) => {\n    const program = cellBO.getProgram();\n    if (normalMatrixUsed) {\n      const a = model.normalMatrix;\n      const b = narray;\n      const ofs = p * 9;\n      const out = model.tmpMat3;\n      const a00 = a[0];\n      const a01 = a[1];\n      const a02 = a[2];\n      const a10 = a[3];\n      const a11 = a[4];\n      const a12 = a[5];\n      const a20 = a[6];\n      const a21 = a[7];\n      const a22 = a[8];\n      const b00 = b[ofs];\n      const b01 = b[ofs + 1];\n      const b02 = b[ofs + 2];\n      const b10 = b[ofs + 3];\n      const b11 = b[ofs + 4];\n      const b12 = b[ofs + 5];\n      const b20 = b[ofs + 6];\n      const b21 = b[ofs + 7];\n      const b22 = b[ofs + 8];\n      out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n      out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n      out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n      out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n      out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n      out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n      out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n      out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n      out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n      program.setUniformMatrix3x3('normalMatrix', model.tmpMat3);\n    }\n    publicAPI.multiply4x4WithOffset(model.tmpMat4, model.mcpcMatrix, garray, p * 16);\n    program.setUniformMatrix('MCPCMatrix', model.tmpMat4);\n    if (mcvcMatrixUsed) {\n      publicAPI.multiply4x4WithOffset(model.tmpMat4, model.mcvcMatrix, garray, p * 16);\n      program.setUniformMatrix('MCVCMatrix', model.tmpMat4);\n    }\n\n    // set color\n    if (carray) {\n      const cdata = carray.getData();\n      model.tmpColor[0] = cdata[p * 4] / 255.0;\n      model.tmpColor[1] = cdata[p * 4 + 1] / 255.0;\n      model.tmpColor[2] = cdata[p * 4 + 2] / 255.0;\n      program.setUniform3fArray('ambientColorUniform', model.tmpColor);\n      program.setUniform3fArray('diffuseColorUniform', model.tmpColor);\n    }\n    if (selector) {\n      program.setUniform3fArray('mapperIndex', selector.getPropColorValue());\n    }\n  };\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const representation = actor.getProperty().getRepresentation();\n    const gl = model.context;\n    const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;\n\n    // [WMVP]C == {world, model, view, projection} coordinates\n    // E.g., WCPC == world to projection coordinate transformation\n    const keyMats = model.openGLCamera.getKeyMatrices(ren);\n    const actMats = model.openGLActor.getKeyMatrices();\n\n    // precompute the actor+camera mats once\n    mat3.multiply(model.normalMatrix, keyMats.normalMatrix, actMats.normalMatrix);\n    mat4.multiply(model.mcpcMatrix, keyMats.wcpc, actMats.mcwc);\n    mat4.multiply(model.mcvcMatrix, keyMats.wcvc, actMats.mcwc);\n    const garray = model.renderable.getMatrixArray();\n    const narray = model.renderable.getNormalArray();\n    const carray = model.renderable.getColorArray();\n    const numPts = garray.length / 16;\n    let compositePass = false;\n    if (model._openGLRenderer.getSelector()) {\n      if (model._openGLRenderer.getSelector().getCurrentPass() === PassTypes.COMPOSITE_INDEX_PASS) {\n        compositePass = true;\n      }\n    }\n\n    // for every primitive type\n    for (let i = model.primTypes.Start; i < model.primTypes.End; i++) {\n      // if there are entries\n      const cabo = model.primitives[i].getCABO();\n      if (cabo.getElementCount()) {\n        // are we drawing edges\n        model.drawingEdges = drawSurfaceWithEdges && (i === model.primTypes.TrisEdges || i === model.primTypes.TriStripsEdges);\n        model.lastBoundBO = model.primitives[i];\n        model.primitives[i].updateShaders(ren, actor, publicAPI);\n        const program = model.primitives[i].getProgram();\n        const mode = model.primitives[i].getOpenGLMode(representation);\n        const normalMatrixUsed = program.isUniformUsed('normalMatrix');\n        const mcvcMatrixUsed = program.isUniformUsed('MCVCMatrix');\n        if (model.hardwareSupport) {\n          if (model.extension) {\n            model.extension.drawArraysInstancedANGLE(mode, 0, cabo.getElementCount(), numPts);\n          } else {\n            gl.drawArraysInstanced(mode, 0, cabo.getElementCount(), numPts);\n          }\n        } else {\n          // draw the array multiple times with different cam matrix\n          for (let p = 0; p < numPts; ++p) {\n            if (compositePass) {\n              model._openGLRenderer.getSelector().renderCompositeIndex(p);\n            }\n            publicAPI.updateGlyphShaderParameters(normalMatrixUsed, mcvcMatrixUsed, model.primitives[i], carray, garray, narray, p, compositePass ? model._openGLRenderer.getSelector() : null);\n            gl.drawArrays(mode, 0, cabo.getElementCount());\n          }\n        }\n      }\n    }\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    if (cellBO.getCABO().getElementCount() && (model.glyphBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      if (cellBO.getProgram().isAttributeUsed('gMatrix')) {\n        if (!cellBO.getVAO().addAttributeMatrixWithDivisor(cellBO.getProgram(), model.matrixBuffer, 'gMatrix', 0, 64, model.context.FLOAT, 4, false, 1)) {\n          vtkErrorMacro('Error setting gMatrix in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('gMatrix');\n      }\n      if (cellBO.getProgram().isAttributeUsed('gNormal')) {\n        if (!cellBO.getVAO().addAttributeMatrixWithDivisor(cellBO.getProgram(), model.normalBuffer, 'gNormal', 0, 36, model.context.FLOAT, 3, false, 1)) {\n          vtkErrorMacro('Error setting gNormal in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('gNormal');\n      }\n      if (cellBO.getProgram().isAttributeUsed('gColor')) {\n        if (!cellBO.getVAO().addAttributeArrayWithDivisor(cellBO.getProgram(), model.colorBuffer, 'gColor', 0, 4, model.context.UNSIGNED_BYTE, 4, true, 1, false)) {\n          vtkErrorMacro('Error setting gColor in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('gColor');\n      }\n      if (cellBO.getProgram().isAttributeUsed('mapperIndexVS')) {\n        if (!cellBO.getVAO().addAttributeArrayWithDivisor(cellBO.getProgram(), model.pickBuffer, 'mapperIndexVS', 0, 4, model.context.UNSIGNED_BYTE, 4, true, 1, false)) {\n          vtkErrorMacro('Error setting mapperIndexVS in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('mapperIndexVS');\n      }\n      superClass.setMapperShaderParameters(cellBO, ren, actor);\n      cellBO.getAttributeUpdateTime().modified();\n      return;\n    }\n    superClass.setMapperShaderParameters(cellBO, ren, actor);\n  };\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {\n    model.renderable.buildArrays();\n\n    // first do a coarse check\n    // Note that the actor's mtime includes it's properties mtime\n    const vmtime = model.VBOBuildTime.getMTime();\n    if (vmtime < model.renderable.getBuildTime().getMTime()) {\n      return true;\n    }\n    return superClass.getNeedToRebuildBufferObjects(ren, actor);\n  };\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    if (superClass.getNeedToRebuildShaders(cellBO, ren, actor) || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    if (model.hardwareSupport) {\n      // update the buffer objects if needed\n      const garray = model.renderable.getMatrixArray();\n      const narray = model.renderable.getNormalArray();\n      const carray = model.renderable.getColorArray();\n      if (!model.matrixBuffer) {\n        model.matrixBuffer = vtkBufferObject.newInstance();\n        model.matrixBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);\n        model.normalBuffer = vtkBufferObject.newInstance();\n        model.normalBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);\n        model.colorBuffer = vtkBufferObject.newInstance();\n        model.colorBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);\n        model.pickBuffer = vtkBufferObject.newInstance();\n        model.pickBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n      if (model.renderable.getBuildTime().getMTime() > model.glyphBOBuildTime.getMTime()) {\n        model.matrixBuffer.upload(garray, ObjectType.ARRAY_BUFFER);\n        model.normalBuffer.upload(narray, ObjectType.ARRAY_BUFFER);\n        if (carray) {\n          model.colorBuffer.upload(carray.getData(), ObjectType.ARRAY_BUFFER);\n        } else {\n          model.colorBuffer.releaseGraphicsResources();\n        }\n        const numPts = garray.length / 16;\n        const parray = new Uint8Array(4 * numPts);\n        for (let i = 0; i < numPts; ++i) {\n          let value = i + 1;\n          const offset = i * 4;\n          parray[offset] = value % 256;\n          value -= parray[offset];\n          value /= 256;\n          parray[offset + 1] = value % 256;\n          value -= parray[offset + 1];\n          value /= 256;\n          parray[offset + 2] = value % 256;\n          parray[offset + 3] = 255;\n        }\n        model.pickBuffer.upload(parray, ObjectType.ARRAY_BUFFER);\n        model.glyphBOBuildTime.modified();\n      }\n    }\n    return superClass.buildBufferObjects(ren, actor);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  normalMatrix: null,\n  mcpcMatrix: null,\n  mcwcMatrix: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkOpenGLPolyDataMapper.extend(publicAPI, model, initialValues);\n  model.tmpMat3 = mat3.identity(new Float64Array(9));\n  model.normalMatrix = mat3.identity(new Float64Array(9));\n  model.mcpcMatrix = mat4.identity(new Float64Array(16));\n  model.mcvcMatrix = mat4.identity(new Float64Array(16));\n  model.tmpColor = [];\n  model.glyphBOBuildTime = {};\n  obj(model.glyphBOBuildTime, {\n    mtime: 0\n  });\n\n  // Object methods\n  vtkOpenGLGlyph3DMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLGlyph3DMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkGlyph3DMapper = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkGlyph3DMapper', newInstance);\nexport { vtkGlyph3DMapper as default, extend, newInstance };","map":{"version":3,"names":["mat3","mat4","n","newInstance$1","o","obj","c","macro","vtkBufferObject","vtkHardwareSelector","vtkProperty","vtkOpenGLPolyDataMapper","vtkShaderProgram","registerOverride","vtkErrorMacro","Representation","ObjectType","PassTypes","StartEvent","type","EndEvent","vtkOpenGLGlyph3DMapper","publicAPI","model","classHierarchy","push","superClass","renderPiece","ren","actor","invokeEvent","renderable","getStatic","update","currentInput","getInputData","getPoints","getNumberOfValues","gl","context","_openGLRenderWindow","getWebgl2","hardwareSupport","extension","getExtension","backfaceCulling","getProperty","getBackfaceCulling","frontfaceCulling","getFrontfaceCulling","disableCullFace","enableCullFace","cullFace","FRONT","BACK","renderPieceStart","renderPieceDraw","renderPieceFinish","multiply4x4WithOffset","out","a","b","off","a00","a01","a02","a03","a10","a11","a12","a13","a20","a21","a22","a23","a30","a31","a32","a33","b0","b1","b2","b3","replaceShaderNormal","shaders","lastLightComplexity","lastBoundBO","getReferenceByName","VSSource","Vertex","getCABO","getNormalOffset","substitute","result","replaceShaderColor","getColorArray","GSSource","Geometry","FSSource","Fragment","colorDec","concat","colorImpl","drawingEdges","replaceShaderPositionVC","replaceShaderPicking","updateGlyphShaderParameters","normalMatrixUsed","mcvcMatrixUsed","cellBO","carray","garray","narray","p","selector","program","getProgram","normalMatrix","ofs","tmpMat3","b00","b01","b02","b10","b11","b12","b20","b21","b22","setUniformMatrix3x3","tmpMat4","mcpcMatrix","setUniformMatrix","mcvcMatrix","cdata","getData","tmpColor","setUniform3fArray","getPropColorValue","representation","getRepresentation","drawSurfaceWithEdges","getEdgeVisibility","SURFACE","keyMats","openGLCamera","getKeyMatrices","actMats","openGLActor","multiply","wcpc","mcwc","wcvc","getMatrixArray","getNormalArray","numPts","length","compositePass","_openGLRenderer","getSelector","getCurrentPass","COMPOSITE_INDEX_PASS","i","primTypes","Start","End","cabo","primitives","getElementCount","TrisEdges","TriStripsEdges","updateShaders","mode","getOpenGLMode","isUniformUsed","drawArraysInstancedANGLE","drawArraysInstanced","renderCompositeIndex","drawArrays","setMapperShaderParameters","glyphBOBuildTime","getMTime","getAttributeUpdateTime","getShaderSourceTime","isAttributeUsed","getVAO","addAttributeMatrixWithDivisor","matrixBuffer","FLOAT","removeAttributeArray","normalBuffer","addAttributeArrayWithDivisor","colorBuffer","UNSIGNED_BYTE","pickBuffer","modified","getNeedToRebuildBufferObjects","buildArrays","vmtime","VBOBuildTime","getBuildTime","getNeedToRebuildShaders","buildBufferObjects","newInstance","setOpenGLRenderWindow","upload","ARRAY_BUFFER","releaseGraphicsResources","parray","Uint8Array","value","offset","DEFAULT_VALUES","mcwcMatrix","extend","initialValues","arguments","undefined","Object","assign","identity","Float64Array","mtime","vtkGlyph3DMapper","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/OpenGL/Glyph3DMapper.js"],"sourcesContent":["import { mat3, mat4 } from 'gl-matrix';\nimport { n as newInstance$1, o as obj, c as macro } from '../../macros2.js';\nimport vtkBufferObject from './BufferObject.js';\nimport vtkHardwareSelector from './HardwareSelector.js';\nimport vtkProperty from '../Core/Property.js';\nimport vtkOpenGLPolyDataMapper from './PolyDataMapper.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nconst {\n  Representation\n} = vtkProperty;\nconst {\n  ObjectType\n} = vtkBufferObject;\nconst {\n  PassTypes\n} = vtkHardwareSelector;\nconst StartEvent = {\n  type: 'StartEvent'\n};\nconst EndEvent = {\n  type: 'EndEvent'\n};\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLSphereMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLGlyph3DMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLGlyph3DMapper');\n\n  // Capture 'parentClass' api for internal use\n  const superClass = {\n    ...publicAPI\n  };\n  publicAPI.renderPiece = (ren, actor) => {\n    publicAPI.invokeEvent(StartEvent);\n    if (!model.renderable.getStatic()) {\n      model.renderable.update();\n    }\n    model.currentInput = model.renderable.getInputData(1);\n    publicAPI.invokeEvent(EndEvent);\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n\n    // if there are no points then we are done\n    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {\n      return;\n    }\n\n    // apply faceCulling\n    const gl = model.context;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.hardwareSupport = true;\n      model.extension = null;\n    } else if (!model.extension) {\n      model.extension = model.context.getExtension('ANGLE_instanced_arrays');\n      model.hardwareSupport = !!model.extension;\n    }\n    // to test without extension support uncomment the next two lines\n    // model.extension = null;\n    // model.hardwareSupport = !!model.extension;\n\n    const backfaceCulling = actor.getProperty().getBackfaceCulling();\n    const frontfaceCulling = actor.getProperty().getFrontfaceCulling();\n    if (!backfaceCulling && !frontfaceCulling) {\n      model._openGLRenderWindow.disableCullFace();\n    } else if (frontfaceCulling) {\n      model._openGLRenderWindow.enableCullFace();\n      gl.cullFace(gl.FRONT);\n    } else {\n      model._openGLRenderWindow.enableCullFace();\n      gl.cullFace(gl.BACK);\n    }\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n  publicAPI.multiply4x4WithOffset = (out, a, b, off) => {\n    const a00 = a[0];\n    const a01 = a[1];\n    const a02 = a[2];\n    const a03 = a[3];\n    const a10 = a[4];\n    const a11 = a[5];\n    const a12 = a[6];\n    const a13 = a[7];\n    const a20 = a[8];\n    const a21 = a[9];\n    const a22 = a[10];\n    const a23 = a[11];\n    const a30 = a[12];\n    const a31 = a[13];\n    const a32 = a[14];\n    const a33 = a[15];\n\n    // Cache only the current line of the second matrix\n    let b0 = b[off];\n    let b1 = b[off + 1];\n    let b2 = b[off + 2];\n    let b3 = b[off + 3];\n    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    b0 = b[off + 4];\n    b1 = b[off + 5];\n    b2 = b[off + 6];\n    b3 = b[off + 7];\n    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    b0 = b[off + 8];\n    b1 = b[off + 9];\n    b2 = b[off + 10];\n    b3 = b[off + 11];\n    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    b0 = b[off + 12];\n    b1 = b[off + 13];\n    b2 = b[off + 14];\n    b3 = b[off + 15];\n    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  };\n  publicAPI.replaceShaderNormal = (shaders, ren, actor) => {\n    if (model.hardwareSupport) {\n      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n      if (lastLightComplexity > 0) {\n        let VSSource = shaders.Vertex;\n        if (model.lastBoundBO.getCABO().getNormalOffset()) {\n          VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Normal::Dec', ['attribute vec3 normalMC;', 'attribute mat3 gNormal;', 'uniform mat3 normalMatrix;', 'varying vec3 normalVCVSOutput;']).result;\n          VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Normal::Impl', ['normalVCVSOutput = normalMatrix * gNormal * normalMC;']).result;\n        }\n        shaders.Vertex = VSSource;\n      }\n    }\n    superClass.replaceShaderNormal(shaders, ren, actor);\n  };\n  publicAPI.replaceShaderColor = (shaders, ren, actor) => {\n    if (model.hardwareSupport && model.renderable.getColorArray()) {\n      let VSSource = shaders.Vertex;\n      let GSSource = shaders.Geometry;\n      let FSSource = shaders.Fragment;\n      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n\n      // create the material/color property declarations, and VS implementation\n      // these are always defined\n      let colorDec = ['uniform float ambient;', 'uniform float diffuse;', 'uniform float specular;', 'uniform float opacityUniform; // the fragment opacity'];\n      // add more for specular\n      if (lastLightComplexity) {\n        colorDec = colorDec.concat(['uniform vec3 specularColorUniform;', 'uniform float specularPowerUniform;']);\n      }\n\n      // now handle the more complex fragment shader implementation\n      // the following are always defined variables.  We start\n      // by assigning a default value from the uniform\n      let colorImpl = ['vec3 ambientColor;', '  vec3 diffuseColor;', '  float opacity;'];\n      if (lastLightComplexity) {\n        colorImpl = colorImpl.concat(['  vec3 specularColor;', '  float specularPower;']);\n      }\n      colorImpl = colorImpl.concat(['  opacity = opacityUniform;']);\n      if (lastLightComplexity) {\n        colorImpl = colorImpl.concat(['  specularColor = specularColorUniform;', '  specularPower = specularPowerUniform;']);\n      }\n      if (!model.drawingEdges) {\n        colorDec = colorDec.concat(['varying vec4 vertexColorVSOutput;']);\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Dec', ['attribute vec4 gColor;', 'varying vec4 vertexColorVSOutput;']).result;\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Impl', ['vertexColorVSOutput = gColor;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Dec', ['in vec4 vertexColorVSOutput[];', 'out vec4 vertexColorGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Impl', ['vertexColorGSOutput = vertexColorVSOutput[i];']).result;\n        colorImpl = colorImpl.concat(['  diffuseColor = vertexColorVSOutput.rgb;', '  ambientColor = vertexColorVSOutput.rgb;', '  opacity = opacity*vertexColorVSOutput.a;']);\n      }\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Dec', colorDec).result;\n      shaders.Vertex = VSSource;\n      shaders.Geometry = GSSource;\n      shaders.Fragment = FSSource;\n    }\n    superClass.replaceShaderColor(shaders, ren, actor);\n  };\n  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {\n    if (model.hardwareSupport) {\n      let VSSource = shaders.Vertex;\n\n      // do we need the vertex in the shader in View Coordinates\n      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n      if (lastLightComplexity > 0) {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['vec4 gVertexMC = gMatrix * vertexMC;', 'vertexVCVSOutput = MCVCMatrix * gVertexMC;', '  gl_Position = MCPCMatrix * gVertexMC;']).result;\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['attribute mat4 gMatrix;', 'uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;\n      } else {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['attribute mat4 gMatrix;', 'uniform mat4 MCPCMatrix;']).result;\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['vec4 gVertexMC = gMatrix * vertexMC;', '  gl_Position = MCPCMatrix * gVertexMC;']).result;\n      }\n      shaders.Vertex = VSSource;\n    }\n    superClass.replaceShaderPositionVC(shaders, ren, actor);\n  };\n  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {\n    if (model.hardwareSupport) {\n      let FSSource = shaders.Fragment;\n      let VSSource = shaders.Vertex;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Picking::Dec', ['attribute vec3 mapperIndexVS;', 'varying vec3 mapperIndexVSOutput;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Picking::Impl', '  mapperIndexVSOutput = mapperIndexVS;').result;\n      shaders.Vertex = VSSource;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', ['varying vec3 mapperIndexVSOutput;', 'uniform vec3 mapperIndex;', 'uniform int picking;']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', ['  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);', '  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];']).result;\n      shaders.Fragment = FSSource;\n    } else {\n      superClass.replaceShaderPicking(shaders, ren, actor);\n    }\n  };\n  publicAPI.updateGlyphShaderParameters = (normalMatrixUsed, mcvcMatrixUsed, cellBO, carray, garray, narray, p, selector) => {\n    const program = cellBO.getProgram();\n    if (normalMatrixUsed) {\n      const a = model.normalMatrix;\n      const b = narray;\n      const ofs = p * 9;\n      const out = model.tmpMat3;\n      const a00 = a[0];\n      const a01 = a[1];\n      const a02 = a[2];\n      const a10 = a[3];\n      const a11 = a[4];\n      const a12 = a[5];\n      const a20 = a[6];\n      const a21 = a[7];\n      const a22 = a[8];\n      const b00 = b[ofs];\n      const b01 = b[ofs + 1];\n      const b02 = b[ofs + 2];\n      const b10 = b[ofs + 3];\n      const b11 = b[ofs + 4];\n      const b12 = b[ofs + 5];\n      const b20 = b[ofs + 6];\n      const b21 = b[ofs + 7];\n      const b22 = b[ofs + 8];\n      out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n      out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n      out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n      out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n      out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n      out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n      out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n      out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n      out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n      program.setUniformMatrix3x3('normalMatrix', model.tmpMat3);\n    }\n    publicAPI.multiply4x4WithOffset(model.tmpMat4, model.mcpcMatrix, garray, p * 16);\n    program.setUniformMatrix('MCPCMatrix', model.tmpMat4);\n    if (mcvcMatrixUsed) {\n      publicAPI.multiply4x4WithOffset(model.tmpMat4, model.mcvcMatrix, garray, p * 16);\n      program.setUniformMatrix('MCVCMatrix', model.tmpMat4);\n    }\n\n    // set color\n    if (carray) {\n      const cdata = carray.getData();\n      model.tmpColor[0] = cdata[p * 4] / 255.0;\n      model.tmpColor[1] = cdata[p * 4 + 1] / 255.0;\n      model.tmpColor[2] = cdata[p * 4 + 2] / 255.0;\n      program.setUniform3fArray('ambientColorUniform', model.tmpColor);\n      program.setUniform3fArray('diffuseColorUniform', model.tmpColor);\n    }\n    if (selector) {\n      program.setUniform3fArray('mapperIndex', selector.getPropColorValue());\n    }\n  };\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const representation = actor.getProperty().getRepresentation();\n    const gl = model.context;\n    const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;\n\n    // [WMVP]C == {world, model, view, projection} coordinates\n    // E.g., WCPC == world to projection coordinate transformation\n    const keyMats = model.openGLCamera.getKeyMatrices(ren);\n    const actMats = model.openGLActor.getKeyMatrices();\n\n    // precompute the actor+camera mats once\n    mat3.multiply(model.normalMatrix, keyMats.normalMatrix, actMats.normalMatrix);\n    mat4.multiply(model.mcpcMatrix, keyMats.wcpc, actMats.mcwc);\n    mat4.multiply(model.mcvcMatrix, keyMats.wcvc, actMats.mcwc);\n    const garray = model.renderable.getMatrixArray();\n    const narray = model.renderable.getNormalArray();\n    const carray = model.renderable.getColorArray();\n    const numPts = garray.length / 16;\n    let compositePass = false;\n    if (model._openGLRenderer.getSelector()) {\n      if (model._openGLRenderer.getSelector().getCurrentPass() === PassTypes.COMPOSITE_INDEX_PASS) {\n        compositePass = true;\n      }\n    }\n\n    // for every primitive type\n    for (let i = model.primTypes.Start; i < model.primTypes.End; i++) {\n      // if there are entries\n      const cabo = model.primitives[i].getCABO();\n      if (cabo.getElementCount()) {\n        // are we drawing edges\n        model.drawingEdges = drawSurfaceWithEdges && (i === model.primTypes.TrisEdges || i === model.primTypes.TriStripsEdges);\n        model.lastBoundBO = model.primitives[i];\n        model.primitives[i].updateShaders(ren, actor, publicAPI);\n        const program = model.primitives[i].getProgram();\n        const mode = model.primitives[i].getOpenGLMode(representation);\n        const normalMatrixUsed = program.isUniformUsed('normalMatrix');\n        const mcvcMatrixUsed = program.isUniformUsed('MCVCMatrix');\n        if (model.hardwareSupport) {\n          if (model.extension) {\n            model.extension.drawArraysInstancedANGLE(mode, 0, cabo.getElementCount(), numPts);\n          } else {\n            gl.drawArraysInstanced(mode, 0, cabo.getElementCount(), numPts);\n          }\n        } else {\n          // draw the array multiple times with different cam matrix\n          for (let p = 0; p < numPts; ++p) {\n            if (compositePass) {\n              model._openGLRenderer.getSelector().renderCompositeIndex(p);\n            }\n            publicAPI.updateGlyphShaderParameters(normalMatrixUsed, mcvcMatrixUsed, model.primitives[i], carray, garray, narray, p, compositePass ? model._openGLRenderer.getSelector() : null);\n            gl.drawArrays(mode, 0, cabo.getElementCount());\n          }\n        }\n      }\n    }\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    if (cellBO.getCABO().getElementCount() && (model.glyphBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      if (cellBO.getProgram().isAttributeUsed('gMatrix')) {\n        if (!cellBO.getVAO().addAttributeMatrixWithDivisor(cellBO.getProgram(), model.matrixBuffer, 'gMatrix', 0, 64, model.context.FLOAT, 4, false, 1)) {\n          vtkErrorMacro('Error setting gMatrix in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('gMatrix');\n      }\n      if (cellBO.getProgram().isAttributeUsed('gNormal')) {\n        if (!cellBO.getVAO().addAttributeMatrixWithDivisor(cellBO.getProgram(), model.normalBuffer, 'gNormal', 0, 36, model.context.FLOAT, 3, false, 1)) {\n          vtkErrorMacro('Error setting gNormal in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('gNormal');\n      }\n      if (cellBO.getProgram().isAttributeUsed('gColor')) {\n        if (!cellBO.getVAO().addAttributeArrayWithDivisor(cellBO.getProgram(), model.colorBuffer, 'gColor', 0, 4, model.context.UNSIGNED_BYTE, 4, true, 1, false)) {\n          vtkErrorMacro('Error setting gColor in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('gColor');\n      }\n      if (cellBO.getProgram().isAttributeUsed('mapperIndexVS')) {\n        if (!cellBO.getVAO().addAttributeArrayWithDivisor(cellBO.getProgram(), model.pickBuffer, 'mapperIndexVS', 0, 4, model.context.UNSIGNED_BYTE, 4, true, 1, false)) {\n          vtkErrorMacro('Error setting mapperIndexVS in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('mapperIndexVS');\n      }\n      superClass.setMapperShaderParameters(cellBO, ren, actor);\n      cellBO.getAttributeUpdateTime().modified();\n      return;\n    }\n    superClass.setMapperShaderParameters(cellBO, ren, actor);\n  };\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {\n    model.renderable.buildArrays();\n\n    // first do a coarse check\n    // Note that the actor's mtime includes it's properties mtime\n    const vmtime = model.VBOBuildTime.getMTime();\n    if (vmtime < model.renderable.getBuildTime().getMTime()) {\n      return true;\n    }\n    return superClass.getNeedToRebuildBufferObjects(ren, actor);\n  };\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    if (superClass.getNeedToRebuildShaders(cellBO, ren, actor) || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    if (model.hardwareSupport) {\n      // update the buffer objects if needed\n      const garray = model.renderable.getMatrixArray();\n      const narray = model.renderable.getNormalArray();\n      const carray = model.renderable.getColorArray();\n      if (!model.matrixBuffer) {\n        model.matrixBuffer = vtkBufferObject.newInstance();\n        model.matrixBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);\n        model.normalBuffer = vtkBufferObject.newInstance();\n        model.normalBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);\n        model.colorBuffer = vtkBufferObject.newInstance();\n        model.colorBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);\n        model.pickBuffer = vtkBufferObject.newInstance();\n        model.pickBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n      if (model.renderable.getBuildTime().getMTime() > model.glyphBOBuildTime.getMTime()) {\n        model.matrixBuffer.upload(garray, ObjectType.ARRAY_BUFFER);\n        model.normalBuffer.upload(narray, ObjectType.ARRAY_BUFFER);\n        if (carray) {\n          model.colorBuffer.upload(carray.getData(), ObjectType.ARRAY_BUFFER);\n        } else {\n          model.colorBuffer.releaseGraphicsResources();\n        }\n        const numPts = garray.length / 16;\n        const parray = new Uint8Array(4 * numPts);\n        for (let i = 0; i < numPts; ++i) {\n          let value = i + 1;\n          const offset = i * 4;\n          parray[offset] = value % 256;\n          value -= parray[offset];\n          value /= 256;\n          parray[offset + 1] = value % 256;\n          value -= parray[offset + 1];\n          value /= 256;\n          parray[offset + 2] = value % 256;\n          parray[offset + 3] = 255;\n        }\n        model.pickBuffer.upload(parray, ObjectType.ARRAY_BUFFER);\n        model.glyphBOBuildTime.modified();\n      }\n    }\n    return superClass.buildBufferObjects(ren, actor);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  normalMatrix: null,\n  mcpcMatrix: null,\n  mcwcMatrix: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkOpenGLPolyDataMapper.extend(publicAPI, model, initialValues);\n  model.tmpMat3 = mat3.identity(new Float64Array(9));\n  model.normalMatrix = mat3.identity(new Float64Array(9));\n  model.mcpcMatrix = mat4.identity(new Float64Array(16));\n  model.mcvcMatrix = mat4.identity(new Float64Array(16));\n  model.tmpColor = [];\n  model.glyphBOBuildTime = {};\n  obj(model.glyphBOBuildTime, {\n    mtime: 0\n  });\n\n  // Object methods\n  vtkOpenGLGlyph3DMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLGlyph3DMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkGlyph3DMapper = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkGlyph3DMapper', newInstance);\n\nexport { vtkGlyph3DMapper as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}