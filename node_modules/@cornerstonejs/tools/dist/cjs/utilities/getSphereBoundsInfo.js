"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSphereBoundsInfo = void 0;
const core_1 = require("@cornerstonejs/core");
const gl_matrix_1 = require("gl-matrix");
const boundingBox_1 = require("./boundingBox");
const { transformWorldToIndex } = core_1.utilities;
function getSphereBoundsInfo(circlePoints, imageData, viewport) {
    const [bottom, top] = circlePoints;
    const centerWorld = gl_matrix_1.vec3.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);
    const radiusWorld = gl_matrix_1.vec3.distance(bottom, top) / 2;
    if (!viewport) {
        throw new Error('viewport is required in order to calculate the sphere bounds');
    }
    const { boundsIJK, topLeftWorld, bottomRightWorld } = _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld);
    return {
        boundsIJK,
        centerWorld: centerWorld,
        radiusWorld,
        topLeftWorld: topLeftWorld,
        bottomRightWorld: bottomRightWorld,
    };
}
exports.getSphereBoundsInfo = getSphereBoundsInfo;
function _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld) {
    const [bottom, top] = circlePoints;
    const dimensions = imageData.getDimensions();
    const camera = viewport.getCamera();
    const viewUp = gl_matrix_1.vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);
    const viewPlaneNormal = gl_matrix_1.vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);
    const viewRight = gl_matrix_1.vec3.create();
    gl_matrix_1.vec3.cross(viewRight, viewUp, viewPlaneNormal);
    const topLeftWorld = gl_matrix_1.vec3.create();
    const bottomRightWorld = gl_matrix_1.vec3.create();
    gl_matrix_1.vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);
    gl_matrix_1.vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);
    gl_matrix_1.vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);
    gl_matrix_1.vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);
    const topLeftIJK = transformWorldToIndex(imageData, topLeftWorld);
    const bottomRightIJK = transformWorldToIndex(imageData, bottomRightWorld);
    const pointsIJK = circlePoints.map((p) => transformWorldToIndex(imageData, p));
    const boundsIJK = (0, boundingBox_1.getBoundingBoxAroundShapeIJK)([topLeftIJK, bottomRightIJK, ...pointsIJK], dimensions);
    return { boundsIJK, topLeftWorld, bottomRightWorld };
}
//# sourceMappingURL=getSphereBoundsInfo.js.map