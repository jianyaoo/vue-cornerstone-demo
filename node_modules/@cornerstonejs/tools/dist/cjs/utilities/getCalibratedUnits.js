"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCalibratedProbeUnitsAndValue = exports.getCalibratedAspect = exports.getCalibratedScale = exports.getCalibratedLengthUnitsAndScale = exports.getCalibratedLengthUnits = exports.getCalibratedAreaUnits = void 0;
const core_1 = require("@cornerstonejs/core");
const { CalibrationTypes } = core_1.Enums;
const PIXEL_UNITS = 'px';
const SUPPORTED_REGION_DATA_TYPES = [
    1,
];
const SUPPORTED_LENGTH_VARIANT = [
    '3,3',
];
const SUPPORTED_PROBE_VARIANT = [
    '4,3',
];
const UNIT_MAPPING = {
    3: 'cm',
    4: 'seconds',
};
const EPS = 1e-3;
const getCalibratedLengthUnits = (handles, image) => {
    const { calibration, hasPixelSpacing } = image;
    const units = hasPixelSpacing ? 'mm' : PIXEL_UNITS;
    if (!calibration ||
        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {
        return units;
    }
    if (calibration.type === CalibrationTypes.UNCALIBRATED) {
        return PIXEL_UNITS;
    }
    if (calibration.sequenceOfUltrasoundRegions) {
        return 'US Region';
    }
    return `${units} ${calibration.type}`;
};
exports.getCalibratedLengthUnits = getCalibratedLengthUnits;
const SQUARE = '\xb2';
const getCalibratedAreaUnits = (handles, image) => {
    const { calibration, hasPixelSpacing } = image;
    const units = (hasPixelSpacing ? 'mm' : PIXEL_UNITS) + SQUARE;
    if (!calibration || !calibration.type) {
        return units;
    }
    if (calibration.sequenceOfUltrasoundRegions) {
        return 'US Region';
    }
    return `${units} ${calibration.type}`;
};
exports.getCalibratedAreaUnits = getCalibratedAreaUnits;
const getCalibratedScale = (image, handles = []) => {
    var _a, _b;
    if ((_a = image.calibration) === null || _a === void 0 ? void 0 : _a.sequenceOfUltrasoundRegions) {
    }
    else if ((_b = image.calibration) === null || _b === void 0 ? void 0 : _b.scale) {
        return image.calibration.scale;
    }
    else {
        return 1;
    }
};
exports.getCalibratedScale = getCalibratedScale;
const getCalibratedLengthUnitsAndScale = (image, handles) => {
    const [imageIndex1, imageIndex2] = handles;
    const { calibration, hasPixelSpacing } = image;
    let units = hasPixelSpacing ? 'mm' : PIXEL_UNITS;
    const areaUnits = units + SQUARE;
    let scale = 1;
    let calibrationType = '';
    if (!calibration ||
        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {
        return { units, areaUnits, scale };
    }
    if (calibration.type === CalibrationTypes.UNCALIBRATED) {
        return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };
    }
    if (calibration.sequenceOfUltrasoundRegions) {
        let regions = calibration.sequenceOfUltrasoundRegions.filter((region) => imageIndex1[0] >= region.regionLocationMinX0 &&
            imageIndex1[0] <= region.regionLocationMaxX1 &&
            imageIndex1[1] >= region.regionLocationMinY0 &&
            imageIndex1[1] <= region.regionLocationMaxY1 &&
            imageIndex2[0] >= region.regionLocationMinX0 &&
            imageIndex2[0] <= region.regionLocationMaxX1 &&
            imageIndex2[1] >= region.regionLocationMinY0 &&
            imageIndex2[1] <= region.regionLocationMaxY1);
        if (!(regions === null || regions === void 0 ? void 0 : regions.length)) {
            return { units, areaUnits, scale };
        }
        regions = regions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&
            SUPPORTED_LENGTH_VARIANT.includes(`${region.physicalUnitXDirection},${region.physicalUnitYDirection}`));
        if (!regions.length) {
            return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };
        }
        const region = regions[0];
        const physicalDeltaX = Math.abs(region.physicalDeltaX);
        const physicalDeltaY = Math.abs(region.physicalDeltaY);
        const isSamePhysicalDelta = core_1.utilities.isEqual(physicalDeltaX, physicalDeltaY, EPS);
        if (isSamePhysicalDelta) {
            scale = 1 / (physicalDeltaX * physicalDeltaY * 100);
            calibrationType = 'US Region';
            units = 'mm';
        }
        else {
            return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };
        }
    }
    else if (calibration.scale) {
        scale = calibration.scale;
    }
    return {
        units: units + (calibrationType ? ` ${calibrationType}` : ''),
        areaUnits: areaUnits + (calibrationType ? ` ${calibrationType}` : ''),
        scale,
    };
};
exports.getCalibratedLengthUnitsAndScale = getCalibratedLengthUnitsAndScale;
const getCalibratedProbeUnitsAndValue = (image, handles) => {
    const [imageIndex] = handles;
    const { calibration } = image;
    let units = ['raw'];
    let values = [null];
    let calibrationType = '';
    if (!calibration ||
        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {
        return { units, values };
    }
    if (calibration.sequenceOfUltrasoundRegions) {
        const supportedRegionsMetadata = calibration.sequenceOfUltrasoundRegions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&
            SUPPORTED_PROBE_VARIANT.includes(`${region.physicalUnitXDirection},${region.physicalUnitYDirection}`));
        if (!(supportedRegionsMetadata === null || supportedRegionsMetadata === void 0 ? void 0 : supportedRegionsMetadata.length)) {
            return { units, values };
        }
        const region = supportedRegionsMetadata.find((region) => imageIndex[0] >= region.regionLocationMinX0 &&
            imageIndex[0] <= region.regionLocationMaxX1 &&
            imageIndex[1] >= region.regionLocationMinY0 &&
            imageIndex[1] <= region.regionLocationMaxY1);
        if (!region) {
            return { units, values };
        }
        const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;
        const { physicalDeltaX, physicalDeltaY } = region;
        const yValue = (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) *
            physicalDeltaY;
        const xValue = (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) *
            physicalDeltaX;
        calibrationType = 'US Region';
        values = [xValue, yValue];
        units = [
            UNIT_MAPPING[region.physicalUnitXDirection],
            UNIT_MAPPING[region.physicalUnitYDirection],
        ];
    }
    return {
        units,
        values,
        calibrationType,
    };
};
exports.getCalibratedProbeUnitsAndValue = getCalibratedProbeUnitsAndValue;
const getCalibratedAspect = (image) => { var _a; return ((_a = image.calibration) === null || _a === void 0 ? void 0 : _a.aspect) || 1; };
exports.getCalibratedAspect = getCalibratedAspect;
exports.default = getCalibratedLengthUnits;
//# sourceMappingURL=getCalibratedUnits.js.map