import { cache, utilities as csUtils, eventTarget, } from '@cornerstonejs/core';
import { Events, SegmentationRepresentations } from '../../enums';
import addSegmentations from './addSegmentations';
import addSegmentationRepresentations from './addSegmentationRepresentations';
import { triggerSegmentationRender, createImageIdReferenceMap, } from '../../utilities/segmentation';
import { getSegmentation, removeSegmentation } from './segmentationState';
import { triggerSegmentationDataModified } from './triggerSegmentationEvents';
export async function convertVolumeToStackSegmentation({ segmentationId, options, }) {
    const segmentation = getSegmentation(segmentationId);
    const { toolGroupId } = options;
    const data = segmentation.representationData
        .LABELMAP;
    const segmentationVolume = cache.getVolume(data.volumeId);
    const imageIdReferenceMap = _getImageIdReferenceMapForStackSegmentation(segmentationVolume);
    const newSegmentationId = options?.newSegmentationId ?? csUtils.uuidv4();
    if (options?.removeOriginal ?? true) {
        removeSegmentation(segmentationId);
    }
    await addSegmentations([
        {
            segmentationId: newSegmentationId,
            representation: {
                type: SegmentationRepresentations.Labelmap,
                data: {
                    imageIdReferenceMap,
                },
            },
        },
    ]);
    await addSegmentationRepresentations(toolGroupId, [
        {
            segmentationId: newSegmentationId,
            type: SegmentationRepresentations.Labelmap,
        },
    ]);
    triggerSegmentationRender(toolGroupId);
    eventTarget.addEventListenerOnce(Events.SEGMENTATION_RENDERED, () => triggerSegmentationDataModified(newSegmentationId));
}
function _getImageIdReferenceMapForStackSegmentation(segmentationVolume) {
    const segmentationImageIds = segmentationVolume.imageIds;
    if (segmentationVolume.additionalDetails?.imageIdReferenceMap) {
        return segmentationVolume.additionalDetails.imageIdReferenceMap;
    }
    else if (segmentationVolume.referencedImageIds?.length &&
        !segmentationVolume.referencedImageIds[0].startsWith('derived')) {
        const referencedImageIds = segmentationVolume.referencedImageIds;
        return createImageIdReferenceMap(referencedImageIds, segmentationImageIds);
    }
    else {
        const referencedVolumeId = segmentationVolume.referencedVolumeId;
        const referencedVolume = cache.getVolume(referencedVolumeId);
        if (!referencedVolume) {
            throw new Error('Cannot convert volumetric segmentation without referenced volume to stack segmentation yet');
        }
        if (!referencedVolume?.imageIds?.length) {
            throw new Error('Cannot convert volumetric segmentation without imageIds to stack segmentation yet');
        }
        if (referencedVolume.imageIds?.[0].startsWith('derived')) {
            throw new Error(`Cannot convert volume segmentation that is derived from another segmentation
         to stack segmentation yet, include the additionalDetails.imageIdReferenceMap
         in the volume segmentation in case you need it for the conversion`);
        }
        const referencedImageIds = referencedVolume.imageIds;
        let segmentationImageIdsToUse = segmentationVolume.imageIds;
        if (!segmentationImageIdsToUse?.length) {
            segmentationImageIdsToUse =
                segmentationVolume.convertToImageSlicesAndCache();
        }
        return createImageIdReferenceMap(referencedImageIds, segmentationImageIdsToUse);
    }
}
//# sourceMappingURL=convertVolumeToStackSegmentation.js.map