{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport vtkCaseTable from './ImageMarchingSquares/caseTable.js';\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageMarchingSquares methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMarchingSquares(publicAPI, model) {\n  /**\n   * Get the X,Y kernels based on the set slicing mode.\n   * @returns {[number, number]}\n   */\n  function getKernels() {\n    let kernelX = 0; // default K slicing mode\n    let kernelY = 1;\n    if (model.slicingMode === 1) {\n      kernelX = 0;\n      kernelY = 2;\n    } else if (model.slicingMode === 0) {\n      kernelX = 1;\n      kernelY = 2;\n    }\n    return [kernelX, kernelY];\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkImageMarchingSquares');\n\n  /**\n   * Get the list of contour values.\n   * @returns {number[]}\n   */\n  publicAPI.getContourValues = () => model.contourValues;\n\n  /**\n   * Set the list contour values.\n   * @param {number[]} cValues\n   */\n  publicAPI.setContourValues = cValues => {\n    model.contourValues = cValues;\n    publicAPI.modified();\n  };\n  const ids = [];\n  const pixelScalars = [];\n  const pixelPts = [];\n  const edgeLocator = vtkEdgeLocator.newInstance();\n\n  /**\n   * Retrieve scalars and pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelScalars = (ijk, dims, scalars, increments, kernelX, kernelY) => {\n    const [i, j, k] = ijk;\n\n    // First get the indices for the pixel\n    ids[0] = k * dims[1] * dims[0] + j * dims[0] + i; // i, j, k\n    ids[1] = ids[0] + increments[kernelX]; // i+1, j, k\n    ids[2] = ids[0] + increments[kernelY]; // i, j+1, k\n    ids[3] = ids[2] + increments[kernelX]; // i+1, j+1, k\n\n    // Now retrieve the scalars\n    for (let ii = 0; ii < 4; ++ii) {\n      pixelScalars[ii] = scalars[ids[ii]];\n    }\n  };\n\n  /**\n   * Retrieve pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing spacing of the image\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelPoints = (ijk, origin, spacing, kernelX, kernelY) => {\n    const i = ijk[kernelX];\n    const j = ijk[kernelY];\n\n    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k\n    pixelPts[0] = origin[kernelX] + i * spacing[kernelX]; // 0\n    pixelPts[1] = origin[kernelY] + j * spacing[kernelY];\n    pixelPts[2] = pixelPts[0] + spacing[kernelX]; // 1\n    pixelPts[3] = pixelPts[1];\n    pixelPts[4] = pixelPts[0]; // 2\n    pixelPts[5] = pixelPts[1] + spacing[kernelY];\n    pixelPts[6] = pixelPts[2]; // 3\n    pixelPts[7] = pixelPts[5];\n  };\n\n  /**\n   * Produce points and lines for the polydata.\n   * @param {number[]} cVal list of contour values\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing sapcing of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {number[]} points list of points\n   * @param {number[]} lines list of lines\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.produceLines = (cVal, ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY) => {\n    const k = ijk[model.slicingMode];\n    const CASE_MASK = [1, 2, 8, 4]; // case table is actually for quad\n    const xyz = [];\n    let pId;\n    publicAPI.getPixelScalars(ijk, dims, scalars, increments, kernelX, kernelY);\n    let index = 0;\n    for (let idx = 0; idx < 4; idx++) {\n      if (pixelScalars[idx] >= cVal) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n    const pixelLines = vtkCaseTable.getCase(index);\n    if (pixelLines[0] < 0) {\n      return; // don't get the pixel coordinates, nothing to do\n    }\n    publicAPI.getPixelPoints(ijk, origin, spacing, kernelX, kernelY);\n    const z = origin[model.slicingMode] + k * spacing[model.slicingMode];\n    for (let idx = 0; pixelLines[idx] >= 0; idx += 2) {\n      lines.push(2);\n      for (let eid = 0; eid < 2; eid++) {\n        const edgeVerts = vtkCaseTable.getEdge(pixelLines[idx + eid]);\n        pId = undefined;\n        if (model.mergePoints) {\n          pId = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])?.value;\n        }\n        if (pId === undefined) {\n          const t = (cVal - pixelScalars[edgeVerts[0]]) / (pixelScalars[edgeVerts[1]] - pixelScalars[edgeVerts[0]]);\n          const x0 = pixelPts.slice(edgeVerts[0] * 2, (edgeVerts[0] + 1) * 2);\n          const x1 = pixelPts.slice(edgeVerts[1] * 2, (edgeVerts[1] + 1) * 2);\n          xyz[kernelX] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[kernelY] = x0[1] + t * (x1[1] - x0[1]);\n          xyz[model.slicingMode] = z;\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], xyz[2]);\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n        lines.push(pId);\n      }\n    }\n  };\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (model.slicingMode == null || model.slicingMode < 0 || model.slicingMode > 2) {\n      vtkErrorMacro('Invalid or missing slicing mode');\n      return;\n    }\n    console.time('msquares');\n\n    // Retrieve output and volume data\n    const origin = input.getOrigin();\n    const spacing = input.getSpacing();\n    const dims = input.getDimensions();\n    const extent = input.getExtent();\n    const increments = input.computeIncrements(extent);\n    const scalars = input.getPointData().getScalars().getData();\n    const [kernelX, kernelY] = getKernels();\n\n    // Points - dynamic array\n    const points = [];\n\n    // Cells - dynamic array\n    const lines = [];\n\n    // Ensure slice is valid\n    let k = Math.round(model.slice);\n    if (k >= dims[model.slicingMode]) {\n      k = 0;\n    }\n\n    // Loop over all contour values, and then pixels, determine case and process\n    const ijk = [0, 0, 0];\n    ijk[model.slicingMode] = k;\n    for (let cv = 0; cv < model.contourValues.length; ++cv) {\n      for (let j = 0; j < dims[kernelY] - 1; ++j) {\n        ijk[kernelY] = j;\n        for (let i = 0; i < dims[kernelX] - 1; ++i) {\n          ijk[kernelX] = i;\n          publicAPI.produceLines(model.contourValues[cv], ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY);\n        }\n      }\n      edgeLocator.initialize();\n    }\n\n    // Update output\n    const polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(points), 3);\n    polydata.getLines().setData(new Uint32Array(lines));\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('msquares');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  contourValues: [],\n  slicingMode: 2,\n  slice: 0,\n  mergePoints: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['slicingMode', 'slice', 'mergePoints']);\n\n  // Object specific methods\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageMarchingSquares(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMarchingSquares');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMarchingSquares$1 = {\n  newInstance,\n  extend\n};\nexport { vtkImageMarchingSquares$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkPolyData","vtkEdgeLocator","vtkCaseTable","vtkErrorMacro","vtkDebugMacro","vtkImageMarchingSquares","publicAPI","model","getKernels","kernelX","kernelY","slicingMode","classHierarchy","push","getContourValues","contourValues","setContourValues","cValues","modified","ids","pixelScalars","pixelPts","edgeLocator","newInstance","getPixelScalars","ijk","dims","scalars","increments","i","j","k","ii","getPixelPoints","origin","spacing","produceLines","cVal","points","lines","CASE_MASK","xyz","pId","index","idx","pixelLines","getCase","z","eid","edgeVerts","getEdge","undefined","mergePoints","isInsertedEdge","value","t","x0","slice","x1","length","insertEdge","requestData","inData","outData","input","console","time","getOrigin","getSpacing","getDimensions","extent","getExtent","computeIncrements","getPointData","getScalars","getData","Math","round","cv","initialize","polydata","getPoints","setData","Float32Array","getLines","Uint32Array","timeEnd","DEFAULT_VALUES","extend","initialValues","arguments","Object","assign","obj","algo","setGet","vtkImageMarchingSquares$1","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport vtkCaseTable from './ImageMarchingSquares/caseTable.js';\n\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageMarchingSquares methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMarchingSquares(publicAPI, model) {\n  /**\n   * Get the X,Y kernels based on the set slicing mode.\n   * @returns {[number, number]}\n   */\n  function getKernels() {\n    let kernelX = 0; // default K slicing mode\n    let kernelY = 1;\n    if (model.slicingMode === 1) {\n      kernelX = 0;\n      kernelY = 2;\n    } else if (model.slicingMode === 0) {\n      kernelX = 1;\n      kernelY = 2;\n    }\n    return [kernelX, kernelY];\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkImageMarchingSquares');\n\n  /**\n   * Get the list of contour values.\n   * @returns {number[]}\n   */\n  publicAPI.getContourValues = () => model.contourValues;\n\n  /**\n   * Set the list contour values.\n   * @param {number[]} cValues\n   */\n  publicAPI.setContourValues = cValues => {\n    model.contourValues = cValues;\n    publicAPI.modified();\n  };\n  const ids = [];\n  const pixelScalars = [];\n  const pixelPts = [];\n  const edgeLocator = vtkEdgeLocator.newInstance();\n\n  /**\n   * Retrieve scalars and pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelScalars = (ijk, dims, scalars, increments, kernelX, kernelY) => {\n    const [i, j, k] = ijk;\n\n    // First get the indices for the pixel\n    ids[0] = k * dims[1] * dims[0] + j * dims[0] + i; // i, j, k\n    ids[1] = ids[0] + increments[kernelX]; // i+1, j, k\n    ids[2] = ids[0] + increments[kernelY]; // i, j+1, k\n    ids[3] = ids[2] + increments[kernelX]; // i+1, j+1, k\n\n    // Now retrieve the scalars\n    for (let ii = 0; ii < 4; ++ii) {\n      pixelScalars[ii] = scalars[ids[ii]];\n    }\n  };\n\n  /**\n   * Retrieve pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing spacing of the image\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelPoints = (ijk, origin, spacing, kernelX, kernelY) => {\n    const i = ijk[kernelX];\n    const j = ijk[kernelY];\n\n    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k\n    pixelPts[0] = origin[kernelX] + i * spacing[kernelX]; // 0\n    pixelPts[1] = origin[kernelY] + j * spacing[kernelY];\n    pixelPts[2] = pixelPts[0] + spacing[kernelX]; // 1\n    pixelPts[3] = pixelPts[1];\n    pixelPts[4] = pixelPts[0]; // 2\n    pixelPts[5] = pixelPts[1] + spacing[kernelY];\n    pixelPts[6] = pixelPts[2]; // 3\n    pixelPts[7] = pixelPts[5];\n  };\n\n  /**\n   * Produce points and lines for the polydata.\n   * @param {number[]} cVal list of contour values\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing sapcing of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {number[]} points list of points\n   * @param {number[]} lines list of lines\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.produceLines = (cVal, ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY) => {\n    const k = ijk[model.slicingMode];\n    const CASE_MASK = [1, 2, 8, 4]; // case table is actually for quad\n    const xyz = [];\n    let pId;\n    publicAPI.getPixelScalars(ijk, dims, scalars, increments, kernelX, kernelY);\n    let index = 0;\n    for (let idx = 0; idx < 4; idx++) {\n      if (pixelScalars[idx] >= cVal) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n\n    const pixelLines = vtkCaseTable.getCase(index);\n    if (pixelLines[0] < 0) {\n      return; // don't get the pixel coordinates, nothing to do\n    }\n\n    publicAPI.getPixelPoints(ijk, origin, spacing, kernelX, kernelY);\n    const z = origin[model.slicingMode] + k * spacing[model.slicingMode];\n    for (let idx = 0; pixelLines[idx] >= 0; idx += 2) {\n      lines.push(2);\n      for (let eid = 0; eid < 2; eid++) {\n        const edgeVerts = vtkCaseTable.getEdge(pixelLines[idx + eid]);\n        pId = undefined;\n        if (model.mergePoints) {\n          pId = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])?.value;\n        }\n        if (pId === undefined) {\n          const t = (cVal - pixelScalars[edgeVerts[0]]) / (pixelScalars[edgeVerts[1]] - pixelScalars[edgeVerts[0]]);\n          const x0 = pixelPts.slice(edgeVerts[0] * 2, (edgeVerts[0] + 1) * 2);\n          const x1 = pixelPts.slice(edgeVerts[1] * 2, (edgeVerts[1] + 1) * 2);\n          xyz[kernelX] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[kernelY] = x0[1] + t * (x1[1] - x0[1]);\n          xyz[model.slicingMode] = z;\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], xyz[2]);\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n        lines.push(pId);\n      }\n    }\n  };\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (model.slicingMode == null || model.slicingMode < 0 || model.slicingMode > 2) {\n      vtkErrorMacro('Invalid or missing slicing mode');\n      return;\n    }\n    console.time('msquares');\n\n    // Retrieve output and volume data\n    const origin = input.getOrigin();\n    const spacing = input.getSpacing();\n    const dims = input.getDimensions();\n    const extent = input.getExtent();\n    const increments = input.computeIncrements(extent);\n    const scalars = input.getPointData().getScalars().getData();\n    const [kernelX, kernelY] = getKernels();\n\n    // Points - dynamic array\n    const points = [];\n\n    // Cells - dynamic array\n    const lines = [];\n\n    // Ensure slice is valid\n    let k = Math.round(model.slice);\n    if (k >= dims[model.slicingMode]) {\n      k = 0;\n    }\n\n    // Loop over all contour values, and then pixels, determine case and process\n    const ijk = [0, 0, 0];\n    ijk[model.slicingMode] = k;\n    for (let cv = 0; cv < model.contourValues.length; ++cv) {\n      for (let j = 0; j < dims[kernelY] - 1; ++j) {\n        ijk[kernelY] = j;\n        for (let i = 0; i < dims[kernelX] - 1; ++i) {\n          ijk[kernelX] = i;\n          publicAPI.produceLines(model.contourValues[cv], ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY);\n        }\n      }\n      edgeLocator.initialize();\n    }\n\n    // Update output\n    const polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(points), 3);\n    polydata.getLines().setData(new Uint32Array(lines));\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('msquares');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  contourValues: [],\n  slicingMode: 2,\n  slice: 0,\n  mergePoints: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['slicingMode', 'slice', 'mergePoints']);\n\n  // Object specific methods\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageMarchingSquares(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMarchingSquares');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMarchingSquares$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageMarchingSquares$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}