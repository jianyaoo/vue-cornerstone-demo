import ICamera from './ICamera';
import Point2 from './Point2';
import Point3 from './Point3';
import ViewportInputOptions from './ViewportInputOptions';
import { ActorEntry } from './IActor';
import ViewportType from '../enums/ViewportType';
import ViewportStatus from '../enums/ViewportStatus';
import DisplayArea from './displayArea';
interface IViewport {
    id: string;
    renderingEngineId: string;
    type: ViewportType;
    canvas: HTMLCanvasElement;
    element: HTMLDivElement;
    sx: number;
    sy: number;
    sWidth: number;
    sHeight: number;
    _actors: Map<string, any>;
    defaultOptions: any;
    options: ViewportInputOptions;
    suppressEvents: boolean;
    isDisabled: boolean;
    viewportStatus: ViewportStatus;
    getRotation: () => number;
    getFrameOfReferenceUID: () => string;
    canvasToWorld: (canvasPos: Point2) => Point3;
    worldToCanvas: (worldPos: Point3) => Point2;
    getDefaultActor(): ActorEntry;
    getActors(): Array<ActorEntry>;
    getActor(actorUID: string): ActorEntry;
    getActorUIDByIndex(index: number): string;
    getActorByIndex(index: number): ActorEntry;
    setActors(actors: Array<ActorEntry>): void;
    addActors(actors: Array<ActorEntry>): void;
    addActor(actorEntry: ActorEntry): void;
    getActorUIDs(): Array<string>;
    removeAllActors(): void;
    removeActors(actorUIDs: Array<string>): void;
    getRenderingEngine(): any;
    getRenderer(): void;
    render(): void;
    setOptions(options: ViewportInputOptions, immediate: boolean): void;
    setDisplayArea(displayArea: DisplayArea, callResetCamera?: boolean, suppressEvents?: boolean): any;
    getDisplayArea(): DisplayArea | undefined;
    reset(immediate: boolean): void;
    getCanvas(): HTMLCanvasElement;
    getCamera(): ICamera;
    setRendered(): void;
    getZoom(): number;
    setZoom(zoom: number, storeAsInitialCamera?: boolean): any;
    getPan(): Point2;
    setPan(pan: Point2, storeAsInitialCamera?: boolean): any;
    setCamera(cameraInterface: ICamera, storeAsInitialCamera?: boolean): void;
    getNumberOfSlices(): number;
    customRenderViewportToCanvas: () => unknown;
    _getCorners(bounds: Array<number>): Array<number>[];
    updateRenderingPipeline: () => void;
}
declare type PublicViewportInput = {
    element: HTMLDivElement;
    viewportId: string;
    type: ViewportType;
    defaultOptions?: ViewportInputOptions;
};
declare type NormalizedViewportInput = {
    element: HTMLDivElement;
    viewportId: string;
    type: ViewportType;
    defaultOptions: ViewportInputOptions;
};
declare type InternalViewportInput = {
    element: HTMLDivElement;
    canvas: HTMLCanvasElement;
    viewportId: string;
    type: ViewportType;
    defaultOptions: ViewportInputOptions;
};
declare type ViewportInput = {
    id: string;
    element: HTMLDivElement;
    canvas: HTMLCanvasElement;
    renderingEngineId: string;
    type: ViewportType;
    sx: number;
    sy: number;
    sWidth: number;
    sHeight: number;
    defaultOptions: ViewportInputOptions;
};
export type { IViewport, ViewportInput, PublicViewportInput, InternalViewportInput, NormalizedViewportInput, };
//# sourceMappingURL=IViewport.d.ts.map