"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isLineInSegment = exports.createIsInSegment = void 0;
const core_1 = require("@cornerstonejs/core");
const gl_matrix_1 = require("gl-matrix");
function isLineInSegment(point1, point2, isInSegment) {
    const ijk1 = isInSegment.toIJK(point1);
    const ijk2 = isInSegment.toIJK(point2);
    const testPoint = gl_matrix_1.vec3.create();
    const { testIJK } = isInSegment;
    const delta = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), ijk1, ijk2);
    const testSize = Math.round(Math.max(...delta.map(Math.abs)));
    if (testSize < 2) {
        return true;
    }
    const unitDelta = gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), delta, 1 / testSize);
    for (let i = 1; i < testSize; i++) {
        gl_matrix_1.vec3.scaleAndAdd(testPoint, ijk2, unitDelta, i);
        if (!testIJK(testPoint)) {
            return false;
        }
    }
    return true;
}
exports.default = isLineInSegment;
exports.isLineInSegment = isLineInSegment;
function createIsInSegment(segVolumeId, segmentIndex, containedSegmentIndices) {
    const vol = core_1.cache.getVolume(segVolumeId);
    if (!vol) {
        console.warn(`No volume found for ${segVolumeId}`);
        return;
    }
    const segData = vol.imageData.getPointData().getScalars().getData();
    const width = vol.dimensions[0];
    const pixelsPerSlice = width * vol.dimensions[1];
    return {
        testCenter: (point1, point2) => {
            const point = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), point1, point2).map((it) => it / 2);
            const ijk = vol.imageData.worldToIndex(point).map(Math.round);
            const [i, j, k] = ijk;
            const index = i + j * width + k * pixelsPerSlice;
            const value = segData[index];
            return value === segmentIndex || (containedSegmentIndices === null || containedSegmentIndices === void 0 ? void 0 : containedSegmentIndices.has(value));
        },
        toIJK: (point) => vol.imageData.worldToIndex(point),
        testIJK: (ijk) => {
            const [i, j, k] = ijk;
            const index = Math.round(i) + Math.round(j) * width + Math.round(k) * pixelsPerSlice;
            const value = segData[index];
            return value === segmentIndex || (containedSegmentIndices === null || containedSegmentIndices === void 0 ? void 0 : containedSegmentIndices.has(value));
        },
    };
}
exports.createIsInSegment = createIsInSegment;
//# sourceMappingURL=isLineInSegment.js.map