{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { m as macro } from '../../macros2.js';\nimport Constants from './HardwareSelector/Constants.js';\nimport vtkHardwareSelector$1 from '../Core/HardwareSelector.js';\nimport vtkOpenGLFramebuffer from './Framebuffer.js';\nimport vtkSelectionNode from '../../Common/DataModel/SelectionNode.js';\nimport vtkDataSet from '../../Common/DataModel/DataSet.js';\nconst {\n  PassTypes\n} = Constants;\nconst {\n  SelectionContent,\n  SelectionField\n} = vtkSelectionNode;\nconst {\n  FieldAssociations\n} = vtkDataSet;\nconst {\n  vtkErrorMacro\n} = macro;\nconst idOffset = 1;\nfunction getInfoHash(info) {\n  return `${info.propID} ${info.compositeID}`;\n}\nfunction getAlpha(xx, yy, pb, area) {\n  if (!pb) {\n    return 0;\n  }\n  const offset = (yy * (area[2] - area[0] + 1) + xx) * 4;\n  return pb[offset + 3];\n}\nfunction convert(xx, yy, pb, area) {\n  if (!pb) {\n    return 0;\n  }\n  const offset = (yy * (area[2] - area[0] + 1) + xx) * 4;\n  const r = pb[offset];\n  const g = pb[offset + 1];\n  const b = pb[offset + 2];\n  return (b * 256 + g) * 256 + r;\n}\nfunction getID(low24, high8) {\n  /* eslint-disable no-bitwise */\n  let val = high8;\n  val <<= 24;\n  val |= low24;\n  return val;\n  /* eslint-enable no-bitwise */\n}\nfunction getPixelInformationWithData(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {\n  // Base case\n  const maxDist = maxDistance < 0 ? 0 : maxDistance;\n  if (maxDist === 0) {\n    outSelectedPosition[0] = inDisplayPosition[0];\n    outSelectedPosition[1] = inDisplayPosition[1];\n    if (inDisplayPosition[0] < buffdata.area[0] || inDisplayPosition[0] > buffdata.area[2] || inDisplayPosition[1] < buffdata.area[1] || inDisplayPosition[1] > buffdata.area[3]) {\n      return null;\n    }\n\n    // offset inDisplayPosition based on the lower-left-corner of the Area.\n    const displayPosition = [inDisplayPosition[0] - buffdata.area[0], inDisplayPosition[1] - buffdata.area[1]];\n    const actorid = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ACTOR_PASS], buffdata.area);\n    if (actorid <= 0 || actorid - idOffset >= buffdata.props.length) {\n      // the pixel did not hit any actor.\n      return null;\n    }\n    const info = {};\n    info.valid = true;\n    info.propID = actorid - idOffset;\n    info.prop = buffdata.props[info.propID];\n    let compositeID = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.COMPOSITE_INDEX_PASS], buffdata.area);\n    if (compositeID < 0 || compositeID > 0xffffff) {\n      compositeID = 0;\n    }\n    info.compositeID = compositeID - idOffset;\n    if (buffdata.captureZValues) {\n      const offset = (displayPosition[1] * (buffdata.area[2] - buffdata.area[0] + 1) + displayPosition[0]) * 4;\n      info.zValue = (256 * buffdata.zBuffer[offset] + buffdata.zBuffer[offset + 1]) / 65535.0;\n      info.displayPosition = inDisplayPosition;\n    }\n    if (buffdata.pixBuffer[PassTypes.ID_LOW24]) {\n      if (getAlpha(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_LOW24], buffdata.area) === 0.0) {\n        return info;\n      }\n    }\n    const low24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_LOW24], buffdata.area);\n    const high24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_HIGH24], buffdata.area);\n    info.attributeID = getID(low24, high24);\n    return info;\n  }\n\n  // Iterate over successively growing boxes.\n  // They recursively call the base case to handle single pixels.\n  const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];\n  const curPos = [0, 0];\n  let info = getPixelInformationWithData(buffdata, inDisplayPosition, 0, outSelectedPosition);\n  if (info && info.valid) {\n    return info;\n  }\n  for (let dist = 1; dist < maxDist; ++dist) {\n    // Vertical sides of box.\n    for (let y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {\n      curPos[1] = y;\n      if (dispPos[0] >= dist) {\n        curPos[0] = dispPos[0] - dist;\n        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n        if (info && info.valid) {\n          return info;\n        }\n      }\n      curPos[0] = dispPos[0] + dist;\n      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n      if (info && info.valid) {\n        return info;\n      }\n    }\n    // Horizontal sides of box.\n    for (let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {\n      curPos[0] = x;\n      if (dispPos[1] >= dist) {\n        curPos[1] = dispPos[1] - dist;\n        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n        if (info && info.valid) {\n          return info;\n        }\n      }\n      curPos[1] = dispPos[1] + dist;\n      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n      if (info && info.valid) {\n        return info;\n      }\n    }\n  }\n\n  // nothing hit.\n  outSelectedPosition[0] = inDisplayPosition[0];\n  outSelectedPosition[1] = inDisplayPosition[1];\n  return null;\n}\n\n//-----------------------------------------------------------------------------\nfunction convertSelection(fieldassociation, dataMap, captureZValues, renderer, openGLRenderWindow) {\n  const sel = [];\n  let count = 0;\n  dataMap.forEach((value, key) => {\n    const child = vtkSelectionNode.newInstance();\n    child.setContentType(SelectionContent.INDICES);\n    switch (fieldassociation) {\n      case FieldAssociations.FIELD_ASSOCIATION_CELLS:\n        child.setFieldType(SelectionField.CELL);\n        break;\n      case FieldAssociations.FIELD_ASSOCIATION_POINTS:\n        child.setFieldType(SelectionField.POINT);\n        break;\n      default:\n        vtkErrorMacro('Unknown field association');\n    }\n    child.getProperties().propID = value.info.propID;\n    child.getProperties().prop = value.info.prop;\n    child.getProperties().compositeID = value.info.compositeID;\n    child.getProperties().attributeID = value.info.attributeID;\n    child.getProperties().pixelCount = value.pixelCount;\n    if (captureZValues) {\n      child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];\n      child.getProperties().worldPosition = openGLRenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, renderer);\n    }\n    child.setSelectionList(value.attributeIDs);\n    sel[count] = child;\n    count++;\n  });\n  return sel;\n}\n\n//----------------------------------------------------------------------------\nfunction generateSelectionWithData(buffdata, fx1, fy1, fx2, fy2) {\n  const x1 = Math.floor(fx1);\n  const y1 = Math.floor(fy1);\n  const x2 = Math.floor(fx2);\n  const y2 = Math.floor(fy2);\n  const dataMap = new Map();\n  const outSelectedPosition = [0, 0];\n  for (let yy = y1; yy <= y2; yy++) {\n    for (let xx = x1; xx <= x2; xx++) {\n      const pos = [xx, yy];\n      const info = getPixelInformationWithData(buffdata, pos, 0, outSelectedPosition);\n      if (info && info.valid) {\n        const hash = getInfoHash(info);\n        if (!dataMap.has(hash)) {\n          dataMap.set(hash, {\n            info,\n            pixelCount: 1,\n            attributeIDs: [info.attributeID]\n          });\n        } else {\n          const dmv = dataMap.get(hash);\n          dmv.pixelCount++;\n          if (buffdata.captureZValues) {\n            if (info.zValue < dmv.info.zValue) {\n              dmv.info = info;\n            }\n          }\n          if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {\n            dmv.attributeIDs.push(info.attributeID);\n          }\n        }\n      }\n    }\n  }\n  return convertSelection(buffdata.fieldAssociation, dataMap, buffdata.captureZValues, buffdata.renderer, buffdata.openGLRenderWindow);\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLHardwareSelector methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLHardwareSelector(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLHardwareSelector');\n\n  //----------------------------------------------------------------------------\n  publicAPI.releasePixBuffers = () => {\n    model.rawPixBuffer = [];\n    model.pixBuffer = [];\n    model.zBuffer = null;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.beginSelection = () => {\n    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer);\n    model.maxAttributeId = 0;\n    const size = model._openGLRenderWindow.getSize();\n    if (!model.framebuffer) {\n      model.framebuffer = vtkOpenGLFramebuffer.newInstance();\n      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.framebuffer.saveCurrentBindingsAndBuffers();\n      model.framebuffer.create(size[0], size[1]);\n      // this calls model.framebuffer.bind()\n      model.framebuffer.populateFramebuffer();\n    } else {\n      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.framebuffer.saveCurrentBindingsAndBuffers();\n      const fbSize = model.framebuffer.getSize();\n      if (fbSize[0] !== size[0] || fbSize[1] !== size[1]) {\n        model.framebuffer.create(size[0], size[1]);\n        // this calls model.framebuffer.bind()\n        model.framebuffer.populateFramebuffer();\n      } else {\n        model.framebuffer.bind();\n      }\n    }\n    model._openGLRenderer.clear();\n    model._openGLRenderer.setSelector(publicAPI);\n    model.hitProps = {};\n    model.propPixels = {};\n    model.props = [];\n    publicAPI.releasePixBuffers();\n    if (model.fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      const gl = model._openGLRenderWindow.getContext();\n      const originalBlending = gl.isEnabled(gl.BLEND);\n      gl.disable(gl.BLEND);\n      model._openGLRenderWindow.traverseAllPasses();\n      if (originalBlending) {\n        gl.enable(gl.BLEND);\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.endSelection = () => {\n    model.hitProps = {};\n    model._openGLRenderer.setSelector(null);\n    model.framebuffer.restorePreviousBindingsAndBuffers();\n  };\n  publicAPI.preCapturePass = () => {\n    const gl = model._openGLRenderWindow.getContext();\n    // Disable blending\n    model.originalBlending = gl.isEnabled(gl.BLEND);\n    gl.disable(gl.BLEND);\n  };\n  publicAPI.postCapturePass = () => {\n    const gl = model._openGLRenderWindow.getContext();\n    // Restore blending if it was enabled prior to the capture\n    if (model.originalBlending) {\n      gl.enable(gl.BLEND);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.select = () => {\n    let sel = null;\n    if (publicAPI.captureBuffers()) {\n      sel = publicAPI.generateSelection(model.area[0], model.area[1], model.area[2], model.area[3]);\n      publicAPI.releasePixBuffers();\n    }\n    return sel;\n  };\n  publicAPI.getSourceDataAsync = async (renderer, fx1, fy1, fx2, fy2) => {\n    // assign the renderer\n    model._renderer = renderer;\n\n    // set area to all if no arguments provided\n    if (fx1 === undefined) {\n      const size = model._openGLRenderWindow.getSize();\n      publicAPI.setArea(0, 0, size[0] - 1, size[1] - 1);\n    } else {\n      publicAPI.setArea(fx1, fy1, fx2, fy2);\n    }\n    // just do capture buffers and package up the result\n    if (!publicAPI.captureBuffers()) {\n      return false;\n    }\n    const result = {\n      area: [...model.area],\n      pixBuffer: [...model.pixBuffer],\n      captureZValues: model.captureZValues,\n      zBuffer: model.zBuffer,\n      props: [...model.props],\n      fieldAssociation: model.fieldAssociation,\n      renderer,\n      openGLRenderWindow: model._openGLRenderWindow\n    };\n    result.generateSelection = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return generateSelectionWithData(result, ...args);\n    };\n    return result;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.captureBuffers = () => {\n    if (!model._renderer || !model._openGLRenderWindow) {\n      vtkErrorMacro('Renderer and view must be set before calling Select.');\n      return false;\n    }\n    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer);\n\n    // todo revisit making selection part of core\n    // then we can do this in core\n    model._openGLRenderWindow.getRenderable().preRender();\n\n    // int rgba[4];\n    // rwin.getColorBufferSizes(rgba);\n    // if (rgba[0] < 8 || rgba[1] < 8 || rgba[2] < 8) {\n    //   vtkErrorMacro(\"Color buffer depth must be at least 8 bit. \"\n    //     \"Currently: \" << rgba[0] << \", \" << rgba[1] << \", \" <<rgba[2]);\n    //   return false;\n    // }\n    publicAPI.invokeEvent({\n      type: 'StartEvent'\n    });\n\n    // Initialize renderer for selection.\n    // change the renderer's background to black, which will indicate a miss\n    model.originalBackground = model._renderer.getBackgroundByReference();\n    model._renderer.setBackground(0.0, 0.0, 0.0, 0.0);\n    const rpasses = model._openGLRenderWindow.getRenderPasses();\n    publicAPI.beginSelection();\n    for (model.currentPass = PassTypes.MIN_KNOWN_PASS; model.currentPass <= PassTypes.MAX_KNOWN_PASS; model.currentPass++) {\n      if (publicAPI.passRequired(model.currentPass)) {\n        publicAPI.preCapturePass(model.currentPass);\n        if (model.captureZValues && model.currentPass === PassTypes.ACTOR_PASS && typeof rpasses[0].requestDepth === 'function' && typeof rpasses[0].getFramebuffer === 'function') {\n          rpasses[0].requestDepth();\n          model._openGLRenderWindow.traverseAllPasses();\n        } else {\n          model._openGLRenderWindow.traverseAllPasses();\n        }\n        publicAPI.postCapturePass(model.currentPass);\n        publicAPI.savePixelBuffer(model.currentPass);\n        publicAPI.processPixelBuffers();\n      }\n    }\n    publicAPI.endSelection();\n\n    // restore original background\n    model._renderer.setBackground(model.originalBackground);\n    publicAPI.invokeEvent({\n      type: 'EndEvent'\n    });\n\n    // restore image, not needed?\n    // model._openGLRenderWindow.traverseAllPasses();\n    return true;\n  };\n  publicAPI.processPixelBuffers = () => {\n    model.props.forEach((prop, index) => {\n      if (publicAPI.isPropHit(index)) {\n        prop.processSelectorPixelBuffers(publicAPI, model.propPixels[index]);\n      }\n    });\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.passRequired = pass => {\n    if (pass === PassTypes.ID_HIGH24) {\n      if (model.fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n        return model.maximumPointId > 0x00ffffff;\n      }\n      if (model.fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_CELLS) {\n        return model.maximumCellId > 0x00ffffff;\n      }\n    }\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.savePixelBuffer = passNo => {\n    model.pixBuffer[passNo] = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);\n    if (!model.rawPixBuffer[passNo]) {\n      const size = (model.area[2] - model.area[0] + 1) * (model.area[3] - model.area[1] + 1) * 4;\n      model.rawPixBuffer[passNo] = new Uint8Array(size);\n      model.rawPixBuffer[passNo].set(model.pixBuffer[passNo]);\n    }\n    if (passNo === PassTypes.ACTOR_PASS) {\n      if (model.captureZValues) {\n        const rpasses = model._openGLRenderWindow.getRenderPasses();\n        if (typeof rpasses[0].requestDepth === 'function' && typeof rpasses[0].getFramebuffer === 'function') {\n          const fb = rpasses[0].getFramebuffer();\n          fb.saveCurrentBindingsAndBuffers();\n          fb.bind();\n          model.zBuffer = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);\n          fb.restorePreviousBindingsAndBuffers();\n        }\n      }\n      publicAPI.buildPropHitList(model.rawPixBuffer[passNo]);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.buildPropHitList = pixelbuffer => {\n    let offset = 0;\n    for (let yy = 0; yy <= model.area[3] - model.area[1]; yy++) {\n      for (let xx = 0; xx <= model.area[2] - model.area[0]; xx++) {\n        let val = convert(xx, yy, pixelbuffer, model.area);\n        if (val > 0) {\n          val--;\n          if (!(val in model.hitProps)) {\n            model.hitProps[val] = true;\n            model.propPixels[val] = [];\n          }\n          model.propPixels[val].push(offset * 4);\n        }\n        ++offset;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.renderProp = prop => {\n    if (model.currentPass === PassTypes.ACTOR_PASS) {\n      publicAPI.setPropColorValueFromInt(model.props.length + idOffset);\n      model.props.push(prop);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.renderCompositeIndex = index => {\n    if (model.currentPass === PassTypes.COMPOSITE_INDEX_PASS) {\n      publicAPI.setPropColorValueFromInt(index + idOffset);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  // TODO: make inline\n  publicAPI.renderAttributeId = attribid => {\n    if (attribid < 0) {\n      // negative attribid is valid. It happens when rendering higher order\n      // elements where new points are added for rendering smooth surfaces.\n      return;\n    }\n    model.maxAttributeId = attribid > model.maxAttributeId ? attribid : model.maxAttributeId;\n\n    // if (model.currentPass < PassTypes.ID_LOW24) {\n    //   return; // useless...\n    // }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.passTypeToString = type => macro.enumToString(PassTypes, type);\n\n  //----------------------------------------------------------------------------\n  publicAPI.isPropHit = id => Boolean(model.hitProps[id]);\n  publicAPI.setPropColorValueFromInt = val => {\n    model.propColorValue[0] = val % 256 / 255.0;\n    model.propColorValue[1] = Math.floor(val / 256) % 256 / 255.0;\n    model.propColorValue[2] = Math.floor(val / 65536) % 256 / 255.0;\n  };\n\n  // info has\n  //   valid\n  //   propId\n  //   prop\n  //   compositeID\n  //   attributeID\n\n  //----------------------------------------------------------------------------\n  publicAPI.getPixelInformation = (inDisplayPosition, maxDistance, outSelectedPosition) => {\n    // Base case\n    const maxDist = maxDistance < 0 ? 0 : maxDistance;\n    if (maxDist === 0) {\n      outSelectedPosition[0] = inDisplayPosition[0];\n      outSelectedPosition[1] = inDisplayPosition[1];\n      if (inDisplayPosition[0] < model.area[0] || inDisplayPosition[0] > model.area[2] || inDisplayPosition[1] < model.area[1] || inDisplayPosition[1] > model.area[3]) {\n        return null;\n      }\n\n      // offset inDisplayPosition based on the lower-left-corner of the Area.\n      const displayPosition = [inDisplayPosition[0] - model.area[0], inDisplayPosition[1] - model.area[1]];\n      const actorid = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ACTOR_PASS], model.area);\n      if (actorid <= 0 || actorid - idOffset >= model.props.length) {\n        // the pixel did not hit any actor.\n        return null;\n      }\n      const info = {};\n      info.valid = true;\n      info.propID = actorid - idOffset;\n      info.prop = model.props[info.propID];\n      let compositeID = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.COMPOSITE_INDEX_PASS], model.area);\n      if (compositeID < 0 || compositeID > 0xffffff) {\n        compositeID = 0;\n      }\n      info.compositeID = compositeID - idOffset;\n      if (model.captureZValues) {\n        const offset = (displayPosition[1] * (model.area[2] - model.area[0] + 1) + displayPosition[0]) * 4;\n        info.zValue = (256 * model.zBuffer[offset] + model.zBuffer[offset + 1]) / 65535.0;\n        info.displayPosition = inDisplayPosition;\n      }\n\n      // Skip attribute ids if alpha is zero (missed)\n      if (model.pixBuffer[PassTypes.ID_LOW24]) {\n        if (getAlpha(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_LOW24], model.area) === 0.0) {\n          return info;\n        }\n      }\n      const low24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_LOW24], model.area);\n      const high24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_HIGH24], model.area);\n      info.attributeID = getID(low24, high24);\n      return info;\n    }\n\n    // Iterate over successively growing boxes.\n    // They recursively call the base case to handle single pixels.\n    const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];\n    const curPos = [0, 0];\n    let info = publicAPI.getPixelInformation(inDisplayPosition, 0, outSelectedPosition);\n    if (info && info.valid) {\n      return info;\n    }\n    for (let dist = 1; dist < maxDist; ++dist) {\n      // Vertical sides of box.\n      for (let y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {\n        curPos[1] = y;\n        if (dispPos[0] >= dist) {\n          curPos[0] = dispPos[0] - dist;\n          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);\n          if (info && info.valid) {\n            return info;\n          }\n        }\n        curPos[0] = dispPos[0] + dist;\n        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);\n        if (info && info.valid) {\n          return info;\n        }\n      }\n      // Horizontal sides of box.\n      for (let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {\n        curPos[0] = x;\n        if (dispPos[1] >= dist) {\n          curPos[1] = dispPos[1] - dist;\n          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);\n          if (info && info.valid) {\n            return info;\n          }\n        }\n        curPos[1] = dispPos[1] + dist;\n        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);\n        if (info && info.valid) {\n          return info;\n        }\n      }\n    }\n\n    // nothing hit.\n    outSelectedPosition[0] = inDisplayPosition[0];\n    outSelectedPosition[1] = inDisplayPosition[1];\n    return null;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.generateSelection = (fx1, fy1, fx2, fy2) => {\n    const x1 = Math.floor(fx1);\n    const y1 = Math.floor(fy1);\n    const x2 = Math.floor(fx2);\n    const y2 = Math.floor(fy2);\n    const dataMap = new Map();\n    const outSelectedPosition = [0, 0];\n    for (let yy = y1; yy <= y2; yy++) {\n      for (let xx = x1; xx <= x2; xx++) {\n        const pos = [xx, yy];\n        const info = publicAPI.getPixelInformation(pos, 0, outSelectedPosition);\n        if (info && info.valid) {\n          const hash = getInfoHash(info);\n          if (!dataMap.has(hash)) {\n            dataMap.set(hash, {\n              info,\n              pixelCount: 1,\n              attributeIDs: [info.attributeID]\n            });\n          } else {\n            const dmv = dataMap.get(hash);\n            dmv.pixelCount++;\n            if (model.captureZValues) {\n              if (info.zValue < dmv.info.zValue) {\n                dmv.info = info;\n              }\n            }\n            if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {\n              dmv.attributeIDs.push(info.attributeID);\n            }\n          }\n        }\n      }\n    }\n    return convertSelection(model.fieldAssociation, dataMap, model.captureZValues, model._renderer, model._openGLRenderWindow);\n  };\n  publicAPI.getRawPixelBuffer = passNo => model.rawPixBuffer[passNo];\n  publicAPI.getPixelBuffer = passNo => model.pixBuffer[passNo];\n\n  //----------------------------------------------------------------------------\n\n  publicAPI.attach = (w, r) => {\n    model._openGLRenderWindow = w;\n    model._renderer = r;\n  };\n\n  // override\n  const superSetArea = publicAPI.setArea;\n  publicAPI.setArea = function () {\n    if (superSetArea(...arguments)) {\n      model.area[0] = Math.floor(model.area[0]);\n      model.area[1] = Math.floor(model.area[1]);\n      model.area[2] = Math.floor(model.area[2]);\n      model.area[3] = Math.floor(model.area[3]);\n      return true;\n    }\n    return false;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  area: undefined,\n  // _renderer: null,\n  // _openGLRenderWindow: null,\n  // _openGLRenderer: null,\n  currentPass: -1,\n  propColorValue: null,\n  props: null,\n  maximumPointId: 0,\n  maximumCellId: 0,\n  idOffset: 1\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  vtkHardwareSelector$1.extend(publicAPI, model, initialValues);\n  model.propColorValue = [0, 0, 0];\n  model.props = [];\n  if (!model.area) {\n    model.area = [0, 0, 0, 0];\n  }\n  macro.setGetArray(publicAPI, model, ['area'], 4);\n  macro.setGet(publicAPI, model, ['_renderer', 'currentPass', '_openGLRenderWindow', 'maximumPointId', 'maximumCellId']);\n  macro.setGetArray(publicAPI, model, ['propColorValue'], 3);\n  macro.moveToProtected(publicAPI, model, ['renderer', 'openGLRenderWindow']);\n  macro.event(publicAPI, model, 'event');\n\n  // Object methods\n  vtkOpenGLHardwareSelector(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkOpenGLHardwareSelector');\n\n// ----------------------------------------------------------------------------\n\nvar vtkHardwareSelector = {\n  newInstance,\n  extend,\n  ...Constants\n};\nexport { vtkHardwareSelector as default, extend, newInstance };","map":{"version":3,"names":["m","macro","Constants","vtkHardwareSelector$1","vtkOpenGLFramebuffer","vtkSelectionNode","vtkDataSet","PassTypes","SelectionContent","SelectionField","FieldAssociations","vtkErrorMacro","idOffset","getInfoHash","info","propID","compositeID","getAlpha","xx","yy","pb","area","offset","convert","r","g","b","getID","low24","high8","val","getPixelInformationWithData","buffdata","inDisplayPosition","maxDistance","outSelectedPosition","maxDist","displayPosition","actorid","pixBuffer","ACTOR_PASS","props","length","valid","prop","COMPOSITE_INDEX_PASS","captureZValues","zValue","zBuffer","ID_LOW24","high24","ID_HIGH24","attributeID","dispPos","curPos","dist","y","x","convertSelection","fieldassociation","dataMap","renderer","openGLRenderWindow","sel","count","forEach","value","key","child","newInstance","setContentType","INDICES","FIELD_ASSOCIATION_CELLS","setFieldType","CELL","FIELD_ASSOCIATION_POINTS","POINT","getProperties","pixelCount","worldPosition","displayToWorld","setSelectionList","attributeIDs","generateSelectionWithData","fx1","fy1","fx2","fy2","x1","Math","floor","y1","x2","y2","Map","pos","hash","has","set","dmv","get","indexOf","push","fieldAssociation","vtkOpenGLHardwareSelector","publicAPI","model","classHierarchy","releasePixBuffers","rawPixBuffer","beginSelection","_openGLRenderer","_openGLRenderWindow","getViewNodeFor","_renderer","maxAttributeId","size","getSize","framebuffer","setOpenGLRenderWindow","saveCurrentBindingsAndBuffers","create","populateFramebuffer","fbSize","bind","clear","setSelector","hitProps","propPixels","gl","getContext","originalBlending","isEnabled","BLEND","disable","traverseAllPasses","enable","endSelection","restorePreviousBindingsAndBuffers","preCapturePass","postCapturePass","select","captureBuffers","generateSelection","getSourceDataAsync","undefined","setArea","result","_len","arguments","args","Array","_key","getRenderable","preRender","invokeEvent","type","originalBackground","getBackgroundByReference","setBackground","rpasses","getRenderPasses","currentPass","MIN_KNOWN_PASS","MAX_KNOWN_PASS","passRequired","requestDepth","getFramebuffer","savePixelBuffer","processPixelBuffers","index","isPropHit","processSelectorPixelBuffers","pass","maximumPointId","maximumCellId","passNo","getPixelData","Uint8Array","fb","buildPropHitList","pixelbuffer","renderProp","setPropColorValueFromInt","renderCompositeIndex","renderAttributeId","attribid","passTypeToString","enumToString","id","Boolean","propColorValue","getPixelInformation","getRawPixelBuffer","getPixelBuffer","attach","w","superSetArea","DEFAULT_VALUES","extend","initialValues","Object","assign","setGetArray","setGet","moveToProtected","event","vtkHardwareSelector","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport Constants from './HardwareSelector/Constants.js';\nimport vtkHardwareSelector$1 from '../Core/HardwareSelector.js';\nimport vtkOpenGLFramebuffer from './Framebuffer.js';\nimport vtkSelectionNode from '../../Common/DataModel/SelectionNode.js';\nimport vtkDataSet from '../../Common/DataModel/DataSet.js';\n\nconst {\n  PassTypes\n} = Constants;\nconst {\n  SelectionContent,\n  SelectionField\n} = vtkSelectionNode;\nconst {\n  FieldAssociations\n} = vtkDataSet;\nconst {\n  vtkErrorMacro\n} = macro;\nconst idOffset = 1;\nfunction getInfoHash(info) {\n  return `${info.propID} ${info.compositeID}`;\n}\nfunction getAlpha(xx, yy, pb, area) {\n  if (!pb) {\n    return 0;\n  }\n  const offset = (yy * (area[2] - area[0] + 1) + xx) * 4;\n  return pb[offset + 3];\n}\nfunction convert(xx, yy, pb, area) {\n  if (!pb) {\n    return 0;\n  }\n  const offset = (yy * (area[2] - area[0] + 1) + xx) * 4;\n  const r = pb[offset];\n  const g = pb[offset + 1];\n  const b = pb[offset + 2];\n  return (b * 256 + g) * 256 + r;\n}\nfunction getID(low24, high8) {\n  /* eslint-disable no-bitwise */\n  let val = high8;\n  val <<= 24;\n  val |= low24;\n  return val;\n  /* eslint-enable no-bitwise */\n}\n\nfunction getPixelInformationWithData(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {\n  // Base case\n  const maxDist = maxDistance < 0 ? 0 : maxDistance;\n  if (maxDist === 0) {\n    outSelectedPosition[0] = inDisplayPosition[0];\n    outSelectedPosition[1] = inDisplayPosition[1];\n    if (inDisplayPosition[0] < buffdata.area[0] || inDisplayPosition[0] > buffdata.area[2] || inDisplayPosition[1] < buffdata.area[1] || inDisplayPosition[1] > buffdata.area[3]) {\n      return null;\n    }\n\n    // offset inDisplayPosition based on the lower-left-corner of the Area.\n    const displayPosition = [inDisplayPosition[0] - buffdata.area[0], inDisplayPosition[1] - buffdata.area[1]];\n    const actorid = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ACTOR_PASS], buffdata.area);\n    if (actorid <= 0 || actorid - idOffset >= buffdata.props.length) {\n      // the pixel did not hit any actor.\n      return null;\n    }\n    const info = {};\n    info.valid = true;\n    info.propID = actorid - idOffset;\n    info.prop = buffdata.props[info.propID];\n    let compositeID = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.COMPOSITE_INDEX_PASS], buffdata.area);\n    if (compositeID < 0 || compositeID > 0xffffff) {\n      compositeID = 0;\n    }\n    info.compositeID = compositeID - idOffset;\n    if (buffdata.captureZValues) {\n      const offset = (displayPosition[1] * (buffdata.area[2] - buffdata.area[0] + 1) + displayPosition[0]) * 4;\n      info.zValue = (256 * buffdata.zBuffer[offset] + buffdata.zBuffer[offset + 1]) / 65535.0;\n      info.displayPosition = inDisplayPosition;\n    }\n    if (buffdata.pixBuffer[PassTypes.ID_LOW24]) {\n      if (getAlpha(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_LOW24], buffdata.area) === 0.0) {\n        return info;\n      }\n    }\n    const low24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_LOW24], buffdata.area);\n    const high24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_HIGH24], buffdata.area);\n    info.attributeID = getID(low24, high24);\n    return info;\n  }\n\n  // Iterate over successively growing boxes.\n  // They recursively call the base case to handle single pixels.\n  const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];\n  const curPos = [0, 0];\n  let info = getPixelInformationWithData(buffdata, inDisplayPosition, 0, outSelectedPosition);\n  if (info && info.valid) {\n    return info;\n  }\n  for (let dist = 1; dist < maxDist; ++dist) {\n    // Vertical sides of box.\n    for (let y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {\n      curPos[1] = y;\n      if (dispPos[0] >= dist) {\n        curPos[0] = dispPos[0] - dist;\n        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n        if (info && info.valid) {\n          return info;\n        }\n      }\n      curPos[0] = dispPos[0] + dist;\n      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n      if (info && info.valid) {\n        return info;\n      }\n    }\n    // Horizontal sides of box.\n    for (let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {\n      curPos[0] = x;\n      if (dispPos[1] >= dist) {\n        curPos[1] = dispPos[1] - dist;\n        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n        if (info && info.valid) {\n          return info;\n        }\n      }\n      curPos[1] = dispPos[1] + dist;\n      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n      if (info && info.valid) {\n        return info;\n      }\n    }\n  }\n\n  // nothing hit.\n  outSelectedPosition[0] = inDisplayPosition[0];\n  outSelectedPosition[1] = inDisplayPosition[1];\n  return null;\n}\n\n//-----------------------------------------------------------------------------\nfunction convertSelection(fieldassociation, dataMap, captureZValues, renderer, openGLRenderWindow) {\n  const sel = [];\n  let count = 0;\n  dataMap.forEach((value, key) => {\n    const child = vtkSelectionNode.newInstance();\n    child.setContentType(SelectionContent.INDICES);\n    switch (fieldassociation) {\n      case FieldAssociations.FIELD_ASSOCIATION_CELLS:\n        child.setFieldType(SelectionField.CELL);\n        break;\n      case FieldAssociations.FIELD_ASSOCIATION_POINTS:\n        child.setFieldType(SelectionField.POINT);\n        break;\n      default:\n        vtkErrorMacro('Unknown field association');\n    }\n    child.getProperties().propID = value.info.propID;\n    child.getProperties().prop = value.info.prop;\n    child.getProperties().compositeID = value.info.compositeID;\n    child.getProperties().attributeID = value.info.attributeID;\n    child.getProperties().pixelCount = value.pixelCount;\n    if (captureZValues) {\n      child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];\n      child.getProperties().worldPosition = openGLRenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, renderer);\n    }\n    child.setSelectionList(value.attributeIDs);\n    sel[count] = child;\n    count++;\n  });\n  return sel;\n}\n\n//----------------------------------------------------------------------------\nfunction generateSelectionWithData(buffdata, fx1, fy1, fx2, fy2) {\n  const x1 = Math.floor(fx1);\n  const y1 = Math.floor(fy1);\n  const x2 = Math.floor(fx2);\n  const y2 = Math.floor(fy2);\n  const dataMap = new Map();\n  const outSelectedPosition = [0, 0];\n  for (let yy = y1; yy <= y2; yy++) {\n    for (let xx = x1; xx <= x2; xx++) {\n      const pos = [xx, yy];\n      const info = getPixelInformationWithData(buffdata, pos, 0, outSelectedPosition);\n      if (info && info.valid) {\n        const hash = getInfoHash(info);\n        if (!dataMap.has(hash)) {\n          dataMap.set(hash, {\n            info,\n            pixelCount: 1,\n            attributeIDs: [info.attributeID]\n          });\n        } else {\n          const dmv = dataMap.get(hash);\n          dmv.pixelCount++;\n          if (buffdata.captureZValues) {\n            if (info.zValue < dmv.info.zValue) {\n              dmv.info = info;\n            }\n          }\n          if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {\n            dmv.attributeIDs.push(info.attributeID);\n          }\n        }\n      }\n    }\n  }\n  return convertSelection(buffdata.fieldAssociation, dataMap, buffdata.captureZValues, buffdata.renderer, buffdata.openGLRenderWindow);\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLHardwareSelector methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLHardwareSelector(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLHardwareSelector');\n\n  //----------------------------------------------------------------------------\n  publicAPI.releasePixBuffers = () => {\n    model.rawPixBuffer = [];\n    model.pixBuffer = [];\n    model.zBuffer = null;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.beginSelection = () => {\n    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer);\n    model.maxAttributeId = 0;\n    const size = model._openGLRenderWindow.getSize();\n    if (!model.framebuffer) {\n      model.framebuffer = vtkOpenGLFramebuffer.newInstance();\n      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.framebuffer.saveCurrentBindingsAndBuffers();\n      model.framebuffer.create(size[0], size[1]);\n      // this calls model.framebuffer.bind()\n      model.framebuffer.populateFramebuffer();\n    } else {\n      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.framebuffer.saveCurrentBindingsAndBuffers();\n      const fbSize = model.framebuffer.getSize();\n      if (fbSize[0] !== size[0] || fbSize[1] !== size[1]) {\n        model.framebuffer.create(size[0], size[1]);\n        // this calls model.framebuffer.bind()\n        model.framebuffer.populateFramebuffer();\n      } else {\n        model.framebuffer.bind();\n      }\n    }\n    model._openGLRenderer.clear();\n    model._openGLRenderer.setSelector(publicAPI);\n    model.hitProps = {};\n    model.propPixels = {};\n    model.props = [];\n    publicAPI.releasePixBuffers();\n    if (model.fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      const gl = model._openGLRenderWindow.getContext();\n      const originalBlending = gl.isEnabled(gl.BLEND);\n      gl.disable(gl.BLEND);\n      model._openGLRenderWindow.traverseAllPasses();\n      if (originalBlending) {\n        gl.enable(gl.BLEND);\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.endSelection = () => {\n    model.hitProps = {};\n    model._openGLRenderer.setSelector(null);\n    model.framebuffer.restorePreviousBindingsAndBuffers();\n  };\n  publicAPI.preCapturePass = () => {\n    const gl = model._openGLRenderWindow.getContext();\n    // Disable blending\n    model.originalBlending = gl.isEnabled(gl.BLEND);\n    gl.disable(gl.BLEND);\n  };\n  publicAPI.postCapturePass = () => {\n    const gl = model._openGLRenderWindow.getContext();\n    // Restore blending if it was enabled prior to the capture\n    if (model.originalBlending) {\n      gl.enable(gl.BLEND);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.select = () => {\n    let sel = null;\n    if (publicAPI.captureBuffers()) {\n      sel = publicAPI.generateSelection(model.area[0], model.area[1], model.area[2], model.area[3]);\n      publicAPI.releasePixBuffers();\n    }\n    return sel;\n  };\n  publicAPI.getSourceDataAsync = async (renderer, fx1, fy1, fx2, fy2) => {\n    // assign the renderer\n    model._renderer = renderer;\n\n    // set area to all if no arguments provided\n    if (fx1 === undefined) {\n      const size = model._openGLRenderWindow.getSize();\n      publicAPI.setArea(0, 0, size[0] - 1, size[1] - 1);\n    } else {\n      publicAPI.setArea(fx1, fy1, fx2, fy2);\n    }\n    // just do capture buffers and package up the result\n    if (!publicAPI.captureBuffers()) {\n      return false;\n    }\n    const result = {\n      area: [...model.area],\n      pixBuffer: [...model.pixBuffer],\n      captureZValues: model.captureZValues,\n      zBuffer: model.zBuffer,\n      props: [...model.props],\n      fieldAssociation: model.fieldAssociation,\n      renderer,\n      openGLRenderWindow: model._openGLRenderWindow\n    };\n    result.generateSelection = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return generateSelectionWithData(result, ...args);\n    };\n    return result;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.captureBuffers = () => {\n    if (!model._renderer || !model._openGLRenderWindow) {\n      vtkErrorMacro('Renderer and view must be set before calling Select.');\n      return false;\n    }\n    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer);\n\n    // todo revisit making selection part of core\n    // then we can do this in core\n    model._openGLRenderWindow.getRenderable().preRender();\n\n    // int rgba[4];\n    // rwin.getColorBufferSizes(rgba);\n    // if (rgba[0] < 8 || rgba[1] < 8 || rgba[2] < 8) {\n    //   vtkErrorMacro(\"Color buffer depth must be at least 8 bit. \"\n    //     \"Currently: \" << rgba[0] << \", \" << rgba[1] << \", \" <<rgba[2]);\n    //   return false;\n    // }\n    publicAPI.invokeEvent({\n      type: 'StartEvent'\n    });\n\n    // Initialize renderer for selection.\n    // change the renderer's background to black, which will indicate a miss\n    model.originalBackground = model._renderer.getBackgroundByReference();\n    model._renderer.setBackground(0.0, 0.0, 0.0, 0.0);\n    const rpasses = model._openGLRenderWindow.getRenderPasses();\n    publicAPI.beginSelection();\n    for (model.currentPass = PassTypes.MIN_KNOWN_PASS; model.currentPass <= PassTypes.MAX_KNOWN_PASS; model.currentPass++) {\n      if (publicAPI.passRequired(model.currentPass)) {\n        publicAPI.preCapturePass(model.currentPass);\n        if (model.captureZValues && model.currentPass === PassTypes.ACTOR_PASS && typeof rpasses[0].requestDepth === 'function' && typeof rpasses[0].getFramebuffer === 'function') {\n          rpasses[0].requestDepth();\n          model._openGLRenderWindow.traverseAllPasses();\n        } else {\n          model._openGLRenderWindow.traverseAllPasses();\n        }\n        publicAPI.postCapturePass(model.currentPass);\n        publicAPI.savePixelBuffer(model.currentPass);\n        publicAPI.processPixelBuffers();\n      }\n    }\n    publicAPI.endSelection();\n\n    // restore original background\n    model._renderer.setBackground(model.originalBackground);\n    publicAPI.invokeEvent({\n      type: 'EndEvent'\n    });\n\n    // restore image, not needed?\n    // model._openGLRenderWindow.traverseAllPasses();\n    return true;\n  };\n  publicAPI.processPixelBuffers = () => {\n    model.props.forEach((prop, index) => {\n      if (publicAPI.isPropHit(index)) {\n        prop.processSelectorPixelBuffers(publicAPI, model.propPixels[index]);\n      }\n    });\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.passRequired = pass => {\n    if (pass === PassTypes.ID_HIGH24) {\n      if (model.fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n        return model.maximumPointId > 0x00ffffff;\n      }\n      if (model.fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_CELLS) {\n        return model.maximumCellId > 0x00ffffff;\n      }\n    }\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.savePixelBuffer = passNo => {\n    model.pixBuffer[passNo] = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);\n    if (!model.rawPixBuffer[passNo]) {\n      const size = (model.area[2] - model.area[0] + 1) * (model.area[3] - model.area[1] + 1) * 4;\n      model.rawPixBuffer[passNo] = new Uint8Array(size);\n      model.rawPixBuffer[passNo].set(model.pixBuffer[passNo]);\n    }\n    if (passNo === PassTypes.ACTOR_PASS) {\n      if (model.captureZValues) {\n        const rpasses = model._openGLRenderWindow.getRenderPasses();\n        if (typeof rpasses[0].requestDepth === 'function' && typeof rpasses[0].getFramebuffer === 'function') {\n          const fb = rpasses[0].getFramebuffer();\n          fb.saveCurrentBindingsAndBuffers();\n          fb.bind();\n          model.zBuffer = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);\n          fb.restorePreviousBindingsAndBuffers();\n        }\n      }\n      publicAPI.buildPropHitList(model.rawPixBuffer[passNo]);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.buildPropHitList = pixelbuffer => {\n    let offset = 0;\n    for (let yy = 0; yy <= model.area[3] - model.area[1]; yy++) {\n      for (let xx = 0; xx <= model.area[2] - model.area[0]; xx++) {\n        let val = convert(xx, yy, pixelbuffer, model.area);\n        if (val > 0) {\n          val--;\n          if (!(val in model.hitProps)) {\n            model.hitProps[val] = true;\n            model.propPixels[val] = [];\n          }\n          model.propPixels[val].push(offset * 4);\n        }\n        ++offset;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.renderProp = prop => {\n    if (model.currentPass === PassTypes.ACTOR_PASS) {\n      publicAPI.setPropColorValueFromInt(model.props.length + idOffset);\n      model.props.push(prop);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.renderCompositeIndex = index => {\n    if (model.currentPass === PassTypes.COMPOSITE_INDEX_PASS) {\n      publicAPI.setPropColorValueFromInt(index + idOffset);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  // TODO: make inline\n  publicAPI.renderAttributeId = attribid => {\n    if (attribid < 0) {\n      // negative attribid is valid. It happens when rendering higher order\n      // elements where new points are added for rendering smooth surfaces.\n      return;\n    }\n    model.maxAttributeId = attribid > model.maxAttributeId ? attribid : model.maxAttributeId;\n\n    // if (model.currentPass < PassTypes.ID_LOW24) {\n    //   return; // useless...\n    // }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.passTypeToString = type => macro.enumToString(PassTypes, type);\n\n  //----------------------------------------------------------------------------\n  publicAPI.isPropHit = id => Boolean(model.hitProps[id]);\n  publicAPI.setPropColorValueFromInt = val => {\n    model.propColorValue[0] = val % 256 / 255.0;\n    model.propColorValue[1] = Math.floor(val / 256) % 256 / 255.0;\n    model.propColorValue[2] = Math.floor(val / 65536) % 256 / 255.0;\n  };\n\n  // info has\n  //   valid\n  //   propId\n  //   prop\n  //   compositeID\n  //   attributeID\n\n  //----------------------------------------------------------------------------\n  publicAPI.getPixelInformation = (inDisplayPosition, maxDistance, outSelectedPosition) => {\n    // Base case\n    const maxDist = maxDistance < 0 ? 0 : maxDistance;\n    if (maxDist === 0) {\n      outSelectedPosition[0] = inDisplayPosition[0];\n      outSelectedPosition[1] = inDisplayPosition[1];\n      if (inDisplayPosition[0] < model.area[0] || inDisplayPosition[0] > model.area[2] || inDisplayPosition[1] < model.area[1] || inDisplayPosition[1] > model.area[3]) {\n        return null;\n      }\n\n      // offset inDisplayPosition based on the lower-left-corner of the Area.\n      const displayPosition = [inDisplayPosition[0] - model.area[0], inDisplayPosition[1] - model.area[1]];\n      const actorid = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ACTOR_PASS], model.area);\n      if (actorid <= 0 || actorid - idOffset >= model.props.length) {\n        // the pixel did not hit any actor.\n        return null;\n      }\n      const info = {};\n      info.valid = true;\n      info.propID = actorid - idOffset;\n      info.prop = model.props[info.propID];\n      let compositeID = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.COMPOSITE_INDEX_PASS], model.area);\n      if (compositeID < 0 || compositeID > 0xffffff) {\n        compositeID = 0;\n      }\n      info.compositeID = compositeID - idOffset;\n      if (model.captureZValues) {\n        const offset = (displayPosition[1] * (model.area[2] - model.area[0] + 1) + displayPosition[0]) * 4;\n        info.zValue = (256 * model.zBuffer[offset] + model.zBuffer[offset + 1]) / 65535.0;\n        info.displayPosition = inDisplayPosition;\n      }\n\n      // Skip attribute ids if alpha is zero (missed)\n      if (model.pixBuffer[PassTypes.ID_LOW24]) {\n        if (getAlpha(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_LOW24], model.area) === 0.0) {\n          return info;\n        }\n      }\n      const low24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_LOW24], model.area);\n      const high24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_HIGH24], model.area);\n      info.attributeID = getID(low24, high24);\n      return info;\n    }\n\n    // Iterate over successively growing boxes.\n    // They recursively call the base case to handle single pixels.\n    const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];\n    const curPos = [0, 0];\n    let info = publicAPI.getPixelInformation(inDisplayPosition, 0, outSelectedPosition);\n    if (info && info.valid) {\n      return info;\n    }\n    for (let dist = 1; dist < maxDist; ++dist) {\n      // Vertical sides of box.\n      for (let y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {\n        curPos[1] = y;\n        if (dispPos[0] >= dist) {\n          curPos[0] = dispPos[0] - dist;\n          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);\n          if (info && info.valid) {\n            return info;\n          }\n        }\n        curPos[0] = dispPos[0] + dist;\n        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);\n        if (info && info.valid) {\n          return info;\n        }\n      }\n      // Horizontal sides of box.\n      for (let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {\n        curPos[0] = x;\n        if (dispPos[1] >= dist) {\n          curPos[1] = dispPos[1] - dist;\n          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);\n          if (info && info.valid) {\n            return info;\n          }\n        }\n        curPos[1] = dispPos[1] + dist;\n        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);\n        if (info && info.valid) {\n          return info;\n        }\n      }\n    }\n\n    // nothing hit.\n    outSelectedPosition[0] = inDisplayPosition[0];\n    outSelectedPosition[1] = inDisplayPosition[1];\n    return null;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.generateSelection = (fx1, fy1, fx2, fy2) => {\n    const x1 = Math.floor(fx1);\n    const y1 = Math.floor(fy1);\n    const x2 = Math.floor(fx2);\n    const y2 = Math.floor(fy2);\n    const dataMap = new Map();\n    const outSelectedPosition = [0, 0];\n    for (let yy = y1; yy <= y2; yy++) {\n      for (let xx = x1; xx <= x2; xx++) {\n        const pos = [xx, yy];\n        const info = publicAPI.getPixelInformation(pos, 0, outSelectedPosition);\n        if (info && info.valid) {\n          const hash = getInfoHash(info);\n          if (!dataMap.has(hash)) {\n            dataMap.set(hash, {\n              info,\n              pixelCount: 1,\n              attributeIDs: [info.attributeID]\n            });\n          } else {\n            const dmv = dataMap.get(hash);\n            dmv.pixelCount++;\n            if (model.captureZValues) {\n              if (info.zValue < dmv.info.zValue) {\n                dmv.info = info;\n              }\n            }\n            if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {\n              dmv.attributeIDs.push(info.attributeID);\n            }\n          }\n        }\n      }\n    }\n    return convertSelection(model.fieldAssociation, dataMap, model.captureZValues, model._renderer, model._openGLRenderWindow);\n  };\n  publicAPI.getRawPixelBuffer = passNo => model.rawPixBuffer[passNo];\n  publicAPI.getPixelBuffer = passNo => model.pixBuffer[passNo];\n\n  //----------------------------------------------------------------------------\n\n  publicAPI.attach = (w, r) => {\n    model._openGLRenderWindow = w;\n    model._renderer = r;\n  };\n\n  // override\n  const superSetArea = publicAPI.setArea;\n  publicAPI.setArea = function () {\n    if (superSetArea(...arguments)) {\n      model.area[0] = Math.floor(model.area[0]);\n      model.area[1] = Math.floor(model.area[1]);\n      model.area[2] = Math.floor(model.area[2]);\n      model.area[3] = Math.floor(model.area[3]);\n      return true;\n    }\n    return false;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  area: undefined,\n  // _renderer: null,\n  // _openGLRenderWindow: null,\n  // _openGLRenderer: null,\n  currentPass: -1,\n  propColorValue: null,\n  props: null,\n  maximumPointId: 0,\n  maximumCellId: 0,\n  idOffset: 1\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  vtkHardwareSelector$1.extend(publicAPI, model, initialValues);\n  model.propColorValue = [0, 0, 0];\n  model.props = [];\n  if (!model.area) {\n    model.area = [0, 0, 0, 0];\n  }\n  macro.setGetArray(publicAPI, model, ['area'], 4);\n  macro.setGet(publicAPI, model, ['_renderer', 'currentPass', '_openGLRenderWindow', 'maximumPointId', 'maximumCellId']);\n  macro.setGetArray(publicAPI, model, ['propColorValue'], 3);\n  macro.moveToProtected(publicAPI, model, ['renderer', 'openGLRenderWindow']);\n  macro.event(publicAPI, model, 'event');\n\n  // Object methods\n  vtkOpenGLHardwareSelector(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkOpenGLHardwareSelector');\n\n// ----------------------------------------------------------------------------\n\nvar vtkHardwareSelector = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\nexport { vtkHardwareSelector as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}