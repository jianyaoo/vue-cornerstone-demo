{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkCellArray from '../../Common/Core/CellArray.js';\nimport vtkPolygon from '../../Common/DataModel/Polygon.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport { vtkCCSMakePolysFromLines, vtkCCSJoinLooseEnds, vtkCCSFindTrueEdges, vtkCCSMakeHoleyPolys, vtkCCSCutHoleyPolys, vtkCCSSplitAtPinchPoints, vtkCCSTriangulate } from './ContourTriangulator/helper.js';\nconst {\n  vtkErrorMacro\n} = macro;\nconst TRIANGULATION_ERROR_DISPLAY = false;\n\n//------------------------------------------------------------------------------\nfunction triangulateContours(polyData, firstLine, numLines, polys, normal) {\n  let triangulatePolys = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  let triangulationFailure = false;\n\n  // If no cut lines were generated, there's nothing to do\n  if (numLines <= 0) {\n    return false;\n  }\n  const points = polyData.getPoints();\n\n  // Join all the new lines into connected groups, i.e. polygons.\n  // If we are lucky these will be simple, convex polygons. But\n  // we can't count on that.\n\n  const newPolys = [];\n  const incompletePolys = [];\n  const oriented = normal?.length < 3;\n  vtkCCSMakePolysFromLines(polyData, firstLine, firstLine + numLines, oriented, newPolys, incompletePolys);\n\n  // if no normal specified, then compute one from largest contour\n  let computedNormal = normal;\n  if (!oriented) {\n    computedNormal = [0, 0, 1];\n    let maxnorm = 0;\n    const n = [];\n    for (let i = 0; i < newPolys.length; i++) {\n      const norm = vtkPolygon.getNormal(newPolys[i], points, n);\n      if (norm > maxnorm) {\n        maxnorm = norm;\n        computedNormal[0] = n[0];\n        computedNormal[1] = n[1];\n        computedNormal[2] = n[2];\n      }\n    }\n  }\n\n  // Join any loose ends. If the input was a closed surface then there\n  // will not be any loose ends, so this is provided as a service to users\n  // who want to clip a non-closed surface.\n  vtkCCSJoinLooseEnds(newPolys, incompletePolys, points, computedNormal);\n\n  // Some points might be in the middle of straight line segments.\n  // These points can be removed without changing the shape of the\n  // polys, and removing them makes triangulation more stable.\n  // Unfortunately removing these points also means that the polys\n  // will no longer form a watertight cap over the cut.\n\n  const polyEdges = [];\n  const originalEdges = [];\n  vtkCCSFindTrueEdges(newPolys, points, polyEdges, originalEdges);\n\n  // Next we have to check for polygons with holes, i.e. polygons that\n  // have other polygons inside. Each polygon is \"grouped\" with the\n  // polygons that make up its holes.\n\n  // Initialize each group to hold just one polygon.\n  const numNewPolys = newPolys.length;\n  const polyGroups = new Array(numNewPolys);\n  for (let i = 0; i < numNewPolys; i++) {\n    polyGroups[i] = [i];\n  }\n\n  // Find out which polys are holes in larger polys. Create a group\n  // for each poly where the first member of the group is the larger\n  // poly, and all other members are the holes. The number of polyGroups\n  // will be the same as the number of polys, and any polys that are\n  // holes will have a matching empty group.\n\n  vtkCCSMakeHoleyPolys(newPolys, points, polyGroups, polyEdges, originalEdges, computedNormal, oriented);\n\n  // Make cuts to create simple polygons out of the holey polys.\n  // After this is done, each polyGroup will have exactly 1 polygon,\n  // and no polys will be holes. This is currently the most computationally\n  // expensive part of the process.\n\n  if (!vtkCCSCutHoleyPolys(newPolys, points, polyGroups, polyEdges, computedNormal)) {\n    triangulationFailure = true;\n  }\n\n  // Some polys might be self-intersecting. Split the polys at each intersection point.\n  vtkCCSSplitAtPinchPoints(newPolys, points, polyGroups, polyEdges, computedNormal, oriented);\n\n  // ------ Triangulation code ------\n\n  // Go through all polys and triangulate them\n  for (let polyId = 0; polyId < polyGroups.length; polyId++) {\n    // If group is empty, then poly was a hole without a containing poly\n    if (polyGroups[polyId].length === 0) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    if (!triangulatePolys) {\n      polys.insertNextCell(originalEdges.slice(1, originalEdges.length));\n    } else if (!vtkCCSTriangulate(newPolys[polyId], points, polyEdges[polyId], originalEdges, polys, computedNormal)) {\n      triangulationFailure = false;\n    }\n  }\n  return !triangulationFailure;\n}\n\n// ---------------------------------------------------\nfunction triangulatePolygon(polygon, points, triangles) {\n  const poly = [...polygon];\n  const polys = [poly];\n  const originalEdges = [];\n  const polyEdges = [];\n  vtkCCSFindTrueEdges(polys, points, polyEdges, originalEdges);\n  const edges = polyEdges[0];\n  let success = true;\n  const normal = [];\n  const norm = vtkPolygon.getNormal(poly, points, normal);\n  if (norm !== 0) {\n    success = vtkCCSTriangulate(poly, points, edges, originalEdges, triangles, normal);\n  }\n  return success;\n}\nconst STATIC = {\n  triangulateContours,\n  triangulatePolygon\n};\nfunction vtkContourTriangulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkContourTriangulator');\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    // FIXME: do not instantiate a new polydata each time the filter is executed.\n    const output = vtkPolyData.newInstance();\n    outData[0] = output;\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return false;\n    }\n    let triangulationError = false;\n    const lines = input.getLines();\n    if (lines == null || lines.getNumberOfCells() === 0) {\n      return true;\n    }\n    input.buildCells();\n    const polysArray = vtkCellArray.newInstance({\n      dataType: VtkDataTypes.DOUBLE,\n      empty: true\n    });\n    output.setPolys(polysArray);\n    output.setPoints(input.getPoints());\n    output.getPointData().passData(input.getPointData());\n    triangulationError = !triangulateContours(input, input.getNumberOfVerts(), lines.getNumberOfCells(), polysArray, null, model.triangulatePolys);\n    if (triangulationError && TRIANGULATION_ERROR_DISPLAY) {\n      vtkErrorMacro('Triangulation failed, output might have holes.');\n    }\n    return true;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  triangulatePolys: true\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['triangulatePolys']);\n\n  // Object specific methods\n  vtkContourTriangulator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkContourTriangulator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkContourTriangulator$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\nexport { STATIC, vtkContourTriangulator$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkCellArray","vtkPolygon","vtkPolyData","VtkDataTypes","vtkCCSMakePolysFromLines","vtkCCSJoinLooseEnds","vtkCCSFindTrueEdges","vtkCCSMakeHoleyPolys","vtkCCSCutHoleyPolys","vtkCCSSplitAtPinchPoints","vtkCCSTriangulate","vtkErrorMacro","TRIANGULATION_ERROR_DISPLAY","triangulateContours","polyData","firstLine","numLines","polys","normal","triangulatePolys","arguments","length","undefined","triangulationFailure","points","getPoints","newPolys","incompletePolys","oriented","computedNormal","maxnorm","n","i","norm","getNormal","polyEdges","originalEdges","numNewPolys","polyGroups","Array","polyId","insertNextCell","slice","triangulatePolygon","polygon","triangles","poly","edges","success","STATIC","vtkContourTriangulator","publicAPI","model","classHierarchy","push","requestData","inData","outData","input","output","newInstance","triangulationError","lines","getLines","getNumberOfCells","buildCells","polysArray","dataType","DOUBLE","empty","setPolys","setPoints","getPointData","passData","getNumberOfVerts","DEFAULT_VALUES","extend","initialValues","Object","assign","obj","algo","setGet","vtkContourTriangulator$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Filters/General/ContourTriangulator.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkCellArray from '../../Common/Core/CellArray.js';\nimport vtkPolygon from '../../Common/DataModel/Polygon.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport { vtkCCSMakePolysFromLines, vtkCCSJoinLooseEnds, vtkCCSFindTrueEdges, vtkCCSMakeHoleyPolys, vtkCCSCutHoleyPolys, vtkCCSSplitAtPinchPoints, vtkCCSTriangulate } from './ContourTriangulator/helper.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nconst TRIANGULATION_ERROR_DISPLAY = false;\n\n//------------------------------------------------------------------------------\nfunction triangulateContours(polyData, firstLine, numLines, polys, normal) {\n  let triangulatePolys = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  let triangulationFailure = false;\n\n  // If no cut lines were generated, there's nothing to do\n  if (numLines <= 0) {\n    return false;\n  }\n  const points = polyData.getPoints();\n\n  // Join all the new lines into connected groups, i.e. polygons.\n  // If we are lucky these will be simple, convex polygons. But\n  // we can't count on that.\n\n  const newPolys = [];\n  const incompletePolys = [];\n  const oriented = normal?.length < 3;\n  vtkCCSMakePolysFromLines(polyData, firstLine, firstLine + numLines, oriented, newPolys, incompletePolys);\n\n  // if no normal specified, then compute one from largest contour\n  let computedNormal = normal;\n  if (!oriented) {\n    computedNormal = [0, 0, 1];\n    let maxnorm = 0;\n    const n = [];\n    for (let i = 0; i < newPolys.length; i++) {\n      const norm = vtkPolygon.getNormal(newPolys[i], points, n);\n      if (norm > maxnorm) {\n        maxnorm = norm;\n        computedNormal[0] = n[0];\n        computedNormal[1] = n[1];\n        computedNormal[2] = n[2];\n      }\n    }\n  }\n\n  // Join any loose ends. If the input was a closed surface then there\n  // will not be any loose ends, so this is provided as a service to users\n  // who want to clip a non-closed surface.\n  vtkCCSJoinLooseEnds(newPolys, incompletePolys, points, computedNormal);\n\n  // Some points might be in the middle of straight line segments.\n  // These points can be removed without changing the shape of the\n  // polys, and removing them makes triangulation more stable.\n  // Unfortunately removing these points also means that the polys\n  // will no longer form a watertight cap over the cut.\n\n  const polyEdges = [];\n  const originalEdges = [];\n  vtkCCSFindTrueEdges(newPolys, points, polyEdges, originalEdges);\n\n  // Next we have to check for polygons with holes, i.e. polygons that\n  // have other polygons inside. Each polygon is \"grouped\" with the\n  // polygons that make up its holes.\n\n  // Initialize each group to hold just one polygon.\n  const numNewPolys = newPolys.length;\n  const polyGroups = new Array(numNewPolys);\n  for (let i = 0; i < numNewPolys; i++) {\n    polyGroups[i] = [i];\n  }\n\n  // Find out which polys are holes in larger polys. Create a group\n  // for each poly where the first member of the group is the larger\n  // poly, and all other members are the holes. The number of polyGroups\n  // will be the same as the number of polys, and any polys that are\n  // holes will have a matching empty group.\n\n  vtkCCSMakeHoleyPolys(newPolys, points, polyGroups, polyEdges, originalEdges, computedNormal, oriented);\n\n  // Make cuts to create simple polygons out of the holey polys.\n  // After this is done, each polyGroup will have exactly 1 polygon,\n  // and no polys will be holes. This is currently the most computationally\n  // expensive part of the process.\n\n  if (!vtkCCSCutHoleyPolys(newPolys, points, polyGroups, polyEdges, computedNormal)) {\n    triangulationFailure = true;\n  }\n\n  // Some polys might be self-intersecting. Split the polys at each intersection point.\n  vtkCCSSplitAtPinchPoints(newPolys, points, polyGroups, polyEdges, computedNormal, oriented);\n\n  // ------ Triangulation code ------\n\n  // Go through all polys and triangulate them\n  for (let polyId = 0; polyId < polyGroups.length; polyId++) {\n    // If group is empty, then poly was a hole without a containing poly\n    if (polyGroups[polyId].length === 0) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    if (!triangulatePolys) {\n      polys.insertNextCell(originalEdges.slice(1, originalEdges.length));\n    } else if (!vtkCCSTriangulate(newPolys[polyId], points, polyEdges[polyId], originalEdges, polys, computedNormal)) {\n      triangulationFailure = false;\n    }\n  }\n  return !triangulationFailure;\n}\n\n// ---------------------------------------------------\nfunction triangulatePolygon(polygon, points, triangles) {\n  const poly = [...polygon];\n  const polys = [poly];\n  const originalEdges = [];\n  const polyEdges = [];\n  vtkCCSFindTrueEdges(polys, points, polyEdges, originalEdges);\n  const edges = polyEdges[0];\n  let success = true;\n  const normal = [];\n  const norm = vtkPolygon.getNormal(poly, points, normal);\n  if (norm !== 0) {\n    success = vtkCCSTriangulate(poly, points, edges, originalEdges, triangles, normal);\n  }\n  return success;\n}\nconst STATIC = {\n  triangulateContours,\n  triangulatePolygon\n};\nfunction vtkContourTriangulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkContourTriangulator');\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    // FIXME: do not instantiate a new polydata each time the filter is executed.\n    const output = vtkPolyData.newInstance();\n    outData[0] = output;\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return false;\n    }\n    let triangulationError = false;\n    const lines = input.getLines();\n    if (lines == null || lines.getNumberOfCells() === 0) {\n      return true;\n    }\n    input.buildCells();\n    const polysArray = vtkCellArray.newInstance({\n      dataType: VtkDataTypes.DOUBLE,\n      empty: true\n    });\n    output.setPolys(polysArray);\n    output.setPoints(input.getPoints());\n    output.getPointData().passData(input.getPointData());\n    triangulationError = !triangulateContours(input, input.getNumberOfVerts(), lines.getNumberOfCells(), polysArray, null, model.triangulatePolys);\n    if (triangulationError && TRIANGULATION_ERROR_DISPLAY) {\n      vtkErrorMacro('Triangulation failed, output might have holes.');\n    }\n    return true;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  triangulatePolys: true\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['triangulatePolys']);\n\n  // Object specific methods\n  vtkContourTriangulator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkContourTriangulator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkContourTriangulator$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkContourTriangulator$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}