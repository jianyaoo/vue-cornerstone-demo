"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@cornerstonejs/core");
const base_1 = require("../base");
const triggerSegmentationEvents_1 = require("../../stateManagement/segmentation/triggerSegmentationEvents");
const triggerAnnotationRenderForViewportIds_1 = __importDefault(require("../../utilities/triggerAnnotationRenderForViewportIds"));
const stackVolumeCheck_1 = require("./strategies/utils/stackVolumeCheck");
const activeSegmentation_1 = require("../../stateManagement/segmentation/activeSegmentation");
const SegmentationRepresentations_1 = __importDefault(require("../../enums/SegmentationRepresentations"));
const segmentIndex_1 = require("../../stateManagement/segmentation/segmentIndex");
class SegmentSelectTool extends base_1.BaseTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            hoverTimeout: 750,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.mouseMoveCallback = (evt) => {
            if (this.hoverTimer) {
                clearTimeout(this.hoverTimer);
            }
            this.hoverTimer = setTimeout(() => {
                this._setActiveSegment(evt);
                this.hoverTimer = null;
            }, this.configuration.hoverTimeout);
            return true;
        };
        this.onSetToolEnabled = () => {
            this.onSetToolActive();
        };
        this.onSetToolActive = () => {
            this.hoverTimer = null;
        };
        this.onSetToolDisabled = () => {
            this.hoverTimer = null;
        };
        this.hoverTimer = null;
    }
    _setActiveSegment(evt = {}) {
        const { element, currentPoints } = evt.detail;
        const worldPoint = currentPoints.world;
        const enabledElement = (0, core_1.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        const { viewport } = enabledElement;
        const activeSegmentation = (0, activeSegmentation_1.getActiveSegmentation)(this.toolGroupId);
        if (activeSegmentation.type === SegmentationRepresentations_1.default.Labelmap) {
            this._setActiveSegmentLabelmap(activeSegmentation, worldPoint, viewport);
        }
        else {
            throw Error('non-labelmap segmentation not supported yet');
        }
    }
    _setActiveSegmentLabelmap(activeSegmentation, worldPoint, viewport) {
        const imageDataInfo = viewport.getImageData();
        if (!imageDataInfo) {
            return;
        }
        const labelmapData = activeSegmentation.representationData.LABELMAP;
        let hoveredSegmentIndex;
        if ((0, stackVolumeCheck_1.isVolumeSegmentation)(activeSegmentation.representationData.LABELMAP)) {
            const { volumeId } = labelmapData;
            const segmentationVolume = core_1.cache.getVolume(volumeId);
            if (!segmentationVolume) {
                return;
            }
            hoveredSegmentIndex =
                segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);
        }
        else {
            const { imageIdReferenceMap } = labelmapData;
            const currentImageId = viewport.getCurrentImageId();
            const segmentationImageId = imageIdReferenceMap.get(currentImageId);
            const image = core_1.cache.getImage(segmentationImageId);
            if (!image) {
                return;
            }
            const activeSegmentationRepresentation = (0, activeSegmentation_1.getActiveSegmentationRepresentation)(this.toolGroupId);
            if (!activeSegmentationRepresentation) {
                return;
            }
            const segmentationActor = viewport.getActor(activeSegmentationRepresentation.segmentationRepresentationUID);
            const imageData = segmentationActor === null || segmentationActor === void 0 ? void 0 : segmentationActor.actor.getMapper().getInputData();
            const indexIJK = core_1.utilities.transformWorldToIndex(imageData, worldPoint);
            const flattenedIndex = indexIJK[0] + indexIJK[1] * image.columns;
            const scalars = imageData.getPointData().getScalars().getData();
            hoveredSegmentIndex = scalars[flattenedIndex];
        }
        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {
            return;
        }
        (0, segmentIndex_1.setActiveSegmentIndex)(activeSegmentation.segmentationId, hoveredSegmentIndex);
        const renderingEngine = viewport.getRenderingEngine();
        (0, triggerSegmentationEvents_1.triggerSegmentationModified)(activeSegmentation.segmentationId);
        (0, triggerAnnotationRenderForViewportIds_1.default)(renderingEngine, renderingEngine.getViewports().map((v) => v.id));
    }
}
SegmentSelectTool.toolName = 'SegmentSelectTool';
exports.default = SegmentSelectTool;
//# sourceMappingURL=SegmentSelectTool.js.map