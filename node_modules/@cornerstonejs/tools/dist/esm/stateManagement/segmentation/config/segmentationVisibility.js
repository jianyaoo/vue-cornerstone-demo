import { cache } from '@cornerstonejs/core';
import * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';
import { getSegmentationRepresentations } from '../../../stateManagement/segmentation/segmentationState';
import { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';
import SegmentationRepresentations from '../../../enums/SegmentationRepresentations';
function getUniqueSegmentIndices(segmentationId) {
    const segmentation = SegmentationState.getSegmentation(segmentationId);
    if (segmentation.type === SegmentationRepresentations.Labelmap) {
        const volume = cache.getVolume(segmentationId);
        const scalarData = volume.getScalarData();
        const keySet = {};
        for (let i = 0; i < scalarData.length; i++) {
            const segmentIndex = scalarData[i];
            if (segmentIndex !== 0 && !keySet[segmentIndex]) {
                keySet[segmentIndex] = true;
            }
        }
        return Object.keys(keySet).map((it) => parseInt(it, 10));
    }
    else if (segmentation.type === SegmentationRepresentations.Contour) {
        const annotationUIDsMap = segmentation.representationData.CONTOUR?.annotationUIDsMap;
        const indices = new Set(annotationUIDsMap.keys());
        const geometryIds = segmentation.representationData.CONTOUR?.geometryIds;
        if (!geometryIds) {
            throw new Error(`No geometryIds found for segmentationId ${segmentationId}`);
        }
        geometryIds.forEach((geometryId) => {
            const geometry = cache.getGeometry(geometryId);
            indices.add(geometry.data.getSegmentIndex());
        });
        return Array.from(indices.values()).sort();
    }
}
function setSegmentationVisibility(toolGroupId, segmentationRepresentationUID, visibility) {
    const toolGroupSegmentationRepresentations = getSegmentationRepresentations(toolGroupId);
    if (!toolGroupSegmentationRepresentations) {
        return;
    }
    const representation = toolGroupSegmentationRepresentations.find((representation) => representation.segmentationRepresentationUID ===
        segmentationRepresentationUID);
    if (!representation) {
        return;
    }
    const { segmentsHidden, segmentationId } = representation;
    const indices = getUniqueSegmentIndices(segmentationId);
    if (visibility) {
        segmentsHidden.clear();
    }
    else {
        indices.forEach((index) => {
            segmentsHidden.add(index);
        });
    }
    triggerSegmentationRepresentationModified(toolGroupId, representation.segmentationRepresentationUID);
}
function getSegmentationVisibility(toolGroupId, segmentationRepresentationUID) {
    const toolGroupSegmentationRepresentations = getSegmentationRepresentations(toolGroupId);
    const representation = toolGroupSegmentationRepresentations.find((representation) => representation.segmentationRepresentationUID ===
        segmentationRepresentationUID);
    if (!representation) {
        return;
    }
    const { segmentsHidden, segmentationId } = representation;
    const indices = getUniqueSegmentIndices(segmentationId);
    const indicesSet = new Set(indices);
    segmentsHidden.forEach((segmentIndex) => indicesSet.delete(segmentIndex));
    return !!indicesSet.size;
}
function setSegmentsVisibility(toolGroupId, segmentationRepresentationUID, segmentIndices, visibility) {
    const segRepresentation = SegmentationState.getSegmentationRepresentationByUID(toolGroupId, segmentationRepresentationUID);
    if (!segRepresentation) {
        return;
    }
    segmentIndices.forEach((segmentIndex) => {
        visibility
            ? segRepresentation.segmentsHidden.delete(segmentIndex)
            : segRepresentation.segmentsHidden.add(segmentIndex);
    });
    triggerSegmentationRepresentationModified(toolGroupId, segmentationRepresentationUID);
}
function setSegmentVisibility(toolGroupId, segmentationRepresentationUID, segmentIndex, visibility) {
    const segRepresentation = SegmentationState.getSegmentationRepresentationByUID(toolGroupId, segmentationRepresentationUID);
    if (!segRepresentation) {
        return;
    }
    visibility
        ? segRepresentation.segmentsHidden.delete(segmentIndex)
        : segRepresentation.segmentsHidden.add(segmentIndex);
    triggerSegmentationRepresentationModified(toolGroupId, segmentationRepresentationUID);
}
function getSegmentVisibility(toolGroupId, segmentationRepresentationUID, segmentIndex) {
    const segRepresentation = SegmentationState.getSegmentationRepresentationByUID(toolGroupId, segmentationRepresentationUID);
    if (!segRepresentation) {
        return false;
    }
    return !segRepresentation.segmentsHidden.has(segmentIndex);
}
export { setSegmentationVisibility, getSegmentationVisibility, setSegmentVisibility, setSegmentsVisibility, getSegmentVisibility, };
//# sourceMappingURL=segmentationVisibility.js.map