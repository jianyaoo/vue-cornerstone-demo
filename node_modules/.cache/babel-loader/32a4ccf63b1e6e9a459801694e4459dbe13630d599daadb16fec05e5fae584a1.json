{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { m as macro } from '../../macros2.js';\nimport Constants from './BufferManager/Constants.js';\nimport vtkProperty from '../Core/Property.js';\nimport vtkWebGPUBuffer from './Buffer.js';\nconst {\n  Representation\n} = vtkProperty;\nconst {\n  PrimitiveTypes\n} = Constants;\n\n// Simulate a small map of pointId to flatId for a cell. The original code\n// used a map and was 2.6x slower (4.7 to 1.9 seconds). Using two fixed\n// length arrays with a count is so much faster even with the required for\n// loops and if statements. This only works as we know the usage is\n// restricted to clear(), set() get() and has() so the count is always\n// incrmenting except for clear where it goes back to 0. Performance\n// improvement is probably due to this appoach not hitting the heap but wow\n// it is so much faster. Code that adds to these vectors checks against 9 to\n// make sure there is room. Switching to test against vec.length -1 results\n// in a small performance hit, so if you change 10, search for 9 in this\n// small class and change those as well.\nclass _LimitedMap {\n  constructor() {\n    this.keys = new Uint32Array(10);\n    this.values = new Uint32Array(10);\n    this.count = 0;\n  }\n  clear() {\n    this.count = 0;\n  }\n  has(key) {\n    for (let i = 0; i < this.count; i++) {\n      if (this.keys[i] === key) {\n        return true;\n      }\n    }\n    return undefined;\n  }\n  get(key) {\n    for (let i = 0; i < this.count; i++) {\n      if (this.keys[i] === key) {\n        return this.values[i];\n      }\n    }\n    return undefined;\n  }\n  set(key, value) {\n    if (this.count < 9) {\n      this.keys[this.count] = key;\n      this.values[this.count++] = value;\n    }\n  }\n}\nfunction getPrimitiveName(primType) {\n  switch (primType) {\n    case PrimitiveTypes.Points:\n      return 'points';\n    case PrimitiveTypes.Lines:\n      return 'lines';\n    case PrimitiveTypes.Triangles:\n    case PrimitiveTypes.TriangleEdges:\n      return 'polys';\n    case PrimitiveTypes.TriangleStripEdges:\n    case PrimitiveTypes.TriangleStrips:\n      return 'strips';\n    default:\n      return '';\n  }\n}\nfunction _getOrAddFlatId(state, ptId, cellId) {\n  let flatId = state.pointIdToFlatId[ptId];\n  if (flatId < 0) {\n    flatId = state.flatId;\n    state.pointIdToFlatId[ptId] = flatId;\n    state.flatIdToPointId[state.flatId] = ptId;\n    state.flatIdToCellId[state.flatId] = cellId;\n    state.flatId++;\n  }\n  return flatId;\n}\nfunction fillCell(ptIds, cellId, state) {\n  const numPtIds = ptIds.length;\n  // are any points already marked for this cell? If so use that as the provoking point\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    let ptId = ptIds[ptIdx];\n    if (state.cellProvokedMap.has(ptId)) {\n      state.ibo[state.iboId++] = state.cellProvokedMap.get(ptId);\n\n      // insert remaining ptIds (they do not need to provoke)\n      for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {\n        ptId = ptIds[ptIdx2 % numPtIds];\n        const flatId = _getOrAddFlatId(state, ptId, cellId);\n        // add to ibo\n        state.ibo[state.iboId++] = flatId;\n      }\n      // all done now\n      return;\n    }\n  }\n\n  // else have any of the points not been used yet? (not in provokedPointIds)\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    let ptId = ptIds[ptIdx];\n    if (!state.provokedPointIds[ptId]) {\n      let flatId = _getOrAddFlatId(state, ptId, cellId);\n      // mark provoking and add to ibo\n      state.provokedPointIds[ptId] = 1;\n      state.cellProvokedMap.set(ptId, flatId);\n      // when provoking always set the cellId as an original non-provoking value\n      // will have been stored and we need to overwrite that\n      state.flatIdToCellId[flatId] = cellId;\n      state.ibo[state.iboId++] = flatId;\n\n      // insert remaining ptIds (they do not need to provoke)\n      for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {\n        ptId = ptIds[ptIdx2 % numPtIds];\n        flatId = _getOrAddFlatId(state, ptId, cellId);\n        // add to ibo\n        state.ibo[state.iboId++] = flatId;\n      }\n      // all done now\n      return;\n    }\n  }\n\n  // if we got here then none of the ptIds could be used to provoke\n  // so just duplicate the first one\n  let ptId = ptIds[0];\n  let flatId = state.flatId;\n  state.cellProvokedMap.set(ptId, flatId);\n  state.flatIdToPointId[state.flatId] = ptId;\n  state.flatIdToCellId[state.flatId] = cellId;\n  state.flatId++;\n\n  // add to ibo\n  state.ibo[state.iboId++] = flatId;\n\n  // insert remaining ptIds (they do not need to provoke)\n  for (let ptIdx2 = 1; ptIdx2 < numPtIds; ptIdx2++) {\n    ptId = ptIds[ptIdx2];\n    flatId = _getOrAddFlatId(state, ptId, cellId);\n    // add to ibo\n    state.ibo[state.iboId++] = flatId;\n  }\n}\nfunction countCell(ptIds, cellId, state) {\n  const numPtIds = ptIds.length;\n  state.iboSize += numPtIds;\n\n  // are any points already marked for this cell? If so use that as the provoking point\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    const ptId = ptIds[ptIdx];\n    if (state.cellProvokedMap.has(ptId)) {\n      return;\n    }\n  }\n\n  // else have any of the points not been used yet? (not in provokedPointIds)\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    const ptId = ptIds[ptIdx];\n    if (!state.provokedPointIds[ptId]) {\n      state.provokedPointIds[ptId] = 1;\n      state.cellProvokedMap.set(ptId, 1);\n      return;\n    }\n  }\n  // if we got here then none of the ptIds could be used to provoke\n  state.cellProvokedMap.set(ptIds[0], 1);\n  state.extraPoints++;\n}\nlet processCell;\nconst _single = new Uint32Array(1);\nconst _double = new Uint32Array(2);\nconst _triple = new Uint32Array(3);\nconst _indexCellBuilders = {\n  // easy, every input point becomes an output point\n  anythingToPoints(numPoints, cellPts, offset, cellId, state) {\n    for (let i = 0; i < numPoints; ++i) {\n      _single[0] = cellPts[offset + i];\n      processCell(_single, cellId, state);\n    }\n  },\n  linesToWireframe(numPoints, cellPts, offset, cellId, state) {\n    // for lines we add a bunch of segments\n    for (let i = 0; i < numPoints - 1; ++i) {\n      _double[0] = cellPts[offset + i];\n      _double[1] = cellPts[offset + i + 1];\n      processCell(_double, cellId, state);\n    }\n  },\n  polysToWireframe(numPoints, cellPts, offset, cellId, state) {\n    // for polys we add a bunch of segments and close it\n    if (numPoints > 2) {\n      for (let i = 0; i < numPoints; ++i) {\n        _double[0] = cellPts[offset + i];\n        _double[1] = cellPts[offset + (i + 1) % numPoints];\n        processCell(_double, cellId, state);\n      }\n    }\n  },\n  stripsToWireframe(numPoints, cellPts, offset, cellId, state) {\n    if (numPoints > 2) {\n      // for strips we add a bunch of segments and close it\n      for (let i = 0; i < numPoints - 1; ++i) {\n        _double[0] = cellPts[offset + i];\n        _double[1] = cellPts[offset + i + 1];\n        processCell(_double, cellId, state);\n      }\n      for (let i = 0; i < numPoints - 2; i++) {\n        _double[0] = cellPts[offset + i];\n        _double[1] = cellPts[offset + i + 2];\n        processCell(_double, cellId, state);\n      }\n    }\n  },\n  polysToSurface(npts, cellPts, offset, cellId, state) {\n    for (let i = 0; i < npts - 2; i++) {\n      _triple[0] = cellPts[offset];\n      _triple[1] = cellPts[offset + i + 1];\n      _triple[2] = cellPts[offset + i + 2];\n      processCell(_triple, cellId, state);\n    }\n  },\n  stripsToSurface(npts, cellPts, offset, cellId, state) {\n    for (let i = 0; i < npts - 2; i++) {\n      _triple[0] = cellPts[offset + i];\n      _triple[1] = cellPts[offset + i + 1 + i % 2];\n      _triple[2] = cellPts[offset + i + 1 + (i + 1) % 2];\n      processCell(_triple, cellId, state);\n    }\n  }\n};\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUIndexBufferManager methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUIndexBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUIndexBuffer');\n  publicAPI.buildIndexBuffer = req => {\n    const cellArray = req.cells;\n    const primitiveType = req.primitiveType;\n    const representation = req.representation;\n    const cellOffset = req.cellOffset;\n    const array = cellArray.getData();\n    const cellArraySize = array.length;\n    const inRepName = getPrimitiveName(primitiveType);\n    const numPts = req.numberOfPoints;\n    const state = {\n      provokedPointIds: new Uint8Array(numPts),\n      // size is good\n      extraPoints: 0,\n      iboSize: 0,\n      flatId: 0,\n      iboId: 0,\n      cellProvokedMap: new _LimitedMap()\n    };\n    let func = null;\n    if (representation === Representation.POINTS || primitiveType === PrimitiveTypes.Points) {\n      func = _indexCellBuilders.anythingToPoints;\n    } else if (representation === Representation.WIREFRAME || primitiveType === PrimitiveTypes.Lines) {\n      func = _indexCellBuilders[`${inRepName}ToWireframe`];\n    } else {\n      func = _indexCellBuilders[`${inRepName}ToSurface`];\n    }\n\n    // first we count how many extra provoking points we need\n    processCell = countCell;\n    let cellId = cellOffset || 0;\n    for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize;) {\n      state.cellProvokedMap.clear();\n      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);\n      cellArrayIndex += array[cellArrayIndex] + 1;\n      cellId++;\n    }\n\n    // then we allocate the remaining structures\n    // (we pick the best size to save space and transfer costs)\n    if (numPts <= 0xffff) {\n      state.flatIdToPointId = new Uint16Array(numPts + state.extraPoints);\n    } else {\n      state.flatIdToPointId = new Uint32Array(numPts + state.extraPoints);\n    }\n    if (numPts + state.extraPoints < 0x8fff) {\n      state.pointIdToFlatId = new Int16Array(numPts);\n    } else {\n      state.pointIdToFlatId = new Int32Array(numPts);\n    }\n    if (numPts + state.extraPoints <= 0xffff) {\n      state.ibo = new Uint16Array(state.iboSize);\n      req.format = 'uint16';\n    } else {\n      state.ibo = new Uint32Array(state.iboSize);\n      req.format = 'uint32';\n    }\n    if (cellId <= 0xffff) {\n      state.flatIdToCellId = new Uint16Array(numPts + state.extraPoints);\n    } else {\n      state.flatIdToCellId = new Uint32Array(numPts + state.extraPoints);\n    }\n    state.pointIdToFlatId.fill(-1);\n    state.provokedPointIds.fill(0);\n\n    // and fill them in\n    processCell = fillCell;\n    cellId = cellOffset || 0;\n    for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize;) {\n      state.cellProvokedMap.clear();\n      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);\n      cellArrayIndex += array[cellArrayIndex] + 1;\n      cellId++;\n    }\n    delete state.provokedPointIds;\n    delete state.pointIdToFlatId;\n\n    // store the results we need\n    req.nativeArray = state.ibo;\n    model.flatIdToPointId = state.flatIdToPointId;\n    model.flatIdToCellId = state.flatIdToCellId;\n    model.flatSize = state.flatId;\n    model.indexCount = state.iboId;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  flatIdToPointId: null,\n  flatIdToCellId: null,\n  flatSize: 0,\n  indexCount: 0\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkWebGPUBuffer.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['flatIdToPointId', 'flatIdToCellId', 'flatSize', 'indexCount']);\n  vtkWebGPUIndexBuffer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUIndexBuffer$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\nexport { vtkWebGPUIndexBuffer$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","Constants","vtkProperty","vtkWebGPUBuffer","Representation","PrimitiveTypes","_LimitedMap","constructor","keys","Uint32Array","values","count","clear","has","key","i","undefined","get","set","value","getPrimitiveName","primType","Points","Lines","Triangles","TriangleEdges","TriangleStripEdges","TriangleStrips","_getOrAddFlatId","state","ptId","cellId","flatId","pointIdToFlatId","flatIdToPointId","flatIdToCellId","fillCell","ptIds","numPtIds","length","ptIdx","cellProvokedMap","ibo","iboId","ptIdx2","provokedPointIds","countCell","iboSize","extraPoints","processCell","_single","_double","_triple","_indexCellBuilders","anythingToPoints","numPoints","cellPts","offset","linesToWireframe","polysToWireframe","stripsToWireframe","polysToSurface","npts","stripsToSurface","vtkWebGPUIndexBuffer","publicAPI","model","classHierarchy","push","buildIndexBuffer","req","cellArray","cells","primitiveType","representation","cellOffset","array","getData","cellArraySize","inRepName","numPts","numberOfPoints","Uint8Array","func","POINTS","WIREFRAME","cellArrayIndex","Uint16Array","Int16Array","Int32Array","format","fill","nativeArray","flatSize","indexCount","DEFAULT_VALUES","extend","initialValues","arguments","Object","assign","setGet","newInstance","vtkWebGPUIndexBuffer$1","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/WebGPU/IndexBuffer.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport Constants from './BufferManager/Constants.js';\nimport vtkProperty from '../Core/Property.js';\nimport vtkWebGPUBuffer from './Buffer.js';\n\nconst {\n  Representation\n} = vtkProperty;\nconst {\n  PrimitiveTypes\n} = Constants;\n\n// Simulate a small map of pointId to flatId for a cell. The original code\n// used a map and was 2.6x slower (4.7 to 1.9 seconds). Using two fixed\n// length arrays with a count is so much faster even with the required for\n// loops and if statements. This only works as we know the usage is\n// restricted to clear(), set() get() and has() so the count is always\n// incrmenting except for clear where it goes back to 0. Performance\n// improvement is probably due to this appoach not hitting the heap but wow\n// it is so much faster. Code that adds to these vectors checks against 9 to\n// make sure there is room. Switching to test against vec.length -1 results\n// in a small performance hit, so if you change 10, search for 9 in this\n// small class and change those as well.\nclass _LimitedMap {\n  constructor() {\n    this.keys = new Uint32Array(10);\n    this.values = new Uint32Array(10);\n    this.count = 0;\n  }\n  clear() {\n    this.count = 0;\n  }\n  has(key) {\n    for (let i = 0; i < this.count; i++) {\n      if (this.keys[i] === key) {\n        return true;\n      }\n    }\n    return undefined;\n  }\n  get(key) {\n    for (let i = 0; i < this.count; i++) {\n      if (this.keys[i] === key) {\n        return this.values[i];\n      }\n    }\n    return undefined;\n  }\n  set(key, value) {\n    if (this.count < 9) {\n      this.keys[this.count] = key;\n      this.values[this.count++] = value;\n    }\n  }\n}\nfunction getPrimitiveName(primType) {\n  switch (primType) {\n    case PrimitiveTypes.Points:\n      return 'points';\n    case PrimitiveTypes.Lines:\n      return 'lines';\n    case PrimitiveTypes.Triangles:\n    case PrimitiveTypes.TriangleEdges:\n      return 'polys';\n    case PrimitiveTypes.TriangleStripEdges:\n    case PrimitiveTypes.TriangleStrips:\n      return 'strips';\n    default:\n      return '';\n  }\n}\nfunction _getOrAddFlatId(state, ptId, cellId) {\n  let flatId = state.pointIdToFlatId[ptId];\n  if (flatId < 0) {\n    flatId = state.flatId;\n    state.pointIdToFlatId[ptId] = flatId;\n    state.flatIdToPointId[state.flatId] = ptId;\n    state.flatIdToCellId[state.flatId] = cellId;\n    state.flatId++;\n  }\n  return flatId;\n}\nfunction fillCell(ptIds, cellId, state) {\n  const numPtIds = ptIds.length;\n  // are any points already marked for this cell? If so use that as the provoking point\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    let ptId = ptIds[ptIdx];\n    if (state.cellProvokedMap.has(ptId)) {\n      state.ibo[state.iboId++] = state.cellProvokedMap.get(ptId);\n\n      // insert remaining ptIds (they do not need to provoke)\n      for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {\n        ptId = ptIds[ptIdx2 % numPtIds];\n        const flatId = _getOrAddFlatId(state, ptId, cellId);\n        // add to ibo\n        state.ibo[state.iboId++] = flatId;\n      }\n      // all done now\n      return;\n    }\n  }\n\n  // else have any of the points not been used yet? (not in provokedPointIds)\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    let ptId = ptIds[ptIdx];\n    if (!state.provokedPointIds[ptId]) {\n      let flatId = _getOrAddFlatId(state, ptId, cellId);\n      // mark provoking and add to ibo\n      state.provokedPointIds[ptId] = 1;\n      state.cellProvokedMap.set(ptId, flatId);\n      // when provoking always set the cellId as an original non-provoking value\n      // will have been stored and we need to overwrite that\n      state.flatIdToCellId[flatId] = cellId;\n      state.ibo[state.iboId++] = flatId;\n\n      // insert remaining ptIds (they do not need to provoke)\n      for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {\n        ptId = ptIds[ptIdx2 % numPtIds];\n        flatId = _getOrAddFlatId(state, ptId, cellId);\n        // add to ibo\n        state.ibo[state.iboId++] = flatId;\n      }\n      // all done now\n      return;\n    }\n  }\n\n  // if we got here then none of the ptIds could be used to provoke\n  // so just duplicate the first one\n  let ptId = ptIds[0];\n  let flatId = state.flatId;\n  state.cellProvokedMap.set(ptId, flatId);\n  state.flatIdToPointId[state.flatId] = ptId;\n  state.flatIdToCellId[state.flatId] = cellId;\n  state.flatId++;\n\n  // add to ibo\n  state.ibo[state.iboId++] = flatId;\n\n  // insert remaining ptIds (they do not need to provoke)\n  for (let ptIdx2 = 1; ptIdx2 < numPtIds; ptIdx2++) {\n    ptId = ptIds[ptIdx2];\n    flatId = _getOrAddFlatId(state, ptId, cellId);\n    // add to ibo\n    state.ibo[state.iboId++] = flatId;\n  }\n}\nfunction countCell(ptIds, cellId, state) {\n  const numPtIds = ptIds.length;\n  state.iboSize += numPtIds;\n\n  // are any points already marked for this cell? If so use that as the provoking point\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    const ptId = ptIds[ptIdx];\n    if (state.cellProvokedMap.has(ptId)) {\n      return;\n    }\n  }\n\n  // else have any of the points not been used yet? (not in provokedPointIds)\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    const ptId = ptIds[ptIdx];\n    if (!state.provokedPointIds[ptId]) {\n      state.provokedPointIds[ptId] = 1;\n      state.cellProvokedMap.set(ptId, 1);\n      return;\n    }\n  }\n  // if we got here then none of the ptIds could be used to provoke\n  state.cellProvokedMap.set(ptIds[0], 1);\n  state.extraPoints++;\n}\nlet processCell;\nconst _single = new Uint32Array(1);\nconst _double = new Uint32Array(2);\nconst _triple = new Uint32Array(3);\nconst _indexCellBuilders = {\n  // easy, every input point becomes an output point\n  anythingToPoints(numPoints, cellPts, offset, cellId, state) {\n    for (let i = 0; i < numPoints; ++i) {\n      _single[0] = cellPts[offset + i];\n      processCell(_single, cellId, state);\n    }\n  },\n  linesToWireframe(numPoints, cellPts, offset, cellId, state) {\n    // for lines we add a bunch of segments\n    for (let i = 0; i < numPoints - 1; ++i) {\n      _double[0] = cellPts[offset + i];\n      _double[1] = cellPts[offset + i + 1];\n      processCell(_double, cellId, state);\n    }\n  },\n  polysToWireframe(numPoints, cellPts, offset, cellId, state) {\n    // for polys we add a bunch of segments and close it\n    if (numPoints > 2) {\n      for (let i = 0; i < numPoints; ++i) {\n        _double[0] = cellPts[offset + i];\n        _double[1] = cellPts[offset + (i + 1) % numPoints];\n        processCell(_double, cellId, state);\n      }\n    }\n  },\n  stripsToWireframe(numPoints, cellPts, offset, cellId, state) {\n    if (numPoints > 2) {\n      // for strips we add a bunch of segments and close it\n      for (let i = 0; i < numPoints - 1; ++i) {\n        _double[0] = cellPts[offset + i];\n        _double[1] = cellPts[offset + i + 1];\n        processCell(_double, cellId, state);\n      }\n      for (let i = 0; i < numPoints - 2; i++) {\n        _double[0] = cellPts[offset + i];\n        _double[1] = cellPts[offset + i + 2];\n        processCell(_double, cellId, state);\n      }\n    }\n  },\n  polysToSurface(npts, cellPts, offset, cellId, state) {\n    for (let i = 0; i < npts - 2; i++) {\n      _triple[0] = cellPts[offset];\n      _triple[1] = cellPts[offset + i + 1];\n      _triple[2] = cellPts[offset + i + 2];\n      processCell(_triple, cellId, state);\n    }\n  },\n  stripsToSurface(npts, cellPts, offset, cellId, state) {\n    for (let i = 0; i < npts - 2; i++) {\n      _triple[0] = cellPts[offset + i];\n      _triple[1] = cellPts[offset + i + 1 + i % 2];\n      _triple[2] = cellPts[offset + i + 1 + (i + 1) % 2];\n      processCell(_triple, cellId, state);\n    }\n  }\n};\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUIndexBufferManager methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUIndexBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUIndexBuffer');\n  publicAPI.buildIndexBuffer = req => {\n    const cellArray = req.cells;\n    const primitiveType = req.primitiveType;\n    const representation = req.representation;\n    const cellOffset = req.cellOffset;\n    const array = cellArray.getData();\n    const cellArraySize = array.length;\n    const inRepName = getPrimitiveName(primitiveType);\n    const numPts = req.numberOfPoints;\n    const state = {\n      provokedPointIds: new Uint8Array(numPts),\n      // size is good\n      extraPoints: 0,\n      iboSize: 0,\n      flatId: 0,\n      iboId: 0,\n      cellProvokedMap: new _LimitedMap()\n    };\n    let func = null;\n    if (representation === Representation.POINTS || primitiveType === PrimitiveTypes.Points) {\n      func = _indexCellBuilders.anythingToPoints;\n    } else if (representation === Representation.WIREFRAME || primitiveType === PrimitiveTypes.Lines) {\n      func = _indexCellBuilders[`${inRepName}ToWireframe`];\n    } else {\n      func = _indexCellBuilders[`${inRepName}ToSurface`];\n    }\n\n    // first we count how many extra provoking points we need\n    processCell = countCell;\n    let cellId = cellOffset || 0;\n    for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize;) {\n      state.cellProvokedMap.clear();\n      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);\n      cellArrayIndex += array[cellArrayIndex] + 1;\n      cellId++;\n    }\n\n    // then we allocate the remaining structures\n    // (we pick the best size to save space and transfer costs)\n    if (numPts <= 0xffff) {\n      state.flatIdToPointId = new Uint16Array(numPts + state.extraPoints);\n    } else {\n      state.flatIdToPointId = new Uint32Array(numPts + state.extraPoints);\n    }\n    if (numPts + state.extraPoints < 0x8fff) {\n      state.pointIdToFlatId = new Int16Array(numPts);\n    } else {\n      state.pointIdToFlatId = new Int32Array(numPts);\n    }\n    if (numPts + state.extraPoints <= 0xffff) {\n      state.ibo = new Uint16Array(state.iboSize);\n      req.format = 'uint16';\n    } else {\n      state.ibo = new Uint32Array(state.iboSize);\n      req.format = 'uint32';\n    }\n    if (cellId <= 0xffff) {\n      state.flatIdToCellId = new Uint16Array(numPts + state.extraPoints);\n    } else {\n      state.flatIdToCellId = new Uint32Array(numPts + state.extraPoints);\n    }\n    state.pointIdToFlatId.fill(-1);\n    state.provokedPointIds.fill(0);\n\n    // and fill them in\n    processCell = fillCell;\n    cellId = cellOffset || 0;\n    for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize;) {\n      state.cellProvokedMap.clear();\n      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);\n      cellArrayIndex += array[cellArrayIndex] + 1;\n      cellId++;\n    }\n    delete state.provokedPointIds;\n    delete state.pointIdToFlatId;\n\n    // store the results we need\n    req.nativeArray = state.ibo;\n    model.flatIdToPointId = state.flatIdToPointId;\n    model.flatIdToCellId = state.flatIdToCellId;\n    model.flatSize = state.flatId;\n    model.indexCount = state.iboId;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  flatIdToPointId: null,\n  flatIdToCellId: null,\n  flatSize: 0,\n  indexCount: 0\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkWebGPUBuffer.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['flatIdToPointId', 'flatIdToCellId', 'flatSize', 'indexCount']);\n  vtkWebGPUIndexBuffer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUIndexBuffer$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\nexport { vtkWebGPUIndexBuffer$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}