{"ast":null,"code":"import { m as macro } from '../../macros2.js';\nimport { e as distance2BetweenPoints } from '../Core/Math/index.js';\nconst {\n  vtkErrorMacro\n} = macro;\nconst OCTREENODE_INSERTPOINT = [(points, pointIdx, coords) => pointIdx, (points, pointIdx, coords) => {\n  points.setTuple(pointIdx, coords);\n  return pointIdx;\n}, (points, pointIdx, coords) => points.insertNextTuple(coords)];\n\n// Given the index (0 ~ 7) of a child node, the spatial bounding axis (0 ~ 2\n// for x, y, and z), and the value (0 ~ 1 for min and max) to access, this LUT\n// allows for rapid assignment of its spatial bounding box --- MinBounds[3]\n// and MaxBounds[3], with each specific value or entry of this LUT pointing to\n// MinBounds[3] for 0, center point for 1, or MaxBounds[3] for 2.\nconst OCTREE_CHILD_BOUNDS_LUT = [[[0, 1], [0, 1], [0, 1]], [[1, 2], [0, 1], [0, 1]], [[0, 1], [1, 2], [0, 1]], [[1, 2], [1, 2], [0, 1]], [[0, 1], [0, 1], [1, 2]], [[1, 2], [0, 1], [1, 2]], [[0, 1], [1, 2], [1, 2]], [[1, 2], [1, 2], [1, 2]]];\nfunction vtkIncrementalOctreeNode(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkIncrementalOctreeNode');\n\n  //------------------------------------------------------------------------------\n  publicAPI.createPointIdSet = (initSize, growSize) => {\n    if (model.pointIdSet == null) {\n      model.pointIdSet = [];\n      // TODO: use initSize and growSize.\n      // model.pointIdSet.allocate(initSize, growSize);\n    }\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.setBounds = (x1, x2, y1, y2, z1, z2) => {\n    if (model.minBounds == null) model.minBounds = [];\n    if (model.maxBounds == null) model.maxBounds = [];\n    if (model.minDataBounds == null) model.minDataBounds = [];\n    if (model.maxDataBounds == null) model.maxDataBounds = [];\n    model.minBounds[0] = x1;\n    model.maxBounds[0] = x2;\n    model.minBounds[1] = y1;\n    model.maxBounds[1] = y2;\n    model.minBounds[2] = z1;\n    model.maxBounds[2] = z2;\n    model.minDataBounds[0] = x2;\n    model.maxDataBounds[0] = x1;\n    model.minDataBounds[1] = y2;\n    model.maxDataBounds[1] = y1;\n    model.minDataBounds[2] = z2;\n    model.maxDataBounds[2] = z1;\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.getBounds = bounds => {\n    bounds[0] = model.minBounds[0];\n    bounds[1] = model.maxBounds[0];\n    bounds[2] = model.minBounds[1];\n    bounds[3] = model.maxBounds[1];\n    bounds[4] = model.minBounds[2];\n    bounds[5] = model.maxBounds[2];\n  };\n  publicAPI.getChildIndex = point => Number(point[0] > model.children[0].getMaxBoundsByReference()[0]) + (\n  // eslint-disable-next-line no-bitwise\n  Number(point[1] > model.children[0].getMaxBoundsByReference()[1]) << 1) + (\n  // eslint-disable-next-line no-bitwise\n  Number(point[2] > model.children[0].getMaxBoundsByReference()[2]) << 2);\n  publicAPI.containsPoint = pnt => model.minBounds[0] < pnt[0] && pnt[0] <= model.maxBounds[0] && model.minBounds[1] < pnt[1] && pnt[1] <= model.maxBounds[1] && model.minBounds[2] < pnt[2] && pnt[2] <= model.maxBounds[2] ? 1 : 0;\n  publicAPI.containsPointByData = pnt => model.minDataBounds[0] <= pnt[0] && pnt[0] <= model.maxDataBounds[0] && model.minDataBounds[1] <= pnt[1] && pnt[1] <= model.maxDataBounds[1] && model.minDataBounds[2] <= pnt[2] && pnt[2] <= model.maxDataBounds[2] ? 1 : 0;\n\n  //------------------------------------------------------------------------------\n  publicAPI.updateCounterAndDataBounds = (point, nHits, updateData) => {\n    model.numberOfPoints += nHits;\n    if (!updateData) return false;\n    let updated = false;\n    if (point[0] < model.minDataBounds[0]) {\n      updated = true;\n      model.minDataBounds[0] = point[0];\n    }\n    if (point[0] > model.maxDataBounds[0]) {\n      updated = true;\n      model.maxDataBounds[0] = point[0];\n    }\n    if (point[1] < model.minDataBounds[1]) {\n      updated = true;\n      model.minDataBounds[1] = point[1];\n    }\n    if (point[1] > model.maxDataBounds[1]) {\n      updated = true;\n      model.maxDataBounds[1] = point[1];\n    }\n    if (point[2] < model.minDataBounds[2]) {\n      updated = true;\n      model.minDataBounds[2] = point[2];\n    }\n    if (point[2] > model.maxDataBounds[2]) {\n      updated = true;\n      model.maxDataBounds[2] = point[2];\n    }\n    return updated;\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.updateCounterAndDataBoundsRecursively = (point, nHits, updateData, endNode) => {\n    const updated = publicAPI.updateCounterAndDataBounds(point, nHits, updateData);\n    return model.parent === endNode ? updated : model.parent.updateCounterAndDataBoundsRecursively(point, nHits, updated, endNode);\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.containsDuplicatePointsOnly = point => model.minDataBounds[0] === point[0] && point[0] === model.maxDataBounds[0] && model.minDataBounds[1] === point[1] && point[1] === model.maxDataBounds[1] && model.minDataBounds[2] === point[2] && point[2] === model.maxDataBounds[2];\n\n  //------------------------------------------------------------------------------\n  publicAPI.isLeaf = () => model.children == null;\n\n  //------------------------------------------------------------------------------\n  publicAPI.getChild = i => model.children[i];\n\n  //------------------------------------------------------------------------------\n  /* eslint-disable no-use-before-define */\n  publicAPI.separateExactlyDuplicatePointsFromNewInsertion = (points, pntIds, newPnt, pntIdx, maxPts, ptMode) => {\n    // the number of points already maintained in this leaf node\n    // >= maxPts AND all of them are exactly duplicate with one another\n    //           BUT the new point is not a duplicate of them any more\n    let pointIdx = pntIdx;\n    let i;\n    const dupPnt = [0.0, 0.0, 0.0];\n    const octMin = [0.0, 0.0, 0.0];\n    const octMid = [0.0, 0.0, 0.0];\n    const octMax = [0.0, 0.0, 0.0];\n    const boxPtr = [null, null, null];\n    let ocNode = null;\n    let duplic = publicAPI;\n    let single = publicAPI;\n\n    // the coordinate of the duplicate points: note pntIds == model.pointIdSet\n    points.getPoint(pntIds[0], dupPnt);\n    while (duplic === single) {\n      // as long as separation has not been achieved\n      // update the current (in recursion) node and access the bounding box info\n      ocNode = duplic;\n      octMid[0] = (ocNode.minBounds[0] + ocNode.maxBounds[0]) * 0.5;\n      octMid[1] = (ocNode.minBounds[1] + ocNode.maxBounds[1]) * 0.5;\n      octMid[2] = (ocNode.minBounds[2] + ocNode.maxBounds[2]) * 0.5;\n      boxPtr[0] = ocNode.minBounds;\n      boxPtr[1] = octMid;\n      boxPtr[2] = ocNode.maxBounds;\n\n      // create eight child nodes\n      // FIXME: May be too slow to use vtk newInstance()\n      ocNode.children = [newInstance(), newInstance(), newInstance(), newInstance(), newInstance(), newInstance(), newInstance(), newInstance()];\n      for (i = 0; i < 8; i++) {\n        // x-bound: axis 0\n        octMin[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][0]][0];\n        octMax[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][1]][0];\n\n        // y-bound: axis 1\n        octMin[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][0]][1];\n        octMax[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][1]][1];\n\n        // z-bound: axis 2\n        octMin[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][0]][2];\n        octMax[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][1]][2];\n        ocNode.children[i] = newInstance();\n        ocNode.children[i].setParent(ocNode);\n        ocNode.children[i].setBounds(octMin[0], octMax[0], octMin[1], octMax[1], octMin[2], octMax[2]);\n      }\n\n      // determine the leaf node of the duplicate points & that of the new point\n      duplic = ocNode.children[ocNode.getChildIndex(dupPnt)];\n      single = ocNode.children[ocNode.getChildIndex(newPnt)];\n    }\n    // Now the duplicate points have been separated from the new point //\n\n    // create a vtkIdList object for the new point\n    // update the counter and the data bounding box until the root node\n    // (including the root node)\n    pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt);\n    // eslint-disable-next-line no-bitwise\n    single.createPointIdSet(maxPts >> 2, maxPts >> 1);\n    single.getPointIdSet().push(pointIdx);\n    single.updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null);\n\n    // We just need to reference pntIds while un-registering it from 'this'.\n    // This avoids deep-copying point ids from pntIds to duplic's PointIdSet.\n    // update the counter and the data bounding box, but until 'this' node\n    // (excluding 'this' node)\n    duplic.setPointIdSet(pntIds);\n    duplic.updateCounterAndDataBoundsRecursively(dupPnt, pntIds.length, 1, publicAPI);\n    return pointIdx;\n  };\n  /* eslint-enable no-use-before-define */\n\n  //------------------------------------------------------------------------------\n  publicAPI.createChildNodes = (points, pntIds, newPnt, pntIdx, maxPts, ptMode, numberOfNodes) => {\n    // There are two scenarios for which this function is invoked.\n    //\n    // (1) the number of points already maintained in this leaf node\n    //     == maxPts AND not all of them are exactly duplicate\n    //               AND the new point is not a duplicate of them all\n    // (2) the number of points already maintained in this leaf node\n    //     >= maxPts AND all of them are exactly duplicate with one another\n    //               BUT the new point is not a duplicate of them any more\n\n    // address case (2) first if necessary\n    let nbNodes = numberOfNodes;\n    let pointIdx = pntIdx;\n    const sample = [];\n    points.getPoint(pntIds[0], sample);\n    if (publicAPI.containsDuplicatePointsOnly(sample)) {\n      pointIdx = publicAPI.separateExactlyDuplicatePointsFromNewInsertion(points, pntIds, newPnt, pointIdx, maxPts, ptMode);\n      return {\n        success: false,\n        nbNodes,\n        pointIdx\n      };\n    }\n\n    // then address case (1) below\n    let i;\n    let target;\n    let dvidId = -1; // index of the sub-dividing octant, if any\n    let fullId = -1; // index of the full octant, if any\n    const numIds = [0, 0, 0, 0, 0, 0, 0, 0];\n    const octMin = [];\n    const octMax = [];\n    const tempPt = [];\n    let tempId;\n    const octMid = [(model.minBounds[0] + model.maxBounds[0]) * 0.5, (model.minBounds[1] + model.maxBounds[1]) * 0.5, (model.minBounds[2] + model.maxBounds[2]) * 0.5];\n    const boxPtr = [model.minBounds, octMid, model.maxBounds];\n\n    // create eight child nodes\n    model.children = [];\n    for (i = 0; i < 8; i++) {\n      // x-bound: axis 0\n      octMin[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][0]][0];\n      octMax[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][1]][0];\n\n      // y-bound: axis 1\n      octMin[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][0]][1];\n      octMax[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][1]][1];\n\n      // z-bound: axis 2\n      octMin[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][0]][2];\n      octMax[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][1]][2];\n\n      // This call internally sets the cener and default data bounding box, too.\n      // eslint-disable-next-line no-use-before-define\n      model.children[i] = newInstance();\n      // model.children[i].iD = nbNodes++;\n      model.children[i].setParent(publicAPI);\n      model.children[i].setBounds(octMin[0], octMax[0], octMin[1], octMax[1], octMin[2], octMax[2]);\n\n      // allocate a list of point-indices (size = 2^n) for index registration\n      // eslint-disable-next-line no-bitwise\n      model.children[i].createPointIdSet(maxPts >> 2, maxPts >> 1);\n    }\n    boxPtr[0] = null;\n    boxPtr[1] = null;\n    boxPtr[2] = null;\n\n    // distribute the available point-indices to the eight child nodes\n    for (i = 0; i < maxPts; i++) {\n      tempId = pntIds[i];\n      points.getPoint(tempId, tempPt);\n      target = publicAPI.getChildIndex(tempPt);\n      model.children[target].getPointIdSet().push(tempId);\n      model.children[target].updateCounterAndDataBounds(tempPt);\n      numIds[target]++;\n    }\n\n    // locate the full child, just if any\n    for (i = 0; i < 8; i++) {\n      if (numIds[i] === maxPts) {\n        fullId = i;\n        break;\n      }\n    }\n    target = publicAPI.getChildIndex(newPnt);\n    if (fullId === target) {\n      // The fact is that we are going to insert the new point to an already\n      // full octant (child node). Thus we need to further divide this child\n      // to avoid the overflow problem.\n      ({\n        numberOfNodes: nbNodes,\n        pointIdx\n      } = model.children[target].createChildNodes(points, pntIds, newPnt, pointIdx, maxPts, ptMode, nbNodes));\n      dvidId = fullId;\n    } else {\n      // the initial division is a success\n      pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt);\n      model.children[target].getPointIdSet().push(pointIdx);\n      model.children[target].updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null);\n\n      // NOTE: The counter below might reach the threshold, though we delay the\n      // sub-division of this child node until the next point insertion occurs.\n      numIds[target]++;\n    }\n\n    // Now it is time to reclaim those un-used vtkIdList objects, of which each\n    // either is empty or still needs to be deleted due to further division of\n    // the child node. This post-deallocation of the un-used vtkIdList objects\n    // (of some child nodes) is based on the assumption that retrieving the\n    // 'maxPts' points from vtkPoints and the associated 'maxPts' point-indices\n    // from vtkIdList is more expensive than reclaiming at most 8 vtkIdList\n    // objects at hand.\n    for (i = 0; i < 8; i++) {\n      if (numIds[i] === 0 || i === dvidId) {\n        model.children[i].getPointIdSet().length = 0;\n      }\n    }\n\n    // notify vtkIncrementalOctreeNode::InsertPoint() to destroy pntIds\n    return {\n      success: true,\n      numberOfNodes: nbNodes,\n      pointIdx\n    };\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.insertPoint = (points, newPnt, maxPts, pntId, ptMode, numberOfNodes) => {\n    let nbNodes = 0;\n    let pointIdx = pntId;\n    if (model.pointIdSet) {\n      // there has been at least one point index\n      if (model.pointIdSet.length < maxPts || publicAPI.containsDuplicatePointsOnly(newPnt)) {\n        // this leaf node is not full or\n        // this leaf node is full, but of all exactly duplicate points\n        // and the point under check is another duplicate of these points\n        pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt);\n        model.pointIdSet.push(pointIdx);\n        publicAPI.updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null);\n      } else {\n        // overflow: divide this node and delete the list of point-indices.\n        // Note that the number of exactly duplicate points might be greater\n        // than or equal to maxPts.\n        ({\n          numberOfNodes: nbNodes,\n          pointIdx\n        } = publicAPI.createChildNodes(points, model.pointIdSet, newPnt, pointIdx, maxPts, ptMode, numberOfNodes));\n        model.pointIdSet = null;\n      }\n    } else {\n      // There has been no any point index registered in this leaf node\n      pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt);\n      model.pointIdSet = [];\n      model.pointIdSet.push(pointIdx);\n      publicAPI.updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null);\n    }\n    return {\n      numberOfNodes: numberOfNodes + nbNodes,\n      pointIdx\n    };\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.getDistance2ToBoundary = (point, closest, innerOnly, rootNode, checkData) => {\n    // It is mandatory that GetMinDataBounds() and GetMaxDataBounds() be used.\n    // Direct access to MinDataBounds and MaxDataBounds might incur problems.\n    let thisMin = null;\n    let thisMax = null;\n    let rootMin = null;\n    let rootMax = null;\n    // TODO: Check\n    // let minDist = VTK_DOUBLE_MAX;\n    let minDist = Number.MAX_VALUE; // minimum distance to the boundaries\n    if (checkData) {\n      thisMin = publicAPI.getMinDataBounds();\n      thisMax = publicAPI.getMaxDataBounds();\n      rootMin = rootNode.getMinDataBounds();\n      rootMax = rootNode.getMaxDataBounds();\n    } else {\n      thisMin = model.minBounds;\n      thisMax = model.maxBounds;\n      rootMin = rootNode.getMinBounds();\n      rootMax = rootNode.getMaxBounds();\n    }\n    let minFace = 0; // index of the face with min distance to the point\n    const beXless = Number(point[0] < thisMin[0]);\n    const beXmore = Number(point[0] > thisMax[0]);\n    const beYless = Number(point[1] < thisMin[1]);\n    const beYmore = Number(point[1] > thisMax[1]);\n    const beZless = Number(point[2] < thisMin[2]);\n    const beZmore = Number(point[2] > thisMax[2]);\n    const withinX = Number(!beXless && !beXmore);\n    const withinY = Number(!beYless && !beYmore);\n    const withinZ = Number(!beZless && !beZmore);\n    // eslint-disable-next-line no-bitwise\n    const xyzFlag = (withinZ << 2) + (withinY << 1) + withinX;\n    switch (xyzFlag) {\n      case 0:\n        {\n          // withinZ = 0; withinY = 0;  withinX = 0\n          // closest to a corner\n\n          closest[0] = beXless ? thisMin[0] : thisMax[0];\n          closest[1] = beYless ? thisMin[1] : thisMax[1];\n          closest[2] = beZless ? thisMin[2] : thisMax[2];\n          minDist = distance2BetweenPoints(point, closest);\n          break;\n        }\n      case 1:\n        {\n          // withinZ = 0; withinY = 0; withinX = 1\n          // closest to an x-aligned edge\n\n          closest[0] = point[0];\n          closest[1] = beYless ? thisMin[1] : thisMax[1];\n          closest[2] = beZless ? thisMin[2] : thisMax[2];\n          minDist = distance2BetweenPoints(point, closest);\n          break;\n        }\n      case 2:\n        {\n          // withinZ = 0; withinY = 1; withinX = 0\n          // closest to a y-aligned edge\n\n          closest[0] = beXless ? thisMin[0] : thisMax[0];\n          closest[1] = point[1];\n          closest[2] = beZless ? thisMin[2] : thisMax[2];\n          minDist = distance2BetweenPoints(point, closest);\n          break;\n        }\n      case 3:\n        {\n          // withinZ = 0; withinY = 1; withinX = 1\n          // closest to a z-face\n\n          if (beZless) {\n            minDist = thisMin[2] - point[2];\n            closest[2] = thisMin[2];\n          } else {\n            minDist = point[2] - thisMax[2];\n            closest[2] = thisMax[2];\n          }\n          minDist *= minDist;\n          closest[0] = point[0];\n          closest[1] = point[1];\n          break;\n        }\n      case 4:\n        {\n          // withinZ = 1; withinY = 0; withinX = 0\n          // cloest to a z-aligned edge\n\n          closest[0] = beXless ? thisMin[0] : thisMax[0];\n          closest[1] = beYless ? thisMin[1] : thisMax[1];\n          closest[2] = point[2];\n          minDist = distance2BetweenPoints(point, closest);\n          break;\n        }\n      case 5:\n        {\n          // withinZ = 1; withinY = 0; withinX = 1\n          // closest to a y-face\n\n          if (beYless) {\n            minDist = thisMin[1] - point[1];\n            closest[1] = thisMin[1];\n          } else {\n            minDist = point[1] - thisMax[1];\n            closest[1] = thisMax[1];\n          }\n          minDist *= minDist;\n          closest[0] = point[0];\n          closest[2] = point[2];\n          break;\n        }\n      case 6:\n        {\n          // withinZ = 1; withinY = 1; withinX = 0\n          // closest to an x-face\n\n          if (beXless) {\n            minDist = thisMin[0] - point[0];\n            closest[0] = thisMin[0];\n          } else {\n            minDist = point[0] - thisMax[0];\n            closest[0] = thisMax[0];\n          }\n          minDist *= minDist;\n          closest[1] = point[1];\n          closest[2] = point[2];\n          break;\n        }\n      case 7:\n        {\n          // withinZ = 1; withinY = 1;  withinZ = 1\n          // point is inside the box\n\n          if (innerOnly) {\n            // check only inner boundaries\n            let faceDst;\n            faceDst = point[0] - thisMin[0]; // x-min face\n            if (thisMin[0] !== rootMin[0] && faceDst < minDist) {\n              minFace = 0;\n              minDist = faceDst;\n            }\n            faceDst = thisMax[0] - point[0]; // x-max face\n            if (thisMax[0] !== rootMax[0] && faceDst < minDist) {\n              minFace = 1;\n              minDist = faceDst;\n            }\n            faceDst = point[1] - thisMin[1]; // y-min face\n            if (thisMin[1] !== rootMin[1] && faceDst < minDist) {\n              minFace = 2;\n              minDist = faceDst;\n            }\n            faceDst = thisMax[1] - point[1]; // y-max face\n            if (thisMax[1] !== rootMax[1] && faceDst < minDist) {\n              minFace = 3;\n              minDist = faceDst;\n            }\n            faceDst = point[2] - thisMin[2]; // z-min face\n            if (thisMin[2] !== rootMin[2] && faceDst < minDist) {\n              minFace = 4;\n              minDist = faceDst;\n            }\n            faceDst = thisMax[2] - point[2]; // z-max face\n            if (thisMax[2] !== rootMax[2] && faceDst < minDist) {\n              minFace = 5;\n              minDist = faceDst;\n            }\n          } else {\n            // check all boundaries\n            const tmpDist = [point[0] - thisMin[0], thisMax[0] - point[0], point[1] - thisMin[1], thisMax[1] - point[1], point[2] - thisMin[2], thisMax[2] - point[2]];\n            for (let i = 0; i < 6; i++) {\n              if (tmpDist[i] < minDist) {\n                minFace = i;\n                minDist = tmpDist[i];\n              }\n            }\n          }\n\n          // no square operation if no any inner boundary\n          if (minDist !== Number.MAX_VALUE) {\n            minDist *= minDist;\n          }\n          closest[0] = point[0];\n          closest[1] = point[1];\n          closest[2] = point[2];\n\n          // minFace: the quad with the min distance to the point\n          // 0: x-min face  ===>  xyzIndx = 0:  x  and  minFace & 1 = 0:  thisMin\n          // 1: x-max face  ===>  xyzIndx = 0:  x  and  minFace & 1 = 1:  thisMax\n          // 2: y-min face  ===>  xyzIndx = 1:  y  and  minFace & 1 = 0:  thisMin\n          // 3: y-max face  ===>  xyzIndx = 1:  y  and  minFace & 1 = 1:  thisMax\n          // 4: z-min face  ===>  xyzIndx = 2:  z  and  minFace & 1 = 0:  thisMin\n          // 5: z-max face  ===>  xyzIndx = 2:  z  and  minFace & 1 = 1:  thisMax\n          const pMinMax = [thisMin, thisMax];\n          // eslint-disable-next-line no-bitwise\n          const xyzIndx = minFace >> 1;\n          // eslint-disable-next-line no-bitwise\n          closest[xyzIndx] = pMinMax[minFace & 1][xyzIndx];\n          break;\n        }\n      default:\n        vtkErrorMacro('unexpected case in getDistance2ToBoundary');\n    }\n    return minDist;\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.getDistance2ToInnerBoundary = (point, rootNode) => {\n    const dummy = [];\n    return publicAPI.getDistance2ToBoundary(point, dummy, 0, rootNode, 0);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  pointIdSet: null,\n  minBounds: null,\n  maxBounds: null,\n  minDataBounds: null,\n  maxDataBounds: null,\n  parent: null,\n  children: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n  macro.setGetArray(publicAPI, model, ['minBounds', 'maxBounds', 'minDataBounds', 'maxDataBounds'], 6);\n  macro.get(publicAPI, model, ['pointIdSet', 'numberOfPoints']);\n\n  // TODO: No get?\n  macro.set(publicAPI, model, ['parent']);\n\n  // Object specific methods\n  vtkIncrementalOctreeNode(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkIncrementalOctreeNode');\n\n// ----------------------------------------------------------------------------\n\nvar vtkIncrementalOctreeNode$1 = {\n  newInstance,\n  extend\n};\nexport { vtkIncrementalOctreeNode$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","e","distance2BetweenPoints","vtkErrorMacro","OCTREENODE_INSERTPOINT","points","pointIdx","coords","setTuple","insertNextTuple","OCTREE_CHILD_BOUNDS_LUT","vtkIncrementalOctreeNode","publicAPI","model","classHierarchy","push","createPointIdSet","initSize","growSize","pointIdSet","setBounds","x1","x2","y1","y2","z1","z2","minBounds","maxBounds","minDataBounds","maxDataBounds","getBounds","bounds","getChildIndex","point","Number","children","getMaxBoundsByReference","containsPoint","pnt","containsPointByData","updateCounterAndDataBounds","nHits","updateData","numberOfPoints","updated","updateCounterAndDataBoundsRecursively","endNode","parent","containsDuplicatePointsOnly","isLeaf","getChild","i","separateExactlyDuplicatePointsFromNewInsertion","pntIds","newPnt","pntIdx","maxPts","ptMode","dupPnt","octMin","octMid","octMax","boxPtr","ocNode","duplic","single","getPoint","newInstance","setParent","getPointIdSet","setPointIdSet","length","createChildNodes","numberOfNodes","nbNodes","sample","success","target","dvidId","fullId","numIds","tempPt","tempId","insertPoint","pntId","getDistance2ToBoundary","closest","innerOnly","rootNode","checkData","thisMin","thisMax","rootMin","rootMax","minDist","MAX_VALUE","getMinDataBounds","getMaxDataBounds","getMinBounds","getMaxBounds","minFace","beXless","beXmore","beYless","beYmore","beZless","beZmore","withinX","withinY","withinZ","xyzFlag","faceDst","tmpDist","pMinMax","xyzIndx","getDistance2ToInnerBoundary","dummy","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","obj","setGetArray","get","set","vtkIncrementalOctreeNode$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Common/DataModel/IncrementalOctreeNode.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport { e as distance2BetweenPoints } from '../Core/Math/index.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nconst OCTREENODE_INSERTPOINT = [(points, pointIdx, coords) => pointIdx, (points, pointIdx, coords) => {\n  points.setTuple(pointIdx, coords);\n  return pointIdx;\n}, (points, pointIdx, coords) => points.insertNextTuple(coords)];\n\n// Given the index (0 ~ 7) of a child node, the spatial bounding axis (0 ~ 2\n// for x, y, and z), and the value (0 ~ 1 for min and max) to access, this LUT\n// allows for rapid assignment of its spatial bounding box --- MinBounds[3]\n// and MaxBounds[3], with each specific value or entry of this LUT pointing to\n// MinBounds[3] for 0, center point for 1, or MaxBounds[3] for 2.\nconst OCTREE_CHILD_BOUNDS_LUT = [[[0, 1], [0, 1], [0, 1]], [[1, 2], [0, 1], [0, 1]], [[0, 1], [1, 2], [0, 1]], [[1, 2], [1, 2], [0, 1]], [[0, 1], [0, 1], [1, 2]], [[1, 2], [0, 1], [1, 2]], [[0, 1], [1, 2], [1, 2]], [[1, 2], [1, 2], [1, 2]]];\nfunction vtkIncrementalOctreeNode(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkIncrementalOctreeNode');\n\n  //------------------------------------------------------------------------------\n  publicAPI.createPointIdSet = (initSize, growSize) => {\n    if (model.pointIdSet == null) {\n      model.pointIdSet = [];\n      // TODO: use initSize and growSize.\n      // model.pointIdSet.allocate(initSize, growSize);\n    }\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.setBounds = (x1, x2, y1, y2, z1, z2) => {\n    if (model.minBounds == null) model.minBounds = [];\n    if (model.maxBounds == null) model.maxBounds = [];\n    if (model.minDataBounds == null) model.minDataBounds = [];\n    if (model.maxDataBounds == null) model.maxDataBounds = [];\n    model.minBounds[0] = x1;\n    model.maxBounds[0] = x2;\n    model.minBounds[1] = y1;\n    model.maxBounds[1] = y2;\n    model.minBounds[2] = z1;\n    model.maxBounds[2] = z2;\n    model.minDataBounds[0] = x2;\n    model.maxDataBounds[0] = x1;\n    model.minDataBounds[1] = y2;\n    model.maxDataBounds[1] = y1;\n    model.minDataBounds[2] = z2;\n    model.maxDataBounds[2] = z1;\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.getBounds = bounds => {\n    bounds[0] = model.minBounds[0];\n    bounds[1] = model.maxBounds[0];\n    bounds[2] = model.minBounds[1];\n    bounds[3] = model.maxBounds[1];\n    bounds[4] = model.minBounds[2];\n    bounds[5] = model.maxBounds[2];\n  };\n  publicAPI.getChildIndex = point => Number(point[0] > model.children[0].getMaxBoundsByReference()[0]) + (\n  // eslint-disable-next-line no-bitwise\n  Number(point[1] > model.children[0].getMaxBoundsByReference()[1]) << 1) + (\n  // eslint-disable-next-line no-bitwise\n  Number(point[2] > model.children[0].getMaxBoundsByReference()[2]) << 2);\n  publicAPI.containsPoint = pnt => model.minBounds[0] < pnt[0] && pnt[0] <= model.maxBounds[0] && model.minBounds[1] < pnt[1] && pnt[1] <= model.maxBounds[1] && model.minBounds[2] < pnt[2] && pnt[2] <= model.maxBounds[2] ? 1 : 0;\n  publicAPI.containsPointByData = pnt => model.minDataBounds[0] <= pnt[0] && pnt[0] <= model.maxDataBounds[0] && model.minDataBounds[1] <= pnt[1] && pnt[1] <= model.maxDataBounds[1] && model.minDataBounds[2] <= pnt[2] && pnt[2] <= model.maxDataBounds[2] ? 1 : 0;\n\n  //------------------------------------------------------------------------------\n  publicAPI.updateCounterAndDataBounds = (point, nHits, updateData) => {\n    model.numberOfPoints += nHits;\n    if (!updateData) return false;\n    let updated = false;\n    if (point[0] < model.minDataBounds[0]) {\n      updated = true;\n      model.minDataBounds[0] = point[0];\n    }\n    if (point[0] > model.maxDataBounds[0]) {\n      updated = true;\n      model.maxDataBounds[0] = point[0];\n    }\n    if (point[1] < model.minDataBounds[1]) {\n      updated = true;\n      model.minDataBounds[1] = point[1];\n    }\n    if (point[1] > model.maxDataBounds[1]) {\n      updated = true;\n      model.maxDataBounds[1] = point[1];\n    }\n    if (point[2] < model.minDataBounds[2]) {\n      updated = true;\n      model.minDataBounds[2] = point[2];\n    }\n    if (point[2] > model.maxDataBounds[2]) {\n      updated = true;\n      model.maxDataBounds[2] = point[2];\n    }\n    return updated;\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.updateCounterAndDataBoundsRecursively = (point, nHits, updateData, endNode) => {\n    const updated = publicAPI.updateCounterAndDataBounds(point, nHits, updateData);\n    return model.parent === endNode ? updated : model.parent.updateCounterAndDataBoundsRecursively(point, nHits, updated, endNode);\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.containsDuplicatePointsOnly = point => model.minDataBounds[0] === point[0] && point[0] === model.maxDataBounds[0] && model.minDataBounds[1] === point[1] && point[1] === model.maxDataBounds[1] && model.minDataBounds[2] === point[2] && point[2] === model.maxDataBounds[2];\n\n  //------------------------------------------------------------------------------\n  publicAPI.isLeaf = () => model.children == null;\n\n  //------------------------------------------------------------------------------\n  publicAPI.getChild = i => model.children[i];\n\n  //------------------------------------------------------------------------------\n  /* eslint-disable no-use-before-define */\n  publicAPI.separateExactlyDuplicatePointsFromNewInsertion = (points, pntIds, newPnt, pntIdx, maxPts, ptMode) => {\n    // the number of points already maintained in this leaf node\n    // >= maxPts AND all of them are exactly duplicate with one another\n    //           BUT the new point is not a duplicate of them any more\n    let pointIdx = pntIdx;\n    let i;\n    const dupPnt = [0.0, 0.0, 0.0];\n    const octMin = [0.0, 0.0, 0.0];\n    const octMid = [0.0, 0.0, 0.0];\n    const octMax = [0.0, 0.0, 0.0];\n    const boxPtr = [null, null, null];\n    let ocNode = null;\n    let duplic = publicAPI;\n    let single = publicAPI;\n\n    // the coordinate of the duplicate points: note pntIds == model.pointIdSet\n    points.getPoint(pntIds[0], dupPnt);\n    while (duplic === single) {\n      // as long as separation has not been achieved\n      // update the current (in recursion) node and access the bounding box info\n      ocNode = duplic;\n      octMid[0] = (ocNode.minBounds[0] + ocNode.maxBounds[0]) * 0.5;\n      octMid[1] = (ocNode.minBounds[1] + ocNode.maxBounds[1]) * 0.5;\n      octMid[2] = (ocNode.minBounds[2] + ocNode.maxBounds[2]) * 0.5;\n      boxPtr[0] = ocNode.minBounds;\n      boxPtr[1] = octMid;\n      boxPtr[2] = ocNode.maxBounds;\n\n      // create eight child nodes\n      // FIXME: May be too slow to use vtk newInstance()\n      ocNode.children = [newInstance(), newInstance(), newInstance(), newInstance(), newInstance(), newInstance(), newInstance(), newInstance()];\n      for (i = 0; i < 8; i++) {\n        // x-bound: axis 0\n        octMin[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][0]][0];\n        octMax[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][1]][0];\n\n        // y-bound: axis 1\n        octMin[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][0]][1];\n        octMax[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][1]][1];\n\n        // z-bound: axis 2\n        octMin[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][0]][2];\n        octMax[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][1]][2];\n        ocNode.children[i] = newInstance();\n        ocNode.children[i].setParent(ocNode);\n        ocNode.children[i].setBounds(octMin[0], octMax[0], octMin[1], octMax[1], octMin[2], octMax[2]);\n      }\n\n      // determine the leaf node of the duplicate points & that of the new point\n      duplic = ocNode.children[ocNode.getChildIndex(dupPnt)];\n      single = ocNode.children[ocNode.getChildIndex(newPnt)];\n    }\n    // Now the duplicate points have been separated from the new point //\n\n    // create a vtkIdList object for the new point\n    // update the counter and the data bounding box until the root node\n    // (including the root node)\n    pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt);\n    // eslint-disable-next-line no-bitwise\n    single.createPointIdSet(maxPts >> 2, maxPts >> 1);\n    single.getPointIdSet().push(pointIdx);\n    single.updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null);\n\n    // We just need to reference pntIds while un-registering it from 'this'.\n    // This avoids deep-copying point ids from pntIds to duplic's PointIdSet.\n    // update the counter and the data bounding box, but until 'this' node\n    // (excluding 'this' node)\n    duplic.setPointIdSet(pntIds);\n    duplic.updateCounterAndDataBoundsRecursively(dupPnt, pntIds.length, 1, publicAPI);\n    return pointIdx;\n  };\n  /* eslint-enable no-use-before-define */\n\n  //------------------------------------------------------------------------------\n  publicAPI.createChildNodes = (points, pntIds, newPnt, pntIdx, maxPts, ptMode, numberOfNodes) => {\n    // There are two scenarios for which this function is invoked.\n    //\n    // (1) the number of points already maintained in this leaf node\n    //     == maxPts AND not all of them are exactly duplicate\n    //               AND the new point is not a duplicate of them all\n    // (2) the number of points already maintained in this leaf node\n    //     >= maxPts AND all of them are exactly duplicate with one another\n    //               BUT the new point is not a duplicate of them any more\n\n    // address case (2) first if necessary\n    let nbNodes = numberOfNodes;\n    let pointIdx = pntIdx;\n    const sample = [];\n    points.getPoint(pntIds[0], sample);\n    if (publicAPI.containsDuplicatePointsOnly(sample)) {\n      pointIdx = publicAPI.separateExactlyDuplicatePointsFromNewInsertion(points, pntIds, newPnt, pointIdx, maxPts, ptMode);\n      return {\n        success: false,\n        nbNodes,\n        pointIdx\n      };\n    }\n\n    // then address case (1) below\n    let i;\n    let target;\n    let dvidId = -1; // index of the sub-dividing octant, if any\n    let fullId = -1; // index of the full octant, if any\n    const numIds = [0, 0, 0, 0, 0, 0, 0, 0];\n    const octMin = [];\n    const octMax = [];\n    const tempPt = [];\n    let tempId;\n    const octMid = [(model.minBounds[0] + model.maxBounds[0]) * 0.5, (model.minBounds[1] + model.maxBounds[1]) * 0.5, (model.minBounds[2] + model.maxBounds[2]) * 0.5];\n    const boxPtr = [model.minBounds, octMid, model.maxBounds];\n\n    // create eight child nodes\n    model.children = [];\n    for (i = 0; i < 8; i++) {\n      // x-bound: axis 0\n      octMin[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][0]][0];\n      octMax[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][1]][0];\n\n      // y-bound: axis 1\n      octMin[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][0]][1];\n      octMax[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][1]][1];\n\n      // z-bound: axis 2\n      octMin[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][0]][2];\n      octMax[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][1]][2];\n\n      // This call internally sets the cener and default data bounding box, too.\n      // eslint-disable-next-line no-use-before-define\n      model.children[i] = newInstance();\n      // model.children[i].iD = nbNodes++;\n      model.children[i].setParent(publicAPI);\n      model.children[i].setBounds(octMin[0], octMax[0], octMin[1], octMax[1], octMin[2], octMax[2]);\n\n      // allocate a list of point-indices (size = 2^n) for index registration\n      // eslint-disable-next-line no-bitwise\n      model.children[i].createPointIdSet(maxPts >> 2, maxPts >> 1);\n    }\n    boxPtr[0] = null;\n    boxPtr[1] = null;\n    boxPtr[2] = null;\n\n    // distribute the available point-indices to the eight child nodes\n    for (i = 0; i < maxPts; i++) {\n      tempId = pntIds[i];\n      points.getPoint(tempId, tempPt);\n      target = publicAPI.getChildIndex(tempPt);\n      model.children[target].getPointIdSet().push(tempId);\n      model.children[target].updateCounterAndDataBounds(tempPt);\n      numIds[target]++;\n    }\n\n    // locate the full child, just if any\n    for (i = 0; i < 8; i++) {\n      if (numIds[i] === maxPts) {\n        fullId = i;\n        break;\n      }\n    }\n    target = publicAPI.getChildIndex(newPnt);\n    if (fullId === target) {\n      // The fact is that we are going to insert the new point to an already\n      // full octant (child node). Thus we need to further divide this child\n      // to avoid the overflow problem.\n      ({\n        numberOfNodes: nbNodes,\n        pointIdx\n      } = model.children[target].createChildNodes(points, pntIds, newPnt, pointIdx, maxPts, ptMode, nbNodes));\n      dvidId = fullId;\n    } else {\n      // the initial division is a success\n      pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt);\n      model.children[target].getPointIdSet().push(pointIdx);\n      model.children[target].updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null);\n\n      // NOTE: The counter below might reach the threshold, though we delay the\n      // sub-division of this child node until the next point insertion occurs.\n      numIds[target]++;\n    }\n\n    // Now it is time to reclaim those un-used vtkIdList objects, of which each\n    // either is empty or still needs to be deleted due to further division of\n    // the child node. This post-deallocation of the un-used vtkIdList objects\n    // (of some child nodes) is based on the assumption that retrieving the\n    // 'maxPts' points from vtkPoints and the associated 'maxPts' point-indices\n    // from vtkIdList is more expensive than reclaiming at most 8 vtkIdList\n    // objects at hand.\n    for (i = 0; i < 8; i++) {\n      if (numIds[i] === 0 || i === dvidId) {\n        model.children[i].getPointIdSet().length = 0;\n      }\n    }\n\n    // notify vtkIncrementalOctreeNode::InsertPoint() to destroy pntIds\n    return {\n      success: true,\n      numberOfNodes: nbNodes,\n      pointIdx\n    };\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.insertPoint = (points, newPnt, maxPts, pntId, ptMode, numberOfNodes) => {\n    let nbNodes = 0;\n    let pointIdx = pntId;\n    if (model.pointIdSet) {\n      // there has been at least one point index\n      if (model.pointIdSet.length < maxPts || publicAPI.containsDuplicatePointsOnly(newPnt)) {\n        // this leaf node is not full or\n        // this leaf node is full, but of all exactly duplicate points\n        // and the point under check is another duplicate of these points\n        pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt);\n        model.pointIdSet.push(pointIdx);\n        publicAPI.updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null);\n      } else {\n        // overflow: divide this node and delete the list of point-indices.\n        // Note that the number of exactly duplicate points might be greater\n        // than or equal to maxPts.\n        ({\n          numberOfNodes: nbNodes,\n          pointIdx\n        } = publicAPI.createChildNodes(points, model.pointIdSet, newPnt, pointIdx, maxPts, ptMode, numberOfNodes));\n        model.pointIdSet = null;\n      }\n    } else {\n      // There has been no any point index registered in this leaf node\n      pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt);\n      model.pointIdSet = [];\n      model.pointIdSet.push(pointIdx);\n      publicAPI.updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null);\n    }\n    return {\n      numberOfNodes: numberOfNodes + nbNodes,\n      pointIdx\n    };\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.getDistance2ToBoundary = (point, closest, innerOnly, rootNode, checkData) => {\n    // It is mandatory that GetMinDataBounds() and GetMaxDataBounds() be used.\n    // Direct access to MinDataBounds and MaxDataBounds might incur problems.\n    let thisMin = null;\n    let thisMax = null;\n    let rootMin = null;\n    let rootMax = null;\n    // TODO: Check\n    // let minDist = VTK_DOUBLE_MAX;\n    let minDist = Number.MAX_VALUE; // minimum distance to the boundaries\n    if (checkData) {\n      thisMin = publicAPI.getMinDataBounds();\n      thisMax = publicAPI.getMaxDataBounds();\n      rootMin = rootNode.getMinDataBounds();\n      rootMax = rootNode.getMaxDataBounds();\n    } else {\n      thisMin = model.minBounds;\n      thisMax = model.maxBounds;\n      rootMin = rootNode.getMinBounds();\n      rootMax = rootNode.getMaxBounds();\n    }\n    let minFace = 0; // index of the face with min distance to the point\n    const beXless = Number(point[0] < thisMin[0]);\n    const beXmore = Number(point[0] > thisMax[0]);\n    const beYless = Number(point[1] < thisMin[1]);\n    const beYmore = Number(point[1] > thisMax[1]);\n    const beZless = Number(point[2] < thisMin[2]);\n    const beZmore = Number(point[2] > thisMax[2]);\n    const withinX = Number(!beXless && !beXmore);\n    const withinY = Number(!beYless && !beYmore);\n    const withinZ = Number(!beZless && !beZmore);\n    // eslint-disable-next-line no-bitwise\n    const xyzFlag = (withinZ << 2) + (withinY << 1) + withinX;\n    switch (xyzFlag) {\n      case 0:\n        {\n          // withinZ = 0; withinY = 0;  withinX = 0\n          // closest to a corner\n\n          closest[0] = beXless ? thisMin[0] : thisMax[0];\n          closest[1] = beYless ? thisMin[1] : thisMax[1];\n          closest[2] = beZless ? thisMin[2] : thisMax[2];\n          minDist = distance2BetweenPoints(point, closest);\n          break;\n        }\n      case 1:\n        {\n          // withinZ = 0; withinY = 0; withinX = 1\n          // closest to an x-aligned edge\n\n          closest[0] = point[0];\n          closest[1] = beYless ? thisMin[1] : thisMax[1];\n          closest[2] = beZless ? thisMin[2] : thisMax[2];\n          minDist = distance2BetweenPoints(point, closest);\n          break;\n        }\n      case 2:\n        {\n          // withinZ = 0; withinY = 1; withinX = 0\n          // closest to a y-aligned edge\n\n          closest[0] = beXless ? thisMin[0] : thisMax[0];\n          closest[1] = point[1];\n          closest[2] = beZless ? thisMin[2] : thisMax[2];\n          minDist = distance2BetweenPoints(point, closest);\n          break;\n        }\n      case 3:\n        {\n          // withinZ = 0; withinY = 1; withinX = 1\n          // closest to a z-face\n\n          if (beZless) {\n            minDist = thisMin[2] - point[2];\n            closest[2] = thisMin[2];\n          } else {\n            minDist = point[2] - thisMax[2];\n            closest[2] = thisMax[2];\n          }\n          minDist *= minDist;\n          closest[0] = point[0];\n          closest[1] = point[1];\n          break;\n        }\n      case 4:\n        {\n          // withinZ = 1; withinY = 0; withinX = 0\n          // cloest to a z-aligned edge\n\n          closest[0] = beXless ? thisMin[0] : thisMax[0];\n          closest[1] = beYless ? thisMin[1] : thisMax[1];\n          closest[2] = point[2];\n          minDist = distance2BetweenPoints(point, closest);\n          break;\n        }\n      case 5:\n        {\n          // withinZ = 1; withinY = 0; withinX = 1\n          // closest to a y-face\n\n          if (beYless) {\n            minDist = thisMin[1] - point[1];\n            closest[1] = thisMin[1];\n          } else {\n            minDist = point[1] - thisMax[1];\n            closest[1] = thisMax[1];\n          }\n          minDist *= minDist;\n          closest[0] = point[0];\n          closest[2] = point[2];\n          break;\n        }\n      case 6:\n        {\n          // withinZ = 1; withinY = 1; withinX = 0\n          // closest to an x-face\n\n          if (beXless) {\n            minDist = thisMin[0] - point[0];\n            closest[0] = thisMin[0];\n          } else {\n            minDist = point[0] - thisMax[0];\n            closest[0] = thisMax[0];\n          }\n          minDist *= minDist;\n          closest[1] = point[1];\n          closest[2] = point[2];\n          break;\n        }\n      case 7:\n        {\n          // withinZ = 1; withinY = 1;  withinZ = 1\n          // point is inside the box\n\n          if (innerOnly) {\n            // check only inner boundaries\n            let faceDst;\n            faceDst = point[0] - thisMin[0]; // x-min face\n            if (thisMin[0] !== rootMin[0] && faceDst < minDist) {\n              minFace = 0;\n              minDist = faceDst;\n            }\n            faceDst = thisMax[0] - point[0]; // x-max face\n            if (thisMax[0] !== rootMax[0] && faceDst < minDist) {\n              minFace = 1;\n              minDist = faceDst;\n            }\n            faceDst = point[1] - thisMin[1]; // y-min face\n            if (thisMin[1] !== rootMin[1] && faceDst < minDist) {\n              minFace = 2;\n              minDist = faceDst;\n            }\n            faceDst = thisMax[1] - point[1]; // y-max face\n            if (thisMax[1] !== rootMax[1] && faceDst < minDist) {\n              minFace = 3;\n              minDist = faceDst;\n            }\n            faceDst = point[2] - thisMin[2]; // z-min face\n            if (thisMin[2] !== rootMin[2] && faceDst < minDist) {\n              minFace = 4;\n              minDist = faceDst;\n            }\n            faceDst = thisMax[2] - point[2]; // z-max face\n            if (thisMax[2] !== rootMax[2] && faceDst < minDist) {\n              minFace = 5;\n              minDist = faceDst;\n            }\n          } else {\n            // check all boundaries\n            const tmpDist = [point[0] - thisMin[0], thisMax[0] - point[0], point[1] - thisMin[1], thisMax[1] - point[1], point[2] - thisMin[2], thisMax[2] - point[2]];\n            for (let i = 0; i < 6; i++) {\n              if (tmpDist[i] < minDist) {\n                minFace = i;\n                minDist = tmpDist[i];\n              }\n            }\n          }\n\n          // no square operation if no any inner boundary\n          if (minDist !== Number.MAX_VALUE) {\n            minDist *= minDist;\n          }\n          closest[0] = point[0];\n          closest[1] = point[1];\n          closest[2] = point[2];\n\n          // minFace: the quad with the min distance to the point\n          // 0: x-min face  ===>  xyzIndx = 0:  x  and  minFace & 1 = 0:  thisMin\n          // 1: x-max face  ===>  xyzIndx = 0:  x  and  minFace & 1 = 1:  thisMax\n          // 2: y-min face  ===>  xyzIndx = 1:  y  and  minFace & 1 = 0:  thisMin\n          // 3: y-max face  ===>  xyzIndx = 1:  y  and  minFace & 1 = 1:  thisMax\n          // 4: z-min face  ===>  xyzIndx = 2:  z  and  minFace & 1 = 0:  thisMin\n          // 5: z-max face  ===>  xyzIndx = 2:  z  and  minFace & 1 = 1:  thisMax\n          const pMinMax = [thisMin, thisMax];\n          // eslint-disable-next-line no-bitwise\n          const xyzIndx = minFace >> 1;\n          // eslint-disable-next-line no-bitwise\n          closest[xyzIndx] = pMinMax[minFace & 1][xyzIndx];\n          break;\n        }\n      default:\n        vtkErrorMacro('unexpected case in getDistance2ToBoundary');\n    }\n    return minDist;\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.getDistance2ToInnerBoundary = (point, rootNode) => {\n    const dummy = [];\n    return publicAPI.getDistance2ToBoundary(point, dummy, 0, rootNode, 0);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  pointIdSet: null,\n  minBounds: null,\n  maxBounds: null,\n  minDataBounds: null,\n  maxDataBounds: null,\n  parent: null,\n  children: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n  macro.setGetArray(publicAPI, model, ['minBounds', 'maxBounds', 'minDataBounds', 'maxDataBounds'], 6);\n  macro.get(publicAPI, model, ['pointIdSet', 'numberOfPoints']);\n\n  // TODO: No get?\n  macro.set(publicAPI, model, ['parent']);\n\n  // Object specific methods\n  vtkIncrementalOctreeNode(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkIncrementalOctreeNode');\n\n// ----------------------------------------------------------------------------\n\nvar vtkIncrementalOctreeNode$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkIncrementalOctreeNode$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}