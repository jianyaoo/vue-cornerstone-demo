{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { mat4 } from 'gl-matrix';\nimport { ObjectType } from './BufferObject/Constants.js';\nimport { n as newInstance$1, c as macro } from '../../macros2.js';\nimport vtkBufferObject from './BufferObject.js';\nimport { r as radiansFromDegrees } from '../../Common/Core/Math/index.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkOpenGLPolyDataMapper from './PolyDataMapper.js';\nimport { v as vtkSphereMapperVS } from './glsl/vtkSphereMapperVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLSphereMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLSphereMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLSphereMapper');\n\n  // Capture 'parentClass' api for internal use\n  const superClass = {\n    ...publicAPI\n  };\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkSphereMapperVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 VCPCMatrix;\\n', 'uniform mat4 MCVCMatrix;']).result;\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;\n\n    // we create vertexVC below, so turn off the default\n    // implementation\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Impl', ['vec4 vertexVC = vertexVCVSOutput;\\n']).result;\n\n    // for lights kit and positional the VCPC matrix is already defined\n    // so don't redefine it\n    const replacement = ['uniform float invertedDepth;\\n', 'uniform int cameraParallel;\\n', 'varying float radiusVCVSOutput;\\n', 'varying vec3 centerVCVSOutput;\\n', 'uniform mat4 VCPCMatrix;\\n'];\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', replacement).result;\n    let fragString = '';\n    if (model.context.getExtension('EXT_frag_depth')) {\n      fragString = 'gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n';\n    }\n    if (model._openGLRenderWindow.getWebgl2()) {\n      fragString = 'gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n';\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', [\n    // compute the eye position and unit direction\n    '  vec3 EyePos;\\n', '  vec3 EyeDir;\\n', '  if (cameraParallel != 0) {\\n', '    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n', '    EyeDir = vec3(0.0,0.0,-1.0); }\\n', '  else {\\n', '    EyeDir = vertexVC.xyz;\\n', '    EyePos = vec3(0.0,0.0,0.0);\\n', '    float lengthED = length(EyeDir);\\n', '    EyeDir = normalize(EyeDir);\\n',\n    // we adjust the EyePos to be closer if it is too far away\n    // to prevent floating point precision noise\n    '    if (lengthED > radiusVCVSOutput*3.0) {\\n', '      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n', '    }\\n',\n    // translate to Sphere center\n    '  EyePos = EyePos - centerVCVSOutput;\\n',\n    // scale to radius 1.0\n    '  EyePos = EyePos/radiusVCVSOutput;\\n',\n    // find the intersection\n    '  float b = 2.0*dot(EyePos,EyeDir);\\n', '  float c = dot(EyePos,EyePos) - 1.0;\\n', '  float d = b*b - 4.0*c;\\n', '  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n', '  if (d < 0.0) { discard; }\\n', '  else {\\n', '    float t = (-b - invertedDepth*sqrt(d))*0.5;\\n',\n    // compute the normal, for unit sphere this is just\n    // the intersection point\n    '    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\\n',\n    // compute the intersection point in VC\n    '    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\\n', '    }\\n',\n    // compute the pixel's depth\n    // ' normalVCVSOutput = vec3(0,0,1);\\n'\n    '  vec4 pos = VCPCMatrix * vertexVC;\\n', fragString]).result;\n\n    // Strip out the normal line -- the normal is computed as part of the depth\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', '').result;\n    if (model.haveSeenDepthRequest) {\n      // special depth impl\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float computedZ = (pos.z / pos.w + 1.0) / 2.0;', 'float iz = floor(computedZ * 65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    superClass.replaceShaderValues(shaders, ren, actor);\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime()) && cellBO.getProgram().isAttributeUsed('offsetMC')) {\n      if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'offsetMC', 12,\n      // 12:this->VBO->ColorOffset+sizeof(float)\n      cellBO.getCABO().getStride(), model.context.FLOAT, 2, false)) {\n        vtkErrorMacro(\"Error setting 'offsetMC' in shader VAO.\");\n      }\n    }\n    if (cellBO.getProgram().isUniformUsed('invertedDepth')) {\n      cellBO.getProgram().setUniformf('invertedDepth', model.invert ? -1.0 : 1.0);\n    }\n    if (cellBO.getProgram().isUniformUsed('scaleFactor')) {\n      // apply scaling factor only if a scale array has been provided.\n      const poly = model.currentInput;\n      const pointData = poly.getPointData();\n      if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n        cellBO.getProgram().setUniformf('scaleFactor', model.renderable.getScaleFactor());\n      } else {\n        cellBO.getProgram().setUniformf('scaleFactor', 1.0);\n      }\n    }\n    superClass.setMapperShaderParameters(cellBO, ren, actor);\n  };\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    const cam = ren.getActiveCamera();\n    const keyMats = model.openGLCamera.getKeyMatrices(ren);\n    if (program.isUniformUsed('VCPCMatrix')) {\n      program.setUniformMatrix('VCPCMatrix', keyMats.vcpc);\n    }\n    if (program.isUniformUsed('MCVCMatrix')) {\n      if (!actor.getIsIdentity()) {\n        const actMats = model.openGLActor.getKeyMatrices();\n        const tmp4 = new Float64Array(16);\n        mat4.multiply(tmp4, keyMats.wcvc, actMats.mcwc);\n        program.setUniformMatrix('MCVCMatrix', tmp4);\n      } else {\n        program.setUniformMatrix('MCVCMatrix', keyMats.wcvc);\n      }\n    }\n    if (program.isUniformUsed('cameraParallel')) {\n      cellBO.getProgram().setUniformi('cameraParallel', cam.getParallelProjection());\n    }\n  };\n  publicAPI.getOpenGLMode = (rep, type) => model.context.TRIANGLES;\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const poly = model.currentInput;\n    if (poly === null) {\n      return;\n    }\n    model.renderable.mapScalars(poly, 1.0);\n    const c = model.renderable.getColorMapColors();\n    const vbo = model.primitives[model.primTypes.Tris].getCABO();\n    const pointData = poly.getPointData();\n    const points = poly.getPoints();\n    const numPoints = points.getNumberOfPoints();\n    const pointArray = points.getData();\n    const pointSize = 5; // x,y,z,orientation1,orientation2\n    let scales = null;\n    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n      scales = pointData.getArray(model.renderable.getScaleArray()).getData();\n    }\n    let colorData = null;\n    let colorComponents = 0;\n    let packedUCVBO = null;\n    if (c) {\n      colorComponents = c.getNumberOfComponents();\n      vbo.setColorOffset(0);\n      vbo.setColorBOStride(4);\n      colorData = c.getData();\n      packedUCVBO = new Uint8Array(3 * numPoints * 4);\n      if (!vbo.getColorBO()) {\n        vbo.setColorBO(vtkBufferObject.newInstance());\n      }\n      vbo.getColorBO().setOpenGLRenderWindow(model._openGLRenderWindow);\n    } else if (vbo.getColorBO()) {\n      vbo.setColorBO(null);\n    }\n    vbo.setColorComponents(colorComponents);\n    const packedVBO = new Float32Array(pointSize * numPoints * 3);\n    vbo.setStride(pointSize * 4);\n    const cos30 = Math.cos(radiansFromDegrees(30.0));\n    let pointIdx = 0;\n    let colorIdx = 0;\n\n    //\n    // Generate points and point data for sides\n    //\n    let vboIdx = 0;\n    let ucIdx = 0;\n    for (let i = 0; i < numPoints; ++i) {\n      let radius = model.renderable.getRadius();\n      if (scales) {\n        radius = scales[i];\n      }\n      pointIdx = i * 3;\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = -2.0 * radius * cos30;\n      packedVBO[vboIdx++] = -radius;\n      if (colorData) {\n        colorIdx = i * colorComponents;\n        packedUCVBO[ucIdx++] = colorData[colorIdx];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];\n      }\n      pointIdx = i * 3;\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = 2.0 * radius * cos30;\n      packedVBO[vboIdx++] = -radius;\n      if (colorData) {\n        packedUCVBO[ucIdx++] = colorData[colorIdx];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];\n      }\n      pointIdx = i * 3;\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = 0.0;\n      packedVBO[vboIdx++] = 2.0 * radius;\n      if (colorData) {\n        packedUCVBO[ucIdx++] = colorData[colorIdx];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];\n      }\n    }\n    vbo.setElementCount(vboIdx / pointSize);\n    vbo.upload(packedVBO, ObjectType.ARRAY_BUFFER);\n    if (c) {\n      vbo.getColorBO().upload(packedUCVBO, ObjectType.ARRAY_BUFFER);\n    }\n    model.VBOBuildTime.modified();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkOpenGLPolyDataMapper.extend(publicAPI, model, initialValues);\n\n  // Object methods\n  vtkOpenGLSphereMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLSphereMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkSphereMapper = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkSphereMapper', newInstance);\nexport { vtkSphereMapper as default, extend, newInstance };","map":{"version":3,"names":["mat4","ObjectType","n","newInstance$1","c","macro","vtkBufferObject","r","radiansFromDegrees","vtkShaderProgram","vtkOpenGLPolyDataMapper","v","vtkSphereMapperVS","vtkPolyDataFS","registerOverride","vtkErrorMacro","vtkOpenGLSphereMapper","publicAPI","model","classHierarchy","push","superClass","getShaderTemplate","shaders","ren","actor","Vertex","Fragment","Geometry","replaceShaderValues","VSSource","FSSource","substitute","result","replacement","fragString","context","getExtension","_openGLRenderWindow","getWebgl2","haveSeenDepthRequest","setMapperShaderParameters","cellBO","getCABO","getElementCount","VBOBuildTime","getAttributeUpdateTime","getMTime","getShaderSourceTime","getProgram","isAttributeUsed","getVAO","addAttributeArray","getStride","FLOAT","isUniformUsed","setUniformf","invert","poly","currentInput","pointData","getPointData","renderable","getScaleArray","hasArray","getScaleFactor","setCameraShaderParameters","program","cam","getActiveCamera","keyMats","openGLCamera","getKeyMatrices","setUniformMatrix","vcpc","getIsIdentity","actMats","openGLActor","tmp4","Float64Array","multiply","wcvc","mcwc","setUniformi","getParallelProjection","getOpenGLMode","rep","type","TRIANGLES","buildBufferObjects","mapScalars","getColorMapColors","vbo","primitives","primTypes","Tris","points","getPoints","numPoints","getNumberOfPoints","pointArray","getData","pointSize","scales","getArray","colorData","colorComponents","packedUCVBO","getNumberOfComponents","setColorOffset","setColorBOStride","Uint8Array","getColorBO","setColorBO","newInstance","setOpenGLRenderWindow","setColorComponents","packedVBO","Float32Array","setStride","cos30","Math","cos","pointIdx","colorIdx","vboIdx","ucIdx","i","radius","getRadius","setElementCount","upload","ARRAY_BUFFER","modified","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","vtkSphereMapper","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/OpenGL/SphereMapper.js"],"sourcesContent":["import { mat4 } from 'gl-matrix';\nimport { ObjectType } from './BufferObject/Constants.js';\nimport { n as newInstance$1, c as macro } from '../../macros2.js';\nimport vtkBufferObject from './BufferObject.js';\nimport { r as radiansFromDegrees } from '../../Common/Core/Math/index.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkOpenGLPolyDataMapper from './PolyDataMapper.js';\nimport { v as vtkSphereMapperVS } from './glsl/vtkSphereMapperVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLSphereMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLSphereMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLSphereMapper');\n\n  // Capture 'parentClass' api for internal use\n  const superClass = {\n    ...publicAPI\n  };\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkSphereMapperVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 VCPCMatrix;\\n', 'uniform mat4 MCVCMatrix;']).result;\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;\n\n    // we create vertexVC below, so turn off the default\n    // implementation\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Impl', ['vec4 vertexVC = vertexVCVSOutput;\\n']).result;\n\n    // for lights kit and positional the VCPC matrix is already defined\n    // so don't redefine it\n    const replacement = ['uniform float invertedDepth;\\n', 'uniform int cameraParallel;\\n', 'varying float radiusVCVSOutput;\\n', 'varying vec3 centerVCVSOutput;\\n', 'uniform mat4 VCPCMatrix;\\n'];\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', replacement).result;\n    let fragString = '';\n    if (model.context.getExtension('EXT_frag_depth')) {\n      fragString = 'gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n';\n    }\n    if (model._openGLRenderWindow.getWebgl2()) {\n      fragString = 'gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n';\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', [\n    // compute the eye position and unit direction\n    '  vec3 EyePos;\\n', '  vec3 EyeDir;\\n', '  if (cameraParallel != 0) {\\n', '    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n', '    EyeDir = vec3(0.0,0.0,-1.0); }\\n', '  else {\\n', '    EyeDir = vertexVC.xyz;\\n', '    EyePos = vec3(0.0,0.0,0.0);\\n', '    float lengthED = length(EyeDir);\\n', '    EyeDir = normalize(EyeDir);\\n',\n    // we adjust the EyePos to be closer if it is too far away\n    // to prevent floating point precision noise\n    '    if (lengthED > radiusVCVSOutput*3.0) {\\n', '      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n', '    }\\n',\n    // translate to Sphere center\n    '  EyePos = EyePos - centerVCVSOutput;\\n',\n    // scale to radius 1.0\n    '  EyePos = EyePos/radiusVCVSOutput;\\n',\n    // find the intersection\n    '  float b = 2.0*dot(EyePos,EyeDir);\\n', '  float c = dot(EyePos,EyePos) - 1.0;\\n', '  float d = b*b - 4.0*c;\\n', '  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n', '  if (d < 0.0) { discard; }\\n', '  else {\\n', '    float t = (-b - invertedDepth*sqrt(d))*0.5;\\n',\n    // compute the normal, for unit sphere this is just\n    // the intersection point\n    '    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\\n',\n    // compute the intersection point in VC\n    '    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\\n', '    }\\n',\n    // compute the pixel's depth\n    // ' normalVCVSOutput = vec3(0,0,1);\\n'\n    '  vec4 pos = VCPCMatrix * vertexVC;\\n', fragString]).result;\n\n    // Strip out the normal line -- the normal is computed as part of the depth\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', '').result;\n    if (model.haveSeenDepthRequest) {\n      // special depth impl\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float computedZ = (pos.z / pos.w + 1.0) / 2.0;', 'float iz = floor(computedZ * 65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    superClass.replaceShaderValues(shaders, ren, actor);\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime()) && cellBO.getProgram().isAttributeUsed('offsetMC')) {\n      if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'offsetMC', 12,\n      // 12:this->VBO->ColorOffset+sizeof(float)\n      cellBO.getCABO().getStride(), model.context.FLOAT, 2, false)) {\n        vtkErrorMacro(\"Error setting 'offsetMC' in shader VAO.\");\n      }\n    }\n    if (cellBO.getProgram().isUniformUsed('invertedDepth')) {\n      cellBO.getProgram().setUniformf('invertedDepth', model.invert ? -1.0 : 1.0);\n    }\n    if (cellBO.getProgram().isUniformUsed('scaleFactor')) {\n      // apply scaling factor only if a scale array has been provided.\n      const poly = model.currentInput;\n      const pointData = poly.getPointData();\n      if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n        cellBO.getProgram().setUniformf('scaleFactor', model.renderable.getScaleFactor());\n      } else {\n        cellBO.getProgram().setUniformf('scaleFactor', 1.0);\n      }\n    }\n    superClass.setMapperShaderParameters(cellBO, ren, actor);\n  };\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    const cam = ren.getActiveCamera();\n    const keyMats = model.openGLCamera.getKeyMatrices(ren);\n    if (program.isUniformUsed('VCPCMatrix')) {\n      program.setUniformMatrix('VCPCMatrix', keyMats.vcpc);\n    }\n    if (program.isUniformUsed('MCVCMatrix')) {\n      if (!actor.getIsIdentity()) {\n        const actMats = model.openGLActor.getKeyMatrices();\n        const tmp4 = new Float64Array(16);\n        mat4.multiply(tmp4, keyMats.wcvc, actMats.mcwc);\n        program.setUniformMatrix('MCVCMatrix', tmp4);\n      } else {\n        program.setUniformMatrix('MCVCMatrix', keyMats.wcvc);\n      }\n    }\n    if (program.isUniformUsed('cameraParallel')) {\n      cellBO.getProgram().setUniformi('cameraParallel', cam.getParallelProjection());\n    }\n  };\n  publicAPI.getOpenGLMode = (rep, type) => model.context.TRIANGLES;\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const poly = model.currentInput;\n    if (poly === null) {\n      return;\n    }\n    model.renderable.mapScalars(poly, 1.0);\n    const c = model.renderable.getColorMapColors();\n    const vbo = model.primitives[model.primTypes.Tris].getCABO();\n    const pointData = poly.getPointData();\n    const points = poly.getPoints();\n    const numPoints = points.getNumberOfPoints();\n    const pointArray = points.getData();\n    const pointSize = 5; // x,y,z,orientation1,orientation2\n    let scales = null;\n    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n      scales = pointData.getArray(model.renderable.getScaleArray()).getData();\n    }\n    let colorData = null;\n    let colorComponents = 0;\n    let packedUCVBO = null;\n    if (c) {\n      colorComponents = c.getNumberOfComponents();\n      vbo.setColorOffset(0);\n      vbo.setColorBOStride(4);\n      colorData = c.getData();\n      packedUCVBO = new Uint8Array(3 * numPoints * 4);\n      if (!vbo.getColorBO()) {\n        vbo.setColorBO(vtkBufferObject.newInstance());\n      }\n      vbo.getColorBO().setOpenGLRenderWindow(model._openGLRenderWindow);\n    } else if (vbo.getColorBO()) {\n      vbo.setColorBO(null);\n    }\n    vbo.setColorComponents(colorComponents);\n    const packedVBO = new Float32Array(pointSize * numPoints * 3);\n    vbo.setStride(pointSize * 4);\n    const cos30 = Math.cos(radiansFromDegrees(30.0));\n    let pointIdx = 0;\n    let colorIdx = 0;\n\n    //\n    // Generate points and point data for sides\n    //\n    let vboIdx = 0;\n    let ucIdx = 0;\n    for (let i = 0; i < numPoints; ++i) {\n      let radius = model.renderable.getRadius();\n      if (scales) {\n        radius = scales[i];\n      }\n      pointIdx = i * 3;\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = -2.0 * radius * cos30;\n      packedVBO[vboIdx++] = -radius;\n      if (colorData) {\n        colorIdx = i * colorComponents;\n        packedUCVBO[ucIdx++] = colorData[colorIdx];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];\n      }\n      pointIdx = i * 3;\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = 2.0 * radius * cos30;\n      packedVBO[vboIdx++] = -radius;\n      if (colorData) {\n        packedUCVBO[ucIdx++] = colorData[colorIdx];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];\n      }\n      pointIdx = i * 3;\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = 0.0;\n      packedVBO[vboIdx++] = 2.0 * radius;\n      if (colorData) {\n        packedUCVBO[ucIdx++] = colorData[colorIdx];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];\n      }\n    }\n    vbo.setElementCount(vboIdx / pointSize);\n    vbo.upload(packedVBO, ObjectType.ARRAY_BUFFER);\n    if (c) {\n      vbo.getColorBO().upload(packedUCVBO, ObjectType.ARRAY_BUFFER);\n    }\n    model.VBOBuildTime.modified();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkOpenGLPolyDataMapper.extend(publicAPI, model, initialValues);\n\n  // Object methods\n  vtkOpenGLSphereMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLSphereMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkSphereMapper = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkSphereMapper', newInstance);\n\nexport { vtkSphereMapper as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}