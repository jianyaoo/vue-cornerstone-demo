import { Enums, eventTarget, metaData, imageLoadPoolManager, triggerEvent, ImageVolume, cache, imageLoader, utilities as csUtils, ProgressiveRetrieveImages, canRenderFloatTextures, } from '@cornerstonejs/core';
import { scaleArray, autoLoad } from './helpers';
const requestTypeDefault = Enums.RequestType.Prefetch;
const { ProgressiveIterator, imageRetrieveMetadataProvider, hasFloatScalingParameters, } = csUtils;
const { ImageQualityStatus } = Enums;
export default class BaseStreamingImageVolume extends ImageVolume {
    constructor(imageVolumeProperties, streamingProperties) {
        super(imageVolumeProperties);
        this.framesLoaded = 0;
        this.framesProcessed = 0;
        this.framesUpdated = 0;
        this.autoRenderOnLoad = true;
        this.cachedFrames = [];
        this.reRenderTarget = 0;
        this.reRenderFraction = 2;
        this.imagesLoader = this;
        this.cancelLoading = () => {
            const { loadStatus } = this;
            if (!loadStatus || !loadStatus.loading) {
                return;
            }
            loadStatus.loading = false;
            loadStatus.cancelled = true;
            this.clearLoadCallbacks();
            const filterFunction = ({ additionalDetails }) => {
                return additionalDetails.volumeId !== this.volumeId;
            };
            imageLoadPoolManager.filterRequests(filterFunction);
        };
        this.load = (callback) => {
            const { imageIds, loadStatus, numFrames } = this;
            const { transferSyntaxUID } = metaData.get('transferSyntax', imageIds[0]) || {};
            const imageRetrieveConfiguration = metaData.get(imageRetrieveMetadataProvider.IMAGE_RETRIEVE_CONFIGURATION, this.volumeId, transferSyntaxUID, 'volume');
            this.imagesLoader = imageRetrieveConfiguration
                ? (imageRetrieveConfiguration.create ||
                    ProgressiveRetrieveImages.createProgressive)(imageRetrieveConfiguration)
                : this;
            if (loadStatus.loading === true) {
                return;
            }
            const { loaded } = this.loadStatus;
            const totalNumFrames = imageIds.length;
            if (loaded) {
                if (callback) {
                    callback({
                        success: true,
                        framesLoaded: totalNumFrames,
                        framesProcessed: totalNumFrames,
                        numFrames,
                        totalNumFrames,
                    });
                }
                return;
            }
            if (callback) {
                this.loadStatus.callbacks.push(callback);
            }
            this._prefetchImageIds();
        };
        this.loadStatus = streamingProperties.loadStatus;
    }
    invalidateVolume(immediate) {
        const { imageData, vtkOpenGLTexture } = this;
        const { numFrames } = this;
        for (let i = 0; i < numFrames; i++) {
            vtkOpenGLTexture.setUpdatedFrame(i);
        }
        imageData.modified();
        if (immediate) {
            autoLoad(this.volumeId);
        }
    }
    clearLoadCallbacks() {
        this.loadStatus.callbacks = [];
    }
    callLoadStatusCallback(evt) {
        const { framesUpdated, framesProcessed, totalNumFrames } = evt;
        const { volumeId, reRenderFraction, loadStatus, metadata } = this;
        const { FrameOfReferenceUID } = metadata;
        if (this.autoRenderOnLoad) {
            if (framesUpdated > this.reRenderTarget ||
                framesProcessed === totalNumFrames) {
                this.reRenderTarget += reRenderFraction;
                autoLoad(volumeId);
            }
        }
        if (framesProcessed === totalNumFrames) {
            loadStatus.callbacks.forEach((callback) => callback(evt));
            const eventDetail = {
                FrameOfReferenceUID,
                volumeId: volumeId,
            };
            triggerEvent(eventTarget, Enums.Events.IMAGE_VOLUME_LOADING_COMPLETED, eventDetail);
        }
    }
    updateTextureAndTriggerEvents(imageIdIndex, imageId, imageQualityStatus = ImageQualityStatus.FULL_RESOLUTION) {
        const frameIndex = this.imageIdIndexToFrameIndex(imageIdIndex);
        const { cachedFrames, numFrames, totalNumFrames } = this;
        const { FrameOfReferenceUID } = this.metadata;
        const currentStatus = cachedFrames[frameIndex];
        if (currentStatus > imageQualityStatus) {
            return;
        }
        if (cachedFrames[frameIndex] === ImageQualityStatus.FULL_RESOLUTION) {
            return;
        }
        const complete = imageQualityStatus === ImageQualityStatus.FULL_RESOLUTION;
        cachedFrames[imageIdIndex] = imageQualityStatus;
        this.framesUpdated++;
        if (complete) {
            this.framesLoaded++;
            this.framesProcessed++;
        }
        this.vtkOpenGLTexture.setUpdatedFrame(frameIndex);
        this.imageData.modified();
        const eventDetail = {
            FrameOfReferenceUID,
            imageVolume: this,
            numberOfFrames: numFrames,
            framesProcessed: this.framesProcessed,
        };
        triggerEvent(eventTarget, Enums.Events.IMAGE_VOLUME_MODIFIED, eventDetail);
        if (complete && this.framesProcessed === this.totalNumFrames) {
            this.loadStatus.loaded = true;
            this.loadStatus.loading = false;
        }
        this.callLoadStatusCallback({
            success: true,
            imageIdIndex,
            imageId,
            framesLoaded: this.framesLoaded,
            framesProcessed: this.framesProcessed,
            framesUpdated: this.framesUpdated,
            numFrames,
            totalNumFrames,
            complete,
            imageQualityStatus,
        });
        if (this.loadStatus.loaded) {
            this.loadStatus.callbacks = [];
        }
    }
    successCallback(imageId, image) {
        const imageIdIndex = this.getImageIdIndex(imageId);
        const options = this.getLoaderImageOptions(imageId);
        const scalarData = this.getScalarDataByImageIdIndex(imageIdIndex);
        handleArrayBufferLoad(scalarData, image, options);
        const { scalingParameters } = image.preScale || {};
        const { imageQualityStatus } = image;
        const frameIndex = this.imageIdIndexToFrameIndex(imageIdIndex);
        const cachedImage = cache.getCachedImageBasedOnImageURI(imageId);
        const cachedVolume = cache.getVolumeContainingImageId(imageId);
        if (this.loadStatus.cancelled) {
            console.warn('volume load cancelled, returning for imageIdIndex: ', imageIdIndex);
            return;
        }
        if (!cachedImage && !(cachedVolume && cachedVolume.volume !== this)) {
            return this.updateTextureAndTriggerEvents(imageIdIndex, imageId, imageQualityStatus);
        }
        const isFromImageCache = !!cachedImage;
        if (isFromImageCache && options.targetBuffer) {
            this.imageCacheOffsetMap.set(imageId, {
                imageIdIndex,
                frameIndex,
                offset: options.targetBuffer?.offset || 0,
                length: options.targetBuffer?.length,
            });
        }
        const cachedImageOrVolume = cachedImage || cachedVolume.volume;
        this.handleImageComingFromCache(cachedImageOrVolume, isFromImageCache, scalingParameters, scalarData, frameIndex, scalarData.buffer, imageIdIndex, imageId);
    }
    errorCallback(imageId, permanent, error) {
        if (!permanent) {
            return;
        }
        const { totalNumFrames, numFrames } = this;
        const imageIdIndex = this.getImageIdIndex(imageId);
        this.framesProcessed++;
        if (this.framesProcessed === totalNumFrames) {
            this.loadStatus.loaded = true;
            this.loadStatus.loading = false;
        }
        this.callLoadStatusCallback({
            success: false,
            imageId,
            imageIdIndex,
            error,
            framesLoaded: this.framesLoaded,
            framesProcessed: this.framesProcessed,
            framesUpdated: this.framesUpdated,
            numFrames,
            totalNumFrames,
        });
        if (this.loadStatus.loaded) {
            this.loadStatus.callbacks = [];
        }
        const eventDetail = {
            error,
            imageIdIndex,
            imageId,
        };
        triggerEvent(eventTarget, Enums.Events.IMAGE_LOAD_ERROR, eventDetail);
    }
    getLoaderImageOptions(imageId) {
        const { transferSyntaxUID: transferSyntaxUID } = metaData.get('transferSyntax', imageId) || {};
        const imagePlaneModule = metaData.get('imagePlaneModule', imageId) || {};
        const { rows, columns } = imagePlaneModule;
        const imageIdIndex = this.getImageIdIndex(imageId);
        const scalarData = this.getScalarDataByImageIdIndex(imageIdIndex);
        if (!scalarData) {
            return null;
        }
        const arrayBuffer = scalarData.buffer;
        const { type, length, lengthInBytes } = getScalarDataType(scalarData, this.numFrames);
        const modalityLutModule = metaData.get('modalityLutModule', imageId) || {};
        const generalSeriesModule = metaData.get('generalSeriesModule', imageId) || {};
        const scalingParameters = {
            rescaleSlope: modalityLutModule.rescaleSlope,
            rescaleIntercept: modalityLutModule.rescaleIntercept,
            modality: generalSeriesModule.modality,
        };
        if (scalingParameters.modality === 'PT') {
            const suvFactor = metaData.get('scalingModule', imageId);
            if (suvFactor) {
                this._addScalingToVolume(suvFactor);
                scalingParameters.suvbw = suvFactor.suvbw;
            }
        }
        const floatAfterScale = hasFloatScalingParameters(scalingParameters);
        const allowFloatRendering = canRenderFloatTextures();
        this.isPreScaled = true;
        if (scalingParameters &&
            scalingParameters.rescaleSlope !== undefined &&
            scalingParameters.rescaleIntercept !== undefined) {
            const { rescaleSlope, rescaleIntercept } = scalingParameters;
            this.isPreScaled =
                typeof rescaleSlope === 'number' &&
                    typeof rescaleIntercept === 'number';
        }
        if (!allowFloatRendering && floatAfterScale) {
            this.isPreScaled = false;
        }
        const frameIndex = this.imageIdIndexToFrameIndex(imageIdIndex);
        return {
            targetBuffer: {
                arrayBuffer: arrayBuffer instanceof ArrayBuffer ? undefined : arrayBuffer,
                offset: frameIndex * lengthInBytes,
                length,
                type,
                rows,
                columns,
            },
            skipCreateImage: true,
            allowFloatRendering,
            preScale: {
                enabled: this.isPreScaled,
                scalingParameters,
            },
            transferPixelData: true,
            transferSyntaxUID,
            loader: imageLoader.loadImage,
            additionalDetails: {
                imageId,
                imageIdIndex,
                volumeId: this.volumeId,
            },
        };
    }
    callLoadImage(imageId, imageIdIndex, options) {
        const { cachedFrames } = this;
        if (cachedFrames[imageIdIndex] === ImageQualityStatus.FULL_RESOLUTION) {
            return;
        }
        const uncompressedIterator = ProgressiveIterator.as(imageLoader.loadImage(imageId, options));
        return uncompressedIterator.forEach((image) => {
            this.successCallback(imageId, image);
        }, this.errorCallback.bind(this, imageIdIndex, imageId));
    }
    getImageIdsRequests(imageIds, priorityDefault) {
        this.totalNumFrames = this.imageIds.length;
        const autoRenderPercentage = 2;
        if (this.autoRenderOnLoad) {
            this.reRenderFraction =
                this.totalNumFrames * (autoRenderPercentage / 100);
            this.reRenderTarget = this.reRenderFraction;
        }
        const requests = imageIds.map((imageId) => {
            const imageIdIndex = this.getImageIdIndex(imageId);
            const requestType = requestTypeDefault;
            const priority = priorityDefault;
            const options = this.getLoaderImageOptions(imageId);
            return {
                callLoadImage: this.callLoadImage.bind(this),
                imageId,
                imageIdIndex,
                options,
                priority,
                requestType,
                additionalDetails: {
                    volumeId: this.volumeId,
                },
            };
        });
        return requests;
    }
    handleImageComingFromCache(cachedImageOrVolume, isFromImageCache, scalingParameters, scalarData, frameIndex, arrayBuffer, imageIdIndex, imageId) {
        const imageLoadObject = isFromImageCache
            ? cachedImageOrVolume.imageLoadObject
            : cachedImageOrVolume.convertToCornerstoneImage(imageId, imageIdIndex);
        imageLoadObject.promise
            .then((cachedImage) => {
            const imageScalarData = this._scaleIfNecessary(cachedImage, scalingParameters);
            const { pixelsPerImage, bytesPerImage } = this.cornerstoneImageMetaData;
            const TypedArray = scalarData.constructor;
            let byteOffset = bytesPerImage * frameIndex;
            const bytePerPixel = bytesPerImage / pixelsPerImage;
            if (scalarData.BYTES_PER_ELEMENT !== bytePerPixel) {
                byteOffset *= scalarData.BYTES_PER_ELEMENT / bytePerPixel;
            }
            const volumeBufferView = new TypedArray(arrayBuffer, byteOffset, pixelsPerImage);
            volumeBufferView.set(imageScalarData);
            this.updateTextureAndTriggerEvents(imageIdIndex, imageId, cachedImage.imageQualityStatus);
        })
            .catch((err) => {
            this.errorCallback(imageId, true, err);
        });
    }
    getImageLoadRequests(_priority) {
        throw new Error('Abstract method');
    }
    getImageIdsToLoad() {
        throw new Error('Abstract method');
    }
    loadImages(imageIds, listener) {
        this.loadStatus.loading = true;
        const requests = this.getImageLoadRequests(5);
        requests.reverse().forEach((request) => {
            if (!request) {
                return;
            }
            const { callLoadImage, imageId, imageIdIndex, options, priority, requestType, additionalDetails, } = request;
            imageLoadPoolManager.addRequest(callLoadImage.bind(this, imageId, imageIdIndex, options), requestType, additionalDetails, priority);
        });
        return Promise.resolve(true);
    }
    _prefetchImageIds() {
        this.loadStatus.loading = true;
        const imageIds = [...this.getImageIdsToLoad()];
        imageIds.reverse();
        this.totalNumFrames = this.imageIds.length;
        const autoRenderPercentage = 2;
        if (this.autoRenderOnLoad) {
            this.reRenderFraction =
                this.totalNumFrames * (autoRenderPercentage / 100);
            this.reRenderTarget = this.reRenderFraction;
        }
        return this.imagesLoader.loadImages(imageIds, this).catch((e) => {
            console.debug('progressive loading failed to complete', e);
        });
    }
    _scaleIfNecessary(image, scalingParametersToUse) {
        if (!image.preScale?.enabled) {
            return image.getPixelData().slice(0);
        }
        const imageIsAlreadyScaled = image.preScale?.scaled;
        const noScalingParametersToUse = !scalingParametersToUse ||
            !scalingParametersToUse.rescaleIntercept ||
            !scalingParametersToUse.rescaleSlope;
        if (!imageIsAlreadyScaled && noScalingParametersToUse) {
            return image.getPixelData().slice(0);
        }
        if (!imageIsAlreadyScaled &&
            scalingParametersToUse &&
            scalingParametersToUse.rescaleIntercept !== undefined &&
            scalingParametersToUse.rescaleSlope !== undefined) {
            const pixelDataCopy = image.getPixelData().slice(0);
            const scaledArray = scaleArray(pixelDataCopy, scalingParametersToUse);
            return scaledArray;
        }
        const { rescaleSlope: rescaleSlopeToUse, rescaleIntercept: rescaleInterceptToUse, suvbw: suvbwToUse, } = scalingParametersToUse;
        const { rescaleSlope: rescaleSlopeUsed, rescaleIntercept: rescaleInterceptUsed, suvbw: suvbwUsed, } = image.preScale.scalingParameters;
        const rescaleSlopeIsSame = rescaleSlopeToUse === rescaleSlopeUsed;
        const rescaleInterceptIsSame = rescaleInterceptToUse === rescaleInterceptUsed;
        const suvbwIsSame = suvbwToUse === suvbwUsed;
        if (rescaleSlopeIsSame && rescaleInterceptIsSame && suvbwIsSame) {
            return image.getPixelData();
        }
        const pixelDataCopy = image.getPixelData().slice(0);
        const newSuvbw = suvbwToUse / suvbwUsed;
        const newRescaleSlope = rescaleSlopeToUse / rescaleSlopeUsed;
        const newRescaleIntercept = rescaleInterceptToUse - rescaleInterceptUsed * newRescaleSlope;
        const newScalingParameters = {
            ...scalingParametersToUse,
            rescaleSlope: newRescaleSlope,
            rescaleIntercept: newRescaleIntercept,
            suvbw: newSuvbw,
        };
        const scaledArray = scaleArray(pixelDataCopy, newScalingParameters);
        return scaledArray;
    }
    _addScalingToVolume(suvFactor) {
        if (this.scaling) {
            return;
        }
        const { suvbw, suvlbm, suvbsa } = suvFactor;
        const petScaling = {};
        if (suvlbm) {
            petScaling.suvbwToSuvlbm = suvlbm / suvbw;
        }
        if (suvbsa) {
            petScaling.suvbwToSuvbsa = suvbsa / suvbw;
        }
        if (suvbw) {
            petScaling.suvbw = suvbw;
        }
        this.scaling = { PT: petScaling };
    }
}
function getScalarDataType(scalarData, numFrames) {
    let type, byteSize;
    if (scalarData instanceof Uint8Array) {
        type = 'Uint8Array';
        byteSize = 1;
    }
    else if (scalarData instanceof Float32Array) {
        type = 'Float32Array';
        byteSize = 4;
    }
    else if (scalarData instanceof Uint16Array) {
        type = 'Uint16Array';
        byteSize = 2;
    }
    else if (scalarData instanceof Int16Array) {
        type = 'Int16Array';
        byteSize = 2;
    }
    else {
        throw new Error('Unsupported array type');
    }
    const length = scalarData.length / numFrames;
    const lengthInBytes = length * byteSize;
    return { type, byteSize, length, lengthInBytes };
}
function handleArrayBufferLoad(scalarData, image, options) {
    if (!(scalarData.buffer instanceof ArrayBuffer)) {
        return;
    }
    const offset = options.targetBuffer.offset;
    const length = options.targetBuffer.length;
    const pixelData = image.pixelData ? image.pixelData : image.getPixelData();
    try {
        if (scalarData instanceof Float32Array) {
            const bytesInFloat = 4;
            const floatView = new Float32Array(pixelData);
            if (floatView.length !== length) {
                throw 'Error pixelData length does not match frame length';
            }
            scalarData.set(floatView, offset / bytesInFloat);
        }
        if (scalarData instanceof Int16Array) {
            const bytesInInt16 = 2;
            const intView = new Int16Array(pixelData);
            if (intView.length !== length) {
                throw 'Error pixelData length does not match frame length';
            }
            scalarData.set(intView, offset / bytesInInt16);
        }
        if (scalarData instanceof Uint16Array) {
            const bytesInUint16 = 2;
            const intView = new Uint16Array(pixelData);
            if (intView.length !== length) {
                throw 'Error pixelData length does not match frame length';
            }
            scalarData.set(intView, offset / bytesInUint16);
        }
        if (scalarData instanceof Uint8Array) {
            const bytesInUint8 = 1;
            const intView = new Uint8Array(pixelData);
            if (intView.length !== length) {
                throw 'Error pixelData length does not match frame length';
            }
            scalarData.set(intView, offset / bytesInUint8);
        }
    }
    catch (e) {
        console.error(e);
    }
}
//# sourceMappingURL=BaseStreamingImageVolume.js.map