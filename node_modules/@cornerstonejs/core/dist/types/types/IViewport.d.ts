import ICamera from './ICamera';
import Point2 from './Point2';
import Point3 from './Point3';
import ViewportInputOptions from './ViewportInputOptions';
import { ActorEntry } from './IActor';
import ViewportType from '../enums/ViewportType';
import ViewportStatus from '../enums/ViewportStatus';
import DisplayArea from './displayArea';
import BoundsLPS from './BoundsLPS';
export declare type ViewReferenceSpecifier = {
    sliceIndex?: number | [number, number];
    forFrameOfReference?: boolean;
    points?: Point3[];
    volumeId?: string;
};
export declare type ReferenceCompatibleOptions = {
    withNavigation?: boolean;
    asVolume?: boolean;
    imageURI?: string;
};
export declare type ViewReference = {
    FrameOfReferenceUID: string;
    referencedImageId?: string;
    cameraFocalPoint?: Point3;
    viewPlaneNormal?: Point3;
    sliceIndex?: number | [number, number];
    volumeId?: string;
    bounds?: BoundsLPS;
};
export declare type ViewPresentation = {
    slabThickness?: number;
    rotation?: number;
    displayArea?: DisplayArea;
    zoom?: number;
    pan?: Point2;
};
export declare type ViewPresentationSelector = {
    slabThickness?: boolean;
    rotation?: boolean;
    displayArea?: boolean;
    zoom?: boolean;
    pan?: boolean;
    windowLevel?: boolean;
    paletteLut?: boolean;
};
interface IViewport {
    id: string;
    getWidget: (id: string) => any;
    addWidget: (id: string, widget: any) => void;
    getWidgets: () => any;
    removeWidgets: () => void;
    renderingEngineId: string;
    type: ViewportType;
    canvas: HTMLCanvasElement;
    element: HTMLDivElement;
    sx: number;
    sy: number;
    sWidth: number;
    sHeight: number;
    _actors: Map<string, any>;
    defaultOptions: any;
    options: ViewportInputOptions;
    suppressEvents: boolean;
    isDisabled: boolean;
    viewportStatus: ViewportStatus;
    getRotation: () => number;
    getFrameOfReferenceUID: () => string;
    canvasToWorld: (canvasPos: Point2) => Point3;
    worldToCanvas: (worldPos: Point3) => Point2;
    getDefaultActor(): ActorEntry;
    getActors(): Array<ActorEntry>;
    getActor(actorUID: string): ActorEntry;
    getActorUIDByIndex(index: number): string;
    getActorByIndex(index: number): ActorEntry;
    setActors(actors: Array<ActorEntry>): void;
    addActors(actors: Array<ActorEntry>): void;
    addActor(actorEntry: ActorEntry): void;
    getActorUIDs(): Array<string>;
    removeAllActors(): void;
    removeActors(actorUIDs: Array<string>): void;
    getRenderingEngine(): any;
    getRenderer(): void;
    render(): void;
    setOptions(options: ViewportInputOptions, immediate: boolean): void;
    setDisplayArea(displayArea: DisplayArea, callResetCamera?: boolean, suppressEvents?: boolean): any;
    getDisplayArea(): DisplayArea | undefined;
    reset(immediate: boolean): void;
    getCanvas(): HTMLCanvasElement;
    getCamera(): ICamera;
    setRendered(): void;
    getZoom(): number;
    setZoom(zoom: number, storeAsInitialCamera?: boolean): any;
    getPan(): Point2;
    setPan(pan: Point2, storeAsInitialCamera?: boolean): any;
    setCamera(cameraInterface: ICamera, storeAsInitialCamera?: boolean): void;
    getNumberOfSlices(): number;
    getCurrentImageIdIndex(): number;
    getReferenceId(viewRefSpecifier?: ViewReferenceSpecifier): string;
    getViewReference(viewRefSpecifier?: ViewReferenceSpecifier): ViewReference;
    isReferenceViewable(viewRef: ViewReference, options?: ReferenceCompatibleOptions): boolean;
    getViewPresentation(viewPresSel?: ViewPresentationSelector): ViewPresentation;
    setView(viewRef?: ViewReference, viewPres?: ViewPresentation): any;
    customRenderViewportToCanvas: () => unknown;
    _getCorners(bounds: Array<number>): Array<number>[];
    updateRenderingPipeline: () => void;
}
declare type PublicViewportInput = {
    element: HTMLDivElement;
    viewportId: string;
    type: ViewportType;
    defaultOptions?: ViewportInputOptions;
};
declare type NormalizedViewportInput = {
    element: HTMLDivElement;
    viewportId: string;
    type: ViewportType;
    defaultOptions: ViewportInputOptions;
};
declare type InternalViewportInput = {
    element: HTMLDivElement;
    canvas: HTMLCanvasElement;
    viewportId: string;
    type: ViewportType;
    defaultOptions: ViewportInputOptions;
};
declare type ViewportInput = {
    id: string;
    element: HTMLDivElement;
    canvas: HTMLCanvasElement;
    renderingEngineId: string;
    type: ViewportType;
    sx: number;
    sy: number;
    sWidth: number;
    sHeight: number;
    defaultOptions: ViewportInputOptions;
};
export type { IViewport, ViewportInput, PublicViewportInput, InternalViewportInput, NormalizedViewportInput, };
//# sourceMappingURL=IViewport.d.ts.map