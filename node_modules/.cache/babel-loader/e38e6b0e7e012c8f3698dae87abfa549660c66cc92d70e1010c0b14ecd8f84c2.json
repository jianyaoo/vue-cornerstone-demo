{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkDataArray from './DataArray.js';\nimport vtkScalarsToColors$2 from './ScalarsToColors/Constants.js';\nimport Constants from '../../Rendering/Core/Mapper/Constants.js';\nconst {\n  ScalarMappingTarget,\n  VectorMode\n} = vtkScalarsToColors$2;\nconst {\n  VtkDataTypes\n} = vtkDataArray;\nconst {\n  ColorMode\n} = Constants;\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n// Add module-level functions or api that you want to expose statically via\n// the next section...\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nfunction intColorToUChar(c) {\n  return c;\n}\nfunction floatColorToUChar(c) {\n  return Math.floor(c * 255.0 + 0.5);\n}\n\n// ----------------------------------------------------------------------------\n// vtkScalarsToColors methods\n// ----------------------------------------------------------------------------\n\nfunction vtkScalarsToColors(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkScalarsToColors');\n  publicAPI.setVectorModeToMagnitude = () => publicAPI.setVectorMode(VectorMode.MAGNITUDE);\n  publicAPI.setVectorModeToComponent = () => publicAPI.setVectorMode(VectorMode.COMPONENT);\n  publicAPI.setVectorModeToRGBColors = () => publicAPI.setVectorMode(VectorMode.RGBCOLORS);\n  publicAPI.build = () => {};\n  publicAPI.isOpaque = () => true;\n\n  //----------------------------------------------------------------------------\n  publicAPI.setAnnotations = (values, annotations) => {\n    if (values && !annotations || !values && annotations) {\n      return;\n    }\n    if (values && annotations && values.length !== annotations.length) {\n      vtkErrorMacro('Values and annotations do not have the same number of tuples so ignoring');\n      return;\n    }\n    model.annotationArray = [];\n    if (annotations && values) {\n      const num = annotations.length;\n      for (let i = 0; i < num; i++) {\n        model.annotationArray.push({\n          value: values[i],\n          annotation: String(annotations[i])\n        });\n      }\n    }\n    publicAPI.updateAnnotatedValueMap();\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.setAnnotation = (value, annotation) => {\n    let i = publicAPI.checkForAnnotatedValue(value);\n    let modified = false;\n    if (i >= 0) {\n      if (model.annotationArray[i].annotation !== annotation) {\n        model.annotationArray[i].annotation = annotation;\n        modified = true;\n      }\n    } else {\n      model.annotationArray.push({\n        value,\n        annotation\n      });\n      i = model.annotationArray.length - 1;\n      modified = true;\n    }\n    if (modified) {\n      publicAPI.updateAnnotatedValueMap();\n      publicAPI.modified();\n    }\n    return i;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getNumberOfAnnotatedValues = () => model.annotationArray.length;\n\n  //----------------------------------------------------------------------------\n  publicAPI.getAnnotatedValue = idx => {\n    if (idx < 0 || idx >= model.annotationArray.length) {\n      return null;\n    }\n    return model.annotationArray[idx].value;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getAnnotation = idx => {\n    if (model.annotationArray[idx] === undefined) {\n      return null;\n    }\n    return model.annotationArray[idx].annotation;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getAnnotatedValueIndex = val => model.annotationArray.length ? publicAPI.checkForAnnotatedValue(val) : -1;\n\n  //----------------------------------------------------------------------------\n  publicAPI.removeAnnotation = value => {\n    const i = publicAPI.checkForAnnotatedValue(value);\n    const needToRemove = i >= 0;\n    if (needToRemove) {\n      model.annotationArray.splice(i, 1);\n      publicAPI.updateAnnotatedValueMap();\n      publicAPI.modified();\n    }\n    return needToRemove;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.resetAnnotations = () => {\n    model.annotationArray = [];\n    model.annotatedValueMap = [];\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getAnnotationColor = (val, rgba) => {\n    if (model.indexedLookup) {\n      const i = publicAPI.getAnnotatedValueIndex(val);\n      publicAPI.getIndexedColor(i, rgba);\n    } else {\n      publicAPI.getColor(parseFloat(val), rgba);\n      rgba[3] = 1.0;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.checkForAnnotatedValue = value => publicAPI.getAnnotatedValueIndexInternal(value);\n\n  //----------------------------------------------------------------------------\n  // An unsafe version of vtkScalarsToColors::CheckForAnnotatedValue for\n  // internal use (no pointer checks performed)\n  publicAPI.getAnnotatedValueIndexInternal = value => {\n    if (model.annotatedValueMap[value] !== undefined) {\n      const na = model.annotationArray.length;\n      return model.annotatedValueMap[value] % na;\n    }\n    // Treat as a NaN\n    return -1;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getIndexedColor = (val, rgba) => {\n    rgba[0] = 0.0;\n    rgba[1] = 0.0;\n    rgba[2] = 0.0;\n    rgba[3] = 0.0;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.updateAnnotatedValueMap = () => {\n    model.annotatedValueMap = [];\n    const na = model.annotationArray.length;\n    for (let i = 0; i < na; i++) {\n      model.annotatedValueMap[model.annotationArray[i].value] = i;\n    }\n  };\n\n  // Description:\n  // Internal methods that map a data array into a 4-component,\n  // unsigned char RGBA array. The color mode determines the behavior\n  // of mapping. If ColorMode.DEFAULT is set, then unsigned char\n  // data arrays are treated as colors (and converted to RGBA if\n  // necessary); If ColorMode.DIRECT_SCALARS is set, then all arrays\n  // are treated as colors (integer types are clamped in the range 0-255,\n  // floating point arrays are clamped in the range 0.0-1.0. Note 'char' does\n  // not have enough values to represent a color so mapping this type is\n  // considered an error);\n  // otherwise, the data is mapped through this instance\n  // of ScalarsToColors. The component argument is used for data\n  // arrays with more than one component; it indicates which component\n  // to use to do the blending.  When the component argument is -1,\n  // then the this object uses its own selected technique to change a\n  // vector into a scalar to map.\n  publicAPI.mapScalars = (scalars, colorMode, componentIn) => {\n    const numberOfComponents = scalars.getNumberOfComponents();\n    let newColors = null;\n\n    // map scalars through lookup table only if needed\n    if (colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || colorMode === ColorMode.DIRECT_SCALARS && scalars) {\n      newColors = publicAPI.convertToRGBA(scalars, numberOfComponents, scalars.getNumberOfTuples());\n    } else {\n      const newscalars = {\n        type: 'vtkDataArray',\n        name: 'temp',\n        numberOfComponents: 4,\n        dataType: VtkDataTypes.UNSIGNED_CHAR\n      };\n      const s = macro.newTypedArray(newscalars.dataType, 4 * scalars.getNumberOfTuples());\n      newscalars.values = s;\n      newscalars.size = s.length;\n      newColors = vtkDataArray.newInstance(newscalars);\n      let component = componentIn;\n\n      // If mapper did not specify a component, use the VectorMode\n      if (component < 0 && numberOfComponents > 1) {\n        publicAPI.mapVectorsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, -1, -1);\n      } else {\n        if (component < 0) {\n          component = 0;\n        }\n        if (component >= numberOfComponents) {\n          component = numberOfComponents - 1;\n        }\n\n        // Map the scalars to colors\n        publicAPI.mapScalarsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, component);\n      }\n    }\n    return newColors;\n  };\n  publicAPI.mapVectorsToMagnitude = (input, output, compsToUse) => {\n    const length = input.getNumberOfTuples();\n    const inIncr = input.getNumberOfComponents();\n    const outputV = output.getData();\n    const inputV = input.getData();\n    for (let i = 0; i < length; i++) {\n      let sum = 0.0;\n      for (let j = 0; j < compsToUse; j++) {\n        sum += inputV[i * inIncr + j] * inputV[i * inIncr + j];\n      }\n      outputV[i] = Math.sqrt(sum);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  // Map a set of vector values through the table\n  publicAPI.mapVectorsThroughTable = (input, output, outputFormat, vectorComponentIn, vectorSizeIn) => {\n    let vectorMode = publicAPI.getVectorMode();\n    let vectorSize = vectorSizeIn;\n    let vectorComponent = vectorComponentIn;\n    const inComponents = input.getNumberOfComponents();\n    if (vectorMode === VectorMode.COMPONENT) {\n      // make sure vectorComponent is within allowed range\n      if (vectorComponent === -1) {\n        // if set to -1, use default value provided by table\n        vectorComponent = publicAPI.getVectorComponent();\n      }\n      if (vectorComponent < 0) {\n        vectorComponent = 0;\n      }\n      if (vectorComponent >= inComponents) {\n        vectorComponent = inComponents - 1;\n      }\n    } else {\n      // make sure vectorSize is within allowed range\n      if (vectorSize === -1) {\n        // if set to -1, use default value provided by table\n        vectorSize = publicAPI.getVectorSize();\n      }\n      if (vectorSize <= 0) {\n        vectorComponent = 0;\n        vectorSize = inComponents;\n      } else {\n        if (vectorComponent < 0) {\n          vectorComponent = 0;\n        }\n        if (vectorComponent >= inComponents) {\n          vectorComponent = inComponents - 1;\n        }\n        if (vectorComponent + vectorSize > inComponents) {\n          vectorSize = inComponents - vectorComponent;\n        }\n      }\n      if (vectorMode === VectorMode.MAGNITUDE && (inComponents === 1 || vectorSize === 1)) {\n        vectorMode = VectorMode.COMPONENT;\n      }\n    }\n\n    // increment input pointer to the first component to map\n    let inputOffset = 0;\n    if (vectorComponent > 0) {\n      inputOffset = vectorComponent;\n    }\n\n    // map according to the current vector mode\n    switch (vectorMode) {\n      case VectorMode.COMPONENT:\n        {\n          publicAPI.mapScalarsThroughTable(input, output, outputFormat, inputOffset);\n          break;\n        }\n      case VectorMode.RGBCOLORS:\n        {\n          // publicAPI.mapColorsToColors(\n          //   input, output, inComponents, vectorSize,\n          //   outputFormat);\n          break;\n        }\n\n      // MAGNITUDE is considered default\n      case VectorMode.MAGNITUDE:\n      default:\n        {\n          const magValues = vtkDataArray.newInstance({\n            numberOfComponents: 1,\n            values: new Float32Array(input.getNumberOfTuples())\n          });\n          publicAPI.mapVectorsToMagnitude(input, magValues, vectorSize);\n          publicAPI.mapScalarsThroughTable(magValues, output, outputFormat, 0);\n          break;\n        }\n    }\n  };\n  publicAPI.luminanceToRGBA = (newColors, colors, alpha, convtFun) => {\n    const a = convtFun(alpha);\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 1;\n    let count = 0;\n    for (let i = component; i < size; i += tuple) {\n      const l = convtFun(values[i]);\n      newValues[count * 4] = l;\n      newValues[count * 4 + 1] = l;\n      newValues[count * 4 + 2] = l;\n      newValues[count * 4 + 3] = a;\n      count++;\n    }\n  };\n  publicAPI.luminanceAlphaToRGBA = (newColors, colors, alpha, convtFun) => {\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 2;\n    let count = 0;\n    for (let i = component; i < size; i += tuple) {\n      const l = convtFun(values[i]);\n      newValues[count] = l;\n      newValues[count + 1] = l;\n      newValues[count + 2] = l;\n      newValues[count + 3] = convtFun(values[i + 1]) * alpha;\n      count += 4;\n    }\n  };\n  publicAPI.rGBToRGBA = (newColors, colors, alpha, convtFun) => {\n    const a = floatColorToUChar(alpha);\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 3;\n    let count = 0;\n    for (let i = component; i < size; i += tuple) {\n      newValues[count * 4] = convtFun(values[i]);\n      newValues[count * 4 + 1] = convtFun(values[i + 1]);\n      newValues[count * 4 + 2] = convtFun(values[i + 2]);\n      newValues[count * 4 + 3] = a;\n      count++;\n    }\n  };\n  publicAPI.rGBAToRGBA = (newColors, colors, alpha, convtFun) => {\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 4;\n    let count = 0;\n    for (let i = component; i < size; i += tuple) {\n      newValues[count * 4] = convtFun(values[i]);\n      newValues[count * 4 + 1] = convtFun(values[i + 1]);\n      newValues[count * 4 + 2] = convtFun(values[i + 2]);\n      newValues[count * 4 + 3] = convtFun(values[i + 3]) * alpha;\n      count++;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.convertToRGBA = (colors, numComp, numTuples) => {\n    let {\n      alpha\n    } = model;\n    if (numComp === 4 && alpha >= 1.0 && colors.getDataType() === VtkDataTypes.UNSIGNED_CHAR) {\n      return colors;\n    }\n    const newColors = vtkDataArray.newInstance({\n      numberOfComponents: 4,\n      empty: true,\n      size: 4 * numTuples,\n      dataType: VtkDataTypes.UNSIGNED_CHAR\n    });\n    if (numTuples <= 0) {\n      return newColors;\n    }\n    alpha = alpha > 0 ? alpha : 0;\n    alpha = alpha < 1 ? alpha : 1;\n    let convtFun = intColorToUChar;\n    if (colors.getDataType() === VtkDataTypes.FLOAT || colors.getDataType() === VtkDataTypes.DOUBLE) {\n      convtFun = floatColorToUChar;\n    }\n    switch (numComp) {\n      case 1:\n        publicAPI.luminanceToRGBA(newColors, colors, alpha, convtFun);\n        break;\n      case 2:\n        publicAPI.luminanceAlphaToRGBA(newColors, colors, convtFun);\n        break;\n      case 3:\n        publicAPI.rGBToRGBA(newColors, colors, alpha, convtFun);\n        break;\n      case 4:\n        publicAPI.rGBAToRGBA(newColors, colors, alpha, convtFun);\n        break;\n      default:\n        vtkErrorMacro('Cannot convert colors');\n        return null;\n    }\n    return newColors;\n  };\n  publicAPI.usingLogScale = () => false;\n  publicAPI.getNumberOfAvailableColors = () => 256 * 256 * 256;\n  publicAPI.setRange = (min, max) => publicAPI.setMappingRange(min, max);\n  publicAPI.getRange = () => publicAPI.getMappingRange();\n  publicAPI.areScalarsOpaque = (scalars, colorMode, componentIn) => {\n    if (!scalars) {\n      return publicAPI.isOpaque();\n    }\n    const numberOfComponents = scalars.getNumberOfComponents();\n\n    // map scalars through lookup table only if needed\n    if (colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || colorMode === ColorMode.DIRECT_SCALARS) {\n      // we will be using the scalars directly, so look at the number of\n      // components and the range\n      if (numberOfComponents === 3 || numberOfComponents === 1) {\n        return model.alpha >= 1.0;\n      }\n      // otherwise look at the range of the alpha channel\n      const range = scalars.getRange(numberOfComponents - 1);\n      return range[0] === 255;\n    }\n    return true;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  alpha: 1.0,\n  vectorComponent: 0,\n  vectorSize: -1,\n  vectorMode: VectorMode.COMPONENT,\n  mappingRange: null,\n  annotationArray: null,\n  annotatedValueMap: null,\n  indexedLookup: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  model.mappingRange = [0, 255];\n  model.annotationArray = [];\n  model.annotatedValueMap = [];\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['vectorSize', 'vectorComponent', 'vectorMode', 'alpha', 'indexedLookup']);\n\n  // Create set macros for array (needs to know size)\n  macro.setArray(publicAPI, model, ['mappingRange'], 2);\n\n  // Create get macros for array\n  macro.getArray(publicAPI, model, ['mappingRange']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkScalarsToColors(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkScalarsToColors');\n\n// ----------------------------------------------------------------------------\n\nvar vtkScalarsToColors$1 = {\n  newInstance,\n  extend,\n  ...vtkScalarsToColors$2\n};\nexport { vtkScalarsToColors$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkDataArray","vtkScalarsToColors$2","Constants","ScalarMappingTarget","VectorMode","VtkDataTypes","ColorMode","vtkErrorMacro","intColorToUChar","c","floatColorToUChar","Math","floor","vtkScalarsToColors","publicAPI","model","classHierarchy","push","setVectorModeToMagnitude","setVectorMode","MAGNITUDE","setVectorModeToComponent","COMPONENT","setVectorModeToRGBColors","RGBCOLORS","build","isOpaque","setAnnotations","values","annotations","length","annotationArray","num","i","value","annotation","String","updateAnnotatedValueMap","modified","setAnnotation","checkForAnnotatedValue","getNumberOfAnnotatedValues","getAnnotatedValue","idx","getAnnotation","undefined","getAnnotatedValueIndex","val","removeAnnotation","needToRemove","splice","resetAnnotations","annotatedValueMap","getAnnotationColor","rgba","indexedLookup","getIndexedColor","getColor","parseFloat","getAnnotatedValueIndexInternal","na","mapScalars","scalars","colorMode","componentIn","numberOfComponents","getNumberOfComponents","newColors","DEFAULT","getDataType","UNSIGNED_CHAR","DIRECT_SCALARS","convertToRGBA","getNumberOfTuples","newscalars","type","name","dataType","s","newTypedArray","size","newInstance","component","mapVectorsThroughTable","RGBA","mapScalarsThroughTable","mapVectorsToMagnitude","input","output","compsToUse","inIncr","outputV","getData","inputV","sum","j","sqrt","outputFormat","vectorComponentIn","vectorSizeIn","vectorMode","getVectorMode","vectorSize","vectorComponent","inComponents","getVectorComponent","getVectorSize","inputOffset","magValues","Float32Array","luminanceToRGBA","colors","alpha","convtFun","a","newValues","tuple","count","l","luminanceAlphaToRGBA","rGBToRGBA","rGBAToRGBA","numComp","numTuples","empty","FLOAT","DOUBLE","usingLogScale","getNumberOfAvailableColors","setRange","min","max","setMappingRange","getRange","getMappingRange","areScalarsOpaque","range","DEFAULT_VALUES","mappingRange","extend","initialValues","arguments","Object","assign","obj","setGet","setArray","getArray","vtkScalarsToColors$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Common/Core/ScalarsToColors.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkDataArray from './DataArray.js';\nimport vtkScalarsToColors$2 from './ScalarsToColors/Constants.js';\nimport Constants from '../../Rendering/Core/Mapper/Constants.js';\n\nconst {\n  ScalarMappingTarget,\n  VectorMode\n} = vtkScalarsToColors$2;\nconst {\n  VtkDataTypes\n} = vtkDataArray;\nconst {\n  ColorMode\n} = Constants;\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n// Add module-level functions or api that you want to expose statically via\n// the next section...\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nfunction intColorToUChar(c) {\n  return c;\n}\nfunction floatColorToUChar(c) {\n  return Math.floor(c * 255.0 + 0.5);\n}\n\n// ----------------------------------------------------------------------------\n// vtkScalarsToColors methods\n// ----------------------------------------------------------------------------\n\nfunction vtkScalarsToColors(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkScalarsToColors');\n  publicAPI.setVectorModeToMagnitude = () => publicAPI.setVectorMode(VectorMode.MAGNITUDE);\n  publicAPI.setVectorModeToComponent = () => publicAPI.setVectorMode(VectorMode.COMPONENT);\n  publicAPI.setVectorModeToRGBColors = () => publicAPI.setVectorMode(VectorMode.RGBCOLORS);\n  publicAPI.build = () => {};\n  publicAPI.isOpaque = () => true;\n\n  //----------------------------------------------------------------------------\n  publicAPI.setAnnotations = (values, annotations) => {\n    if (values && !annotations || !values && annotations) {\n      return;\n    }\n    if (values && annotations && values.length !== annotations.length) {\n      vtkErrorMacro('Values and annotations do not have the same number of tuples so ignoring');\n      return;\n    }\n    model.annotationArray = [];\n    if (annotations && values) {\n      const num = annotations.length;\n      for (let i = 0; i < num; i++) {\n        model.annotationArray.push({\n          value: values[i],\n          annotation: String(annotations[i])\n        });\n      }\n    }\n    publicAPI.updateAnnotatedValueMap();\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.setAnnotation = (value, annotation) => {\n    let i = publicAPI.checkForAnnotatedValue(value);\n    let modified = false;\n    if (i >= 0) {\n      if (model.annotationArray[i].annotation !== annotation) {\n        model.annotationArray[i].annotation = annotation;\n        modified = true;\n      }\n    } else {\n      model.annotationArray.push({\n        value,\n        annotation\n      });\n      i = model.annotationArray.length - 1;\n      modified = true;\n    }\n    if (modified) {\n      publicAPI.updateAnnotatedValueMap();\n      publicAPI.modified();\n    }\n    return i;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getNumberOfAnnotatedValues = () => model.annotationArray.length;\n\n  //----------------------------------------------------------------------------\n  publicAPI.getAnnotatedValue = idx => {\n    if (idx < 0 || idx >= model.annotationArray.length) {\n      return null;\n    }\n    return model.annotationArray[idx].value;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getAnnotation = idx => {\n    if (model.annotationArray[idx] === undefined) {\n      return null;\n    }\n    return model.annotationArray[idx].annotation;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getAnnotatedValueIndex = val => model.annotationArray.length ? publicAPI.checkForAnnotatedValue(val) : -1;\n\n  //----------------------------------------------------------------------------\n  publicAPI.removeAnnotation = value => {\n    const i = publicAPI.checkForAnnotatedValue(value);\n    const needToRemove = i >= 0;\n    if (needToRemove) {\n      model.annotationArray.splice(i, 1);\n      publicAPI.updateAnnotatedValueMap();\n      publicAPI.modified();\n    }\n    return needToRemove;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.resetAnnotations = () => {\n    model.annotationArray = [];\n    model.annotatedValueMap = [];\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getAnnotationColor = (val, rgba) => {\n    if (model.indexedLookup) {\n      const i = publicAPI.getAnnotatedValueIndex(val);\n      publicAPI.getIndexedColor(i, rgba);\n    } else {\n      publicAPI.getColor(parseFloat(val), rgba);\n      rgba[3] = 1.0;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.checkForAnnotatedValue = value => publicAPI.getAnnotatedValueIndexInternal(value);\n\n  //----------------------------------------------------------------------------\n  // An unsafe version of vtkScalarsToColors::CheckForAnnotatedValue for\n  // internal use (no pointer checks performed)\n  publicAPI.getAnnotatedValueIndexInternal = value => {\n    if (model.annotatedValueMap[value] !== undefined) {\n      const na = model.annotationArray.length;\n      return model.annotatedValueMap[value] % na;\n    }\n    // Treat as a NaN\n    return -1;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getIndexedColor = (val, rgba) => {\n    rgba[0] = 0.0;\n    rgba[1] = 0.0;\n    rgba[2] = 0.0;\n    rgba[3] = 0.0;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.updateAnnotatedValueMap = () => {\n    model.annotatedValueMap = [];\n    const na = model.annotationArray.length;\n    for (let i = 0; i < na; i++) {\n      model.annotatedValueMap[model.annotationArray[i].value] = i;\n    }\n  };\n\n  // Description:\n  // Internal methods that map a data array into a 4-component,\n  // unsigned char RGBA array. The color mode determines the behavior\n  // of mapping. If ColorMode.DEFAULT is set, then unsigned char\n  // data arrays are treated as colors (and converted to RGBA if\n  // necessary); If ColorMode.DIRECT_SCALARS is set, then all arrays\n  // are treated as colors (integer types are clamped in the range 0-255,\n  // floating point arrays are clamped in the range 0.0-1.0. Note 'char' does\n  // not have enough values to represent a color so mapping this type is\n  // considered an error);\n  // otherwise, the data is mapped through this instance\n  // of ScalarsToColors. The component argument is used for data\n  // arrays with more than one component; it indicates which component\n  // to use to do the blending.  When the component argument is -1,\n  // then the this object uses its own selected technique to change a\n  // vector into a scalar to map.\n  publicAPI.mapScalars = (scalars, colorMode, componentIn) => {\n    const numberOfComponents = scalars.getNumberOfComponents();\n    let newColors = null;\n\n    // map scalars through lookup table only if needed\n    if (colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || colorMode === ColorMode.DIRECT_SCALARS && scalars) {\n      newColors = publicAPI.convertToRGBA(scalars, numberOfComponents, scalars.getNumberOfTuples());\n    } else {\n      const newscalars = {\n        type: 'vtkDataArray',\n        name: 'temp',\n        numberOfComponents: 4,\n        dataType: VtkDataTypes.UNSIGNED_CHAR\n      };\n      const s = macro.newTypedArray(newscalars.dataType, 4 * scalars.getNumberOfTuples());\n      newscalars.values = s;\n      newscalars.size = s.length;\n      newColors = vtkDataArray.newInstance(newscalars);\n      let component = componentIn;\n\n      // If mapper did not specify a component, use the VectorMode\n      if (component < 0 && numberOfComponents > 1) {\n        publicAPI.mapVectorsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, -1, -1);\n      } else {\n        if (component < 0) {\n          component = 0;\n        }\n        if (component >= numberOfComponents) {\n          component = numberOfComponents - 1;\n        }\n\n        // Map the scalars to colors\n        publicAPI.mapScalarsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, component);\n      }\n    }\n    return newColors;\n  };\n  publicAPI.mapVectorsToMagnitude = (input, output, compsToUse) => {\n    const length = input.getNumberOfTuples();\n    const inIncr = input.getNumberOfComponents();\n    const outputV = output.getData();\n    const inputV = input.getData();\n    for (let i = 0; i < length; i++) {\n      let sum = 0.0;\n      for (let j = 0; j < compsToUse; j++) {\n        sum += inputV[i * inIncr + j] * inputV[i * inIncr + j];\n      }\n      outputV[i] = Math.sqrt(sum);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  // Map a set of vector values through the table\n  publicAPI.mapVectorsThroughTable = (input, output, outputFormat, vectorComponentIn, vectorSizeIn) => {\n    let vectorMode = publicAPI.getVectorMode();\n    let vectorSize = vectorSizeIn;\n    let vectorComponent = vectorComponentIn;\n    const inComponents = input.getNumberOfComponents();\n    if (vectorMode === VectorMode.COMPONENT) {\n      // make sure vectorComponent is within allowed range\n      if (vectorComponent === -1) {\n        // if set to -1, use default value provided by table\n        vectorComponent = publicAPI.getVectorComponent();\n      }\n      if (vectorComponent < 0) {\n        vectorComponent = 0;\n      }\n      if (vectorComponent >= inComponents) {\n        vectorComponent = inComponents - 1;\n      }\n    } else {\n      // make sure vectorSize is within allowed range\n      if (vectorSize === -1) {\n        // if set to -1, use default value provided by table\n        vectorSize = publicAPI.getVectorSize();\n      }\n      if (vectorSize <= 0) {\n        vectorComponent = 0;\n        vectorSize = inComponents;\n      } else {\n        if (vectorComponent < 0) {\n          vectorComponent = 0;\n        }\n        if (vectorComponent >= inComponents) {\n          vectorComponent = inComponents - 1;\n        }\n        if (vectorComponent + vectorSize > inComponents) {\n          vectorSize = inComponents - vectorComponent;\n        }\n      }\n      if (vectorMode === VectorMode.MAGNITUDE && (inComponents === 1 || vectorSize === 1)) {\n        vectorMode = VectorMode.COMPONENT;\n      }\n    }\n\n    // increment input pointer to the first component to map\n    let inputOffset = 0;\n    if (vectorComponent > 0) {\n      inputOffset = vectorComponent;\n    }\n\n    // map according to the current vector mode\n    switch (vectorMode) {\n      case VectorMode.COMPONENT:\n        {\n          publicAPI.mapScalarsThroughTable(input, output, outputFormat, inputOffset);\n          break;\n        }\n      case VectorMode.RGBCOLORS:\n        {\n          // publicAPI.mapColorsToColors(\n          //   input, output, inComponents, vectorSize,\n          //   outputFormat);\n          break;\n        }\n\n      // MAGNITUDE is considered default\n      case VectorMode.MAGNITUDE:\n      default:\n        {\n          const magValues = vtkDataArray.newInstance({\n            numberOfComponents: 1,\n            values: new Float32Array(input.getNumberOfTuples())\n          });\n          publicAPI.mapVectorsToMagnitude(input, magValues, vectorSize);\n          publicAPI.mapScalarsThroughTable(magValues, output, outputFormat, 0);\n          break;\n        }\n    }\n  };\n  publicAPI.luminanceToRGBA = (newColors, colors, alpha, convtFun) => {\n    const a = convtFun(alpha);\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 1;\n    let count = 0;\n    for (let i = component; i < size; i += tuple) {\n      const l = convtFun(values[i]);\n      newValues[count * 4] = l;\n      newValues[count * 4 + 1] = l;\n      newValues[count * 4 + 2] = l;\n      newValues[count * 4 + 3] = a;\n      count++;\n    }\n  };\n  publicAPI.luminanceAlphaToRGBA = (newColors, colors, alpha, convtFun) => {\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 2;\n    let count = 0;\n    for (let i = component; i < size; i += tuple) {\n      const l = convtFun(values[i]);\n      newValues[count] = l;\n      newValues[count + 1] = l;\n      newValues[count + 2] = l;\n      newValues[count + 3] = convtFun(values[i + 1]) * alpha;\n      count += 4;\n    }\n  };\n  publicAPI.rGBToRGBA = (newColors, colors, alpha, convtFun) => {\n    const a = floatColorToUChar(alpha);\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 3;\n    let count = 0;\n    for (let i = component; i < size; i += tuple) {\n      newValues[count * 4] = convtFun(values[i]);\n      newValues[count * 4 + 1] = convtFun(values[i + 1]);\n      newValues[count * 4 + 2] = convtFun(values[i + 2]);\n      newValues[count * 4 + 3] = a;\n      count++;\n    }\n  };\n  publicAPI.rGBAToRGBA = (newColors, colors, alpha, convtFun) => {\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 4;\n    let count = 0;\n    for (let i = component; i < size; i += tuple) {\n      newValues[count * 4] = convtFun(values[i]);\n      newValues[count * 4 + 1] = convtFun(values[i + 1]);\n      newValues[count * 4 + 2] = convtFun(values[i + 2]);\n      newValues[count * 4 + 3] = convtFun(values[i + 3]) * alpha;\n      count++;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.convertToRGBA = (colors, numComp, numTuples) => {\n    let {\n      alpha\n    } = model;\n    if (numComp === 4 && alpha >= 1.0 && colors.getDataType() === VtkDataTypes.UNSIGNED_CHAR) {\n      return colors;\n    }\n    const newColors = vtkDataArray.newInstance({\n      numberOfComponents: 4,\n      empty: true,\n      size: 4 * numTuples,\n      dataType: VtkDataTypes.UNSIGNED_CHAR\n    });\n    if (numTuples <= 0) {\n      return newColors;\n    }\n    alpha = alpha > 0 ? alpha : 0;\n    alpha = alpha < 1 ? alpha : 1;\n    let convtFun = intColorToUChar;\n    if (colors.getDataType() === VtkDataTypes.FLOAT || colors.getDataType() === VtkDataTypes.DOUBLE) {\n      convtFun = floatColorToUChar;\n    }\n    switch (numComp) {\n      case 1:\n        publicAPI.luminanceToRGBA(newColors, colors, alpha, convtFun);\n        break;\n      case 2:\n        publicAPI.luminanceAlphaToRGBA(newColors, colors, convtFun);\n        break;\n      case 3:\n        publicAPI.rGBToRGBA(newColors, colors, alpha, convtFun);\n        break;\n      case 4:\n        publicAPI.rGBAToRGBA(newColors, colors, alpha, convtFun);\n        break;\n      default:\n        vtkErrorMacro('Cannot convert colors');\n        return null;\n    }\n    return newColors;\n  };\n  publicAPI.usingLogScale = () => false;\n  publicAPI.getNumberOfAvailableColors = () => 256 * 256 * 256;\n  publicAPI.setRange = (min, max) => publicAPI.setMappingRange(min, max);\n  publicAPI.getRange = () => publicAPI.getMappingRange();\n  publicAPI.areScalarsOpaque = (scalars, colorMode, componentIn) => {\n    if (!scalars) {\n      return publicAPI.isOpaque();\n    }\n    const numberOfComponents = scalars.getNumberOfComponents();\n\n    // map scalars through lookup table only if needed\n    if (colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || colorMode === ColorMode.DIRECT_SCALARS) {\n      // we will be using the scalars directly, so look at the number of\n      // components and the range\n      if (numberOfComponents === 3 || numberOfComponents === 1) {\n        return model.alpha >= 1.0;\n      }\n      // otherwise look at the range of the alpha channel\n      const range = scalars.getRange(numberOfComponents - 1);\n      return range[0] === 255;\n    }\n    return true;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  alpha: 1.0,\n  vectorComponent: 0,\n  vectorSize: -1,\n  vectorMode: VectorMode.COMPONENT,\n  mappingRange: null,\n  annotationArray: null,\n  annotatedValueMap: null,\n  indexedLookup: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  model.mappingRange = [0, 255];\n  model.annotationArray = [];\n  model.annotatedValueMap = [];\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['vectorSize', 'vectorComponent', 'vectorMode', 'alpha', 'indexedLookup']);\n\n  // Create set macros for array (needs to know size)\n  macro.setArray(publicAPI, model, ['mappingRange'], 2);\n\n  // Create get macros for array\n  macro.getArray(publicAPI, model, ['mappingRange']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkScalarsToColors(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkScalarsToColors');\n\n// ----------------------------------------------------------------------------\n\nvar vtkScalarsToColors$1 = {\n  newInstance,\n  extend,\n  ...vtkScalarsToColors$2\n};\n\nexport { vtkScalarsToColors$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}