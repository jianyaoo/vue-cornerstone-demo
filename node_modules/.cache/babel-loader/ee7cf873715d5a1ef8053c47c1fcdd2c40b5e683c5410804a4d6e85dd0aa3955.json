{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\n/**\n * Converts a Uint8Array to a String.\n * @param {Uint8Array} array that should be converted\n * @param {Number} offset array offset in case only subset of array items should\n                   be extracted (default: 0)\n * @param {Number} limit maximum number of array items that should be extracted\n                   (defaults to length of array)\n * @returns {String}\n */\nfunction uint8ArrayToString(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var limit = arguments.length > 2 ? arguments[2] : undefined;\n  var itemLimit = limit || arr.length - offset;\n  var str = '';\n  for (var i = offset; i < offset + itemLimit; i++) {\n    str += String.fromCharCode(arr[i]);\n  }\n  return str;\n}\n\n/**\n * Converts a String to a Uint8Array.\n * @param {String} str string that should be converted\n * @returns {Uint8Array}\n */\nfunction stringToUint8Array(str) {\n  var arr = new Uint8Array(str.length);\n  for (var i = 0, j = str.length; i < j; i++) {\n    arr[i] = str.charCodeAt(i);\n  }\n  return arr;\n}\n\n/**\n * Identifies the boundary in a multipart/related message header.\n * @param {String} header message header\n * @returns {String} boundary\n */\nfunction identifyBoundary(header) {\n  var parts = header.split('\\r\\n');\n  for (var i = 0; i < parts.length; i++) {\n    if (parts[i].substr(0, 2) === '--') {\n      return parts[i];\n    }\n  }\n  return null;\n}\n\n/**\n * Checks whether a given token is contained by a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be present\n * @param {Number} offset offset in message content from where search should start\n * @returns {Boolean} whether message contains token at offset\n */\nfunction containsToken(message, token) {\n  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (offset + token.length > message.length) {\n    return false;\n  }\n  var index = offset;\n  for (var i = 0; i < token.length; i++) {\n    if (token[i] !== message[index]) {\n      return false;\n    }\n    index += 1;\n  }\n  return true;\n}\n\n/**\n * Finds a given token in a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be found\n * @param {String} offset message body offset from where search should start\n * @returns {Boolean} whether message has a part at given offset or not\n */\nfunction findToken(message, token) {\n  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var maxSearchLength = arguments.length > 3 ? arguments[3] : undefined;\n  var searchLength = message.length;\n  if (maxSearchLength) {\n    searchLength = Math.min(offset + maxSearchLength, message.length);\n  }\n  for (var i = offset; i < searchLength; i++) {\n    // If the first value of the message matches\n    // the first value of the token, check if\n    // this is the full token.\n    if (message[i] === token[0]) {\n      if (containsToken(message, token, i)) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n\n/**\n * Create a random GUID\n *\n * @return {string}\n */\nfunction guid() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n  }\n  return \"\".concat(s4() + s4(), \"-\").concat(s4(), \"-\").concat(s4(), \"-\").concat(s4(), \"-\").concat(s4()).concat(s4()).concat(s4());\n}\n\n/**\n * @typedef {Object} MultipartEncodedData\n * @property {ArrayBuffer} data The encoded Multipart Data\n * @property {String} boundary The boundary used to divide pieces of the encoded data\n */\n\n/**\n * Encode one or more DICOM datasets into a single body so it can be\n * sent using the Multipart Content-Type.\n *\n * @param {ArrayBuffer[]} datasets Array containing each file to be encoded in the\n                          multipart body, passed as ArrayBuffers.\n * @param {String} [boundary] Optional string to define a boundary between each part\n                              of the multipart body. If this is not specified, a random\n                              GUID will be generated.\n * @return {MultipartEncodedData} The Multipart encoded data returned as an Object. This\n                                  contains both the data itself, and the boundary string\n                                  used to divide it.\n */\nfunction multipartEncode(datasets) {\n  var boundary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : guid();\n  var contentType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'application/dicom';\n  var contentTypeString = \"Content-Type: \".concat(contentType);\n  var header = \"\\r\\n--\".concat(boundary, \"\\r\\n\").concat(contentTypeString, \"\\r\\n\\r\\n\");\n  var footer = \"\\r\\n--\".concat(boundary, \"--\");\n  var headerArray = stringToUint8Array(header);\n  var footerArray = stringToUint8Array(footer);\n  var headerLength = headerArray.length;\n  var footerLength = footerArray.length;\n  var length = 0;\n\n  // Calculate the total length for the final array\n  var contentArrays = datasets.map(function (datasetBuffer) {\n    var contentArray = new Uint8Array(datasetBuffer);\n    var contentLength = contentArray.length;\n    length += headerLength + contentLength + footerLength;\n    return contentArray;\n  });\n\n  // Allocate the array\n  var multipartArray = new Uint8Array(length);\n\n  // Set the initial header\n  multipartArray.set(headerArray, 0);\n\n  // Write each dataset into the multipart array\n  var position = 0;\n  contentArrays.forEach(function (contentArray) {\n    multipartArray.set(headerArray, position);\n    multipartArray.set(contentArray, position + headerLength);\n    position += headerLength + contentArray.length;\n  });\n  multipartArray.set(footerArray, position);\n  return {\n    data: multipartArray.buffer,\n    boundary: boundary\n  };\n}\n\n/**\n * Decode a Multipart encoded ArrayBuffer and return the components as an Array.\n *\n * @param {ArrayBuffer} response Data encoded as a 'multipart/related' message\n * @returns {Array} The content\n */\nfunction multipartDecode(response) {\n  // Use the raw data if it is provided in an appropriate format\n  var message = ArrayBuffer.isView(response) ? response : new Uint8Array(response);\n\n  /* Set a maximum length to search for the header boundaries, otherwise\n       findToken can run for a long time\n    */\n  var maxSearchLength = 1000;\n\n  // First look for the multipart mime header\n  var separator = stringToUint8Array('\\r\\n\\r\\n');\n  var headerIndex = findToken(message, separator, 0, maxSearchLength);\n  if (headerIndex === -1) {\n    throw new Error('Response message has no multipart mime header');\n  }\n  var header = uint8ArrayToString(message, 0, headerIndex);\n  var boundaryString = identifyBoundary(header);\n  if (!boundaryString) {\n    throw new Error('Header of response message does not specify boundary');\n  }\n  var boundary = stringToUint8Array(boundaryString);\n  var boundaryLength = boundary.length;\n  var components = [];\n  var offset = boundaryLength;\n\n  // Loop until we cannot find any more boundaries\n  var boundaryIndex;\n  while (boundaryIndex !== -1) {\n    // Search for the next boundary in the message, starting\n    // from the current offset position\n    boundaryIndex = findToken(message, boundary, offset);\n\n    // If no further boundaries are found, stop here.\n    if (boundaryIndex === -1) {\n      break;\n    }\n    var headerTokenIndex = findToken(message, separator, offset, maxSearchLength);\n    if (headerTokenIndex === -1) {\n      throw new Error('Response message part has no mime header');\n    }\n    offset = headerTokenIndex + separator.length;\n\n    // Extract data from response message, excluding \"\\r\\n\"\n    var spacingLength = 2;\n    var data = response.slice(offset, boundaryIndex - spacingLength);\n\n    // Add the data to the array of results\n    components.push(data);\n\n    // Move the offset to the end of the current section,\n    // plus the identified boundary\n    offset = boundaryIndex + boundaryLength;\n  }\n  return components;\n}\nfunction isObject(obj) {\n  return _typeof(obj) === 'object' && obj !== null;\n}\nfunction isEmptyObject(obj) {\n  return Object.keys(obj).length === 0 && obj.constructor === Object;\n}\nfunction areValidRequestHooks(requestHooks) {\n  var isValid = Array.isArray(requestHooks) && requestHooks.every(function (requestHook) {\n    return typeof requestHook === 'function' && requestHook.length === 2;\n  });\n  if (!isValid) {\n    console.warn('Request hooks should have the following signature: ' + 'function requestHook(request, metadata) { return request; }');\n  }\n  return isValid;\n}\nvar getFirstResult = function getFirstResult(result) {\n  return result[0];\n};\nvar MEDIATYPES = {\n  DICOM: 'application/dicom',\n  DICOM_JSON: 'application/dicom+json',\n  OCTET_STREAM: 'application/octet-stream',\n  PDF: 'application/pdf',\n  JPEG: 'image/jpeg',\n  PNG: 'image/png'\n};\n\n/**\n * debugLog is a function that can be called with console.log arguments, and will\n * be conditionally displayed, only when debug logging is enabled.\n */\nvar debugLog = function debugLog() {};\n\n/**\n * @typedef { import(\"../types/types\").InstanceMetadata } InstanceMetadata\n */\n\n/**\n * A callback with the request instance and metadata information\n * of the currently request being executed that should necessarily\n * return the given request optionally modified.\n * @typedef {function} RequestHook\n * @param {XMLHttpRequest} request - The original XMLHttpRequest instance.\n * @param {object} metadata - The metadata used by the request.\n */\n\n/**\n * Class for interacting with DICOMweb RESTful services.\n */\nvar DICOMwebClient = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {Object} options\n   * @param {String} options.url - URL of the DICOMweb RESTful Service endpoint\n   * @param {String=} options.qidoURLPrefix - URL path prefix for QIDO-RS\n   * @param {String=} options.wadoURLPrefix - URL path prefix for WADO-RS\n   * @param {String=} options.stowURLPrefix - URL path prefix for STOW-RS\n   * @param {String=} options.username - Username\n   * @param {String=} options.password - Password\n   * @param {Object=} options.headers - HTTP headers\n   * @param {Array.<RequestHook>=} options.requestHooks - Request hooks.\n   * @param {Object=} options.verbose - print to console request warnings and errors, default true\n   * @param {Object=} options.debug - print to the console debug level information/status updates.\n   * @param {boolean|String} options.singlepart - retrieve singlepart for the named types.\n   * The available types are:  bulkdata, video, image.  true means all.\n   */\n  function DICOMwebClient(options) {\n    _classCallCheck(this, DICOMwebClient);\n    this.baseURL = options.url;\n    if (!this.baseURL) {\n      console.error('no DICOMweb base url provided - calls that require a URL will fail');\n    }\n    if ('username' in options) {\n      this.username = options.username;\n      if (!('password' in options)) {\n        console.error('no password provided to authenticate with DICOMweb service');\n      }\n      this.password = options.password;\n    }\n    if ('qidoURLPrefix' in options) {\n      debugLog(\"use URL prefix for QIDO-RS: \".concat(options.qidoURLPrefix));\n      this.qidoURL = \"\".concat(this.baseURL, \"/\").concat(options.qidoURLPrefix);\n    } else {\n      this.qidoURL = this.baseURL;\n    }\n    if ('wadoURLPrefix' in options) {\n      debugLog(\"use URL prefix for WADO-RS: \".concat(options.wadoURLPrefix));\n      this.wadoURL = \"\".concat(this.baseURL, \"/\").concat(options.wadoURLPrefix);\n    } else {\n      this.wadoURL = this.baseURL;\n    }\n    if ('stowURLPrefix' in options) {\n      debugLog(\"use URL prefix for STOW-RS: \".concat(options.stowURLPrefix));\n      this.stowURL = \"\".concat(this.baseURL, \"/\").concat(options.stowURLPrefix);\n    } else {\n      this.stowURL = this.baseURL;\n    }\n    if (options.singlepart) {\n      debugLog('use singlepart', options.singlepart);\n      this.singlepart = options.singlepart === true ? 'bulkdata,video,image' : options.singlepart;\n    } else {\n      this.singlepart = '';\n    }\n    if ('requestHooks' in options) {\n      this.requestHooks = options.requestHooks;\n    }\n\n    // Headers to pass to requests.\n    this.headers = options.headers || {};\n\n    // Optional error interceptor callback to handle any failed request.\n    this.errorInterceptor = options.errorInterceptor || function () {\n      return undefined;\n    };\n\n    // Verbose - print to console request warnings and errors, default true\n    this.verbose = options.verbose !== false;\n    this.setDebug(options.debug);\n  }\n\n  /**\n   * Allows setting the debug log information. \n   * Note this is different from verbose in that verbose is whether to include warning/error information, defaulting to true\n   * \n   * @param {boolean} debugLevel \n   * @param {function} debugLogFunction to call with the debug output arguments. \n   */\n  _createClass(DICOMwebClient, [{\n    key: \"setDebug\",\n    value: function setDebug() {\n      var debugLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var debugLogFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      this.debugLevel = !!debugLevel;\n      debugLog = debugLogFunction || debugLevel ? console.log : function () {};\n    }\n    /**\n     * Gets debug flag\n     * \n     * @returns true if debug logging is enabled\n     */\n  }, {\n    key: \"getDebug\",\n    value: function getDebug() {\n      return this.debugLevel;\n    }\n    /**\n     * Sets verbose flag.\n     *\n     * @param {Boolean} verbose\n     */\n  }, {\n    key: \"setVerbose\",\n    value: function setVerbose(verbose) {\n      this.verbose = verbose;\n    }\n    /**\n     * Gets verbose flag.\n     *\n     * @return {Boolean} verbose\n     */\n  }, {\n    key: \"getVerbose\",\n    value: function getVerbose() {\n      return this.verbose;\n    }\n  }, {\n    key: \"_httpRequest\",\n    /**\n     * Performs an HTTP request.\n     *\n     * @param {String} url\n     * @param {String} method\n     * @param {Object} headers\n     * @param {Object} options\n     * @param {Array.<RequestHook>} options.requestHooks - Request hooks.\n     * @param {XMLHttpRequest} [options.request] - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n     * @return {*}\n     * @private\n     */\n    value: function _httpRequest(url, method) {\n      var _this = this;\n      var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var errorInterceptor = this.errorInterceptor,\n        requestHooks = this.requestHooks;\n      return new Promise(function (resolve, reject) {\n        var request = options.request ? options.request : new XMLHttpRequest();\n        request.open(method, url, true);\n        if ('responseType' in options) {\n          request.responseType = options.responseType;\n        }\n        if (_typeof(headers) === 'object') {\n          Object.keys(headers).forEach(function (key) {\n            request.setRequestHeader(key, headers[key]);\n          });\n        }\n\n        // now add custom headers from the user\n        // (e.g. access tokens)\n        var userHeaders = _this.headers;\n        Object.keys(userHeaders).forEach(function (key) {\n          request.setRequestHeader(key, userHeaders[key]);\n        });\n\n        // Event triggered when upload starts\n        request.onloadstart = function onloadstart() {\n          debugLog('upload started: ', url);\n        };\n\n        // Event triggered when upload ends\n        request.onloadend = function onloadend() {\n          debugLog('upload finished');\n        };\n\n        // Handle response message\n        request.onreadystatechange = function () {\n          if (request.readyState === 4) {\n            if (request.status === 200) {\n              var contentType = request.getResponseHeader('Content-Type');\n              // Automatically distinguishes between multipart and singlepart in an array buffer, and\n              // converts them into a consistent type.\n              if (contentType && contentType.indexOf('multipart') !== -1) {\n                resolve(multipartDecode(request.response));\n              } else if (request.responseType === 'arraybuffer') {\n                resolve([request.response]);\n              } else {\n                resolve(request.response);\n              }\n            } else if (request.status === 202) {\n              if (_this.verbose) {\n                console.warn('some resources already existed: ', request);\n              }\n              resolve(request.response);\n            } else if (request.status === 204) {\n              if (_this.verbose) {\n                console.warn('empty response for request: ', request);\n              }\n              resolve([]);\n            } else {\n              var error = new Error('request failed');\n              error.request = request;\n              error.response = request.response;\n              error.status = request.status;\n              if (_this.verbose) {\n                console.error('request failed: ', request);\n                console.error(error);\n                console.error(error.response);\n              }\n              errorInterceptor(error);\n              reject(error);\n            }\n          }\n        };\n\n        // Event triggered while download progresses\n        if ('progressCallback' in options) {\n          if (typeof options.progressCallback === 'function') {\n            request.onprogress = options.progressCallback;\n          }\n        }\n        if (requestHooks && areValidRequestHooks(requestHooks)) {\n          var combinedHeaders = Object.assign({}, headers, _this.headers);\n          var metadata = {\n            method: method,\n            url: url,\n            headers: combinedHeaders\n          };\n          var pipeRequestHooks = function pipeRequestHooks(functions) {\n            return function (args) {\n              return functions.reduce(function (props, fn) {\n                return fn(props, metadata);\n              }, args);\n            };\n          };\n          var pipedRequest = pipeRequestHooks(requestHooks);\n          request = pipedRequest(request);\n        }\n\n        // Add withCredentials to request if needed\n        if ('withCredentials' in options) {\n          if (options.withCredentials) {\n            request.withCredentials = true;\n          }\n        }\n        if ('data' in options) {\n          request.send(options.data);\n        } else {\n          request.send();\n        }\n      });\n    }\n    /**\n     * Performs an HTTP GET request.\n     *\n     * @param {String} url\n     * @param {Object} headers\n     * @param {Object} responseType\n     * @param {Function} progressCallback\n     * @return {*}\n     * @private\n     */\n  }, {\n    key: \"_httpGet\",\n    value: function _httpGet(url, headers, responseType, progressCallback, withCredentials) {\n      return this._httpRequest(url, 'get', headers, {\n        responseType: responseType,\n        progressCallback: progressCallback,\n        withCredentials: withCredentials\n      });\n    }\n    /**\n     * Performs an HTTP GET request that accepts a message with application/json\n     * media type.\n     *\n     * @param {String} url\n     * @param {Object} params\n     * @param {Function} progressCallback\n     * @return {*}\n     * @private\n     */\n  }, {\n    key: \"_httpGetApplicationJson\",\n    value: function _httpGetApplicationJson(url) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var progressCallback = arguments.length > 2 ? arguments[2] : undefined;\n      var withCredentials = arguments.length > 3 ? arguments[3] : undefined;\n      var urlWithQueryParams = url;\n      if (_typeof(params) === 'object') {\n        if (!isEmptyObject(params)) {\n          urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n        }\n      }\n      var headers = {\n        Accept: MEDIATYPES.DICOM_JSON\n      };\n      var responseType = 'json';\n      return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback, withCredentials);\n    }\n    /**\n     * Performs an HTTP GET request that accepts a message with application/pdf\n     * media type.\n     *\n     * @param {String} url\n     * @param {Object} params\n     * @param {Function} progressCallback\n     * @return {*}\n     * @private\n     */\n  }, {\n    key: \"_httpGetApplicationPdf\",\n    value: function _httpGetApplicationPdf(url) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var progressCallback = arguments.length > 2 ? arguments[2] : undefined;\n      var withCredentials = arguments.length > 3 ? arguments[3] : undefined;\n      var urlWithQueryParams = url;\n      if (_typeof(params) === 'object') {\n        if (!isEmptyObject(params)) {\n          urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n        }\n      }\n      var headers = {\n        Accept: MEDIATYPES.PDF\n      };\n      var responseType = 'json';\n      return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback, withCredentials);\n    }\n    /**\n     * Performs an HTTP GET request that accepts a message with an image\n     media type.\n     *\n     * @param {String} url\n     * @param {Object[]} mediaTypes\n     * @param {Object} params\n     * @param {Function} progressCallback\n     * @return {*}\n     * @private\n     */\n  }, {\n    key: \"_httpGetImage\",\n    value: function _httpGetImage(url, mediaTypes) {\n      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var progressCallback = arguments.length > 3 ? arguments[3] : undefined;\n      var withCredentials = arguments.length > 4 ? arguments[4] : undefined;\n      var urlWithQueryParams = url;\n      if (_typeof(params) === 'object') {\n        if (!isEmptyObject(params)) {\n          urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n        }\n      }\n      var supportedMediaTypes = ['image/', 'image/*', 'image/jpeg', 'image/jp2', 'image/gif', 'image/png'];\n      var acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);\n      var headers = {\n        Accept: acceptHeaderFieldValue\n      };\n      var responseType = 'arraybuffer';\n      return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback, withCredentials);\n    }\n    /**\n     * Performs an HTTP GET request that accepts a message with a text\n     media type.\n     *\n     * @param {String} url\n     * @param {Object[]} mediaTypes\n     * @param {Object} params\n     * @param {Function} progressCallback\n     * @return {*}\n     * @private\n     */\n  }, {\n    key: \"_httpGetText\",\n    value: function _httpGetText(url, mediaTypes) {\n      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var progressCallback = arguments.length > 3 ? arguments[3] : undefined;\n      var withCredentials = arguments.length > 4 ? arguments[4] : undefined;\n      var urlWithQueryParams = url;\n      if (_typeof(params) === 'object') {\n        if (!isEmptyObject(params)) {\n          urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n        }\n      }\n      var supportedMediaTypes = ['text/', 'text/*', 'text/html', 'text/plain', 'text/rtf', 'text/xml'];\n      var acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);\n      var headers = {\n        Accept: acceptHeaderFieldValue\n      };\n      var responseType = 'arraybuffer';\n      return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback, withCredentials);\n    }\n    /**\n     * Performs an HTTP GET request that accepts a message with a video\n     media type.\n     *\n     * @param {String} url\n     * @param {Object[]} mediaTypes\n     * @param {Object} params\n     * @param {Function} progressCallback\n     * @return {*}\n     * @private\n     */\n  }, {\n    key: \"_httpGetVideo\",\n    value: function _httpGetVideo(url, mediaTypes) {\n      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var progressCallback = arguments.length > 3 ? arguments[3] : undefined;\n      var withCredentials = arguments.length > 4 ? arguments[4] : undefined;\n      var urlWithQueryParams = url;\n      if (_typeof(params) === 'object') {\n        if (!isEmptyObject(params)) {\n          urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n        }\n      }\n      var supportedMediaTypes = ['video/', 'video/*', 'video/mpeg', 'video/mp4', 'video/H265'];\n      var acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);\n      var headers = {\n        Accept: acceptHeaderFieldValue\n      };\n      var responseType = 'arraybuffer';\n      return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback, withCredentials);\n    }\n    /**\n     * Asserts that a given media type is valid.\n     *\n     * @params {String} mediaType media type\n     */\n  }, {\n    key: \"_httpGetMultipartImage\",\n    /**\n     * Performs an HTTP GET request that accepts a multipart message with an image media type.\n     *\n     * @param {String} url - Unique resource locator\n     * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n     corresponding transfer syntaxes\n     * @param {Array} byteRange - Start and end of byte range\n     * @param {Object} params - Additional HTTP GET query parameters\n     * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n     * @param {Function} progressCallback\n     * @private\n     * @returns {Promise<Array>} Content of HTTP message body parts\n     */\n    value: function _httpGetMultipartImage(url, mediaTypes, byteRange, params) {\n      var rendered = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var progressCallback = arguments.length > 5 ? arguments[5] : undefined;\n      var withCredentials = arguments.length > 6 ? arguments[6] : undefined;\n      var headers = {};\n      var supportedMediaTypes;\n      if (rendered) {\n        supportedMediaTypes = ['image/jpeg', 'image/gif', 'image/png', 'image/jp2'];\n      } else {\n        supportedMediaTypes = {\n          '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],\n          '1.2.840.10008.1.2.4.50': ['image/jpeg'],\n          '1.2.840.10008.1.2.4.51': ['image/jpeg'],\n          '1.2.840.10008.1.2.4.57': ['image/jpeg'],\n          '1.2.840.10008.1.2.4.70': ['image/jpeg'],\n          '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],\n          '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],\n          '1.2.840.10008.1.2.4.90': ['image/jp2'],\n          '1.2.840.10008.1.2.4.91': ['image/jp2'],\n          '1.2.840.10008.1.2.4.92': ['image/jpx'],\n          '1.2.840.10008.1.2.4.93': ['image/jpx']\n        };\n        if (byteRange) {\n          headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n        }\n      }\n      headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);\n      return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n    }\n    /**\n     * Performs an HTTP GET request that accepts a multipart message with a video media type.\n     *\n     * @param {String} url - Unique resource locator\n     * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n     corresponding transfer syntaxes\n     * @param {Array} byteRange - Start and end of byte range\n     * @param {Object} params - Additional HTTP GET query parameters\n     * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n     * @param {Function} progressCallback\n     * @private\n     * @returns {Promise<Array>} Content of HTTP message body parts\n     */\n  }, {\n    key: \"_httpGetMultipartVideo\",\n    value: function _httpGetMultipartVideo(url, mediaTypes, byteRange, params) {\n      var rendered = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var progressCallback = arguments.length > 5 ? arguments[5] : undefined;\n      var withCredentials = arguments.length > 6 ? arguments[6] : undefined;\n      var headers = {};\n      var supportedMediaTypes;\n      if (rendered) {\n        supportedMediaTypes = ['video/', 'video/*', 'video/mpeg2', 'video/mp4', 'video/H265'];\n      } else {\n        supportedMediaTypes = {\n          '1.2.840.10008.1.2.4.100': ['video/mpeg2'],\n          '1.2.840.10008.1.2.4.101': ['video/mpeg2'],\n          '1.2.840.10008.1.2.4.102': ['video/mp4'],\n          '1.2.840.10008.1.2.4.103': ['video/mp4'],\n          '1.2.840.10008.1.2.4.104': ['video/mp4'],\n          '1.2.840.10008.1.2.4.105': ['video/mp4'],\n          '1.2.840.10008.1.2.4.106': ['video/mp4']\n        };\n        if (byteRange) {\n          headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n        }\n      }\n      headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);\n      return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n    }\n    /**\n     * Performs an HTTP GET request that accepts a multipart message\n     * with a application/dicom media type.\n     *\n     * @param {String} url - Unique resource locator\n     * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n     corresponding transfer syntaxes\n     * @param {Object} params - Additional HTTP GET query parameters\n     * @param {Function} progressCallback\n     * @private\n     * @returns {Promise<Array>} Content of HTTP message body parts\n     */\n  }, {\n    key: \"_httpGetMultipartApplicationDicom\",\n    value: function _httpGetMultipartApplicationDicom(url, mediaTypes, params, progressCallback, withCredentials) {\n      var headers = {};\n      var defaultMediaType = 'application/dicom';\n      var supportedMediaTypes = {\n        '1.2.840.10008.1.2.1': [defaultMediaType],\n        '1.2.840.10008.1.2.5': [defaultMediaType],\n        '1.2.840.10008.1.2.4.50': [defaultMediaType],\n        '1.2.840.10008.1.2.4.51': [defaultMediaType],\n        '1.2.840.10008.1.2.4.57': [defaultMediaType],\n        '1.2.840.10008.1.2.4.70': [defaultMediaType],\n        '1.2.840.10008.1.2.4.80': [defaultMediaType],\n        '1.2.840.10008.1.2.4.81': [defaultMediaType],\n        '1.2.840.10008.1.2.4.90': [defaultMediaType],\n        '1.2.840.10008.1.2.4.91': [defaultMediaType],\n        '1.2.840.10008.1.2.4.92': [defaultMediaType],\n        '1.2.840.10008.1.2.4.93': [defaultMediaType],\n        '1.2.840.10008.1.2.4.100': [defaultMediaType],\n        '1.2.840.10008.1.2.4.101': [defaultMediaType],\n        '1.2.840.10008.1.2.4.102': [defaultMediaType],\n        '1.2.840.10008.1.2.4.103': [defaultMediaType],\n        '1.2.840.10008.1.2.4.104': [defaultMediaType],\n        '1.2.840.10008.1.2.4.105': [defaultMediaType],\n        '1.2.840.10008.1.2.4.106': [defaultMediaType]\n      };\n      var acceptableMediaTypes = mediaTypes;\n      if (!mediaTypes) {\n        acceptableMediaTypes = [{\n          mediaType: defaultMediaType\n        }];\n      }\n      headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(acceptableMediaTypes, supportedMediaTypes);\n      return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n    }\n    /**\n     * Performs an HTTP GET request that accepts a multipart message\n     * with a application/octet-stream, OR any of the equivalencies for that (eg\n     * application/pdf etc)\n     *\n     * @param {String} url - Unique resource locator\n     * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n     corresponding transfer syntaxes\n     * @param {Array} byteRange start and end of byte range\n     * @param {Object} params - Additional HTTP GET query parameters\n     * @param {Function} progressCallback\n     * @private\n     * @returns {Promise<Array>} Content of HTTP message body parts\n     */\n  }, {\n    key: \"_httpGetMultipartApplicationOctetStream\",\n    value: function _httpGetMultipartApplicationOctetStream(url, mediaTypes, byteRange, params, progressCallback, withCredentials) {\n      var headers = {};\n      var defaultMediaType = 'application/octet-stream';\n      var supportedMediaTypes = {\n        '1.2.840.10008.1.2.1': _toConsumableArray(Object.values(MEDIATYPES))\n      };\n      var acceptableMediaTypes = mediaTypes;\n      if (!mediaTypes) {\n        acceptableMediaTypes = [{\n          mediaType: defaultMediaType\n        }];\n      }\n      if (byteRange) {\n        headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n      }\n      headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(acceptableMediaTypes, supportedMediaTypes);\n      return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n    }\n    /**\n     * Performs an HTTP POST request.\n     *\n     * @param {String} url - Unique resource locator\n     * @param {Object} headers - HTTP header fields\n     * @param {Array} data - Data that should be stored\n     * @param {Function} progressCallback\n     * @param {Function} progressCallback\n     * @param {XMLHttpRequest} request - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n     * @private\n     * @returns {Promise} Response\n     */\n  }, {\n    key: \"_httpPost\",\n    value: function _httpPost(url, headers, data, progressCallback, withCredentials, request) {\n      return this._httpRequest(url, 'post', headers, {\n        data: data,\n        progressCallback: progressCallback,\n        withCredentials: withCredentials,\n        request: request\n      });\n    }\n    /**\n     * Performs an HTTP POST request with content-type application/dicom+json.\n     *\n     * @param {String} url - Unique resource locator\n     * @param {Object} headers - HTTP header fields\n     * @param {Array} data - Data that should be stored\n     * @param {Function} progressCallback\n     * @private\n     * @returns {Promise} Response\n     */\n  }, {\n    key: \"_httpPostApplicationJson\",\n    value: function _httpPostApplicationJson(url, data, progressCallback, withCredentials) {\n      var headers = {\n        'Content-Type': MEDIATYPES.DICOM_JSON\n      };\n      return this._httpPost(url, headers, data, progressCallback, withCredentials);\n    }\n    /**\n     * Parses media type and extracts its type and subtype.\n     *\n     * @param {String} mediaType - HTTP media type (e.g. image/jpeg)\n     * @private\n     * @returns {String[]} Media type and subtype\n     */\n  }, {\n    key: \"searchForStudies\",\n    /**\n     * Searches for DICOM studies.\n     *\n     * @param {Object} options\n     * @param {Object} [options.queryParams] - HTTP query parameters\n     * @return {Object[]} Study representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2)\n     */\n    value: function searchForStudies() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      debugLog('search for studies');\n      var withCredentials = false;\n      var url = \"\".concat(this.qidoURL, \"/studies\");\n      if ('queryParams' in options) {\n        url += DICOMwebClient._parseQueryParameters(options.queryParams);\n      }\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      return this._httpGetApplicationJson(url, {}, false, withCredentials);\n    }\n    /**\n     * Retrieves metadata for a DICOM study.\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance\n                        belonging to the study\n     */\n  }, {\n    key: \"retrieveStudyMetadata\",\n    value: function retrieveStudyMetadata(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required for retrieval of study metadata');\n      }\n      debugLog(\"retrieve metadata of study \".concat(options.studyInstanceUID));\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/metadata\");\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      return this._httpGetApplicationJson(url, {}, false, withCredentials);\n    }\n    /**\n     * Searches for DICOM series.\n     *\n     * @param {Object} options\n     * @param {Object} [options.studyInstanceUID] - Study Instance UID\n     * @param {Object} [options.queryParams] - HTTP query parameters\n     * @returns {Object[]} Series representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2a)\n     */\n  }, {\n    key: \"searchForSeries\",\n    value: function searchForSeries() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var url = this.qidoURL;\n      if ('studyInstanceUID' in options) {\n        debugLog(\"search series of study \".concat(options.studyInstanceUID));\n        url += \"/studies/\".concat(options.studyInstanceUID);\n      }\n      url += '/series';\n      if ('queryParams' in options) {\n        url += DICOMwebClient._parseQueryParameters(options.queryParams);\n      }\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      return this._httpGetApplicationJson(url, {}, false, withCredentials);\n    }\n    /**\n     * Retrieves metadata for a DICOM series.\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance\n                        belonging to the series\n     */\n  }, {\n    key: \"retrieveSeriesMetadata\",\n    value: function retrieveSeriesMetadata(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required for retrieval of series metadata');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required for retrieval of series metadata');\n      }\n      debugLog(\"retrieve metadata of series \".concat(options.seriesInstanceUID));\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/series/\").concat(options.seriesInstanceUID, \"/metadata\");\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      return this._httpGetApplicationJson(url, {}, false, withCredentials);\n    }\n    /**\n     * Searches for DICOM Instances.\n     *\n     * @param {Object} options\n     * @param {String} [options.studyInstanceUID] - Study Instance UID\n     * @param {String} [options.seriesInstanceUID] - Series Instance UID\n     * @param {Object} [options.queryParams] - HTTP query parameters\n     * @returns {Object[]} Instance representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2b)\n     */\n  }, {\n    key: \"searchForInstances\",\n    value: function searchForInstances() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var url = this.qidoURL;\n      var withCredentials = false;\n      if ('studyInstanceUID' in options) {\n        url += \"/studies/\".concat(options.studyInstanceUID);\n        if ('seriesInstanceUID' in options) {\n          debugLog(\"search for instances of series \".concat(options.seriesInstanceUID));\n          url += \"/series/\".concat(options.seriesInstanceUID);\n        } else {\n          debugLog(\"search for instances of study \".concat(options.studyInstanceUID));\n        }\n      } else {\n        debugLog('search for instances');\n      }\n      url += '/instances';\n      if ('queryParams' in options) {\n        url += DICOMwebClient._parseQueryParameters(options.queryParams);\n      }\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      return this._httpGetApplicationJson(url, {}, false, withCredentials);\n    }\n    /** Returns a WADO-URI URL for an instance\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @param {String} options.sopInstanceUID - SOP Instance UID\n     * @returns {String} WADO-URI URL\n     */\n  }, {\n    key: \"buildInstanceWadoURIUrl\",\n    value: function buildInstanceWadoURIUrl(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required.');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required.');\n      }\n      if (!('sopInstanceUID' in options)) {\n        throw new Error('SOP Instance UID is required.');\n      }\n      var contentType = options.contentType || MEDIATYPES.DICOM;\n      var transferSyntax = options.transferSyntax || '*';\n      var params = [];\n      params.push('requestType=WADO');\n      params.push(\"studyUID=\".concat(options.studyInstanceUID));\n      params.push(\"seriesUID=\".concat(options.seriesInstanceUID));\n      params.push(\"objectUID=\".concat(options.sopInstanceUID));\n      params.push(\"contentType=\".concat(contentType));\n      params.push(\"transferSyntax=\".concat(transferSyntax));\n      var paramString = params.join('&');\n      return \"\".concat(this.wadoURL, \"?\").concat(paramString);\n    }\n    /**\n     * Retrieves metadata for a DICOM Instance.\n     *\n     * @param {Object} options object\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @param {String} options.sopInstanceUID - SOP Instance UID\n     * @returns {Promise<InstanceMetadata>} metadata elements in DICOM JSON format\n     */\n  }, {\n    key: \"retrieveInstanceMetadata\",\n    value: function retrieveInstanceMetadata(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required for retrieval of instance metadata');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required for retrieval of instance metadata');\n      }\n      if (!('sopInstanceUID' in options)) {\n        throw new Error('SOP Instance UID is required for retrieval of instance metadata');\n      }\n      debugLog(\"retrieve metadata of instance \".concat(options.sopInstanceUID));\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/series/\").concat(options.seriesInstanceUID, \"/instances/\").concat(options.sopInstanceUID, \"/metadata\");\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      return this._httpGetApplicationJson(url, {}, false, withCredentials);\n    }\n    /**\n     * Retrieves frames for a DICOM Instance.\n     * @param {Object} options options object\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @param {String} options.sopInstanceUID - SOP Instance UID\n     * @param {String} options.frameNumbers - One-based indices of Frame Items\n     * @returns {Array} frame items as byte arrays of the pixel data element\n     */\n  }, {\n    key: \"retrieveInstanceFrames\",\n    value: function retrieveInstanceFrames(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required for retrieval of instance frames');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required for retrieval of instance frames');\n      }\n      if (!('sopInstanceUID' in options)) {\n        throw new Error('SOP Instance UID is required for retrieval of instance frames');\n      }\n      if (!('frameNumbers' in options)) {\n        throw new Error('frame numbers are required for retrieval of instance frames');\n      }\n      debugLog(\"retrieve frames \".concat(options.frameNumbers.toString(), \" of instance \").concat(options.sopInstanceUID));\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/series/\").concat(options.seriesInstanceUID, \"/instances/\").concat(options.sopInstanceUID, \"/frames/\").concat(options.frameNumbers.toString());\n      var mediaTypes = options.mediaTypes;\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      var progressCallback = false;\n      if ('progressCallback' in options) {\n        progressCallback = options.progressCallback;\n      }\n      if (!mediaTypes) {\n        return this._httpGetMultipartApplicationOctetStream(url, false, false, false, progressCallback, withCredentials);\n      }\n      var sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n      if (sharedMediaTypes.length > 1) {\n        /**\n         * Enable request of frames that are stored either compressed\n         * (image/* media type) or uncompressed (application/octet-stream\n         * media type).\n         */\n        var supportedMediaTypes = {\n          '1.2.840.10008.1.2.1': ['application/octet-stream'],\n          '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],\n          '1.2.840.10008.1.2.4.50': ['image/jpeg'],\n          '1.2.840.10008.1.2.4.51': ['image/jpeg'],\n          '1.2.840.10008.1.2.4.57': ['image/jpeg'],\n          '1.2.840.10008.1.2.4.70': ['image/jpeg'],\n          '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],\n          '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],\n          '1.2.840.10008.1.2.4.90': ['image/jp2'],\n          '1.2.840.10008.1.2.4.91': ['image/jp2'],\n          '1.2.840.10008.1.2.4.92': ['image/jpx'],\n          '1.2.840.10008.1.2.4.93': ['image/jpx'],\n          '1.2.840.10008.1.2.4.201': ['image/jhc'],\n          '1.2.840.10008.1.2.4.202': ['image/jhc']\n        };\n        var headers = {\n          Accept: DICOMwebClient._buildMultipartAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes)\n        };\n        return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n      }\n      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n      if (commonMediaType.startsWith('application')) {\n        return this._httpGetMultipartApplicationOctetStream(url, mediaTypes, false, false, progressCallback, withCredentials);\n      }\n      if (commonMediaType.startsWith('image')) {\n        return this._httpGetMultipartImage(url, mediaTypes, false, false, false, progressCallback, withCredentials);\n      }\n      if (commonMediaType.startsWith('video')) {\n        return this._httpGetMultipartVideo(url, mediaTypes, false, false, false, progressCallback, withCredentials);\n      }\n      throw new Error(\"Media type \".concat(commonMediaType, \" is not supported for retrieval of frames.\"));\n    }\n    /**\n    * Element in mediaTypes parameter\n    * @typedef {Object} MediaType\n    * @param {String} [MediaType.mediaType] - ie 'image/jpeg', 'image/png'...\n    */\n    /**\n     * Retrieves an individual, server-side rendered DICOM Instance.\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @param {String} options.sopInstanceUID - SOP Instance UID\n     * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n     * @param {Object} [options.queryParams] - HTTP query parameters\n     * @returns {Promise<ArrayBuffer>} Rendered DICOM Instance\n     */\n  }, {\n    key: \"retrieveInstanceRendered\",\n    value: function retrieveInstanceRendered(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required for retrieval of rendered instance');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required for retrieval of rendered instance');\n      }\n      if (!('sopInstanceUID' in options)) {\n        throw new Error('SOP Instance UID is required for retrieval of rendered instance');\n      }\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/series/\").concat(options.seriesInstanceUID, \"/instances/\").concat(options.sopInstanceUID, \"/rendered\");\n      var mediaTypes = options.mediaTypes,\n        queryParams = options.queryParams;\n      var headers = {};\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      var progressCallback = false;\n      if ('progressCallback' in options) {\n        progressCallback = options.progressCallback;\n      }\n      if (!mediaTypes) {\n        var responseType = 'arraybuffer';\n        if (queryParams) {\n          url += DICOMwebClient._parseQueryParameters(queryParams);\n        }\n        return this._httpGet(url, headers, responseType, progressCallback, withCredentials);\n      }\n      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n      if (commonMediaType.startsWith('image')) {\n        return this._httpGetImage(url, mediaTypes, queryParams, progressCallback, withCredentials);\n      }\n      if (commonMediaType.startsWith('video')) {\n        return this._httpGetVideo(url, mediaTypes, queryParams, progressCallback, withCredentials);\n      }\n      if (commonMediaType.startsWith('text')) {\n        return this._httpGetText(url, mediaTypes, queryParams, progressCallback, withCredentials);\n      }\n      if (commonMediaType === MEDIATYPES.PDF) {\n        return this._httpGetApplicationPdf(url, queryParams, progressCallback, withCredentials);\n      }\n      throw new Error(\"Media type \".concat(commonMediaType, \" is not supported \") + 'for retrieval of rendered instance.');\n    }\n    /**\n     * Retrieves a thumbnail of an DICOM Instance.\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @param {String} options.sopInstanceUID - SOP Instance UID\n     * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n     * @param {Object} [options.queryParams] - HTTP query parameters\n     * @returns {ArrayBuffer} Thumbnail\n     */\n  }, {\n    key: \"retrieveInstanceThumbnail\",\n    value: function retrieveInstanceThumbnail(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required for retrieval of rendered instance');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required for retrieval of rendered instance');\n      }\n      if (!('sopInstanceUID' in options)) {\n        throw new Error('SOP Instance UID is required for retrieval of rendered instance');\n      }\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/series/\").concat(options.seriesInstanceUID, \"/instances/\").concat(options.sopInstanceUID, \"/thumbnail\");\n      var mediaTypes = options.mediaTypes,\n        queryParams = options.queryParams;\n      var headers = {};\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      var progressCallback = false;\n      if ('progressCallback' in options) {\n        progressCallback = options.progressCallback;\n      }\n      if (!mediaTypes) {\n        var responseType = 'arraybuffer';\n        if (queryParams) {\n          url += DICOMwebClient._parseQueryParameters(queryParams);\n        }\n        return this._httpGet(url, headers, responseType, progressCallback, withCredentials);\n      }\n      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n      if (commonMediaType.startsWith('image')) {\n        return this._httpGetImage(url, mediaTypes, queryParams, progressCallback, withCredentials);\n      }\n      throw new Error(\"Media type \".concat(commonMediaType, \" is not supported \") + 'for retrieval of rendered instance.');\n    }\n    /**\n     * Retrieves rendered frames for a DICOM Instance.\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @param {String} options.sopInstanceUID - SOP Instance UID\n     * @param {String} options.frameNumbers - One-based indices of Frame Items\n     * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n     * @param {Object} [options.queryParams] - HTTP query parameters\n     * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n     */\n  }, {\n    key: \"retrieveInstanceFramesRendered\",\n    value: function retrieveInstanceFramesRendered(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required for retrieval of rendered instance frames');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required for retrieval of rendered instance frames');\n      }\n      if (!('sopInstanceUID' in options)) {\n        throw new Error('SOP Instance UID is required for retrieval of rendered instance frames');\n      }\n      if (!('frameNumbers' in options)) {\n        throw new Error('frame numbers are required for retrieval of rendered instance frames');\n      }\n      debugLog(\"retrieve rendered frames \".concat(options.frameNumbers.toString(), \" of instance \").concat(options.sopInstanceUID));\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/series/\").concat(options.seriesInstanceUID, \"/instances/\").concat(options.sopInstanceUID, \"/frames/\").concat(options.frameNumbers.toString(), \"/rendered\");\n      var mediaTypes = options.mediaTypes,\n        queryParams = options.queryParams;\n      var headers = {};\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      var progressCallback = false;\n      if ('progressCallback' in options) {\n        progressCallback = options.progressCallback;\n      }\n      if (!mediaTypes) {\n        var responseType = 'arraybuffer';\n        if (queryParams) {\n          url += DICOMwebClient._parseQueryParameters(queryParams);\n        }\n        return this._httpGet(url, headers, responseType, false, withCredentials);\n      }\n      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n      if (commonMediaType.startsWith('image')) {\n        return this._httpGetImage(url, mediaTypes, queryParams, progressCallback, withCredentials);\n      }\n      if (commonMediaType.startsWith('video')) {\n        return this._httpGetVideo(url, mediaTypes, queryParams, progressCallback, withCredentials);\n      }\n      throw new Error(\"Media type \".concat(commonMediaType, \" is not supported \") + 'for retrieval of rendered frame.');\n    }\n    /**\n     * Retrieves thumbnail of frames for a DICOM Instance.\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @param {String} options.sopInstanceUID - SOP Instance UID\n     * @param {String} options.frameNumbers - One-based indices of Frame Items\n     * @param {Object} [options.queryParams] - HTTP query parameters\n     * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n     */\n  }, {\n    key: \"retrieveInstanceFramesThumbnail\",\n    value: function retrieveInstanceFramesThumbnail(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required for retrieval of rendered instance frames');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required for retrieval of rendered instance frames');\n      }\n      if (!('sopInstanceUID' in options)) {\n        throw new Error('SOP Instance UID is required for retrieval of rendered instance frames');\n      }\n      if (!('frameNumbers' in options)) {\n        throw new Error('frame numbers are required for retrieval of rendered instance frames');\n      }\n      console.debug(\"retrieve rendered frames \".concat(options.frameNumbers.toString(), \" of instance \").concat(options.sopInstanceUID));\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/series/\").concat(options.seriesInstanceUID, \"/instances/\").concat(options.sopInstanceUID, \"/frames/\").concat(options.frameNumbers.toString(), \"/thumbnail\");\n      var mediaTypes = options.mediaTypes,\n        queryParams = options.queryParams;\n      var headers = {};\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      var progressCallback = false;\n      if ('progressCallback' in options) {\n        progressCallback = options.progressCallback;\n      }\n      if (!mediaTypes) {\n        var responseType = 'arraybuffer';\n        if (queryParams) {\n          url += DICOMwebClient._parseQueryParameters(queryParams);\n        }\n        return this._httpGet(url, headers, responseType, progressCallback, withCredentials);\n      }\n      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n      if (commonMediaType.startsWith('image')) {\n        return this._httpGetImage(url, mediaTypes, queryParams, progressCallback, withCredentials);\n      }\n      throw new Error(\"Media type \".concat(commonMediaType, \" is not supported \") + 'for retrieval of rendered frame.');\n    }\n    /**\n     * Retrieves a DICOM Instance.\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @param {String} options.sopInstanceUID - SOP Instance UID\n     * @returns {Promise<ArrayBuffer>} DICOM Part 10 file as Arraybuffer\n     */\n  }, {\n    key: \"retrieveInstance\",\n    value: function retrieveInstance(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required');\n      }\n      if (!('sopInstanceUID' in options)) {\n        throw new Error('SOP Instance UID is required');\n      }\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/series/\").concat(options.seriesInstanceUID, \"/instances/\").concat(options.sopInstanceUID);\n      var mediaTypes = options.mediaTypes;\n      var _options$withCredenti = options.withCredentials,\n        withCredentials = _options$withCredenti === void 0 ? false : _options$withCredenti;\n      var _options$progressCall = options.progressCallback,\n        progressCallback = _options$progressCall === void 0 ? false : _options$progressCall;\n      if (!mediaTypes) {\n        return this._httpGetMultipartApplicationDicom(url, false, false, progressCallback, withCredentials).then(getFirstResult);\n      }\n      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n      if (commonMediaType === MEDIATYPES.DICOM) {\n        return this._httpGetMultipartApplicationDicom(url, mediaTypes, false, progressCallback, withCredentials).then(getFirstResult);\n      }\n      throw new Error(\"Media type \".concat(commonMediaType, \" is not supported for retrieval of instance.\"));\n    }\n    /**\n     * Retrieves all DICOM Instances of a Series.\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @param {String} options.seriesInstanceUID - Series Instance UID\n     * @param {Function} options.progressCallback\n     * @returns {Promise<ArrayBuffer[]>} DICOM Instances\n     */\n  }, {\n    key: \"retrieveSeries\",\n    value: function retrieveSeries(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required');\n      }\n      if (!('seriesInstanceUID' in options)) {\n        throw new Error('Series Instance UID is required');\n      }\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID, \"/series/\").concat(options.seriesInstanceUID);\n      var mediaTypes = options.mediaTypes;\n      var withCredentials = false;\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          withCredentials = options.withCredentials;\n        }\n      }\n      var progressCallback = false;\n      if ('progressCallback' in options) {\n        progressCallback = options.progressCallback;\n      }\n      if (!mediaTypes) {\n        return this._httpGetMultipartApplicationDicom(url, false, false, progressCallback, withCredentials);\n      }\n      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n      if (commonMediaType === MEDIATYPES.DICOM) {\n        return this._httpGetMultipartApplicationDicom(url, mediaTypes, false, progressCallback, withCredentials);\n      }\n      throw new Error(\"Media type \".concat(commonMediaType, \" is not supported for retrieval of series.\"));\n    }\n    /**\n     * Retrieves all DICOM Instances of a Study.\n     *\n     * @param {Object} options\n     * @param {String} options.studyInstanceUID - Study Instance UID\n     * @returns {ArrayBuffer[]} DICOM Instances\n     */\n  }, {\n    key: \"retrieveStudy\",\n    value: function retrieveStudy(options) {\n      if (!('studyInstanceUID' in options)) {\n        throw new Error('Study Instance UID is required');\n      }\n      var url = \"\".concat(this.wadoURL, \"/studies/\").concat(options.studyInstanceUID);\n      var mediaTypes = options.mediaTypes;\n      var _options$withCredenti2 = options.withCredentials,\n        withCredentials = _options$withCredenti2 === void 0 ? false : _options$withCredenti2;\n      var _options$progressCall2 = options.progressCallback,\n        progressCallback = _options$progressCall2 === void 0 ? false : _options$progressCall2;\n      if (!mediaTypes) {\n        return this._httpGetMultipartApplicationDicom(url, false, false, progressCallback, withCredentials);\n      }\n      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n      if (commonMediaType === MEDIATYPES.DICOM) {\n        return this._httpGetMultipartApplicationDicom(url, mediaTypes, false, progressCallback, withCredentials);\n      }\n      throw new Error(\"Media type \".concat(commonMediaType, \" is not supported for retrieval of study.\"));\n    }\n    /**\n     * Retrieves and parses BulkData from a BulkDataURI location.\n     * Decodes the multipart encoded data and returns the resulting data\n     * as an ArrayBuffer.\n     *\n     * See http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.5.5.html\n     *\n     * @param {Object} options\n     * @param {string} options.BulkDataURI to retrieve\n     * @param {Array}  options.mediaTypes to use to fetch the URI\n     * @param {string} options.byteRange to request a sub-range (only valid on single part)\n     * @returns {Promise<Array>} Bulkdata parts\n     */\n  }, {\n    key: \"retrieveBulkData\",\n    value: function retrieveBulkData(options) {\n      if (!('BulkDataURI' in options)) {\n        throw new Error('BulkDataURI is required.');\n      }\n      var url = options.BulkDataURI;\n      var mediaTypes = options.mediaTypes,\n        byteRange = options.byteRange;\n      var _options$withCredenti3 = options.withCredentials,\n        withCredentials = _options$withCredenti3 === void 0 ? false : _options$withCredenti3;\n      var _options$progressCall3 = options.progressCallback,\n        progressCallback = _options$progressCall3 === void 0 ? false : _options$progressCall3;\n      if (this.singlepart.indexOf('bulkdata') !== -1) {\n        return this._httpGet(url, options.headers, 'arraybuffer', null, withCredentials);\n      }\n      if (mediaTypes) {\n        try {\n          var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n          if (commonMediaType === 'image/') {\n            return this._httpGetMultipartImage(url, mediaTypes, byteRange, false, false, progressCallback, withCredentials);\n          }\n        } catch (e) {\n          // No-op - this happens sometimes if trying to fetch the specific desired type but want to fallback to octet-stream\n        }\n      }\n\n      // Just use the media types provided\n      return this._httpGetMultipartApplicationOctetStream(url, mediaTypes, byteRange, false, progressCallback, withCredentials);\n    }\n    /**\n     * Stores DICOM Instances.\n     *\n     * @param {Object} options\n     * @param {ArrayBuffer[]} options.datasets - DICOM Instances in PS3.10 format\n     * @param {String} [options.studyInstanceUID] - Study Instance UID\n     * @param {XMLHttpRequest} [options.request] - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n     * @returns {Promise} Response message\n     */\n  }, {\n    key: \"storeInstances\",\n    value: function storeInstances(options) {\n      if (!('datasets' in options)) {\n        throw new Error('datasets are required for storing');\n      }\n      var url = \"\".concat(this.stowURL, \"/studies\");\n      if ('studyInstanceUID' in options) {\n        url += \"/\".concat(options.studyInstanceUID);\n      }\n      var _multipartEncode = multipartEncode(options.datasets),\n        data = _multipartEncode.data,\n        boundary = _multipartEncode.boundary;\n      var headers = {\n        'Content-Type': \"multipart/related; type=\\\"application/dicom\\\"; boundary=\\\"\".concat(boundary, \"\\\"\")\n      };\n      var _options$withCredenti4 = options.withCredentials,\n        withCredentials = _options$withCredenti4 === void 0 ? false : _options$withCredenti4;\n      return this._httpPost(url, headers, data, options.progressCallback, withCredentials, options.request);\n    }\n  }], [{\n    key: \"_parseQueryParameters\",\n    value: function _parseQueryParameters() {\n      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var queryString = '?';\n      Object.keys(params).forEach(function (key, index) {\n        if (index !== 0) {\n          queryString += '&';\n        }\n        queryString += \"\".concat(key, \"=\").concat(encodeURIComponent(params[key]));\n      });\n      return queryString;\n    }\n  }, {\n    key: \"_assertMediaTypeIsValid\",\n    value: function _assertMediaTypeIsValid(mediaType) {\n      if (!mediaType) {\n        throw new Error(\"Not a valid media type: \".concat(mediaType));\n      }\n      var sepIndex = mediaType.indexOf('/');\n      if (sepIndex === -1) {\n        throw new Error(\"Not a valid media type: \".concat(mediaType));\n      }\n      var mediaTypeType = mediaType.slice(0, sepIndex);\n      var types = ['application', 'image', 'text', 'video'];\n      if (!types.includes(mediaTypeType)) {\n        throw new Error(\"Not a valid media type: \".concat(mediaType));\n      }\n      if (mediaType.slice(sepIndex + 1).includes('/')) {\n        throw new Error(\"Not a valid media type: \".concat(mediaType));\n      }\n    }\n  }, {\n    key: \"_parseMediaType\",\n    value: function _parseMediaType(mediaType) {\n      DICOMwebClient._assertMediaTypeIsValid(mediaType);\n      return mediaType.split('/');\n    }\n    /**\n     * Builds an accept header field value for HTTP GET request messages.\n     *\n     * @param {Object[]} mediaTypes - Acceptable media types\n     * @param {Object[]} supportedMediaTypes - Supported media types\n     * @return {*}\n     * @private\n     */\n  }, {\n    key: \"_buildAcceptHeaderFieldValue\",\n    value: function _buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes) {\n      if (!Array.isArray(mediaTypes)) {\n        throw new Error('Acceptable media types must be provided as an Array');\n      }\n      var fieldValueParts = mediaTypes.map(function (item) {\n        var mediaType = item.mediaType;\n        DICOMwebClient._assertMediaTypeIsValid(mediaType);\n        if (!supportedMediaTypes.includes(mediaType)) {\n          throw new Error(\"Media type \".concat(mediaType, \" is not supported for requested resource\"));\n        }\n        return mediaType;\n      });\n      return fieldValueParts.join(', ');\n    }\n    /**\n     * Builds an accept header field value for HTTP GET multipart request\n     * messages.  Will throw an exception if no media types are found which are acceptable,\n     * but will only log a verbose level message when types are specified which are\n     * not acceptable.  This allows requesting several types with having to know\n     * whether they are all acceptable or not.\n     *\n     * @param {Object[]} mediaTypes - Acceptable media types\n     * @param {Object[]} supportedMediaTypes - Supported media types\n     * @private\n     */\n  }, {\n    key: \"_buildMultipartAcceptHeaderFieldValue\",\n    value: function _buildMultipartAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes) {\n      var _this2 = this;\n      if (!Array.isArray(mediaTypes)) {\n        throw new Error('Acceptable media types must be provided as an Array');\n      }\n      if (!Array.isArray(supportedMediaTypes) && !isObject(supportedMediaTypes)) {\n        throw new Error('Supported media types must be provided as an Array or an Object');\n      }\n      var fieldValueParts = [];\n      mediaTypes.forEach(function (item) {\n        var transferSyntaxUID = item.transferSyntaxUID,\n          mediaType = item.mediaType;\n        DICOMwebClient._assertMediaTypeIsValid(mediaType);\n        var fieldValue = \"multipart/related; type=\\\"\".concat(mediaType, \"\\\"\");\n        if (isObject(supportedMediaTypes)) {\n          // SupportedMediaTypes is a lookup table that maps Transfer Syntax UID\n          // to one or more Media Types\n          if (!Object.values(supportedMediaTypes).flat(1).includes(mediaType)) {\n            if (!mediaType.endsWith('/*') || !mediaType.endsWith('/')) {\n              debugLog(\"Media type \".concat(mediaType, \" is not supported for requested resource\"));\n              return;\n            }\n          }\n          if (transferSyntaxUID) {\n            if (transferSyntaxUID !== '*') {\n              if (!Object.keys(supportedMediaTypes).includes(transferSyntaxUID)) {\n                throw new Error(\"Transfer syntax \".concat(transferSyntaxUID, \" is not supported for requested resource\"));\n              }\n              var expectedMediaTypes = supportedMediaTypes[transferSyntaxUID];\n              if (!expectedMediaTypes.includes(mediaType)) {\n                var actualType = DICOMwebClient._parseMediaType(mediaType)[0];\n                expectedMediaTypes.map(function (expectedMediaType) {\n                  var expectedType = DICOMwebClient._parseMediaType(expectedMediaType)[0];\n                  var haveSameType = actualType === expectedType;\n                  if (haveSameType && (mediaType.endsWith('/*') || mediaType.endsWith('/'))) {\n                    return;\n                  }\n                  throw new Error(\"Transfer syntax \".concat(transferSyntaxUID, \" is not supported for requested resource\"));\n                });\n              }\n            }\n            fieldValue += \"; transfer-syntax=\".concat(transferSyntaxUID);\n          }\n        } else if (Array.isArray(supportedMediaTypes) && !supportedMediaTypes.includes(mediaType)) {\n          if (_this2.verbose) {\n            console.warn(\"Media type \".concat(mediaType, \" is not supported for requested resource\"));\n          }\n          return;\n        }\n        fieldValueParts.push(fieldValue);\n      });\n      if (!fieldValueParts.length) {\n        throw new Error(\"No acceptable media types found among \".concat(JSON.stringify(mediaTypes)));\n      }\n      return fieldValueParts.join(', ');\n    }\n    /**\n     * Builds a range header field value for HTTP GET request messages.\n     *\n     * @param {Array} byteRange - Start and end of byte range\n     * @returns {String} Range header field value\n     * @private\n     */\n  }, {\n    key: \"_buildRangeHeaderFieldValue\",\n    value: function _buildRangeHeaderFieldValue() {\n      var byteRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      if (byteRange.length === 1) {\n        return \"bytes=\".concat(byteRange[0], \"-\");\n      }\n      if (byteRange.length === 2) {\n        return \"bytes=\".concat(byteRange[0], \"-\").concat(byteRange[1]);\n      }\n      return 'bytes=0-';\n    }\n    /**\n     * Gets types that are shared among acceptable media types.\n     *\n     * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n     corresponding transfer syntaxes\n     * @private\n     * @returns {String[]} Types that are shared among acceptable media types\n     */\n  }, {\n    key: \"_getSharedMediaTypes\",\n    value: function _getSharedMediaTypes(mediaTypes) {\n      var types = new Set();\n      if (!mediaTypes || !mediaTypes.length) {\n        return types;\n      }\n      mediaTypes.forEach(function (item) {\n        var mediaType = item.mediaType;\n        var type = DICOMwebClient._parseMediaType(mediaType)[0];\n        types.add(\"\".concat(type, \"/\"));\n      });\n      return Array.from(types);\n    }\n    /**\n     * Gets common base type of acceptable media types and asserts that only\n     one type is specified. For example, ``(\"image/jpeg\", \"image/jp2\")``\n     will pass, but ``(\"image/jpeg\", \"video/mpeg2\")`` will raise an\n     exception.\n     *\n     * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n     corresponding transfer syntaxes\n     * @private\n     * @returns {String[]} Common media type, eg `image/` for the above example.\n     */\n  }, {\n    key: \"_getCommonMediaType\",\n    value: function _getCommonMediaType(mediaTypes) {\n      if (!mediaTypes || !mediaTypes.length) {\n        throw new Error('No acceptable media types provided');\n      }\n      var sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n      if (sharedMediaTypes.length === 0) {\n        throw new Error('No common acceptable media type could be identified.');\n      } else if (sharedMediaTypes.length > 1) {\n        throw new Error('Acceptable media types must have the same type.');\n      }\n      return sharedMediaTypes[0];\n    }\n  }]);\n  return DICOMwebClient;\n}();\nfunction findSubstring(str, before, after) {\n  var beforeIndex = str.lastIndexOf(before) + before.length;\n  if (beforeIndex < before.length) {\n    return null;\n  }\n  if (after !== undefined) {\n    var afterIndex = str.lastIndexOf(after);\n    if (afterIndex < 0) {\n      return null;\n    }\n    return str.substring(beforeIndex, afterIndex);\n  }\n  return str.substring(beforeIndex);\n}\nfunction getStudyInstanceUIDFromUri(uri) {\n  var uid = findSubstring(uri, 'studies/', '/series');\n  if (!uid) {\n    uid = findSubstring(uri, 'studies/');\n  }\n  if (!uid) {\n    console.debug(\"Study Instance UID could not be dertermined from URI \\\"\".concat(uri, \"\\\"\"));\n  }\n  return uid;\n}\nfunction getSeriesInstanceUIDFromUri(uri) {\n  var uid = findSubstring(uri, 'series/', '/instances');\n  if (!uid) {\n    uid = findSubstring(uri, 'series/');\n  }\n  if (!uid) {\n    console.debug(\"Series Instance UID could not be dertermined from URI \\\"\".concat(uri, \"\\\"\"));\n  }\n  return uid;\n}\nfunction getSOPInstanceUIDFromUri(uri) {\n  var uid = findSubstring(uri, '/instances/', '/frames');\n  if (!uid) {\n    uid = findSubstring(uri, '/instances/', '/metadata');\n  }\n  if (!uid) {\n    uid = findSubstring(uri, '/instances/');\n  }\n  if (!uid) {\n    console.debug(\"SOP Instance UID could not be dertermined from URI\\\"\".concat(uri, \"\\\"\"));\n  }\n  return uid;\n}\nfunction getFrameNumbersFromUri(uri) {\n  var numbers = findSubstring(uri, '/frames/', '/rendered');\n  if (!numbers) {\n    numbers = findSubstring(uri, '/frames/');\n  }\n  if (numbers === undefined) {\n    console.debug(\"Frame Numbers could not be dertermined from URI\\\"\".concat(uri, \"\\\"\"));\n  }\n  return numbers.split(',');\n}\nvar version = '0.5.2';\nvar api = {\n  DICOMwebClient: DICOMwebClient\n};\nvar utils = {\n  getStudyInstanceUIDFromUri: getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri: getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri: getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri: getFrameNumbersFromUri\n};\nexport { api, utils, version };","map":{"version":3,"names":["uint8ArrayToString","arr","offset","arguments","length","undefined","limit","itemLimit","str","i","String","fromCharCode","stringToUint8Array","Uint8Array","j","charCodeAt","identifyBoundary","header","parts","split","substr","containsToken","message","token","index","findToken","maxSearchLength","searchLength","Math","min","guid","s4","floor","random","toString","substring","concat","multipartEncode","datasets","boundary","contentType","contentTypeString","footer","headerArray","footerArray","headerLength","footerLength","contentArrays","map","datasetBuffer","contentArray","contentLength","multipartArray","set","position","forEach","data","buffer","multipartDecode","response","ArrayBuffer","isView","separator","headerIndex","Error","boundaryString","boundaryLength","components","boundaryIndex","headerTokenIndex","spacingLength","slice","push","isObject","obj","_typeof","isEmptyObject","Object","keys","constructor","areValidRequestHooks","requestHooks","isValid","Array","isArray","every","requestHook","console","warn","getFirstResult","result","MEDIATYPES","DICOM","DICOM_JSON","OCTET_STREAM","PDF","JPEG","PNG","debugLog","DICOMwebClient","options","_classCallCheck","baseURL","url","error","username","password","qidoURLPrefix","qidoURL","wadoURLPrefix","wadoURL","stowURLPrefix","stowURL","singlepart","headers","errorInterceptor","verbose","setDebug","debug","_createClass","key","value","debugLevel","debugLogFunction","log","getDebug","setVerbose","getVerbose","_httpRequest","method","_this","Promise","resolve","reject","request","XMLHttpRequest","open","responseType","setRequestHeader","userHeaders","onloadstart","onloadend","onreadystatechange","readyState","status","getResponseHeader","indexOf","progressCallback","onprogress","combinedHeaders","assign","metadata","pipeRequestHooks","functions","args","reduce","props","fn","pipedRequest","withCredentials","send","_httpGet","_httpGetApplicationJson","params","urlWithQueryParams","_parseQueryParameters","Accept","_httpGetApplicationPdf","_httpGetImage","mediaTypes","supportedMediaTypes","acceptHeaderFieldValue","_buildAcceptHeaderFieldValue","_httpGetText","_httpGetVideo","_httpGetMultipartImage","byteRange","rendered","Range","_buildRangeHeaderFieldValue","_buildMultipartAcceptHeaderFieldValue","_httpGetMultipartVideo","_httpGetMultipartApplicationDicom","defaultMediaType","acceptableMediaTypes","mediaType","_httpGetMultipartApplicationOctetStream","_toConsumableArray","values","_httpPost","_httpPostApplicationJson","searchForStudies","queryParams","retrieveStudyMetadata","studyInstanceUID","searchForSeries","retrieveSeriesMetadata","seriesInstanceUID","searchForInstances","buildInstanceWadoURIUrl","transferSyntax","sopInstanceUID","paramString","join","retrieveInstanceMetadata","retrieveInstanceFrames","frameNumbers","sharedMediaTypes","_getSharedMediaTypes","commonMediaType","_getCommonMediaType","startsWith","retrieveInstanceRendered","retrieveInstanceThumbnail","retrieveInstanceFramesRendered","retrieveInstanceFramesThumbnail","retrieveInstance","_options$withCredenti","_options$progressCall","then","retrieveSeries","retrieveStudy","_options$withCredenti2","_options$progressCall2","retrieveBulkData","BulkDataURI","_options$withCredenti3","_options$progressCall3","e","storeInstances","_multipartEncode","_options$withCredenti4","queryString","encodeURIComponent","_assertMediaTypeIsValid","sepIndex","mediaTypeType","types","includes","_parseMediaType","fieldValueParts","item","_this2","transferSyntaxUID","fieldValue","flat","endsWith","expectedMediaTypes","actualType","expectedMediaType","expectedType","haveSameType","JSON","stringify","Set","type","add","from","findSubstring","before","after","beforeIndex","lastIndexOf","afterIndex","getStudyInstanceUIDFromUri","uri","uid","getSeriesInstanceUIDFromUri","getSOPInstanceUIDFromUri","getFrameNumbersFromUri","numbers","version","api","utils"],"sources":["../src/message.js","../src/api.js","../src/utils.js","../src/version.js","../src/dicomweb-client.js"],"sourcesContent":["/**\n * Converts a Uint8Array to a String.\n * @param {Uint8Array} array that should be converted\n * @param {Number} offset array offset in case only subset of array items should\n                   be extracted (default: 0)\n * @param {Number} limit maximum number of array items that should be extracted\n                   (defaults to length of array)\n * @returns {String}\n */\nfunction uint8ArrayToString(arr, offset = 0, limit) {\n  const itemLimit = limit || arr.length - offset;\n  let str = '';\n  for (let i = offset; i < offset + itemLimit; i++) {\n    str += String.fromCharCode(arr[i]);\n  }\n  return str;\n}\n\n/**\n * Converts a String to a Uint8Array.\n * @param {String} str string that should be converted\n * @returns {Uint8Array}\n */\nfunction stringToUint8Array(str) {\n  const arr = new Uint8Array(str.length);\n  for (let i = 0, j = str.length; i < j; i++) {\n    arr[i] = str.charCodeAt(i);\n  }\n  return arr;\n}\n\n/**\n * Identifies the boundary in a multipart/related message header.\n * @param {String} header message header\n * @returns {String} boundary\n */\nfunction identifyBoundary(header) {\n  const parts = header.split('\\r\\n');\n\n  for (let i = 0; i < parts.length; i++) {\n    if (parts[i].substr(0, 2) === '--') {\n      return parts[i];\n    }\n  }\n\n  return null;\n}\n\n/**\n * Checks whether a given token is contained by a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be present\n * @param {Number} offset offset in message content from where search should start\n * @returns {Boolean} whether message contains token at offset\n */\nfunction containsToken(message, token, offset = 0) {\n  if (offset + token.length > message.length) {\n    return false;\n  }\n\n  let index = offset;\n  for (let i = 0; i < token.length; i++) {\n    if (token[i] !== message[index]) {\n      return false;\n    }\n\n    index += 1;\n  }\n  return true;\n}\n\n/**\n * Finds a given token in a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be found\n * @param {String} offset message body offset from where search should start\n * @returns {Boolean} whether message has a part at given offset or not\n */\nfunction findToken(message, token, offset = 0, maxSearchLength) {\n  let searchLength = message.length;\n  if (maxSearchLength) {\n    searchLength = Math.min(offset + maxSearchLength, message.length);\n  }\n\n  for (let i = offset; i < searchLength; i++) {\n    // If the first value of the message matches\n    // the first value of the token, check if\n    // this is the full token.\n    if (message[i] === token[0]) {\n      if (containsToken(message, token, i)) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Create a random GUID\n *\n * @return {string}\n */\nfunction guid() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  }\n  return `${s4() + s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;\n}\n\n/**\n * @typedef {Object} MultipartEncodedData\n * @property {ArrayBuffer} data The encoded Multipart Data\n * @property {String} boundary The boundary used to divide pieces of the encoded data\n */\n\n/**\n * Encode one or more DICOM datasets into a single body so it can be\n * sent using the Multipart Content-Type.\n *\n * @param {ArrayBuffer[]} datasets Array containing each file to be encoded in the\n                          multipart body, passed as ArrayBuffers.\n * @param {String} [boundary] Optional string to define a boundary between each part\n                              of the multipart body. If this is not specified, a random\n                              GUID will be generated.\n * @return {MultipartEncodedData} The Multipart encoded data returned as an Object. This\n                                  contains both the data itself, and the boundary string\n                                  used to divide it.\n */\nfunction multipartEncode(\n  datasets,\n  boundary = guid(),\n  contentType = 'application/dicom',\n) {\n  const contentTypeString = `Content-Type: ${contentType}`;\n  const header = `\\r\\n--${boundary}\\r\\n${contentTypeString}\\r\\n\\r\\n`;\n  const footer = `\\r\\n--${boundary}--`;\n  const headerArray = stringToUint8Array(header);\n  const footerArray = stringToUint8Array(footer);\n  const headerLength = headerArray.length;\n  const footerLength = footerArray.length;\n\n  let length = 0;\n\n  // Calculate the total length for the final array\n  const contentArrays = datasets.map(datasetBuffer => {\n    const contentArray = new Uint8Array(datasetBuffer);\n    const contentLength = contentArray.length;\n\n    length += headerLength + contentLength + footerLength;\n\n    return contentArray;\n  });\n\n  // Allocate the array\n  const multipartArray = new Uint8Array(length);\n\n  // Set the initial header\n  multipartArray.set(headerArray, 0);\n\n  // Write each dataset into the multipart array\n  let position = 0;\n  contentArrays.forEach(contentArray => {\n    multipartArray.set(headerArray, position);\n    multipartArray.set(contentArray, position + headerLength);\n\n    position += headerLength + contentArray.length;\n  });\n\n  multipartArray.set(footerArray, position);\n\n  return {\n    data: multipartArray.buffer,\n    boundary,\n  };\n}\n\n/**\n * Decode a Multipart encoded ArrayBuffer and return the components as an Array.\n *\n * @param {ArrayBuffer} response Data encoded as a 'multipart/related' message\n * @returns {Array} The content\n */\nfunction multipartDecode(response) {\n  // Use the raw data if it is provided in an appropriate format\n  const message = ArrayBuffer.isView(response) ? response : new Uint8Array(response);\n\n  /* Set a maximum length to search for the header boundaries, otherwise\n       findToken can run for a long time\n    */\n  const maxSearchLength = 1000;\n\n  // First look for the multipart mime header\n  const separator = stringToUint8Array('\\r\\n\\r\\n');\n  const headerIndex = findToken(message, separator, 0, maxSearchLength);\n  if (headerIndex === -1) {\n    throw new Error('Response message has no multipart mime header');\n  }\n\n  const header = uint8ArrayToString(message, 0, headerIndex);\n  const boundaryString = identifyBoundary(header);\n  if (!boundaryString) {\n    throw new Error('Header of response message does not specify boundary');\n  }\n\n  const boundary = stringToUint8Array(boundaryString);\n  const boundaryLength = boundary.length;\n  const components = [];\n\n  let offset = boundaryLength;\n\n  // Loop until we cannot find any more boundaries\n  let boundaryIndex;\n\n  while (boundaryIndex !== -1) {\n    // Search for the next boundary in the message, starting\n    // from the current offset position\n    boundaryIndex = findToken(message, boundary, offset);\n\n    // If no further boundaries are found, stop here.\n    if (boundaryIndex === -1) {\n      break;\n    }\n\n    const headerTokenIndex = findToken(\n      message,\n      separator,\n      offset,\n      maxSearchLength,\n    );\n    if (headerTokenIndex === -1) {\n      throw new Error('Response message part has no mime header');\n    }\n    offset = headerTokenIndex + separator.length;\n\n    // Extract data from response message, excluding \"\\r\\n\"\n    const spacingLength = 2;\n    const data = response.slice(offset, boundaryIndex - spacingLength);\n\n    // Add the data to the array of results\n    components.push(data);\n\n    // Move the offset to the end of the current section,\n    // plus the identified boundary\n    offset = boundaryIndex + boundaryLength;\n  }\n\n  return components;\n}\n\nexport {\n  containsToken,\n  findToken,\n  identifyBoundary,\n  uint8ArrayToString,\n  stringToUint8Array,\n  multipartEncode,\n  multipartDecode,\n  guid,\n};\n","import { multipartEncode, multipartDecode } from './message.js';\n\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null;\n}\n\nfunction isEmptyObject(obj) {\n  return Object.keys(obj).length === 0 && obj.constructor === Object;\n}\n\nfunction areValidRequestHooks(requestHooks) {\n  const isValid =\n    Array.isArray(requestHooks) &&\n    requestHooks.every(\n      requestHook =>\n        typeof requestHook === 'function' && requestHook.length === 2,\n    );\n\n  if (!isValid) {\n    console.warn(\n      'Request hooks should have the following signature: ' +\n        'function requestHook(request, metadata) { return request; }',\n    );\n  }\n\n  return isValid;\n}\n\nconst getFirstResult = result => result[0];\n\nconst MEDIATYPES = {\n  DICOM: 'application/dicom',\n  DICOM_JSON: 'application/dicom+json',\n  OCTET_STREAM: 'application/octet-stream',\n  PDF: 'application/pdf',\n  JPEG: 'image/jpeg',\n  PNG: 'image/png',\n};\n\n/**\n * debugLog is a function that can be called with console.log arguments, and will\n * be conditionally displayed, only when debug logging is enabled.\n */\nlet debugLog = () => {};\n\n/**\n * @typedef { import(\"../types/types\").InstanceMetadata } InstanceMetadata\n */\n\n/**\n * A callback with the request instance and metadata information\n * of the currently request being executed that should necessarily\n * return the given request optionally modified.\n * @typedef {function} RequestHook\n * @param {XMLHttpRequest} request - The original XMLHttpRequest instance.\n * @param {object} metadata - The metadata used by the request.\n */\n\n/**\n * Class for interacting with DICOMweb RESTful services.\n */\nclass DICOMwebClient {\n  /**\n   * @constructor\n   * @param {Object} options\n   * @param {String} options.url - URL of the DICOMweb RESTful Service endpoint\n   * @param {String=} options.qidoURLPrefix - URL path prefix for QIDO-RS\n   * @param {String=} options.wadoURLPrefix - URL path prefix for WADO-RS\n   * @param {String=} options.stowURLPrefix - URL path prefix for STOW-RS\n   * @param {String=} options.username - Username\n   * @param {String=} options.password - Password\n   * @param {Object=} options.headers - HTTP headers\n   * @param {Array.<RequestHook>=} options.requestHooks - Request hooks.\n   * @param {Object=} options.verbose - print to console request warnings and errors, default true\n   * @param {Object=} options.debug - print to the console debug level information/status updates.\n   * @param {boolean|String} options.singlepart - retrieve singlepart for the named types.\n   * The available types are:  bulkdata, video, image.  true means all.\n   */\n  constructor(options) {\n    this.baseURL = options.url;\n    if (!this.baseURL) {\n      console.error('no DICOMweb base url provided - calls that require a URL will fail');\n    }\n\n    if ('username' in options) {\n      this.username = options.username;\n      if (!('password' in options)) {\n        console.error(\n          'no password provided to authenticate with DICOMweb service',\n        );\n      }\n      this.password = options.password;\n    }\n\n    if ('qidoURLPrefix' in options) {\n      debugLog(`use URL prefix for QIDO-RS: ${options.qidoURLPrefix}`);\n      this.qidoURL = `${this.baseURL}/${options.qidoURLPrefix}`;\n    } else {\n      this.qidoURL = this.baseURL;\n    }\n\n    if ('wadoURLPrefix' in options) {\n      debugLog(`use URL prefix for WADO-RS: ${options.wadoURLPrefix}`);\n      this.wadoURL = `${this.baseURL}/${options.wadoURLPrefix}`;\n    } else {\n      this.wadoURL = this.baseURL;\n    }\n\n    if ('stowURLPrefix' in options) {\n      debugLog(`use URL prefix for STOW-RS: ${options.stowURLPrefix}`);\n      this.stowURL = `${this.baseURL}/${options.stowURLPrefix}`;\n    } else {\n      this.stowURL = this.baseURL;\n    }\n\n    if (options.singlepart) {\n      debugLog('use singlepart', options.singlepart);\n      this.singlepart = options.singlepart === true ? 'bulkdata,video,image' : options.singlepart;\n    } else {\n      this.singlepart = '';\n    }\n\n    if ('requestHooks' in options) {\n      this.requestHooks = options.requestHooks;\n    }\n\n    // Headers to pass to requests.\n    this.headers = options.headers || {};\n\n    // Optional error interceptor callback to handle any failed request.\n    this.errorInterceptor = options.errorInterceptor || (() => undefined);\n\n    // Verbose - print to console request warnings and errors, default true\n    this.verbose = options.verbose !== false;\n\n    this.setDebug(options.debug);\n \n\n  }\n\n  /**\n   * Allows setting the debug log information. \n   * Note this is different from verbose in that verbose is whether to include warning/error information, defaulting to true\n   * \n   * @param {boolean} debugLevel \n   * @param {function} debugLogFunction to call with the debug output arguments. \n   */\n  setDebug(debugLevel = false, debugLogFunction = null) {\n    this.debugLevel = !!debugLevel;\n    debugLog = debugLogFunction || debugLevel ? console.log : () => {};\n  }\n\n  /**\n   * Gets debug flag\n   * \n   * @returns true if debug logging is enabled\n   */\n  getDebug() {\n    return this.debugLevel;\n  }\n \n  /**\n   * Sets verbose flag.\n   *\n   * @param {Boolean} verbose\n   */\n  setVerbose(verbose) {\n    this.verbose = verbose;\n  }\n\n  /**\n   * Gets verbose flag.\n   *\n   * @return {Boolean} verbose\n   */\n  getVerbose() {\n    return this.verbose;\n  }\n\n  static _parseQueryParameters(params = {}) {\n    let queryString = '?';\n    Object.keys(params).forEach((key, index) => {\n      if (index !== 0) {\n        queryString += '&';\n      }\n      queryString += `${key}=${encodeURIComponent(params[key])}`;\n    });\n    return queryString;\n  }\n\n  /**\n   * Performs an HTTP request.\n   *\n   * @param {String} url\n   * @param {String} method\n   * @param {Object} headers\n   * @param {Object} options\n   * @param {Array.<RequestHook>} options.requestHooks - Request hooks.\n   * @param {XMLHttpRequest} [options.request] - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n   * @return {*}\n   * @private\n   */\n  _httpRequest(url, method, headers = {}, options = {}) {\n    const { errorInterceptor, requestHooks } = this;\n\n    return new Promise((resolve, reject) => {\n      let request = options.request ? options.request : new XMLHttpRequest();\n\n      request.open(method, url, true);\n      if ('responseType' in options) {\n        request.responseType = options.responseType;\n      }\n\n      if (typeof headers === 'object') {\n        Object.keys(headers).forEach(key => {\n          request.setRequestHeader(key, headers[key]);\n        });\n      }\n\n      // now add custom headers from the user\n      // (e.g. access tokens)\n      const userHeaders = this.headers;\n      Object.keys(userHeaders).forEach(key => {\n        request.setRequestHeader(key, userHeaders[key]);\n      });\n\n      // Event triggered when upload starts\n      request.onloadstart = function onloadstart() {\n        debugLog('upload started: ', url)\n      };\n\n      // Event triggered when upload ends\n      request.onloadend = function onloadend() {\n        debugLog('upload finished')\n      };\n\n      // Handle response message\n      request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n          if (request.status === 200) {\n            const contentType = request.getResponseHeader('Content-Type');\n            // Automatically distinguishes between multipart and singlepart in an array buffer, and\n            // converts them into a consistent type.\n            if (contentType && contentType.indexOf('multipart') !== -1) {\n              resolve(multipartDecode(request.response));\n            } else if (request.responseType === 'arraybuffer') {\n              resolve([request.response]);\n            } else {\n              resolve(request.response);\n            }\n          } else if (request.status === 202) {\n            if (this.verbose) {\n              console.warn('some resources already existed: ', request);\n            }\n            resolve(request.response);\n          } else if (request.status === 204) {\n            if (this.verbose) {\n              console.warn('empty response for request: ', request);\n            }\n            resolve([]);\n          } else {\n            const error = new Error('request failed');\n            error.request = request;\n            error.response = request.response;\n            error.status = request.status;\n            if (this.verbose) {\n              console.error('request failed: ', request);\n              console.error(error);\n              console.error(error.response);\n            }\n\n            errorInterceptor(error);\n\n            reject(error);\n          }\n        }\n      };\n\n      // Event triggered while download progresses\n      if ('progressCallback' in options) {\n        if (typeof options.progressCallback === 'function') {\n          request.onprogress = options.progressCallback;\n        }\n      }\n\n      if (requestHooks && areValidRequestHooks(requestHooks)) {\n        const combinedHeaders = Object.assign({}, headers, this.headers);\n        const metadata = { method, url, headers: combinedHeaders };\n        const pipeRequestHooks = functions => args =>\n          functions.reduce((props, fn) => fn(props, metadata), args);\n        const pipedRequest = pipeRequestHooks(requestHooks);\n        request = pipedRequest(request);\n      }\n\n      // Add withCredentials to request if needed\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          request.withCredentials = true;\n        }\n      }\n\n      if ('data' in options) {\n        request.send(options.data);\n      } else {\n        request.send();\n      }\n    });\n  }\n\n  /**\n   * Performs an HTTP GET request.\n   *\n   * @param {String} url\n   * @param {Object} headers\n   * @param {Object} responseType\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGet(url, headers, responseType, progressCallback, withCredentials) {\n    return this._httpRequest(url, 'get', headers, {\n      responseType,\n      progressCallback,\n      withCredentials,\n    });\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with application/json\n   * media type.\n   *\n   * @param {String} url\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetApplicationJson(url, params = {}, progressCallback, withCredentials) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n    const headers = { Accept: MEDIATYPES.DICOM_JSON };\n    const responseType = 'json';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with application/pdf\n   * media type.\n   *\n   * @param {String} url\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetApplicationPdf(url, params = {}, progressCallback, withCredentials) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n    const headers = { Accept: MEDIATYPES.PDF };\n    const responseType = 'json';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with an image\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetImage(\n    url,\n    mediaTypes,\n    params = {},\n    progressCallback,\n    withCredentials,\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'image/',\n      'image/*',\n      'image/jpeg',\n      'image/jp2',\n      'image/gif',\n      'image/png',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = 'arraybuffer';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with a text\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetText(\n    url,\n    mediaTypes,\n    params = {},\n    progressCallback,\n    withCredentials,\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'text/',\n      'text/*',\n      'text/html',\n      'text/plain',\n      'text/rtf',\n      'text/xml',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = 'arraybuffer';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with a video\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetVideo(\n    url,\n    mediaTypes,\n    params = {},\n    progressCallback,\n    withCredentials,\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'video/',\n      'video/*',\n      'video/mpeg',\n      'video/mp4',\n      'video/H265',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = 'arraybuffer';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Asserts that a given media type is valid.\n   *\n   * @params {String} mediaType media type\n   */\n  static _assertMediaTypeIsValid(mediaType) {\n    if (!mediaType) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    const sepIndex = mediaType.indexOf('/');\n    if (sepIndex === -1) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    const mediaTypeType = mediaType.slice(0, sepIndex);\n    const types = ['application', 'image', 'text', 'video'];\n    if (!types.includes(mediaTypeType)) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    if (mediaType.slice(sepIndex + 1).includes('/')) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message with an image media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange - Start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartImage(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    rendered = false,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    let supportedMediaTypes;\n    if (rendered) {\n      supportedMediaTypes = [\n        'image/jpeg',\n        'image/gif',\n        'image/png',\n        'image/jp2',\n      ];\n    } else {\n      supportedMediaTypes = {\n        '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],\n        '1.2.840.10008.1.2.4.50': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.51': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.57': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.70': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.90': ['image/jp2'],\n        '1.2.840.10008.1.2.4.91': ['image/jp2'],\n        '1.2.840.10008.1.2.4.92': ['image/jpx'],\n        '1.2.840.10008.1.2.4.93': ['image/jpx'],\n      };\n\n      if (byteRange) {\n        headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n      }\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message with a video media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange - Start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartVideo(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    rendered = false,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    let supportedMediaTypes;\n    if (rendered) {\n      supportedMediaTypes = [\n        'video/',\n        'video/*',\n        'video/mpeg2',\n        'video/mp4',\n        'video/H265',\n      ];\n    } else {\n      supportedMediaTypes = {\n        '1.2.840.10008.1.2.4.100': ['video/mpeg2'],\n        '1.2.840.10008.1.2.4.101': ['video/mpeg2'],\n        '1.2.840.10008.1.2.4.102': ['video/mp4'],\n        '1.2.840.10008.1.2.4.103': ['video/mp4'],\n        '1.2.840.10008.1.2.4.104': ['video/mp4'],\n        '1.2.840.10008.1.2.4.105': ['video/mp4'],\n        '1.2.840.10008.1.2.4.106': ['video/mp4'],\n      };\n\n      if (byteRange) {\n        headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n      }\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message\n   * with a application/dicom media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartApplicationDicom(\n    url,\n    mediaTypes,\n    params,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    const defaultMediaType = 'application/dicom';\n    const supportedMediaTypes = {\n      '1.2.840.10008.1.2.1': [defaultMediaType],\n      '1.2.840.10008.1.2.5': [defaultMediaType],\n      '1.2.840.10008.1.2.4.50': [defaultMediaType],\n      '1.2.840.10008.1.2.4.51': [defaultMediaType],\n      '1.2.840.10008.1.2.4.57': [defaultMediaType],\n      '1.2.840.10008.1.2.4.70': [defaultMediaType],\n      '1.2.840.10008.1.2.4.80': [defaultMediaType],\n      '1.2.840.10008.1.2.4.81': [defaultMediaType],\n      '1.2.840.10008.1.2.4.90': [defaultMediaType],\n      '1.2.840.10008.1.2.4.91': [defaultMediaType],\n      '1.2.840.10008.1.2.4.92': [defaultMediaType],\n      '1.2.840.10008.1.2.4.93': [defaultMediaType],\n      '1.2.840.10008.1.2.4.100': [defaultMediaType],\n      '1.2.840.10008.1.2.4.101': [defaultMediaType],\n      '1.2.840.10008.1.2.4.102': [defaultMediaType],\n      '1.2.840.10008.1.2.4.103': [defaultMediaType],\n      '1.2.840.10008.1.2.4.104': [defaultMediaType],\n      '1.2.840.10008.1.2.4.105': [defaultMediaType],\n      '1.2.840.10008.1.2.4.106': [defaultMediaType],\n    };\n\n    let acceptableMediaTypes = mediaTypes;\n    if (!mediaTypes) {\n      acceptableMediaTypes = [{ mediaType: defaultMediaType }];\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      acceptableMediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message\n   * with a application/octet-stream, OR any of the equivalencies for that (eg\n   * application/pdf etc)\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartApplicationOctetStream(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    const defaultMediaType = 'application/octet-stream';\n    const supportedMediaTypes = {\n      '1.2.840.10008.1.2.1': [...Object.values(MEDIATYPES)],\n    };\n\n    let acceptableMediaTypes = mediaTypes;\n    if (!mediaTypes) {\n      acceptableMediaTypes = [{ mediaType: defaultMediaType }];\n    }\n\n    if (byteRange) {\n      headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      acceptableMediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP POST request.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object} headers - HTTP header fields\n   * @param {Array} data - Data that should be stored\n   * @param {Function} progressCallback\n   * @param {Function} progressCallback\n   * @param {XMLHttpRequest} request - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n   * @private\n   * @returns {Promise} Response\n   */\n  _httpPost(url, headers, data, progressCallback, withCredentials, request) {\n    return this._httpRequest(url, 'post', headers, {\n      data,\n      progressCallback,\n      withCredentials,\n      request,\n    });\n  }\n\n  /**\n   * Performs an HTTP POST request with content-type application/dicom+json.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object} headers - HTTP header fields\n   * @param {Array} data - Data that should be stored\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise} Response\n   */\n  _httpPostApplicationJson(url, data, progressCallback, withCredentials) {\n    const headers = { 'Content-Type': MEDIATYPES.DICOM_JSON };\n    return this._httpPost(\n      url,\n      headers,\n      data,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Parses media type and extracts its type and subtype.\n   *\n   * @param {String} mediaType - HTTP media type (e.g. image/jpeg)\n   * @private\n   * @returns {String[]} Media type and subtype\n   */\n  static _parseMediaType(mediaType) {\n    DICOMwebClient._assertMediaTypeIsValid(mediaType);\n\n    return mediaType.split('/');\n  }\n\n  /**\n   * Builds an accept header field value for HTTP GET request messages.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types\n   * @param {Object[]} supportedMediaTypes - Supported media types\n   * @return {*}\n   * @private\n   */\n  static _buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes) {\n    if (!Array.isArray(mediaTypes)) {\n      throw new Error('Acceptable media types must be provided as an Array');\n    }\n\n    const fieldValueParts = mediaTypes.map(item => {\n      const { mediaType } = item;\n\n      DICOMwebClient._assertMediaTypeIsValid(mediaType);\n      if (!supportedMediaTypes.includes(mediaType)) {\n        throw new Error(\n          `Media type ${mediaType} is not supported for requested resource`,\n        );\n      }\n\n      return mediaType;\n    });\n\n    return fieldValueParts.join(', ');\n  }\n\n  /**\n   * Builds an accept header field value for HTTP GET multipart request\n   * messages.  Will throw an exception if no media types are found which are acceptable,\n   * but will only log a verbose level message when types are specified which are\n   * not acceptable.  This allows requesting several types with having to know\n   * whether they are all acceptable or not.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types\n   * @param {Object[]} supportedMediaTypes - Supported media types\n   * @private\n   */\n  static _buildMultipartAcceptHeaderFieldValue(\n    mediaTypes,\n    supportedMediaTypes,\n  ) {\n    if (!Array.isArray(mediaTypes)) {\n      throw new Error('Acceptable media types must be provided as an Array');\n    }\n\n    if (!Array.isArray(supportedMediaTypes) && !isObject(supportedMediaTypes)) {\n      throw new Error(\n        'Supported media types must be provided as an Array or an Object',\n      );\n    }\n\n    const fieldValueParts = [];\n\n    mediaTypes.forEach(item => {\n      const { transferSyntaxUID, mediaType } = item;\n      DICOMwebClient._assertMediaTypeIsValid(mediaType);\n      let fieldValue = `multipart/related; type=\"${mediaType}\"`;\n\n      if (isObject(supportedMediaTypes)) {\n        // SupportedMediaTypes is a lookup table that maps Transfer Syntax UID\n        // to one or more Media Types\n        if (\n          !Object.values(supportedMediaTypes)\n            .flat(1)\n            .includes(mediaType)\n        ) {\n          if (!mediaType.endsWith('/*') || !mediaType.endsWith('/')) {\n            debugLog(\n              `Media type ${mediaType} is not supported for requested resource`,\n            );\n            return;\n          }\n        }\n\n        if (transferSyntaxUID) {\n          if (transferSyntaxUID !== '*') {\n            if (!Object.keys(supportedMediaTypes).includes(transferSyntaxUID)) {\n              throw new Error(\n                `Transfer syntax ${transferSyntaxUID} is not supported for requested resource`,\n              );\n            }\n\n            const expectedMediaTypes = supportedMediaTypes[transferSyntaxUID];\n\n            if (!expectedMediaTypes.includes(mediaType)) {\n              const actualType = DICOMwebClient._parseMediaType(mediaType)[0];\n              expectedMediaTypes.map(expectedMediaType => {\n                const expectedType = DICOMwebClient._parseMediaType(\n                  expectedMediaType,\n                )[0];\n                const haveSameType = actualType === expectedType;\n\n                if (\n                  haveSameType &&\n                  (mediaType.endsWith('/*') || mediaType.endsWith('/'))\n                ) {\n                  return;\n                }\n\n                throw new Error(\n                  `Transfer syntax ${transferSyntaxUID} is not supported for requested resource`,\n                );\n              });\n            }\n          }\n\n          fieldValue += `; transfer-syntax=${transferSyntaxUID}`;\n        }\n      } else if (\n        Array.isArray(supportedMediaTypes) &&\n        !supportedMediaTypes.includes(mediaType)\n      ) {\n        if( this.verbose ) {\n          console.warn(\n            `Media type ${mediaType} is not supported for requested resource`,\n          );\n        }\n        return;\n      }\n\n      fieldValueParts.push(fieldValue);\n    });\n\n    if( !fieldValueParts.length ) {\n      throw new Error(`No acceptable media types found among ${JSON.stringify(mediaTypes)}`);\n    }\n\n    return fieldValueParts.join(', ');\n  }\n\n  /**\n   * Builds a range header field value for HTTP GET request messages.\n   *\n   * @param {Array} byteRange - Start and end of byte range\n   * @returns {String} Range header field value\n   * @private\n   */\n  static _buildRangeHeaderFieldValue(byteRange = []) {\n    if (byteRange.length === 1) {\n      return `bytes=${byteRange[0]}-`;\n    }\n    if (byteRange.length === 2) {\n      return `bytes=${byteRange[0]}-${byteRange[1]}`;\n    }\n\n    return 'bytes=0-';\n  }\n\n  /**\n   * Gets types that are shared among acceptable media types.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @private\n   * @returns {String[]} Types that are shared among acceptable media types\n   */\n  static _getSharedMediaTypes(mediaTypes) {\n    const types = new Set();\n\n    if (!mediaTypes || !mediaTypes.length) {\n      return types;\n    }\n\n    mediaTypes.forEach(item => {\n      const { mediaType } = item;\n      const type = DICOMwebClient._parseMediaType(mediaType)[0];\n      types.add(`${type}/`);\n    });\n\n    return Array.from(types);\n  }\n\n  /**\n   * Gets common base type of acceptable media types and asserts that only\n   one type is specified. For example, ``(\"image/jpeg\", \"image/jp2\")``\n   will pass, but ``(\"image/jpeg\", \"video/mpeg2\")`` will raise an\n   exception.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @private\n   * @returns {String[]} Common media type, eg `image/` for the above example.\n   */\n  static _getCommonMediaType(mediaTypes) {\n    if (!mediaTypes || !mediaTypes.length) {\n      throw new Error('No acceptable media types provided');\n    }\n\n    const sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n    if (sharedMediaTypes.length === 0) {\n      throw new Error('No common acceptable media type could be identified.');\n    } else if (sharedMediaTypes.length > 1) {\n      throw new Error('Acceptable media types must have the same type.');\n    }\n\n    return sharedMediaTypes[0];\n  }\n\n  /**\n   * Searches for DICOM studies.\n   *\n   * @param {Object} options\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @return {Object[]} Study representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2)\n   */\n  searchForStudies(options = {}) {\n    debugLog('search for studies');\n    let withCredentials = false;\n    let url = `${this.qidoURL}/studies`;\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves metadata for a DICOM study.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance\n                      belonging to the study\n   */\n  retrieveStudyMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of study metadata',\n      );\n    }\n    debugLog(`retrieve metadata of study ${options.studyInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/metadata`;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Searches for DICOM series.\n   *\n   * @param {Object} options\n   * @param {Object} [options.studyInstanceUID] - Study Instance UID\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Object[]} Series representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2a)\n   */\n  searchForSeries(options = {}) {\n    let url = this.qidoURL;\n    if ('studyInstanceUID' in options) {\n      debugLog(`search series of study ${options.studyInstanceUID}`);\n      url += `/studies/${options.studyInstanceUID}`;\n    }\n    url += '/series';\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves metadata for a DICOM series.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance\n                      belonging to the series\n   */\n  retrieveSeriesMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of series metadata',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of series metadata',\n      );\n    }\n\n    debugLog(`retrieve metadata of series ${options.seriesInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/metadata`;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Searches for DICOM Instances.\n   *\n   * @param {Object} options\n   * @param {String} [options.studyInstanceUID] - Study Instance UID\n   * @param {String} [options.seriesInstanceUID] - Series Instance UID\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Object[]} Instance representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2b)\n   */\n  searchForInstances(options = {}) {\n    let url = this.qidoURL;\n    let withCredentials = false;\n    if ('studyInstanceUID' in options) {\n      url += `/studies/${options.studyInstanceUID}`;\n      if ('seriesInstanceUID' in options) {\n        debugLog(\n          `search for instances of series ${options.seriesInstanceUID}`,\n        );\n        url += `/series/${options.seriesInstanceUID}`;\n      } else {\n        debugLog(\n          `search for instances of study ${options.studyInstanceUID}`,\n        );\n      }\n    } else {\n      debugLog('search for instances');\n    }\n    url += '/instances';\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /** Returns a WADO-URI URL for an instance\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {String} WADO-URI URL\n   */\n  buildInstanceWadoURIUrl(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required.');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required.');\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error('SOP Instance UID is required.');\n    }\n\n    const contentType = options.contentType || MEDIATYPES.DICOM;\n    const transferSyntax = options.transferSyntax || '*';\n    const params = [];\n\n    params.push('requestType=WADO');\n    params.push(`studyUID=${options.studyInstanceUID}`);\n    params.push(`seriesUID=${options.seriesInstanceUID}`);\n    params.push(`objectUID=${options.sopInstanceUID}`);\n    params.push(`contentType=${contentType}`);\n    params.push(`transferSyntax=${transferSyntax}`);\n\n    const paramString = params.join('&');\n\n    return `${this.wadoURL}?${paramString}`;\n  }\n\n  /**\n   * Retrieves metadata for a DICOM Instance.\n   *\n   * @param {Object} options object\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {Promise<InstanceMetadata>} metadata elements in DICOM JSON format\n   */\n  retrieveInstanceMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    debugLog(`retrieve metadata of instance ${options.sopInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/metadata`;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves frames for a DICOM Instance.\n   * @param {Object} options options object\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @returns {Array} frame items as byte arrays of the pixel data element\n   */\n  retrieveInstanceFrames(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of instance frames',\n      );\n    }\n    debugLog(\n      `retrieve frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}`;\n\n    const { mediaTypes } = options;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url,\n        false,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n    if (sharedMediaTypes.length > 1) {\n      /**\n       * Enable request of frames that are stored either compressed\n       * (image/* media type) or uncompressed (application/octet-stream\n       * media type).\n       */\n      const supportedMediaTypes = {\n        '1.2.840.10008.1.2.1': ['application/octet-stream'],\n        '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],\n        '1.2.840.10008.1.2.4.50': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.51': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.57': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.70': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.90': ['image/jp2'],\n        '1.2.840.10008.1.2.4.91': ['image/jp2'],\n        '1.2.840.10008.1.2.4.92': ['image/jpx'],\n        '1.2.840.10008.1.2.4.93': ['image/jpx'],\n        '1.2.840.10008.1.2.4.201': ['image/jhc'],\n        '1.2.840.10008.1.2.4.202': ['image/jhc'],\n      };\n\n      const headers = {\n        Accept: DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n          mediaTypes,\n          supportedMediaTypes,\n        ),\n      };\n      return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n\n    if (commonMediaType.startsWith('application')) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url,\n        mediaTypes,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetMultipartImage(\n        url,\n        mediaTypes,\n        false,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetMultipartVideo(\n        url,\n        mediaTypes,\n        false,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of frames.`,\n    );\n  }\n\n /**\n * Element in mediaTypes parameter\n * @typedef {Object} MediaType\n * @param {String} [MediaType.mediaType] - ie 'image/jpeg', 'image/png'...\n */\n\n  /**\n   * Retrieves an individual, server-side rendered DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Promise<ArrayBuffer>} Rendered DICOM Instance\n   */\n  retrieveInstanceRendered(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance',\n      );\n    }\n\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/rendered`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        responseType,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetVideo(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('text')) {\n      return this._httpGetText(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType === MEDIATYPES.PDF) {\n      return this._httpGetApplicationPdf(\n        url,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered instance.',\n    );\n  }\n\n  /**\n   * Retrieves a thumbnail of an DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer} Thumbnail\n   */\n  retrieveInstanceThumbnail(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance',\n      );\n    }\n\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/thumbnail`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        responseType,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered instance.',\n    );\n  }\n\n  /**\n   * Retrieves rendered frames for a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n   */\n  retrieveInstanceFramesRendered(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of rendered instance frames',\n      );\n    }\n\n    debugLog(\n      `retrieve rendered frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}/rendered`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(url, headers, responseType, false, withCredentials);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetVideo(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered frame.',\n    );\n  }\n\n  /**\n   * Retrieves thumbnail of frames for a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n   */\n  retrieveInstanceFramesThumbnail(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of rendered instance frames',\n      );\n    }\n\n    console.debug(\n      `retrieve rendered frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}/thumbnail`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        responseType,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered frame.',\n    );\n  }\n\n  /**\n   * Retrieves a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {Promise<ArrayBuffer>} DICOM Part 10 file as Arraybuffer\n   */\n  retrieveInstance(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required');\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error('SOP Instance UID is required');\n    }\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}`;\n\n    const { mediaTypes } = options;\n    const { withCredentials = false } = options;\n    const { progressCallback = false } = options;\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      ).then(getFirstResult);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        progressCallback,\n        withCredentials,\n      ).then(getFirstResult);\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of instance.`,\n    );\n  }\n\n  /**\n   * Retrieves all DICOM Instances of a Series.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {Function} options.progressCallback\n   * @returns {Promise<ArrayBuffer[]>} DICOM Instances\n   */\n  retrieveSeries(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required');\n    }\n\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}`;\n\n    const { mediaTypes } = options;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of series.`,\n    );\n  }\n\n  /**\n   * Retrieves all DICOM Instances of a Study.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @returns {ArrayBuffer[]} DICOM Instances\n   */\n  retrieveStudy(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}`;\n\n    const { mediaTypes } = options;\n    const { withCredentials = false } = options;\n    const { progressCallback = false } = options;\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of study.`,\n    );\n  }\n\n  /**\n   * Retrieves and parses BulkData from a BulkDataURI location.\n   * Decodes the multipart encoded data and returns the resulting data\n   * as an ArrayBuffer.\n   *\n   * See http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.5.5.html\n   *\n   * @param {Object} options\n   * @param {string} options.BulkDataURI to retrieve\n   * @param {Array}  options.mediaTypes to use to fetch the URI\n   * @param {string} options.byteRange to request a sub-range (only valid on single part)\n   * @returns {Promise<Array>} Bulkdata parts\n   */\n  retrieveBulkData(options) {\n    if (!('BulkDataURI' in options)) {\n      throw new Error('BulkDataURI is required.');\n    }\n\n    const url = options.BulkDataURI;\n    const { mediaTypes, byteRange } = options;\n    const { withCredentials = false } = options;\n    const { progressCallback = false } = options;\n\n    if (this.singlepart.indexOf('bulkdata') !== -1) {\n      return this._httpGet(url, options.headers, 'arraybuffer', null, withCredentials);\n    }\n\n    if (mediaTypes) {\n      try {\n        const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n\n        if (commonMediaType==='image/') {\n          return this._httpGetMultipartImage(\n            url,\n            mediaTypes,\n            byteRange,\n            false,\n            false,\n            progressCallback,\n            withCredentials,\n          );\n        }\n      } catch(e) {\n        // No-op - this happens sometimes if trying to fetch the specific desired type but want to fallback to octet-stream\n      }\n    }\n\n    // Just use the media types provided\n    return this._httpGetMultipartApplicationOctetStream(\n      url,\n      mediaTypes,\n      byteRange,\n      false,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Stores DICOM Instances.\n   *\n   * @param {Object} options\n   * @param {ArrayBuffer[]} options.datasets - DICOM Instances in PS3.10 format\n   * @param {String} [options.studyInstanceUID] - Study Instance UID\n   * @param {XMLHttpRequest} [options.request] - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n   * @returns {Promise} Response message\n   */\n  storeInstances(options) {\n    if (!('datasets' in options)) {\n      throw new Error('datasets are required for storing');\n    }\n\n    let url = `${this.stowURL}/studies`;\n    if ('studyInstanceUID' in options) {\n      url += `/${options.studyInstanceUID}`;\n    }\n\n    const { data, boundary } = multipartEncode(options.datasets);\n    const headers = {\n      'Content-Type': `multipart/related; type=\"application/dicom\"; boundary=\"${boundary}\"`,\n    };\n    const { withCredentials = false } = options;\n    return this._httpPost(\n      url,\n      headers,\n      data,\n      options.progressCallback,\n      withCredentials,\n      options.request,\n    );\n  }\n\n  \n}\n\n\nexport { DICOMwebClient };\nexport default DICOMwebClient;\n","function findSubstring(str, before, after) {\n  const beforeIndex = str.lastIndexOf(before) + before.length;\n  if (beforeIndex < before.length) {\n    return null;\n  }\n  if (after !== undefined) {\n    const afterIndex = str.lastIndexOf(after);\n    if (afterIndex < 0) {\n      return null;\n    }\n    return str.substring(beforeIndex, afterIndex);\n  }\n  return str.substring(beforeIndex);\n}\n\nfunction getStudyInstanceUIDFromUri(uri) {\n  let uid = findSubstring(uri, 'studies/', '/series');\n  if (!uid) {\n    uid = findSubstring(uri, 'studies/');\n  }\n  if (!uid) {\n    console.debug(\n      `Study Instance UID could not be dertermined from URI \"${uri}\"`,\n    );\n  }\n  return uid;\n}\n\nfunction getSeriesInstanceUIDFromUri(uri) {\n  let uid = findSubstring(uri, 'series/', '/instances');\n  if (!uid) {\n    uid = findSubstring(uri, 'series/');\n  }\n  if (!uid) {\n    console.debug(\n      `Series Instance UID could not be dertermined from URI \"${uri}\"`,\n    );\n  }\n  return uid;\n}\n\nfunction getSOPInstanceUIDFromUri(uri) {\n  let uid = findSubstring(uri, '/instances/', '/frames');\n  if (!uid) {\n    uid = findSubstring(uri, '/instances/', '/metadata');\n  }\n  if (!uid) {\n    uid = findSubstring(uri, '/instances/');\n  }\n  if (!uid) {\n    console.debug(`SOP Instance UID could not be dertermined from URI\"${uri}\"`);\n  }\n  return uid;\n}\n\n\nfunction getFrameNumbersFromUri(uri) {\n  let numbers = findSubstring(uri, '/frames/', '/rendered');\n  if (!numbers) {\n    numbers = findSubstring(uri, '/frames/');\n  }\n  if (numbers === undefined) {\n    console.debug(`Frame Numbers could not be dertermined from URI\"${uri}\"`);\n  }\n  return numbers.split(',');\n}\n\nexport {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri,\n};\n","export default '0.5.2';\n","import { DICOMwebClient } from './api.js';\nimport {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri,\n} from './utils.js';\n\nconst api = {\n  DICOMwebClient,\n};\nconst utils = {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri,\n};\n\nexport { default as version } from './version.js';\n\nexport { api, utils };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}