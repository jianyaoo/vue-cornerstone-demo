import { getEnabledElementByIds, BaseVolumeViewport, } from '@cornerstonejs/core';
import Representations from '../../../enums/SegmentationRepresentations';
import * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';
import { getToolGroup } from '../../../store/ToolGroupManager';
import { addOrUpdateVTKContourSets } from './vtkContour/addOrUpdateVTKContourSets';
import removeContourFromElement from './removeContourFromElement';
import { deleteConfigCache } from './vtkContour/contourConfigCache';
import { polySeg } from '../../../stateManagement/segmentation';
let polySegConversionInProgress = false;
function removeSegmentationRepresentation(toolGroupId, segmentationRepresentationUID, renderImmediate = false) {
    _removeContourFromToolGroupViewports(toolGroupId, segmentationRepresentationUID);
    SegmentationState.removeSegmentationRepresentation(toolGroupId, segmentationRepresentationUID);
    deleteConfigCache(segmentationRepresentationUID);
    if (renderImmediate) {
        const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();
        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);
            enabledElement.viewport.render();
        });
    }
}
async function render(viewport, representationConfig, toolGroupConfig) {
    const { segmentationId } = representationConfig;
    const segmentation = SegmentationState.getSegmentation(segmentationId);
    if (!segmentation) {
        return;
    }
    let contourData = segmentation.representationData[Representations.Contour];
    if (!contourData &&
        polySeg.canComputeRequestedRepresentation(representationConfig.segmentationRepresentationUID) &&
        !polySegConversionInProgress) {
        polySegConversionInProgress = true;
        contourData = await polySeg.computeAndAddContourRepresentation(segmentationId, {
            segmentationRepresentationUID: representationConfig.segmentationRepresentationUID,
            viewport,
        });
    }
    const { geometryIds } = contourData;
    if (!geometryIds?.length || !(viewport instanceof BaseVolumeViewport)) {
        return;
    }
    addOrUpdateVTKContourSets(viewport, geometryIds, representationConfig, toolGroupConfig);
}
function _removeContourFromToolGroupViewports(toolGroupId, segmentationRepresentationUID) {
    const toolGroup = getToolGroup(toolGroupId);
    if (toolGroup === undefined) {
        throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);
    }
    const { viewportsInfo } = toolGroup;
    for (const viewportInfo of viewportsInfo) {
        const { viewportId, renderingEngineId } = viewportInfo;
        const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);
        removeContourFromElement(enabledElement.viewport.element, segmentationRepresentationUID);
    }
}
export default {
    render,
    removeSegmentationRepresentation,
};
//# sourceMappingURL=contourDisplay.js.map