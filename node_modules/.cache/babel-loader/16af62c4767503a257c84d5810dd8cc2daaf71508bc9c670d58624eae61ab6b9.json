{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { create } from 'xmlbuilder2';\nimport { decompressSync } from 'fflate';\nimport DataAccessHelper from '../Core/DataAccessHelper.js';\nimport Base64 from '../../Common/Core/Base64.js';\nimport { m as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkStringArray from '../../Common/Core/StringArray.js';\nimport BinaryHelper from '../Core/BinaryHelper.js';\nimport '../Core/DataAccessHelper/LiteHttpDataAccessHelper.js';\n\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HttpDataAccessHelper'; // HTTP + zip\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HtmlDataAccessHelper'; // html + base64 + zip\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/JSZipDataAccessHelper'; // zip\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction findAllTags(node, tagName) {\n  return [...node.getElementsByTagName(tagName)];\n}\nfunction findFirstTag(node, tagName) {\n  return findAllTags(node, tagName)[0];\n}\nfunction parseXML(xmlStr) {\n  // see xmlbuilder2 docs on the object format\n  return create(xmlStr);\n}\nfunction extractAppendedData(buffer) {\n  // search for appended data tag\n  const prefixRegex = /^\\s*<AppendedData\\s+encoding=\"raw\">\\s*_/m;\n  const suffixRegex = /\\n\\s*<\\/AppendedData>/m;\n  return BinaryHelper.extractBinary(buffer, prefixRegex, suffixRegex);\n}\n\n// ----------------------------------------------------------------------------\n\nconst TYPED_ARRAY = {\n  Int8: Int8Array,\n  UInt8: Uint8Array,\n  Int16: Int16Array,\n  UInt16: Uint16Array,\n  Int32: Int32Array,\n  UInt32: Uint32Array,\n  Int64: Int32Array,\n  // Not supported with JavaScript will cause error in binary\n  UInt64: Uint32Array,\n  // Not supported with JavaScript will cause error in binary\n  Float32: Float32Array,\n  Float64: Float64Array\n};\n\n// ----------------------------------------------------------------------------\n\nconst TYPED_ARRAY_BYTES = {\n  Int8: 1,\n  UInt8: 1,\n  Int16: 2,\n  UInt16: 2,\n  Int32: 4,\n  UInt32: 4,\n  Int64: 8,\n  // Not supported with JavaScript will cause error in binary\n  UInt64: 8,\n  // Not supported with JavaScript will cause error in binary\n  Float32: 4,\n  Float64: 8\n};\n\n// ----------------------------------------------------------------------------\n\nfunction integer64to32(array) {\n  const maxIdx = array.length - 1; // Skip last\n  return array.filter((v, i) => i < maxIdx && i % 2 === 0);\n}\n\n// ----------------------------------------------------------------------------\n\n/**\n * Reads the data of a length-prefixed blob.\n *\n * Int64 headers and values are not supported.\n *\n * @param {Uint8Array} uint8 a uint8 view of the length-prefixed blob.\n * @param {string} dataType\n * @param {string} headerType either UInt64 or UInt32\n */\nfunction readLengthPrefixedData(uint8, dataType, headerType) {\n  if (!['UInt64', 'UInt32'].includes(headerType)) {\n    throw new Error(`Cannot handle a header type of ${headerType}`);\n  }\n  let HeaderTypedArray = TYPED_ARRAY[headerType];\n  let DataTypedArray = TYPED_ARRAY[dataType];\n  let dataFallbackTo32 = false;\n  if (headerType === 'UInt64') {\n    HeaderTypedArray = TYPED_ARRAY.UInt32;\n  }\n  if (/^U?Int64$/.test(dataType)) {\n    dataFallbackTo32 = true;\n    DataTypedArray = TYPED_ARRAY[dataType.replace('64', '32')];\n  }\n  const {\n    byteOffset\n  } = uint8;\n  const dataWordSize = TYPED_ARRAY_BYTES[dataType];\n  const headerWordSize = TYPED_ARRAY_BYTES[headerType];\n\n  // slice if offset is not word aligned\n  let header;\n  if (byteOffset % headerWordSize === 0) {\n    header = new HeaderTypedArray(uint8.buffer, byteOffset, 1);\n  } else {\n    header = new HeaderTypedArray(uint8.buffer.slice(byteOffset, byteOffset + headerWordSize));\n  }\n  const dataByteLength = Number(header[0]);\n\n  // read values\n  let values;\n  let arraySize = dataByteLength / dataWordSize;\n  if (dataFallbackTo32) {\n    // We are reading int64 data with an int32 typed array.\n    arraySize *= 2;\n  }\n\n  // slice if offset is not word aligned\n  const dataOffset = byteOffset + headerWordSize;\n  if (dataOffset % dataWordSize === 0) {\n    values = new DataTypedArray(uint8.buffer, dataOffset, arraySize);\n  } else {\n    values = new DataTypedArray(uint8.buffer.slice(dataOffset, dataOffset + dataByteLength));\n  }\n  if (dataFallbackTo32) {\n    // remove higher order 32 bits\n    values = integer64to32(values);\n  }\n  return values;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction readerHeader(uint8, headerType) {\n  // We do not handle endianness or if more than 32 bits are needed to encode the data\n  if (headerType === 'UInt64') {\n    const offset = 8;\n    let uint32 = new Uint32Array(uint8.buffer, 0, 6);\n    const nbBlocks = uint32[0];\n    const s1 = uint32[2];\n    const s2 = uint32[4];\n    const resultArray = [offset, nbBlocks, s1, s2];\n    uint32 = new Uint32Array(uint8.buffer, 3 * 8, nbBlocks * 2);\n    for (let i = 0; i < nbBlocks; i++) {\n      resultArray.push(uint32[i * 2]);\n    }\n    return resultArray;\n  }\n  // UInt32\n  let uint32 = new Uint32Array(uint8.buffer, 0, 3);\n  const offset = 4;\n  const nbBlocks = uint32[0];\n  const s1 = uint32[1];\n  const s2 = uint32[2];\n  const resultArray = [offset, nbBlocks, s1, s2];\n  uint32 = new Uint32Array(uint8.buffer, 3 * 4, nbBlocks);\n  for (let i = 0; i < nbBlocks; i++) {\n    resultArray.push(uint32[i]);\n  }\n  return resultArray;\n}\n\n// ----------------------------------------------------------------------------\n\n/**\n * Given the return value of readerHeader, return header byte length.\n */\nfunction getHeaderByteLength(header, headerType) {\n  // ignore the first number, which isn't actually part of the header.\n  const [headerWordSize] = header;\n  return (header.length - 1) * headerWordSize;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction uncompressBlock(compressedUint8, output) {\n  const uncompressedBlock = decompressSync(compressedUint8);\n  output.uint8.set(uncompressedBlock, output.offset);\n  output.offset += uncompressedBlock.length;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction decompressZLib(bytes, headerType) {\n  // ----------------------------------------------------------------------\n  // Layout of the data\n  // header[N, s1, s2, blockSize1, ..., blockSizeN], [padding???], block[compressedData], ..., block[compressedData]\n  // [header] N, s1 and s2 are uint 32 or 64 (defined by header_type=\"UInt64\" attribute on the root node)\n  // [header] s1: uncompress size of each block except the last one\n  // [header] s2: uncompress size of the last blocks\n  // [header] blockSize: size of the block in compressed space that represent to bloc to inflate in zlib. (This also give the offset to the next block)\n  // ----------------------------------------------------------------------\n\n  // Header reading: [offset, numBlocks, s1, s2]\n  const header = readerHeader(bytes, headerType);\n  const nbBlocks = header[1];\n  const s1 = header[2];\n  const s2 = header[3];\n  let dataByteLength = 0;\n  if (nbBlocks > 0) {\n    // If the last block's size is labeled as 0, that means the last block\n    // really has size header[2].\n    if (s2 === 0) {\n      dataByteLength = nbBlocks * s1;\n    } else {\n      dataByteLength = (nbBlocks - 1) * s1 + s2;\n    }\n  }\n  const buffer = new ArrayBuffer(dataByteLength);\n  const output = {\n    offset: 0,\n    uint8: new Uint8Array(buffer)\n  };\n  let offset = getHeaderByteLength(header);\n  // Starting from end of the data header, find the zlib header, which starts with 0x78.\n  // This accounts for any padding between the header and the compressed data.\n  while (offset < bytes.length && bytes[offset] !== 0x78) {\n    offset++;\n  }\n  for (let i = 0; i < nbBlocks; i++) {\n    const blockSize = header[4 + i];\n    const compressedBlock = new Uint8Array(bytes.buffer, offset, blockSize);\n    uncompressBlock(compressedBlock, output);\n    offset += blockSize;\n  }\n  return output.uint8;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction processDataArray(size, dataArrayElem, compressor, byteOrder, headerType, binaryBuffer) {\n  const dataType = dataArrayElem.getAttribute('type');\n  const name = dataArrayElem.getAttribute('Name');\n  const format = dataArrayElem.getAttribute('format'); // binary, ascii, appended\n  const numberOfComponents = Number(dataArrayElem.getAttribute('NumberOfComponents') || '1');\n  let values = null;\n  if (format === 'ascii') {\n    values = new TYPED_ARRAY[dataType](size * numberOfComponents);\n    let offset = 0;\n    dataArrayElem.firstChild.nodeValue.split(/[\\\\t \\\\n]+/).forEach(token => {\n      if (token.trim().length) {\n        values[offset++] = Number(token);\n      }\n    });\n  } else if (format === 'binary') {\n    const uint8 = new Uint8Array(Base64.toArrayBuffer(dataArrayElem.firstChild.nodeValue.trim()));\n    if (compressor === 'vtkZLibDataCompressor') {\n      const data = decompressZLib(uint8, headerType);\n      values = new TYPED_ARRAY[dataType](data.buffer);\n\n      // Handle (u)int64 hoping for no overflow...\n      if (/^U?Int64$/.test(dataType)) {\n        values = integer64to32(values);\n      }\n    } else {\n      values = new TYPED_ARRAY[dataType](uint8.buffer, TYPED_ARRAY_BYTES[headerType]);\n\n      // Handle (u)int64 hoping no overflow...\n      if (dataType.indexOf('Int64') !== -1) {\n        values = integer64to32(values);\n      }\n    }\n  } else if (format === 'appended') {\n    const offset = Number(dataArrayElem.getAttribute('offset'));\n    values = readLengthPrefixedData(new Uint8Array(binaryBuffer, offset), dataType, headerType);\n  } else {\n    console.error('Format not supported', format);\n  }\n  return {\n    name,\n    values,\n    numberOfComponents\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction decodeStringArrayFromBytes(bytes) {\n  const decoder = new TextDecoder();\n  const decoded = decoder.decode(bytes);\n\n  // strings are null-terminated\n  return decoded.split('\\x00').slice(0, -1);\n}\n\n// ----------------------------------------------------------------------------\n\nfunction processStringArray(stringArrayElem, compressor, byteOrder, headerType, binaryBuffer) {\n  const name = stringArrayElem.getAttribute('Name');\n  const format = stringArrayElem.getAttribute('format'); // binary, ascii, appended\n  const numberOfComponents = Number(stringArrayElem.getAttribute('NumberOfComponents') || '1');\n  const numberOfTuples = Number(stringArrayElem.getAttribute('NumberOfTuples') || '1');\n  const nbStrings = numberOfTuples * numberOfComponents;\n  const strings = [];\n  if (format === 'ascii') {\n    const tokens = stringArrayElem.firstChild.nodeValue.trim().split(/\\s+/);\n    let tokIdx = 0;\n    const strChars = [];\n    while (strings.length < nbStrings) {\n      const token = Number(tokens[tokIdx++]);\n      if (token === 0) {\n        strings.push(strChars.join(''));\n        strChars.length = 0;\n      } else {\n        strChars.push(String.fromCharCode(token));\n      }\n    }\n  } else if (format === 'binary') {\n    const uint8 = new Uint8Array(Base64.toArrayBuffer(stringArrayElem.firstChild.nodeValue.trim()));\n    if (compressor === 'vtkZLibDataCompressor') {\n      const decompressed = decompressZLib(uint8, headerType);\n      strings.push(...decodeStringArrayFromBytes(decompressed));\n    } else {\n      const strData = readLengthPrefixedData(uint8, 'UInt8', headerType);\n      strings.push(...decodeStringArrayFromBytes(strData));\n    }\n  } else if (format === 'appended') {\n    const offset = Number(stringArrayElem.getAttribute('offset'));\n    const values = readLengthPrefixedData(new Uint8Array(binaryBuffer, offset), 'UInt8', headerType);\n    strings.push(...decodeStringArrayFromBytes(values));\n  } else {\n    macro.vtkErrorMacro(`Format not supported: ${format}`);\n  }\n  return {\n    name,\n    values: strings,\n    numberOfComponents\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction processCells(size, containerElem, compressor, byteOrder, headerType, binaryBuffer) {\n  const arrayElems = {};\n  const dataArrayElems = containerElem.getElementsByTagName('DataArray');\n  for (let elIdx = 0; elIdx < dataArrayElems.length; elIdx++) {\n    const el = dataArrayElems[elIdx];\n    arrayElems[el.getAttribute('Name')] = el;\n  }\n  const offsets = processDataArray(size, arrayElems.offsets, compressor, byteOrder, headerType, binaryBuffer).values;\n  const connectivitySize = offsets[offsets.length - 1];\n  const connectivity = processDataArray(connectivitySize, arrayElems.connectivity, compressor, byteOrder, headerType, binaryBuffer).values;\n  const values = new Uint32Array(size + connectivitySize);\n  let writeOffset = 0;\n  let previousOffset = 0;\n  offsets.forEach(v => {\n    const cellSize = v - previousOffset;\n    values[writeOffset++] = cellSize;\n    for (let i = 0; i < cellSize; i++) {\n      values[writeOffset++] = connectivity[previousOffset + i];\n    }\n\n    // save previous offset\n    previousOffset = v;\n  });\n  return values;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction processFieldData(size, fieldElem, fieldContainer, compressor, byteOrder, headerType, binaryBuffer) {\n  if (fieldElem) {\n    const attributes = ['Scalars', 'Vectors', 'Normals', 'Tensors', 'TCoords'];\n    const nameBinding = {};\n    attributes.forEach(attrName => {\n      const arrayName = fieldElem.getAttribute(attrName);\n      if (arrayName) {\n        nameBinding[arrayName] = fieldContainer[`set${attrName}`];\n      }\n    });\n    const dataArrayElems = fieldElem.getElementsByTagName('DataArray');\n    const nbArrays = dataArrayElems.length;\n    for (let idx = 0; idx < nbArrays; idx++) {\n      const array = dataArrayElems[idx];\n      const dataArray = vtkDataArray.newInstance(processDataArray(size, array, compressor, byteOrder, headerType, binaryBuffer));\n      const name = dataArray.getName();\n      (nameBinding[name] || fieldContainer.addArray)(dataArray);\n    }\n  }\n}\n\n// ----------------------------------------------------------------------------\nfunction handleFieldDataArrays(fieldDataElem, compressor, byteOrder, headerType, binaryBuffer) {\n  const dataArrays = [...fieldDataElem.getElementsByTagName('DataArray')].map(daElem => vtkDataArray.newInstance(processDataArray(Number(daElem.getAttribute('NumberOfTuples')), daElem, compressor, byteOrder, headerType, binaryBuffer)));\n  const stringArrays = [...fieldDataElem.getElementsByTagName('Array')].filter(elem => elem.getAttribute('type') === 'String').map(arrElem => {\n    const sa = vtkStringArray.newInstance(processStringArray(arrElem, compressor, byteOrder, headerType, binaryBuffer));\n    return sa;\n  });\n  return [...dataArrays, ...stringArrays];\n}\n\n// ----------------------------------------------------------------------------\n// vtkXMLReader methods\n// ----------------------------------------------------------------------------\n\nfunction vtkXMLReader(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkXMLReader');\n\n  // Create default dataAccessHelper if not available\n  if (!model.dataAccessHelper) {\n    model.dataAccessHelper = DataAccessHelper.get('http');\n  }\n\n  // Internal method to fetch Array\n  function fetchData(url) {\n    let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return model.dataAccessHelper.fetchBinary(url, option);\n  }\n\n  // Set DataSet url\n  publicAPI.setUrl = function (url) {\n    let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    model.url = url;\n\n    // Remove the file in the URL\n    const path = url.split('/');\n    path.pop();\n    model.baseURL = path.join('/');\n\n    // Fetch metadata\n    return publicAPI.loadData(option);\n  };\n\n  // Fetch the actual data arrays\n  publicAPI.loadData = function () {\n    let option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return fetchData(model.url, option).then(publicAPI.parseAsArrayBuffer);\n  };\n  publicAPI.parseAsArrayBuffer = arrayBuffer => {\n    if (!arrayBuffer) {\n      return false;\n    }\n    if (arrayBuffer !== model.rawDataBuffer) {\n      publicAPI.modified();\n    } else {\n      return true;\n    }\n    const {\n      text: content,\n      binaryBuffer\n    } = extractAppendedData(arrayBuffer);\n    model.rawDataBuffer = arrayBuffer;\n    model.binaryBuffer = binaryBuffer;\n\n    // Parse data here...\n    const doc = parseXML(content);\n    const root = doc.root();\n    const rootElem = root.node;\n    const type = rootElem.getAttribute('type');\n    const compressor = rootElem.getAttribute('compressor');\n    const byteOrder = rootElem.getAttribute('byte_order');\n    // default to UInt32. I think version 0.1 vtp/vti files default to UInt32.\n    const headerType = rootElem.getAttribute('header_type') || 'UInt32';\n    if (compressor && compressor !== 'vtkZLibDataCompressor') {\n      console.error('Invalid compressor', compressor);\n      return false;\n    }\n    if (byteOrder && byteOrder !== 'LittleEndian') {\n      console.error('Only LittleEndian encoding is supported');\n      return false;\n    }\n    if (type !== model.dataType) {\n      console.error('Invalid data type', type, 'expecting', model.dataType);\n      return false;\n    }\n\n    // appended format\n    if (findFirstTag(rootElem, 'AppendedData')) {\n      const appendedDataElem = findFirstTag(rootElem, 'AppendedData');\n      const encoding = appendedDataElem.getAttribute('encoding');\n      const arrays = root.filter(xmlNode => {\n        const {\n          node\n        } = xmlNode;\n        return node.nodeType === Node.ELEMENT_NODE && node.getAttribute('format') === 'appended' && node.hasAttribute('offset');\n      }, false, true).map(xmlNode => ({\n        node: xmlNode.node,\n        offset: Number(xmlNode.node.getAttribute('offset'))\n      }));\n\n      // sort dataElems by increasing offset\n      arrays.sort((a, b) => a.offset - b.offset);\n      let appendedBuffer = model.binaryBuffer;\n      if (encoding === 'base64') {\n        // substr(1) is to remove the '_' prefix\n        appendedBuffer = appendedDataElem.textContent.trim().substr(1);\n      }\n\n      // get data array chunks\n      const dataArrays = [];\n      for (let i = 0; i < arrays.length; ++i) {\n        const offset = arrays[i].offset;\n        let nextOffset = 0;\n        if (i === arrays.length - 1) {\n          nextOffset = appendedBuffer.length || appendedBuffer.byteLength;\n        } else {\n          nextOffset = arrays[i + 1].offset;\n        }\n        if (encoding === 'base64') {\n          dataArrays.push(new Uint8Array(Base64.toArrayBuffer(appendedBuffer.substring(offset, nextOffset))));\n        } else {\n          // encoding === 'raw'\n          // Need to slice the ArrayBuffer so readerHeader() works properly\n          dataArrays.push(new Uint8Array(appendedBuffer.slice(offset, nextOffset)));\n        }\n      }\n      if (compressor === 'vtkZLibDataCompressor') {\n        for (let arrayidx = 0; arrayidx < dataArrays.length; ++arrayidx) {\n          const dataArray = dataArrays[arrayidx];\n          const uncompressed = decompressZLib(dataArray, headerType);\n          const data = new Uint8Array(uncompressed.length + TYPED_ARRAY_BYTES[headerType]);\n          // set length header\n          // TODO this does not work for lengths that are greater than the max Uint32 value.\n          new TYPED_ARRAY[headerType](data.buffer, 0, 1)[0] = uncompressed.length;\n          data.set(uncompressed, TYPED_ARRAY_BYTES[headerType]);\n          dataArrays[arrayidx] = data;\n        }\n      }\n      const bufferLength = dataArrays.reduce((acc, arr) => acc + arr.length, 0);\n      const buffer = new ArrayBuffer(bufferLength);\n      const view = new Uint8Array(buffer);\n      for (let i = 0, offset = 0; i < dataArrays.length; ++i) {\n        // set correct offsets\n        arrays[i].node.setAttribute('offset', offset);\n        // set final buffer data\n        view.set(dataArrays[i], offset);\n        offset += dataArrays[i].length;\n      }\n      model.binaryBuffer = buffer;\n      if (!model.binaryBuffer) {\n        console.error('Processing appended data format: requires binaryBuffer to parse');\n        return false;\n      }\n    }\n    publicAPI.parseXML(rootElem, type, compressor, byteOrder, headerType);\n    const datasetElem = rootElem.getElementsByTagName(type)[0];\n    const fieldDataElem = datasetElem.getElementsByTagName('FieldData')[0];\n    if (fieldDataElem) {\n      const fieldDataArrays = handleFieldDataArrays(fieldDataElem, compressor, byteOrder, headerType, model.binaryBuffer);\n      for (let i = 0; i < model.output.length; i++) {\n        const fieldData = model.output[i].getFieldData();\n        for (let j = 0; j < fieldDataArrays.length; j++) {\n          fieldData.addArray(fieldDataArrays[j]);\n        }\n      }\n    }\n    return true;\n  };\n  publicAPI.requestData = (inData, outData) => {\n    publicAPI.parseAsArrayBuffer(model.rawDataBuffer);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // baseURL: null,\n  // dataAccessHelper: null,\n  // url: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['url', 'baseURL']);\n  macro.setGet(publicAPI, model, ['dataAccessHelper']);\n  macro.algo(publicAPI, model, 0, 1);\n\n  // vtkXMLReader methods\n  vtkXMLReader(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nvar vtkXMLReader$1 = {\n  extend,\n  processDataArray,\n  processFieldData,\n  processCells\n};\nexport { vtkXMLReader$1 as default, extend, findAllTags, findFirstTag };","map":{"version":3,"names":["create","decompressSync","DataAccessHelper","Base64","m","macro","vtkDataArray","vtkStringArray","BinaryHelper","findAllTags","node","tagName","getElementsByTagName","findFirstTag","parseXML","xmlStr","extractAppendedData","buffer","prefixRegex","suffixRegex","extractBinary","TYPED_ARRAY","Int8","Int8Array","UInt8","Uint8Array","Int16","Int16Array","UInt16","Uint16Array","Int32","Int32Array","UInt32","Uint32Array","Int64","UInt64","Float32","Float32Array","Float64","Float64Array","TYPED_ARRAY_BYTES","integer64to32","array","maxIdx","length","filter","v","i","readLengthPrefixedData","uint8","dataType","headerType","includes","Error","HeaderTypedArray","DataTypedArray","dataFallbackTo32","test","replace","byteOffset","dataWordSize","headerWordSize","header","slice","dataByteLength","Number","values","arraySize","dataOffset","readerHeader","offset","uint32","nbBlocks","s1","s2","resultArray","push","getHeaderByteLength","uncompressBlock","compressedUint8","output","uncompressedBlock","set","decompressZLib","bytes","ArrayBuffer","blockSize","compressedBlock","processDataArray","size","dataArrayElem","compressor","byteOrder","binaryBuffer","getAttribute","name","format","numberOfComponents","firstChild","nodeValue","split","forEach","token","trim","toArrayBuffer","data","indexOf","console","error","decodeStringArrayFromBytes","decoder","TextDecoder","decoded","decode","processStringArray","stringArrayElem","numberOfTuples","nbStrings","strings","tokens","tokIdx","strChars","join","String","fromCharCode","decompressed","strData","vtkErrorMacro","processCells","containerElem","arrayElems","dataArrayElems","elIdx","el","offsets","connectivitySize","connectivity","writeOffset","previousOffset","cellSize","processFieldData","fieldElem","fieldContainer","attributes","nameBinding","attrName","arrayName","nbArrays","idx","dataArray","newInstance","getName","addArray","handleFieldDataArrays","fieldDataElem","dataArrays","map","daElem","stringArrays","elem","arrElem","sa","vtkXMLReader","publicAPI","model","classHierarchy","dataAccessHelper","get","fetchData","url","option","arguments","undefined","fetchBinary","setUrl","path","pop","baseURL","loadData","then","parseAsArrayBuffer","arrayBuffer","rawDataBuffer","modified","text","content","doc","root","rootElem","type","appendedDataElem","encoding","arrays","xmlNode","nodeType","Node","ELEMENT_NODE","hasAttribute","sort","a","b","appendedBuffer","textContent","substr","nextOffset","byteLength","substring","arrayidx","uncompressed","bufferLength","reduce","acc","arr","view","setAttribute","datasetElem","fieldDataArrays","fieldData","getFieldData","j","requestData","inData","outData","DEFAULT_VALUES","extend","initialValues","Object","assign","obj","setGet","algo","vtkXMLReader$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/IO/XML/XMLReader.js"],"sourcesContent":["import { create } from 'xmlbuilder2';\nimport { decompressSync } from 'fflate';\nimport DataAccessHelper from '../Core/DataAccessHelper.js';\nimport Base64 from '../../Common/Core/Base64.js';\nimport { m as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkStringArray from '../../Common/Core/StringArray.js';\nimport BinaryHelper from '../Core/BinaryHelper.js';\nimport '../Core/DataAccessHelper/LiteHttpDataAccessHelper.js';\n\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HttpDataAccessHelper'; // HTTP + zip\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HtmlDataAccessHelper'; // html + base64 + zip\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/JSZipDataAccessHelper'; // zip\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction findAllTags(node, tagName) {\n  return [...node.getElementsByTagName(tagName)];\n}\nfunction findFirstTag(node, tagName) {\n  return findAllTags(node, tagName)[0];\n}\nfunction parseXML(xmlStr) {\n  // see xmlbuilder2 docs on the object format\n  return create(xmlStr);\n}\nfunction extractAppendedData(buffer) {\n  // search for appended data tag\n  const prefixRegex = /^\\s*<AppendedData\\s+encoding=\"raw\">\\s*_/m;\n  const suffixRegex = /\\n\\s*<\\/AppendedData>/m;\n  return BinaryHelper.extractBinary(buffer, prefixRegex, suffixRegex);\n}\n\n// ----------------------------------------------------------------------------\n\nconst TYPED_ARRAY = {\n  Int8: Int8Array,\n  UInt8: Uint8Array,\n  Int16: Int16Array,\n  UInt16: Uint16Array,\n  Int32: Int32Array,\n  UInt32: Uint32Array,\n  Int64: Int32Array,\n  // Not supported with JavaScript will cause error in binary\n  UInt64: Uint32Array,\n  // Not supported with JavaScript will cause error in binary\n  Float32: Float32Array,\n  Float64: Float64Array\n};\n\n// ----------------------------------------------------------------------------\n\nconst TYPED_ARRAY_BYTES = {\n  Int8: 1,\n  UInt8: 1,\n  Int16: 2,\n  UInt16: 2,\n  Int32: 4,\n  UInt32: 4,\n  Int64: 8,\n  // Not supported with JavaScript will cause error in binary\n  UInt64: 8,\n  // Not supported with JavaScript will cause error in binary\n  Float32: 4,\n  Float64: 8\n};\n\n// ----------------------------------------------------------------------------\n\nfunction integer64to32(array) {\n  const maxIdx = array.length - 1; // Skip last\n  return array.filter((v, i) => i < maxIdx && i % 2 === 0);\n}\n\n// ----------------------------------------------------------------------------\n\n/**\n * Reads the data of a length-prefixed blob.\n *\n * Int64 headers and values are not supported.\n *\n * @param {Uint8Array} uint8 a uint8 view of the length-prefixed blob.\n * @param {string} dataType\n * @param {string} headerType either UInt64 or UInt32\n */\nfunction readLengthPrefixedData(uint8, dataType, headerType) {\n  if (!['UInt64', 'UInt32'].includes(headerType)) {\n    throw new Error(`Cannot handle a header type of ${headerType}`);\n  }\n  let HeaderTypedArray = TYPED_ARRAY[headerType];\n  let DataTypedArray = TYPED_ARRAY[dataType];\n  let dataFallbackTo32 = false;\n  if (headerType === 'UInt64') {\n    HeaderTypedArray = TYPED_ARRAY.UInt32;\n  }\n  if (/^U?Int64$/.test(dataType)) {\n    dataFallbackTo32 = true;\n    DataTypedArray = TYPED_ARRAY[dataType.replace('64', '32')];\n  }\n  const {\n    byteOffset\n  } = uint8;\n  const dataWordSize = TYPED_ARRAY_BYTES[dataType];\n  const headerWordSize = TYPED_ARRAY_BYTES[headerType];\n\n  // slice if offset is not word aligned\n  let header;\n  if (byteOffset % headerWordSize === 0) {\n    header = new HeaderTypedArray(uint8.buffer, byteOffset, 1);\n  } else {\n    header = new HeaderTypedArray(uint8.buffer.slice(byteOffset, byteOffset + headerWordSize));\n  }\n  const dataByteLength = Number(header[0]);\n\n  // read values\n  let values;\n  let arraySize = dataByteLength / dataWordSize;\n  if (dataFallbackTo32) {\n    // We are reading int64 data with an int32 typed array.\n    arraySize *= 2;\n  }\n\n  // slice if offset is not word aligned\n  const dataOffset = byteOffset + headerWordSize;\n  if (dataOffset % dataWordSize === 0) {\n    values = new DataTypedArray(uint8.buffer, dataOffset, arraySize);\n  } else {\n    values = new DataTypedArray(uint8.buffer.slice(dataOffset, dataOffset + dataByteLength));\n  }\n  if (dataFallbackTo32) {\n    // remove higher order 32 bits\n    values = integer64to32(values);\n  }\n  return values;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction readerHeader(uint8, headerType) {\n  // We do not handle endianness or if more than 32 bits are needed to encode the data\n  if (headerType === 'UInt64') {\n    const offset = 8;\n    let uint32 = new Uint32Array(uint8.buffer, 0, 6);\n    const nbBlocks = uint32[0];\n    const s1 = uint32[2];\n    const s2 = uint32[4];\n    const resultArray = [offset, nbBlocks, s1, s2];\n    uint32 = new Uint32Array(uint8.buffer, 3 * 8, nbBlocks * 2);\n    for (let i = 0; i < nbBlocks; i++) {\n      resultArray.push(uint32[i * 2]);\n    }\n    return resultArray;\n  }\n  // UInt32\n  let uint32 = new Uint32Array(uint8.buffer, 0, 3);\n  const offset = 4;\n  const nbBlocks = uint32[0];\n  const s1 = uint32[1];\n  const s2 = uint32[2];\n  const resultArray = [offset, nbBlocks, s1, s2];\n  uint32 = new Uint32Array(uint8.buffer, 3 * 4, nbBlocks);\n  for (let i = 0; i < nbBlocks; i++) {\n    resultArray.push(uint32[i]);\n  }\n  return resultArray;\n}\n\n// ----------------------------------------------------------------------------\n\n/**\n * Given the return value of readerHeader, return header byte length.\n */\nfunction getHeaderByteLength(header, headerType) {\n  // ignore the first number, which isn't actually part of the header.\n  const [headerWordSize] = header;\n  return (header.length - 1) * headerWordSize;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction uncompressBlock(compressedUint8, output) {\n  const uncompressedBlock = decompressSync(compressedUint8);\n  output.uint8.set(uncompressedBlock, output.offset);\n  output.offset += uncompressedBlock.length;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction decompressZLib(bytes, headerType) {\n  // ----------------------------------------------------------------------\n  // Layout of the data\n  // header[N, s1, s2, blockSize1, ..., blockSizeN], [padding???], block[compressedData], ..., block[compressedData]\n  // [header] N, s1 and s2 are uint 32 or 64 (defined by header_type=\"UInt64\" attribute on the root node)\n  // [header] s1: uncompress size of each block except the last one\n  // [header] s2: uncompress size of the last blocks\n  // [header] blockSize: size of the block in compressed space that represent to bloc to inflate in zlib. (This also give the offset to the next block)\n  // ----------------------------------------------------------------------\n\n  // Header reading: [offset, numBlocks, s1, s2]\n  const header = readerHeader(bytes, headerType);\n  const nbBlocks = header[1];\n  const s1 = header[2];\n  const s2 = header[3];\n  let dataByteLength = 0;\n  if (nbBlocks > 0) {\n    // If the last block's size is labeled as 0, that means the last block\n    // really has size header[2].\n    if (s2 === 0) {\n      dataByteLength = nbBlocks * s1;\n    } else {\n      dataByteLength = (nbBlocks - 1) * s1 + s2;\n    }\n  }\n  const buffer = new ArrayBuffer(dataByteLength);\n  const output = {\n    offset: 0,\n    uint8: new Uint8Array(buffer)\n  };\n  let offset = getHeaderByteLength(header);\n  // Starting from end of the data header, find the zlib header, which starts with 0x78.\n  // This accounts for any padding between the header and the compressed data.\n  while (offset < bytes.length && bytes[offset] !== 0x78) {\n    offset++;\n  }\n  for (let i = 0; i < nbBlocks; i++) {\n    const blockSize = header[4 + i];\n    const compressedBlock = new Uint8Array(bytes.buffer, offset, blockSize);\n    uncompressBlock(compressedBlock, output);\n    offset += blockSize;\n  }\n  return output.uint8;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction processDataArray(size, dataArrayElem, compressor, byteOrder, headerType, binaryBuffer) {\n  const dataType = dataArrayElem.getAttribute('type');\n  const name = dataArrayElem.getAttribute('Name');\n  const format = dataArrayElem.getAttribute('format'); // binary, ascii, appended\n  const numberOfComponents = Number(dataArrayElem.getAttribute('NumberOfComponents') || '1');\n  let values = null;\n  if (format === 'ascii') {\n    values = new TYPED_ARRAY[dataType](size * numberOfComponents);\n    let offset = 0;\n    dataArrayElem.firstChild.nodeValue.split(/[\\\\t \\\\n]+/).forEach(token => {\n      if (token.trim().length) {\n        values[offset++] = Number(token);\n      }\n    });\n  } else if (format === 'binary') {\n    const uint8 = new Uint8Array(Base64.toArrayBuffer(dataArrayElem.firstChild.nodeValue.trim()));\n    if (compressor === 'vtkZLibDataCompressor') {\n      const data = decompressZLib(uint8, headerType);\n      values = new TYPED_ARRAY[dataType](data.buffer);\n\n      // Handle (u)int64 hoping for no overflow...\n      if (/^U?Int64$/.test(dataType)) {\n        values = integer64to32(values);\n      }\n    } else {\n      values = new TYPED_ARRAY[dataType](uint8.buffer, TYPED_ARRAY_BYTES[headerType]);\n\n      // Handle (u)int64 hoping no overflow...\n      if (dataType.indexOf('Int64') !== -1) {\n        values = integer64to32(values);\n      }\n    }\n  } else if (format === 'appended') {\n    const offset = Number(dataArrayElem.getAttribute('offset'));\n    values = readLengthPrefixedData(new Uint8Array(binaryBuffer, offset), dataType, headerType);\n  } else {\n    console.error('Format not supported', format);\n  }\n  return {\n    name,\n    values,\n    numberOfComponents\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction decodeStringArrayFromBytes(bytes) {\n  const decoder = new TextDecoder();\n  const decoded = decoder.decode(bytes);\n\n  // strings are null-terminated\n  return decoded.split('\\x00').slice(0, -1);\n}\n\n// ----------------------------------------------------------------------------\n\nfunction processStringArray(stringArrayElem, compressor, byteOrder, headerType, binaryBuffer) {\n  const name = stringArrayElem.getAttribute('Name');\n  const format = stringArrayElem.getAttribute('format'); // binary, ascii, appended\n  const numberOfComponents = Number(stringArrayElem.getAttribute('NumberOfComponents') || '1');\n  const numberOfTuples = Number(stringArrayElem.getAttribute('NumberOfTuples') || '1');\n  const nbStrings = numberOfTuples * numberOfComponents;\n  const strings = [];\n  if (format === 'ascii') {\n    const tokens = stringArrayElem.firstChild.nodeValue.trim().split(/\\s+/);\n    let tokIdx = 0;\n    const strChars = [];\n    while (strings.length < nbStrings) {\n      const token = Number(tokens[tokIdx++]);\n      if (token === 0) {\n        strings.push(strChars.join(''));\n        strChars.length = 0;\n      } else {\n        strChars.push(String.fromCharCode(token));\n      }\n    }\n  } else if (format === 'binary') {\n    const uint8 = new Uint8Array(Base64.toArrayBuffer(stringArrayElem.firstChild.nodeValue.trim()));\n    if (compressor === 'vtkZLibDataCompressor') {\n      const decompressed = decompressZLib(uint8, headerType);\n      strings.push(...decodeStringArrayFromBytes(decompressed));\n    } else {\n      const strData = readLengthPrefixedData(uint8, 'UInt8', headerType);\n      strings.push(...decodeStringArrayFromBytes(strData));\n    }\n  } else if (format === 'appended') {\n    const offset = Number(stringArrayElem.getAttribute('offset'));\n    const values = readLengthPrefixedData(new Uint8Array(binaryBuffer, offset), 'UInt8', headerType);\n    strings.push(...decodeStringArrayFromBytes(values));\n  } else {\n    macro.vtkErrorMacro(`Format not supported: ${format}`);\n  }\n  return {\n    name,\n    values: strings,\n    numberOfComponents\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction processCells(size, containerElem, compressor, byteOrder, headerType, binaryBuffer) {\n  const arrayElems = {};\n  const dataArrayElems = containerElem.getElementsByTagName('DataArray');\n  for (let elIdx = 0; elIdx < dataArrayElems.length; elIdx++) {\n    const el = dataArrayElems[elIdx];\n    arrayElems[el.getAttribute('Name')] = el;\n  }\n  const offsets = processDataArray(size, arrayElems.offsets, compressor, byteOrder, headerType, binaryBuffer).values;\n  const connectivitySize = offsets[offsets.length - 1];\n  const connectivity = processDataArray(connectivitySize, arrayElems.connectivity, compressor, byteOrder, headerType, binaryBuffer).values;\n  const values = new Uint32Array(size + connectivitySize);\n  let writeOffset = 0;\n  let previousOffset = 0;\n  offsets.forEach(v => {\n    const cellSize = v - previousOffset;\n    values[writeOffset++] = cellSize;\n    for (let i = 0; i < cellSize; i++) {\n      values[writeOffset++] = connectivity[previousOffset + i];\n    }\n\n    // save previous offset\n    previousOffset = v;\n  });\n  return values;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction processFieldData(size, fieldElem, fieldContainer, compressor, byteOrder, headerType, binaryBuffer) {\n  if (fieldElem) {\n    const attributes = ['Scalars', 'Vectors', 'Normals', 'Tensors', 'TCoords'];\n    const nameBinding = {};\n    attributes.forEach(attrName => {\n      const arrayName = fieldElem.getAttribute(attrName);\n      if (arrayName) {\n        nameBinding[arrayName] = fieldContainer[`set${attrName}`];\n      }\n    });\n    const dataArrayElems = fieldElem.getElementsByTagName('DataArray');\n    const nbArrays = dataArrayElems.length;\n    for (let idx = 0; idx < nbArrays; idx++) {\n      const array = dataArrayElems[idx];\n      const dataArray = vtkDataArray.newInstance(processDataArray(size, array, compressor, byteOrder, headerType, binaryBuffer));\n      const name = dataArray.getName();\n      (nameBinding[name] || fieldContainer.addArray)(dataArray);\n    }\n  }\n}\n\n// ----------------------------------------------------------------------------\nfunction handleFieldDataArrays(fieldDataElem, compressor, byteOrder, headerType, binaryBuffer) {\n  const dataArrays = [...fieldDataElem.getElementsByTagName('DataArray')].map(daElem => vtkDataArray.newInstance(processDataArray(Number(daElem.getAttribute('NumberOfTuples')), daElem, compressor, byteOrder, headerType, binaryBuffer)));\n  const stringArrays = [...fieldDataElem.getElementsByTagName('Array')].filter(elem => elem.getAttribute('type') === 'String').map(arrElem => {\n    const sa = vtkStringArray.newInstance(processStringArray(arrElem, compressor, byteOrder, headerType, binaryBuffer));\n    return sa;\n  });\n  return [...dataArrays, ...stringArrays];\n}\n\n// ----------------------------------------------------------------------------\n// vtkXMLReader methods\n// ----------------------------------------------------------------------------\n\nfunction vtkXMLReader(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkXMLReader');\n\n  // Create default dataAccessHelper if not available\n  if (!model.dataAccessHelper) {\n    model.dataAccessHelper = DataAccessHelper.get('http');\n  }\n\n  // Internal method to fetch Array\n  function fetchData(url) {\n    let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return model.dataAccessHelper.fetchBinary(url, option);\n  }\n\n  // Set DataSet url\n  publicAPI.setUrl = function (url) {\n    let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    model.url = url;\n\n    // Remove the file in the URL\n    const path = url.split('/');\n    path.pop();\n    model.baseURL = path.join('/');\n\n    // Fetch metadata\n    return publicAPI.loadData(option);\n  };\n\n  // Fetch the actual data arrays\n  publicAPI.loadData = function () {\n    let option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return fetchData(model.url, option).then(publicAPI.parseAsArrayBuffer);\n  };\n  publicAPI.parseAsArrayBuffer = arrayBuffer => {\n    if (!arrayBuffer) {\n      return false;\n    }\n    if (arrayBuffer !== model.rawDataBuffer) {\n      publicAPI.modified();\n    } else {\n      return true;\n    }\n    const {\n      text: content,\n      binaryBuffer\n    } = extractAppendedData(arrayBuffer);\n    model.rawDataBuffer = arrayBuffer;\n    model.binaryBuffer = binaryBuffer;\n\n    // Parse data here...\n    const doc = parseXML(content);\n    const root = doc.root();\n    const rootElem = root.node;\n    const type = rootElem.getAttribute('type');\n    const compressor = rootElem.getAttribute('compressor');\n    const byteOrder = rootElem.getAttribute('byte_order');\n    // default to UInt32. I think version 0.1 vtp/vti files default to UInt32.\n    const headerType = rootElem.getAttribute('header_type') || 'UInt32';\n    if (compressor && compressor !== 'vtkZLibDataCompressor') {\n      console.error('Invalid compressor', compressor);\n      return false;\n    }\n    if (byteOrder && byteOrder !== 'LittleEndian') {\n      console.error('Only LittleEndian encoding is supported');\n      return false;\n    }\n    if (type !== model.dataType) {\n      console.error('Invalid data type', type, 'expecting', model.dataType);\n      return false;\n    }\n\n    // appended format\n    if (findFirstTag(rootElem, 'AppendedData')) {\n      const appendedDataElem = findFirstTag(rootElem, 'AppendedData');\n      const encoding = appendedDataElem.getAttribute('encoding');\n      const arrays = root.filter(xmlNode => {\n        const {\n          node\n        } = xmlNode;\n        return node.nodeType === Node.ELEMENT_NODE && node.getAttribute('format') === 'appended' && node.hasAttribute('offset');\n      }, false, true).map(xmlNode => ({\n        node: xmlNode.node,\n        offset: Number(xmlNode.node.getAttribute('offset'))\n      }));\n\n      // sort dataElems by increasing offset\n      arrays.sort((a, b) => a.offset - b.offset);\n      let appendedBuffer = model.binaryBuffer;\n      if (encoding === 'base64') {\n        // substr(1) is to remove the '_' prefix\n        appendedBuffer = appendedDataElem.textContent.trim().substr(1);\n      }\n\n      // get data array chunks\n      const dataArrays = [];\n      for (let i = 0; i < arrays.length; ++i) {\n        const offset = arrays[i].offset;\n        let nextOffset = 0;\n        if (i === arrays.length - 1) {\n          nextOffset = appendedBuffer.length || appendedBuffer.byteLength;\n        } else {\n          nextOffset = arrays[i + 1].offset;\n        }\n        if (encoding === 'base64') {\n          dataArrays.push(new Uint8Array(Base64.toArrayBuffer(appendedBuffer.substring(offset, nextOffset))));\n        } else {\n          // encoding === 'raw'\n          // Need to slice the ArrayBuffer so readerHeader() works properly\n          dataArrays.push(new Uint8Array(appendedBuffer.slice(offset, nextOffset)));\n        }\n      }\n      if (compressor === 'vtkZLibDataCompressor') {\n        for (let arrayidx = 0; arrayidx < dataArrays.length; ++arrayidx) {\n          const dataArray = dataArrays[arrayidx];\n          const uncompressed = decompressZLib(dataArray, headerType);\n          const data = new Uint8Array(uncompressed.length + TYPED_ARRAY_BYTES[headerType]);\n          // set length header\n          // TODO this does not work for lengths that are greater than the max Uint32 value.\n          new TYPED_ARRAY[headerType](data.buffer, 0, 1)[0] = uncompressed.length;\n          data.set(uncompressed, TYPED_ARRAY_BYTES[headerType]);\n          dataArrays[arrayidx] = data;\n        }\n      }\n      const bufferLength = dataArrays.reduce((acc, arr) => acc + arr.length, 0);\n      const buffer = new ArrayBuffer(bufferLength);\n      const view = new Uint8Array(buffer);\n      for (let i = 0, offset = 0; i < dataArrays.length; ++i) {\n        // set correct offsets\n        arrays[i].node.setAttribute('offset', offset);\n        // set final buffer data\n        view.set(dataArrays[i], offset);\n        offset += dataArrays[i].length;\n      }\n      model.binaryBuffer = buffer;\n      if (!model.binaryBuffer) {\n        console.error('Processing appended data format: requires binaryBuffer to parse');\n        return false;\n      }\n    }\n    publicAPI.parseXML(rootElem, type, compressor, byteOrder, headerType);\n    const datasetElem = rootElem.getElementsByTagName(type)[0];\n    const fieldDataElem = datasetElem.getElementsByTagName('FieldData')[0];\n    if (fieldDataElem) {\n      const fieldDataArrays = handleFieldDataArrays(fieldDataElem, compressor, byteOrder, headerType, model.binaryBuffer);\n      for (let i = 0; i < model.output.length; i++) {\n        const fieldData = model.output[i].getFieldData();\n        for (let j = 0; j < fieldDataArrays.length; j++) {\n          fieldData.addArray(fieldDataArrays[j]);\n        }\n      }\n    }\n    return true;\n  };\n  publicAPI.requestData = (inData, outData) => {\n    publicAPI.parseAsArrayBuffer(model.rawDataBuffer);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // baseURL: null,\n  // dataAccessHelper: null,\n  // url: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['url', 'baseURL']);\n  macro.setGet(publicAPI, model, ['dataAccessHelper']);\n  macro.algo(publicAPI, model, 0, 1);\n\n  // vtkXMLReader methods\n  vtkXMLReader(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nvar vtkXMLReader$1 = {\n  extend,\n  processDataArray,\n  processFieldData,\n  processCells\n};\n\nexport { vtkXMLReader$1 as default, extend, findAllTags, findFirstTag };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}