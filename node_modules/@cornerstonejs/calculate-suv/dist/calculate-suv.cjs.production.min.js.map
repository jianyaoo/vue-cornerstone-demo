{"version":3,"file":"calculate-suv.cjs.production.min.js","sources":["../src/combineDateTime.ts","../src/parseDA.ts","../src/parseTM.ts","../src/dateTimeToFullDateInterface.ts","../src/calculateSUVScalingFactors.ts","../src/calculateScanTimes.ts","../src/calculateStartTime.ts","../src/calculateSUVbsaScalingFactor.ts","../src/calculateSUVlbmScalingFactor.ts"],"sourcesContent":["import { DateInterface } from './parseDA';\nimport { TimeInterface } from './parseTM';\n\n/**\n * Javascript object that handles dates and compute the time.\n *\n * @export\n * @class FullDateInterface\n */\nexport class FullDateInterface {\n  fullDate: string;\n\n  /**\n   * Creates an instance of FullDateInterface.\n   * @param {string} date formatted as yyyy-mm-ddTHH:MM:SS.FFFFFFZ\n   * @memberof FullDateInterface\n   */\n  constructor(date: string) {\n    this.fullDate = date;\n  }\n\n  /**\n   * returns time since 1 january 1970\n   *\n   * @returns {number} time in sec\n   * @memberof FullDateInterface\n   */\n  getTimeInSec(): number {\n    // yyyy-mm-ddTHH:MM:SS.FFFFFFZ\n    const dateString = this.fullDate.substring(0, 10);\n    const timeString = this.fullDate.substring(11, 28);\n\n    // yyyy-mm-dd\n    const yyyy = parseInt(dateString.substring(0, 4), 10);\n    const mm =\n      dateString.length >= 7\n        ? parseInt(dateString.substring(5, 7), 10)\n        : undefined;\n    const dd =\n      dateString.length >= 10\n        ? parseInt(dateString.substring(8, 10), 10)\n        : undefined;\n\n    if (\n      isNaN(yyyy) ||\n      (mm !== undefined && isNaN(mm)) ||\n      (dd !== undefined && isNaN(dd)) ||\n      yyyy > 3000 ||\n      (mm && (mm < 1 || mm > 12)) ||\n      (dd && (dd < 1 || dd > 31))\n    ) {\n      throw new Error(`invalid date '${dateString}'`);\n    }\n\n    const dateJS = new Date(`${dateString}T00:00:00.000000Z`);\n\n    // HHMMSS.FFFFFF\n    const HH = parseInt(timeString.substring(0, 2), 10);\n    const MM =\n      timeString.length >= 5\n        ? parseInt(timeString.substring(3, 5), 10)\n        : undefined;\n    const SS =\n      timeString.length >= 8\n        ? parseInt(timeString.substring(6, 8), 10)\n        : undefined;\n    const fractionalStr = timeString.substring(9, 15);\n    const FFFFFF = fractionalStr\n      ? parseInt(fractionalStr, 10) * Math.pow(10, -fractionalStr.length)\n      : undefined;\n\n    if (\n      isNaN(HH) ||\n      (MM !== undefined && isNaN(MM)) ||\n      (SS !== undefined && isNaN(SS)) ||\n      (FFFFFF !== undefined && isNaN(FFFFFF)) ||\n      HH < 0 ||\n      HH > 23 ||\n      (MM && (MM < 0 || MM > 59)) ||\n      (SS && (SS < 0 || SS > 59)) ||\n      (FFFFFF && (FFFFFF < 0 || FFFFFF > 999999))\n    ) {\n      throw new Error(`invalid time '${timeString}'`);\n    }\n\n    let timeInSec = dateJS.getTime() / 1000;\n\n    timeInSec += HH * 3600;\n    if (MM !== undefined) {\n      timeInSec += MM * 60;\n    }\n    if (SS !== undefined) {\n      timeInSec += SS;\n    }\n    if (FFFFFF !== undefined) {\n      timeInSec += FFFFFF;\n    }\n\n    return timeInSec;\n  }\n\n  /**\n   * returns time since 1 january 1970\n   *\n   * @returns {number} time in microsec\n   * @memberof FullDateInterface\n   */\n  getTimeInMicroSec(): number {\n    const timeInMicroSec = this.getTimeInSec() * 1e6;\n    return timeInMicroSec;\n  }\n}\n\nexport interface FullDateInterface {\n  date: string;\n}\n\n/**\n * Combines two javascript objects containing the date and time information\n *\n * @export\n * @param {DateInterface} date\n * @param {TimeInterface} time\n * @returns {FullDateInterface}\n */\nexport default function combineDateTime(\n  date: DateInterface,\n  time: TimeInterface\n): FullDateInterface {\n  const hours = `${time.hours || '00'}`.padStart(2, '0');\n  const minutes = `${time.minutes || '00'}`.padStart(2, '0');\n  const seconds = `${time.seconds || '00'}`.padStart(2, '0');\n  const month = `${date.month}`.padStart(2, '0');\n  const day = `${date.day}`.padStart(2, '0');\n  const fractionalSeconds = `${time.fractionalSeconds || '000000'}`.padEnd(\n    6,\n    '0'\n  );\n  const dateString = `${date.year}-${month}-${day}`;\n  const timeString = `T${hours}:${minutes}:${seconds}.${fractionalSeconds}Z`;\n  const fullDateString = `${dateString}${timeString}`;\n\n  return new FullDateInterface(fullDateString);\n}\n\nexport { combineDateTime };\n","/**\n * Check the number of days for a picked month and year\n * algorithm based on http://stackoverflow.com/questions/1433030/validate-number-of-days-in-a-given-month\n *\n * @param {number} m\n * @param {number} y\n * @returns {number} number of days\n */\nfunction daysInMonth(m: number, y: number): number {\n  // m is 0 indexed: 0-11\n  switch (m) {\n    case 2:\n      return (y % 4 === 0 && y % 100) || y % 400 === 0 ? 29 : 28;\n    case 9:\n    case 4:\n    case 6:\n    case 11:\n      return 30;\n    default:\n      return 31;\n  }\n}\n\n/**\n * Check if the date is valid\n *\n * @param {number} d\n * @param {number} m\n * @param {number} y\n * @returns {boolean} boolean result\n */\nfunction isValidDate(d: number, m: number, y: number): boolean {\n  // make year is a number\n  if (isNaN(y)) {\n    return false;\n  }\n\n  return m > 0 && m <= 12 && d > 0 && d <= daysInMonth(m, y);\n}\n\n/**\n * Javascript object with properties year, month and day\n *\n * @export\n * @interface DateInterface\n */\nexport interface DateInterface {\n  year: number;\n  month: number;\n  day: number;\n}\n\n/**\n * Parses a DA formatted string into a Javascript object\n * @param {string} date a string in the DA VR format\n * @param {boolean} [validate] - true if an exception should be thrown if the date is invalid\n * @returns {DateInterface} Javascript object with properties year, month and day or undefined if not present or not 8 bytes long\n */\nexport default function parseDA(date: string): DateInterface {\n  if (\n    date === undefined ||\n    date === null ||\n    date.length !== 8 ||\n    typeof date !== 'string'\n  ) {\n    throw new Error(`invalid DA '${date}'`);\n  }\n\n  const yyyy = parseInt(date.substring(0, 4), 10);\n  const mm = parseInt(date.substring(4, 6), 10);\n  const dd = parseInt(date.substring(6, 8), 10);\n\n  if (isValidDate(dd, mm, yyyy) !== true) {\n    throw new Error(`invalid DA '${date}'`);\n  }\n\n  return {\n    year: yyyy,\n    month: mm,\n    day: dd,\n  };\n}\n\nexport { parseDA };\n","/**\n * Javascript object with properties for hours, minutes, seconds and fractionalSeconds\n *\n * @export\n * @interface TimeInterface\n */\nexport interface TimeInterface {\n  hours?: number;\n  minutes?: number;\n  seconds?: number;\n  fractionalSeconds?: number;\n}\n\n/**\n * Parses a TM formatted string into a javascript object with properties for hours, minutes, seconds and fractionalSeconds\n * @param {string} time - a string in the TM VR format\n * @returns {string} javascript object with properties for hours, minutes, seconds and fractionalSeconds or undefined if no element or data.  Missing fields are set to undefined\n */\nexport default function parseTM(time: string): TimeInterface {\n  if (\n    time === null ||\n    time === undefined ||\n    time.length < 2 ||\n    typeof time !== 'string'\n  ) {\n    // must at least have HH\n    throw new Error(`invalid TM '${time}'`);\n  }\n\n  // 0123456789\n  // HHMMSS.FFFFFF\n  const hh = parseInt(time.substring(0, 2), 10);\n  const mm = time.length >= 4 ? parseInt(time.substring(2, 4), 10) : undefined;\n  const ss = time.length >= 6 ? parseInt(time.substring(4, 6), 10) : undefined;\n  const fractionalStr = time.length >= 8 ? time.substring(7, 13) : undefined;\n  const ffffff = fractionalStr\n    ? parseInt(fractionalStr, 10) * Math.pow(10, 6 - fractionalStr.length)\n    : undefined;\n\n  if (\n    isNaN(hh) ||\n    (mm !== undefined && isNaN(mm)) ||\n    (ss !== undefined && isNaN(ss)) ||\n    (ffffff !== undefined && isNaN(ffffff)) ||\n    hh < 0 ||\n    hh > 23 ||\n    (mm && (mm < 0 || mm > 59)) ||\n    (ss && (ss < 0 || ss > 59)) ||\n    (ffffff && (ffffff < 0 || ffffff > 999999))\n  ) {\n    throw new Error(`invalid TM '${time}'`);\n  }\n\n  return {\n    hours: hh,\n    minutes: mm,\n    seconds: ss,\n    fractionalSeconds: ffffff,\n  };\n}\n\nexport { parseTM };\n","import combineDateTime, { FullDateInterface } from './combineDateTime';\nimport parseDA from './parseDA';\nimport parseTM from './parseTM';\n\n/**\n * Utility to create a FullDateInterface object given a string formatted as yyyy-mm-ddTHH:MM:SS.FFFFFFZ\n *\n * @export\n * @param {string} dateTime\n * @returns {FullDateInterface}\n */\nexport default function dateTimeToFullDateInterface(\n  dateTime: string\n): FullDateInterface {\n  if (dateTime === undefined || dateTime === null) {\n    throw new Error('dateTimeToFullDateInterface : dateTime not defined.');\n  }\n\n  const date = parseDA(dateTime.substring(0, 8));\n  const time = parseTM(dateTime.substring(8));\n  return combineDateTime(date, time);\n}\n\nexport { dateTimeToFullDateInterface };\n","import { FullDateInterface } from './combineDateTime';\nimport { calculateScanTimes } from './calculateScanTimes';\nimport {\n  calculateSUVlbmJanmahasatianScalingFactor,\n  calculateSUVlbmScalingFactor,\n  SUVlbmScalingFactorInput,\n} from './calculateSUVlbmScalingFactor';\nimport {\n  calculateSUVbsaScalingFactor,\n  SUVbsaScalingFactorInput,\n} from './calculateSUVbsaScalingFactor';\nimport { calculateStartTime } from './calculateStartTime';\nimport { InstanceMetadata } from './types';\n\n/**\n * Javascript object containing the SUV and SUL factors.\n * TODO, the result property names may changes\n *\n * @interface ScalingFactorResult\n */\ninterface ScalingFactorResult {\n  suvbw: number;\n  suvlbm?: number;\n  suvlbmJanma?: number;\n  suvbsa?: number;\n}\n\n/**\n * The injected dose used to calculate SUV is corrected for the\n * decay that occurs between the time of injection and the start of the scan\n *\n * @param {InstanceMetadata[]} instances\n * @returns {number[]}\n */\nfunction calculateDecayCorrection(instances: InstanceMetadata[]): number[] {\n  const {\n    RadionuclideTotalDose,\n    RadionuclideHalfLife,\n    RadiopharmaceuticalStartDateTime,\n    RadiopharmaceuticalStartTime,\n    SeriesDate,\n  } = instances[0];\n\n  if (RadionuclideTotalDose === undefined || RadionuclideTotalDose === null) {\n    throw new Error(\n      'calculateDecayCorrection : RadionuclideTotalDose value not found.'\n    );\n  }\n\n  if (RadionuclideHalfLife === undefined || RadionuclideHalfLife === null) {\n    throw new Error(\n      'calculateDecayCorrection : RadionuclideHalfLife value not found.'\n    );\n  }\n\n  const scanTimes: FullDateInterface[] = calculateScanTimes(instances);\n  const startTime: FullDateInterface = calculateStartTime({\n    RadiopharmaceuticalStartDateTime,\n    RadiopharmaceuticalStartTime,\n    SeriesDate,\n  });\n\n  return instances.map((_, index) => {\n    const scanTime = scanTimes[index];\n    const decayTimeInSec: number =\n      scanTime.getTimeInSec() - startTime.getTimeInSec();\n    if (decayTimeInSec < 0) {\n      throw new Error('Decay time cannot be less than zero');\n    }\n\n    const decayedDose: number =\n      RadionuclideTotalDose *\n      Math.pow(2, -decayTimeInSec / RadionuclideHalfLife);\n\n    return 1 / decayedDose;\n  });\n}\n\n/**\n *\n * @param a Simple value or array of simple values\n * @param b Simple value or array of simple values\n * @returns boolean true if the values are equal.\n */\nconst deepEquals = (\n  a: string | number | any[],\n  b: string | number | any[]\n): boolean => {\n  return (\n    a === b ||\n    (Array.isArray(a) &&\n      Array.isArray(b) &&\n      a.length === b.length &&\n      a.every((val, index) => val === b[index]))\n  );\n};\n\n/**\n * Calculate the SUV factor\n *\n * Note: Rescale Slope / Intercept must still be applied. These must be applied\n *       on a per-Frame basis, since some scanners may have different values per Frame.\n *\n * @export\n * @param {InstanceMetadata[]} instances\n * @returns {ScalingFactorResult[]}\n */\nexport default function calculateSUVScalingFactors(\n  instances: InstanceMetadata[]\n): ScalingFactorResult[] {\n  const {\n    CorrectedImage,\n    Units,\n    PhilipsPETPrivateGroup,\n    PatientWeight,\n    PatientSex,\n    PatientSize,\n  } = instances[0];\n\n  if (!CorrectedImage.includes('ATTN') || !CorrectedImage.includes('DECY')) {\n    throw new Error(\n      `CorrectedImage must contain \"ATTN\" and \"DECY\": ${CorrectedImage}`\n    );\n  }\n\n  // Sanity check that every instance provided has identical\n  // values for series-level metadata. If not, the provided\n  // data is invalid.\n  const isSingleSeries = instances.every(instance => {\n    return (\n      instance.Units === Units &&\n      deepEquals(instance.CorrectedImage, CorrectedImage) &&\n      instance.PatientWeight === PatientWeight &&\n      instance.PatientSex === PatientSex &&\n      instance.PatientSize === PatientSize &&\n      instance.RadionuclideHalfLife === instances[0].RadionuclideHalfLife &&\n      instance.RadionuclideTotalDose === instances[0].RadionuclideTotalDose &&\n      instance.DecayCorrection === instances[0].DecayCorrection &&\n      instance.SeriesDate === instances[0].SeriesDate &&\n      instance.SeriesTime === instances[0].SeriesTime\n    );\n  });\n\n  if (!isSingleSeries) {\n    throw new Error(\n      'The set of instances does not appear to come from one Series. Every instance must have identical values for series-level metadata properties'\n    );\n  }\n\n  // Treat null, undefined and zero as a missing PatientWeight.\n  if (!PatientWeight) {\n    throw new Error(\n      'PatientWeight value is missing. It is not possible to calculate the SUV factors'\n    );\n  }\n\n  let decayCorrectionArray: number[] = new Array(instances.length);\n  decayCorrectionArray = calculateDecayCorrection(instances);\n\n  let results: number[] = new Array(instances.length);\n  const weightInGrams: number = PatientWeight * 1000;\n\n  if (Units === 'BQML') {\n    results = decayCorrectionArray.map(function(value) {\n      return value * weightInGrams;\n    });\n  } else if (Units === 'CNTS') {\n    const hasValidSUVScaleFactor: boolean = instances.every(instance => {\n      return (\n        instance.PhilipsPETPrivateGroup &&\n        instance.PhilipsPETPrivateGroup?.SUVScaleFactor !== null &&\n        instance.PhilipsPETPrivateGroup?.SUVScaleFactor !== undefined &&\n        instance.PhilipsPETPrivateGroup?.SUVScaleFactor !== 0\n      );\n    });\n\n    const hasValidActivityConcentrationScaleFactor: boolean = instances.every(\n      instance => {\n        return (\n          instance.PhilipsPETPrivateGroup &&\n          !instance.PhilipsPETPrivateGroup?.SUVScaleFactor &&\n          instance.PhilipsPETPrivateGroup?.ActivityConcentrationScaleFactor !==\n            undefined &&\n          instance.PhilipsPETPrivateGroup?.ActivityConcentrationScaleFactor !==\n            0\n        );\n      }\n    );\n\n    //console.log(`hasValidSUVScaleFactor: ${hasValidSUVScaleFactor}`);\n    //console.log(`hasValidActivityConcentrationScaleFactor: ${hasValidActivityConcentrationScaleFactor}`);\n\n    if (hasValidSUVScaleFactor) {\n      results = instances.map(\n        // Added ! to tell Typescript that this can't be undefined, since we are testing it\n        // in the .every loop above.\n        instance => instance.PhilipsPETPrivateGroup!.SUVScaleFactor!\n      );\n    } else if (hasValidActivityConcentrationScaleFactor) {\n      // if (0x7053,0x1000) not present, but (0x7053,0x1009) is present, then (0x7053,0x1009) * Rescale Slope,\n      // scales pixels to Bq/ml, and proceed as if Units are BQML\n      results = instances.map((instance, index) => {\n        // Added ! to tell Typescript that this can't be undefined, since we are testing it\n        // in the .every loop above.\n        return (\n          instance.PhilipsPETPrivateGroup!.ActivityConcentrationScaleFactor! *\n          decayCorrectionArray[index] *\n          weightInGrams\n        );\n      });\n    } else {\n      throw new Error(\n        `Units are in CNTS, but PhilipsPETPrivateGroup has invalid values: ${JSON.stringify(\n          PhilipsPETPrivateGroup\n        )}`\n      );\n    }\n  } else if (Units === 'GML') {\n    // assumes that GML indicates SUVbw instead of SUVlbm\n    results.fill(1);\n  } else {\n    throw new Error(`Units has an invalid value: ${Units}`);\n  }\n\n  // get BSA\n  let suvbsaFactor: number | undefined;\n  if (PatientSize === null || PatientSize === undefined) {\n    console.warn(\n      'PatientSize value is missing. It is not possible to calculate the SUV bsa factors'\n    );\n  } else {\n    const sulInputs: SUVbsaScalingFactorInput = {\n      PatientWeight,\n      PatientSize,\n    };\n\n    suvbsaFactor = calculateSUVbsaScalingFactor(sulInputs);\n  }\n\n  // get LBM\n  let suvlbmFactor: number | undefined;\n  let suvlbmJenmaFactor: number | undefined;\n  if (PatientSize === null || PatientSize === undefined) {\n    console.warn(\n      'PatientSize value is missing. It is not possible to calculate the SUV lbm factors'\n    );\n  } else if (PatientSex === null || PatientSex === undefined) {\n    console.warn(\n      'PatientSex value is missing. It is not possible to calculate the SUV lbm factors'\n    );\n  } else {\n    const suvlbmInputs: SUVlbmScalingFactorInput = {\n      PatientWeight,\n      PatientSex,\n      PatientSize,\n    };\n\n    suvlbmFactor = calculateSUVlbmScalingFactor(suvlbmInputs);\n    suvlbmJenmaFactor = calculateSUVlbmJanmahasatianScalingFactor(suvlbmInputs);\n  }\n\n  return results.map(function(result, index) {\n    const factors: ScalingFactorResult = {\n      suvbw: result,\n    };\n\n    if (suvbsaFactor) {\n      // multiply for BSA\n      factors.suvbsa = decayCorrectionArray[index] * suvbsaFactor;\n    }\n\n    if (suvlbmFactor) {\n      // multiply for LBM\n      factors.suvlbm = decayCorrectionArray[index] * suvlbmFactor;\n    }\n\n    if (suvlbmJenmaFactor) {\n      factors.suvlbmJanma = decayCorrectionArray[index] * suvlbmJenmaFactor;\n    }\n\n    // factor formulaes taken from:\n    // https://www.medicalconnections.co.uk/kb/calculating-suv-from-pet-images/\n\n    return factors;\n  });\n}\n\nexport { calculateSUVScalingFactors };\n","import combineDateTime, { FullDateInterface } from './combineDateTime';\nimport parseDA, { DateInterface } from './parseDA';\nimport parseTM, { TimeInterface } from './parseTM';\nimport dateTimeToFullDateInterface from './dateTimeToFullDateInterface';\n\n/**\n * Javascript object with scan properties\n *\n * @interface InstanceMetadataForScanTimes\n */\ninterface InstanceMetadataForScanTimes {\n  SeriesDate: string;\n  SeriesTime: string;\n  AcquisitionDate: string;\n  AcquisitionTime: string;\n\n  GEPrivatePostInjectionDateTime?: string;\n\n  // Only used in Siemens case\n  RadionuclideHalfLife?: number; // \tRadionuclideHalfLife(0x0018,0x1075)\tin\tRadiopharmaceutical\tInformation\tSequence(0x0054,0x0016)\n  RadionuclideTotalDose?: number;\n  FrameReferenceTime?: number;\n  ActualFrameDuration?: number;\n}\n\n/**\n * Calculate the scan times\n *\n * @export\n * @param {InstanceMetadataForScanTimes[]} instances\n * @returns {FullDateInterface[]}\n */\nexport default function calculateScanTimes(\n  instances: InstanceMetadataForScanTimes[]\n): FullDateInterface[] {\n  const {\n    SeriesDate,\n    SeriesTime,\n    GEPrivatePostInjectionDateTime,\n  } = instances[0];\n  const results = new Array(instances.length);\n  const seriesDate: DateInterface = parseDA(SeriesDate);\n  const seriesTime: TimeInterface = parseTM(SeriesTime);\n  const seriesDateTime: FullDateInterface = combineDateTime(\n    seriesDate,\n    seriesTime\n  );\n\n  let earliestAcquisitionDateTime = new FullDateInterface(\n    `3000-01-01T00:00:00.000000Z`\n  );\n  let timeError = earliestAcquisitionDateTime.getTimeInSec();\n  instances.forEach(instance => {\n    const { AcquisitionDate, AcquisitionTime } = instance;\n\n    const acquisitionDate: DateInterface = parseDA(AcquisitionDate);\n    const acquisitionTime: TimeInterface = parseTM(AcquisitionTime);\n    const acquisitionDateTime: FullDateInterface = combineDateTime(\n      acquisitionDate,\n      acquisitionTime\n    );\n\n    if (earliestAcquisitionDateTime.getTimeInSec() >= timeError) {\n      earliestAcquisitionDateTime = acquisitionDateTime;\n    } else {\n      earliestAcquisitionDateTime =\n        acquisitionDateTime.getTimeInSec() <\n        earliestAcquisitionDateTime.getTimeInSec()\n          ? acquisitionDateTime\n          : earliestAcquisitionDateTime;\n    }\n  });\n\n  if (earliestAcquisitionDateTime.getTimeInSec() >= timeError) {\n    throw new Error('Earliest acquisition time or date could not be parsed.');\n  }\n\n  if (\n    seriesDateTime.getTimeInSec() <= earliestAcquisitionDateTime.getTimeInSec()\n  ) {\n    return results.fill(seriesDateTime);\n  } else {\n    if (GEPrivatePostInjectionDateTime) {\n      // GE Private scan\n      return results.fill(\n        dateTimeToFullDateInterface(GEPrivatePostInjectionDateTime)\n      );\n    } else {\n      /*const hasValidFrameTimes = instances.every(instance => {\n        return (\n          instance.FrameReferenceTime &&\n          instance.FrameReferenceTime > 0 &&\n          instance.ActualFrameDuration &&\n          instance.ActualFrameDuration > 0\n        );\n      });*/\n\n      // TODO: Temporarily commented out the checks and logic below to\n      // investigate the BQML_AC_DT_lessThan_S_DT_SIEMENS-instances case\n      //if (!hasValidFrameTimes) {\n      return results.fill(earliestAcquisitionDateTime);\n      //}\n\n      /* Siemens PETsyngo\t3.x\tmulti-injection logic\n      - backcompute\tfrom\tcenter\t(average\tcount\trate\t)\tof\ttime\twindow\tfor\tbed\tposition\t(frame)\tin\tseries (reliable\tin\tall\tcases)\n      - Acquisition\tDate\t(0x0008,0x0022)\tand\tTime\t(0x0008,0x0032) are\tthe\tstart\tof\tthe\tbed\tposition\t(frame)\n      - Frame\tReference\tTime\t(0x0054,0x1300) is\tthe\toffset\t(ms)\tfrom\tthe\tscan\tDate\tand\tTime we\twant\tto\tthe\taverage\tcount\trate\ttime\n      */\n      /*return instances.map(instance => {\n        const {\n          FrameReferenceTime,\n          ActualFrameDuration,\n          RadionuclideHalfLife,\n          AcquisitionDate,\n          AcquisitionTime,\n        } = instance;\n        // Some of these checks are only here because the compiler is complaining\n        // We could potentially use the ! operator instead\n        if (!FrameReferenceTime || FrameReferenceTime <= 0) {\n          throw new Error(\n            `FrameReferenceTime is invalid: ${FrameReferenceTime}`\n          );\n        }\n\n        if (!ActualFrameDuration || ActualFrameDuration <= 0) {\n          throw new Error(\n            `ActualFrameDuration is invalid: ${ActualFrameDuration}`\n          );\n        }\n\n        if (!RadionuclideHalfLife) {\n          throw new Error('RadionuclideHalfLife is required');\n        }\n\n        if (!AcquisitionDate) {\n          throw new Error('AcquisitionDate is required');\n        }\n\n        if (!AcquisitionTime) {\n          throw new Error('AcquisitionTime is required');\n        }\n\n        const acquisitionDate: DateInterface = parseDA(AcquisitionDate);\n        const acquisitionTime: TimeInterface = parseTM(AcquisitionTime);\n        const acquisitionDateTime: FullDateInterface = combineDateTime(\n          acquisitionDate,\n          acquisitionTime\n        );\n\n        const frameDurationInSec = ActualFrameDuration / 1000;\n        const decayConstant = Math.log(2) / RadionuclideHalfLife;\n        const decayDuringFrame = decayConstant * frameDurationInSec;\n        // TODO: double check this is correctly copied from QIBA pseudocode\n        const averageCountRateTimeWithinFrameInSec =\n          (1 / decayConstant) *\n          Math.log(decayDuringFrame / (1 - Math.exp(-decayConstant)));\n        const scanDateTimeAsNumber =\n          Number(acquisitionDateTime) -\n          FrameReferenceTime / 1000 +\n          averageCountRateTimeWithinFrameInSec;\n\n        const scanDate = new Date(scanDateTimeAsNumber);\n        console.log('SIEMENS PATH');\n        console.log(new Date(scanDateTimeAsNumber));\n        return scanDate;\n      });*/\n    }\n  }\n}\n\nexport { calculateScanTimes };\n","import combineDateTime, { FullDateInterface } from './combineDateTime';\nimport { parseDA, DateInterface } from './parseDA';\nimport { parseTM, TimeInterface } from './parseTM';\nimport dateTimeToFullDateInterface from './dateTimeToFullDateInterface';\n\n/**\n * Calculate start time\n *\n * @export\n * @param {{\n *   RadiopharmaceuticalStartDateTime?: string;\n *   RadiopharmaceuticalStartTime?: string;\n *   SeriesDate?: string;\n * }} input\n * @returns {FullDateInterface}\n */\nexport default function calculateStartTime(input: {\n  RadiopharmaceuticalStartDateTime?: string;\n  RadiopharmaceuticalStartTime?: string;\n  SeriesDate?: string;\n}): FullDateInterface {\n  const {\n    RadiopharmaceuticalStartDateTime,\n    RadiopharmaceuticalStartTime,\n    SeriesDate,\n  } = input;\n\n  let time: TimeInterface;\n  let date: DateInterface;\n  if (RadiopharmaceuticalStartDateTime) {\n    return dateTimeToFullDateInterface(RadiopharmaceuticalStartDateTime);\n  } else if (RadiopharmaceuticalStartTime && SeriesDate) {\n    // start Date\tis not explicit - assume\tsame as\tSeries Date;\n    // but consider\tspanning midnight\n    // TODO: do we need some logic to check if the scan went over midnight?\n    time = parseTM(RadiopharmaceuticalStartTime);\n    date = parseDA(SeriesDate);\n\n    return combineDateTime(date, time);\n  }\n\n  throw new Error(`Invalid input: ${input}`);\n}\n\nexport { calculateStartTime };\n","/**\n * Javascript object with patient properties size, sez, weight\n *\n * @export\n * @interface SUVbsaScalingFactorInput\n */\ninterface SUVbsaScalingFactorInput {\n  PatientSize: number;\n  PatientWeight: number;\n}\n\nfunction calculateSUVbsaScalingFactor(\n  inputs: SUVbsaScalingFactorInput\n): number {\n  const { PatientWeight, PatientSize } = inputs;\n\n  let BSA =\n    Math.pow(PatientWeight, 0.425) * Math.pow(PatientSize * 100, 0.725) * 71.84;\n\n  return BSA;\n}\n\nexport { calculateSUVbsaScalingFactor, SUVbsaScalingFactorInput };\n","/**\n * Javascript object with patient properties size, sez, weight\n *\n * @export\n * @interface SUVlbmScalingFactorInput\n */\ninterface SUVlbmScalingFactorInput {\n  PatientSize: number; // m\n  PatientSex: string; //'M' | 'F' | 'O';\n  PatientWeight: number; // Kg\n}\n\nfunction calculateSUVlbmScalingFactor(\n  inputs: SUVlbmScalingFactorInput\n): number {\n  const { PatientSex, PatientWeight, PatientSize } = inputs;\n\n  let LBM;\n  const weightSizeFactor = Math.pow(PatientWeight / (PatientSize * 100), 2);\n  // reference: https://www.medicalconnections.co.uk/kb/calculating-suv-from-pet-images/\n  if (PatientSex === 'F') {\n    LBM = 1.07 * PatientWeight - 148 * weightSizeFactor;\n  } else if (PatientSex === 'M') {\n    LBM = 1.1 * PatientWeight - 120 * weightSizeFactor;\n  } else {\n    throw new Error(`PatientSex is an invalid value: ${PatientSex}`);\n  }\n\n  return LBM * 1000; // convert in gr\n}\n\n/**\n * From https://link.springer.com/article/10.1007/s00259-014-2961-x\n * and https://link.springer.com/article/10.2165/00003088-200544100-00004\n * and\n * @param inputs\n * @returns\n */\nfunction calculateSUVlbmJanmahasatianScalingFactor(\n  inputs: SUVlbmScalingFactorInput\n): number {\n  const { PatientSex, PatientWeight, PatientSize } = inputs;\n\n  let LBM;\n  const bodyMassIndex = PatientWeight / Math.pow(PatientSize, 2);\n\n  if (PatientSex === 'F') {\n    LBM = (9270 * PatientWeight) / (8780 + 244 * bodyMassIndex);\n  } else if (PatientSex === 'M') {\n    LBM = (9270 * PatientWeight) / (6680 + 216 * bodyMassIndex);\n  } else {\n    throw new Error(`PatientSex is an invalid value: ${PatientSex}`);\n  }\n  return LBM * 1000; // convert in gr\n}\n\nexport {\n  calculateSUVlbmScalingFactor,\n  calculateSUVlbmJanmahasatianScalingFactor,\n  SUVlbmScalingFactorInput,\n};\n"],"names":["FullDateInterface","constructor","date","fullDate","getTimeInSec","dateString","this","substring","timeString","yyyy","parseInt","mm","length","undefined","dd","isNaN","Error","dateJS","Date","HH","MM","SS","fractionalStr","FFFFFF","Math","pow","timeInSec","getTime","getTimeInMicroSec","combineDateTime","time","hours","padStart","minutes","seconds","month","day","fractionalSeconds","padEnd","year","parseDA","d","m","y","daysInMonth","parseTM","hh","ss","ffffff","dateTimeToFullDateInterface","dateTime","instances","CorrectedImage","Units","PhilipsPETPrivateGroup","PatientWeight","PatientSex","PatientSize","includes","every","instance","a","b","Array","isArray","val","index","RadionuclideHalfLife","RadionuclideTotalDose","DecayCorrection","SeriesDate","SeriesTime","decayCorrectionArray","RadiopharmaceuticalStartDateTime","RadiopharmaceuticalStartTime","scanTimes","GEPrivatePostInjectionDateTime","results","seriesDateTime","earliestAcquisitionDateTime","timeError","forEach","AcquisitionDate","AcquisitionTime","acquisitionDateTime","fill","calculateScanTimes","startTime","input","calculateStartTime","map","_","decayTimeInSec","calculateDecayCorrection","weightInGrams","value","hasValidSUVScaleFactor","SUVScaleFactor","hasValidActivityConcentrationScaleFactor","_instance$PhilipsPETP4","ActivityConcentrationScaleFactor","JSON","stringify","suvbsaFactor","suvlbmFactor","suvlbmJenmaFactor","console","warn","inputs","calculateSUVbsaScalingFactor","suvlbmInputs","LBM","weightSizeFactor","calculateSUVlbmScalingFactor","bodyMassIndex","calculateSUVlbmJanmahasatianScalingFactor","result","factors","suvbw","suvbsa","suvlbm","suvlbmJanma"],"mappings":"0EASaA,EAQXC,YAAYC,QACLC,SAAWD,EASlBE,qBAEQC,EAAaC,KAAKH,SAASI,UAAU,EAAG,IACxCC,EAAaF,KAAKH,SAASI,UAAU,GAAI,IAGzCE,EAAOC,SAASL,EAAWE,UAAU,EAAG,GAAI,IAC5CI,EACJN,EAAWO,QAAU,EACjBF,SAASL,EAAWE,UAAU,EAAG,GAAI,SACrCM,EACAC,EACJT,EAAWO,QAAU,GACjBF,SAASL,EAAWE,UAAU,EAAG,IAAK,SACtCM,KAGJE,MAAMN,SACEI,IAAPF,GAAoBI,MAAMJ,SACnBE,IAAPC,GAAoBC,MAAMD,IAC3BL,EAAO,KACNE,IAAOA,EAAK,GAAKA,EAAK,KACtBG,IAAOA,EAAK,GAAKA,EAAK,UAEjB,IAAIE,uBAAuBX,YAG7BY,EAAS,IAAIC,KAAQb,uBAGrBc,EAAKT,SAASF,EAAWD,UAAU,EAAG,GAAI,IAC1Ca,EACJZ,EAAWI,QAAU,EACjBF,SAASF,EAAWD,UAAU,EAAG,GAAI,SACrCM,EACAQ,EACJb,EAAWI,QAAU,EACjBF,SAASF,EAAWD,UAAU,EAAG,GAAI,SACrCM,EACAS,EAAgBd,EAAWD,UAAU,EAAG,IACxCgB,EAASD,EACXZ,SAASY,EAAe,IAAME,KAAKC,IAAI,IAAKH,EAAcV,aAC1DC,KAGFE,MAAMI,SACEN,IAAPO,GAAoBL,MAAMK,SACnBP,IAAPQ,GAAoBN,MAAMM,SACfR,IAAXU,GAAwBR,MAAMQ,IAC/BJ,EAAK,GACLA,EAAK,IACJC,IAAOA,EAAK,GAAKA,EAAK,KACtBC,IAAOA,EAAK,GAAKA,EAAK,KACtBE,IAAWA,EAAS,GAAKA,EAAS,cAE7B,IAAIP,uBAAuBR,UAG/BkB,EAAYT,EAAOU,UAAY,WAEnCD,GAAkB,KAALP,OACFN,IAAPO,IACFM,GAAkB,GAALN,QAEJP,IAAPQ,IACFK,GAAaL,QAEAR,IAAXU,IACFG,GAAaH,GAGRG,EASTE,2BAC+C,IAAtBtB,KAAKF,yBAiBRyB,EACtB3B,EACA4B,SAEMC,OAAWD,EAAKC,OAAS,OAAOC,SAAS,EAAG,KAC5CC,OAAaH,EAAKG,SAAW,OAAOD,SAAS,EAAG,KAChDE,OAAaJ,EAAKI,SAAW,OAAOF,SAAS,EAAG,KAChDG,MAAWjC,EAAKiC,OAAQH,SAAS,EAAG,KACpCI,MAASlC,EAAKkC,KAAMJ,SAAS,EAAG,KAChCK,OAAuBP,EAAKO,mBAAqB,WAAWC,OAChE,EACA,YAMK,IAAItC,KAJWE,EAAKqC,QAAQJ,KAASC,KACrBL,KAASE,KAAWC,KAAWG,eCjFhCG,EAAQtC,MAE5BA,MAAAA,GAEgB,IAAhBA,EAAKU,QACW,iBAATV,QAED,IAAIc,qBAAqBd,YAG3BO,EAAOC,SAASR,EAAKK,UAAU,EAAG,GAAI,IACtCI,EAAKD,SAASR,EAAKK,UAAU,EAAG,GAAI,IACpCO,EAAKJ,SAASR,EAAKK,UAAU,EAAG,GAAI,OAER,IAzCfkC,EAyCH3B,EAzCc4B,EAyCV/B,EAzCqBgC,EAyCjBlC,GAvCpBM,MAAM4B,IAIHD,EAAI,GAAKA,GAAK,IAAMD,EAAI,GAAKA,GA7BtC,SAAqBC,EAAWC,UAEtBD,QACD,SACKC,EAAI,GAAM,GAAKA,EAAI,KAAQA,EAAI,KAAQ,EAAI,GAAK,QACrD,OACA,OACA,OACA,UACI,kBAEA,IAkB8BC,CAAYF,EAAGC,UAoChD,IAAI3B,qBAAqBd,MA1CnC,IAAqBuC,EAAWC,EAAWC,QA6ClC,CACLJ,KAAM9B,EACN0B,MAAOxB,EACPyB,IAAKtB,YC7De+B,EAAQf,MAE5BA,MAAAA,GAEAA,EAAKlB,OAAS,GACE,iBAATkB,QAGD,IAAId,qBAAqBc,YAK3BgB,EAAKpC,SAASoB,EAAKvB,UAAU,EAAG,GAAI,IACpCI,EAAKmB,EAAKlB,QAAU,EAAIF,SAASoB,EAAKvB,UAAU,EAAG,GAAI,SAAMM,EAC7DkC,EAAKjB,EAAKlB,QAAU,EAAIF,SAASoB,EAAKvB,UAAU,EAAG,GAAI,SAAMM,EAC7DS,EAAgBQ,EAAKlB,QAAU,EAAIkB,EAAKvB,UAAU,EAAG,SAAMM,EAC3DmC,EAAS1B,EACXZ,SAASY,EAAe,IAAME,KAAKC,IAAI,GAAI,EAAIH,EAAcV,aAC7DC,KAGFE,MAAM+B,SACEjC,IAAPF,GAAoBI,MAAMJ,SACnBE,IAAPkC,GAAoBhC,MAAMgC,SACflC,IAAXmC,GAAwBjC,MAAMiC,IAC/BF,EAAK,GACLA,EAAK,IACJnC,IAAOA,EAAK,GAAKA,EAAK,KACtBoC,IAAOA,EAAK,GAAKA,EAAK,KACtBC,IAAWA,EAAS,GAAKA,EAAS,cAE7B,IAAIhC,qBAAqBc,YAG1B,CACLC,MAAOe,EACPb,QAAStB,EACTuB,QAASa,EACTV,kBAAmBW,YC9CCC,EACtBC,MAEIA,MAAAA,QACI,IAAIlC,MAAM,8DAKXa,EAFMW,EAAQU,EAAS3C,UAAU,EAAG,IAC9BsC,EAAQK,EAAS3C,UAAU,iDCyFxC4C,SAEMC,eACJA,EADIC,MAEJA,EAFIC,uBAGJA,EAHIC,cAIJA,EAJIC,WAKJA,EALIC,YAMJA,GACEN,EAAU,OAETC,EAAeM,SAAS,UAAYN,EAAeM,SAAS,cACzD,IAAI1C,wDAC0CoC,OAO/BD,EAAUQ,MAAMC,WAEnCA,EAASP,QAAUA,KA7CvBQ,EA8CeD,EAASR,mBA7CxBU,EA6CwCV,IAzCrCW,MAAMC,QAAQH,IACbE,MAAMC,QAAQF,IACdD,EAAEjD,SAAWkD,EAAElD,QACfiD,EAAEF,MAAM,CAACM,EAAKC,IAAUD,IAAQH,EAAEI,MAuClCN,EAASL,gBAAkBA,GAC3BK,EAASJ,aAAeA,GACxBI,EAASH,cAAgBA,GACzBG,EAASO,uBAAyBhB,EAAU,GAAGgB,sBAC/CP,EAASQ,wBAA0BjB,EAAU,GAAGiB,uBAChDR,EAASS,kBAAoBlB,EAAU,GAAGkB,iBAC1CT,EAASU,aAAenB,EAAU,GAAGmB,YACrCV,EAASW,aAAepB,EAAU,GAAGoB,WAvDxB,IACjBV,EACAC,UA0DQ,IAAI9C,MACR,oJAKCuC,QACG,IAAIvC,MACR,uFAIAwD,EAAiC,IAAIT,MAAMZ,EAAUvC,QACzD4D,EA3HF,SAAkCrB,SAC1BiB,sBACJA,EADID,qBAEJA,EAFIM,iCAGJA,EAHIC,6BAIJA,EAJIJ,WAKJA,GACEnB,EAAU,MAEViB,MAAAA,QACI,IAAIpD,MACR,wEAIAmD,MAAAA,QACI,IAAInD,MACR,0EAIE2D,WCtBNxB,SAEMmB,WACJA,EADIC,WAEJA,EAFIK,+BAGJA,GACEzB,EAAU,GACR0B,EAAU,IAAId,MAAMZ,EAAUvC,QAG9BkE,EAAoCjD,EAFRW,EAAQ8B,GACRzB,EAAQ0B,QAMtCQ,EAA8B,IAAI/E,iCAGlCgF,EAAYD,EAA4B3E,kBAC5C+C,EAAU8B,QAAQrB,UACVsB,gBAAEA,EAAFC,gBAAmBA,GAAoBvB,EAIvCwB,EAAyCvD,EAFRW,EAAQ0C,GACRrC,EAAQsC,IAO7CJ,EADEA,EAA4B3E,gBAAkB4E,GAI9CI,EAAoBhF,eACpB2E,EAA4B3E,eAJAgF,EAMxBL,IAINA,EAA4B3E,gBAAkB4E,QAC1C,IAAIhE,MAAM,iEAIhB8D,EAAe1E,gBAAkB2E,EAA4B3E,eAEtDyE,EAAQQ,KAAKP,GAIXD,EAAQQ,KAFbT,EAGA3B,EAA4B2B,GAeVG,GD7CeO,CAAmBnC,GACpDoC,WExCmCC,SAKnCf,iCACJA,EADIC,6BAEJA,EAFIJ,WAGJA,GACEkB,MAEA1D,EACA5B,KACAuE,SACKxB,EAA4BwB,GAC9B,GAAIC,GAAgCJ,SAIzCxC,EAAOe,EAAQ6B,GACfxE,EAAOsC,EAAQ8B,GAERzC,EAAgB3B,EAAM4B,SAGzB,IAAId,wBAAwBwE,GFeGC,CAAmB,CACtDhB,iCAAAA,EACAC,6BAAAA,EACAJ,WAAAA,WAGKnB,EAAUuC,IAAI,CAACC,EAAGzB,WAEjB0B,EADWjB,EAAUT,GAEhB9D,eAAiBmF,EAAUnF,kBAClCwF,EAAiB,QACb,IAAI5E,MAAM,8CAOX,GAHLoD,EACA5C,KAAKC,IAAI,GAAImE,EAAiBzB,MAqFX0B,CAAyB1C,OAE5C0B,EAAoB,IAAId,MAAMZ,EAAUvC,cACtCkF,EAAwC,IAAhBvC,KAEhB,SAAVF,EACFwB,EAAUL,EAAqBkB,KAAI,SAASK,UACnCA,EAAQD,UAEZ,GAAc,SAAVzC,EAAkB,OACrB2C,EAAkC7C,EAAUQ,MAAMC,qBAEpDA,EAASN,wBAC2C,kBAApDM,EAASN,6CAAwB2C,sBACmBpF,eAApD+C,EAASN,6CAAwB2C,iBACmB,eAApDrC,EAASN,6CAAwB2C,kBAI/BC,EAAoD/C,EAAUQ,MAClEC,qBAEIA,EAASN,oCACRM,EAASN,qCAAT6C,EAAiCF,sBAEhCpF,eADF+C,EAASN,6CAAwB8C,mCAG/B,eADFxC,EAASN,6CAAwB8C,uCASnCJ,EACFnB,EAAU1B,EAAUuC,IAGlB9B,GAAYA,EAASN,uBAAwB2C,oBAE1C,CAAA,IAAIC,QAaH,IAAIlF,2EAC6DqF,KAAKC,UACxEhD,IAZJuB,EAAU1B,EAAUuC,IAAI,CAAC9B,EAAUM,IAI/BN,EAASN,uBAAwB8C,iCACjC5B,EAAqBN,GACrB4B,QAUD,CAAA,GAAc,QAAVzC,QAIH,IAAIrC,qCAAqCqC,GAF/CwB,EAAQQ,KAAK,OAMXkB,EAeAC,EACAC,KAfAhD,MAAAA,EACFiD,QAAQC,KACN,qFAQFJ,EGjOJ,SACEK,SAEMrD,cAAEA,EAAFE,YAAiBA,GAAgBmD,SAGrCpF,KAAKC,IAAI8B,EAAe,MAAS/B,KAAKC,IAAkB,IAAdgC,EAAmB,MAAS,MH2NvDoD,CAL6B,CAC1CtD,cAAAA,EACAE,YAAAA,IASAA,MAAAA,EACFiD,QAAQC,KACN,0FAEG,GAAInD,MAAAA,EACTkD,QAAQC,KACN,wFAEG,OACCG,EAAyC,CAC7CvD,cAAAA,EACAC,WAAAA,EACAC,YAAAA,GAGF+C,EIrPJ,SACEI,SAEMpD,WAAEA,EAAFD,cAAcA,EAAdE,YAA6BA,GAAgBmD,MAE/CG,QACEC,EAAmBxF,KAAKC,IAAI8B,GAA+B,IAAdE,GAAoB,MAEpD,MAAfD,EACFuD,EAAM,KAAOxD,EAAgB,IAAMyD,MAC9B,CAAA,GAAmB,MAAfxD,QAGH,IAAIxC,yCAAyCwC,GAFnDuD,EAAM,IAAMxD,EAAgB,IAAMyD,SAKvB,IAAND,EJqOUE,CAA6BH,GAC5CL,EI5NJ,SACEG,SAEMpD,WAAEA,EAAFD,cAAcA,EAAdE,YAA6BA,GAAgBmD,MAE/CG,QACEG,EAAgB3D,EAAgB/B,KAAKC,IAAIgC,EAAa,MAEzC,MAAfD,EACFuD,EAAO,KAAOxD,GAAkB,KAAO,IAAM2D,OACxC,CAAA,GAAmB,MAAf1D,QAGH,IAAIxC,yCAAyCwC,GAFnDuD,EAAO,KAAOxD,GAAkB,KAAO,IAAM2D,UAIlC,IAANH,EJ6MeI,CAA0CL,UAGzDjC,EAAQa,KAAI,SAAS0B,EAAQlD,SAC5BmD,EAA+B,CACnCC,MAAOF,UAGLb,IAEFc,EAAQE,OAAS/C,EAAqBN,GAASqC,GAG7CC,IAEFa,EAAQG,OAAShD,EAAqBN,GAASsC,GAG7CC,IACFY,EAAQI,YAAcjD,EAAqBN,GAASuC,GAM/CY"}