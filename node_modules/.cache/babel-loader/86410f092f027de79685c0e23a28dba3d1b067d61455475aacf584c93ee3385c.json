{"ast":null,"code":"import { m as macro } from '../../macros2.js';\nimport { CellTypesStrings, CellType } from './CellTypes/Constants.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n/**\n * Given an int (as defined in vtkCellType.h) identifier for a class\n * return it's classname.\n */\nfunction getClassNameFromTypeId(typeId) {\n  return typeId < CellTypesStrings.length ? CellTypesStrings[typeId] : 'UnknownClass';\n}\n\n/**\n * Given a data object classname, return it's int identified (as\n * defined in vtkCellType.h)\n */\nfunction getTypeIdFromClassName(cellTypeString) {\n  return CellTypesStrings.findIndex(cellTypeString);\n}\n\n/**\n * This convenience method is a fast check to determine if a cell type\n * represents a linear or nonlinear cell.  This is generally much more\n * efficient than getting the appropriate vtkCell and checking its IsLinear\n * method.\n */\nfunction isLinear(type) {\n  return type < CellType.VTK_QUADRATIC_EDGE || type === CellType.VTK_CONVEX_POINT_SET || type === CellType.VTK_POLYHEDRON;\n}\nfunction hasSubCells(cellType) {\n  return cellType === CellType.VTK_TRIANGLE_STRIP || cellType === CellType.VTK_POLY_LINE || cellType === CellType.VTK_POLY_VERTEX;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  getClassNameFromTypeId,\n  getTypeIdFromClassName,\n  isLinear,\n  hasSubCells\n};\n\n// ----------------------------------------------------------------------------\n// vtkCellTypes methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellTypes(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellTypes');\n\n  /**\n   * Allocate memory for this array. Delete old storage only if necessary.\n   */\n  publicAPI.allocate = function () {\n    let sz = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 512;\n    let ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    model.size = sz > 0 ? sz : 1;\n    model.extend = ext > 0 ? ext : 1;\n    model.maxId = -1;\n    model.typeArray = new Uint8Array(sz);\n    model.locationArray = new Uint32Array(sz);\n  };\n\n  /**\n   * Add a cell at specified id.\n   */\n  publicAPI.insertCell = (cellId, type, loc) => {\n    model.typeArray[cellId] = type;\n    model.locationArray[cellId] = loc;\n    if (cellId > model.maxId) {\n      model.maxId = cellId;\n    }\n  };\n\n  /**\n   * Add a cell to the object in the next available slot.\n   */\n  publicAPI.insertNextCell = (type, loc) => {\n    publicAPI.insertCell(++model.maxId, type, loc);\n    return model.maxId;\n  };\n\n  /**\n   * Specify a group of cell types. This version is provided to maintain\n   * backwards compatibility and does a copy of the cellLocations\n   */\n  publicAPI.setCellTypes = (ncells, cellTypes, cellLocations) => {\n    model.size = ncells;\n    model.typeArray = cellTypes;\n    model.locationArray = cellLocations;\n    model.maxId = ncells - 1;\n  };\n\n  /**\n   * Return the location of the cell in the associated vtkCellArray.\n   */\n  publicAPI.getCellLocation = cellId => model.locationArray[cellId];\n\n  /**\n   * Delete cell by setting to nullptr cell type.\n   */\n  publicAPI.deleteCell = cellId => {\n    model.typeArray[cellId] = CellType.VTK_EMPTY_CELL;\n  };\n\n  /**\n   * Return the number of types in the list.\n   */\n  publicAPI.getNumberOfTypes = () => model.maxId + 1;\n\n  /**\n   * Return true if type specified is contained in list; false otherwise.\n   */\n  publicAPI.isType = type => {\n    const numTypes = publicAPI.getNumberOfTypes();\n    for (let i = 0; i < numTypes; ++i) {\n      if (type === publicAPI.getCellType(i)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Add the type specified to the end of the list. Range checking is performed.\n   */\n  publicAPI.insertNextType = type => publicAPI.insertNextCell(type, -1);\n\n  /**\n   * Return the type of cell.\n   */\n  publicAPI.getCellType = cellId => model.typeArray[cellId];\n\n  /**\n   * Reclaim any extra memory.\n   */\n  // TODO: publicAPI.squeeze = () =>  {};\n\n  /**\n   * Initialize object without releasing memory.\n   */\n  publicAPI.reset = () => {\n    model.maxId = -1;\n  };\n\n  /**\n   * Standard DeepCopy method.  Since this object contains no reference\n   * to other objects, there is no ShallowCopy.\n   */\n  publicAPI.deepCopy = src => {\n    publicAPI.allocate(src.getSize(), src.getExtend());\n    model.typeArray.set(src.getTypeArray());\n    model.locationArray.set(src.getLocationArray());\n    model.maxId = src.getMaxId();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // typeArray: null, // pointer to types array\n  // locationArray: null;   // pointer to array of offsets\n  size: 0,\n  // allocated size of data\n  maxId: -1,\n  // maximum index inserted thus far\n  extend: 1000 // grow array by this point\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['size', 'maxId', 'extend']);\n  macro.getArray(publicAPI, model, ['typeArray', 'locationArray']);\n  vtkCellTypes(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCellTypes');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellTypes$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\nexport { STATIC, vtkCellTypes$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","CellTypesStrings","CellType","getClassNameFromTypeId","typeId","length","getTypeIdFromClassName","cellTypeString","findIndex","isLinear","type","VTK_QUADRATIC_EDGE","VTK_CONVEX_POINT_SET","VTK_POLYHEDRON","hasSubCells","cellType","VTK_TRIANGLE_STRIP","VTK_POLY_LINE","VTK_POLY_VERTEX","STATIC","vtkCellTypes","publicAPI","model","classHierarchy","push","allocate","sz","arguments","undefined","ext","size","extend","maxId","typeArray","Uint8Array","locationArray","Uint32Array","insertCell","cellId","loc","insertNextCell","setCellTypes","ncells","cellTypes","cellLocations","getCellLocation","deleteCell","VTK_EMPTY_CELL","getNumberOfTypes","isType","numTypes","i","getCellType","insertNextType","reset","deepCopy","src","getSize","getExtend","set","getTypeArray","getLocationArray","getMaxId","DEFAULT_VALUES","initialValues","Object","assign","obj","get","getArray","newInstance","vtkCellTypes$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Common/DataModel/CellTypes.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport { CellTypesStrings, CellType } from './CellTypes/Constants.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n/**\n * Given an int (as defined in vtkCellType.h) identifier for a class\n * return it's classname.\n */\nfunction getClassNameFromTypeId(typeId) {\n  return typeId < CellTypesStrings.length ? CellTypesStrings[typeId] : 'UnknownClass';\n}\n\n/**\n * Given a data object classname, return it's int identified (as\n * defined in vtkCellType.h)\n */\nfunction getTypeIdFromClassName(cellTypeString) {\n  return CellTypesStrings.findIndex(cellTypeString);\n}\n\n/**\n * This convenience method is a fast check to determine if a cell type\n * represents a linear or nonlinear cell.  This is generally much more\n * efficient than getting the appropriate vtkCell and checking its IsLinear\n * method.\n */\nfunction isLinear(type) {\n  return type < CellType.VTK_QUADRATIC_EDGE || type === CellType.VTK_CONVEX_POINT_SET || type === CellType.VTK_POLYHEDRON;\n}\nfunction hasSubCells(cellType) {\n  return cellType === CellType.VTK_TRIANGLE_STRIP || cellType === CellType.VTK_POLY_LINE || cellType === CellType.VTK_POLY_VERTEX;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  getClassNameFromTypeId,\n  getTypeIdFromClassName,\n  isLinear,\n  hasSubCells\n};\n\n// ----------------------------------------------------------------------------\n// vtkCellTypes methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellTypes(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellTypes');\n\n  /**\n   * Allocate memory for this array. Delete old storage only if necessary.\n   */\n  publicAPI.allocate = function () {\n    let sz = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 512;\n    let ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    model.size = sz > 0 ? sz : 1;\n    model.extend = ext > 0 ? ext : 1;\n    model.maxId = -1;\n    model.typeArray = new Uint8Array(sz);\n    model.locationArray = new Uint32Array(sz);\n  };\n\n  /**\n   * Add a cell at specified id.\n   */\n  publicAPI.insertCell = (cellId, type, loc) => {\n    model.typeArray[cellId] = type;\n    model.locationArray[cellId] = loc;\n    if (cellId > model.maxId) {\n      model.maxId = cellId;\n    }\n  };\n\n  /**\n   * Add a cell to the object in the next available slot.\n   */\n  publicAPI.insertNextCell = (type, loc) => {\n    publicAPI.insertCell(++model.maxId, type, loc);\n    return model.maxId;\n  };\n\n  /**\n   * Specify a group of cell types. This version is provided to maintain\n   * backwards compatibility and does a copy of the cellLocations\n   */\n  publicAPI.setCellTypes = (ncells, cellTypes, cellLocations) => {\n    model.size = ncells;\n    model.typeArray = cellTypes;\n    model.locationArray = cellLocations;\n    model.maxId = ncells - 1;\n  };\n\n  /**\n   * Return the location of the cell in the associated vtkCellArray.\n   */\n  publicAPI.getCellLocation = cellId => model.locationArray[cellId];\n\n  /**\n   * Delete cell by setting to nullptr cell type.\n   */\n  publicAPI.deleteCell = cellId => {\n    model.typeArray[cellId] = CellType.VTK_EMPTY_CELL;\n  };\n\n  /**\n   * Return the number of types in the list.\n   */\n  publicAPI.getNumberOfTypes = () => model.maxId + 1;\n\n  /**\n   * Return true if type specified is contained in list; false otherwise.\n   */\n  publicAPI.isType = type => {\n    const numTypes = publicAPI.getNumberOfTypes();\n    for (let i = 0; i < numTypes; ++i) {\n      if (type === publicAPI.getCellType(i)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Add the type specified to the end of the list. Range checking is performed.\n   */\n  publicAPI.insertNextType = type => publicAPI.insertNextCell(type, -1);\n\n  /**\n   * Return the type of cell.\n   */\n  publicAPI.getCellType = cellId => model.typeArray[cellId];\n\n  /**\n   * Reclaim any extra memory.\n   */\n  // TODO: publicAPI.squeeze = () =>  {};\n\n  /**\n   * Initialize object without releasing memory.\n   */\n  publicAPI.reset = () => {\n    model.maxId = -1;\n  };\n\n  /**\n   * Standard DeepCopy method.  Since this object contains no reference\n   * to other objects, there is no ShallowCopy.\n   */\n  publicAPI.deepCopy = src => {\n    publicAPI.allocate(src.getSize(), src.getExtend());\n    model.typeArray.set(src.getTypeArray());\n    model.locationArray.set(src.getLocationArray());\n    model.maxId = src.getMaxId();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // typeArray: null, // pointer to types array\n  // locationArray: null;   // pointer to array of offsets\n  size: 0,\n  // allocated size of data\n  maxId: -1,\n  // maximum index inserted thus far\n  extend: 1000 // grow array by this point\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['size', 'maxId', 'extend']);\n  macro.getArray(publicAPI, model, ['typeArray', 'locationArray']);\n  vtkCellTypes(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCellTypes');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellTypes$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkCellTypes$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}