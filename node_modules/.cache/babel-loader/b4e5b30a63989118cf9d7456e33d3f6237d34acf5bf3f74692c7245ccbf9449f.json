{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkOpenGLFramebuffer from './Framebuffer.js';\nimport vtkRenderPass from '../SceneGraph/RenderPass.js';\nimport vtkOpenGLOrderIndependentTranslucentPass from './OrderIndependentTranslucentPass.js';\n\n// ----------------------------------------------------------------------------\n\nfunction vtkForwardPass(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkForwardPass');\n\n  // this pass implements a forward rendering pipeline\n  // if both volumes and opaque geometry are present\n  // it will mix the two together by capturing a zbuffer\n  // first\n  publicAPI.traverse = function (viewNode) {\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (model.deleted) {\n      return;\n    }\n\n    // we just render our delegates in order\n    model._currentParent = parent;\n\n    // build\n    publicAPI.setCurrentOperation('buildPass');\n    viewNode.traverse(publicAPI);\n    const numlayers = viewNode.getRenderable().getNumberOfLayers();\n\n    // iterate over renderers\n    const renderers = viewNode.getChildren();\n    for (let i = 0; i < numlayers; i++) {\n      for (let index = 0; index < renderers.length; index++) {\n        const renNode = renderers[index];\n        const ren = viewNode.getRenderable().getRenderers()[index];\n        if (ren.getDraw() && ren.getLayer() === i) {\n          // check for both opaque and volume actors\n          model.opaqueActorCount = 0;\n          model.translucentActorCount = 0;\n          model.volumeCount = 0;\n          model.overlayActorCount = 0;\n          publicAPI.setCurrentOperation('queryPass');\n          renNode.traverse(publicAPI);\n\n          // do we need to capture a zbuffer?\n          if ((model.opaqueActorCount > 0 || model.translucentActorCount > 0) && model.volumeCount > 0 || model.depthRequested) {\n            const size = viewNode.getFramebufferSize();\n            // make sure the framebuffer is setup\n            if (model.framebuffer === null) {\n              model.framebuffer = vtkOpenGLFramebuffer.newInstance();\n            }\n            model.framebuffer.setOpenGLRenderWindow(viewNode);\n            model.framebuffer.saveCurrentBindingsAndBuffers();\n            const fbSize = model.framebuffer.getSize();\n            if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {\n              model.framebuffer.create(size[0], size[1]);\n              model.framebuffer.populateFramebuffer();\n            }\n            model.framebuffer.bind();\n            // opaqueZBufferPass only renders opaque actors\n            // zBufferPass renders both translucent and opaque actors\n            // we want to be able to pick translucent actors\n            publicAPI.setCurrentOperation('zBufferPass');\n            renNode.traverse(publicAPI);\n            model.framebuffer.restorePreviousBindingsAndBuffers();\n\n            // reset now that we have done it\n            model.depthRequested = false;\n          }\n          publicAPI.setCurrentOperation('cameraPass');\n          renNode.traverse(publicAPI);\n          if (model.opaqueActorCount > 0) {\n            publicAPI.setCurrentOperation('opaquePass');\n            renNode.traverse(publicAPI);\n          }\n          if (model.translucentActorCount > 0) {\n            if (!model.translucentPass) {\n              model.translucentPass = vtkOpenGLOrderIndependentTranslucentPass.newInstance();\n            }\n            model.translucentPass.traverse(viewNode, renNode, publicAPI);\n          }\n          if (model.volumeCount > 0) {\n            publicAPI.setCurrentOperation('volumePass');\n            renNode.traverse(publicAPI);\n          }\n          if (model.overlayActorCount > 0) {\n            publicAPI.setCurrentOperation('overlayPass');\n            renNode.traverse(publicAPI);\n          }\n        }\n      }\n    }\n  };\n  publicAPI.getZBufferTexture = () => {\n    if (model.framebuffer) {\n      return model.framebuffer.getColorTexture();\n    }\n    return null;\n  };\n  publicAPI.requestDepth = () => {\n    model.depthRequested = true;\n  };\n  publicAPI.incrementOpaqueActorCount = () => model.opaqueActorCount++;\n  publicAPI.incrementTranslucentActorCount = () => model.translucentActorCount++;\n  publicAPI.incrementVolumeCount = () => model.volumeCount++;\n  publicAPI.incrementOverlayActorCount = () => model.overlayActorCount++;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  opaqueActorCount: 0,\n  translucentActorCount: 0,\n  volumeCount: 0,\n  overlayActorCount: 0,\n  framebuffer: null,\n  depthRequested: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  vtkRenderPass.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['framebuffer', 'opaqueActorCount', 'translucentActorCount', 'volumeCount']);\n\n  // Object methods\n  vtkForwardPass(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkForwardPass');\n\n// ----------------------------------------------------------------------------\n\nvar vtkForwardPass$1 = {\n  newInstance,\n  extend\n};\nexport { vtkForwardPass$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkOpenGLFramebuffer","vtkRenderPass","vtkOpenGLOrderIndependentTranslucentPass","vtkForwardPass","publicAPI","model","classHierarchy","push","traverse","viewNode","parent","arguments","length","undefined","deleted","_currentParent","setCurrentOperation","numlayers","getRenderable","getNumberOfLayers","renderers","getChildren","i","index","renNode","ren","getRenderers","getDraw","getLayer","opaqueActorCount","translucentActorCount","volumeCount","overlayActorCount","depthRequested","size","getFramebufferSize","framebuffer","newInstance","setOpenGLRenderWindow","saveCurrentBindingsAndBuffers","fbSize","getSize","create","populateFramebuffer","bind","restorePreviousBindingsAndBuffers","translucentPass","getZBufferTexture","getColorTexture","requestDepth","incrementOpaqueActorCount","incrementTranslucentActorCount","incrementVolumeCount","incrementOverlayActorCount","DEFAULT_VALUES","extend","initialValues","Object","assign","get","vtkForwardPass$1","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/OpenGL/ForwardPass.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkOpenGLFramebuffer from './Framebuffer.js';\nimport vtkRenderPass from '../SceneGraph/RenderPass.js';\nimport vtkOpenGLOrderIndependentTranslucentPass from './OrderIndependentTranslucentPass.js';\n\n// ----------------------------------------------------------------------------\n\nfunction vtkForwardPass(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkForwardPass');\n\n  // this pass implements a forward rendering pipeline\n  // if both volumes and opaque geometry are present\n  // it will mix the two together by capturing a zbuffer\n  // first\n  publicAPI.traverse = function (viewNode) {\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (model.deleted) {\n      return;\n    }\n\n    // we just render our delegates in order\n    model._currentParent = parent;\n\n    // build\n    publicAPI.setCurrentOperation('buildPass');\n    viewNode.traverse(publicAPI);\n    const numlayers = viewNode.getRenderable().getNumberOfLayers();\n\n    // iterate over renderers\n    const renderers = viewNode.getChildren();\n    for (let i = 0; i < numlayers; i++) {\n      for (let index = 0; index < renderers.length; index++) {\n        const renNode = renderers[index];\n        const ren = viewNode.getRenderable().getRenderers()[index];\n        if (ren.getDraw() && ren.getLayer() === i) {\n          // check for both opaque and volume actors\n          model.opaqueActorCount = 0;\n          model.translucentActorCount = 0;\n          model.volumeCount = 0;\n          model.overlayActorCount = 0;\n          publicAPI.setCurrentOperation('queryPass');\n          renNode.traverse(publicAPI);\n\n          // do we need to capture a zbuffer?\n          if ((model.opaqueActorCount > 0 || model.translucentActorCount > 0) && model.volumeCount > 0 || model.depthRequested) {\n            const size = viewNode.getFramebufferSize();\n            // make sure the framebuffer is setup\n            if (model.framebuffer === null) {\n              model.framebuffer = vtkOpenGLFramebuffer.newInstance();\n            }\n            model.framebuffer.setOpenGLRenderWindow(viewNode);\n            model.framebuffer.saveCurrentBindingsAndBuffers();\n            const fbSize = model.framebuffer.getSize();\n            if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {\n              model.framebuffer.create(size[0], size[1]);\n              model.framebuffer.populateFramebuffer();\n            }\n            model.framebuffer.bind();\n            // opaqueZBufferPass only renders opaque actors\n            // zBufferPass renders both translucent and opaque actors\n            // we want to be able to pick translucent actors\n            publicAPI.setCurrentOperation('zBufferPass');\n            renNode.traverse(publicAPI);\n            model.framebuffer.restorePreviousBindingsAndBuffers();\n\n            // reset now that we have done it\n            model.depthRequested = false;\n          }\n          publicAPI.setCurrentOperation('cameraPass');\n          renNode.traverse(publicAPI);\n          if (model.opaqueActorCount > 0) {\n            publicAPI.setCurrentOperation('opaquePass');\n            renNode.traverse(publicAPI);\n          }\n          if (model.translucentActorCount > 0) {\n            if (!model.translucentPass) {\n              model.translucentPass = vtkOpenGLOrderIndependentTranslucentPass.newInstance();\n            }\n            model.translucentPass.traverse(viewNode, renNode, publicAPI);\n          }\n          if (model.volumeCount > 0) {\n            publicAPI.setCurrentOperation('volumePass');\n            renNode.traverse(publicAPI);\n          }\n          if (model.overlayActorCount > 0) {\n            publicAPI.setCurrentOperation('overlayPass');\n            renNode.traverse(publicAPI);\n          }\n        }\n      }\n    }\n  };\n  publicAPI.getZBufferTexture = () => {\n    if (model.framebuffer) {\n      return model.framebuffer.getColorTexture();\n    }\n    return null;\n  };\n  publicAPI.requestDepth = () => {\n    model.depthRequested = true;\n  };\n  publicAPI.incrementOpaqueActorCount = () => model.opaqueActorCount++;\n  publicAPI.incrementTranslucentActorCount = () => model.translucentActorCount++;\n  publicAPI.incrementVolumeCount = () => model.volumeCount++;\n  publicAPI.incrementOverlayActorCount = () => model.overlayActorCount++;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  opaqueActorCount: 0,\n  translucentActorCount: 0,\n  volumeCount: 0,\n  overlayActorCount: 0,\n  framebuffer: null,\n  depthRequested: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  vtkRenderPass.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['framebuffer', 'opaqueActorCount', 'translucentActorCount', 'volumeCount']);\n\n  // Object methods\n  vtkForwardPass(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkForwardPass');\n\n// ----------------------------------------------------------------------------\n\nvar vtkForwardPass$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkForwardPass$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}