{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { m as macro } from '../../macros2.js';\nimport { ObjectType } from './BufferObject/Constants.js';\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLVertexArrayObject methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLVertexArrayObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLVertexArrayObject');\n\n  // Public API methods\n  publicAPI.exposedMethod = () => {\n    // This is a publicly exposed method of this object\n  };\n  publicAPI.initialize = () => {\n    model.instancingExtension = null;\n    if (!model._openGLRenderWindow.getWebgl2()) {\n      model.instancingExtension = model.context.getExtension('ANGLE_instanced_arrays');\n    }\n    if (!model.forceEmulation && model._openGLRenderWindow && model._openGLRenderWindow.getWebgl2()) {\n      model.extension = null;\n      model.supported = true;\n      model.handleVAO = model.context.createVertexArray();\n    } else {\n      model.extension = model.context.getExtension('OES_vertex_array_object');\n      // Start setting up VAO\n      if (!model.forceEmulation && model.extension) {\n        model.supported = true;\n        model.handleVAO = model.extension.createVertexArrayOES();\n      } else {\n        model.supported = false;\n      }\n    }\n  };\n  publicAPI.isReady = () =>\n  // We either probed and allocated a VAO, or are falling back as the current\n  // hardware does not support VAOs.\n  model.handleVAO !== 0 || model.supported === false;\n  publicAPI.bind = () => {\n    // Either simply bind the VAO, or emulate behavior by binding all attributes.\n    if (!publicAPI.isReady()) {\n      publicAPI.initialize();\n    }\n    if (publicAPI.isReady() && model.supported) {\n      if (model.extension) {\n        model.extension.bindVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.bindVertexArray(model.handleVAO);\n      }\n    } else if (publicAPI.isReady()) {\n      const gl = model.context;\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);\n        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          const attrIt = buff.attributes[iatt];\n          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;\n          for (let i = 0; i < matrixCount; ++i) {\n            gl.enableVertexAttribArray(attrIt.index + i);\n            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);\n            if (attrIt.divisor > 0) {\n              if (model.instancingExtension) {\n                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 1);\n              } else {\n                gl.vertexAttribDivisor(attrIt.index + i, 1);\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n  publicAPI.release = () => {\n    // Either simply release the VAO, or emulate behavior by releasing all attributes.\n    if (publicAPI.isReady() && model.supported) {\n      if (model.extension) {\n        model.extension.bindVertexArrayOES(null);\n      } else {\n        model.context.bindVertexArray(null);\n      }\n    } else if (publicAPI.isReady()) {\n      const gl = model.context;\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);\n        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          const attrIt = buff.attributes[iatt];\n          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;\n          for (let i = 0; i < matrixCount; ++i) {\n            gl.enableVertexAttribArray(attrIt.index + i);\n            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);\n            if (attrIt.divisor > 0) {\n              if (model.instancingExtension) {\n                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 0);\n              } else {\n                gl.vertexAttribDivisor(attrIt.index + i, 0);\n              }\n            }\n            gl.disableVertexAttribArray(attrIt.index + i);\n          }\n        }\n      }\n    }\n  };\n  publicAPI.shaderProgramChanged = () => {\n    publicAPI.release();\n    if (model.handleVAO) {\n      if (model.extension) {\n        model.extension.deleteVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.deleteVertexArray(model.handleVAO);\n      }\n    }\n    model.handleVAO = 0;\n    model.handleProgram = 0;\n  };\n  publicAPI.releaseGraphicsResources = () => {\n    publicAPI.shaderProgramChanged();\n    if (model.handleVAO) {\n      if (model.extension) {\n        model.extension.deleteVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.deleteVertexArray(model.handleVAO);\n      }\n    }\n    model.handleVAO = 0;\n    model.supported = true;\n    model.handleProgram = 0;\n  };\n  publicAPI.addAttributeArray = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize) => publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, 0, false);\n  publicAPI.addAttributeArrayWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, isMatrix) => {\n    if (!program) {\n      return false;\n    }\n\n    // Check the program is bound, and the buffer is valid.\n    if (!program.isBound() || buffer.getHandle() === 0 || buffer.getType() !== ObjectType.ARRAY_BUFFER) {\n      return false;\n    }\n\n    // Perform initialization if necessary, ensure program matches VAOs.\n    if (model.handleProgram === 0) {\n      model.handleProgram = program.getHandle();\n    }\n    if (!publicAPI.isReady()) {\n      publicAPI.initialize();\n    }\n    if (!publicAPI.isReady() || model.handleProgram !== program.getHandle()) {\n      return false;\n    }\n    const gl = model.context;\n    const attribs = {};\n    attribs.name = name;\n    attribs.index = gl.getAttribLocation(model.handleProgram, name);\n    attribs.offset = offset;\n    attribs.stride = stride;\n    attribs.type = elementType;\n    attribs.size = elementTupleSize;\n    attribs.normalize = normalize;\n    attribs.isMatrix = isMatrix;\n    attribs.divisor = divisor;\n    if (attribs.Index === -1) {\n      return false;\n    }\n\n    // Always make the call as even the first use wants the attrib pointer setting\n    // up when we are emulating.\n    buffer.bind();\n    gl.enableVertexAttribArray(attribs.index);\n    gl.vertexAttribPointer(attribs.index, attribs.size, attribs.type, attribs.normalize, attribs.stride, attribs.offset);\n    if (divisor > 0) {\n      if (model.instancingExtension) {\n        model.instancingExtension.vertexAttribDivisorANGLE(attribs.index, 1);\n      } else {\n        gl.vertexAttribDivisor(attribs.index, 1);\n      }\n    }\n    attribs.buffer = buffer.getHandle();\n\n    // If vertex array objects are not supported then build up our list.\n    if (!model.supported) {\n      // find the buffer\n      let buffFound = false;\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        if (buff.buffer === attribs.buffer) {\n          buffFound = true;\n          let found = false;\n          for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n            const attrIt = buff.attributes[iatt];\n            if (attrIt.name === name) {\n              found = true;\n              buff.attributes[iatt] = attribs;\n            }\n          }\n          if (!found) {\n            buff.attributes.push(attribs);\n          }\n        }\n      }\n      if (!buffFound) {\n        model.buffers.push({\n          buffer: attribs.buffer,\n          attributes: [attribs]\n        });\n      }\n    }\n    return true;\n  };\n  publicAPI.addAttributeMatrixWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor) => {\n    // bind the first row of values\n    const result = publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, true);\n    if (!result) {\n      return result;\n    }\n    const gl = model.context;\n    const index = gl.getAttribLocation(model.handleProgram, name);\n    for (let i = 1; i < elementTupleSize; i++) {\n      gl.enableVertexAttribArray(index + i);\n      gl.vertexAttribPointer(index + i, elementTupleSize, elementType, normalize, stride, offset + stride * i / elementTupleSize);\n      if (divisor > 0) {\n        if (model.instancingExtension) {\n          model.instancingExtension.vertexAttribDivisorANGLE(index + i, 1);\n        } else {\n          gl.vertexAttribDivisor(index + i, 1);\n        }\n      }\n    }\n    return true;\n  };\n  publicAPI.removeAttributeArray = name => {\n    if (!publicAPI.isReady() || model.handleProgram === 0) {\n      return false;\n    }\n\n    // If we don't have real VAOs find the entry and remove it too.\n    if (!model.supported) {\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          const attrIt = buff.attributes[iatt];\n          if (attrIt.name === name) {\n            buff.attributes.splice(iatt, 1);\n            if (!buff.attributes.length) {\n              model.buffers.splice(ibuff, 1);\n            }\n            return true;\n          }\n        }\n      }\n    }\n    return true;\n  };\n  publicAPI.setOpenGLRenderWindow = rw => {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  forceEmulation: false,\n  handleVAO: 0,\n  handleProgram: 0,\n  supported: true,\n  buffers: null,\n  context: null\n  // _openGLRenderWindow: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Internal objects initialization\n  model.buffers = [];\n\n  // Object methods\n  macro.obj(publicAPI, model);\n\n  // Create get-only macros\n  macro.get(publicAPI, model, ['supported']);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['forceEmulation']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkOpenGLVertexArrayObject(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkOpenGLVertexArrayObject');\n\n// ----------------------------------------------------------------------------\n\nvar vtkVertexArrayObject = {\n  newInstance,\n  extend\n};\nexport { vtkVertexArrayObject as default, extend, newInstance };","map":{"version":3,"names":["m","macro","ObjectType","vtkOpenGLVertexArrayObject","publicAPI","model","classHierarchy","push","exposedMethod","initialize","instancingExtension","_openGLRenderWindow","getWebgl2","context","getExtension","forceEmulation","extension","supported","handleVAO","createVertexArray","createVertexArrayOES","isReady","bind","bindVertexArrayOES","bindVertexArray","gl","ibuff","buffers","length","buff","bindBuffer","ARRAY_BUFFER","buffer","iatt","attributes","attrIt","matrixCount","isMatrix","size","i","enableVertexAttribArray","index","vertexAttribPointer","type","normalize","stride","offset","divisor","vertexAttribDivisorANGLE","vertexAttribDivisor","release","disableVertexAttribArray","shaderProgramChanged","deleteVertexArrayOES","deleteVertexArray","handleProgram","releaseGraphicsResources","addAttributeArray","program","name","elementType","elementTupleSize","addAttributeArrayWithDivisor","isBound","getHandle","getType","attribs","getAttribLocation","Index","buffFound","found","addAttributeMatrixWithDivisor","result","removeAttributeArray","splice","setOpenGLRenderWindow","rw","getContext","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","obj","get","setGet","newInstance","vtkVertexArrayObject","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/OpenGL/VertexArrayObject.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport { ObjectType } from './BufferObject/Constants.js';\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLVertexArrayObject methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLVertexArrayObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLVertexArrayObject');\n\n  // Public API methods\n  publicAPI.exposedMethod = () => {\n    // This is a publicly exposed method of this object\n  };\n  publicAPI.initialize = () => {\n    model.instancingExtension = null;\n    if (!model._openGLRenderWindow.getWebgl2()) {\n      model.instancingExtension = model.context.getExtension('ANGLE_instanced_arrays');\n    }\n    if (!model.forceEmulation && model._openGLRenderWindow && model._openGLRenderWindow.getWebgl2()) {\n      model.extension = null;\n      model.supported = true;\n      model.handleVAO = model.context.createVertexArray();\n    } else {\n      model.extension = model.context.getExtension('OES_vertex_array_object');\n      // Start setting up VAO\n      if (!model.forceEmulation && model.extension) {\n        model.supported = true;\n        model.handleVAO = model.extension.createVertexArrayOES();\n      } else {\n        model.supported = false;\n      }\n    }\n  };\n  publicAPI.isReady = () =>\n  // We either probed and allocated a VAO, or are falling back as the current\n  // hardware does not support VAOs.\n  model.handleVAO !== 0 || model.supported === false;\n  publicAPI.bind = () => {\n    // Either simply bind the VAO, or emulate behavior by binding all attributes.\n    if (!publicAPI.isReady()) {\n      publicAPI.initialize();\n    }\n    if (publicAPI.isReady() && model.supported) {\n      if (model.extension) {\n        model.extension.bindVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.bindVertexArray(model.handleVAO);\n      }\n    } else if (publicAPI.isReady()) {\n      const gl = model.context;\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);\n        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          const attrIt = buff.attributes[iatt];\n          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;\n          for (let i = 0; i < matrixCount; ++i) {\n            gl.enableVertexAttribArray(attrIt.index + i);\n            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);\n            if (attrIt.divisor > 0) {\n              if (model.instancingExtension) {\n                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 1);\n              } else {\n                gl.vertexAttribDivisor(attrIt.index + i, 1);\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n  publicAPI.release = () => {\n    // Either simply release the VAO, or emulate behavior by releasing all attributes.\n    if (publicAPI.isReady() && model.supported) {\n      if (model.extension) {\n        model.extension.bindVertexArrayOES(null);\n      } else {\n        model.context.bindVertexArray(null);\n      }\n    } else if (publicAPI.isReady()) {\n      const gl = model.context;\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);\n        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          const attrIt = buff.attributes[iatt];\n          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;\n          for (let i = 0; i < matrixCount; ++i) {\n            gl.enableVertexAttribArray(attrIt.index + i);\n            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);\n            if (attrIt.divisor > 0) {\n              if (model.instancingExtension) {\n                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 0);\n              } else {\n                gl.vertexAttribDivisor(attrIt.index + i, 0);\n              }\n            }\n            gl.disableVertexAttribArray(attrIt.index + i);\n          }\n        }\n      }\n    }\n  };\n  publicAPI.shaderProgramChanged = () => {\n    publicAPI.release();\n    if (model.handleVAO) {\n      if (model.extension) {\n        model.extension.deleteVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.deleteVertexArray(model.handleVAO);\n      }\n    }\n    model.handleVAO = 0;\n    model.handleProgram = 0;\n  };\n  publicAPI.releaseGraphicsResources = () => {\n    publicAPI.shaderProgramChanged();\n    if (model.handleVAO) {\n      if (model.extension) {\n        model.extension.deleteVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.deleteVertexArray(model.handleVAO);\n      }\n    }\n    model.handleVAO = 0;\n    model.supported = true;\n    model.handleProgram = 0;\n  };\n  publicAPI.addAttributeArray = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize) => publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, 0, false);\n  publicAPI.addAttributeArrayWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, isMatrix) => {\n    if (!program) {\n      return false;\n    }\n\n    // Check the program is bound, and the buffer is valid.\n    if (!program.isBound() || buffer.getHandle() === 0 || buffer.getType() !== ObjectType.ARRAY_BUFFER) {\n      return false;\n    }\n\n    // Perform initialization if necessary, ensure program matches VAOs.\n    if (model.handleProgram === 0) {\n      model.handleProgram = program.getHandle();\n    }\n    if (!publicAPI.isReady()) {\n      publicAPI.initialize();\n    }\n    if (!publicAPI.isReady() || model.handleProgram !== program.getHandle()) {\n      return false;\n    }\n    const gl = model.context;\n    const attribs = {};\n    attribs.name = name;\n    attribs.index = gl.getAttribLocation(model.handleProgram, name);\n    attribs.offset = offset;\n    attribs.stride = stride;\n    attribs.type = elementType;\n    attribs.size = elementTupleSize;\n    attribs.normalize = normalize;\n    attribs.isMatrix = isMatrix;\n    attribs.divisor = divisor;\n    if (attribs.Index === -1) {\n      return false;\n    }\n\n    // Always make the call as even the first use wants the attrib pointer setting\n    // up when we are emulating.\n    buffer.bind();\n    gl.enableVertexAttribArray(attribs.index);\n    gl.vertexAttribPointer(attribs.index, attribs.size, attribs.type, attribs.normalize, attribs.stride, attribs.offset);\n    if (divisor > 0) {\n      if (model.instancingExtension) {\n        model.instancingExtension.vertexAttribDivisorANGLE(attribs.index, 1);\n      } else {\n        gl.vertexAttribDivisor(attribs.index, 1);\n      }\n    }\n    attribs.buffer = buffer.getHandle();\n\n    // If vertex array objects are not supported then build up our list.\n    if (!model.supported) {\n      // find the buffer\n      let buffFound = false;\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        if (buff.buffer === attribs.buffer) {\n          buffFound = true;\n          let found = false;\n          for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n            const attrIt = buff.attributes[iatt];\n            if (attrIt.name === name) {\n              found = true;\n              buff.attributes[iatt] = attribs;\n            }\n          }\n          if (!found) {\n            buff.attributes.push(attribs);\n          }\n        }\n      }\n      if (!buffFound) {\n        model.buffers.push({\n          buffer: attribs.buffer,\n          attributes: [attribs]\n        });\n      }\n    }\n    return true;\n  };\n  publicAPI.addAttributeMatrixWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor) => {\n    // bind the first row of values\n    const result = publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, true);\n    if (!result) {\n      return result;\n    }\n    const gl = model.context;\n    const index = gl.getAttribLocation(model.handleProgram, name);\n    for (let i = 1; i < elementTupleSize; i++) {\n      gl.enableVertexAttribArray(index + i);\n      gl.vertexAttribPointer(index + i, elementTupleSize, elementType, normalize, stride, offset + stride * i / elementTupleSize);\n      if (divisor > 0) {\n        if (model.instancingExtension) {\n          model.instancingExtension.vertexAttribDivisorANGLE(index + i, 1);\n        } else {\n          gl.vertexAttribDivisor(index + i, 1);\n        }\n      }\n    }\n    return true;\n  };\n  publicAPI.removeAttributeArray = name => {\n    if (!publicAPI.isReady() || model.handleProgram === 0) {\n      return false;\n    }\n\n    // If we don't have real VAOs find the entry and remove it too.\n    if (!model.supported) {\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          const attrIt = buff.attributes[iatt];\n          if (attrIt.name === name) {\n            buff.attributes.splice(iatt, 1);\n            if (!buff.attributes.length) {\n              model.buffers.splice(ibuff, 1);\n            }\n            return true;\n          }\n        }\n      }\n    }\n    return true;\n  };\n  publicAPI.setOpenGLRenderWindow = rw => {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  forceEmulation: false,\n  handleVAO: 0,\n  handleProgram: 0,\n  supported: true,\n  buffers: null,\n  context: null\n  // _openGLRenderWindow: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Internal objects initialization\n  model.buffers = [];\n\n  // Object methods\n  macro.obj(publicAPI, model);\n\n  // Create get-only macros\n  macro.get(publicAPI, model, ['supported']);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['forceEmulation']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkOpenGLVertexArrayObject(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkOpenGLVertexArrayObject');\n\n// ----------------------------------------------------------------------------\n\nvar vtkVertexArrayObject = {\n  newInstance,\n  extend\n};\n\nexport { vtkVertexArrayObject as default, extend, newInstance };\n"],"mappings":";AAAA,SAASA,CAAC,IAAIC,KAAK,QAAQ,kBAAkB;AAC7C,SAASC,UAAU,QAAQ,6BAA6B;;AAExD;AACA;AACA;;AAEA,SAASC,0BAA0BA,CAACC,SAAS,EAAEC,KAAK,EAAE;EACpD;EACAA,KAAK,CAACC,cAAc,CAACC,IAAI,CAAC,4BAA4B,CAAC;;EAEvD;EACAH,SAAS,CAACI,aAAa,GAAG,MAAM;IAC9B;EAAA,CACD;EACDJ,SAAS,CAACK,UAAU,GAAG,MAAM;IAC3BJ,KAAK,CAACK,mBAAmB,GAAG,IAAI;IAChC,IAAI,CAACL,KAAK,CAACM,mBAAmB,CAACC,SAAS,CAAC,CAAC,EAAE;MAC1CP,KAAK,CAACK,mBAAmB,GAAGL,KAAK,CAACQ,OAAO,CAACC,YAAY,CAAC,wBAAwB,CAAC;IAClF;IACA,IAAI,CAACT,KAAK,CAACU,cAAc,IAAIV,KAAK,CAACM,mBAAmB,IAAIN,KAAK,CAACM,mBAAmB,CAACC,SAAS,CAAC,CAAC,EAAE;MAC/FP,KAAK,CAACW,SAAS,GAAG,IAAI;MACtBX,KAAK,CAACY,SAAS,GAAG,IAAI;MACtBZ,KAAK,CAACa,SAAS,GAAGb,KAAK,CAACQ,OAAO,CAACM,iBAAiB,CAAC,CAAC;IACrD,CAAC,MAAM;MACLd,KAAK,CAACW,SAAS,GAAGX,KAAK,CAACQ,OAAO,CAACC,YAAY,CAAC,yBAAyB,CAAC;MACvE;MACA,IAAI,CAACT,KAAK,CAACU,cAAc,IAAIV,KAAK,CAACW,SAAS,EAAE;QAC5CX,KAAK,CAACY,SAAS,GAAG,IAAI;QACtBZ,KAAK,CAACa,SAAS,GAAGb,KAAK,CAACW,SAAS,CAACI,oBAAoB,CAAC,CAAC;MAC1D,CAAC,MAAM;QACLf,KAAK,CAACY,SAAS,GAAG,KAAK;MACzB;IACF;EACF,CAAC;EACDb,SAAS,CAACiB,OAAO,GAAG;EACpB;EACA;EACAhB,KAAK,CAACa,SAAS,KAAK,CAAC,IAAIb,KAAK,CAACY,SAAS,KAAK,KAAK;EAClDb,SAAS,CAACkB,IAAI,GAAG,MAAM;IACrB;IACA,IAAI,CAAClB,SAAS,CAACiB,OAAO,CAAC,CAAC,EAAE;MACxBjB,SAAS,CAACK,UAAU,CAAC,CAAC;IACxB;IACA,IAAIL,SAAS,CAACiB,OAAO,CAAC,CAAC,IAAIhB,KAAK,CAACY,SAAS,EAAE;MAC1C,IAAIZ,KAAK,CAACW,SAAS,EAAE;QACnBX,KAAK,CAACW,SAAS,CAACO,kBAAkB,CAAClB,KAAK,CAACa,SAAS,CAAC;MACrD,CAAC,MAAM;QACLb,KAAK,CAACQ,OAAO,CAACW,eAAe,CAACnB,KAAK,CAACa,SAAS,CAAC;MAChD;IACF,CAAC,MAAM,IAAId,SAAS,CAACiB,OAAO,CAAC,CAAC,EAAE;MAC9B,MAAMI,EAAE,GAAGpB,KAAK,CAACQ,OAAO;MACxB,KAAK,IAAIa,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGrB,KAAK,CAACsB,OAAO,CAACC,MAAM,EAAE,EAAEF,KAAK,EAAE;QACzD,MAAMG,IAAI,GAAGxB,KAAK,CAACsB,OAAO,CAACD,KAAK,CAAC;QACjCrB,KAAK,CAACQ,OAAO,CAACiB,UAAU,CAACL,EAAE,CAACM,YAAY,EAAEF,IAAI,CAACG,MAAM,CAAC;QACtD,KAAK,IAAIC,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGJ,IAAI,CAACK,UAAU,CAACN,MAAM,EAAE,EAAEK,IAAI,EAAE;UACxD,MAAME,MAAM,GAAGN,IAAI,CAACK,UAAU,CAACD,IAAI,CAAC;UACpC,MAAMG,WAAW,GAAGD,MAAM,CAACE,QAAQ,GAAGF,MAAM,CAACG,IAAI,GAAG,CAAC;UACrD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,WAAW,EAAE,EAAEG,CAAC,EAAE;YACpCd,EAAE,CAACe,uBAAuB,CAACL,MAAM,CAACM,KAAK,GAAGF,CAAC,CAAC;YAC5Cd,EAAE,CAACiB,mBAAmB,CAACP,MAAM,CAACM,KAAK,GAAGF,CAAC,EAAEJ,MAAM,CAACG,IAAI,EAAEH,MAAM,CAACQ,IAAI,EAAER,MAAM,CAACS,SAAS,EAAET,MAAM,CAACU,MAAM,EAAEV,MAAM,CAACW,MAAM,GAAGX,MAAM,CAACU,MAAM,GAAGN,CAAC,GAAGJ,MAAM,CAACG,IAAI,CAAC;YACpJ,IAAIH,MAAM,CAACY,OAAO,GAAG,CAAC,EAAE;cACtB,IAAI1C,KAAK,CAACK,mBAAmB,EAAE;gBAC7BL,KAAK,CAACK,mBAAmB,CAACsC,wBAAwB,CAACb,MAAM,CAACM,KAAK,GAAGF,CAAC,EAAE,CAAC,CAAC;cACzE,CAAC,MAAM;gBACLd,EAAE,CAACwB,mBAAmB,CAACd,MAAM,CAACM,KAAK,GAAGF,CAAC,EAAE,CAAC,CAAC;cAC7C;YACF;UACF;QACF;MACF;IACF;EACF,CAAC;EACDnC,SAAS,CAAC8C,OAAO,GAAG,MAAM;IACxB;IACA,IAAI9C,SAAS,CAACiB,OAAO,CAAC,CAAC,IAAIhB,KAAK,CAACY,SAAS,EAAE;MAC1C,IAAIZ,KAAK,CAACW,SAAS,EAAE;QACnBX,KAAK,CAACW,SAAS,CAACO,kBAAkB,CAAC,IAAI,CAAC;MAC1C,CAAC,MAAM;QACLlB,KAAK,CAACQ,OAAO,CAACW,eAAe,CAAC,IAAI,CAAC;MACrC;IACF,CAAC,MAAM,IAAIpB,SAAS,CAACiB,OAAO,CAAC,CAAC,EAAE;MAC9B,MAAMI,EAAE,GAAGpB,KAAK,CAACQ,OAAO;MACxB,KAAK,IAAIa,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGrB,KAAK,CAACsB,OAAO,CAACC,MAAM,EAAE,EAAEF,KAAK,EAAE;QACzD,MAAMG,IAAI,GAAGxB,KAAK,CAACsB,OAAO,CAACD,KAAK,CAAC;QACjCrB,KAAK,CAACQ,OAAO,CAACiB,UAAU,CAACL,EAAE,CAACM,YAAY,EAAEF,IAAI,CAACG,MAAM,CAAC;QACtD,KAAK,IAAIC,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGJ,IAAI,CAACK,UAAU,CAACN,MAAM,EAAE,EAAEK,IAAI,EAAE;UACxD,MAAME,MAAM,GAAGN,IAAI,CAACK,UAAU,CAACD,IAAI,CAAC;UACpC,MAAMG,WAAW,GAAGD,MAAM,CAACE,QAAQ,GAAGF,MAAM,CAACG,IAAI,GAAG,CAAC;UACrD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,WAAW,EAAE,EAAEG,CAAC,EAAE;YACpCd,EAAE,CAACe,uBAAuB,CAACL,MAAM,CAACM,KAAK,GAAGF,CAAC,CAAC;YAC5Cd,EAAE,CAACiB,mBAAmB,CAACP,MAAM,CAACM,KAAK,GAAGF,CAAC,EAAEJ,MAAM,CAACG,IAAI,EAAEH,MAAM,CAACQ,IAAI,EAAER,MAAM,CAACS,SAAS,EAAET,MAAM,CAACU,MAAM,EAAEV,MAAM,CAACW,MAAM,GAAGX,MAAM,CAACU,MAAM,GAAGN,CAAC,GAAGJ,MAAM,CAACG,IAAI,CAAC;YACpJ,IAAIH,MAAM,CAACY,OAAO,GAAG,CAAC,EAAE;cACtB,IAAI1C,KAAK,CAACK,mBAAmB,EAAE;gBAC7BL,KAAK,CAACK,mBAAmB,CAACsC,wBAAwB,CAACb,MAAM,CAACM,KAAK,GAAGF,CAAC,EAAE,CAAC,CAAC;cACzE,CAAC,MAAM;gBACLd,EAAE,CAACwB,mBAAmB,CAACd,MAAM,CAACM,KAAK,GAAGF,CAAC,EAAE,CAAC,CAAC;cAC7C;YACF;YACAd,EAAE,CAAC0B,wBAAwB,CAAChB,MAAM,CAACM,KAAK,GAAGF,CAAC,CAAC;UAC/C;QACF;MACF;IACF;EACF,CAAC;EACDnC,SAAS,CAACgD,oBAAoB,GAAG,MAAM;IACrChD,SAAS,CAAC8C,OAAO,CAAC,CAAC;IACnB,IAAI7C,KAAK,CAACa,SAAS,EAAE;MACnB,IAAIb,KAAK,CAACW,SAAS,EAAE;QACnBX,KAAK,CAACW,SAAS,CAACqC,oBAAoB,CAAChD,KAAK,CAACa,SAAS,CAAC;MACvD,CAAC,MAAM;QACLb,KAAK,CAACQ,OAAO,CAACyC,iBAAiB,CAACjD,KAAK,CAACa,SAAS,CAAC;MAClD;IACF;IACAb,KAAK,CAACa,SAAS,GAAG,CAAC;IACnBb,KAAK,CAACkD,aAAa,GAAG,CAAC;EACzB,CAAC;EACDnD,SAAS,CAACoD,wBAAwB,GAAG,MAAM;IACzCpD,SAAS,CAACgD,oBAAoB,CAAC,CAAC;IAChC,IAAI/C,KAAK,CAACa,SAAS,EAAE;MACnB,IAAIb,KAAK,CAACW,SAAS,EAAE;QACnBX,KAAK,CAACW,SAAS,CAACqC,oBAAoB,CAAChD,KAAK,CAACa,SAAS,CAAC;MACvD,CAAC,MAAM;QACLb,KAAK,CAACQ,OAAO,CAACyC,iBAAiB,CAACjD,KAAK,CAACa,SAAS,CAAC;MAClD;IACF;IACAb,KAAK,CAACa,SAAS,GAAG,CAAC;IACnBb,KAAK,CAACY,SAAS,GAAG,IAAI;IACtBZ,KAAK,CAACkD,aAAa,GAAG,CAAC;EACzB,CAAC;EACDnD,SAAS,CAACqD,iBAAiB,GAAG,CAACC,OAAO,EAAE1B,MAAM,EAAE2B,IAAI,EAAEb,MAAM,EAAED,MAAM,EAAEe,WAAW,EAAEC,gBAAgB,EAAEjB,SAAS,KAAKxC,SAAS,CAAC0D,4BAA4B,CAACJ,OAAO,EAAE1B,MAAM,EAAE2B,IAAI,EAAEb,MAAM,EAAED,MAAM,EAAEe,WAAW,EAAEC,gBAAgB,EAAEjB,SAAS,EAAE,CAAC,EAAE,KAAK,CAAC;EACpPxC,SAAS,CAAC0D,4BAA4B,GAAG,CAACJ,OAAO,EAAE1B,MAAM,EAAE2B,IAAI,EAAEb,MAAM,EAAED,MAAM,EAAEe,WAAW,EAAEC,gBAAgB,EAAEjB,SAAS,EAAEG,OAAO,EAAEV,QAAQ,KAAK;IAC/I,IAAI,CAACqB,OAAO,EAAE;MACZ,OAAO,KAAK;IACd;;IAEA;IACA,IAAI,CAACA,OAAO,CAACK,OAAO,CAAC,CAAC,IAAI/B,MAAM,CAACgC,SAAS,CAAC,CAAC,KAAK,CAAC,IAAIhC,MAAM,CAACiC,OAAO,CAAC,CAAC,KAAK/D,UAAU,CAAC6B,YAAY,EAAE;MAClG,OAAO,KAAK;IACd;;IAEA;IACA,IAAI1B,KAAK,CAACkD,aAAa,KAAK,CAAC,EAAE;MAC7BlD,KAAK,CAACkD,aAAa,GAAGG,OAAO,CAACM,SAAS,CAAC,CAAC;IAC3C;IACA,IAAI,CAAC5D,SAAS,CAACiB,OAAO,CAAC,CAAC,EAAE;MACxBjB,SAAS,CAACK,UAAU,CAAC,CAAC;IACxB;IACA,IAAI,CAACL,SAAS,CAACiB,OAAO,CAAC,CAAC,IAAIhB,KAAK,CAACkD,aAAa,KAAKG,OAAO,CAACM,SAAS,CAAC,CAAC,EAAE;MACvE,OAAO,KAAK;IACd;IACA,MAAMvC,EAAE,GAAGpB,KAAK,CAACQ,OAAO;IACxB,MAAMqD,OAAO,GAAG,CAAC,CAAC;IAClBA,OAAO,CAACP,IAAI,GAAGA,IAAI;IACnBO,OAAO,CAACzB,KAAK,GAAGhB,EAAE,CAAC0C,iBAAiB,CAAC9D,KAAK,CAACkD,aAAa,EAAEI,IAAI,CAAC;IAC/DO,OAAO,CAACpB,MAAM,GAAGA,MAAM;IACvBoB,OAAO,CAACrB,MAAM,GAAGA,MAAM;IACvBqB,OAAO,CAACvB,IAAI,GAAGiB,WAAW;IAC1BM,OAAO,CAAC5B,IAAI,GAAGuB,gBAAgB;IAC/BK,OAAO,CAACtB,SAAS,GAAGA,SAAS;IAC7BsB,OAAO,CAAC7B,QAAQ,GAAGA,QAAQ;IAC3B6B,OAAO,CAACnB,OAAO,GAAGA,OAAO;IACzB,IAAImB,OAAO,CAACE,KAAK,KAAK,CAAC,CAAC,EAAE;MACxB,OAAO,KAAK;IACd;;IAEA;IACA;IACApC,MAAM,CAACV,IAAI,CAAC,CAAC;IACbG,EAAE,CAACe,uBAAuB,CAAC0B,OAAO,CAACzB,KAAK,CAAC;IACzChB,EAAE,CAACiB,mBAAmB,CAACwB,OAAO,CAACzB,KAAK,EAAEyB,OAAO,CAAC5B,IAAI,EAAE4B,OAAO,CAACvB,IAAI,EAAEuB,OAAO,CAACtB,SAAS,EAAEsB,OAAO,CAACrB,MAAM,EAAEqB,OAAO,CAACpB,MAAM,CAAC;IACpH,IAAIC,OAAO,GAAG,CAAC,EAAE;MACf,IAAI1C,KAAK,CAACK,mBAAmB,EAAE;QAC7BL,KAAK,CAACK,mBAAmB,CAACsC,wBAAwB,CAACkB,OAAO,CAACzB,KAAK,EAAE,CAAC,CAAC;MACtE,CAAC,MAAM;QACLhB,EAAE,CAACwB,mBAAmB,CAACiB,OAAO,CAACzB,KAAK,EAAE,CAAC,CAAC;MAC1C;IACF;IACAyB,OAAO,CAAClC,MAAM,GAAGA,MAAM,CAACgC,SAAS,CAAC,CAAC;;IAEnC;IACA,IAAI,CAAC3D,KAAK,CAACY,SAAS,EAAE;MACpB;MACA,IAAIoD,SAAS,GAAG,KAAK;MACrB,KAAK,IAAI3C,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGrB,KAAK,CAACsB,OAAO,CAACC,MAAM,EAAE,EAAEF,KAAK,EAAE;QACzD,MAAMG,IAAI,GAAGxB,KAAK,CAACsB,OAAO,CAACD,KAAK,CAAC;QACjC,IAAIG,IAAI,CAACG,MAAM,KAAKkC,OAAO,CAAClC,MAAM,EAAE;UAClCqC,SAAS,GAAG,IAAI;UAChB,IAAIC,KAAK,GAAG,KAAK;UACjB,KAAK,IAAIrC,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGJ,IAAI,CAACK,UAAU,CAACN,MAAM,EAAE,EAAEK,IAAI,EAAE;YACxD,MAAME,MAAM,GAAGN,IAAI,CAACK,UAAU,CAACD,IAAI,CAAC;YACpC,IAAIE,MAAM,CAACwB,IAAI,KAAKA,IAAI,EAAE;cACxBW,KAAK,GAAG,IAAI;cACZzC,IAAI,CAACK,UAAU,CAACD,IAAI,CAAC,GAAGiC,OAAO;YACjC;UACF;UACA,IAAI,CAACI,KAAK,EAAE;YACVzC,IAAI,CAACK,UAAU,CAAC3B,IAAI,CAAC2D,OAAO,CAAC;UAC/B;QACF;MACF;MACA,IAAI,CAACG,SAAS,EAAE;QACdhE,KAAK,CAACsB,OAAO,CAACpB,IAAI,CAAC;UACjByB,MAAM,EAAEkC,OAAO,CAAClC,MAAM;UACtBE,UAAU,EAAE,CAACgC,OAAO;QACtB,CAAC,CAAC;MACJ;IACF;IACA,OAAO,IAAI;EACb,CAAC;EACD9D,SAAS,CAACmE,6BAA6B,GAAG,CAACb,OAAO,EAAE1B,MAAM,EAAE2B,IAAI,EAAEb,MAAM,EAAED,MAAM,EAAEe,WAAW,EAAEC,gBAAgB,EAAEjB,SAAS,EAAEG,OAAO,KAAK;IACtI;IACA,MAAMyB,MAAM,GAAGpE,SAAS,CAAC0D,4BAA4B,CAACJ,OAAO,EAAE1B,MAAM,EAAE2B,IAAI,EAAEb,MAAM,EAAED,MAAM,EAAEe,WAAW,EAAEC,gBAAgB,EAAEjB,SAAS,EAAEG,OAAO,EAAE,IAAI,CAAC;IACrJ,IAAI,CAACyB,MAAM,EAAE;MACX,OAAOA,MAAM;IACf;IACA,MAAM/C,EAAE,GAAGpB,KAAK,CAACQ,OAAO;IACxB,MAAM4B,KAAK,GAAGhB,EAAE,CAAC0C,iBAAiB,CAAC9D,KAAK,CAACkD,aAAa,EAAEI,IAAI,CAAC;IAC7D,KAAK,IAAIpB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsB,gBAAgB,EAAEtB,CAAC,EAAE,EAAE;MACzCd,EAAE,CAACe,uBAAuB,CAACC,KAAK,GAAGF,CAAC,CAAC;MACrCd,EAAE,CAACiB,mBAAmB,CAACD,KAAK,GAAGF,CAAC,EAAEsB,gBAAgB,EAAED,WAAW,EAAEhB,SAAS,EAAEC,MAAM,EAAEC,MAAM,GAAGD,MAAM,GAAGN,CAAC,GAAGsB,gBAAgB,CAAC;MAC3H,IAAId,OAAO,GAAG,CAAC,EAAE;QACf,IAAI1C,KAAK,CAACK,mBAAmB,EAAE;UAC7BL,KAAK,CAACK,mBAAmB,CAACsC,wBAAwB,CAACP,KAAK,GAAGF,CAAC,EAAE,CAAC,CAAC;QAClE,CAAC,MAAM;UACLd,EAAE,CAACwB,mBAAmB,CAACR,KAAK,GAAGF,CAAC,EAAE,CAAC,CAAC;QACtC;MACF;IACF;IACA,OAAO,IAAI;EACb,CAAC;EACDnC,SAAS,CAACqE,oBAAoB,GAAGd,IAAI,IAAI;IACvC,IAAI,CAACvD,SAAS,CAACiB,OAAO,CAAC,CAAC,IAAIhB,KAAK,CAACkD,aAAa,KAAK,CAAC,EAAE;MACrD,OAAO,KAAK;IACd;;IAEA;IACA,IAAI,CAAClD,KAAK,CAACY,SAAS,EAAE;MACpB,KAAK,IAAIS,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGrB,KAAK,CAACsB,OAAO,CAACC,MAAM,EAAE,EAAEF,KAAK,EAAE;QACzD,MAAMG,IAAI,GAAGxB,KAAK,CAACsB,OAAO,CAACD,KAAK,CAAC;QACjC,KAAK,IAAIO,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGJ,IAAI,CAACK,UAAU,CAACN,MAAM,EAAE,EAAEK,IAAI,EAAE;UACxD,MAAME,MAAM,GAAGN,IAAI,CAACK,UAAU,CAACD,IAAI,CAAC;UACpC,IAAIE,MAAM,CAACwB,IAAI,KAAKA,IAAI,EAAE;YACxB9B,IAAI,CAACK,UAAU,CAACwC,MAAM,CAACzC,IAAI,EAAE,CAAC,CAAC;YAC/B,IAAI,CAACJ,IAAI,CAACK,UAAU,CAACN,MAAM,EAAE;cAC3BvB,KAAK,CAACsB,OAAO,CAAC+C,MAAM,CAAChD,KAAK,EAAE,CAAC,CAAC;YAChC;YACA,OAAO,IAAI;UACb;QACF;MACF;IACF;IACA,OAAO,IAAI;EACb,CAAC;EACDtB,SAAS,CAACuE,qBAAqB,GAAGC,EAAE,IAAI;IACtC,IAAIvE,KAAK,CAACM,mBAAmB,KAAKiE,EAAE,EAAE;MACpC;IACF;IACAxE,SAAS,CAACoD,wBAAwB,CAAC,CAAC;IACpCnD,KAAK,CAACM,mBAAmB,GAAGiE,EAAE;IAC9BvE,KAAK,CAACQ,OAAO,GAAG,IAAI;IACpB,IAAI+D,EAAE,EAAE;MACNvE,KAAK,CAACQ,OAAO,GAAGR,KAAK,CAACM,mBAAmB,CAACkE,UAAU,CAAC,CAAC;IACxD;EACF,CAAC;AACH;;AAEA;AACA;AACA;;AAEA,MAAMC,cAAc,GAAG;EACrB/D,cAAc,EAAE,KAAK;EACrBG,SAAS,EAAE,CAAC;EACZqC,aAAa,EAAE,CAAC;EAChBtC,SAAS,EAAE,IAAI;EACfU,OAAO,EAAE,IAAI;EACbd,OAAO,EAAE;EACT;AACF,CAAC;;AAED;;AAEA,SAASkE,MAAMA,CAAC3E,SAAS,EAAEC,KAAK,EAAE;EAChC,IAAI2E,aAAa,GAAGC,SAAS,CAACrD,MAAM,GAAG,CAAC,IAAIqD,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;EAC1FE,MAAM,CAACC,MAAM,CAAC/E,KAAK,EAAEyE,cAAc,EAAEE,aAAa,CAAC;;EAEnD;EACA3E,KAAK,CAACsB,OAAO,GAAG,EAAE;;EAElB;EACA1B,KAAK,CAACoF,GAAG,CAACjF,SAAS,EAAEC,KAAK,CAAC;;EAE3B;EACAJ,KAAK,CAACqF,GAAG,CAAClF,SAAS,EAAEC,KAAK,EAAE,CAAC,WAAW,CAAC,CAAC;;EAE1C;EACAJ,KAAK,CAACsF,MAAM,CAACnF,SAAS,EAAEC,KAAK,EAAE,CAAC,gBAAgB,CAAC,CAAC;;EAElD;;EAEA;EACAF,0BAA0B,CAACC,SAAS,EAAEC,KAAK,CAAC;AAC9C;;AAEA;;AAEA,MAAMmF,WAAW,GAAGvF,KAAK,CAACuF,WAAW,CAACT,MAAM,EAAE,4BAA4B,CAAC;;AAE3E;;AAEA,IAAIU,oBAAoB,GAAG;EACzBD,WAAW;EACXT;AACF,CAAC;AAED,SAASU,oBAAoB,IAAIC,OAAO,EAAEX,MAAM,EAAES,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}