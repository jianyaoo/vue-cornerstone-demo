"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const triggerSegmentationEvents_1 = require("../../../../stateManagement/segmentation/triggerSegmentationEvents");
const segmentation_1 = require("../../../../stateManagement/segmentation");
const StrategyCallbacks_1 = __importDefault(require("../../../../enums/StrategyCallbacks"));
function lightenColor(r, g, b, a, factor = 0.4) {
    return [
        Math.round(r + (255 - r) * factor),
        Math.round(g + (255 - g) * factor),
        Math.round(b + (255 - b) * factor),
        a,
    ];
}
exports.default = {
    [StrategyCallbacks_1.default.Preview]: function (operationData) {
        var _a, _b;
        const { previewColors, strategySpecificConfiguration, enabledElement } = operationData;
        if (!previewColors || !strategySpecificConfiguration) {
            return;
        }
        if (operationData.preview) {
            delete operationData.preview;
        }
        delete strategySpecificConfiguration.centerSegmentIndex;
        (_a = this.onInteractionStart) === null || _a === void 0 ? void 0 : _a.call(this, enabledElement, operationData);
        const preview = this.fill(enabledElement, operationData);
        if (preview) {
            preview.isPreviewFromHover = true;
            operationData.preview = preview;
            (_b = this.onInteractionEnd) === null || _b === void 0 ? void 0 : _b.call(this, enabledElement, operationData);
        }
        return preview;
    },
    [StrategyCallbacks_1.default.Initialize]: (operationData) => {
        const { toolGroupId, segmentIndex, segmentationRepresentationUID, previewSegmentIndex, previewColors, preview, } = operationData;
        if (previewColors === undefined) {
            return;
        }
        if (preview) {
            preview.previewVoxelManager.sourceVoxelManager =
                operationData.segmentationVoxelManager;
            operationData.previewVoxelManager = preview.previewVoxelManager;
        }
        if (segmentIndex === null || !previewSegmentIndex) {
            return;
        }
        const configColor = previewColors === null || previewColors === void 0 ? void 0 : previewColors[segmentIndex];
        const segmentColor = segmentation_1.config.color.getColorForSegmentIndex(toolGroupId, segmentationRepresentationUID, segmentIndex);
        if (!configColor && !segmentColor) {
            return;
        }
        const previewColor = configColor || lightenColor(...segmentColor);
        segmentation_1.config.color.setColorForSegmentIndex(toolGroupId, segmentationRepresentationUID, previewSegmentIndex, previewColor);
    },
    [StrategyCallbacks_1.default.AcceptPreview]: (operationData) => {
        var _a;
        const { segmentationVoxelManager: segmentationVoxelManager, previewVoxelManager: previewVoxelManager, previewSegmentIndex, preview, } = operationData || {};
        if (previewSegmentIndex === undefined) {
            return;
        }
        const segmentIndex = (_a = preview === null || preview === void 0 ? void 0 : preview.segmentIndex) !== null && _a !== void 0 ? _a : operationData.segmentIndex;
        const tracking = previewVoxelManager;
        if (!tracking || tracking.modifiedSlices.size === 0) {
            return;
        }
        const callback = ({ index }) => {
            const oldValue = segmentationVoxelManager.getAtIndex(index);
            if (oldValue === previewSegmentIndex) {
                segmentationVoxelManager.setAtIndex(index, segmentIndex);
            }
        };
        tracking.forEach(callback, {});
        (0, triggerSegmentationEvents_1.triggerSegmentationDataModified)(operationData.segmentationId, tracking.getArrayOfSlices());
        tracking.clear();
    },
    [StrategyCallbacks_1.default.RejectPreview]: (operationData) => {
        const { previewVoxelManager: previewVoxelManager, segmentationVoxelManager: segmentationVoxelManager, } = operationData;
        if (previewVoxelManager.modifiedSlices.size === 0) {
            return;
        }
        const callback = ({ index, value }) => {
            segmentationVoxelManager.setAtIndex(index, value);
        };
        previewVoxelManager.forEach(callback);
        (0, triggerSegmentationEvents_1.triggerSegmentationDataModified)(operationData.segmentationId, previewVoxelManager.getArrayOfSlices());
        previewVoxelManager.clear();
    },
};
//# sourceMappingURL=preview.js.map