{"version":3,"file":"index.js","mappings":"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CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KA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","sources":["webpack://cornerstoneTools3D/webpack/universalModuleDefinition","webpack://cornerstoneTools3D/../../node_modules/lodash.clonedeep/index.js","webpack://cornerstoneTools3D/../../node_modules/lodash.get/index.js","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/CellArray\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/DataArray\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/Math\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/MatrixBuilder\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/Points\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/DataModel/ImageData\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/DataModel/PolyData\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Filters/General/AppendPolyData\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Filters/General/ClipClosedSurface\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Filters/General/ImageMarchingSquares\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/IO/XML/XMLPolyDataReader\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Rendering/Core/Actor\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Rendering/Core/AxesActor\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Rendering/Core/Mapper\"","webpack://cornerstoneTools3D/external umd {\"root\":\"cornerstone3D\",\"commonjs\":\"@cornerstonejs/core\",\"commonjs2\":\"@cornerstonejs/core\",\"amd\":\"@cornerstonejs/core\"}","webpack://cornerstoneTools3D/external umd {\"root\":\"window\",\"commonjs\":\"gl-matrix\",\"commonjs2\":\"gl-matrix\",\"amd\":\"gl-matrix\"}","webpack://cornerstoneTools3D/webpack/bootstrap","webpack://cornerstoneTools3D/webpack/runtime/compat get default export","webpack://cornerstoneTools3D/webpack/runtime/define property getters","webpack://cornerstoneTools3D/webpack/runtime/global","webpack://cornerstoneTools3D/webpack/runtime/hasOwnProperty shorthand","webpack://cornerstoneTools3D/webpack/runtime/make namespace object","webpack://cornerstoneTools3D/webpack/runtime/node module decorator","webpack://cornerstoneTools3D/./src/enums/Events.ts","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","webpack://cornerstoneTools3D/./src/stateManagement/annotation/annotationLocking.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/annotationSelection.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/annotationVisibility.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.ts","webpack://cornerstoneTools3D/./src/store/svgNodeCache.ts","webpack://cornerstoneTools3D/./src/store/state.ts","webpack://cornerstoneTools3D/./src/enums/ToolModes.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/getToolGroupsWithToolName.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/annotationState.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/helpers/state.ts","webpack://cornerstoneTools3D/./src/enums/SegmentationRepresentations.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/contourConfig.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/labelmapConfig.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/SegmentationStateManager.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/triggerSegmentationEvents.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/helpers/normalizeSegmentationInput.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/segmentationState.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/getMouseEventPoints.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/mouseDoubleClickListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/mouseMoveListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/mouseDownListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/index.ts","webpack://cornerstoneTools3D/./src/eventListeners/wheel/wheelListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/wheel/normalizeWheel.ts","webpack://cornerstoneTools3D/./src/eventListeners/wheel/index.ts","webpack://cornerstoneTools3D/./src/eventListeners/touch/preventGhostClick.js","webpack://cornerstoneTools3D/./src/enums/Touch.ts","webpack://cornerstoneTools3D/./src/eventListeners/touch/getTouchEventPoints.ts","webpack://cornerstoneTools3D/./src/utilities/touch/index.ts","webpack://cornerstoneTools3D/./src/eventListeners/touch/touchStartListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/touch/index.ts","webpack://cornerstoneTools3D/./src/eventListeners/keyboard/keyDownListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/keyboard/index.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/getToolGroupForViewport.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/utils/stackVolumeCheck.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/getToolGroup.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/config/segmentationConfig.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/config/segmentationVisibility.ts","webpack://cornerstoneTools3D/./src/tools/base/BaseTool.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Surface/removeSurfaceFromElement.ts","webpack://cornerstoneTools3D/./src/utilities/pointToString.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Surface/addSurfaceToElement.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Surface/surfaceDisplay.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/utils.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/contourConfigCache.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/addContourSetsToElement.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/updateContourSets.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/removeContourFromElement.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/contourDisplay.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/addOrUpdateContourSets.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/addLabelmapToElement.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/removeLabelmapFromElement.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/labelmapDisplay.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/SegmentationDisplayTool.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/triggerSegmentationRender.ts","webpack://cornerstoneTools3D/./src/eventListeners/segmentation/imageChangeEventListener.ts","webpack://cornerstoneTools3D/./src/drawingSvg/getSvgDrawingHelper.ts","webpack://cornerstoneTools3D/./src/drawingSvg/draw.ts","webpack://cornerstoneTools3D/./src/utilities/getToolsWithModesForElement.ts","webpack://cornerstoneTools3D/./src/utilities/triggerAnnotationRender.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/imageRenderedEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getToolsWithModesForMouseEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/cameraModifiedEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/imageSpacingCalibratedEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/customCallbackHandler.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseClick.ts","webpack://cornerstoneTools3D/./src/store/filterToolsWithMoveableHandles.ts","webpack://cornerstoneTools3D/./src/store/filterToolsWithAnnotationsForElement.ts","webpack://cornerstoneTools3D/./src/store/filterMoveableAnnotationTools.ts","webpack://cornerstoneTools3D/./src/enums/ToolBindings.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getMouseModifier.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getActiveToolForMouseEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseDownAnnotationAction.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseDown.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getToolsWithActionsForMouseEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseDownActivate.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseDoubleClick.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseDrag.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseMove.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseUp.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseWheel.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseToolEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getActiveToolForKeyboardEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/keyboardEventHandlers/keyDown.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getToolsWithActionsForKeyboardEvents.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/keyboardEventHandlers/keyUp.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/keyboardToolEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getActiveToolForTouchEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getToolsWithModesForTouchEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchStart.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchStartActivate.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchDrag.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchEnd.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchTap.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchPress.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchToolEventDispatcher.ts","webpack://cornerstoneTools3D/./src/store/addEnabledElement.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/getSynchronizersForViewport.ts","webpack://cornerstoneTools3D/./src/store/removeEnabledElement.ts","webpack://cornerstoneTools3D/./src/utilities/triggerAnnotationRenderForViewportIds.ts","webpack://cornerstoneTools3D/./src/eventListeners/annotations/annotationModifiedListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/annotations/annotationSelectionListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/segmentation/segmentationModifiedEventListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/segmentation/segmentationDataModifiedEventListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/segmentation/segmentationRepresentationModifiedEventListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/segmentation/segmentationRepresentationRemovedEventListener.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/removeSegmentationsFromToolGroup.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/destroyToolGroup.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/destroy.ts","webpack://cornerstoneTools3D/./src/init.ts","webpack://cornerstoneTools3D/./src/store/addTool.ts","webpack://cornerstoneTools3D/./src/store/cancelActiveManipulations.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/Synchronizer.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/createSynchronizer.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/destroy.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/getSynchronizer.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/getAllSynchronizers.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/destroySynchronizer.ts","webpack://cornerstoneTools3D/./src/cursors/MouseCursor.ts","webpack://cornerstoneTools3D/./src/enums/AnnotationStyleStates.ts","webpack://cornerstoneTools3D/./src/cursors/ImageMouseCursor.ts","webpack://cornerstoneTools3D/./src/cursors/SVGCursorDescriptor.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/config/ToolStyle.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/config/helpers.ts","webpack://cornerstoneTools3D/./src/cursors/SVGMouseCursor.ts","webpack://cornerstoneTools3D/./src/cursors/elementCursor.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/ToolGroup.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/createToolGroup.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/getAllToolGroups.ts","webpack://cornerstoneTools3D/./src/constants/COLOR_LUT.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/cameraSyncCallback.ts","webpack://cornerstoneTools3D/./src/synchronizers/synchronizers/createCameraPositionSynchronizer.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/voiSyncCallback.ts","webpack://cornerstoneTools3D/./src/synchronizers/synchronizers/createVOISynchronizer.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/zoomPanSyncCallback.ts","webpack://cornerstoneTools3D/./src/synchronizers/synchronizers/createZoomPanSynchronizer.ts","webpack://cornerstoneTools3D/./src/utilities/clip.js","webpack://cornerstoneTools3D/./src/utilities/scroll.ts","webpack://cornerstoneTools3D/./src/utilities/viewport/jumpToSlice.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/imageSliceSyncCallback.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/areViewportsCoplanar .ts","webpack://cornerstoneTools3D/./src/synchronizers/synchronizers/createImageSliceSynchronizer.ts","webpack://cornerstoneTools3D/./src/synchronizers/index.ts","webpack://cornerstoneTools3D/./src/drawingSvg/_getHash.ts","webpack://cornerstoneTools3D/./src/drawingSvg/setAttributesIfNecessary.ts","webpack://cornerstoneTools3D/./src/drawingSvg/setNewAttributesIfValid.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawCircle.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawEllipseByCoordinates.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawEllipse.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawHandle.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawHandles.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawLine.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawPolyline.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawTextBox.ts","webpack://cornerstoneTools3D/./src/utilities/math/vec2/findClosestPoint.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawLink.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawLinkedTextBox.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawRect.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawArrow.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawRedactionRect.ts","webpack://cornerstoneTools3D/./src/utilities/getAnnotationNearPoint.ts","webpack://cornerstoneTools3D/./src/utilities/isObject.js","webpack://cornerstoneTools3D/./src/utilities/debounce.js","webpack://cornerstoneTools3D/./src/utilities/throttle.js","webpack://cornerstoneTools3D/./src/utilities/calibrateImageSpacing.ts","webpack://cornerstoneTools3D/./src/utilities/getCalibratedUnits.ts","webpack://cornerstoneTools3D/./src/utilities/pointInShapeCallback.ts","webpack://cornerstoneTools3D/./src/utilities/boundingBox/getBoundingBoxAroundShape.ts","webpack://cornerstoneTools3D/./src/utilities/getSphereBoundsInfo.ts","webpack://cornerstoneTools3D/./src/utilities/annotationFrameRange.ts","webpack://cornerstoneTools3D/./src/utilities/contours/contourFinder.ts","webpack://cornerstoneTools3D/./src/utilities/contours/mergePoints.ts","webpack://cornerstoneTools3D/./src/utilities/contours/detectContourHoles.ts","webpack://cornerstoneTools3D/./src/utilities/contours/generateContourSetsFromLabelmap.ts","webpack://cornerstoneTools3D/./src/utilities/contours/RectangleROIStartEndThreshold.ts","webpack://cornerstoneTools3D/./src/utilities/contours/AnnotationToPointData.ts","webpack://cornerstoneTools3D/./src/enums/StrategyCallbacks.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/compositions/determineSegmentIndex.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/compositions/dynamicThreshold.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/compositions/erase.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/floodFill.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/config/segmentationColor.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/compositions/preview.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/compositions/index.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/compositions/islandRemoval.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/compositions/regionFill.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/compositions/setValue.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/compositions/threshold.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/utils/getStrategyData.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/BrushStrategy.ts","webpack://cornerstoneTools3D/./src/utilities/math/ellipse/getCanvasEllipseCorners.ts","webpack://cornerstoneTools3D/./src/utilities/math/ellipse/pointInEllipse.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/fillCircle.ts","webpack://cornerstoneTools3D/./src/utilities/math/sphere/pointInSphere.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/fillSphere.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/eraseSphere.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/eraseCircle.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/activeSegmentation.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/segmentLocking.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/invalidateBrushCursor.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/segmentIndex.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/BrushTool.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/utilities.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/thresholdVolumeByRange.ts","webpack://cornerstoneTools3D/./src/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.ts","webpack://cornerstoneTools3D/./src/utilities/viewportFilters/filterViewportsWithToolEnabled.ts","webpack://cornerstoneTools3D/./src/utilities/viewportFilters/filterViewportsWithParallelNormals.ts","webpack://cornerstoneTools3D/./src/utilities/viewportFilters/getViewportIdsWithToolToRender.ts","webpack://cornerstoneTools3D/./src/utilities/planar/filterAnnotationsWithinSlice.ts","webpack://cornerstoneTools3D/./src/utilities/planar/filterAnnotationsForDisplay.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/config/getState.ts","webpack://cornerstoneTools3D/./src/tools/base/AnnotationDisplayTool.ts","webpack://cornerstoneTools3D/./src/tools/base/AnnotationTool.ts","webpack://cornerstoneTools3D/./src/utilities/math/point/distanceToPointSquared.ts","webpack://cornerstoneTools3D/./src/utilities/math/line/distanceToPointSquaredInfo.ts","webpack://cornerstoneTools3D/./src/utilities/math/line/distanceToPointSquared.ts","webpack://cornerstoneTools3D/./src/utilities/math/line/distanceToPoint.ts","webpack://cornerstoneTools3D/./src/utilities/math/rectangle/distanceToPoint.ts","webpack://cornerstoneTools3D/./src/utilities/drawing/getTextBoxCoordsCanvas.ts","webpack://cornerstoneTools3D/./src/utilities/planar/getWorldWidthAndHeightFromCorners.ts","webpack://cornerstoneTools3D/./src/utilities/getModalityUnit.ts","webpack://cornerstoneTools3D/./src/utilities/viewport/isViewportPreScaled.ts","webpack://cornerstoneTools3D/./src/utilities/math/basic/Calculator.ts","webpack://cornerstoneTools3D/./src/utilities/math/basic/BasicStatsCalculator.ts","webpack://cornerstoneTools3D/./src/tools/annotation/RectangleROITool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/RectangleROIThresholdTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/RectangleROIStartEndThresholdTool.ts","webpack://cornerstoneTools3D/./src/utilities/boundingBox/extend2DBoundingBoxInViewAxis.ts","webpack://cornerstoneTools3D/./src/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/rectangleROIThresholdVolumeByRange.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/createMergedLabelmapForIndex.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/isValidRepresentationConfig.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/getDefaultRepresentationConfig.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/createLabelmapVolumeForViewport.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/brushSizeForToolGroup.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/brushThresholdForToolGroup.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/thresholdSegmentationByRange.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/createImageIdReferenceMap.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/isLineInSegment.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/findLargestBidirectional.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/contourAndFindLargestBidirectional.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/createBidirectionalToolData.ts","webpack://cornerstoneTools3D/./src/utilities/math/line/intersectLine.ts","webpack://cornerstoneTools3D/./src/tools/annotation/BidirectionalTool.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/segmentContourAction.ts","webpack://cornerstoneTools3D/./src/utilities/math/aabb/distanceToPointSquared.ts","webpack://cornerstoneTools3D/./src/utilities/math/aabb/distanceToPoint.ts","webpack://cornerstoneTools3D/./src/utilities/math/point/distanceToPoint.ts","webpack://cornerstoneTools3D/./src/utilities/math/point/mirror.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/getIntersectionWithPolyline.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/getSubPixelSpacingAndXYDirections.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/pointsAreWithinCloseContourProximity.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/addCanvasPointsToArray.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/pointCanProjectOnLine.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/calculateAreaOfPoints.ts","webpack://cornerstoneTools3D/./src/utilities/math/vec2/liangBarksyClip.ts","webpack://cornerstoneTools3D/./src/utilities/planar/getPointInLineOfSightWithCriteria.ts","webpack://cornerstoneTools3D/./src/utilities/planar/index.ts","webpack://cornerstoneTools3D/./src/utilities/orientation/getOrientationStringLPS.ts","webpack://cornerstoneTools3D/./src/utilities/orientation/invertOrientationStringLPS.ts","webpack://cornerstoneTools3D/./src/utilities/cine/events.ts","webpack://cornerstoneTools3D/./src/utilities/cine/state.ts","webpack://cornerstoneTools3D/./src/utilities/cine/playClip.ts","webpack://cornerstoneTools3D/../../node_modules/d3-interpolate/src/basis.js","webpack://cornerstoneTools3D/../../node_modules/d3-interpolate/src/quantize.js","webpack://cornerstoneTools3D/../../node_modules/d3-array/src/transpose.js","webpack://cornerstoneTools3D/../../node_modules/d3-array/src/zip.js","webpack://cornerstoneTools3D/../../node_modules/d3-array/src/min.js","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints.ts","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/interpolation/algorithms/bspline.ts","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/interpolatePoints.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/findOpenUShapedContourVectorToPeak.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/drawLoop.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/editLoopCommon.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/closedContourEditLoop.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/openContourEditLoop.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/openContourEndEditLoop.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/renderMethods.ts","webpack://cornerstoneTools3D/./src/tools/base/ContourBaseTool.ts","webpack://cornerstoneTools3D/./src/tools/base/ContourSegmentationBaseTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/PlanarFreehandROITool.ts","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/interpolateAnnotation.ts","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/index.ts","webpack://cornerstoneTools3D/./src/utilities/rectangleROITool/isAxisAlignedRectangle.ts","webpack://cornerstoneTools3D/./src/utilities/stackPrefetch/state.ts","webpack://cornerstoneTools3D/./src/utilities/stackPrefetch/stackPrefetchUtils.ts","webpack://cornerstoneTools3D/./src/utilities/stackPrefetch/stackPrefetch.ts","webpack://cornerstoneTools3D/./src/utilities/stackPrefetch/stackContextPrefetch.ts","webpack://cornerstoneTools3D/./src/utilities/viewport/jumpToWorld.ts","webpack://cornerstoneTools3D/./src/utilities/dynamicVolume/getDataInTime.ts","webpack://cornerstoneTools3D/./src/utilities/dynamicVolume/generateImageFromTimeData.ts","webpack://cornerstoneTools3D/./src/utilities/polyData/utils.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/common/isRangeValid.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/common/areColorbarRangesEqual.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/common/isColorbarSizeValid.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/common/areColorbarSizesEqual.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/ColorbarCanvas.ts","webpack://cornerstoneTools3D/./src/utilities/math/vec3/interpolateVec3.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/ColorbarTicks.ts","webpack://cornerstoneTools3D/./src/widgets/Widget.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/Colorbar.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/common/isRangeTextPositionValid.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/ViewportColorbar.ts","webpack://cornerstoneTools3D/./src/utilities/getVOIMultipliers.ts","webpack://cornerstoneTools3D/./src/utilities/index.ts","webpack://cornerstoneTools3D/./src/cursors/setCursorForElement.ts","webpack://cornerstoneTools3D/./src/cursors/index.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/config/getFont.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/AnnotationGroup.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/validateRepresentationData.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/helpers/validateSegmentationInput.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/addSegmentations.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/helpers/getRepresentationSpecificConfig.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/addSegmentationRepresentations.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/addSegmentationRepresentation.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/convertStackToVolumeSegmentation.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/convertVolumeToStackSegmentation.ts","webpack://cornerstoneTools3D/./src/tools/PanTool.ts","webpack://cornerstoneTools3D/./src/tools/TrackballRotateTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/ProbeTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/DragProbeTool.ts","webpack://cornerstoneTools3D/./src/tools/WindowLevelTool.ts","webpack://cornerstoneTools3D/./src/tools/ZoomTool.ts","webpack://cornerstoneTools3D/./src/tools/StackScrollTool.ts","webpack://cornerstoneTools3D/./src/utilities/math/angle/angleBetweenLines.ts","webpack://cornerstoneTools3D/./src/tools/PlanarRotateTool.ts","webpack://cornerstoneTools3D/./src/tools/StackScrollToolMouseWheelTool.ts","webpack://cornerstoneTools3D/./src/tools/VolumeRotateMouseWheelTool.ts","webpack://cornerstoneTools3D/./src/tools/MIPJumpToClickTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/LengthTool.ts","webpack://cornerstoneTools3D/./src/tools/CrosshairsTool.ts","webpack://cornerstoneTools3D/./src/tools/ReferenceLinesTool.ts","webpack://cornerstoneTools3D/./src/tools/OverlayGridTool.ts","webpack://cornerstoneTools3D/./src/tools/SegmentationIntersectionTool.ts","webpack://cornerstoneTools3D/./src/utilities/planar/getWorldWidthAndHeightFromTwoPoints.ts","webpack://cornerstoneTools3D/./src/tools/annotation/EllipticalROITool.ts","webpack://cornerstoneTools3D/./src/utilities/math/circle/getCanvasCircleRadius.ts","webpack://cornerstoneTools3D/./src/utilities/math/circle/getCanvasCircleCorners.ts","webpack://cornerstoneTools3D/./src/tools/annotation/CircleROITool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/splines/Spline.ts","webpack://cornerstoneTools3D/./src/tools/annotation/splines/CubicSpline.ts","webpack://cornerstoneTools3D/./src/tools/annotation/splines/CardinalSpline.ts","webpack://cornerstoneTools3D/./src/tools/annotation/splines/LinearSpline.ts","webpack://cornerstoneTools3D/./src/tools/annotation/splines/CatmullRomSpline.ts","webpack://cornerstoneTools3D/./src/tools/annotation/splines/BSpline.ts","webpack://cornerstoneTools3D/./src/tools/annotation/SplineROITool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/SplineContourSegmentationTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/PlanarFreehandContourSegmentationTool.ts","webpack://cornerstoneTools3D/./src/utilities/BucketQueue.ts","webpack://cornerstoneTools3D/./src/utilities/livewire/LivewireScissors.ts","webpack://cornerstoneTools3D/./src/utilities/livewire/LiveWirePath.ts","webpack://cornerstoneTools3D/./src/tools/annotation/LivewireContourTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/LivewireContourSegmentationTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/ArrowAnnotateTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/AngleTool.ts","webpack://cornerstoneTools3D/./src/utilities/math/midPoint.ts","webpack://cornerstoneTools3D/./src/tools/annotation/CobbAngleTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/UltrasoundDirectionalTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/KeyImageTool.ts","webpack://cornerstoneTools3D/./src/tools/MagnifyTool.ts","webpack://cornerstoneTools3D/./src/tools/AdvancedMagnifyViewport.ts","webpack://cornerstoneTools3D/./src/tools/AdvancedMagnifyViewportManager.ts","webpack://cornerstoneTools3D/./src/tools/AdvancedMagnifyTool.ts","webpack://cornerstoneTools3D/./src/tools/ReferenceCursors.ts","webpack://cornerstoneTools3D/./src/tools/ScaleOverlayTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/fillRectangle.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/eraseRectangle.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/RectangleScissorsTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/CircleScissorsTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/SphereScissorsTool.ts","webpack://cornerstoneTools3D/./src/tools/OrientationMarkerTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/SegmentSelectTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/PaintFillTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/VideoRedactionTool.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"gl-matrix\"), require(\"@cornerstonejs/core\"), require(\"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\"), require(\"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\"), require(\"@kitware/vtk.js/Common/Core/CellArray\"), require(\"@kitware/vtk.js/Common/Core/Points\"), require(\"@kitware/vtk.js/Common/DataModel/PolyData\"), require(\"@kitware/vtk.js/Common/Core/DataArray\"), require(\"@kitware/vtk.js/Filters/General/AppendPolyData\"), require(\"@kitware/vtk.js/Rendering/Core/Actor\"), require(\"@kitware/vtk.js/Rendering/Core/Mapper\"), require(\"@kitware/vtk.js/Filters/General/ClipClosedSurface\"), require(\"@kitware/vtk.js/Common/DataModel/ImageData\"), require(\"@kitware/vtk.js/Common/Core/Math\"), require(\"@kitware/vtk.js/Filters/General/ImageMarchingSquares\"), require(\"@kitware/vtk.js/Common/Core/MatrixBuilder\"), require(\"@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget\"), require(\"@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor\"), require(\"@kitware/vtk.js/Rendering/Core/AxesActor\"), require(\"@kitware/vtk.js/IO/XML/XMLPolyDataReader\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"gl-matrix\", \"@cornerstonejs/core\", \"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\", \"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\", \"@kitware/vtk.js/Common/Core/CellArray\", \"@kitware/vtk.js/Common/Core/Points\", \"@kitware/vtk.js/Common/DataModel/PolyData\", \"@kitware/vtk.js/Common/Core/DataArray\", \"@kitware/vtk.js/Filters/General/AppendPolyData\", \"@kitware/vtk.js/Rendering/Core/Actor\", \"@kitware/vtk.js/Rendering/Core/Mapper\", \"@kitware/vtk.js/Filters/General/ClipClosedSurface\", \"@kitware/vtk.js/Common/DataModel/ImageData\", \"@kitware/vtk.js/Common/Core/Math\", \"@kitware/vtk.js/Filters/General/ImageMarchingSquares\", \"@kitware/vtk.js/Common/Core/MatrixBuilder\", \"@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget\", \"@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor\", \"@kitware/vtk.js/Rendering/Core/AxesActor\", \"@kitware/vtk.js/IO/XML/XMLPolyDataReader\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cornerstoneTools3D\"] = factory(require(\"gl-matrix\"), require(\"@cornerstonejs/core\"), require(\"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\"), require(\"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\"), require(\"@kitware/vtk.js/Common/Core/CellArray\"), require(\"@kitware/vtk.js/Common/Core/Points\"), require(\"@kitware/vtk.js/Common/DataModel/PolyData\"), require(\"@kitware/vtk.js/Common/Core/DataArray\"), require(\"@kitware/vtk.js/Filters/General/AppendPolyData\"), require(\"@kitware/vtk.js/Rendering/Core/Actor\"), require(\"@kitware/vtk.js/Rendering/Core/Mapper\"), require(\"@kitware/vtk.js/Filters/General/ClipClosedSurface\"), require(\"@kitware/vtk.js/Common/DataModel/ImageData\"), require(\"@kitware/vtk.js/Common/Core/Math\"), require(\"@kitware/vtk.js/Filters/General/ImageMarchingSquares\"), require(\"@kitware/vtk.js/Common/Core/MatrixBuilder\"), require(\"@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget\"), require(\"@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor\"), require(\"@kitware/vtk.js/Rendering/Core/AxesActor\"), require(\"@kitware/vtk.js/IO/XML/XMLPolyDataReader\"));\n\telse\n\t\troot[\"cornerstoneTools3D\"] = factory(root[\"window\"], root[\"cornerstone3D\"], root[\"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\"], root[\"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\"], root[\"@kitware/vtk.js/Common/Core/CellArray\"], root[\"@kitware/vtk.js/Common/Core/Points\"], root[\"@kitware/vtk.js/Common/DataModel/PolyData\"], root[\"@kitware/vtk.js/Common/Core/DataArray\"], root[\"@kitware/vtk.js/Filters/General/AppendPolyData\"], root[\"@kitware/vtk.js/Rendering/Core/Actor\"], root[\"@kitware/vtk.js/Rendering/Core/Mapper\"], root[\"@kitware/vtk.js/Filters/General/ClipClosedSurface\"], root[\"@kitware/vtk.js/Common/DataModel/ImageData\"], root[\"@kitware/vtk.js/Common/Core/Math\"], root[\"@kitware/vtk.js/Filters/General/ImageMarchingSquares\"], root[\"@kitware/vtk.js/Common/Core/MatrixBuilder\"], root[\"@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget\"], root[\"@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor\"], root[\"@kitware/vtk.js/Rendering/Core/AxesActor\"], root[\"@kitware/vtk.js/IO/XML/XMLPolyDataReader\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__976__, __WEBPACK_EXTERNAL_MODULE__953__, __WEBPACK_EXTERNAL_MODULE__441__, __WEBPACK_EXTERNAL_MODULE__795__, __WEBPACK_EXTERNAL_MODULE__396__, __WEBPACK_EXTERNAL_MODULE__348__, __WEBPACK_EXTERNAL_MODULE__70__, __WEBPACK_EXTERNAL_MODULE__785__, __WEBPACK_EXTERNAL_MODULE__127__, __WEBPACK_EXTERNAL_MODULE__474__, __WEBPACK_EXTERNAL_MODULE__610__, __WEBPACK_EXTERNAL_MODULE__448__, __WEBPACK_EXTERNAL_MODULE__283__, __WEBPACK_EXTERNAL_MODULE__807__, __WEBPACK_EXTERNAL_MODULE__543__, __WEBPACK_EXTERNAL_MODULE__847__, __WEBPACK_EXTERNAL_MODULE__518__, __WEBPACK_EXTERNAL_MODULE__744__, __WEBPACK_EXTERNAL_MODULE__424__, __WEBPACK_EXTERNAL_MODULE__614__) => {\nreturn ","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\n/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {boolean} [isFull] Specify a clone including symbols.\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      if (isHostObject(value)) {\n        return object ? value : {};\n      }\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (!isArr) {\n    var props = isFull ? getAllKeys(value) : keys(value);\n  }\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var result = new buffer.constructor(buffer.length);\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n  return object;\n}\n\n/**\n * Copies own symbol properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Creates an array of the own enumerable symbol properties of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, true, true);\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = cloneDeep;\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__396__;","module.exports = __WEBPACK_EXTERNAL_MODULE__785__;","module.exports = __WEBPACK_EXTERNAL_MODULE__807__;","module.exports = __WEBPACK_EXTERNAL_MODULE__847__;","module.exports = __WEBPACK_EXTERNAL_MODULE__348__;","module.exports = __WEBPACK_EXTERNAL_MODULE__283__;","module.exports = __WEBPACK_EXTERNAL_MODULE__441__;","module.exports = __WEBPACK_EXTERNAL_MODULE__70__;","module.exports = __WEBPACK_EXTERNAL_MODULE__127__;","module.exports = __WEBPACK_EXTERNAL_MODULE__448__;","module.exports = __WEBPACK_EXTERNAL_MODULE__543__;","module.exports = __WEBPACK_EXTERNAL_MODULE__614__;","module.exports = __WEBPACK_EXTERNAL_MODULE__518__;","module.exports = __WEBPACK_EXTERNAL_MODULE__474__;","module.exports = __WEBPACK_EXTERNAL_MODULE__744__;","module.exports = __WEBPACK_EXTERNAL_MODULE__424__;","module.exports = __WEBPACK_EXTERNAL_MODULE__795__;","module.exports = __WEBPACK_EXTERNAL_MODULE__610__;","module.exports = __WEBPACK_EXTERNAL_MODULE__953__;","module.exports = __WEBPACK_EXTERNAL_MODULE__976__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","/**\n *  The events for cornerstoneTools3D Tools. Native Mouse and Keyboard events are\n *  captured, normalized, and re-triggered with a `CORNERSTONE_TOOLS` prefix. This\n *  allows us to handle events consistently across different browsers.\n *\n */\nenum Events {\n  ///////////////////////////////////////\n  //            Tools\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a new tools is activated.\n   *\n   * Make use of {@link EventTypes.ToolActivatedEventType | Tool Activated Event Type  }\n   * for typing your event listeners for this tool activated event, and see what event\n   * detail is included in {@link EventTypes.ToolActivatedEventDetail | Tool Activated Event Detail}.\n   */\n  TOOL_ACTIVATED = 'CORNERSTONE_TOOLS_TOOL_ACTIVATED',\n\n  /**\n   * Triggers on the eventTarget when a mode of a tool is changed (active, passive, enabled and disabled).\n   *\n   * Make use of {@link EventTypes.ToolModeChangedEventType | Tool Mode Changed Event Type  }\n   * for typing your event listeners for this tool activated event, and see what event\n   * detail is included in {@link EventTypes.ToolModeChangedEventDetail | Tool Mode Changed Event Detail}.\n   */\n  TOOL_MODE_CHANGED = 'CORNERSTONE_TOOLS_TOOL_MODE_CHANGED',\n\n  ///////////////////////////////////////\n  //            Annotations\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a new annotation is added to the state.\n   *\n   * Make use of {@link EventTypes.AnnotationAddedEventType | Annotation Added Event Type  }\n   * for typing your event listeners for this annotation added event, and see what event\n   * detail is included in {@link EventTypes.AnnotationAddedEventDetail | Annotation Added Event Detail}.\n   */\n  ANNOTATION_ADDED = 'CORNERSTONE_TOOLS_ANNOTATION_ADDED',\n\n  /**\n   * Triggers on the eventTarget when a new annotation is completed its drawing\n   * Make use of {@link EventTypes.AnnotationCompletedEventType | Annotation Completed Event Type }\n   * for typing your event listeners for this annotation completed event, and see what event\n   * detail is included in {@link EventTypes.AnnotationCompletedEventDetail | Annotation Completed Event Detail}.\n   */\n  ANNOTATION_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_COMPLETED',\n\n  /**\n   * Triggers on the eventTarget when an annotation is modified (e.g. a handle is modified).\n   * Make use of {@link EventTypes.AnnotationModifiedEventType | Annotation Modified Event Type}\n   * for typing your event listeners for this annotation modified event, and see what\n   * event detail is included in {@link EventTypes.AnnotationModifiedEventDetail | Annotation Modified Event Detail}.\n   */\n  ANNOTATION_MODIFIED = 'CORNERSTONE_TOOLS_ANNOTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when an annotation is removed from the annotations manager.\n   * Make use of {@link EventTypes.AnnotationRemovedEventType | Annotation Removed Event Type}\n   * for typing your event listeners for this annotation removed event, and see what\n   * event detail is included in {@link EventTypes.AnnotationRemovedEventDetail | Annotation Removed Event Detail}.\n   */\n  ANNOTATION_REMOVED = 'CORNERSTONE_TOOLS_ANNOTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when an annotation selection status is changed.\n   * Make use of {@link EventTypes.AnnotationSelectionChangeEventType | Annotation Selection Change Event Type}\n   * for typing your event listeners for this annotation selection change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationSelectionChangeEventDetail | Annotation Selection Change Event Detail}.\n   */\n  ANNOTATION_SELECTION_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation locked status is changed.\n   * Make use of {@link EventTypes.AnnotationLockChangeEventType | Annotation Lock Change Event Type}\n   * for typing your event listeners for this annotation lock change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationLockChangeEventDetail | Annotation Lock Change Event Detail}.\n   */\n  ANNOTATION_LOCK_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation visible status is changed.\n   * Make use of {@link EventTypes.AnnotationVisibilityChangeEventType | Annotation Visible Change Event Type}\n   * for typing your event listeners for this annotation Hide change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationVisibilityChangeEventDetail | Annotation Visible Change Event Detail}.\n   */\n  ANNOTATION_VISIBILITY_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation is rendered.\n   * Make use of {@link EventTypes.AnnotationRenderedEventType | Annotation Rendered Event Type}\n   * for typing your event listeners for this annotation rendered event, and see what\n   * event detail is included in {@link EventTypes.AnnotationRenderedEventDetail | Annotation Rendered Event Detail}.\n   */\n  ANNOTATION_RENDERED = 'CORNERSTONE_TOOLS_ANNOTATION_RENDERED',\n\n  ///////////////////////////////////////\n  //        Segmentations Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is updated in the state manager.\n   * Make use of {@link EventTypes.SegmentationModifiedEventType | Segmentation Modified Event Type}\n   * for typing your event listeners for this segmentation modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationModifiedEventDetail | Segmentation Modified Event Detail}.\n   */\n  SEGMENTATION_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is rendered by the Segmentation Rendering Engine.\n   * Make use of {@link EventTypes.SegmentationRenderedEventType | Segmentation Rendered Event Type}\n   * for typing your event listeners for this segmentation rendered event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRenderedEventDetail | Segmentation Rendered Event Detail}.\n   */\n  SEGMENTATION_RENDERED = 'CORNERSTONE_TOOLS_SEGMENTATION_RENDERED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation representation of a toolGroup is modified in the state manager.\n   * Make use of {@link EventTypes.SegmentationRepresentationModifiedEventType | Segmentation Representation Modified Event Type}\n   * for typing your event listeners for this segmentation representation modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRepresentationModifiedEventDetail | Segmentation Representation Modified Event Detail}.\n   */\n  SEGMENTATION_REPRESENTATION_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is removed from the state manager.\n   * Make use of {@link EventTypes.SegmentationRemovedEventType | Segmentation Removed Event Type}\n   * for typing your event listeners for this segmentation removed event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRemovedEventDetail | Segmentation Removed Event Detail}.\n   */\n  SEGMENTATION_REMOVED = 'CORNERSTONE_TOOLS_SEGMENTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation representation of a toolGroup is removed in the state manager.\n   * Make use of {@link EventTypes.SegmentationRepresentationRemovedEventType | Segmentation Representation Removed Event Type}\n   * for typing your event listeners for this segmentation representation removed event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRepresentationRemovedEventDetail | Segmentation Representation Removed Event Detail}.\n   */\n  SEGMENTATION_REPRESENTATION_REMOVED = 'CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation data is modified (e.g., by brush tool).\n   * Make use of {@link EventTypes.SegmentationDataModifiedEventType | Segmentation Data Modified Event Type}\n   * for typing your event listeners for this segmentation data modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationDataModifiedEventDetail | Segmentation Data Modified Event Detail}.\n   */\n  SEGMENTATION_DATA_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED',\n\n  ///////////////////////////////////////\n  //         Keyboard Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a key on the keyboard is pressed.\n   * Make use of {@link EventTypes.KeyDownEventType | Key Down Event Type}\n   * for typing your event listeners for this key down event, and see what\n   * event detail is included in {@link EventTypes.KeyDownEventDetail | Key Down Event Detail}.\n   */\n  KEY_DOWN = 'CORNERSTONE_TOOLS_KEY_DOWN',\n\n  /**\n   * Triggers on the eventTarget when a key on the keyboard is released.\n   * Make use of {@link EventTypes.KeyUpEventType | Key Up Event Type}\n   * for typing your event listeners for this key up event, and see what\n   * event detail is included in {@link EventTypes.KeyUpEventDetail | Key Up Event Detail}.\n   */\n  KEY_UP = 'CORNERSTONE_TOOLS_KEY_UP',\n\n  ///////////////////////////////////////\n  //      Mouse Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when the mouse is pressed down, it is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseDownEventType | Mouse Down Event Type}\n   * for typing your event listeners for this mouse down event, and see what\n   * event detail is included in {@link EventTypes.MouseDownEventDetail | Mouse Down Event Detail}.\n   */\n  MOUSE_DOWN = 'CORNERSTONE_TOOLS_MOUSE_DOWN',\n\n  /**\n   * Triggers on the eventTarget when the mouse is released, it is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseUpEventType | Mouse Up Event Type}\n   * for typing your event listeners for this mouse up event, and see what\n   * event detail is included in {@link EventTypes.MouseUpEventDetail | Mouse Up Event Detail}.\n   */\n  MOUSE_UP = 'CORNERSTONE_TOOLS_MOUSE_UP',\n\n  /**\n   * Triggers on the eventTarget when a handled `MOUSE_DOWN` event does not `stopPropagation`. The hook\n   * we use to create new annotation for mouse events.\n   * Make use of {@link EventTypes.MouseDownActivateEventType | Mouse Down Activate Event Type}\n   * for typing your event listeners for this mouse down activate event, and see what\n   * event detail is included in {@link EventTypes.MouseDownActivateEventDetail | Mouse Down Activate Event Detail}.\n   */\n  MOUSE_DOWN_ACTIVATE = 'CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE',\n\n  /**\n   * Triggers on the event target when mouse is dragging an annotation or textBox.\n   * Make use of {@link EventTypes.MouseDragEventType | Mouse Drag Event Type}\n   * for typing your event listeners for this mouse drag event, and see what\n   * event detail is included in {@link EventTypes.MouseDragEventDetail | Mouse Drag Event Detail}.\n   */\n  MOUSE_DRAG = 'CORNERSTONE_TOOLS_MOUSE_DRAG',\n\n  /**\n   * Triggers on the eventTarget, when the mouse is moved, it is CornerstoneTools normalized event.\n   * It can be just a mouse move or when double click is performed and annotation\n   * drawing can be performed with just mouse move.\n   * Make use of {@link EventTypes.MouseMoveEventType | Mouse Move Event Type}\n   * for typing your event listeners for this mouse move event, and see what\n   * event detail is included in {@link EventTypes.MouseMoveEventDetail | Mouse Move Event Detail}.\n   */\n  MOUSE_MOVE = 'CORNERSTONE_TOOLS_MOUSE_MOVE',\n\n  /**\n   * Triggers on the eventTarget when a mouse click is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseClickEventType | Mouse Click Event Type}\n   * for typing your event listeners for this mouse click event, and see what\n   * event detail is included in {@link EventTypes.MouseClickEventDetail | Mouse Click Event Detail}.\n   */\n  MOUSE_CLICK = 'CORNERSTONE_TOOLS_MOUSE_CLICK',\n\n  /**\n   * Triggers on the eventTarget when a mouse double click is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseDoubleClickEventType | Mouse Double Click Event Type}\n   * for typing your event listeners for this mouse double click event, and see what\n   * event detail is included in {@link EventTypes.MouseDoubleClickEventDetail | Mouse Double Click Event Detail}.\n   */\n  MOUSE_DOUBLE_CLICK = 'CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK',\n\n  /**\n   * Triggers on the eventTarget when a mouse wheel event is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseWheelEventType | Mouse Wheel Event Type}\n   * for typing your event listeners for this mouse wheel event, and see what\n   * event detail is included in {@link EventTypes.MouseWheelEventDetail | Mouse Wheel Event Detail}.\n   */\n  MOUSE_WHEEL = 'CORNERSTONE_TOOLS_MOUSE_WHEEL',\n\n  // Todo: not being fired as of now\n  // ANNOTATION_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_COMPLETED',\n  // Todo: not implemented yet\n  // KEY_PRESS = 'CORNERSTONE_TOOLS_KEY_PRESS',\n\n  //////////////////////\n  //   Touch Events   //\n  //////////////////////\n  // The event flow looks like the following\n  // Touch Start -> (optional) Touch Press -> Touch Drag -> (optional) Touch Swipe -> Touch End\n  // Touch Tap\n  // mousedown\n  // mousedown, Touch Start, and Tap are mutually exclusive events\n  TOUCH_START = 'CORNERSTONE_TOOLS_TOUCH_START',\n  TOUCH_START_ACTIVATE = 'CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE',\n  TOUCH_PRESS = 'CORNERSTONE_TOOLS_TOUCH_PRESS',\n  TOUCH_DRAG = 'CORNERSTONE_TOOLS_TOUCH_DRAG',\n  TOUCH_END = 'CORNERSTONE_TOOLS_TOUCH_END',\n  TOUCH_TAP = 'CORNERSTONE_TOOLS_TAP',\n  TOUCH_SWIPE = 'CORNERSTONE_TOOLS_SWIPE',\n}\n\nexport default Events;\n","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { Annotation } from '../../types';\nimport { AnnotationLockChangeEventDetail } from '../../types/EventTypes';\n\n/*\n * Constants\n */\nconst globalLockedAnnotationsSet: Set<Annotation> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set the \"Locked\" state of a given annotation instance.\n *\n * @triggers ANNOTATION_LOCK_CHANGE\n *\n * @param annotation - The annotation instance which will have\n * its locked state changed. An event will only be triggered if the locked state\n * of the given annotation instance changed.\n * @param locked - A boolean value indicating if the instance should\n * be locked (true) or not (false)\n */\nfunction setAnnotationLocked(annotation: Annotation, locked = true): void {\n  const detail = makeEventDetail();\n  if (annotation) {\n    if (locked) {\n      lock(annotation, globalLockedAnnotationsSet, detail);\n    } else {\n      unlock(annotation, globalLockedAnnotationsSet, detail);\n    }\n  }\n  publish(detail, globalLockedAnnotationsSet);\n}\n\n/**\n * Clears all the locked annotation\n *\n */\nfunction unlockAllAnnotations(): void {\n  const detail = makeEventDetail();\n  clearLockedAnnotationsSet(globalLockedAnnotationsSet, detail);\n  publish(detail, globalLockedAnnotationsSet);\n}\n\n/**\n * Returns an array of all the annotation that is currently locked\n * @returns An array of tool specific annotation objects.\n *\n */\nfunction getAnnotationsLocked(): Array<Annotation> {\n  return Array.from(globalLockedAnnotationsSet);\n}\n\n/**\n * Given a Annotation object, return true if it is locked.\n * @param annotation - Annotation\n * @returns A boolean value.\n */\nfunction isAnnotationLocked(annotation: Annotation): boolean {\n  return globalLockedAnnotationsSet.has(annotation);\n}\n\n/**\n * Get the number of locked annotation objects in the global set of locked annotation\n * objects.\n * @returns The number of locked annotation objects.\n *\n */\nfunction getAnnotationsLockedCount(): number {\n  return globalLockedAnnotationsSet.size;\n}\n\n/**\n * Properly initialize the isLocked on annotation, and set it as locked if\n * isLocked is true.\n * @param annotation - The annotation object to be checked.\n */\nfunction checkAndDefineIsLockedProperty(annotation: Annotation): void {\n  if (annotation) {\n    const isLocked = !!annotation.isLocked;\n    if (shouldDefineIsLockedProperty(annotation)) {\n      Object.defineProperty(annotation, 'isLocked', {\n        configurable: false,\n        enumerable: true,\n        set: setIsLocked,\n        get: getIsLocked,\n      });\n    }\n    setAnnotationLocked(annotation, isLocked);\n  }\n}\n\n/*\n * Private Helpers\n */\n\nfunction makeEventDetail(): AnnotationLockChangeEventDetail {\n  return Object.freeze({\n    added: [],\n    removed: [],\n    locked: [],\n  });\n}\n\nfunction lock(\n  annotation: Annotation,\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  if (!lockedAnnotationsSet.has(annotation)) {\n    lockedAnnotationsSet.add(annotation);\n    detail.added.push(annotation);\n  }\n}\n\nfunction unlock(\n  annotation: Annotation,\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  if (lockedAnnotationsSet.delete(annotation)) {\n    detail.removed.push(annotation);\n  }\n}\n\nfunction clearLockedAnnotationsSet(\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  lockedAnnotationsSet.forEach((annotation) => {\n    unlock(annotation, lockedAnnotationsSet, detail);\n  });\n}\n\nfunction publish(\n  detail: AnnotationLockChangeEventDetail,\n  lockedAnnotationsSet: Set<Annotation>\n) {\n  if (detail.added.length > 0 || detail.removed.length > 0) {\n    lockedAnnotationsSet.forEach((item) => void detail.locked.push(item));\n    triggerEvent(eventTarget, Events.ANNOTATION_LOCK_CHANGE, detail);\n  }\n}\n\nfunction shouldDefineIsLockedProperty(annotation: Annotation): boolean {\n  const descriptor = Object.getOwnPropertyDescriptor(annotation, 'isLocked');\n  if (descriptor) {\n    return (\n      descriptor.configurable &&\n      (descriptor.set !== setIsLocked || descriptor.get !== getIsLocked)\n    );\n  }\n  return Object.isExtensible(annotation);\n}\n\nfunction setIsLocked(locked: boolean) {\n  setAnnotationLocked(this as Annotation, locked);\n}\n\nfunction getIsLocked() {\n  return isAnnotationLocked(this as Annotation);\n}\n\n/*\n * Exports\n */\n\nexport {\n  setAnnotationLocked,\n  getAnnotationsLocked,\n  getAnnotationsLockedCount,\n  unlockAllAnnotations,\n  isAnnotationLocked,\n  checkAndDefineIsLockedProperty,\n};\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { AnnotationSelectionChangeEventDetail } from '../../types/EventTypes';\nimport { getAnnotation } from './annotationState';\n\n/*\n * Constants\n */\n\nconst selectedAnnotationUIDs: Set<string> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set a given annotationUID as selected or deselected based on the provided\n * selected value.\n *\n * @param annotationUID - The annotation UID to be selected\n * @param selected - When true, the annotation is selected. When false, the annotation is deselected.\n * @param preserveSelected - When true, preserves existing\n *  selections (i.e., the given annotation is appended to the selection set).\n *  When false (the default behavior) the currently selected items are discarded\n *  (i.e., the given annotation instance replaces the currently selected ones).\n */\nfunction setAnnotationSelected(\n  annotationUID: string,\n  selected = true,\n  preserveSelected = false\n): void {\n  if (selected) {\n    selectAnnotation(annotationUID, preserveSelected);\n  } else {\n    deselectAnnotation(annotationUID);\n  }\n}\n\n/**\n * Set a given annotation as selected.\n *\n * @param annotationUID - The annotation UID to be selected\n * @param preserveSelected - When true, preserves existing\n *  selections (i.e., the given annotation is appended to the selection set).\n *  When false (the default behavior) the currently selected items are discarded\n *  (i.e., the given annotation instance replaces the currently selected ones).\n */\nfunction selectAnnotation(\n  annotationUID: string,\n  preserveSelected = false\n): void {\n  const detail = makeEventDetail();\n  if (!preserveSelected) {\n    clearSelectionSet(selectedAnnotationUIDs, detail);\n  }\n  if (annotationUID && !selectedAnnotationUIDs.has(annotationUID)) {\n    selectedAnnotationUIDs.add(annotationUID);\n    detail.added.push(annotationUID);\n  }\n  publish(detail, selectedAnnotationUIDs);\n}\n\n/**\n * Deselect one or all annotations.\n *\n * @param annotationUID - If an annotation is provided that instance will be removed from\n * the internal selection set. If none is given, ALL selections will be cleared.\n */\nfunction deselectAnnotation(annotationUID?: string): void {\n  const detail = makeEventDetail();\n  if (annotationUID) {\n    if (selectedAnnotationUIDs.delete(annotationUID)) {\n      detail.removed.push(annotationUID);\n    }\n  } else {\n    clearSelectionSet(selectedAnnotationUIDs, detail);\n  }\n  publish(detail, selectedAnnotationUIDs);\n}\n\n/**\n * Return an array of ALL the selected annotationUIDs\n * @returns An array of Annotation UIDs\n */\nfunction getAnnotationsSelected(): Array<string> {\n  return Array.from(selectedAnnotationUIDs);\n}\n\n/**\n * Given a tool name, return ALL the annotationUIDs for that tool that are selected\n * @param toolName - The name of the tool you want to get the selected annotation for\n * @returns An array of annotationUIDs\n */\nfunction getAnnotationsSelectedByToolName(toolName: string): Array<string> {\n  return getAnnotationsSelected().filter((annotationUID) => {\n    const annotation = getAnnotation(annotationUID);\n    return annotation.metadata.toolName === toolName;\n  });\n}\n\n/**\n * Given an annotationUID, return true if it is selected, false\n * otherwise.\n * @param annotationUID - Annotation UID\n * @returns A boolean value.\n */\nfunction isAnnotationSelected(annotationUID: string): boolean {\n  return selectedAnnotationUIDs.has(annotationUID);\n}\n\n/**\n * Return the number of the selected annotation\n * @returns The size of the selected annotation set\n */\nfunction getAnnotationsSelectedCount(): number {\n  return selectedAnnotationUIDs.size;\n}\n\n/*\n * Private Helpers\n */\n\nfunction makeEventDetail(): AnnotationSelectionChangeEventDetail {\n  return Object.freeze({\n    added: [],\n    removed: [],\n    selection: [],\n  });\n}\n\nfunction clearSelectionSet(\n  selectionSet: Set<string>,\n  detail: AnnotationSelectionChangeEventDetail\n): void {\n  selectionSet.forEach((value) => {\n    if (selectionSet.delete(value)) {\n      detail.removed.push(value);\n    }\n  });\n}\n\nfunction publish(\n  detail: AnnotationSelectionChangeEventDetail,\n  selectionSet: Set<string>\n) {\n  if (detail.added.length > 0 || detail.removed.length > 0) {\n    selectionSet.forEach((item) => void detail.selection.push(item));\n    triggerEvent(eventTarget, Events.ANNOTATION_SELECTION_CHANGE, detail);\n  }\n}\n\n/*\n * Exports\n */\n\nexport {\n  setAnnotationSelected,\n  getAnnotationsSelected,\n  getAnnotationsSelectedByToolName,\n  getAnnotationsSelectedCount,\n  deselectAnnotation,\n  isAnnotationSelected,\n};\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { getAnnotation } from './annotationState';\nimport { Events } from '../../enums';\nimport { Annotation } from '../../types';\nimport { AnnotationVisibilityChangeEventDetail } from '../../types/EventTypes';\nimport {\n  isAnnotationSelected,\n  deselectAnnotation,\n} from './annotationSelection';\n\n/*\n * It stores all hidden annotation uids.\n */\nconst globalHiddenAnnotationUIDsSet: Set<string> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set the \"visible\" state of a given annotation instance.\n *\n * @event ANNOTATION_VISIBILITY_CHANGE\n *\n * @param annotationUID - The annotation uid which will have\n * its visible state changed. An event will only be triggered if the visible state\n * of the given annotation instance changed.\n * @param visible - A boolean value indicating if the instance should\n * be visible (true) or not (false)\n */\nfunction setAnnotationVisibility(annotationUID: string, visible = true): void {\n  const detail = makeEventDetail();\n  if (annotationUID) {\n    if (visible) {\n      show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n    } else {\n      hide(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n    }\n  }\n  publish(detail);\n}\n\n/**\n * Clears all the hidden annotations.\n *\n */\nfunction showAllAnnotations(): void {\n  const detail = makeEventDetail();\n  globalHiddenAnnotationUIDsSet.forEach((annotationUID) => {\n    show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n  });\n  publish(detail);\n}\n\n/**\n * Given an annotation UID, return true if it is visible, false if hidden and undefined if does not exist.\n * @param annotationUID - The annotation uid to tell if is visible or not.\n * @returns A boolean value or value if does not exist.\n */\nfunction isAnnotationVisible(annotationUID: string): boolean | undefined {\n  const annotation = getAnnotation(annotationUID);\n\n  if (annotation) {\n    return !globalHiddenAnnotationUIDsSet.has(annotationUID);\n  }\n}\n/**\n * It decorates given annotation with isVisible property.\n * It properly initializes the isVisible on annotation(the property will be create if does not exist yet)\n *\n * @param annotation - The annotation object to be checked.\n */\nfunction checkAndDefineIsVisibleProperty(annotation: Annotation): void {\n  if (annotation) {\n    const isVisible = annotation.isVisible ?? true;\n    if (shouldDefineIsVisibleProperty(annotation)) {\n      Object.defineProperty(annotation, 'isVisible', {\n        configurable: false,\n        enumerable: true,\n        set: setIsVisible,\n        get: getIsVisible,\n      });\n    }\n    setAnnotationVisibility(annotation.annotationUID, isVisible);\n  }\n}\n\n/*\n * Private Helpers\n */\nfunction makeEventDetail(): AnnotationVisibilityChangeEventDetail {\n  return Object.freeze({\n    lastVisible: [],\n    lastHidden: [],\n    hidden: [],\n  });\n}\n\nfunction show(\n  annotationUID: string,\n  annotationUIDsSet: Set<string>,\n  detail: AnnotationVisibilityChangeEventDetail\n): void {\n  if (annotationUIDsSet.delete(annotationUID)) {\n    detail.lastVisible.push(annotationUID);\n  }\n}\n\nfunction hide(\n  annotationUID: string,\n  annotationUIDsSet: Set<string>,\n  detail: AnnotationVisibilityChangeEventDetail\n): void {\n  if (!annotationUIDsSet.has(annotationUID)) {\n    annotationUIDsSet.add(annotationUID);\n    if (isAnnotationSelected(annotationUID)) {\n      deselectAnnotation(annotationUID);\n    }\n    detail.lastHidden.push(annotationUID);\n  }\n}\n\nfunction publish(detail: AnnotationVisibilityChangeEventDetail) {\n  if (detail.lastHidden.length > 0 || detail.lastVisible.length > 0) {\n    globalHiddenAnnotationUIDsSet.forEach(\n      (item) => void detail.hidden.push(item)\n    );\n    triggerEvent(eventTarget, Events.ANNOTATION_VISIBILITY_CHANGE, detail);\n  }\n}\n\nfunction shouldDefineIsVisibleProperty(annotation: Annotation): boolean {\n  const descriptor = Object.getOwnPropertyDescriptor(annotation, 'isVisible');\n  if (descriptor) {\n    return (\n      descriptor.configurable &&\n      (descriptor.set !== setIsVisible || descriptor.get !== getIsVisible)\n    );\n  }\n  return Object.isExtensible(annotation);\n}\n\nfunction setIsVisible(hidden: boolean) {\n  setAnnotationVisibility((this as Annotation).annotationUID, hidden);\n}\n\nfunction getIsVisible() {\n  return isAnnotationVisible((this as Annotation).annotationUID);\n}\n\nexport {\n  setAnnotationVisibility,\n  showAllAnnotations,\n  isAnnotationVisible,\n  checkAndDefineIsVisibleProperty,\n};\n","import cloneDeep from 'lodash.clonedeep';\nimport {\n  Annotation,\n  Annotations,\n  AnnotationState,\n  GroupSpecificAnnotations,\n} from '../../types/AnnotationTypes';\n\nimport { AnnotationGroupSelector, IAnnotationManager } from '../../types';\n\nimport {\n  Enums,\n  eventTarget,\n  getEnabledElement,\n  Types,\n  utilities,\n} from '@cornerstonejs/core';\n\nimport { checkAndDefineIsLockedProperty } from './annotationLocking';\nimport { checkAndDefineIsVisibleProperty } from './annotationVisibility';\n\n/**\n * This is the default annotation manager. It stores annotations by default\n * based on the FrameOfReferenceUID. However, it is possible to override the\n * getAnnotationStateKey function to store annotations based on any other\n * property of the element. When you write your custom annotation manager, you\n * can use the setAnnotationManager function to set your custom annotation.\n *\n * Note that this class is a singleton and should not be instantiated directly.\n * To get the stored annotations information you can use ToolState helpers.\n */\nclass FrameOfReferenceSpecificAnnotationManager implements IAnnotationManager {\n  private annotations: AnnotationState;\n  public readonly uid: string;\n\n  /**\n   * @param uid - The uid of the state manager. If omitted it is autogenerated.\n   */\n  constructor(uid?: string) {\n    if (!uid) {\n      uid = utilities.uuidv4();\n    }\n    this.annotations = {};\n    this.uid = uid;\n\n    // Listen to the IMAGE_VOLUME_MODIFIED event to invalidate data.\n    eventTarget.addEventListener(\n      Enums.Events.IMAGE_VOLUME_MODIFIED,\n      this._imageVolumeModifiedHandler\n    );\n  }\n\n  /**\n   * Default annotation manager works with FrameOfReferenceUID as the key. The\n   * manager adds them under the FrameOfReferenceUID for the element being\n   * annotated.\n   *\n   * @param annotationGroupSelector - element or a string that is provided\n   * to the annotation manager to get the key.\n   * @returns - The annotation state key for the element.\n   */\n  getGroupKey = (annotationGroupSelector: AnnotationGroupSelector): string => {\n    if (typeof annotationGroupSelector === 'string') {\n      return annotationGroupSelector;\n    }\n\n    const element = annotationGroupSelector;\n    const enabledElement = getEnabledElement(element);\n\n    if (!enabledElement) {\n      throw new Error(\n        'Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID'\n      );\n    }\n\n    return enabledElement.FrameOfReferenceUID;\n  };\n\n  /**\n   * When a volume is modified we invalidate all of the `annotations` on the\n   * volume's `FrameOfReferenceUID`. This is mainly to update statistics calculations\n   * when an annotation is drawn whilst data is still loading.\n   *\n   * @param evt - The IMAGE_VOLUME_MODIFIED rendering event.\n   */\n  _imageVolumeModifiedHandler = (\n    evt: Types.EventTypes.ImageVolumeModifiedEvent\n  ) => {\n    const eventDetail = evt.detail;\n    const { FrameOfReferenceUID } = eventDetail;\n\n    const annotations = this.annotations;\n    const frameOfReferenceSpecificAnnotations =\n      annotations[FrameOfReferenceUID];\n\n    if (!frameOfReferenceSpecificAnnotations) {\n      return;\n    }\n\n    Object.keys(frameOfReferenceSpecificAnnotations).forEach((toolName) => {\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[toolName];\n\n      toolSpecificAnnotations.forEach((annotation) => {\n        const invalidated = annotation.invalidated;\n\n        if (invalidated !== undefined) {\n          annotation.invalidated = true;\n        }\n      });\n    });\n  };\n\n  /**\n   * Returns all the available frameOfReferences inside the state manager\n   * @returns - All the added frames of references inside the manager\n   */\n  getFramesOfReference = (): Array<string> => {\n    return Object.keys(this.annotations);\n  };\n\n  /**\n   * Returns the annotations associated with the specified frameOfReference and tool, or\n   * all annotations for the group if the tool name is not provided.\n   *\n   * @param groupKey - The annotation group key to retrieve annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - Optional. The name of the tool to retrieve annotations for.\n   * @returns The annotations associated with the specified group (default FrameOfReferenceUID) and tool,\n   * or all annotations for the group (FrameOfReferenceUID) if the tool name is not provided.\n   */\n  getAnnotations = (\n    groupKey: string,\n    toolName?: string\n  ): GroupSpecificAnnotations | Annotations => {\n    const annotations = this.annotations;\n\n    if (!annotations[groupKey]) {\n      return [];\n    }\n\n    if (toolName) {\n      return annotations[groupKey][toolName];\n    }\n\n    return annotations[groupKey];\n  };\n\n  /**\n   * Given the unique identified for the some `annotation`, returns the `annotation`\n   * from the `annotations`. Each `annotation` has a unique identifier.\n   *\n   * @param annotationUID - The unique identifier of the `annotation`.\n   * @returns The retrieved `annotation`.\n   */\n  getAnnotation = (annotationUID: string): Annotation | undefined => {\n    const annotations = this.annotations;\n\n    for (const frameOfReferenceUID in annotations) {\n      const frameOfReferenceAnnotations = annotations[frameOfReferenceUID];\n\n      for (const toolName in frameOfReferenceAnnotations) {\n        const toolSpecificAnnotations = frameOfReferenceAnnotations[toolName];\n\n        for (const annotation of toolSpecificAnnotations) {\n          if (annotationUID === annotation.annotationUID) {\n            return annotation;\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * A function that returns the number of annotations for a given tool in the\n   * specific group (default FrameOfReferenceUID) IF no groupKey (FrameOfReferenceUID) is provided,\n   * it will return the number of annotations for the tool in all groups (FrameOfReferenceUIDs)\n   *\n   * @param groupKey - The annotation group key to retrieve annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - The name of the tool to retrieve data for.\n   *\n   * @returns The number of annotations for a given tool in the state\n   */\n  getNumberOfAnnotations = (groupKey: string, toolName?: string): number => {\n    const annotations = this.getAnnotations(groupKey, toolName);\n\n    if (!annotations.length) {\n      return 0;\n    }\n\n    if (toolName) {\n      return (annotations as Annotations).length;\n    }\n\n    let total = 0;\n\n    for (const toolName in annotations) {\n      total += annotations[toolName].length;\n    }\n\n    return total;\n  };\n\n  /**\n   * Adds an instance of `Annotation` to the `annotations`.\n   *\n   * @param annotation - The annotation to add.\n   * @param groupKey - The annotation group key to add the annotation to (in default manager it is FrameOfReferenceUID).\n   */\n  addAnnotation = (annotation: Annotation, groupKey?: string): void => {\n    const { metadata } = annotation;\n    const { FrameOfReferenceUID, toolName } = metadata;\n\n    groupKey = groupKey || FrameOfReferenceUID;\n\n    const annotations = this.annotations;\n\n    let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n    if (!frameOfReferenceSpecificAnnotations) {\n      annotations[groupKey] = {};\n\n      frameOfReferenceSpecificAnnotations = annotations[groupKey];\n    }\n\n    let toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n\n    if (!toolSpecificAnnotations) {\n      frameOfReferenceSpecificAnnotations[toolName] = [];\n\n      toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n    }\n\n    toolSpecificAnnotations.push(annotation);\n    checkAndDefineIsLockedProperty(annotation);\n    checkAndDefineIsVisibleProperty(annotation);\n  };\n\n  /**\n   * Given the unique identified for the some `annotation`, removes the `annotation`\n   * from the `annotations`.\n   *\n   * @param annotationUID - The unique identifier of the `annotation` to remove.\n   */\n  removeAnnotation = (annotationUID: string): void => {\n    const { annotations } = this;\n\n    for (const groupKey in annotations) {\n      const groupAnnotations = annotations[groupKey];\n\n      for (const toolName in groupAnnotations) {\n        const toolAnnotations = groupAnnotations[toolName];\n\n        const index = toolAnnotations.findIndex(\n          (annotation) => annotation.annotationUID === annotationUID\n        );\n\n        if (index !== -1) {\n          toolAnnotations.splice(index, 1);\n\n          if (toolAnnotations.length === 0) {\n            delete groupAnnotations[toolName];\n          }\n        }\n      }\n\n      if (Object.keys(groupAnnotations).length === 0) {\n        delete annotations[groupKey];\n      }\n    }\n  };\n\n  /**\n   * Removes all annotations associated with the specified group (FrameOfReferenceUID) and tool, or\n   * all annotations for the group (FrameOfReferenceUID) if the tool name is not provided.\n   *\n   * @param groupKey - The group key to remove annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - Optional. The name of the tool to remove annotations for.\n   */\n  removeAnnotations = (groupKey: string, toolName?: string): void => {\n    const annotations = this.annotations;\n    if (annotations[groupKey]) {\n      if (toolName) {\n        delete annotations[groupKey][toolName];\n      } else {\n        delete annotations[groupKey];\n      }\n    }\n  };\n\n  /**\n   * Returns a section of the annotations. Useful for serialization.\n   * If both groupKey (default manager is FrameOfReferenceUID) and toolName are provided, returns the corresponding Annotations instance\n   * for that groupKey (FrameOfReferenceUID) and toolName.\n   * If only groupKey is provided, returns the corresponding FrameOfReferenceSpecificAnnotations instance\n   * for that groupKey.\n   * If neither groupKey nor toolName is provided, returns the entire AnnotationState object.\n   * @param groupKey - Optional. The group key (e.g. FrameOfReferenceUID) to retrieve annotations for.\n   * @param toolName - Optional. The name of the tool to retrieve annotations for.\n   * @returns A section of the annotations.\n   */\n  saveAnnotations = (\n    groupKey?: string,\n    toolName?: string\n  ): AnnotationState | GroupSpecificAnnotations | Annotations => {\n    const annotations = this.annotations;\n\n    if (groupKey && toolName) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      if (!frameOfReferenceSpecificAnnotations) {\n        return;\n      }\n\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[toolName];\n\n      return cloneDeep(toolSpecificAnnotations);\n    } else if (groupKey) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      return cloneDeep(frameOfReferenceSpecificAnnotations);\n    }\n\n    return cloneDeep(annotations);\n  };\n\n  /**\n   * Restores a section of the `annotations`. Useful for loading in serialized data.\n   *\n   * - If no arguments are given, the entire `AnnotationState` instance is restored.\n   * - If the `FrameOfReferenceUID` is given, the corresponding\n   * `FrameOfReferenceSpecificAnnotations` instance is restored.\n   * - If both the `FrameOfReferenceUID` and the `toolName` are are given, the\n   * corresponding `Annotations` instance is restored.\n   *\n   * @param groupKey - A filter string for restoring only the `annotations` of a specific frame of reference.\n   * @param toolName - A filter string for restoring `annotation` for a specific tool on a specific frame of reference.\n   */\n  restoreAnnotations = (\n    state: AnnotationState | GroupSpecificAnnotations | Annotations,\n    groupKey?: string,\n    toolName?: string\n  ): void => {\n    const annotations = this.annotations;\n\n    if (groupKey && toolName) {\n      // Set Annotations for FrameOfReferenceUID and toolName.\n\n      let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      if (!frameOfReferenceSpecificAnnotations) {\n        annotations[groupKey] = {};\n\n        frameOfReferenceSpecificAnnotations = annotations[groupKey];\n      }\n\n      frameOfReferenceSpecificAnnotations[toolName] = <Annotations>state;\n    } else if (groupKey) {\n      // Set FrameOfReferenceSpecificAnnotations for FrameOfReferenceUID.\n\n      annotations[groupKey] = <GroupSpecificAnnotations>state;\n    } else {\n      // Set entire annotations\n      this.annotations = <AnnotationState>cloneDeep(state);\n    }\n  };\n\n  /**\n   * A function that returns the number of all annotations in the annotation state\n   *\n   * @returns The number of all annotations in the state\n   */\n  getNumberOfAllAnnotations = (): number => {\n    let count = 0;\n    const annotations = this.annotations;\n    for (const groupKey in annotations) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n      for (const toolName in frameOfReferenceSpecificAnnotations) {\n        const toolSpecificAnnotations =\n          frameOfReferenceSpecificAnnotations[toolName];\n        count += toolSpecificAnnotations.length;\n      }\n    }\n    return count;\n  };\n\n  /**\n   * Removes all annotations in the annotation state.\n   */\n  removeAllAnnotations = (): void => {\n    this.annotations = {};\n  };\n}\n\nconst defaultFrameOfReferenceSpecificAnnotationManager =\n  new FrameOfReferenceSpecificAnnotationManager('DEFAULT');\n\nexport { defaultFrameOfReferenceSpecificAnnotationManager };\nexport default FrameOfReferenceSpecificAnnotationManager;\n","let svgNodeCache = {};\n\nexport function resetSvgNodeCache(): void {\n  svgNodeCache = {};\n}\n\nexport default svgNodeCache;\n","import _cloneDeep from 'lodash.clonedeep';\n\nimport { IToolGroup, IToolClassReference } from '../types';\nimport Synchronizer from './SynchronizerManager/Synchronizer';\nimport svgNodeCache, { resetSvgNodeCache } from './svgNodeCache';\n\ninterface ICornerstoneTools3dState {\n  isInteractingWithTool: boolean;\n  isMultiPartToolActive: boolean;\n  tools: Record<\n    string,\n    {\n      toolClass: IToolClassReference;\n    }\n  >;\n  toolGroups: Array<IToolGroup>;\n  synchronizers: Array<Synchronizer>;\n  svgNodeCache: Record<string, unknown>;\n  enabledElements: Array<unknown>;\n  handleRadius: number;\n}\n\nconst defaultState: ICornerstoneTools3dState = {\n  isInteractingWithTool: false,\n  isMultiPartToolActive: false,\n  tools: {},\n  toolGroups: [],\n  synchronizers: [],\n  svgNodeCache: svgNodeCache,\n  // Should this be named... canvases?\n  enabledElements: [], // switch to Uids?\n  handleRadius: 6,\n};\n\nlet state: ICornerstoneTools3dState = {\n  isInteractingWithTool: false,\n  isMultiPartToolActive: false,\n  tools: {},\n  toolGroups: [],\n  synchronizers: [],\n  svgNodeCache: svgNodeCache,\n  // Should this be named... canvases?\n  enabledElements: [], // switch to Uids?\n  handleRadius: 6,\n};\n\nfunction resetCornerstoneToolsState(): void {\n  resetSvgNodeCache();\n  state = _cloneDeep(defaultState);\n}\n\nexport {\n  ICornerstoneTools3dState,\n  resetCornerstoneToolsState,\n  state,\n  state as default,\n};\n","/**\n * ToolModes - This enum defines the 4 tool states which are available.\n */\nenum ToolModes {\n  /**\n   * Active:\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\n   * - Can add data if an annotation tool.\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Active = 'Active',\n  /**\n   * Passive:\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Passive = 'Passive',\n  /**\n   * Enabled:\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Enabled = 'Enabled',\n  /**\n   * Disabled:\n   * - Annotation does not render.\n   */\n  Disabled = 'Disabled',\n}\n\nexport default ToolModes;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\nimport { ToolModes } from '../../enums';\n\nconst MODES = [ToolModes.Active, ToolModes.Passive, ToolModes.Enabled];\n\n/**\n * Returns the toolGroups that has the given toolName as active, passive\n * or enabled.\n * @param toolName - The name of the tool\n * @returns An array of tool groups.\n */\nfunction getToolGroupsWithToolName(toolName: string): IToolGroup[] | [] {\n  return state.toolGroups.filter(({ toolOptions }) => {\n    const toolGroupToolNames = Object.keys(toolOptions);\n\n    for (let i = 0; i < toolGroupToolNames.length; i++) {\n      if (toolName !== toolGroupToolNames[i]) {\n        continue;\n      }\n\n      /* filter out tools that don't have options */\n      if (!toolOptions[toolName]) {\n        continue;\n      }\n\n      if (MODES.includes(toolOptions[toolName].mode)) {\n        return true;\n      }\n    }\n    return false;\n  });\n}\n\nexport default getToolGroupsWithToolName;\n","import {\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { defaultFrameOfReferenceSpecificAnnotationManager } from './FrameOfReferenceSpecificAnnotationManager';\nimport { Annotations, Annotation } from '../../types/AnnotationTypes';\nimport { AnnotationRemovedEventDetail } from '../../types/EventTypes';\nimport { AnnotationGroupSelector } from '../../types';\nimport {\n  triggerAnnotationAddedForElement,\n  triggerAnnotationAddedForFOR,\n} from './helpers/state';\n\n// our default annotation manager\nlet defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\n\n/**\n * It returns the default annotations manager.\n * @returns the singleton default annotations manager.\n */\nfunction getAnnotationManager() {\n  return defaultManager;\n}\n\n/**\n * Set the annotation manager to be used for rendering, adding, removing, etc.\n * @param annotationManager - The annotation manager to be used\n */\nfunction setAnnotationManager(annotationManager) {\n  defaultManager = annotationManager;\n}\n\n// set back to default frameOfReferenceSpecificAnnotationManager\nfunction resetAnnotationManager() {\n  defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\n}\n\n/**\n * Returns the annotations for a given tool with the provided options that is\n * used to filter annotations based on the annotation manager.\n *\n * In our default implementation, the options are the element and/or the FrameOfReferenceUID.\n * Hence, the getAnnotations function will return the annotations for the given tool\n * that are associated with the FrameOfReferenceUID.\n *\n * @param toolName - The name of the tool.\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n * @returns The annotations corresponding to the Frame of Reference and the toolName.\n */\nfunction getAnnotations(\n  toolName: string,\n  annotationGroupSelector: AnnotationGroupSelector\n): Annotations {\n  const manager = getAnnotationManager();\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\n  return manager.getAnnotations(groupKey, toolName) as Annotations;\n}\n\n/**\n * Add the annotation to the annotation manager along with the options that is\n * used to filter the annotation manager and the annotation group that\n * the annotation belongs to.\n *\n * As a result, our default implementation will add the annotation to the\n * default manager using the FrameOfReferenceUID as the group key.\n *\n * @param annotation - The annotation that is being added to the annotations manager.\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n */\nfunction addAnnotation(\n  annotation: Annotation,\n  annotationGroupSelector: AnnotationGroupSelector\n): string {\n  if (!annotation.annotationUID) {\n    annotation.annotationUID = csUtils.uuidv4() as string;\n  }\n\n  const manager = getAnnotationManager();\n\n  // if the annotation manager selector is an element, trigger the\n  // annotation added event for that element.\n  if (annotationGroupSelector instanceof HTMLDivElement) {\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\n    manager.addAnnotation(annotation, groupKey);\n    triggerAnnotationAddedForElement(annotation, annotationGroupSelector);\n  } else {\n    // if no element is provided, render all viewports that have the\n    // same frame of reference.\n    // Todo: we should do something else here for other types of annotation managers.\n    manager.addAnnotation(annotation);\n    triggerAnnotationAddedForFOR(annotation);\n  }\n\n  return annotation.annotationUID;\n}\n\n/**\n * Get the number of annotations for a given tool with the provided options that is\n * used to filter annotations based on the annotation manager.\n *\n * In our default implementation, the options are the element and/or the FrameOfReferenceUID.\n * Hence, the getNumberOfAnnotations function will return the number of annotations for the given tool\n * that are associated with the FrameOfReferenceUID.\n *\n * @param toolName - The name of the tool\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n *\n */\nfunction getNumberOfAnnotations(\n  toolName: string,\n  annotationGroupSelector: AnnotationGroupSelector\n): number {\n  const manager = getAnnotationManager();\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\n\n  return manager.getNumberOfAnnotations(groupKey, toolName);\n}\n\n/**\n * Remove the annotation by UID of the annotation.\n * @param annotationUID - The unique identifier for the annotation.\n */\nfunction removeAnnotation(annotationUID: string): void {\n  if (!annotationUID) {\n    return;\n  }\n  const manager = getAnnotationManager();\n  const annotation = manager.getAnnotation(annotationUID);\n\n  // no need to continue in case there is no annotation.\n  if (!annotation) {\n    return;\n  }\n\n  manager.removeAnnotation(annotationUID);\n\n  // trigger annotation removed\n  const eventType = Events.ANNOTATION_REMOVED;\n\n  const eventDetail: AnnotationRemovedEventDetail = {\n    annotation,\n    annotationManagerUID: manager.uid,\n  };\n\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\n/**\n * Get the Annotation object by its UID\n * @param annotationUID - The unique identifier of the annotation.\n */\nfunction getAnnotation(annotationUID: string): Annotation {\n  const manager = getAnnotationManager();\n  const annotation = manager.getAnnotation(annotationUID);\n\n  return annotation;\n}\n\n/**\n * It removes all annotations from the default annotation manager\n */\nfunction removeAllAnnotations(): void {\n  const manager = getAnnotationManager();\n  manager.removeAllAnnotations();\n}\n\nexport {\n  getAnnotations,\n  getNumberOfAnnotations,\n  addAnnotation,\n  getAnnotation,\n  removeAnnotation,\n  removeAllAnnotations,\n  // annotation manager\n  setAnnotationManager,\n  getAnnotationManager,\n  resetAnnotationManager,\n};\n","import {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  getEnabledElementByIds,\n} from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nimport { Annotation } from '../../../types/AnnotationTypes';\nimport { getToolGroupsWithToolName } from '../../../store/ToolGroupManager';\nimport { AnnotationAddedEventDetail } from '../../../types/EventTypes';\n\n/**\n * It triggers an event for the element when an annotation is added\n * @param annotation - Annotation - The annotation that was added.\n * @param element - The element that the annotation was added to.\n */\nfunction triggerAnnotationAddedForElement(\n  annotation: Annotation,\n  element: HTMLDivElement\n) {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewportId } = enabledElement;\n\n  const eventType = Events.ANNOTATION_ADDED;\n\n  const eventDetail: AnnotationAddedEventDetail = {\n    annotation,\n    viewportId,\n    renderingEngineId: renderingEngine.id,\n  };\n\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\n/**\n * If the annotation has a FrameOfReferenceUID, it triggers the ANNOTATION_ADDED\n * event for all the viewports that has the same FrameOfReferenceUID.\n * @param annotation -  Annotation - The annotation that was added\n */\nfunction triggerAnnotationAddedForFOR(annotation: Annotation) {\n  const { toolName } = annotation.metadata;\n\n  const toolGroups = getToolGroupsWithToolName(toolName);\n  if (!toolGroups.length) {\n    return;\n  }\n\n  // Find the viewports in the toolGroups who has the same FrameOfReferenceUID\n  const viewportsToRender = [];\n  toolGroups.forEach((toolGroup) => {\n    toolGroup.viewportsInfo.forEach((viewportInfo) => {\n      const { renderingEngineId, viewportId } = viewportInfo;\n      const { FrameOfReferenceUID } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (annotation.metadata.FrameOfReferenceUID === FrameOfReferenceUID) {\n        viewportsToRender.push(viewportInfo);\n      }\n    });\n  });\n\n  const eventType = Events.ANNOTATION_ADDED;\n  const eventDetail: AnnotationAddedEventDetail = { annotation };\n\n  if (!viewportsToRender.length) {\n    triggerEvent(eventTarget, eventType, eventDetail);\n    return;\n  }\n\n  viewportsToRender.forEach(({ renderingEngineId, viewportId }) => {\n    eventDetail.viewportId = viewportId;\n    eventDetail.renderingEngineId = renderingEngineId;\n    triggerEvent(eventTarget, eventType, eventDetail);\n  });\n}\n\nexport { triggerAnnotationAddedForElement, triggerAnnotationAddedForFOR };\n","/**\n * Segmentations on viewports can be visualized in different ways. This enum\n * defines the different ways of visualizing segmentations. Currently, only\n * labelmap is supported.\n */\nenum SegmentationRepresentations {\n  Labelmap = 'LABELMAP',\n  Contour = 'CONTOUR',\n  Surface = 'SURFACE',\n}\n\nexport default SegmentationRepresentations;\n","import { ContourConfig } from '../../../types/ContourTypes';\n\nconst defaultContourConfig: ContourConfig = {\n  renderOutline: true,\n  outlineWidthActive: 2,\n  outlineWidthInactive: 2,\n  outlineOpacity: 1,\n  outlineOpacityInactive: 0.85,\n  renderFill: true,\n  fillAlpha: 1,\n  fillAlphaInactive: 0,\n};\n\nfunction getDefaultContourConfig(): ContourConfig {\n  return defaultContourConfig;\n}\n\nexport default getDefaultContourConfig;\n","import { LabelmapConfig } from '../../../types/LabelmapTypes';\n\nconst defaultLabelmapConfig: LabelmapConfig = {\n  renderOutline: true,\n  outlineWidthActive: 3,\n  outlineWidthInactive: 2,\n  activeSegmentOutlineWidthDelta: 0,\n  renderFill: true,\n  renderFillInactive: true,\n  fillAlpha: 0.7,\n  fillAlphaInactive: 0.65,\n  outlineOpacity: 1,\n  outlineOpacityInactive: 0.85,\n};\n\nfunction getDefaultLabelmapConfig(): LabelmapConfig {\n  return defaultLabelmapConfig;\n}\n\n// Checks if the labelmap config is valid, which means\n// if all the required fields are present and have the correct type\nfunction isValidLabelmapConfig(config): boolean {\n  return (\n    config &&\n    typeof config.renderOutline === 'boolean' &&\n    typeof config.outlineWidthActive === 'number' &&\n    typeof config.outlineWidthInactive === 'number' &&\n    typeof config.activeSegmentOutlineWidthDelta === 'number' &&\n    typeof config.renderFill === 'boolean' &&\n    typeof config.renderFillInactive === 'boolean' &&\n    typeof config.fillAlpha === 'number' &&\n    typeof config.fillAlphaInactive === 'number' &&\n    typeof config.outlineOpacity === 'number' &&\n    typeof config.outlineOpacityInactive === 'number'\n  );\n}\n\nexport default getDefaultLabelmapConfig;\nexport { isValidLabelmapConfig };\n","import cloneDeep from 'lodash.clonedeep';\nimport type { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\n\nimport { SegmentationRepresentations } from '../../enums';\nimport getDefaultContourConfig from '../../tools/displayTools/Contour/contourConfig';\nimport getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport type {\n  RepresentationConfig,\n  Segmentation,\n  SegmentationRepresentationConfig,\n  SegmentationState,\n  SegmentSpecificRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n  ToolGroupSpecificRepresentations,\n} from '../../types/SegmentationStateTypes';\n\n// Initialize the default configuration\n// Note: when we get other representations, we should set their default representations too.\nconst defaultLabelmapConfig = getDefaultLabelmapConfig();\nconst defaultContourConfig = getDefaultContourConfig();\n\nconst newGlobalConfig: SegmentationRepresentationConfig = {\n  renderInactiveSegmentations: true,\n  representations: {\n    [SegmentationRepresentations.Labelmap]: defaultLabelmapConfig,\n    [SegmentationRepresentations.Contour]: defaultContourConfig,\n  },\n};\n\n/* A default initial state for the segmentation manager. */\nconst initialDefaultState: SegmentationState = {\n  colorLUT: [],\n  segmentations: [],\n  globalConfig: newGlobalConfig,\n  toolGroups: {},\n};\n\n/**\n * The SegmentationStateManager Class is responsible for managing the state of the\n * segmentations. It stores the segmentations and toolGroup specific representations\n * of the segmentation. It also stores a global config and a toolGroup specific\n * config. Note that this is a singleton state manager.\n */\nexport default class SegmentationStateManager {\n  private state: SegmentationState;\n  public readonly uid: string;\n\n  constructor(uid?: string) {\n    if (!uid) {\n      uid = csUtils.uuidv4();\n    }\n    this.state = cloneDeep(initialDefaultState);\n    this.uid = uid;\n  }\n\n  /**\n   * It returns a copy of the current state of the segmentation\n   * @returns A deep copy of the state.\n   */\n  getState(): SegmentationState {\n    return this.state;\n  }\n\n  /**\n   * It returns an array of toolGroupIds currently in the segmentation state.\n   * @returns An array of strings.\n   */\n  getToolGroups(): string[] {\n    return Object.keys(this.state.toolGroups);\n  }\n\n  /**\n   * It returns the colorLUT at the specified index.\n   * @param lutIndex - The index of the color LUT to retrieve.\n   * @returns A ColorLUT object.\n   */\n  getColorLUT(lutIndex: number): Types.ColorLUT | undefined {\n    return this.state.colorLUT[lutIndex];\n  }\n\n  getNextColorLUTIndex(): number {\n    return this.state.colorLUT.length;\n  }\n\n  /**\n   * Reset the state to the default state\n   */\n  resetState(): void {\n    this.state = cloneDeep(initialDefaultState);\n  }\n\n  /**\n   * Given a segmentation Id, return the segmentation state\n   * @param segmentationId - The id of the segmentation to get the data for.\n   * @returns - The segmentation data\n   */\n  getSegmentation(segmentationId: string): Segmentation | undefined {\n    return this.state.segmentations.find(\n      (segmentation) => segmentation.segmentationId === segmentationId\n    );\n  }\n\n  /**\n   * It adds a segmentation to the segmentations array.\n   * @param segmentation - Segmentation\n   */\n  addSegmentation(segmentation: Segmentation): void {\n    // Check if the segmentation already exists with the segmentationId\n    if (this.getSegmentation(segmentation.segmentationId)) {\n      throw new Error(\n        `Segmentation with id ${segmentation.segmentationId} already exists`\n      );\n    }\n\n    this.state.segmentations.push(segmentation);\n  }\n\n  /**\n   * Get the segmentation representations for a tool group\n   * @param toolGroupId - string\n   * @returns A list of segmentation representations.\n   */\n  getSegmentationRepresentations(\n    toolGroupId: string\n  ): ToolGroupSpecificRepresentations | undefined {\n    const toolGroupSegRepresentationsWithConfig =\n      this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupSegRepresentationsWithConfig) {\n      return;\n    }\n\n    return toolGroupSegRepresentationsWithConfig.segmentationRepresentations;\n  }\n\n  /**\n   * Returns an array of all segmentation representations for all tool groups.\n   * @returns An array of ToolGroupSpecificRepresentations.\n   */\n  getAllSegmentationRepresentations(): Record<\n    string,\n    ToolGroupSpecificRepresentation[]\n  > {\n    const toolGroupSegReps: Record<string, ToolGroupSpecificRepresentation[]> =\n      {};\n    Object.entries(this.state.toolGroups).forEach(\n      ([toolGroupId, toolGroupSegRepresentationsWithConfig]) => {\n        toolGroupSegReps[toolGroupId] =\n          toolGroupSegRepresentationsWithConfig.segmentationRepresentations;\n      }\n    );\n    return toolGroupSegReps;\n  }\n\n  /**\n   * Add a new segmentation representation to the toolGroup's segmentation representations.\n   * @param toolGroupId - The Id of the tool group .\n   * @param segmentationRepresentation - The segmentation representation to add.\n   */\n  addSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentation: ToolGroupSpecificRepresentation\n  ): void {\n    // Initialize the default toolGroup state if not created yet\n    if (!this.state.toolGroups[toolGroupId]) {\n      this.state.toolGroups[toolGroupId] = {\n        segmentationRepresentations: [],\n        config: {} as SegmentationRepresentationConfig,\n      };\n    }\n\n    // local toolGroupSpecificSegmentationState\n    this.state.toolGroups[toolGroupId].segmentationRepresentations.push(\n      segmentationRepresentation\n    );\n\n    this._handleActiveSegmentation(toolGroupId, segmentationRepresentation);\n  }\n\n  /**\n   * Get the global config containing both representation config\n   * and render inactive segmentations config\n   * @returns The global config object.\n   */\n  getGlobalConfig(): SegmentationRepresentationConfig {\n    return this.state.globalConfig;\n  }\n\n  /**\n   * It sets the global segmentation config including both representation config\n   * and render inactive segmentations config\n   * @param config - The global configuration for the segmentations.\n   */\n  setGlobalConfig(config: SegmentationRepresentationConfig): void {\n    this.state.globalConfig = config;\n  }\n\n  /**\n   * Given a toolGroupId and a segmentationRepresentationUID, return the segmentation\n   * representation for that tool group.\n   * @param toolGroupId - The Id of the tool group\n   * @param segmentationRepresentationUID - string\n   * @returns The segmentation representation.\n   */\n  getSegmentationRepresentationByUID(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): ToolGroupSpecificRepresentation | undefined {\n    const toolGroupSegRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    const segmentationData = toolGroupSegRepresentations.find(\n      (representation) =>\n        representation.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    return segmentationData;\n  }\n\n  /**\n   * It removes the segmentation from the segmentation state.\n   * @param segmentationId - The id of the segmentation to remove.\n   */\n  removeSegmentation(segmentationId: string): void {\n    this.state.segmentations = this.state.segmentations.filter(\n      (segmentation) => segmentation.segmentationId !== segmentationId\n    );\n  }\n\n  /**\n   * Remove a segmentation representation from the toolGroup\n   * @param toolGroupId - The Id of the tool group\n   * @param segmentationRepresentationUID - the uid of the segmentation representation to remove\n   * @param immediate - If true, the viewport will be updated immediately.\n   */\n  removeSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): void {\n    const toolGroupSegmentationRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      !toolGroupSegmentationRepresentations.length\n    ) {\n      throw new Error(\n        `No viewport specific segmentation state found for viewport ${toolGroupId}`\n      );\n    }\n\n    const state =\n      toolGroupSegmentationRepresentations as ToolGroupSpecificRepresentations;\n    const index = state.findIndex(\n      (segData) =>\n        segData.segmentationRepresentationUID === segmentationRepresentationUID\n    );\n\n    if (index === -1) {\n      console.warn(\n        `No viewport specific segmentation state data found for viewport ${toolGroupId} and segmentation data UID ${segmentationRepresentationUID}`\n      );\n    }\n\n    const removedSegmentationRepresentation =\n      toolGroupSegmentationRepresentations[index];\n\n    toolGroupSegmentationRepresentations.splice(index, 1);\n\n    this._handleActiveSegmentation(\n      toolGroupId,\n      removedSegmentationRepresentation\n    );\n  }\n\n  /**\n   * Set the active segmentation data for a tool group\n   * @param toolGroupId - The Id of the tool group that owns the\n   * segmentation data.\n   * @param segmentationRepresentationUID - string\n   */\n  setActiveSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): void {\n    const toolGroupSegmentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    if (!toolGroupSegmentations || !toolGroupSegmentations.length) {\n      throw new Error(\n        `No segmentation data found for toolGroupId: ${toolGroupId}`\n      );\n    }\n\n    const segmentationData = toolGroupSegmentations.find(\n      (segmentationData) =>\n        segmentationData.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    if (!segmentationData) {\n      throw new Error(\n        `No segmentation data found for segmentation data UID ${segmentationRepresentationUID}`\n      );\n    }\n\n    segmentationData.active = true;\n    this._handleActiveSegmentation(toolGroupId, segmentationData);\n  }\n\n  /**\n   * Given a tool group Id it returns the tool group specific representation config\n   *\n   * @param toolGroupId - The Id of the tool group\n   * @returns A SegmentationConfig object.\n   */\n  getToolGroupSpecificConfig(\n    toolGroupId: string\n  ): SegmentationRepresentationConfig | undefined {\n    const toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupStateWithConfig) {\n      return;\n    }\n\n    return toolGroupStateWithConfig.config;\n  }\n\n  getSegmentationRepresentationSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): RepresentationConfig {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    return segmentationRepresentation.segmentationRepresentationSpecificConfig;\n  }\n\n  setSegmentationRepresentationSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    config: RepresentationConfig\n  ): void {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    segmentationRepresentation.segmentationRepresentationSpecificConfig =\n      config;\n  }\n\n  getSegmentSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    segmentIndex: number\n  ): RepresentationConfig {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    return segmentationRepresentation.segmentSpecificConfig[segmentIndex];\n  }\n\n  setSegmentSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    config: SegmentSpecificRepresentationConfig,\n    options?: {\n      clear: false;\n    }\n  ): void {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    if (!segmentationRepresentation.segmentSpecificConfig || options?.clear) {\n      segmentationRepresentation.segmentSpecificConfig = {};\n    }\n\n    Object.keys(config).forEach((key) => {\n      segmentationRepresentation.segmentSpecificConfig[key] = config[key];\n    });\n  }\n\n  /**\n   * Set the segmentation representations config for a given tool group. It will create a new\n   * tool group specific config if one does not exist.\n   *\n   * @param toolGroupId - The Id of the tool group that the segmentation\n   * belongs to.\n   * @param config - SegmentationConfig\n   */\n  setSegmentationRepresentationConfig(\n    toolGroupId: string,\n    config: SegmentationRepresentationConfig\n  ): void {\n    let toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupStateWithConfig) {\n      this.state.toolGroups[toolGroupId] = {\n        segmentationRepresentations: [],\n        config: {\n          renderInactiveSegmentations: true,\n          representations: {},\n        },\n      };\n\n      toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n    }\n\n    toolGroupStateWithConfig.config = {\n      ...toolGroupStateWithConfig.config,\n      ...config,\n    };\n  }\n\n  /**\n   * It adds a color LUT to the state.\n   * @param colorLUT - ColorLUT\n   * @param lutIndex - The index of the color LUT table to add.\n   */\n  addColorLUT(colorLUT: Types.ColorLUT, lutIndex: number): void {\n    if (this.state.colorLUT[lutIndex]) {\n      console.warn('Color LUT table already exists, overwriting');\n    }\n\n    this.state.colorLUT[lutIndex] = structuredClone(colorLUT);\n  }\n\n  /**\n   * Removes a color LUT to the state.\n   * @param colorLUTIndex - The index of the color LUT table to remove.\n   */\n  removeColorLUT(colorLUTIndex: number): void {\n    delete this.state.colorLUT[colorLUTIndex];\n  }\n\n  /**\n   * It handles the active segmentation representation based on the active status of the\n   * segmentation representation that was added or removed.\n   *\n   * @param toolGroupId - The Id of the tool group that the segmentation representation belongs to.\n   * @param recentlyAddedOrRemovedSegmentationRepresentation - ToolGroupSpecificSegmentationData\n   */\n  _handleActiveSegmentation(\n    toolGroupId: string,\n    recentlyAddedOrRemovedSegmentationRepresentation: ToolGroupSpecificRepresentation\n  ): void {\n    const segmentationRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    // 1. If there is no segmentation representations, return early\n    if (segmentationRepresentations.length === 0) {\n      return;\n    }\n\n    // 2. If there is only one segmentation representation, make that one active\n    if (segmentationRepresentations.length === 1) {\n      segmentationRepresentations[0].active = true;\n      return;\n    }\n\n    // 3. If removed Segmentation representation was active, make the first one active\n    const activeSegmentationRepresentations =\n      segmentationRepresentations.filter(\n        (representation) => representation.active\n      );\n\n    if (activeSegmentationRepresentations.length === 0) {\n      segmentationRepresentations[0].active = true;\n      return;\n    }\n\n    // 4. If the added segmentation representation is active, make other segmentation\n    // representations inactive\n    if (recentlyAddedOrRemovedSegmentationRepresentation.active) {\n      segmentationRepresentations.forEach((representation) => {\n        if (\n          representation.segmentationRepresentationUID !==\n          recentlyAddedOrRemovedSegmentationRepresentation.segmentationRepresentationUID\n        ) {\n          representation.active = false;\n        }\n      });\n    }\n\n    // 5. if added/removed segmentation is is inactive, do nothing\n  }\n}\n\nconst defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');\nexport { defaultSegmentationStateManager };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\n\nimport { Events } from '../../enums';\nimport {\n  getSegmentationRepresentations,\n  getSegmentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport {\n  SegmentationRepresentationModifiedEventDetail,\n  SegmentationDataModifiedEventDetail,\n  SegmentationModifiedEventDetail,\n  SegmentationRepresentationRemovedEventDetail,\n  SegmentationRemovedEventDetail,\n} from '../../types/EventTypes';\n\n/**\n * Trigger an event that a segmentation is removed\n * @param segmentationId - The Id of segmentation\n */\nfunction triggerSegmentationRemoved(segmentationId: string): void {\n  const eventDetail: SegmentationRemovedEventDetail = {\n    segmentationId,\n  };\n\n  triggerEvent(eventTarget, Events.SEGMENTATION_REMOVED, eventDetail);\n}\n\n/**\n * Trigger an event that a segmentation representation was removed\n * @param toolGroupId - The id of the tool group that the segmentation\n * representation was removed from.\n * @param segmentationRepresentationUID - The UID of the segmentation\n * representation that was removed.\n */\nfunction triggerSegmentationRepresentationRemoved(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const eventDetail: SegmentationRepresentationRemovedEventDetail = {\n    toolGroupId,\n    segmentationRepresentationUID,\n  };\n\n  triggerEvent(\n    eventTarget,\n    Events.SEGMENTATION_REPRESENTATION_REMOVED,\n    eventDetail\n  );\n}\n\n/**\n * Trigger an event on the eventTarget that the segmentation representation for\n * toolGroupId has been updated\n * @param toolGroupId - The Id of the toolGroup\n */\nfunction triggerSegmentationRepresentationModified(\n  toolGroupId: string,\n  segmentationRepresentationUID?: string\n): void {\n  const eventDetail: SegmentationRepresentationModifiedEventDetail = {\n    toolGroupId,\n    segmentationRepresentationUID,\n  };\n\n  if (segmentationRepresentationUID) {\n    triggerEvent(\n      eventTarget,\n      Events.SEGMENTATION_REPRESENTATION_MODIFIED,\n      eventDetail\n    );\n    return;\n  }\n\n  // If no segmentationRepresentationUID is provided, then we need to trigger\n  // the event for all segmentation representations in the toolGroup\n\n  // Get all segmentation representations in the toolGroup\n  const segmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId) || [];\n\n  segmentationRepresentations.forEach((segmentationRepresentation) => {\n    const { segmentationRepresentationUID } = segmentationRepresentation;\n    const eventDetail: SegmentationRepresentationModifiedEventDetail = {\n      toolGroupId,\n      segmentationRepresentationUID,\n    };\n\n    triggerEvent(\n      eventTarget,\n      Events.SEGMENTATION_REPRESENTATION_MODIFIED,\n      eventDetail\n    );\n  });\n}\n\n/**\n * Triggers segmentation global state updated event, notifying all toolGroups\n * that the global state has been updated, If a segmentationId is provided\n * the event will only be triggered for that segmentation, otherwise it will\n * be triggered for all segmentations.\n *\n * @param segmentationId - The id of the segmentation that has been updated\n */\nfunction triggerSegmentationModified(segmentationId?: string): void {\n  let segmentationIds;\n\n  if (segmentationId) {\n    segmentationIds = [segmentationId];\n  } else {\n    // get all toolGroups\n    segmentationIds = getSegmentations().map(\n      ({ segmentationId }) => segmentationId\n    );\n  }\n\n  // 1. Trigger an event notifying all listeners about the segmentationId\n  // that has been updated.\n  segmentationIds.forEach((segmentationId) => {\n    const eventDetail: SegmentationModifiedEventDetail = {\n      segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_MODIFIED, eventDetail);\n  });\n\n  // Todo: I don't think we need the following lines of code\n  // // 2. Notify all viewports that render the segmentationId in order to update the\n  // // rendering based on the new global state.\n  // toolGroupIds.forEach((toolGroupId) => {\n  //   triggerSegmentationRepresentationModified(toolGroupId)\n  // })\n}\n\n/**\n * Trigger an event that a segmentation data has been modified\n * @param segmentationId - The Id of segmentation\n */\nfunction triggerSegmentationDataModified(\n  segmentationId: string,\n  modifiedSlicesToUse?: number[]\n): void {\n  const eventDetail: SegmentationDataModifiedEventDetail = {\n    segmentationId,\n    modifiedSlicesToUse,\n  };\n\n  triggerEvent(eventTarget, Events.SEGMENTATION_DATA_MODIFIED, eventDetail);\n}\n\nexport {\n  // ToolGroup Specific\n  triggerSegmentationRepresentationModified,\n  triggerSegmentationRepresentationRemoved,\n  // Global\n  triggerSegmentationDataModified,\n  triggerSegmentationModified,\n  triggerSegmentationRemoved,\n};\n","import { SegmentationRepresentations } from '../../../enums';\nimport {\n  SegmentationPublicInput,\n  Segmentation,\n} from '../../../types/SegmentationStateTypes';\nimport type { ContourSegmentationData } from '../../../types/ContourTypes';\n\n/**\n * It takes in a segmentation input and returns a segmentation with default values\n * @param segmentationInput - The input to the segmentation.\n * @returns A Segmentation object.\n * @internal\n */\nfunction normalizeSegmentationInput(\n  segmentationInput: SegmentationPublicInput\n): Segmentation {\n  const { segmentationId, representation } = segmentationInput;\n  const isContourRepresentation =\n    representation.type === SegmentationRepresentations.Contour;\n  let data = representation.data ? { ...representation.data } : null;\n\n  // Contour representation data is defined internally\n  data = !data && isContourRepresentation ? {} : data;\n\n  // Data cannot be undefined for labelmap and surface\n  if (!data) {\n    throw new Error('Segmentation representation data may not be undefined');\n  }\n\n  if (isContourRepresentation) {\n    const contourData = <ContourSegmentationData>data;\n\n    // geometryIds will be removed in a near future. It still exist in the\n    // code for compatibility only but it is optional from now on.\n    contourData.geometryIds = contourData.geometryIds ?? [];\n\n    // Make sure annotationUIDsMap is defined because an empty contour is\n    // created before adding contour annotations to the map. Also it prevents\n    // breaking legacy code after moving from geometryIds to annotationUIDsMap.\n    contourData.annotationUIDsMap = contourData.annotationUIDsMap ?? new Map();\n  }\n\n  // Todo: we should be able to let the user pass in non-default values for\n  // cachedStats, label, activeSegmentIndex, etc.\n  return {\n    segmentationId,\n    cachedStats: {},\n    segmentLabels: {},\n    label: null,\n    segmentsLocked: new Set(),\n    type: representation.type,\n    activeSegmentIndex: 1,\n    representationData: {\n      [representation.type]: {\n        ...data,\n      },\n    },\n  };\n}\n\nexport default normalizeSegmentationInput;\n","import type { Types } from '@cornerstonejs/core';\nimport type {\n  RepresentationConfig,\n  Segmentation,\n  SegmentationPublicInput,\n  SegmentationRepresentationConfig,\n  SegmentSpecificRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n  ToolGroupSpecificRepresentations,\n} from '../../types/SegmentationStateTypes';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport {\n  triggerSegmentationModified,\n  triggerSegmentationRemoved,\n  triggerSegmentationRepresentationModified,\n  triggerSegmentationRepresentationRemoved,\n} from './triggerSegmentationEvents';\n\nimport normalizeSegmentationInput from './helpers/normalizeSegmentationInput';\n\n/**\n * It returns the defaultSegmentationStateManager.\n */\nfunction getDefaultSegmentationStateManager() {\n  return defaultSegmentationStateManager;\n}\n\n/*************************\n *\n * Segmentation State\n *\n **************************/\n\n/**\n * Get the segmentation for the given segmentationId\n * @param segmentationId - The Id of the segmentation\n * @returns A GlobalSegmentationData object\n */\nfunction getSegmentation(segmentationId: string): Segmentation | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentation(segmentationId);\n}\n\n/**\n * Get the segmentations inside the state\n * @returns Segmentation array\n */\nfunction getSegmentations(): Segmentation[] | [] {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  const state = segmentationStateManager.getState();\n\n  return state.segmentations;\n}\n\n/**\n * It takes a segmentation input and adds it to the segmentation state manager\n * @param segmentationInput - The segmentation to add.\n * @param suppressEvents - If true, the event will not be triggered.\n */\nfunction addSegmentation(\n  segmentationInput: SegmentationPublicInput,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  const segmentation = normalizeSegmentationInput(segmentationInput);\n\n  segmentationStateManager.addSegmentation(segmentation);\n\n  if (!suppressEvents) {\n    triggerSegmentationModified(segmentation.segmentationId);\n  }\n}\n\n/**\n * Get the segmentation state for a tool group. It will return an array of\n * segmentation representation objects.\n * @param toolGroupId - The unique identifier of the tool group.\n * @returns An array of segmentation representation objects.\n */\nfunction getSegmentationRepresentations(\n  toolGroupId: string\n): ToolGroupSpecificRepresentations | [] {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n}\n\n/**\n * Get all segmentation representations in the state\n * @returns An array of segmentation representation objects.\n */\nfunction getAllSegmentationRepresentations(): Record<\n  string,\n  ToolGroupSpecificRepresentation[]\n> {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getAllSegmentationRepresentations();\n}\n\n/**\n * Get the tool group IDs that have a segmentation representation with the given\n * segmentationId\n * @param segmentationId - The id of the segmentation\n * @returns An array of tool group IDs.\n */\nfunction getToolGroupIdsWithSegmentation(segmentationId: string): string[] {\n  if (!segmentationId) {\n    throw new Error('getToolGroupIdsWithSegmentation: segmentationId is empty');\n  }\n\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  const state = segmentationStateManager.getState();\n  const toolGroupIds = Object.keys(state.toolGroups);\n\n  const foundToolGroupIds = [];\n  toolGroupIds.forEach((toolGroupId) => {\n    const toolGroupSegmentationRepresentations =\n      segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n\n    toolGroupSegmentationRepresentations.forEach((representation) => {\n      if (representation.segmentationId === segmentationId) {\n        foundToolGroupIds.push(toolGroupId);\n      }\n    });\n  });\n\n  return foundToolGroupIds;\n}\n\n/**\n * Get the segmentation representations config for a given tool group\n * @param toolGroupId - The Id of the tool group that the segmentation\n * config belongs to.\n * @returns A SegmentationConfig object.\n */\nfunction getToolGroupSpecificConfig(\n  toolGroupId: string\n): SegmentationRepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getToolGroupSpecificConfig(toolGroupId);\n}\n\n/**\n * Set the segmentation representation config for the provided toolGroup. ToolGroup specific\n * configuration overwrites the global configuration for each representation.\n * It fires SEGMENTATION_REPRESENTATION_MODIFIED event if not suppressed.\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n * @param toolGroupId - The Id of the tool group that the segmentation\n * config is being set for.\n * @param config - The new configuration for the tool group.\n * @param suppressEvents - If true, the event will not be triggered.\n */\nfunction setToolGroupSpecificConfig(\n  toolGroupId: string,\n  config: SegmentationRepresentationConfig,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentationRepresentationConfig(\n    toolGroupId,\n    config\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(toolGroupId);\n  }\n}\n\n/**\n * It sets the segmentation representation specific config for all the segments\n * inside the segmentation.\n * @param segmentationRepresentationUID - The unique identifier of the segmentation representation.\n * @param config  - The new configuration for the segmentation representation it is an object with keys of\n * different representation types, and values of the configuration for each representation type.\n */\nfunction setSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: RepresentationConfig,\n  suppressEvents = false\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n  }\n}\n\n/**\n * It returns the segmentation representation specific config which is the same for all the segments\n * @param segmentationRepresentationUID - The unique identifier of the segmentation representation.\n * @returns - The segmentation representation specific config.\n */\nfunction getSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): RepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nfunction getSegmentSpecificRepresentationConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): RepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n}\n\nfunction setSegmentSpecificRepresentationConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: SegmentSpecificRepresentationConfig,\n  suppressEvents = false\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n\n  // Todo: this can be even more performant if we create a new event for\n  // triggering a specific segment config change.\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n  }\n}\n\n/**\n * Add the given segmentation representation data to the given tool group state. It fires\n * SEGMENTATION_REPRESENTATION_MODIFIED event if not suppressed.\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n *\n * @param toolGroupId - The Id of the tool group that the segmentation representation is for.\n * @param segmentationData - The data to add to the segmentation state.\n * @param suppressEvents - boolean\n */\nfunction addSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentation: ToolGroupSpecificRepresentation,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.addSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentation\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentation.segmentationRepresentationUID\n    );\n  }\n}\n\n/**\n * It returns the global segmentation config. Note that the toolGroup-specific\n * configuration has higher priority than the global configuration and overwrites\n * the global configuration for each representation.\n * @returns The global segmentation configuration for all segmentations.\n */\nfunction getGlobalConfig(): SegmentationRepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getGlobalConfig();\n}\n\n/**\n * Set the global segmentation configuration. It fires SEGMENTATION_MODIFIED\n * event if not suppressed.\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param config - The new global segmentation config.\n * @param suppressEvents - If true, the `segmentationGlobalStateModified` event will not be triggered.\n */\nfunction setGlobalConfig(\n  config: SegmentationRepresentationConfig,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setGlobalConfig(config);\n\n  if (!suppressEvents) {\n    triggerSegmentationModified();\n  }\n}\n\n/**\n * Get the segmentation data object for a given tool group and\n * segmentation data UID. It searches all the toolGroup specific segmentation\n * data objects and returns the first one that matches the UID.\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @returns Segmentation Data object.\n */\nfunction getSegmentationRepresentationByUID(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): ToolGroupSpecificRepresentation | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentationByUID(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * It removes the segmentation from the segmentation state manager\n *\n * @triggers SEGMENTATION_REMOVED\n *\n * @param segmentationId - The id of the segmentation\n */\nfunction removeSegmentation(segmentationId: string): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeSegmentation(segmentationId);\n  triggerSegmentationRemoved(segmentationId);\n}\n\n/**\n * Remove a segmentation representation from the segmentation state manager for a toolGroup.\n * It fires SEGMENTATION_REPRESENTATION_MODIFIED event.\n *\n * @triggers SEGMENTATION_REPRESENTATION_REMOVED\n *\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation to remove.\n * remove.\n * @param - immediate - If true, the viewports will be updated immediately.\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  triggerSegmentationRepresentationRemoved(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Removes all segmentation representations associated with a tool group.\n * @param toolGroupId - The ID of the tool group.\n */\nfunction removeSegmentationRepresentations(toolGroupId: string): void {\n  const segmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId) || [];\n\n  segmentationRepresentations.forEach((representation) => {\n    removeSegmentationRepresentation(\n      toolGroupId,\n      representation.segmentationRepresentationUID\n    );\n  });\n}\n\n/**\n * Add a color LUT to the segmentation state manager\n * @param colorLUT - The color LUT array to add.\n * @param index - The index of the color LUT to add.\n */\nfunction removeColorLUT(colorLUTIndex: number): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeColorLUT(colorLUTIndex);\n}\n\n/**\n * Get the color lut for a given index\n * @param index - The index of the color lut to retrieve.\n * @returns A ColorLUT array.\n */\nfunction getColorLUT(index: number): Types.ColorLUT | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getColorLUT(index);\n}\n\nfunction getNextColorLUTIndex(): number {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getNextColorLUTIndex();\n}\n\n/**\n * Add a color LUT to the segmentation state manager\n * @param colorLUT - The color LUT array to add.\n * @param index - The index of the color LUT to add.\n */\nfunction addColorLUT(colorLUT: Types.ColorLUT, index: number): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.addColorLUT(colorLUT, index);\n  // Todo: trigger event color LUT added\n}\n\nexport {\n  getDefaultSegmentationStateManager,\n  // Segmentation\n  getSegmentation,\n  getSegmentations,\n  addSegmentation,\n  removeSegmentation,\n  // ToolGroup specific Segmentation Representation\n  getSegmentationRepresentations,\n  addSegmentationRepresentation,\n  removeSegmentationRepresentation,\n  removeSegmentationRepresentations,\n  // config\n  getToolGroupSpecificConfig,\n  setToolGroupSpecificConfig,\n  getGlobalConfig,\n  setGlobalConfig,\n  getSegmentationRepresentationSpecificConfig,\n  setSegmentationRepresentationSpecificConfig,\n  getSegmentSpecificRepresentationConfig,\n  setSegmentSpecificRepresentationConfig,\n  // helpers s\n  getToolGroupIdsWithSegmentation,\n  getAllSegmentationRepresentations,\n  getSegmentationRepresentationByUID,\n  // color\n  addColorLUT,\n  getColorLUT,\n  getNextColorLUTIndex,\n  removeColorLUT,\n};\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { IPoints } from '../../types';\n\n/**\n * Given a native mouse event, get the associated cornerstone3D enabled element\n * and derive a set of coordinates useful for tools.\n * @param evt - The Mouse event.\n * @param element - The DOM HTMLDivElement that the event was triggered on.\n * @returns The points related to the event in the form of a `IPoints` object containing\n * the following properties: `page`, `client`, `canvas`, and `world` details of the event.\n */\nexport default function getMouseEventPoints(\n  evt: MouseEvent,\n  element?: HTMLDivElement\n): IPoints {\n  const elementToUse = element || (evt.currentTarget as HTMLDivElement);\n  const { viewport } = getEnabledElement(elementToUse);\n  const clientPoint = _clientToPoint(evt);\n  const pagePoint = _pageToPoint(evt);\n  const canvasPoint = _pagePointsToCanvasPoints(elementToUse, pagePoint);\n  const worldPoint = viewport.canvasToWorld(canvasPoint);\n\n  return {\n    page: pagePoint,\n    client: clientPoint,\n    canvas: canvasPoint,\n    world: worldPoint,\n  };\n}\n\n/**\n * Converts point from page coordinates to canvas coordinates.\n * @param element - HTMLDivElement\n * @param pagePoint - Point in page coordinates pageX and pageY\n *\n * @returns The canvas coordinate points\n */\nfunction _pagePointsToCanvasPoints(\n  element: HTMLDivElement,\n  pagePoint: Types.Point2\n): Types.Point2 {\n  const rect = element.getBoundingClientRect();\n  return [\n    pagePoint[0] - rect.left - window.pageXOffset,\n    pagePoint[1] - rect.top - window.pageYOffset,\n  ];\n}\n\n/**\n * Converts the event's `pageX` and `pageY` properties to Types.Point2 format\n *\n * @param evt - The Mouse `Event`\n */\nfunction _pageToPoint(evt: MouseEvent): Types.Point2 {\n  return [evt.pageX, evt.pageY];\n}\n\n/**\n * Converts the event's `clientX` and `clientY` properties to Types.Point2 format\n * @param evt - The Mouse `Event`\n */\nfunction _clientToPoint(evt: MouseEvent): Types.Point2 {\n  return [evt.clientX, evt.clientY];\n}\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport getMouseEventPoints from './getMouseEventPoints';\nimport { EventTypes, IPoints } from '../../types';\n\n/**\n * Captures and normalizes the double click event. Emits as a cornerstoneTools3D\n * double click event.\n *\n * @param evt - The mouse event.\n */\nfunction mouseDoubleClickListener(evt: MouseEvent): void {\n  const element = <HTMLDivElement>evt.currentTarget;\n\n  const { viewportId, renderingEngineId } = getEnabledElement(element);\n\n  const startPoints = getMouseEventPoints(evt, element);\n  const deltaPoints: IPoints = {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  };\n\n  const eventDetail: EventTypes.MouseDoubleClickEventDetail = {\n    event: evt,\n    eventName: Events.MOUSE_DOUBLE_CLICK,\n    viewportId,\n    renderingEngineId,\n    camera: {},\n    element,\n    startPoints,\n    lastPoints: startPoints,\n    currentPoints: startPoints,\n    deltaPoints,\n  };\n\n  const consumed = !triggerEvent(\n    element,\n    Events.MOUSE_DOUBLE_CLICK,\n    eventDetail\n  );\n\n  if (consumed) {\n    // The Events.MOUSE_DOUBLE_CLICK was consumed, thus no other listener should handle this 'dblclick' event.\n\n    // Use stopImmediatePropagation to lessen the possibility that a third party 'dblclick'\n    // listener receives this event. However, there still is no guarantee\n    // that any third party listener has not already handled the event.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  }\n}\n\nexport default mouseDoubleClickListener;\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport getMouseEventPoints from './getMouseEventPoints';\nimport { MouseMoveEventDetail } from '../../types/EventTypes';\n\nconst eventName = Events.MOUSE_MOVE;\n\n/**\n * Captures and normalizes the mouse move event. Emits as a cornerstoneTools3D\n * mouse move event.\n *\n * @param evt - The mouse event.\n */\nfunction mouseMoveListener(evt: MouseEvent) {\n  const element = <HTMLDivElement>evt.currentTarget;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  const currentPoints = getMouseEventPoints(evt);\n  const eventDetail: MouseMoveEventDetail = {\n    renderingEngineId,\n    viewportId,\n    camera: {},\n    element,\n    currentPoints,\n    eventName,\n    event: evt,\n  };\n\n  const consumed = !triggerEvent(element, eventName, eventDetail);\n\n  // Events.MOUSE_MOVE was consumed, thus no other listener should handle this event.\n  if (consumed) {\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  }\n}\n\nexport default mouseMoveListener;\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport Events from '../../enums/Events';\nimport mouseMoveListener from './mouseMoveListener';\nimport { EventTypes, IPoints } from '../../types';\nimport getMouseEventPoints from './getMouseEventPoints';\n\nconst { MOUSE_DOWN, MOUSE_DOWN_ACTIVATE, MOUSE_CLICK, MOUSE_UP, MOUSE_DRAG } =\n  Events;\n\n// The amount of time in milliseconds within which a browser 'dblclick' event has to occur.\n// Any mouse down, up, down and up sequence taking longer than this time is considered to\n// NOT be a double click and any browser 'dblclick' event that subsequently occurs as a result\n// of such a sequence will be ignored. It is best to set this to a value that is less\n// than the system value for detecting a double click. Setting something too large\n// might detect a double click that does not constitute a browser 'dblclick' and thus\n// no mouse events for the sequence will get fired at all.\n//\n// TODO This module should detect and fire 'dblclick' events at its discretion and\n// ignore all those generated by the browser.\n//\nconst DOUBLE_CLICK_TOLERANCE_MS = 400;\n\n// This tolerance is how long to accept a secondary button down\nconst MULTI_BUTTON_TOLERANCE_MS = 150;\n\n// A drag (projected distance) during the double click timeout that is greater than this\n// value will cancel the timeout and suppress any double click that might occur.\n// This tolerance is particularly important on touch devices where some movement\n// might occur between the two clicks.\n//\n// TODO revisit this value for touch devices\n//\nconst DOUBLE_CLICK_DRAG_TOLERANCE = 3;\n\ninterface IMouseDownListenerState {\n  mouseButton: number;\n  element: HTMLDivElement;\n  renderingEngineId: string;\n  viewportId: string;\n  isClickEvent: boolean;\n  clickDelay: number;\n  preventClickTimeout: ReturnType<typeof setTimeout>;\n  startPoints: IPoints;\n  lastPoints: IPoints;\n}\n\ninterface IDoubleClickState {\n  doubleClickTimeout: ReturnType<typeof setTimeout>;\n  mouseDownEvent: MouseEvent;\n  mouseUpEvent: MouseEvent;\n  ignoreDoubleClick: boolean;\n}\n\n// STATE\nconst defaultState: IMouseDownListenerState = {\n  mouseButton: undefined,\n  //\n  element: null,\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  isClickEvent: true,\n  clickDelay: 200,\n  preventClickTimeout: null,\n  startPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n  lastPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n};\n\nlet state: IMouseDownListenerState = {\n  mouseButton: undefined,\n  //\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  isClickEvent: true,\n  clickDelay: 200,\n  element: null,\n  preventClickTimeout: null,\n  startPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n  lastPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n};\n\nconst doubleClickState: IDoubleClickState = {\n  doubleClickTimeout: null,\n  mouseDownEvent: null,\n  mouseUpEvent: null,\n  ignoreDoubleClick: false,\n};\n\n/**\n * Listens to mouse down events from the DOM and depending on interaction and further\n * interaction can emit the following mouse events:\n *\n * - MOUSE_DOWN\n * - MOUSE_DOWN_ACTIVATE\n * - MOUSE_DRAG (move while down)\n * - MOUSE_UP\n * - MOUSE_CLICK\n *\n * The mouse down is NOT handled immediately. Instead, a timeout is started to\n * determine if this mouse down is the first in a sequence that constitutes a\n * double click.\n *\n * @param evt - The Mouse event.\n * @private\n */\nfunction mouseDownListener(evt: MouseEvent) {\n  if (doubleClickState.doubleClickTimeout) {\n    // A second identical click will be a double click event, so ignore it\n    if (evt.buttons === doubleClickState.mouseDownEvent.buttons) {\n      return;\n    }\n\n    // Record the second button or the changed button event as the initial\n    // button down state so that the multi-button event can be detected\n    doubleClickState.mouseDownEvent = evt;\n\n    // If second button is added, then ensure double click timeout is terminated\n    // and do not handle three or more button gestures.\n    _doStateMouseDownAndUp();\n    return;\n  }\n\n  // Handle multi-button clicks by adding a delay before handling them.\n  // Double clicks (left button only) physically take the user longer, so\n  // use a longer timeout, and for multi-button at the same time, the clicks\n  // are done at the same time by the user, just the system perceives them\n  // separately, so have a short timeout to allow catching both buttons.\n  doubleClickState.doubleClickTimeout = setTimeout(\n    _doStateMouseDownAndUp,\n    evt.buttons === 1 ? DOUBLE_CLICK_TOLERANCE_MS : MULTI_BUTTON_TOLERANCE_MS\n  );\n\n  // First mouse down of a potential double click. So save it and start\n  // a timeout to determine a double click.\n  doubleClickState.mouseDownEvent = evt;\n  doubleClickState.ignoreDoubleClick = false;\n\n  state.element = <HTMLDivElement>evt.currentTarget;\n\n  state.mouseButton = evt.buttons;\n\n  const enabledElement = getEnabledElement(state.element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  state.renderingEngineId = renderingEngineId;\n  state.viewportId = viewportId;\n\n  state.preventClickTimeout = setTimeout(\n    _preventClickHandler,\n    state.clickDelay\n  );\n\n  // Prevent CornerstoneToolsMouseMove while mouse is down\n  state.element.removeEventListener('mousemove', mouseMoveListener);\n\n  const startPoints = getMouseEventPoints(evt, state.element);\n  state.startPoints = _copyPoints(startPoints);\n  state.lastPoints = _copyPoints(startPoints);\n\n  document.addEventListener('mouseup', _onMouseUp);\n  document.addEventListener('mousemove', _onMouseDrag);\n}\n\n/**\n * Does the actual mouse down logic if the double click timer has expired or\n * a mouse drag has started.\n * @param evt the mouse down event\n * @private\n */\nfunction _doMouseDown(evt: MouseEvent) {\n  const deltaPoints = _getDeltaPoints(state.startPoints, state.startPoints);\n\n  const eventDetail: EventTypes.MouseDownEventDetail = {\n    event: evt,\n    eventName: MOUSE_DOWN,\n    element: state.element,\n    mouseButton: state.mouseButton,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    startPoints: state.startPoints,\n    lastPoints: state.startPoints,\n    currentPoints: state.startPoints,\n    deltaPoints,\n  };\n\n  state.lastPoints = _copyPoints(eventDetail.lastPoints);\n\n  // by triggering MOUSE_DOWN it checks if this is toolSelection, handle modification etc.\n  // of already existing tools\n  const notConsumed = triggerEvent(\n    eventDetail.element,\n    MOUSE_DOWN,\n    eventDetail\n  );\n\n  // if no tools responded to this event and prevented its default behavior,\n  // create a new tool\n  if (notConsumed) {\n    triggerEvent(eventDetail.element, MOUSE_DOWN_ACTIVATE, eventDetail);\n  }\n}\n\n/**\n *_onMouseDrag - Handle emission of drag events whilst the mouse is depressed.\n *\n * @private\n * @param evt - The mouse event.\n */\nfunction _onMouseDrag(evt: MouseEvent) {\n  const currentPoints = getMouseEventPoints(evt, state.element);\n  const lastPoints = _updateMouseEventsLastPoints(\n    state.element,\n    state.lastPoints\n  );\n\n  const deltaPoints = _getDeltaPoints(currentPoints, lastPoints);\n\n  if (doubleClickState.doubleClickTimeout) {\n    if (_isDragPastDoubleClickTolerance(deltaPoints.canvas)) {\n      // Dragging past the tolerance means no double click should occur.\n      _doStateMouseDownAndUp();\n    } else {\n      return;\n    }\n  }\n\n  const eventDetail: EventTypes.MouseDragEventDetail = {\n    event: evt,\n    eventName: MOUSE_DRAG,\n    mouseButton: state.mouseButton,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    startPoints: _copyPoints(state.startPoints),\n    lastPoints: _copyPoints(lastPoints),\n    currentPoints,\n    deltaPoints,\n  };\n\n  const consumed = !triggerEvent(state.element, MOUSE_DRAG, eventDetail);\n\n  // Events.MOUSE_DRAG was consumed, thus no other listener should handle this event.\n  if (consumed) {\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  }\n\n  // Update the last points\n  state.lastPoints = _copyPoints(currentPoints);\n}\n\n/**\n *_onMouseUp - Handle emission of mouse up events, and re-enabling mouse move events.\n *\n * If the mouse up event occurs during a double click timeout, it is either the first or\n * second mouse up of a potential double click sequence. If the first, then it\n * is saved in case the double click timeout expires and a simple mouse down and\n * up have to get executed. If the second, then the latest mouse down, up, down and\n * up constitute a double click and the mouseDoubleClickListener needs to execute.\n *\n * If the mouse up event comes after the double click timeout, then it is simply\n * handled as the up of a mouse down and up sequence.\n *\n * @private\n * @param evt - The mouse event.\n */\nfunction _onMouseUp(evt: MouseEvent): void {\n  // Cancel the timeout preventing the click event from triggering\n  clearTimeout(state.preventClickTimeout);\n\n  if (doubleClickState.doubleClickTimeout) {\n    // received a mouse up while waiting for a double click (via a timeout)\n\n    if (!doubleClickState.mouseUpEvent) {\n      // this is the first mouse up during the double click timeout; we'll need it later if the timeout expires\n      doubleClickState.mouseUpEvent = evt;\n\n      state.element.addEventListener('mousemove', _onMouseMove);\n    } else {\n      // this is the second mouse up of a double click!\n      _cleanUp();\n    }\n  } else {\n    // Handle the actual mouse up. Note that it may have occurred during the double click timeout or\n    // after it expired. In either case this block is being executed after the time out has expired\n    // or after a drag started.\n\n    const eventName = state.isClickEvent ? MOUSE_CLICK : MOUSE_UP;\n\n    const currentPoints = getMouseEventPoints(evt, state.element);\n    const deltaPoints = _getDeltaPoints(currentPoints, state.lastPoints);\n    const eventDetail:\n      | EventTypes.MouseUpEventDetail\n      | EventTypes.MouseClickEventType = {\n      event: evt,\n      eventName,\n      mouseButton: state.mouseButton,\n      element: state.element,\n      renderingEngineId: state.renderingEngineId,\n      viewportId: state.viewportId,\n      camera: {},\n      startPoints: _copyPoints(state.startPoints),\n      lastPoints: _copyPoints(state.lastPoints),\n      currentPoints,\n      deltaPoints,\n    };\n\n    triggerEvent(eventDetail.element, eventName, eventDetail);\n\n    _cleanUp();\n  }\n\n  // Remove the drag as soon as we get the mouse up because either we have executed\n  // the mouse up logic, or we have not even handled the mouse down logic yet\n  // - either way no drag should/can occur.\n  document.removeEventListener('mousemove', _onMouseDrag);\n}\n\n/**\n * Handles a mouse move on the state element after a mouse down AND up AND\n * while the double click timeout is still running.\n * @private\n * @param evt - The mouse event.\n */\nfunction _onMouseMove(evt: MouseEvent) {\n  const currentPoints = getMouseEventPoints(evt, state.element);\n  const lastPoints = _updateMouseEventsLastPoints(\n    state.element,\n    state.lastPoints\n  );\n\n  const deltaPoints = _getDeltaPoints(currentPoints, lastPoints);\n\n  if (!_isDragPastDoubleClickTolerance(deltaPoints.canvas)) {\n    return;\n  }\n\n  _doStateMouseDownAndUp();\n\n  // Do the move again because during the timeout the global mouse move listener was removed.\n  // Now it is back.\n  mouseMoveListener(evt);\n}\n\n/**\n * Determines if the given delta is past the double click, (projected) drag distance\n * tolerance.\n * @param delta the delta\n * @returns true iff the delta is past the tolerance\n */\nfunction _isDragPastDoubleClickTolerance(delta: Types.Point2): boolean {\n  return Math.abs(delta[0]) + Math.abs(delta[1]) > DOUBLE_CLICK_DRAG_TOLERANCE;\n}\n\nfunction _preventClickHandler() {\n  state.isClickEvent = false;\n}\n\n/**\n * Do a mouse down and potential mouse up using each of the events in the double click state.\n * The events were stored in the state during the timeout to determine a double click.\n *\n * This function should be invoked whenever it is determined that the latest\n * sequence of mouse down(s) and up(s) is NOT a double click. Examples of this include\n * - the expiration of the double click timeout\n * - a mouse drag/move beyond the DOUBLE_CLICK_DRAG_TOLERANCE\n *\n * This function sets the doubleClickState.ignoreDoubleClick flag in case our timeout value\n * or mouse move/drag tolerance is inaccurate and we do indeed get a double click event from\n * the browser later. The flag will be cleared in the mouseDoubleClickIgnoreListener should a\n * double click event get fired. If there is no eventual double click for the latest sequence,\n * the flag spills into the next sequence where it will get cleared at the beginning of that next\n * sequence in mouseDownListener. It is perfectly safe for the flag to be\n * left true when no double click actually occurs because any future double click must start with\n * a mouse down that is handled in this module.\n *\n * @private\n */\nfunction _doStateMouseDownAndUp() {\n  doubleClickState.ignoreDoubleClick = true;\n\n  const mouseDownEvent = doubleClickState.mouseDownEvent;\n  const mouseUpEvent = doubleClickState.mouseUpEvent;\n\n  _clearDoubleClickTimeoutAndEvents();\n\n  _doMouseDown(mouseDownEvent);\n\n  if (mouseUpEvent) {\n    _onMouseUp(mouseUpEvent);\n  }\n}\n\n/**\n * Clears the mouse events and double click timeout id in the double click state object.\n * The timeout itself is also cleared so that no callback is invoked.\n */\nfunction _clearDoubleClickTimeoutAndEvents() {\n  if (doubleClickState.doubleClickTimeout) {\n    clearTimeout(doubleClickState.doubleClickTimeout);\n    doubleClickState.doubleClickTimeout = null;\n  }\n\n  doubleClickState.mouseDownEvent = null;\n  doubleClickState.mouseUpEvent = null;\n}\n\nfunction _cleanUp() {\n  document.removeEventListener('mouseup', _onMouseUp);\n  state.element?.removeEventListener('mousemove', _onMouseMove);\n\n  // Restore our global mousemove listener\n  state.element?.addEventListener('mousemove', mouseMoveListener);\n\n  _clearDoubleClickTimeoutAndEvents();\n\n  state = JSON.parse(JSON.stringify(defaultState));\n}\n\n/**\n * Copies a set of points.\n * @param points - The `IPoints` instance to copy.\n *\n * @returns A copy of the points.\n */\nfunction _copyPoints(points: IPoints): IPoints {\n  return JSON.parse(JSON.stringify(points));\n}\n\n/**\n * Recalculates the last world coordinate, as the linear transform from client\n * to world could be different if the camera was updated.\n * @param element - The HTML element\n * @param lastPoints - The last points\n */\nfunction _updateMouseEventsLastPoints(\n  element: HTMLDivElement,\n  lastPoints: IPoints\n): IPoints {\n  const { viewport } = getEnabledElement(element);\n  // Need to update the world point to be calculated from the current reference frame,\n  // Which might have changed since the last interaction.\n  const world = viewport.canvasToWorld(lastPoints.canvas);\n\n  return {\n    page: lastPoints.page,\n    client: lastPoints.client,\n    canvas: lastPoints.canvas,\n    world,\n  };\n}\n\n/**\n * Returns the difference between two `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints -- The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The difference in IPoints format\n */\nfunction _getDeltaPoints(currentPoints: IPoints, lastPoints: IPoints): IPoints {\n  return {\n    page: _subtractPoints2D(currentPoints.page, lastPoints.page),\n    client: _subtractPoints2D(currentPoints.client, lastPoints.client),\n    canvas: _subtractPoints2D(currentPoints.canvas, lastPoints.canvas),\n    world: _subtractPoints3D(currentPoints.world, lastPoints.world),\n  };\n}\n\n/**\n * _subtractPoints - Subtracts `point1` from `point0`.\n * @param point0 - The first point.\n * @param point1 - The second point to subtract from the first.\n *\n * @returns The difference.\n */\nfunction _subtractPoints2D(\n  point0: Types.Point2,\n  point1: Types.Point2\n): Types.Point2 {\n  return [point0[0] - point1[0], point0[1] - point1[1]];\n}\n\nfunction _subtractPoints3D(\n  point0: Types.Point3,\n  point1: Types.Point3\n): Types.Point3 {\n  return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\n\nexport function getMouseButton(): number {\n  return state.mouseButton;\n}\n\n/**\n * Handles a dblclick event to determine if it should be ignored based on the\n * double click state's ignoreDoubleClick flag. stopImmediatePropagation and\n * preventDefault are used to ignore the event.\n * @param evt browser dblclick event\n */\nexport function mouseDoubleClickIgnoreListener(evt: MouseEvent) {\n  if (doubleClickState.ignoreDoubleClick) {\n    doubleClickState.ignoreDoubleClick = false;\n\n    // Use stopImmediatePropagation to lessen the possibility that a third party 'dblclick'\n    // listener receives this event. However, there still is no guarantee\n    // that any third party listener has not already handled the event.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  } else {\n    // If the embedding application blocked the first mouse down and up\n    // of a double click sequence from reaching this module, then this module\n    // has handled the second mouse down and up and thus needs to clean them up.\n    // Doing a clean up here for the typical double click case is harmless.\n    _cleanUp();\n  }\n}\n\nexport default mouseDownListener;\n","import mouseDoubleClickListener from './mouseDoubleClickListener';\nimport mouseDownListener, {\n  mouseDoubleClickIgnoreListener,\n} from './mouseDownListener';\nimport mouseMoveListener from './mouseMoveListener';\n\n/**\n * Removes mouse event listeners for native mouse event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to remove event listeners from.\n */\nfunction disable(element: HTMLDivElement): void {\n  element.removeEventListener('dblclick', mouseDoubleClickListener);\n  element.removeEventListener('mousedown', mouseDownListener);\n  element.removeEventListener('mousemove', mouseMoveListener);\n  // The mouseDoubleClickIgnoreListener prevents those browser 'dblclick'\n  // events that cornerstone has determined are single clicks from propagating\n  // to other (3rd party) listeners. A capture phase listener is used so that\n  // the 'dblclick' event can be ignored and not propagated ASAP.\n  element.removeEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n    capture: true,\n  });\n}\n\n/**\n * Registers mouse event listeners for native mouse event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to register event listeners on.\n */\nfunction enable(element: HTMLDivElement): void {\n  // Prevent handlers from being attached multiple times\n  disable(element);\n\n  element.addEventListener('dblclick', mouseDoubleClickListener);\n  element.addEventListener('mousedown', mouseDownListener);\n  element.addEventListener('mousemove', mouseMoveListener);\n  // The mouseDoubleClickIgnoreListener prevents those browser 'dblclick'\n  // events that cornerstone has determined are single clicks from propagating\n  // to other (3rd party) listeners. A capture phase listener is used so that\n  // the 'dblclick' event can be ignored and not propagated ASAP.\n  element.addEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n    capture: true,\n  });\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport normalizeWheel from './normalizeWheel';\nimport Events from '../../enums/Events';\n// ~~ VIEWPORT LIBRARY\nimport getMouseEventPoints from '../mouse/getMouseEventPoints';\nimport { MouseWheelEventDetail } from '../../types/EventTypes';\n\n/**\n * wheelListener - Captures and normalizes mouse wheel events. Emits as a\n * cornerstoneTools3D mouse wheel event.\n * @param evt - The mouse wheel event.\n */\nfunction wheelListener(evt: WheelEvent) {\n  const element = <HTMLDivElement>evt.currentTarget;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  // Prevent triggering MouseWheel events that are not real scroll events:\n  // E.g. when clicking the MiddleMouseWheelButton, a deltaY of 0 is emitted.\n  // See https://github.com/cornerstonejs/cornerstoneTools/issues/935\n  if (evt.deltaY > -1 && evt.deltaY < 1) {\n    return;\n  }\n\n  evt.preventDefault();\n\n  const { spinX, spinY, pixelX, pixelY } = normalizeWheel(evt);\n  const direction = spinY < 0 ? -1 : 1;\n\n  const eventDetail: MouseWheelEventDetail = {\n    event: evt,\n    eventName: Events.MOUSE_WHEEL,\n    renderingEngineId,\n    viewportId,\n    element,\n    camera: {},\n    detail: evt,\n    wheel: {\n      spinX,\n      spinY,\n      pixelX,\n      pixelY,\n      direction,\n    },\n    points: getMouseEventPoints(evt),\n  };\n\n  triggerEvent(element, Events.MOUSE_WHEEL, eventDetail);\n}\n\nexport default wheelListener;\n","// Reasonable defaults\nconst PIXEL_STEP = 10;\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\n\n/**\n * Normalizes wheel events and provides properties that are more\n * consistent and helpful across different browsers\n *\n * @param event - the original mouse event\n * @returns a normalized eventDetail\n */\nexport default function normalizeWheel(event) {\n  let spinX = 0,\n    spinY = 0,\n    pixelX = 0,\n    pixelY = 0;\n\n  // Legacy\n  if ('detail' in event) {\n    spinY = event.detail;\n  }\n  if ('wheelDelta' in event) {\n    spinY = -event.wheelDelta / 120;\n  }\n  if ('wheelDeltaY' in event) {\n    spinY = -event.wheelDeltaY / 120;\n  }\n  if ('wheelDeltaX' in event) {\n    spinX = -event.wheelDeltaX / 120;\n  }\n\n  pixelX = spinX * PIXEL_STEP;\n  pixelY = spinY * PIXEL_STEP;\n\n  if ('deltaY' in event) {\n    pixelY = event.deltaY;\n  }\n  if ('deltaX' in event) {\n    pixelX = event.deltaX;\n  }\n\n  if ((pixelX || pixelY) && event.deltaMode) {\n    if (event.deltaMode === 1) {\n      // Delta in LINE units\n      pixelX *= LINE_HEIGHT;\n      pixelY *= LINE_HEIGHT;\n    } else {\n      // Delta in PAGE units\n      pixelX *= PAGE_HEIGHT;\n      pixelY *= PAGE_HEIGHT;\n    }\n  }\n\n  // Fall-back if spin cannot be determined\n  if (pixelX && !spinX) {\n    spinX = pixelX < 1 ? -1 : 1;\n  }\n  if (pixelY && !spinY) {\n    spinY = pixelY < 1 ? -1 : 1;\n  }\n\n  return {\n    spinX,\n    spinY,\n    pixelX,\n    pixelY,\n  };\n}\n","import wheelListener from './wheelListener';\n\n/**\n * Listens for the wheel event, and handles it. Handled event\n * will be \"normalized\" and re-emitted as `Events.MOUSE_WHEEL`\n *\n * @param element - The HTML element\n */\nfunction enable(element: HTMLDivElement) {\n  disable(element);\n  element.addEventListener('wheel', wheelListener, { passive: false });\n}\n\n/**\n * Removes listener and handler for wheel event. `Events.MOUSE_WHEEL`\n * will no longer be emitted.\n *\n * @param element - THe HTML element\n */\nfunction disable(element: HTMLDivElement) {\n  element.removeEventListener('wheel', wheelListener);\n}\n\nexport default {\n  enable,\n  disable,\n};\n","// Functions to prevent ghost clicks following a touch\n// Since the event lifecycle is touchstart, mousedown, touchend, mouseup\n// we want to prevent mousedown and mouseup events after touch events\n// All credit to @kosich\n// https://gist.github.com/kosich/23188dd86633b6c2efb7\n\nconst antiGhostDelay = 2000,\n  pointerType = {\n    mouse: 0,\n    touch: 1,\n  };\n\nlet lastInteractionType, lastInteractionTime;\n\nfunction handleTap(type, e) {\n  const now = Date.now();\n\n  if (type !== lastInteractionType) {\n    if (now - lastInteractionTime <= antiGhostDelay) {\n      e.preventDefault();\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n\n      return false;\n    }\n\n    lastInteractionType = type;\n  }\n\n  lastInteractionTime = now;\n}\n\n// Cacheing the function references\n// Necessary because a new function reference is created after .bind() is called\n// http://stackoverflow.com/questions/11565471/removing-event-listener-which-was-added-with-bind\nconst handleTapMouse = handleTap.bind(null, pointerType.mouse);\nconst handleTapTouch = handleTap.bind(null, pointerType.touch);\n\nfunction attachEvents(element, eventList, interactionType) {\n  const tapHandler = interactionType ? handleTapMouse : handleTapTouch;\n\n  eventList.forEach(function (eventName) {\n    element.addEventListener(eventName, tapHandler, { passive: false });\n  });\n}\n\nfunction removeEvents(element, eventList, interactionType) {\n  const tapHandler = interactionType ? handleTapMouse : handleTapTouch;\n\n  eventList.forEach(function (eventName) {\n    element.removeEventListener(eventName, tapHandler);\n  });\n}\n\nconst mouseEvents = ['mousedown', 'mouseup', 'mousemove'];\nconst touchEvents = ['touchstart', 'touchend'];\n\nfunction disable(element) {\n  removeEvents(element, mouseEvents, pointerType.mouse);\n  removeEvents(element, touchEvents, pointerType.touch);\n}\n\nfunction enable(element) {\n  disable(element);\n  attachEvents(element, mouseEvents, pointerType.mouse);\n  attachEvents(element, touchEvents, pointerType.touch);\n}\n\nexport default {\n  enable,\n  disable,\n};\n","enum Swipe {\n  UP = 'UP',\n  DOWN = 'DOWN',\n  LEFT = 'LEFT',\n  RIGHT = 'RIGHT',\n}\n\nexport { Swipe };\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { ITouchPoints } from '../../types';\n\n/**\n * Given a native touch event, get the associated cornerstone3D enabled element\n * and derive a set of coordinates useful for tools.\n * @param evt - The Touch event.\n * @param element - The DOM HTMLDivElement that the event was triggered on.\n * @returns The points related to the event in the form of a `IPoints` object containing\n * the following properties: `page`, `client`, `canvas`, and `world` details of the event.\n */\nexport default function getTouchEventPoints(\n  evt: TouchEvent,\n  element?: HTMLDivElement\n): ITouchPoints[] {\n  const elementToUse = element || (evt.currentTarget as HTMLDivElement);\n  const touches = evt.type === 'touchend' ? evt.changedTouches : evt.touches;\n  return Object.keys(touches).map((i) => {\n    const clientPoint = _clientToPoint(touches[i]);\n    const pagePoint = _pageToPoint(touches[i]);\n    const canvasPoint = _pagePointsToCanvasPoints(elementToUse, pagePoint);\n    const { viewport } = getEnabledElement(elementToUse);\n    const worldPoint = viewport.canvasToWorld(canvasPoint);\n    return {\n      page: pagePoint,\n      client: clientPoint,\n      canvas: canvasPoint,\n      world: worldPoint,\n      touch: {\n        identifier: i,\n        radiusX: touches[i].radiusX,\n        radiusY: touches[i].radiusY,\n        force: touches[i].force,\n        rotationAngle: touches[i].rotationAngle,\n      },\n    };\n  });\n}\n\n/**\n * Converts point from page coordinates to canvas coordinates.\n * @param element - HTMLDivElement\n * @param pagePoint - Point in page coordinates pageX and pageY\n *\n * @returns The canvas coordinate points\n */\nfunction _pagePointsToCanvasPoints(\n  element: HTMLDivElement,\n  pagePoint: Types.Point2\n): Types.Point2 {\n  const rect = element.getBoundingClientRect();\n  return [\n    pagePoint[0] - rect.left - window.pageXOffset,\n    pagePoint[1] - rect.top - window.pageYOffset,\n  ];\n}\n\n/**\n * Converts the event's `pageX` and `pageY` properties to Types.Point2 format\n *\n * @param touch - The Touch\n */\nfunction _pageToPoint(touch: Touch): Types.Point2 {\n  return [touch.pageX, touch.pageY];\n}\n\n/**\n * Converts the event's `clientX` and `clientY` properties to Types.Point2 format\n * @param evt - The Touch `Event`\n */\nfunction _clientToPoint(touch: Touch): Types.Point2 {\n  return [touch.clientX, touch.clientY];\n}\n","import { IDistance, IPoints, ITouchPoints } from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IPoints {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _subtractPoints2D(curr.page, last.page),\n    client: _subtractPoints2D(curr.client, last.client),\n    canvas: _subtractPoints2D(curr.canvas, last.canvas),\n    world: _subtractPoints3D(curr.world, last.world),\n  };\n}\n\n/**\n * Returns the distance between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The distance difference in IDistance format\n */\nfunction getDeltaDistance(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _getDistance2D(curr.page, last.page),\n    client: _getDistance2D(curr.client, last.client),\n    canvas: _getDistance2D(curr.canvas, last.canvas),\n    world: _getDistance3D(curr.world, last.world),\n  };\n}\n\nfunction getDeltaRotation(\n  currentPoints: ITouchPoints[],\n  lastPoints: ITouchPoints[]\n) {\n  // TODO\n}\n\n/**\n * Returns the distance difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints -- The last points.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaDistanceBetweenIPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);\n  const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);\n  const deltaDistance = {\n    page: currentDistance.page - lastDistance.page,\n    client: currentDistance.client - lastDistance.client,\n    canvas: currentDistance.canvas - lastDistance.canvas,\n    world: currentDistance.world - lastDistance.world,\n  };\n  return deltaDistance;\n}\n\n/**\n * Copies a set of points.\n * @param points - The `IPoints` instance to copy.\n *\n * @returns A copy of the points.\n */\nfunction copyPointsList(points: ITouchPoints[]): ITouchPoints[] {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction copyPoints(points: ITouchPoints): ITouchPoints {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction getMeanPoints(points: IPoints[]): IPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n    }\n  );\n}\n\nfunction getMeanTouchPoints(points: ITouchPoints[]): ITouchPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n        touch: {\n          identifier: null,\n          radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,\n          radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,\n          force: prev.touch.force + curr.touch.force / points.length,\n          rotationAngle:\n            prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,\n        },\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n      touch: {\n        identifier: null,\n        radiusX: 0,\n        radiusY: 0,\n        force: 0,\n        rotationAngle: 0,\n      },\n    }\n  );\n}\n/**\n * _subtractPoints - Subtracts `point1` from `point0`.\n * @param point0 - The first point.\n * @param point1 - The second point to subtract from the first.\n *\n * @returns The difference.\n */\nfunction _subtractPoints2D(\n  point0: Types.Point2,\n  point1: Types.Point2\n): Types.Point2 {\n  return [point0[0] - point1[0], point0[1] - point1[1]];\n}\n\nfunction _subtractPoints3D(\n  point0: Types.Point3,\n  point1: Types.Point3\n): Types.Point3 {\n  return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\n\nfunction _getMeanDistanceBetweenAllIPoints(points: IPoints[]): IDistance {\n  // get mean distance between all unordered pairs of points\n  const pairedDistance: IDistance[] = [];\n  for (let i = 0; i < points.length; i++) {\n    for (let j = 0; j < points.length; j++) {\n      if (i < j) {\n        pairedDistance.push({\n          page: _getDistance2D(points[i].page, points[j].page),\n          client: _getDistance2D(points[i].client, points[j].client),\n          canvas: _getDistance2D(points[i].canvas, points[j].canvas),\n          world: _getDistance3D(points[i].world, points[j].world),\n        });\n      }\n    }\n  }\n\n  // take the average distance\n  return pairedDistance.reduce(\n    (prev, curr) => {\n      return {\n        page: prev.page + curr.page / pairedDistance.length,\n        client: prev.client + curr.client / pairedDistance.length,\n        canvas: prev.canvas + curr.canvas / pairedDistance.length,\n        world: prev.world + curr.world / pairedDistance.length,\n      };\n    },\n    {\n      page: 0,\n      client: 0,\n      canvas: 0,\n      world: 0,\n    }\n  );\n}\n\nfunction _getDistance2D(point0: Types.Point2, point1: Types.Point2): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2)\n  );\n}\n\nfunction _getDistance3D(point0: Types.Point3, point1: Types.Point3): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) +\n      Math.pow(point0[1] - point1[1], 2) +\n      Math.pow(point0[2] - point1[2], 2)\n  );\n}\n\nexport {\n  getMeanPoints,\n  getMeanTouchPoints,\n  copyPoints,\n  copyPointsList,\n  getDeltaDistanceBetweenIPoints,\n  getDeltaPoints,\n  getDeltaDistance,\n  getDeltaRotation,\n};\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport { Swipe } from '../../enums/Touch';\n\nimport { EventTypes, ITouchPoints, IPoints, IDistance } from '../../types';\n\nimport getTouchEventPoints from './getTouchEventPoints';\nimport {\n  copyPoints,\n  copyPointsList,\n  getDeltaDistanceBetweenIPoints,\n  getDeltaDistance,\n  getDeltaPoints,\n  getMeanTouchPoints,\n  // getRotation\n} from '../../utilities/touch';\nimport { Settings } from '@cornerstonejs/core';\n\nconst runtimeSettings = Settings.getRuntimeSettings();\n\nconst {\n  TOUCH_START,\n  TOUCH_START_ACTIVATE,\n  TOUCH_PRESS,\n  TOUCH_DRAG,\n  TOUCH_END,\n  TOUCH_TAP,\n  TOUCH_SWIPE,\n} = Events;\n\ninterface ITouchTapListenerState {\n  element: HTMLDivElement;\n  renderingEngineId: string;\n  viewportId: string;\n  startPointsList: ITouchPoints[];\n  tapMaxDistance: number;\n  tapTimeout: ReturnType<typeof setTimeout>;\n  taps: number;\n  tapToleranceMs: number;\n}\n\ninterface ITouchStartListenerState {\n  element: HTMLDivElement;\n  renderingEngineId: string;\n  viewportId: string;\n  startPointsList: ITouchPoints[];\n  lastPointsList: ITouchPoints[];\n\n  // only trigger one touch event in the case the user puts down multiple fingers\n  isTouchStart: boolean;\n  startTime: Date;\n\n  // handle long press\n  pressTimeout: ReturnType<typeof setTimeout>;\n  pressDelay: number;\n  pressMaxDistance: number;\n  accumulatedDistance: IDistance;\n\n  // handle swipes\n  swipeDistanceThreshold: number;\n  swiped: boolean;\n  swipeToleranceMs: number;\n}\n\nconst zeroIPoint: IPoints = {\n  page: [0, 0],\n  client: [0, 0],\n  canvas: [0, 0],\n  world: [0, 0, 0],\n};\n\nconst zeroIDistance: IDistance = {\n  page: 0,\n  client: 0,\n  canvas: 0,\n  world: 0,\n};\n\n// STATE\nconst defaultState: ITouchStartListenerState = {\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  element: null,\n  startPointsList: [\n    {\n      ...zeroIPoint,\n      touch: null,\n    },\n  ],\n  lastPointsList: [\n    {\n      ...zeroIPoint,\n      touch: null,\n    },\n  ],\n  isTouchStart: false,\n  startTime: null,\n\n  pressTimeout: null,\n  pressDelay: 700,\n  pressMaxDistance: 5,\n  accumulatedDistance: zeroIDistance,\n\n  swipeDistanceThreshold: 48,\n  swiped: false,\n  swipeToleranceMs: 300, // user has 300ms to swipe after touch start or no swipe will trigger\n};\n\n// TODO: these values should be configurable to handle different use cases such\n// as pen, left/right handed, index finger vs thumb, etc. These current values\n// assume thumb usage for single finger and index/middle finger for two finger\n// gestures in an attempt to cover the 90% use case.\nconst defaultTapState: ITouchTapListenerState = {\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  element: null,\n  startPointsList: [\n    {\n      ...zeroIPoint,\n      touch: null,\n    },\n  ],\n  taps: 0,\n  tapTimeout: null,\n  tapMaxDistance: 24,\n  tapToleranceMs: 300,\n};\n\nlet state: ITouchStartListenerState = JSON.parse(JSON.stringify(defaultState));\nlet tapState: ITouchTapListenerState = JSON.parse(\n  JSON.stringify(defaultTapState)\n);\n\nfunction triggerEventCallback(ele, name, eventDetail) {\n  return triggerEvent(ele, name, eventDetail);\n}\n\n/**\n * Listens to touch events from the DOM (touchstart, touchmove, touchend)\n * and depending on interaction and further interaction can emit the\n * following touch events:\n *\n * - TOUCH_START\n * - TOUCH_START_ACTIVATE\n * - TOUCH_PRESS\n * - TOUCH_DRAG (move while down)\n * - TOUCH_SWIPE\n * - TOUCH_END (also an end for multi touch)\n *\n * - TOUCH_TAP\n *\n * @param evt - The Touch event (touchstart).\n * @private\n */\nfunction touchStartListener(evt: TouchEvent) {\n  // if a user adds an extra finger when a touch/multi touch has already started\n  // don't trigger another touch.\n  state.element = <HTMLDivElement>evt.currentTarget;\n  const enabledElement = getEnabledElement(state.element);\n  const { renderingEngineId, viewportId } = enabledElement;\n  state.renderingEngineId = renderingEngineId;\n  state.viewportId = viewportId;\n  // this prevents multiple start firing\n  if (state.isTouchStart) {\n    return;\n  }\n  // this will clear on touchstart and touchend\n  clearTimeout(state.pressTimeout);\n  state.pressTimeout = setTimeout(() => _onTouchPress(evt), state.pressDelay);\n\n  _onTouchStart(evt);\n  document.addEventListener('touchmove', _onTouchDrag); // also checks for swipe\n  document.addEventListener('touchend', _onTouchEnd); // also checks for tap\n}\n\n/**\n * _onTouchPress - Handle emission of touchstart events which are held down for a longer\n * period of time\n *\n * @private\n * @param evt - The touch event (touchstart)\n */\nfunction _onTouchPress(evt: TouchEvent) {\n  const totalDistance = state.accumulatedDistance.canvas;\n  if (totalDistance > state.pressMaxDistance) {\n    return;\n  }\n  const eventDetail: EventTypes.TouchPressEventDetail = {\n    event: evt, // touchstart native event\n    eventName: TOUCH_PRESS,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    startPointsList: copyPointsList(state.startPointsList),\n    lastPointsList: copyPointsList(state.lastPointsList),\n    startPoints: copyPoints(getMeanTouchPoints(state.startPointsList)),\n    lastPoints: copyPoints(getMeanTouchPoints(state.lastPointsList)),\n  };\n  triggerEventCallback(eventDetail.element, TOUCH_PRESS, eventDetail);\n}\n\n/**\n * _onTouchStart - Handle emission of touchstart events.\n *\n * @private\n * @param evt - The touch event (touchstart)\n */\nfunction _onTouchStart(evt: TouchEvent) {\n  state.isTouchStart = true;\n  state.startTime = new Date();\n  const startPointsList = getTouchEventPoints(evt, state.element);\n  const startPoints = getMeanTouchPoints(startPointsList);\n  const deltaPoints = zeroIPoint;\n  const deltaDistance = zeroIDistance;\n  // deltaRotation same as deltaDistance but values are theta\n  const eventDetail: EventTypes.TouchStartEventDetail = {\n    event: evt,\n    eventName: TOUCH_START,\n    element: state.element,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    startPointsList: startPointsList,\n    lastPointsList: startPointsList,\n    currentPointsList: startPointsList,\n    startPoints: startPoints,\n    lastPoints: startPoints,\n    currentPoints: startPoints,\n    deltaPoints,\n    deltaDistance,\n    // deltaRotation\n  };\n\n  state.startPointsList = copyPointsList(eventDetail.startPointsList);\n  state.lastPointsList = copyPointsList(eventDetail.lastPointsList);\n  // by triggering TOUCH_START it checks if this is toolSelection, handle modification etc.\n  // of already existing tools\n  const eventDidPropagate = triggerEventCallback(\n    eventDetail.element,\n    TOUCH_START,\n    eventDetail\n  );\n\n  // if no tools responded to this event and prevented its default propagation behavior,\n  // create a new tool\n  if (eventDidPropagate) {\n    triggerEventCallback(\n      eventDetail.element,\n      TOUCH_START_ACTIVATE,\n      eventDetail\n    );\n  }\n}\n\n/**\n * _onTouchDrag - Handle emission of drag events whilst the touch is depressed.\n *\n * @private\n * @param evt - The touch event (touchmove)\n */\nfunction _onTouchDrag(evt: TouchEvent) {\n  const currentPointsList = getTouchEventPoints(evt, state.element);\n  const lastPointsList = _updateTouchEventsLastPoints(\n    state.element,\n    state.lastPointsList\n  );\n\n  const deltaPoints =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaPoints(currentPointsList, lastPointsList)\n      : zeroIPoint;\n\n  const deltaDistance =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaDistanceBetweenIPoints(currentPointsList, lastPointsList)\n      : zeroIDistance;\n\n  const totalDistance =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaDistance(currentPointsList, state.lastPointsList)\n      : zeroIDistance;\n\n  state.accumulatedDistance = {\n    page: state.accumulatedDistance.page + totalDistance.page,\n    client: state.accumulatedDistance.client + totalDistance.client,\n    canvas: state.accumulatedDistance.canvas + totalDistance.canvas,\n    world: state.accumulatedDistance.world + totalDistance.world,\n  };\n\n  /**\n   * this is can be uncommented to make dragging smoother. In the future, these values\n   * should be in a configuration file. There may also need to be different\n   * profiles for left handed and right handed thumb use. These values\n   * are currently optimized for left handed use.\n   *\n   * const clamp = (num) => Math.min(Math.max(num, -15), 10);\n   * const deltaDistanceClamped = \\{\n   *     page: clamp(deltaDistance.page),\n   *     client: clamp(deltaDistance.client),\n   *     canvas: clamp(deltaDistance.canvas),\n   *     world: clamp(deltaDistance.world),\n   * \\};\n   */\n\n  const eventDetail: EventTypes.TouchDragEventDetail = {\n    event: evt,\n    eventName: TOUCH_DRAG,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    startPoints: getMeanTouchPoints(state.startPointsList),\n    lastPoints: getMeanTouchPoints(lastPointsList),\n    currentPoints: getMeanTouchPoints(currentPointsList),\n    startPointsList: copyPointsList(state.startPointsList),\n    lastPointsList: copyPointsList(lastPointsList),\n    currentPointsList,\n    deltaPoints: deltaPoints,\n    deltaDistance: deltaDistance,\n  };\n\n  triggerEventCallback(state.element, TOUCH_DRAG, eventDetail);\n\n  // check for swipe events\n  _checkTouchSwipe(evt, deltaPoints);\n\n  // Update the last points\n  state.lastPointsList = copyPointsList(currentPointsList);\n}\n\n/**\n * _onTouchEnd - Handle emission of touch end events\n *\n * @private\n * @param evt - The touch event.\n */\nfunction _onTouchEnd(evt: TouchEvent): void {\n  // in case it was a tap event we don't want to fire the cornerstone normalized\n  // touch end event if the touch start never happend\n  clearTimeout(state.pressTimeout);\n  const currentPointsList = getTouchEventPoints(evt, state.element);\n  const lastPointsList = _updateTouchEventsLastPoints(\n    state.element,\n    state.lastPointsList\n  );\n  const deltaPoints =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaPoints(currentPointsList, lastPointsList)\n      : getDeltaPoints(currentPointsList, currentPointsList);\n  const deltaDistance =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaDistanceBetweenIPoints(currentPointsList, lastPointsList)\n      : getDeltaDistanceBetweenIPoints(currentPointsList, currentPointsList);\n  const eventDetail: EventTypes.TouchEndEventDetail = {\n    event: evt,\n    eventName: TOUCH_END,\n    element: state.element,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    startPointsList: copyPointsList(state.startPointsList),\n    lastPointsList: copyPointsList(lastPointsList),\n    currentPointsList,\n    startPoints: getMeanTouchPoints(state.startPointsList),\n    lastPoints: getMeanTouchPoints(lastPointsList),\n    currentPoints: getMeanTouchPoints(currentPointsList),\n    deltaPoints,\n    deltaDistance,\n  };\n\n  triggerEventCallback(eventDetail.element, TOUCH_END, eventDetail);\n  _checkTouchTap(evt);\n\n  // reset to default state\n  state = JSON.parse(JSON.stringify(defaultState));\n  document.removeEventListener('touchmove', _onTouchDrag);\n  document.removeEventListener('touchend', _onTouchEnd);\n}\n\nfunction _checkTouchTap(evt: TouchEvent): void {\n  const currentTime = new Date().getTime();\n  const startTime = state.startTime.getTime();\n  if (currentTime - startTime > tapState.tapToleranceMs) {\n    return;\n  }\n\n  // first tap, initialize the state\n  if (tapState.taps === 0) {\n    tapState.element = state.element;\n    tapState.renderingEngineId = state.renderingEngineId;\n    tapState.viewportId = state.viewportId;\n    tapState.startPointsList = state.startPointsList;\n  }\n\n  // subsequent tap is on a different element\n  if (\n    tapState.taps > 0 &&\n    !(\n      tapState.element == state.element &&\n      tapState.renderingEngineId == state.renderingEngineId &&\n      tapState.viewportId == state.viewportId\n    )\n  ) {\n    return;\n  }\n\n  const currentPointsList = getTouchEventPoints(evt, tapState.element);\n  const distanceFromStart = getDeltaDistance(\n    currentPointsList,\n    tapState.startPointsList\n  ).canvas;\n\n  // if the tap is too far from starting tap, we can ignore it.\n  // TODO: in the case the user means to tap in two separate areas within the\n  // tapTolerance (300ms), the second tap will not trigger. This is because it\n  // is ignored below for simplicity to track multiple taps (double, triple etc)\n  // in order to support two separate single taps that occur < 300ms on the\n  // screen. One can create the concept of \"TapChains\". Our current implementation\n  // only supports a single tap chain on the screen. You can think of it as a\n  // region where the user has the option to perform unlimited multitaps as long\n  // as they are < the tapToleranceMs value. So a tap somewhere else on the screen\n  // that is > the tapMaxDistance will start a separate and new \"TapChain\".\n  if (distanceFromStart > tapState.tapMaxDistance) {\n    return;\n  }\n\n  clearTimeout(tapState.tapTimeout);\n  tapState.taps += 1;\n\n  tapState.tapTimeout = setTimeout(() => {\n    const eventDetail: EventTypes.TouchTapEventDetail = {\n      event: evt,\n      eventName: TOUCH_TAP,\n      element: tapState.element,\n      renderingEngineId: tapState.renderingEngineId,\n      viewportId: tapState.viewportId,\n      camera: {},\n      currentPointsList,\n      currentPoints: getMeanTouchPoints(currentPointsList),\n      taps: tapState.taps,\n    };\n    triggerEventCallback(eventDetail.element, TOUCH_TAP, eventDetail);\n    tapState = JSON.parse(JSON.stringify(defaultTapState));\n  }, tapState.tapToleranceMs);\n}\n\nfunction _checkTouchSwipe(evt: TouchEvent, deltaPoints: IPoints) {\n  const currentTime = new Date().getTime();\n  const startTime = state.startTime.getTime();\n  if (state.swiped || currentTime - startTime > state.swipeToleranceMs) {\n    return;\n  }\n  const [x, y] = deltaPoints.canvas;\n  const eventDetail: EventTypes.TouchSwipeEventDetail = {\n    event: evt,\n    eventName: TOUCH_SWIPE,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    swipe: null,\n  };\n  if (Math.abs(x) > state.swipeDistanceThreshold) {\n    eventDetail.swipe = x > 0 ? Swipe.RIGHT : Swipe.LEFT;\n    triggerEventCallback(eventDetail.element, TOUCH_SWIPE, eventDetail);\n    state.swiped = true;\n  }\n\n  if (Math.abs(y) > state.swipeDistanceThreshold) {\n    eventDetail.swipe = y > 0 ? Swipe.DOWN : Swipe.UP;\n    triggerEventCallback(eventDetail.element, TOUCH_SWIPE, eventDetail);\n    state.swiped = true;\n  }\n}\n\n/**\n * Recalculates the last world coordinate, as the linear transform from client\n * to world could be different if the camera was updated.\n * @param element - The HTML element\n * @param lastPoints - The last points\n */\nfunction _updateTouchEventsLastPoints(\n  element: HTMLDivElement,\n  lastPoints: ITouchPoints[]\n): ITouchPoints[] {\n  const { viewport } = getEnabledElement(element);\n  // Need to update the world point to be calculated from the current reference frame,\n  // Which might have changed since the last interaction.\n  return lastPoints.map((lp) => {\n    const world = viewport.canvasToWorld(lp.canvas);\n    return {\n      page: lp.page,\n      client: lp.client,\n      canvas: lp.canvas,\n      world,\n      touch: lp.touch,\n    };\n  });\n}\n\nexport default touchStartListener;\n","import preventGhostClick from './preventGhostClick';\nimport touchStartListener from './touchStartListener';\n\n/**\n * Removes touch event listeners for native touch event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to remove event listeners from.\n */\nfunction disable(element: HTMLDivElement): void {\n  preventGhostClick.disable(element);\n  element.removeEventListener('touchstart', touchStartListener);\n}\n\n/**\n * Registers touch event listeners for native touch event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to register event listeners on.\n */\nfunction enable(element: HTMLDivElement): void {\n  // Prevent handlers from being attached multiple times\n  disable(element);\n  preventGhostClick.enable(element);\n  element.addEventListener('touchstart', touchStartListener, {\n    passive: false,\n  });\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import _cloneDeep from 'lodash.clonedeep';\nimport { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport { KeyDownEventDetail, KeyUpEventDetail } from '../../types/EventTypes';\n\ninterface IKeyDownListenerState {\n  renderingEngineId: string;\n  viewportId: string;\n  key: string | null;\n  keyCode: number | null;\n  element: HTMLDivElement;\n}\n\nconst defaultState: IKeyDownListenerState = {\n  //\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  key: undefined,\n  keyCode: undefined,\n  element: null,\n};\n\nlet state: IKeyDownListenerState = {\n  //\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  key: undefined,\n  keyCode: undefined,\n  element: null,\n};\n\n/**\n * Normalizes the keyboard event and triggers KEY_DOWN event from CornerstoneTools3D events\n * @param evt - DOM Keyboard event\n */\nfunction keyListener(evt: KeyboardEvent): void {\n  state.element = <HTMLDivElement>evt.currentTarget;\n\n  const enabledElement = getEnabledElement(state.element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  state.renderingEngineId = renderingEngineId;\n  state.viewportId = viewportId;\n  state.key = evt.key;\n  state.keyCode = evt.keyCode;\n\n  evt.preventDefault();\n  const eventDetail: KeyDownEventDetail = {\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    element: state.element,\n    key: state.key,\n    keyCode: state.keyCode,\n\n    // detail: evt,\n    // Todo: mouse event points can be used later for placing tools with a key\n    // e.g., putting an arrow/probe/etc. on the mouse position. Another use case\n    // hovering and deleting the tool\n    // points: getMouseEventPoints(evt),\n  };\n\n  triggerEvent(eventDetail.element, Events.KEY_DOWN, eventDetail);\n\n  document.addEventListener('keyup', _onKeyUp);\n  document.addEventListener('visibilitychange', _onVisibilityChange);\n\n  // Todo: handle combination of keys\n  state.element.removeEventListener('keydown', keyListener);\n}\n\n/**\n * Whenever the visibility (i.e. tab focus) changes such that the tab is NOT the\n * active tab, reset the modifier key.\n */\nfunction _onVisibilityChange(): void {\n  document.removeEventListener('visibilitychange', _onVisibilityChange);\n  if (document.visibilityState === 'hidden') {\n    resetModifierKey();\n  }\n}\n\nfunction _onKeyUp(evt: KeyboardEvent): void {\n  const eventDetail: KeyUpEventDetail = {\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    element: state.element,\n    key: state.key,\n    keyCode: state.keyCode,\n    // detail: evt,\n  };\n\n  // Remove our temporary handlers\n  document.removeEventListener('keyup', _onKeyUp);\n  document.removeEventListener('visibilitychange', _onVisibilityChange);\n  state.element.addEventListener('keydown', keyListener);\n\n  // Restore `state` to `defaultState`\n  state = _cloneDeep(defaultState);\n  triggerEvent(eventDetail.element, Events.KEY_UP, eventDetail);\n}\n\nexport function getModifierKey(): number | undefined {\n  return state.keyCode;\n}\n\nexport function resetModifierKey(): void {\n  state.keyCode = undefined;\n}\n\nexport default keyListener;\n","import keyDownListener, { getModifierKey } from './keyDownListener';\n\nfunction enable(element: HTMLDivElement): void {\n  disable(element);\n  element.addEventListener('keydown', keyDownListener);\n}\n\nfunction disable(element: HTMLDivElement): void {\n  element.removeEventListener('keydown', keyDownListener);\n}\n\nexport default {\n  enable,\n  disable,\n  getModifierKey,\n};\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Given a rendering engine Id and a viewport Id, return the tool group that\n * contains that rendering engine and viewport. Note: A viewport can only be\n * associated with a single tool group. You cannot have a viewport that belongs\n * to multiple tool groups. To achieve so, create a new viewport and a new toolGroup\n * for it. This will not impact memory usage much as the volume textures are\n * shared across all viewports rendering the same image.\n *\n * @param viewportId - The Id of the viewport that the tool is being\n * added to.\n * @param renderingEngineId - The Id of the rendering engine that the\n * tool group is associated with.\n * @returns A tool group.\n */\nfunction getToolGroupForViewport(\n  viewportId: string,\n  renderingEngineId: string\n): IToolGroup | undefined {\n  const toolGroupFilteredByIds = state.toolGroups.filter((tg) =>\n    tg.viewportsInfo.some(\n      (vp) =>\n        vp.renderingEngineId === renderingEngineId &&\n        (!vp.viewportId || vp.viewportId === viewportId)\n    )\n  );\n\n  if (!toolGroupFilteredByIds.length) {\n    return;\n  }\n\n  if (toolGroupFilteredByIds.length > 1) {\n    throw new Error(\n      `Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only\n      have one tool group per viewport in a renderingEngine.`\n    );\n  }\n\n  return toolGroupFilteredByIds[0];\n}\n\nexport default getToolGroupForViewport;\n","import {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../../../types/LabelmapTypes';\nimport {\n  LabelmapToolOperationData,\n  LabelmapToolOperationDataStack,\n  LabelmapToolOperationDataVolume,\n} from '../../../../types';\n\nfunction isStackSegmentation(\n  operationData: LabelmapToolOperationData | LabelmapSegmentationData\n): operationData is\n  | LabelmapToolOperationDataStack\n  | LabelmapSegmentationDataStack {\n  return (\n    (operationData as LabelmapToolOperationDataStack).imageIdReferenceMap !==\n    undefined\n  );\n}\n\nfunction isVolumeSegmentation(\n  operationData: LabelmapToolOperationData | LabelmapSegmentationData\n): operationData is\n  | LabelmapToolOperationDataVolume\n  | LabelmapSegmentationDataVolume {\n  return (\n    (operationData as LabelmapToolOperationDataVolume)?.volumeId !== undefined\n  );\n}\n\nexport { isStackSegmentation, isVolumeSegmentation };\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Given a tool group Id, return the tool group\n * @param toolGroupId - The Id of the tool group to be retrieved.\n * @returns The tool group that has the same id as the tool group id that was\n * passed in.\n */\nfunction getToolGroup(toolGroupId: string): IToolGroup | undefined {\n  return state.toolGroups.find((s) => s.id === toolGroupId);\n}\n\nexport default getToolGroup;\n","import SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\n\nimport {\n  RepresentationConfig,\n  SegmentationRepresentationConfig,\n  SegmentSpecificRepresentationConfig,\n} from '../../../types/SegmentationStateTypes';\n\n/**\n * It returns the global segmentation config.\n * @returns The global segmentation config containing the representations\n * config for each representation type and renderInactiveSegmentations flag.\n */\nfunction getGlobalConfig(): SegmentationRepresentationConfig {\n  return SegmentationState.getGlobalConfig();\n}\n\n/**\n * Set the global segmentation config\n * @param segmentationConfig - SegmentationConfig\n */\nfunction setGlobalConfig(\n  segmentationConfig: SegmentationRepresentationConfig\n): void {\n  SegmentationState.setGlobalConfig(segmentationConfig);\n}\n\n/**\n * Given a representation type, return the corresponding global representation config\n * @param representationType - The type of representation to query\n * @returns A representation configuration object.\n */\nfunction getGlobalRepresentationConfig(\n  representationType: SegmentationRepresentations\n): RepresentationConfig['LABELMAP'] {\n  const globalConfig = getGlobalConfig();\n  return globalConfig.representations[representationType];\n}\n\n/**\n * Set the global configuration for a given representation type. It fires\n * a SEGMENTATION_MODIFIED event.\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param representationType - The type of representation to set config for\n * @param config - The configuration for the representation.\n */\nfunction setGlobalRepresentationConfig(\n  representationType: SegmentationRepresentations,\n  config: RepresentationConfig['LABELMAP']\n): void {\n  const globalConfig = getGlobalConfig();\n\n  setGlobalConfig({\n    ...globalConfig,\n    representations: {\n      ...globalConfig.representations,\n      [representationType]: {\n        ...globalConfig.representations[representationType],\n        ...config,\n      },\n    },\n  });\n}\n\n/**\n * Get the toolGroup specific segmentation config\n * @param toolGroupId - The Id of the tool group\n * @returns A SegmentationConfig object.\n */\nfunction getToolGroupSpecificConfig(\n  toolGroupId: string\n): SegmentationRepresentationConfig {\n  return SegmentationState.getToolGroupSpecificConfig(toolGroupId);\n}\n\n/**\n * Sets the tool group specific configuration for the segmentation\n * representation. This will apply to all segmentation representations.\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationConfig - This is the configuration object that you will use to set the default values for\n * the segmentation representation.\n */\nfunction setToolGroupSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationConfig: SegmentationRepresentationConfig\n): void {\n  SegmentationState.setToolGroupSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationConfig\n  );\n}\n\n/**\n * Give the segmentation representation UID, return the corresponding config\n * which is shared by all segments in the segmentation representation. This is\n * an optional level of configuration that can be set by the user, by default\n * it will fallback to the toolGroup specific config, if not set, it will fallback\n * to the global config.\n *\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param config - The configuration for the representation. This is an object\n * only containing the representation type as key and the config as value.\n * @returns - The configuration for the representation.\n */\nfunction getSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): RepresentationConfig {\n  return SegmentationState.getSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Set the segmentation representation specific configuration for the\n * segmentation representation. This will apply to all segments in the\n * segmentation representation and has higher priority than the toolGroup\n * specific config.\n *\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param config - The configuration for the representation. This is an object\n * only containing the representation type as key and the config as value.\n */\nfunction setSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: RepresentationConfig\n): void {\n  SegmentationState.setSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n}\n\n/**\n * Get the segment specific configuration for the segmentation representation.\n *\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationUID  - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment\n * @returns - The configuration for the segment index in the segmentation representation that is shown in the toolGroup's viewport\n */\nfunction getSegmentSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): RepresentationConfig {\n  return SegmentationState.getSegmentSpecificRepresentationConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n}\n\n/**\n * Set the segment specific configuration for the segmentation representation.\n * This configuration, if specified, has higher priority than the segmentation representation specific config,\n * and the toolGroup specific config. The order of priority is: segment specific config > segmentation representation specific config > toolGroup specific config > global config\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment\n * @param config - The configuration for the representation. This is an object\n */\nfunction setSegmentSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: SegmentSpecificRepresentationConfig\n): void {\n  SegmentationState.setSegmentSpecificRepresentationConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n}\n\nexport {\n  // Global\n  getGlobalConfig,\n  setGlobalConfig,\n  getGlobalRepresentationConfig,\n  setGlobalRepresentationConfig,\n  // ToolGroup Specific\n  getToolGroupSpecificConfig,\n  setToolGroupSpecificConfig,\n  // segmentation representation specific config\n  getSegmentationRepresentationSpecificConfig,\n  setSegmentationRepresentationSpecificConfig,\n  // segment specific config\n  getSegmentSpecificConfig,\n  setSegmentSpecificConfig,\n};\n","import { cache, Types } from '@cornerstonejs/core';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getSegmentationRepresentations } from '../../../stateManagement/segmentation/segmentationState';\nimport { ToolGroupSpecificRepresentation } from '../../../types/SegmentationStateTypes';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nimport SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\n\nfunction getUniqueSegmentIndices(segmentationId) {\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n\n  if (segmentation.type === SegmentationRepresentations.Labelmap) {\n    const volume = cache.getVolume(segmentationId);\n    const scalarData = volume.getScalarData();\n\n    const keySet = {};\n    for (let i = 0; i < scalarData.length; i++) {\n      const segmentIndex = scalarData[i];\n      if (segmentIndex !== 0 && !keySet[segmentIndex]) {\n        keySet[segmentIndex] = true;\n      }\n    }\n    return Object.keys(keySet).map((it) => parseInt(it, 10));\n  } else if (segmentation.type === SegmentationRepresentations.Contour) {\n    const annotationUIDsMap =\n      segmentation.representationData.CONTOUR?.annotationUIDsMap;\n\n    const indices = new Set(annotationUIDsMap.keys());\n    const geometryIds = segmentation.representationData.CONTOUR?.geometryIds;\n\n    if (!geometryIds) {\n      throw new Error(\n        `No geometryIds found for segmentationId ${segmentationId}`\n      );\n    }\n\n    geometryIds.forEach((geometryId) => {\n      const geometry = cache.getGeometry(geometryId) as Types.IGeometry;\n      indices.add((geometry.data as Types.IContourSet).getSegmentIndex());\n    });\n\n    return Array.from(indices.values()).sort();\n  }\n}\n\n/**\n * Set the visibility of a segmentation representation for a given tool group. It fires\n * a SEGMENTATION_REPRESENTATION_MODIFIED event. Visibility true will show all segments\n * and visibility false will hide all segments\"\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n * @param toolGroupId - The Id of the tool group that contains the segmentation.\n * @param segmentationRepresentationUID - The id of the segmentation representation to modify its visibility.\n * @param visibility - boolean\n */\nfunction setSegmentationVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  visibility: boolean\n): void {\n  const toolGroupSegmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  if (!toolGroupSegmentationRepresentations) {\n    return;\n  }\n\n  const representation = toolGroupSegmentationRepresentations.find(\n    (representation: ToolGroupSpecificRepresentation) =>\n      representation.segmentationRepresentationUID ===\n      segmentationRepresentationUID\n  );\n\n  if (!representation) {\n    return;\n  }\n\n  const { segmentsHidden, segmentationId } = representation;\n\n  const indices = getUniqueSegmentIndices(segmentationId);\n\n  // if visibility is set to be true, we need to remove all the segments\n  // from the segmentsHidden set, otherwise we need to add all the segments\n  // to the segmentsHidden set\n  if (visibility) {\n    segmentsHidden.clear();\n  } else {\n    indices.forEach((index) => {\n      segmentsHidden.add(index);\n    });\n  }\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    representation.segmentationRepresentationUID\n  );\n}\n\n/**\n * Get the visibility of a segmentation data for a given tool group.\n *\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The id of the segmentation data to get\n * @returns A boolean value that indicates whether the segmentation data is visible or\n * not on the toolGroup\n */\nfunction getSegmentationVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): boolean | undefined {\n  const toolGroupSegmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  const representation = toolGroupSegmentationRepresentations.find(\n    (representation: ToolGroupSpecificRepresentation) =>\n      representation.segmentationRepresentationUID ===\n      segmentationRepresentationUID\n  );\n\n  if (!representation) {\n    return;\n  }\n\n  const { segmentsHidden, segmentationId } = representation;\n  const indices = getUniqueSegmentIndices(segmentationId);\n\n  // Create a set that contains all segments indices\n  const indicesSet = new Set(indices);\n\n  // Remove a indices that are hidden\n  segmentsHidden.forEach((segmentIndex) => indicesSet.delete(segmentIndex));\n\n  // Check if there is at least one segment visible\n  return !!indicesSet.size;\n}\n\n/**\n * Set the visibility of the given segment indices to the given visibility. This\n * is a helper to set the visibility of multiple segments at once and reduces\n * the number of events fired.\n *\n * @param toolGroupId -  The tool group id of the segmentation representation.\n * @param segmentationRepresentationUID -  The UID of the segmentation\n * representation.\n * @param segmentIndices -  The indices of the segments to be hidden/shown.\n * @param visibility -  The visibility to set the segments to.\n *\n */\nfunction setSegmentsVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndices: number[],\n  visibility: boolean\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    return;\n  }\n\n  segmentIndices.forEach((segmentIndex) => {\n    visibility\n      ? segRepresentation.segmentsHidden.delete(segmentIndex)\n      : segRepresentation.segmentsHidden.add(segmentIndex);\n  });\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * @param toolGroupId - The Id of the tool group that contains the segmentation\n * @param segmentationRepresentationUID - The id of the segmentation representation that contains the segment\n * @param segmentIndex - Index of the segment that will be updated\n * @param visibility - True to show the segment or false to hide it\n * @returns True if the segment is visible or false otherwise\n */\nfunction setSegmentVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number,\n  visibility: boolean\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    return;\n  }\n\n  visibility\n    ? segRepresentation.segmentsHidden.delete(segmentIndex)\n    : segRepresentation.segmentsHidden.add(segmentIndex);\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * @param toolGroupId - The Id of the tool group that contains the segmentation.\n * @param segmentationRepresentationUID - The id of the segmentation representation to modify its visibility.\n * @param segmentIndex - Index of the segment\n * @returns True if the segment is visible or false otherwise\n */\nfunction getSegmentVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): boolean {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    return false;\n  }\n\n  return !segRepresentation.segmentsHidden.has(segmentIndex);\n}\n\nexport {\n  setSegmentationVisibility,\n  getSegmentationVisibility,\n  setSegmentVisibility,\n  setSegmentsVisibility,\n  getSegmentVisibility,\n};\n","import {\n  StackViewport,\n  utilities,\n  BaseVolumeViewport,\n  VideoViewport,\n} from '@cornerstonejs/core';\nimport { Types } from '@cornerstonejs/core';\nimport ToolModes from '../../enums/ToolModes';\nimport StrategyCallbacks from '../../enums/StrategyCallbacks';\nimport { InteractionTypes, ToolProps, PublicToolProps } from '../../types';\n\nexport interface IBaseTool {\n  /** ToolGroup ID the tool instance belongs to */\n  toolGroupId: string;\n  /** Tool supported interaction types */\n  supportedInteractionTypes: InteractionTypes[];\n  /** Tool Mode : Active, Passive, Enabled, Disabled */\n  mode: ToolModes;\n  /** Tool Configuration */\n  configuration: {\n    preventHandleOutsideImage?: boolean;\n    strategies?: Record<string, any>;\n    defaultStrategy?: string;\n    activeStrategy?: string;\n    strategyOptions?: Record<string, unknown>;\n  };\n}\n\n/**\n * Abstract base class from which all tools derive.\n * Deals with cleanly merging custom and default configuration, and strategy\n * application.\n */\nabstract class BaseTool implements IBaseTool {\n  static toolName;\n  /** Supported Interaction Types - currently only Mouse */\n  public supportedInteractionTypes: InteractionTypes[];\n  public configuration: Record<string, any>;\n  /** ToolGroup ID the tool instance belongs to */\n  public toolGroupId: string;\n  /** Tool Mode - Active/Passive/Enabled/Disabled/ */\n  public mode: ToolModes;\n\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    const initialProps = utilities.deepMerge(defaultToolProps, toolProps);\n\n    const {\n      configuration = {},\n      supportedInteractionTypes,\n      toolGroupId,\n    } = initialProps;\n\n    // If strategies are not initialized in the tool config\n    if (!configuration.strategies) {\n      configuration.strategies = {};\n      configuration.defaultStrategy = undefined;\n      configuration.activeStrategy = undefined;\n      configuration.strategyOptions = {};\n    }\n\n    this.toolGroupId = toolGroupId;\n    this.supportedInteractionTypes = supportedInteractionTypes || [];\n    this.configuration = Object.assign({}, configuration);\n    this.mode = ToolModes.Disabled;\n  }\n\n  /**\n   * Returns the name of the tool\n   * @returns The name of the tool.\n   */\n  public getToolName(): string {\n    // Since toolName is static we get it from the class constructor\n    return (<typeof BaseTool>this.constructor).toolName;\n  }\n\n  /**\n   * Applies the active strategy function to the enabled element with the specified\n   * operation data.\n   * @param enabledElement - The element that is being operated on.\n   * @param operationData - The data that needs to be passed to the strategy.\n   * @returns The result of the strategy.\n   */\n  public applyActiveStrategy(\n    enabledElement: Types.IEnabledElement,\n    operationData: unknown\n  ): any {\n    const { strategies, activeStrategy } = this.configuration;\n    return strategies[activeStrategy]?.call(\n      this,\n      enabledElement,\n      operationData\n    );\n  }\n\n  /**\n   * Applies the active strategy, with a given event type being applied.\n   * The event type function is found by indexing it on the active strategy\n   * function.\n   *\n   * @param enabledElement - The element that is being operated on.\n   * @param operationData - The data that needs to be passed to the strategy.\n   * @param callbackType - the type of the callback\n   *\n   * @returns The result of the strategy.\n   */\n  public applyActiveStrategyCallback(\n    enabledElement: Types.IEnabledElement,\n    operationData: unknown,\n    callbackType: StrategyCallbacks | string\n  ): any {\n    const { strategies, activeStrategy } = this.configuration;\n    return strategies[activeStrategy][callbackType]?.call(\n      this,\n      enabledElement,\n      operationData\n    );\n  }\n\n  /**\n   * merges the new configuration with the tool configuration\n   * @param configuration - toolConfiguration\n   */\n  public setConfiguration(newConfiguration: Record<string, any>): void {\n    this.configuration = utilities.deepMerge(\n      this.configuration,\n      newConfiguration\n    );\n  }\n\n  /**\n   * Sets the active strategy for a tool. Strategies are\n   * multiple implementations of tool behavior that can be switched by tool\n   * configuration.\n   *\n   * @param strategyName - name of the strategy to be set as active\n   */\n  public setActiveStrategy(strategyName: string): void {\n    this.setConfiguration({ activeStrategy: strategyName });\n  }\n\n  /**\n   * Returns the volumeId for the volume viewport. It will grabbed the volumeId\n   * from the volumeId if particularly specified in the tool configuration, or if\n   * not, the first actorUID in the viewport is returned as the volumeId. NOTE: for\n   * segmentations, actorUID is not necessarily the volumeId since the segmentation\n   * can have multiple representations, use segmentation helpers to get the volumeId\n   * based on the actorUID.\n   *\n   * @param viewport - Volume viewport\n   * @returns the volumeId for the viewport if specified in the tool configuration,\n   * or the first actorUID in the viewport if not.\n   */\n  private getTargetVolumeId(viewport: Types.IViewport): string | undefined {\n    if (this.configuration.volumeId) {\n      return this.configuration.volumeId;\n    }\n\n    // If volume not specified, then return the actorUID for the\n    // default actor - first actor\n    const actorEntries = viewport.getActors();\n\n    if (!actorEntries) {\n      return;\n    }\n\n    // find the first image actor of instance type vtkVolume\n    return actorEntries.find(\n      (actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume'\n    )?.uid;\n  }\n\n  /**\n   * Get the image that is displayed for the targetId in the cachedStats\n   * which can be\n   * * imageId:<imageId>\n   * * volumeId:<volumeId>\n   * * videoId:<basePathForVideo>/frames/<frameSpecifier>\n   *\n   * @param targetId - annotation targetId stored in the cached stats\n   * @param renderingEngine - The rendering engine\n   * @returns The image data for the target.\n   */\n  protected getTargetIdImage(\n    targetId: string,\n    renderingEngine: Types.IRenderingEngine\n  ): Types.IImageData | Types.CPUIImageData | Types.IImageVolume {\n    if (targetId.startsWith('imageId:')) {\n      const imageId = targetId.split('imageId:')[1];\n      const imageURI = utilities.imageIdToURI(imageId);\n      let viewports = utilities.getViewportsWithImageURI(\n        imageURI,\n        renderingEngine.id\n      );\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      viewports = viewports.filter((viewport) => {\n        return viewport.getCurrentImageId() === imageId;\n      });\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      return viewports[0].getImageData();\n    } else if (targetId.startsWith('volumeId:')) {\n      const volumeId = targetId.split('volumeId:')[1];\n      const viewports = utilities.getViewportsWithVolumeId(\n        volumeId,\n        renderingEngine.id\n      );\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      return viewports[0].getImageData();\n    } else if (targetId.startsWith('videoId:')) {\n      // Video id can be multi-valued for the frame information\n      const imageURI = utilities.imageIdToURI(targetId);\n      const viewports = utilities.getViewportsWithImageURI(\n        imageURI,\n        renderingEngine.id\n      );\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      return viewports[0].getImageData();\n    } else {\n      throw new Error(\n        'getTargetIdImage: targetId must start with \"imageId:\" or \"volumeId:\"'\n      );\n    }\n  }\n\n  /**\n   * Get the target Id for the viewport which will be used to store the cached\n   * statistics scoped to that target in the annotations.\n   * For StackViewport, targetId is the viewportId, but for the volume viewport,\n   * the targetId will be grabbed from the volumeId if particularly specified\n   * in the tool configuration, or if not, the first actorUID in the viewport.\n   *\n   * @param viewport - viewport to get the targetId for\n   * @returns targetId\n   */\n  protected getTargetId(viewport: Types.IViewport): string | undefined {\n    if (viewport instanceof StackViewport) {\n      return `imageId:${viewport.getCurrentImageId()}`;\n    } else if (viewport instanceof BaseVolumeViewport) {\n      return `volumeId:${this.getTargetVolumeId(viewport)}`;\n    } else if (viewport instanceof VideoViewport) {\n      return `videoId:${viewport.getCurrentImageId()}`;\n    } else {\n      throw new Error(\n        'getTargetId: viewport must be a StackViewport or VolumeViewport'\n      );\n    }\n  }\n}\n\n// Note: this is a workaround since terser plugin does not support static blocks\n// yet and we can't easily say static toolName = \"BaseTool\" in the class definition.\nBaseTool.toolName = 'BaseTool';\nexport default BaseTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Remove the surface representation from the viewport's HTML Element.\n * NOTE: This function should not be called directly.\n *\n * @param element - The element that the segmentation is being added to.\n * @param segmentationRepresentationUID - The UID of the surface representation to remove.\n * @param removeFromCache - boolean\n *\n * @internal\n */\nfunction removeContourFromElement(\n  element: HTMLDivElement,\n  segmentationRepresentationUID: string,\n  removeFromCache = false // Todo\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const actorEntries = (viewport as Types.IVolumeViewport).getActors();\n\n  // remove actors whose id has the same prefix as the segmentationRepresentationUID\n  const actorUIDsToRemove = actorEntries\n    .map(({ uid }) =>\n      uid.startsWith(segmentationRepresentationUID) ? uid : undefined\n    )\n    .filter(Boolean);\n\n  // @ts-ignore\n  viewport.removeActors(actorUIDsToRemove);\n}\n\nexport default removeContourFromElement;\n","export function pointToString(point, decimals = 5) {\n  return (\n    parseFloat(point[0]).toFixed(decimals) +\n    ',' +\n    parseFloat(point[1]).toFixed(decimals) +\n    ',' +\n    parseFloat(point[2]).toFixed(decimals) +\n    ','\n  );\n}\n","import {\n  getEnabledElement,\n  Enums,\n  VolumeViewport3D,\n} from '@cornerstonejs/core';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkClipClosedSurface from '@kitware/vtk.js/Filters/General/ClipClosedSurface';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport { pointToString } from '../../../utilities/pointToString';\n\nconst polyDataCache = new Map();\n\nfunction addSurfaceToElement(\n  element: HTMLDivElement,\n  surface: any,\n  actorUID: string\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  // Default to true since we are setting a new segmentation, however,\n  // in the event listener, we will make other segmentations visible/invisible\n  // based on the config\n  const points = surface.getPoints();\n  const polys = surface.getPolys();\n  const color = surface.getColor();\n\n  const polyData = vtkPolyData.newInstance();\n  polyData.getPoints().setData(points, 3);\n\n  const triangles = vtkCellArray.newInstance({\n    values: Float32Array.from(polys),\n  });\n  polyData.setPolys(triangles);\n\n  const mapper = vtkMapper.newInstance({});\n  let clippingFilter;\n  if (!(viewport instanceof VolumeViewport3D)) {\n    clippingFilter = vtkClipClosedSurface.newInstance({\n      clippingPlanes: [],\n      activePlaneId: 2,\n      passPointData: false,\n    });\n    clippingFilter.setInputData(polyData);\n    clippingFilter.setGenerateOutline(true);\n    clippingFilter.setGenerateFaces(false);\n    clippingFilter.update();\n    const filteredData = clippingFilter.getOutputData();\n    mapper.setInputData(filteredData);\n  } else {\n    mapper.setInputData(polyData);\n  }\n\n  const actor = vtkActor.newInstance();\n  actor.setMapper(mapper);\n\n  // sets the color of the surface actor\n  actor.getProperty().setColor(color[0] / 255, color[1] / 255, color[2] / 255);\n  viewport.addActor({\n    actor,\n    uid: actorUID,\n    clippingFilter,\n  });\n\n  element.addEventListener(\n    Enums.Events.CLIPPING_PLANES_UPDATED,\n    updateSurfacePlanes\n  );\n}\n\n/**\n * Updates the clipping planes of a surface and caches the resulting poly data\n * @param evt\n */\nfunction updateSurfacePlanes(evt) {\n  const { actorEntry, vtkPlanes, viewport } = evt.detail;\n  if (!actorEntry?.clippingFilter) {\n    return;\n  }\n\n  const mapper = actorEntry.actor.getMapper();\n\n  const { viewPlaneNormal } = viewport.getCamera();\n  const imageIndex = viewport.getCurrentImageIdIndex();\n\n  // we should not use the focalPoint here, since the pan and zoom updates it,\n  // imageIndex is reliable enough\n  const cacheId = `${viewport.id}-${pointToString(\n    viewPlaneNormal\n  )}-${imageIndex}`;\n\n  let actorCache = polyDataCache.get(actorEntry.uid);\n  if (!actorCache) {\n    actorCache = new Map();\n    polyDataCache.set(actorEntry.uid, actorCache);\n  }\n\n  let polyData = actorCache.get(cacheId);\n  if (!polyData) {\n    const clippingFilter = actorEntry.clippingFilter;\n    clippingFilter.setClippingPlanes(vtkPlanes);\n    try {\n      clippingFilter.update();\n      polyData = clippingFilter.getOutputData();\n      actorCache.set(cacheId, polyData);\n    } catch (e) {\n      console.error('Error clipping surface', e);\n    }\n  }\n  mapper.setInputData(polyData);\n}\n\nexport default addSurfaceToElement;\n","import {\n  cache,\n  getEnabledElementByIds,\n  Types,\n  Enums,\n} from '@cornerstonejs/core';\n\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../../types/SegmentationStateTypes';\n\nimport removeSurfaceFromElement from './removeSurfaceFromElement';\nimport addSurfaceToElement from './addSurfaceToElement';\n\n/**\n * It removes a segmentation representation from the tool group's viewports and\n * from the segmentation state\n * @param toolGroupId - The toolGroupId of the toolGroup that the\n * segmentationRepresentation belongs to.\n * @param segmentationRepresentationUID - This is the unique identifier\n * for the segmentation representation.\n * @param renderImmediate - If true, the viewport will be rendered\n * immediately after the segmentation representation is removed.\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  renderImmediate = false\n): void {\n  _removeSurfaceFromToolGroupViewports(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n  SegmentationState.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  if (renderImmediate) {\n    const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      enabledElement.viewport.render();\n    });\n  }\n}\n\n/**\n * It renders the Surface  for the given segmentation\n * @param viewport - The viewport object\n * @param representation - ToolGroupSpecificRepresentation\n * @param toolGroupConfig - This is the configuration object for the tool group\n */\nasync function render(\n  viewport: Types.IVolumeViewport,\n  representation: ToolGroupSpecificRepresentation,\n  toolGroupConfig: SegmentationRepresentationConfig\n): Promise<void> {\n  const {\n    colorLUTIndex,\n    active,\n    segmentationId,\n    segmentationRepresentationUID,\n    segmentsHidden,\n  } = representation;\n\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n  const SurfaceData = segmentation.representationData[Representations.Surface];\n  const { geometryId } = SurfaceData;\n\n  if (!geometryId) {\n    console.warn(\n      `No Surfaces found for segmentationId ${segmentationId}. Skipping render.`\n    );\n  }\n\n  const geometry = cache.getGeometry(geometryId);\n  if (!geometry) {\n    throw new Error(`No Surfaces found for geometryId ${geometryId}`);\n  }\n\n  if (geometry.type !== Enums.GeometryType.SURFACE) {\n    // Todo: later we can support converting other geometries to Surfaces\n    throw new Error(\n      `Geometry type ${geometry.type} not supported for rendering.`\n    );\n  }\n\n  if (!geometry.data) {\n    console.warn(\n      `No Surfaces found for geometryId ${geometryId}. Skipping render.`\n    );\n    return;\n  }\n\n  const surface = geometry.data;\n\n  const surfaceUID = `${segmentationRepresentationUID}_${surface.id}}`;\n  _renderSurface(viewport, surface, surfaceUID);\n\n  viewport.resetCamera();\n  viewport.render();\n}\n\nfunction _renderSurface(\n  viewport: Types.IVolumeViewport,\n  surface: any,\n  surfaceUID: string\n): void {\n  const actorUID = surfaceUID;\n  const actorEntry = viewport.getActor(actorUID);\n\n  if (!actorEntry) {\n    addSurfaceToElement(viewport.element, surface, actorUID);\n  } else {\n    throw new Error('Not implemented yet. (Update surface)');\n  }\n}\n\nfunction _removeSurfaceFromToolGroupViewports(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);\n  }\n\n  const { viewportsInfo } = toolGroup;\n\n  for (const viewportInfo of viewportsInfo) {\n    const { viewportId, renderingEngineId } = viewportInfo;\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    removeSurfaceFromElement(\n      enabledElement.viewport.element,\n      segmentationRepresentationUID\n    );\n  }\n}\n\nexport default {\n  render,\n  removeSegmentationRepresentation,\n};\n","import { Enums, Types } from '@cornerstonejs/core';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport vtkPoints from '@kitware/vtk.js/Common/Core/Points';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport { ToolGroupSpecificContourRepresentation } from '../../../types';\n\n/**\n * If the segment specific config exists for the given segment id, it returns\n * the segment specific config. Otherwise, it looks for the segment specific\n * config for the given index. If it doesn't exist, it returns null.\n *\n * @param contourRepresentation -  The representation object that is passed\n * to the tool.\n * @param segmentId -  The id of the segment.\n * @param index -  The index of the segment in the list of segments.\n * @returns the segment specific config for the given segment id.\n *\n */\nexport function getSegmentSpecificConfig(\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  segmentId: string,\n  index: number\n) {\n  let segmentSpecificConfig =\n    contourRepresentation.segmentSpecificConfig?.[segmentId];\n\n  if (!segmentSpecificConfig) {\n    // try the index\n    segmentSpecificConfig =\n      contourRepresentation.segmentSpecificConfig?.[index];\n  }\n\n  if (!segmentSpecificConfig) {\n    return null;\n  }\n\n  return segmentSpecificConfig.CONTOUR;\n}\n\n/**\n * takes a geometry object as an argument\n * and throws an error if the geometry object is not a contour\n * @param geometry -  The geometry object to be rendered.\n */\nexport function validateGeometry(geometry: Types.IGeometry): void {\n  if (!geometry) {\n    throw new Error(`No contours found for geometryId ${geometry.id}`);\n  }\n\n  const geometryId = geometry.id;\n\n  if (geometry.type !== Enums.GeometryType.CONTOUR) {\n    throw new Error(\n      `Geometry type ${geometry.type} not supported for rendering.`\n    );\n  }\n\n  if (!geometry.data) {\n    console.warn(\n      `No contours found for geometryId ${geometryId}. Skipping render.`\n    );\n    return;\n  }\n}\n\n/**\n * It takes a contourSet and returns a vtkPolyData for that contourSet. A contour set\n * is a collection of contours. Each contour is a collection of points. Each point\n * is x,y,z in the world coordinate system.\n *\n * @param contourSet -  the contour set that you want to convert to polyData\n * @returns A vtkPolyData object\n */\nexport function getPolyData(contourSet: Types.IContourSet) {\n  const pointArray = [];\n\n  const points = vtkPoints.newInstance();\n  const lines = vtkCellArray.newInstance();\n\n  // this variable will indicate the index of the first point in the current line\n  // so we can correctly generate the point index list to add in the cellArray\n  let pointIndex = 0;\n  contourSet.getContours().forEach((contour: Types.IContour) => {\n    const pointList = contour.getPoints();\n    const flatPoints = contour.getFlatPointsArray();\n    const type = contour.getType();\n\n    // creating a point index list that defines a line\n    const pointIndexes = pointList.map(\n      (_, pointListIndex) => pointListIndex + pointIndex\n    );\n\n    // if close planar, add the first point index to the list\n    if (type === Enums.ContourType.CLOSED_PLANAR) {\n      pointIndexes.push(pointIndexes[0]);\n    }\n\n    const linePoints = Float32Array.from(flatPoints);\n    // add the current points into the point list\n    pointArray.push(...linePoints);\n    // add the point indexes into the cell array\n    lines.insertNextCell([...pointIndexes]);\n    // update the first point index\n    pointIndex = pointIndex + pointList.length;\n  });\n\n  // converts the pointArray into vtkPoints\n  points.setData(pointArray, 3);\n\n  // creates the polyData\n  const polygon = vtkPolyData.newInstance();\n  polygon.setPoints(points);\n  polygon.setLines(lines);\n\n  return polygon;\n}\n","type ConfigCache = {\n  segmentsHidden: Set<number>;\n  outlineWidthActive: number;\n  visibility: boolean;\n};\n\n/**\n * Config cache is used to store the config for a given segmentation\n * representation. This is used to avoid having to recompute the config\n * every time the user changes the active segment, and also for performance\n * reasons.\n */\nconst configCachePerSegmentationRepresentationUID = new Map();\n\nexport function getConfigCache(\n  segmentationRepresentationUID: string\n): ConfigCache {\n  return configCachePerSegmentationRepresentationUID.get(\n    segmentationRepresentationUID\n  );\n}\n\nexport function setConfigCache(\n  segmentationRepresentationUID: string,\n  config: ConfigCache\n) {\n  configCachePerSegmentationRepresentationUID.set(\n    segmentationRepresentationUID,\n    config\n  );\n}\n\nexport function deleteConfigCache(segmentationRepresentationUID: string) {\n  configCachePerSegmentationRepresentationUID.delete(\n    segmentationRepresentationUID\n  );\n}\n","import { cache, Types } from '@cornerstonejs/core';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkAppendPolyData from '@kitware/vtk.js/Filters/General/AppendPolyData';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\n\nimport {\n  getPolyData,\n  getSegmentSpecificConfig,\n  validateGeometry,\n} from './utils';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificContourRepresentation,\n} from '../../../types';\nimport { getConfigCache, setConfigCache } from './contourConfigCache';\n\nexport function addContourSetsToElement(\n  viewport: Types.IVolumeViewport,\n  geometryIds: string[],\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  contourRepresentationConfig: SegmentationRepresentationConfig,\n  contourActorUID: string\n) {\n  const { segmentationRepresentationUID, segmentsHidden } =\n    contourRepresentation;\n  const appendPolyData = vtkAppendPolyData.newInstance();\n\n  const scalarToColorMap = new Map();\n  const segmentSpecificMap = new Map();\n\n  geometryIds.forEach((geometryId) => {\n    const geometry = cache.getGeometry(geometryId);\n\n    if (!geometry) {\n      console.warn(\n        `No geometry found for geometryId ${geometryId}. Skipping render.`\n      );\n      return;\n    }\n\n    const segmentIndex = (geometry.data as Types.IContourSet).getSegmentIndex();\n\n    validateGeometry(geometry);\n\n    const segmentSpecificConfig = getSegmentSpecificConfig(\n      contourRepresentation,\n      geometryId,\n      segmentIndex\n    );\n\n    const contourSet = geometry.data;\n    const polyData = getPolyData(contourSet as Types.IContourSet);\n    const color = contourSet.getColor();\n\n    const size = polyData.getPoints().getNumberOfPoints();\n\n    const scalars = vtkDataArray.newInstance({\n      size: size * 4,\n      numberOfComponents: 4,\n      dataType: 'Uint8Array',\n    });\n    for (let i = 0; i < size; ++i) {\n      scalars.setTuple(i, [...color, 255]);\n    }\n    polyData.getPointData().setScalars(scalars);\n\n    if (segmentSpecificConfig) {\n      segmentSpecificMap.set(segmentIndex, segmentSpecificConfig);\n    }\n\n    scalarToColorMap.set(segmentIndex, [\n      ...color,\n      segmentsHidden.has(segmentIndex) ? 0 : 255,\n    ]);\n\n    segmentIndex === 0\n      ? appendPolyData.setInputData(polyData)\n      : appendPolyData.addInputData(polyData);\n  });\n\n  const polyDataOutput = appendPolyData.getOutputData();\n\n  const outlineWidthActive =\n    contourRepresentationConfig.representations.CONTOUR.outlineWidthActive;\n\n  const mapper = vtkMapper.newInstance();\n  mapper.setInputData(polyDataOutput);\n\n  const actor = vtkActor.newInstance();\n  actor.setMapper(mapper);\n  actor.getProperty().setLineWidth(outlineWidthActive);\n\n  // set the config cache for later update of the contour\n  setConfigCache(\n    segmentationRepresentationUID,\n    Object.assign({}, getConfigCache(segmentationRepresentationUID), {\n      segmentsHidden: new Set(segmentsHidden),\n      segmentSpecificMap,\n      outlineWidthActive,\n    })\n  );\n\n  actor.setForceOpaque(true);\n\n  viewport.addActor({\n    uid: contourActorUID,\n    actor: actor as unknown as Types.Actor,\n  });\n  viewport.resetCamera();\n  viewport.render();\n}\n","import { cache, Types } from '@cornerstonejs/core';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificContourRepresentation,\n} from '../../../types';\nimport { getConfigCache, setConfigCache } from './contourConfigCache';\nimport { getSegmentSpecificConfig } from './utils';\n\nexport function updateContourSets(\n  viewport: Types.IVolumeViewport,\n  geometryIds: string[],\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  contourRepresentationConfig: SegmentationRepresentationConfig,\n  contourActorUID: string\n) {\n  const { segmentationRepresentationUID, segmentsHidden } =\n    contourRepresentation;\n  const newContourConfig = contourRepresentationConfig.representations.CONTOUR;\n  const cachedConfig = getConfigCache(segmentationRepresentationUID);\n\n  const contourSetsActor = viewport.getActor(contourActorUID);\n\n  if (!contourSetsActor) {\n    console.warn(\n      `No contour actor found for actorUID ${contourActorUID}. Skipping render.`\n    );\n    return;\n  }\n\n  const { actor } = contourSetsActor;\n\n  const newOutlineWithActive = newContourConfig.outlineWidthActive;\n\n  if (cachedConfig?.outlineWidthActive !== newOutlineWithActive) {\n    (actor as unknown as vtkActor)\n      .getProperty()\n      .setLineWidth(newOutlineWithActive);\n\n    setConfigCache(\n      segmentationRepresentationUID,\n      Object.assign({}, cachedConfig, {\n        outlineWidthActive: newOutlineWithActive,\n      })\n    );\n  }\n\n  const mapper = (actor as unknown as vtkActor).getMapper();\n  const lut = mapper.getLookupTable();\n\n  const segmentsToSetToInvisible = [];\n  const segmentsToSetToVisible = [];\n\n  for (const segmentIndex of segmentsHidden) {\n    if (!cachedConfig.segmentsHidden.has(segmentIndex)) {\n      segmentsToSetToInvisible.push(segmentIndex);\n    }\n  }\n\n  // the other way around\n  for (const segmentIndex of cachedConfig.segmentsHidden) {\n    if (!segmentsHidden.has(segmentIndex)) {\n      segmentsToSetToVisible.push(segmentIndex);\n    }\n  }\n\n  const mergedInvisibleSegments = Array.from(cachedConfig.segmentsHidden)\n    .filter((segmentIndex) => !segmentsToSetToVisible.includes(segmentIndex))\n    .concat(segmentsToSetToInvisible);\n\n  const { contourSets, segmentSpecificConfigs } = geometryIds.reduce(\n    (acc, geometryId) => {\n      const geometry = cache.getGeometry(geometryId);\n      const { data: contourSet } = geometry;\n      const segmentIndex = (contourSet as Types.IContourSet).getSegmentIndex();\n      const segmentSpecificConfig = getSegmentSpecificConfig(\n        contourRepresentation,\n        geometryId,\n        segmentIndex\n      );\n\n      acc.contourSets.push(contourSet);\n      acc.segmentSpecificConfigs[segmentIndex] = segmentSpecificConfig ?? {};\n\n      return acc;\n    },\n    { contourSets: [], segmentSpecificConfigs: {} }\n  );\n\n  const affectedSegments = [\n    ...mergedInvisibleSegments,\n    ...segmentsToSetToVisible,\n  ];\n\n  const hasCustomSegmentSpecificConfig = Object.values(\n    segmentSpecificConfigs\n  ).some((config) => Object.keys(config).length > 0);\n\n  let polyDataModified = false;\n\n  if (affectedSegments.length || hasCustomSegmentSpecificConfig) {\n    const appendPolyData = mapper.getInputData();\n    const appendScalars = appendPolyData.getPointData().getScalars();\n    const appendScalarsData = appendScalars.getData();\n    // below we will only manipulate the polyData of the contourSets that are affected\n    // by picking the correct offset in the scalarData array\n    let offset = 0;\n    contourSets.forEach((contourSet) => {\n      const segmentIndex = (contourSet as Types.IContourSet).getSegmentIndex();\n      const size = contourSet.getTotalNumberOfPoints();\n\n      if (\n        affectedSegments.includes(segmentIndex) ||\n        segmentSpecificConfigs[segmentIndex]?.fillAlpha // Todo: add others\n      ) {\n        const color = contourSet.getColor();\n        let visibility = mergedInvisibleSegments.includes(segmentIndex)\n          ? 0\n          : 255;\n\n        const segmentConfig = segmentSpecificConfigs[segmentIndex];\n        if (segmentConfig.fillAlpha !== undefined) {\n          visibility = segmentConfig.fillAlpha * 255;\n        }\n\n        for (let i = 0; i < size; ++i) {\n          appendScalarsData[offset + i * 4] = color[0];\n          appendScalarsData[offset + i * 4 + 1] = color[1];\n          appendScalarsData[offset + i * 4 + 2] = color[2];\n          appendScalarsData[offset + i * 4 + 3] = visibility;\n        }\n\n        polyDataModified = true;\n      }\n\n      offset = offset + size * 4;\n    });\n\n    if (polyDataModified) {\n      appendPolyData.modified();\n    }\n\n    setConfigCache(\n      segmentationRepresentationUID,\n      Object.assign({}, cachedConfig, {\n        segmentsHidden: new Set(segmentsHidden),\n      })\n    );\n\n    mapper.setLookupTable(lut);\n  }\n\n  viewport.render();\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Remove the contour representation from the viewport's HTML Element.\n * NOTE: This function should not be called directly.\n *\n * @param element - The element that the segmentation is being added to.\n * @param segmentationRepresentationUID - The UID of the contour representation to remove.\n * @param removeFromCache - boolean\n *\n * @internal\n */\nfunction removeContourFromElement(\n  element: HTMLDivElement,\n  segmentationRepresentationUID: string,\n  removeFromCache = false // Todo\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const actorEntries = (viewport as Types.IVolumeViewport).getActors();\n\n  // remove actors whose id has the same prefix as the segmentationRepresentationUID\n  const actorUIDsToRemove = actorEntries\n    .map(({ uid }) =>\n      uid.includes(segmentationRepresentationUID) ? uid : undefined\n    )\n    .filter(Boolean);\n\n  // @ts-ignore\n  viewport.removeActors(actorUIDsToRemove);\n}\n\nexport default removeContourFromElement;\n","import {\n  getEnabledElementByIds,\n  Types,\n  StackViewport,\n} from '@cornerstonejs/core';\n\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../../types/SegmentationStateTypes';\nimport { addOrUpdateContourSets } from './addOrUpdateContourSets';\nimport removeContourFromElement from './removeContourFromElement';\nimport { deleteConfigCache } from './contourConfigCache';\n\n/**\n * It removes a segmentation representation from the tool group's viewports and\n * from the segmentation state\n * @param toolGroupId - The toolGroupId of the toolGroup that the\n * segmentationRepresentation belongs to.\n * @param segmentationRepresentationUID - This is the unique identifier\n * for the segmentation representation.\n * @param renderImmediate - If true, the viewport will be rendered\n * immediately after the segmentation representation is removed.\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  renderImmediate = false\n): void {\n  _removeContourFromToolGroupViewports(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n  SegmentationState.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  deleteConfigCache(segmentationRepresentationUID);\n\n  if (renderImmediate) {\n    const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      enabledElement.viewport.render();\n    });\n  }\n}\n\n/**\n * It renders the contour sets for the given segmentation\n * @param viewport - The viewport object\n * @param representation - ToolGroupSpecificRepresentation\n * @param toolGroupConfig - This is the configuration object for the tool group\n */\nasync function render(\n  viewport: Types.IVolumeViewport,\n  representationConfig: ToolGroupSpecificRepresentation,\n  toolGroupConfig: SegmentationRepresentationConfig\n): Promise<void> {\n  const { segmentationId } = representationConfig;\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n  const contourData = segmentation.representationData[Representations.Contour];\n  const { geometryIds } = contourData;\n\n  // We don't have a good way to handle stack viewports for contours at the moment.\n  // Plus, if we add a segmentation to one viewport, it gets added to all the viewports in the toolGroup too.\n  if (viewport instanceof StackViewport) {\n    return;\n  }\n\n  if (!geometryIds?.length) {\n    console.warn(\n      `No contours found for segmentationId ${segmentationId}. Skipping render.`\n    );\n    return;\n  }\n\n  // add the contour sets to the viewport\n  addOrUpdateContourSets(\n    viewport,\n    geometryIds,\n    representationConfig,\n    toolGroupConfig\n  );\n}\n\nfunction _removeContourFromToolGroupViewports(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);\n  }\n\n  const { viewportsInfo } = toolGroup;\n\n  for (const viewportInfo of viewportsInfo) {\n    const { viewportId, renderingEngineId } = viewportInfo;\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    removeContourFromElement(\n      enabledElement.viewport.element,\n      segmentationRepresentationUID\n    );\n  }\n}\n\nexport default {\n  render,\n  removeSegmentationRepresentation,\n};\n","import { Types } from '@cornerstonejs/core';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificContourRepresentation,\n} from '../../../types';\nimport { addContourSetsToElement } from './addContourSetsToElement';\nimport { updateContourSets } from './updateContourSets';\n\nexport function addOrUpdateContourSets(\n  viewport: Types.IVolumeViewport,\n  geometryIds: string[],\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  contourRepresentationConfig: SegmentationRepresentationConfig\n) {\n  const { segmentationRepresentationUID } = contourRepresentation;\n  const actorUID = `CONTOUR_${segmentationRepresentationUID}`;\n  const actor = viewport.getActor(actorUID);\n\n  const addOrUpdateFn = actor ? updateContourSets : addContourSetsToElement;\n  addOrUpdateFn(\n    viewport,\n    geometryIds,\n    contourRepresentation,\n    contourRepresentationConfig,\n    actorUID\n  );\n}\n","import {\n  getEnabledElement,\n  addVolumesToViewports,\n  addImageSlicesToViewports,\n  Types,\n  Enums,\n} from '@cornerstonejs/core';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataStack,\n} from '../../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../segmentation/strategies/utils/stackVolumeCheck';\n/**\n * It adds a labelmap segmentation representation of the viewport's HTML Element.\n * NOTE: This function should not be called directly.\n *\n * @param element - The element that will be rendered.\n * @param volumeId - The volume id of the labelmap.\n * @param segmentationRepresentationUID - The segmentation representation UID.\n *\n * @internal\n */\nasync function addLabelmapToElement(\n  element: HTMLDivElement,\n  labelMapData: LabelmapSegmentationData,\n  segmentationRepresentationUID: string\n): Promise<void> {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n  const { id: viewportId } = viewport;\n\n  // Default to true since we are setting a new segmentation, however,\n  // in the event listener, we will make other segmentations visible/invisible\n  // based on the config\n  const visibility = true;\n  const immediateRender = false;\n  const suppressEvents = true;\n\n  if (isVolumeSegmentation(labelMapData)) {\n    // Todo: Right now we use MIP blend mode for the labelmap, since the\n    // composite blend mode has a non linear behavior regarding fill and line\n    // opacity. This should be changed to a custom labelmap blendMode which does\n    // what composite does, but with a linear behavior.\n    const volumeInputs: Types.IVolumeInput[] = [\n      {\n        volumeId: labelMapData.volumeId,\n        actorUID: segmentationRepresentationUID,\n        visibility,\n        blendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n      },\n    ];\n\n    // Add labelmap volumes to the viewports to be be rendered, but not force the render\n    await addVolumesToViewports(\n      renderingEngine,\n      volumeInputs,\n      [viewportId],\n      immediateRender,\n      suppressEvents\n    );\n  } else {\n    // We can use the current imageId in the viewport to get the segmentation imageId\n    // which later is used to create the actor and mapper.\n    const segmentationImageId = (\n      labelMapData as LabelmapSegmentationDataStack\n    ).imageIdReferenceMap.get(viewport.getCurrentImageId());\n\n    const stackInputs: Types.IStackInput[] = [\n      {\n        imageId: segmentationImageId,\n        actorUID: segmentationRepresentationUID,\n      },\n    ];\n\n    // Add labelmap volumes to the viewports to be be rendered, but not force the render\n    await addImageSlicesToViewports(\n      renderingEngine,\n      stackInputs,\n      [viewportId],\n      immediateRender,\n      suppressEvents\n    );\n  }\n}\n\nexport default addLabelmapToElement;\n","import { StackViewport, getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Remove the labelmap segmentation representation from the viewport's HTML Element.\n * NOTE: This function should not be called directly.\n *\n * @param element - The element that the segmentation is being added to.\n * @param segmentationRepresentationUID - The UID of the labelmap representation to remove.\n * @param removeFromCache - boolean\n *\n * @internal\n */\nfunction removeLabelmapFromElement(\n  element: HTMLDivElement,\n  segmentationRepresentationUID: string,\n  removeFromCache = false // Todo\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  if (viewport instanceof StackViewport) {\n    // Todo: we don't have stack segmentation yet\n    return;\n  }\n\n  (viewport as Types.IVolumeViewport).removeVolumeActors([\n    segmentationRepresentationUID,\n  ]);\n}\n\nexport default removeLabelmapFromElement;\n","import vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nimport vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\n\nimport {\n  cache,\n  getEnabledElementByIds,\n  StackViewport,\n  Types,\n  VolumeViewport,\n} from '@cornerstonejs/core';\n\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\nimport type {\n  LabelmapConfig,\n  LabelmapRenderingConfig,\n  LabelmapSegmentationData,\n} from '../../../types/LabelmapTypes';\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../../types/SegmentationStateTypes';\n\nimport addLabelmapToElement from './addLabelmapToElement';\n\nimport removeLabelmapFromElement from './removeLabelmapFromElement';\nimport { isVolumeSegmentation } from '../../segmentation/strategies/utils/stackVolumeCheck';\n\nconst MAX_NUMBER_COLORS = 255;\nconst labelMapConfigCache = new Map();\n\nfunction getRepresentationRenderingConfig() {\n  const cfun = vtkColorTransferFunction.newInstance();\n  const ofun = vtkPiecewiseFunction.newInstance();\n  ofun.addPoint(0, 0);\n  return {\n    ofun,\n    cfun,\n  };\n}\n\n/**\n * For each viewport, and for each segmentation, set the segmentation for the viewport's enabled element\n * Initializes the global and viewport specific state for the segmentation in the\n * SegmentationStateManager.\n * @param toolGroup - the tool group that contains the viewports\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param renderImmediate - If true, there will be a render call after the labelmap is removed\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  renderImmediate = false\n): void {\n  _removeLabelmapFromToolGroupViewports(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n  SegmentationState.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  if (renderImmediate) {\n    const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      enabledElement.viewport.render();\n    });\n  }\n}\n\n/**\n * Checks if a segmentation data have the same frameOfReference as the series\n * displayed in a given viewport\n * @param viewport\n * @param referencedVolumeId volume id of the segmentation reference series\n * @returns\n */\nfunction isSameFrameOfReference(viewport, referencedVolumeId) {\n  // if the referencedVolumeId is not defined, we acted as before to not break\n  // applications as referencedVolumeId is inserted in this change\n  // Can modify that in the future commits\n  if (!referencedVolumeId) {\n    return true;\n  }\n  const defaultActor = viewport.getDefaultActor();\n  if (!defaultActor) {\n    return false;\n  }\n  const { uid: defaultActorUID } = defaultActor;\n  const volume = cache.getVolume(defaultActorUID);\n\n  if (volume) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    if (\n      referencedVolume &&\n      volume.metadata.FrameOfReferenceUID ===\n        referencedVolume.metadata.FrameOfReferenceUID\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * It takes the enabled element, the segmentation Id, and the configuration, and\n * it sets the segmentation for the enabled element as a labelmap\n * @param enabledElement - The cornerstone enabled element\n * @param segmentationId - The id of the segmentation to be rendered.\n * @param configuration - The configuration object for the labelmap.\n */\nasync function render(\n  viewport: Types.IVolumeViewport | Types.IStackViewport,\n  representation: ToolGroupSpecificRepresentation,\n  toolGroupConfig: SegmentationRepresentationConfig\n): Promise<void> {\n  const {\n    colorLUTIndex,\n    active,\n    segmentationId,\n    segmentationRepresentationUID,\n    segmentsHidden,\n    config: renderingConfig,\n  } = representation;\n\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    console.warn('No segmentation found for segmentationId: ', segmentationId);\n    return;\n  }\n\n  const labelmapData =\n    segmentation.representationData[Representations.Labelmap];\n\n  let actorEntry = viewport.getActor(segmentationRepresentationUID);\n  if (isVolumeSegmentation(labelmapData)) {\n    if (viewport instanceof StackViewport) {\n      return;\n    }\n\n    const { volumeId: labelmapUID } = labelmapData;\n\n    const labelmap = cache.getVolume(labelmapUID);\n\n    if (!labelmap) {\n      throw new Error(`No Labelmap found for volumeId: ${labelmapUID}`);\n    }\n\n    if (!isSameFrameOfReference(viewport, labelmapData?.referencedVolumeId)) {\n      return;\n    }\n\n    if (!actorEntry) {\n      // only add the labelmap to ToolGroup viewports if it is not already added\n      await _addLabelmapToViewport(\n        viewport,\n        labelmapData,\n        segmentationRepresentationUID\n      );\n    }\n\n    actorEntry = viewport.getActor(segmentationRepresentationUID);\n  } else {\n    if (viewport instanceof VolumeViewport) {\n      return;\n    }\n\n    // stack segmentation\n    const imageId = viewport.getCurrentImageId();\n    const { imageIdReferenceMap } = labelmapData;\n\n    // if the stack labelmap is not built for the current imageId that is\n    // rendered at the viewport then return\n    if (!imageIdReferenceMap.has(imageId)) {\n      return;\n    }\n\n    if (!actorEntry) {\n      // only add the labelmap to ToolGroup viewports if it is not already added\n      await _addLabelmapToViewport(\n        viewport,\n        labelmapData,\n        segmentationRepresentationUID\n      );\n    }\n\n    actorEntry = viewport.getActor(segmentationRepresentationUID);\n  }\n\n  if (!actorEntry) {\n    return;\n  }\n\n  const { cfun, ofun } = renderingConfig as LabelmapRenderingConfig;\n\n  const renderInactiveSegmentations =\n    toolGroupConfig.renderInactiveSegmentations;\n\n  _setLabelmapColorAndOpacity(\n    viewport.id,\n    actorEntry,\n    cfun,\n    ofun,\n    colorLUTIndex,\n    toolGroupConfig.representations[Representations.Labelmap],\n    representation,\n    active,\n    renderInactiveSegmentations,\n    segmentsHidden\n  );\n}\n\nfunction _setLabelmapColorAndOpacity(\n  viewportId: string,\n  actorEntry: Types.ActorEntry,\n  cfun: vtkColorTransferFunction,\n  ofun: vtkPiecewiseFunction,\n  colorLUTIndex: number,\n  toolGroupLabelmapConfig: LabelmapConfig,\n  segmentationRepresentation: ToolGroupSpecificRepresentation,\n  isActiveLabelmap: boolean,\n  renderInactiveSegmentations: boolean,\n  segmentsHidden: Set<number>\n): void {\n  const { segmentSpecificConfig, segmentationRepresentationSpecificConfig } =\n    segmentationRepresentation;\n\n  const segmentationRepresentationLabelmapConfig =\n    segmentationRepresentationSpecificConfig[Representations.Labelmap];\n\n  // Note: MAX_NUMBER_COLORS = 256 is needed because the current method to generate\n  // the default color table uses RGB.\n  const colorLUT = SegmentationState.getColorLUT(colorLUTIndex);\n  const numColors = Math.min(256, colorLUT.length);\n  const { uid: actorUID } = actorEntry;\n\n  // Note: right now outlineWidth and renderOutline are not configurable\n  // at the segment level, so we don't need to check for segment specific\n  // configuration in the loop, Todo: make them configurable at the segment level\n  const { outlineWidth, renderOutline, outlineOpacity } = _getLabelmapConfig(\n    toolGroupLabelmapConfig,\n    segmentationRepresentationLabelmapConfig,\n    isActiveLabelmap\n  );\n\n  // Todo: the below loop probably can be optimized so that we don't hit it\n  // unless a config has changed. Right now we get into the following loop\n  // even for brush drawing which does not makes sense\n  for (let i = 0; i < numColors; i++) {\n    const segmentIndex = i;\n    const segmentColor = colorLUT[segmentIndex];\n\n    const segmentSpecificLabelmapConfig =\n      segmentSpecificConfig[segmentIndex]?.[Representations.Labelmap];\n\n    const { fillAlpha, outlineWidth, renderFill, renderOutline } =\n      _getLabelmapConfig(\n        toolGroupLabelmapConfig,\n        segmentationRepresentationLabelmapConfig,\n        isActiveLabelmap,\n        segmentSpecificLabelmapConfig\n      );\n\n    const { forceOpacityUpdate, forceColorUpdate } =\n      _needsTransferFunctionUpdate(viewportId, actorUID, segmentIndex, {\n        fillAlpha,\n        renderFill,\n        renderOutline,\n        segmentColor,\n        outlineWidth,\n        segmentsHidden,\n      });\n\n    if (forceColorUpdate) {\n      cfun.addRGBPoint(\n        segmentIndex,\n        segmentColor[0] / MAX_NUMBER_COLORS,\n        segmentColor[1] / MAX_NUMBER_COLORS,\n        segmentColor[2] / MAX_NUMBER_COLORS\n      );\n    }\n\n    if (forceOpacityUpdate) {\n      if (renderFill) {\n        const segmentOpacity = segmentsHidden.has(segmentIndex)\n          ? 0\n          : (segmentColor[3] / 255) * fillAlpha;\n\n        ofun.removePoint(segmentIndex);\n        ofun.addPointLong(segmentIndex, segmentOpacity, 0.5, 1.0);\n      } else {\n        ofun.addPointLong(segmentIndex, 0.01, 0.5, 1.0);\n      }\n    }\n  }\n\n  const actor = actorEntry.actor as Types.VolumeActor;\n\n  actor.getProperty().setRGBTransferFunction(0, cfun);\n\n  ofun.setClamping(false);\n\n  actor.getProperty().setScalarOpacity(0, ofun);\n  actor.getProperty().setInterpolationTypeToNearest();\n  actor.getProperty().setUseLabelOutline(renderOutline);\n\n  // @ts-ignore - fix type in vtk\n  actor.getProperty().setLabelOutlineOpacity(outlineOpacity);\n\n  const { activeSegmentIndex } = SegmentationState.getSegmentation(\n    segmentationRepresentation.segmentationId\n  );\n\n  // create an array that contains all the segment indices and for the active\n  // segment index, use the activeSegmentOutlineWidthDelta, otherwise use the\n  // outlineWidth\n  // Pre-allocate the array with the required size to avoid dynamic resizing.\n  const outlineWidths = new Array(numColors - 1);\n\n  for (let i = 1; i < numColors; i++) {\n    // Start from 1 to skip the background segment index.\n    outlineWidths[i - 1] =\n      i === activeSegmentIndex\n        ? outlineWidth + toolGroupLabelmapConfig.activeSegmentOutlineWidthDelta\n        : outlineWidth;\n  }\n\n  actor.getProperty().setLabelOutlineThickness(outlineWidths);\n\n  // Set visibility based on whether actor visibility is specifically asked\n  // to be turned on/off (on by default) AND whether is is in active but\n  // we are rendering inactive labelmap\n  const visible = isActiveLabelmap || renderInactiveSegmentations;\n  actor.setVisibility(visible);\n}\n\nfunction _getLabelmapConfig(\n  toolGroupLabelmapConfig: LabelmapConfig,\n  segmentationRepresentationLabelmapConfig: LabelmapConfig,\n  isActiveLabelmap: boolean,\n  segmentsLabelmapConfig?: LabelmapConfig\n) {\n  const segmentLabelmapConfig = segmentsLabelmapConfig || {};\n\n  const configToUse = {\n    ...toolGroupLabelmapConfig,\n    ...segmentationRepresentationLabelmapConfig,\n    ...segmentLabelmapConfig,\n  };\n\n  const fillAlpha = isActiveLabelmap\n    ? configToUse.fillAlpha\n    : configToUse.fillAlphaInactive;\n  const outlineWidth = isActiveLabelmap\n    ? configToUse.outlineWidthActive\n    : configToUse.outlineWidthInactive;\n\n  const renderFill = isActiveLabelmap\n    ? configToUse.renderFill\n    : configToUse.renderFillInactive;\n\n  const renderOutline = configToUse.renderOutline;\n\n  const outlineOpacity = isActiveLabelmap\n    ? configToUse.outlineOpacity\n    : configToUse.outlineOpacityInactive;\n\n  return {\n    fillAlpha,\n    outlineWidth,\n    renderFill,\n    renderOutline,\n    outlineOpacity,\n  };\n}\n\nfunction _needsTransferFunctionUpdate(\n  viewportId: string,\n  actorUID: string,\n  segmentIndex: number,\n  {\n    fillAlpha,\n    renderFill,\n    renderOutline,\n    segmentColor,\n    outlineWidth,\n    segmentsHidden,\n  }: {\n    fillAlpha: number;\n    renderFill: boolean;\n    renderOutline: boolean;\n    outlineWidth: number;\n    segmentColor: number[];\n    segmentsHidden: Set<number>;\n  }\n) {\n  const cacheUID = `${viewportId}-${actorUID}-${segmentIndex}`;\n  const oldConfig = labelMapConfigCache.get(cacheUID);\n\n  if (!oldConfig) {\n    labelMapConfigCache.set(cacheUID, {\n      fillAlpha,\n      renderFill,\n      renderOutline,\n      outlineWidth,\n      segmentColor: segmentColor.slice(), // Create a copy\n      segmentsHidden: new Set(segmentsHidden), // Create a copy\n    });\n\n    return {\n      forceOpacityUpdate: true,\n      forceColorUpdate: true,\n    };\n  }\n\n  const {\n    fillAlpha: oldFillAlpha,\n    renderFill: oldRenderFill,\n    renderOutline: oldRenderOutline,\n    outlineWidth: oldOutlineWidth,\n    segmentColor: oldSegmentColor,\n    segmentsHidden: oldSegmentsHidden,\n  } = oldConfig;\n\n  const forceColorUpdate =\n    oldSegmentColor[0] !== segmentColor[0] ||\n    oldSegmentColor[1] !== segmentColor[1] ||\n    oldSegmentColor[2] !== segmentColor[2];\n\n  const forceOpacityUpdate =\n    oldSegmentColor[3] !== segmentColor[3] ||\n    oldFillAlpha !== fillAlpha ||\n    oldRenderFill !== renderFill ||\n    oldRenderOutline !== renderOutline ||\n    oldOutlineWidth !== outlineWidth ||\n    oldSegmentsHidden.has(segmentIndex) !== segmentsHidden.has(segmentIndex);\n\n  // update the cache\n  labelMapConfigCache.set(cacheUID, {\n    fillAlpha,\n    renderFill,\n    renderOutline,\n    outlineWidth,\n    segmentColor: segmentColor.slice(), // Create a copy\n    segmentsHidden: new Set(segmentsHidden), // Create a copy\n  });\n\n  return {\n    forceOpacityUpdate,\n    forceColorUpdate,\n  };\n}\n\nfunction _removeLabelmapFromToolGroupViewports(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);\n  }\n\n  const { viewportsInfo } = toolGroup;\n\n  for (const viewportInfo of viewportsInfo) {\n    const { viewportId, renderingEngineId } = viewportInfo;\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    removeLabelmapFromElement(\n      enabledElement.viewport.element,\n      segmentationRepresentationUID\n    );\n  }\n}\n\nasync function _addLabelmapToViewport(\n  viewport: Types.IVolumeViewport | Types.IStackViewport,\n  labelmapData: LabelmapSegmentationData,\n  segmentationRepresentationUID\n): Promise<void> {\n  await addLabelmapToElement(\n    viewport.element,\n    labelmapData,\n    segmentationRepresentationUID\n  );\n}\n\nexport default {\n  getRepresentationRenderingConfig,\n  render,\n  removeSegmentationRepresentation,\n};\n\nexport {\n  getRepresentationRenderingConfig,\n  render,\n  removeSegmentationRepresentation,\n};\n","import {\n  getEnabledElementByIds,\n  Types,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport { config as segmentationConfig } from '../../stateManagement/segmentation';\nimport { setSegmentationVisibility } from '../../stateManagement/segmentation/config/segmentationVisibility';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport { PublicToolProps, ToolProps } from '../../types';\nimport { BaseTool } from '../base';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../types/SegmentationStateTypes';\nimport { surfaceDisplay } from './Surface';\nimport { contourDisplay } from './Contour';\nimport { labelmapDisplay } from './Labelmap';\n\n/**\n * In Cornerstone3DTools, displaying of segmentations are handled by the SegmentationDisplayTool.\n * Generally, any Segmentation can be viewed in various representations such as\n * labelmap (3d), contours, surface etc. As of now, Cornerstone3DTools only implements\n * Labelmap representation.\n *\n * SegmentationDisplayTool works at ToolGroup level, and is responsible for displaying the\n * segmentation representation for ALL viewports of a toolGroup, this way we can support complex\n * scenarios for displaying segmentations.\n *\n * Current Limitations:\n * - Only supports rendering of the volumetric segmentations in 3D space. (StackViewport segmentations are not supported yet)\n * - Labelmap representation is the only supported representation for now.\n *\n * Similar to other tools in Cornerstone3DTools, the SegmentationDisplayTool should\n * be added to the CornerstoneTools by calling cornerstoneTools.addTool(SegmentationDisplayTool)\n * and a toolGroup should be created for it using the ToolGroupManager API, finally\n * viewports information such as viewportId and renderingEngineId should be provided\n * to the toolGroup and the SegmentationDisplayTool should be set to be activated.\n *\n *\n */\nclass SegmentationDisplayTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {},\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolEnabled(): void {\n    const toolGroupId = this.toolGroupId;\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // for each segmentationData, make the visibility true\n    toolGroupSegmentationRepresentations.forEach(\n      (segmentationRepresentation) => {\n        setSegmentationVisibility(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          true\n        );\n      }\n    );\n  }\n\n  onSetToolDisabled(): void {\n    const toolGroupId = this.toolGroupId;\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // for each segmentationData, make the visibility false\n    toolGroupSegmentationRepresentations.forEach(\n      (segmentationRepresentation) => {\n        setSegmentationVisibility(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          false\n        );\n      }\n    );\n  }\n\n  /**\n   * It is used to trigger the render for each segmentations in the toolGroup.\n   * Based on the segmentation representation type, it will call the corresponding\n   * render function.\n   *\n   * @param toolGroupId - the toolGroupId\n   */\n  renderSegmentation = (toolGroupId: string): void => {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      return;\n    }\n\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // toolGroup Viewports\n    const toolGroupViewports = toolGroup.viewportsInfo.map(\n      ({ renderingEngineId, viewportId }) => {\n        const enabledElement = getEnabledElementByIds(\n          viewportId,\n          renderingEngineId\n        );\n\n        if (enabledElement) {\n          return enabledElement.viewport;\n        }\n      }\n    );\n\n    // Render each segmentationData, in each viewport in the toolGroup\n    const segmentationRenderList = toolGroupSegmentationRepresentations.map(\n      (representation: ToolGroupSpecificRepresentation) => {\n        const config = this._getMergedRepresentationsConfig(toolGroupId);\n\n        const viewportsRenderList = [];\n\n        const renderers = {\n          [Representations.Labelmap]: labelmapDisplay,\n          [Representations.Contour]: contourDisplay,\n          [Representations.Surface]: surfaceDisplay,\n        };\n\n        const display = renderers[representation.type];\n\n        for (const viewport of toolGroupViewports) {\n          const renderedViewport = display.render(\n            viewport as Types.IVolumeViewport,\n            representation,\n            config\n          );\n\n          viewportsRenderList.push(renderedViewport);\n        }\n        return viewportsRenderList;\n      }\n    );\n\n    Promise.allSettled(segmentationRenderList).then(() => {\n      // for all viewports in the toolGroup trigger a re-render\n      toolGroupViewports.forEach((viewport) => {\n        viewport.render();\n      });\n    });\n  };\n\n  /**\n   * Merge the toolGroup specific configuration with the default global configuration\n   * @param toolGroupId\n   * @returns\n   */\n  _getMergedRepresentationsConfig(\n    toolGroupId: string\n  ): SegmentationRepresentationConfig {\n    const toolGroupConfig =\n      segmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n    const globalConfig = segmentationConfig.getGlobalConfig();\n\n    // merge two configurations and override the global config\n    const mergedConfig = csUtils.deepMerge(globalConfig, toolGroupConfig);\n\n    return mergedConfig;\n  }\n}\n\nSegmentationDisplayTool.toolName = 'SegmentationDisplay';\nexport default SegmentationDisplayTool;\n","import {\n  triggerEvent,\n  eventTarget,\n  getRenderingEngine,\n  Enums,\n  Types,\n} from '@cornerstonejs/core';\nimport { Events as csToolsEvents } from '../../enums';\nimport {\n  getToolGroup,\n  getToolGroupForViewport,\n} from '../../store/ToolGroupManager';\n\nimport SegmentationDisplayTool from '../../tools/displayTools/SegmentationDisplayTool';\nimport { SegmentationRenderedEventDetail } from '../../types/EventTypes';\n\n/**\n * SegmentationRenderingEngine is a class that is responsible for rendering\n * segmentations for a toolGroup. It will call SegmentationDisplayTool to render the segmentation\n * based on the segmentation data and their configurations. Note: This is a Singleton class\n * and should not be instantiated directly. To trigger a render for all the\n * segmentations of a tool group you can use.\n *\n * ```\n * triggerSegmentationRender(toolGroupId)\n * ```\n */\nclass SegmentationRenderingEngine {\n  private _needsRender: Set<string> = new Set();\n  private _animationFrameSet = false;\n  private _animationFrameHandle: number | null = null;\n  public hasBeenDestroyed: boolean;\n\n  public removeToolGroup(toolGroupId) {\n    this._needsRender.delete(toolGroupId);\n\n    if (this._needsRender.size === 0) {\n      this._reset();\n    }\n  }\n\n  public renderToolGroupSegmentations(toolGroupId): void {\n    this._setToolGroupSegmentationToBeRenderedNextFrame([toolGroupId]);\n  }\n\n  /**\n   *  _throwIfDestroyed Throws an error if trying to interact with the `RenderingEngine`\n   * instance after its `destroy` method has been called.\n   */\n  private _throwIfDestroyed() {\n    if (this.hasBeenDestroyed) {\n      throw new Error(\n        'this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.'\n      );\n    }\n  }\n\n  private _setToolGroupSegmentationToBeRenderedNextFrame(\n    toolGroupIds: string[]\n  ) {\n    // Add the viewports to the set of flagged viewports\n    toolGroupIds.forEach((toolGroupId) => {\n      this._needsRender.add(toolGroupId);\n    });\n\n    // Render any flagged viewports\n    this._render();\n  }\n\n  /**\n   *  _render Sets up animation frame if necessary\n   */\n  private _render() {\n    // If we have viewports that need rendering and we have not already\n    // set the RAF callback to run on the next frame.\n    if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n      this._animationFrameHandle = window.requestAnimationFrame(\n        this._renderFlaggedToolGroups\n      );\n\n      // Set the flag that we have already set up the next RAF call.\n      this._animationFrameSet = true;\n    }\n  }\n\n  private _renderFlaggedToolGroups = () => {\n    this._throwIfDestroyed();\n\n    // for each toolGroupId insides the _needsRender set, render the segmentation\n    const toolGroupIds = Array.from(this._needsRender.values());\n\n    for (const toolGroupId of toolGroupIds) {\n      this._triggerRender(toolGroupId);\n\n      // This viewport has been rendered, we can remove it from the set\n      this._needsRender.delete(toolGroupId);\n\n      // If there is nothing left that is flagged for rendering, stop here\n      // and allow RAF to be called again\n      if (this._needsRender.size === 0) {\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        return;\n      }\n    }\n  };\n  _triggerRender(toolGroupId) {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      console.warn(`No tool group found with toolGroupId: ${toolGroupId}`);\n      return;\n    }\n\n    const { viewportsInfo } = toolGroup;\n\n    const viewports = viewportsInfo\n      .map(({ viewportId, renderingEngineId }) => {\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n\n        if (!renderingEngine) {\n          console.warn('rendering Engine has been destroyed');\n          return;\n        }\n\n        const viewport = renderingEngine.getViewport(viewportId);\n\n        if (viewport) {\n          return viewport;\n        }\n      })\n      .filter(Boolean);\n\n    const segmentationDisplayToolInstance = toolGroup.getToolInstance(\n      SegmentationDisplayTool.toolName\n    ) as SegmentationDisplayTool;\n    if (!segmentationDisplayToolInstance) {\n      console.warn('No segmentation tool found inside', toolGroupId);\n      return;\n    }\n\n    function onSegmentationRender(evt: Types.EventTypes.ImageRenderedEvent) {\n      const { element, viewportId, renderingEngineId } = evt.detail;\n\n      element.removeEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        onSegmentationRender as EventListener\n      );\n\n      const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n\n      if (!toolGroup) {\n        console.warn('toolGroup has been destroyed');\n        return;\n      }\n\n      const eventDetail: SegmentationRenderedEventDetail = {\n        toolGroupId: toolGroup.id,\n        viewportId,\n      };\n\n      triggerEvent(eventTarget, csToolsEvents.SEGMENTATION_RENDERED, {\n        ...eventDetail,\n      });\n    }\n\n    // Todo: for other representations we probably need the drawSVG, but right now we are not using it\n    // drawSvg(element, (svgDrawingHelper) => {\n    //   const handleDrawSvg = (tool) => {\n    //     if (tool instanceof SegmentationDisplayTool && tool.renderAnnotation) {\n    //       tool.renderAnnotation({ detail: eventDetail })\n    //       triggerEvent(element, csToolsEvents.SEGMENTATION_RENDERED, { ...eventDetail })\n    //     }\n    //   }\n    //   enabledTools.forEach(handleDrawSvg)\n    // })\n\n    viewports.forEach(({ element }) => {\n      element.addEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        onSegmentationRender as EventListener\n      );\n    });\n\n    segmentationDisplayToolInstance.renderSegmentation(toolGroupId);\n  }\n\n  /**\n   *  _reset Resets the `RenderingEngine`\n   */\n  private _reset() {\n    window.cancelAnimationFrame(this._animationFrameHandle);\n\n    this._needsRender.clear();\n    this._animationFrameSet = false;\n    this._animationFrameHandle = null;\n  }\n}\n\nconst segmentationRenderingEngine = new SegmentationRenderingEngine();\n\n/**\n * It triggers a render for all the segmentations of the tool group with the given Id.\n * @param toolGroupId - The Id of the tool group to render.\n */\nfunction triggerSegmentationRender(toolGroupId: string): void {\n  segmentationRenderingEngine.renderToolGroupSegmentations(toolGroupId);\n}\n\nexport { segmentationRenderingEngine, triggerSegmentationRender };\nexport default triggerSegmentationRender;\n","import vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport {\n  StackViewport,\n  getEnabledElement,\n  Enums,\n  getEnabledElementByIds,\n  cache,\n  utilities,\n  Types,\n} from '@cornerstonejs/core';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../stateManagement/segmentation/segmentationState';\nimport { LabelmapSegmentationDataStack } from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\nimport triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\n\nconst enable = function (element: HTMLDivElement): void {\n  const { viewport } = getEnabledElement(element);\n\n  if (!(viewport instanceof StackViewport)) {\n    return;\n  }\n\n  element.addEventListener(\n    Enums.Events.STACK_NEW_IMAGE,\n    _imageChangeEventListener as EventListener\n  );\n  // this listener handles the segmentation modifications\n  element.addEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    _imageChangeEventListener as EventListener\n  );\n};\n\nconst disable = function (element: HTMLDivElement): void {\n  const { viewport } = getEnabledElement(element);\n\n  if (!(viewport instanceof StackViewport)) {\n    return;\n  }\n\n  element.removeEventListener(\n    Enums.Events.STACK_NEW_IMAGE,\n    _imageChangeEventListener as EventListener\n  );\n  element.removeEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    _imageChangeEventListener as EventListener\n  );\n};\n\n/**\n *  When the image is rendered, check what tools can be rendered for this element.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `renderAnnotation` method, then we render them.\n * - Note that these tools don't necessarily have to be instances of  `AnnotationTool`,\n *   Any tool may register a `renderAnnotation` method (e.g. a tool that displays an overlay).\n *\n * @param evt - The normalized IMAGE_RENDERED event.\n */\nfunction _imageChangeEventListener(evt) {\n  const eventData = evt.detail;\n  const { viewportId, renderingEngineId } = eventData;\n  const { viewport } = getEnabledElementByIds(\n    viewportId,\n    renderingEngineId\n  ) as { viewport: Types.IStackViewport };\n\n  const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n\n  if (!toolGroup) {\n    return;\n  }\n\n  let toolGroupSegmentationRepresentations =\n    SegmentationState.getSegmentationRepresentations(toolGroup.id) || [];\n\n  toolGroupSegmentationRepresentations =\n    toolGroupSegmentationRepresentations.filter(\n      (representation) => representation.type === Representations.Labelmap\n    );\n\n  if (!toolGroupSegmentationRepresentations?.length) {\n    return;\n  }\n\n  const segmentationRepresentations = {};\n  toolGroupSegmentationRepresentations.forEach((representation) => {\n    const segmentation = SegmentationState.getSegmentation(\n      representation.segmentationId\n    );\n\n    if (!segmentation) {\n      return;\n    }\n\n    const labelmapData =\n      segmentation.representationData[Representations.Labelmap];\n\n    if (isVolumeSegmentation(labelmapData)) {\n      return;\n    }\n\n    const { imageIdReferenceMap } =\n      labelmapData as LabelmapSegmentationDataStack;\n\n    segmentationRepresentations[representation.segmentationRepresentationUID] =\n      {\n        imageIdReferenceMap,\n      };\n  });\n\n  const representationList = Object.keys(segmentationRepresentations);\n  const currentImageId = viewport.getCurrentImageId();\n  const actors = viewport.getActors();\n\n  const segmentationFound = actors.find((actor) => {\n    if (!representationList.includes(actor.uid)) {\n      return false;\n    }\n\n    return true;\n  });\n\n  if (!segmentationFound) {\n    // If the segmentation is not found, it could be because of some special cases\n    // where we are in the process of updating the volume conversion to a stack while\n    // the data is still coming in. In such situations, we should trigger the render\n    // to ensure that the segmentation actors are created, even if the data arrives late.\n    triggerSegmentationRender(toolGroup.id);\n\n    // we should return here, since there is no segmentation actor to update\n    // we will hit this function later on after the actor is created\n    return;\n  }\n\n  actors.forEach((actor) => {\n    if (!representationList.includes(actor.uid)) {\n      return;\n    }\n    const segmentationActor = actor.actor;\n\n    const { imageIdReferenceMap } = segmentationRepresentations[actor.uid];\n\n    const derivedImageId = imageIdReferenceMap.get(currentImageId);\n\n    const segmentationImageData = segmentationActor.getMapper().getInputData();\n\n    if (!derivedImageId) {\n      // this means that this slice doesn't have a segmentation for this representation\n      // this can be a case where the segmentation was added to certain slices only\n      // so we can keep the actor but empty out the imageData\n      const scalarArray = vtkDataArray.newInstance({\n        name: 'Pixels',\n        numberOfComponents: 1,\n        values: new Uint8Array(segmentationImageData.getNumberOfPoints()),\n      });\n\n      const imageData = vtkImageData.newInstance();\n      imageData.getPointData().setScalars(scalarArray);\n      segmentationActor.getMapper().setInputData(imageData);\n      return;\n    }\n\n    const derivedImage = cache.getImage(derivedImageId);\n\n    const { dimensions, spacing, direction } =\n      viewport.getImageDataMetadata(derivedImage);\n\n    const currentImage = cache.getImage(currentImageId);\n    const { origin: currentOrigin } =\n      viewport.getImageDataMetadata(currentImage);\n\n    // IMPORTANT: We need to make sure that the origin of the segmentation\n    // is the same as the current image origin. This is because due to some\n    // floating point precision issues, when coming from volume to stack\n    // the origin of the segmentation can be slightly different from the\n    // current image origin. This can cause the segmentation to be rendered\n    // in the wrong location.\n    // Todo: This will not work for segmentations that are not in the same frame\n    // of reference or derived from the same image. This can happen when we have\n    // a segmentation that happens to exist in the same space as the image but is\n    // not derived from it. We need to find a way to handle this case, but don't think\n    // it makes sense to do it for the stack viewport, as the volume viewport is designed to handle this case.\n    const originToUse = currentOrigin;\n\n    segmentationImageData.setOrigin(originToUse);\n    segmentationImageData.modified();\n\n    if (\n      segmentationImageData.getDimensions()[0] !== dimensions[0] ||\n      segmentationImageData.getDimensions()[1] !== dimensions[1]\n    ) {\n      // IMPORTANT: Not sure why we can't just update the dimensions\n      // and the orientation of the image data and then call modified\n      // I tried calling modified on everything, but seems like we should remove\n      // and add the actor again below\n      viewport.removeActors([actor.uid]);\n      viewport.addImages(\n        [\n          {\n            imageId: derivedImageId,\n            actorUID: actor.uid,\n            callback: ({ imageActor }) => {\n              const scalarArray = vtkDataArray.newInstance({\n                name: 'Pixels',\n                numberOfComponents: 1,\n                values: [...derivedImage.getPixelData()],\n              });\n\n              const imageData = vtkImageData.newInstance();\n\n              imageData.setDimensions(dimensions[0], dimensions[1], 1);\n              imageData.setSpacing(spacing);\n              imageData.setDirection(direction);\n              imageData.setOrigin(originToUse);\n              imageData.getPointData().setScalars(scalarArray);\n\n              imageActor.getMapper().setInputData(imageData);\n            },\n          },\n        ],\n        true,\n        false\n      );\n\n      triggerSegmentationRender(toolGroup.id);\n      return;\n    }\n\n    utilities.updateVTKImageDataWithCornerstoneImage(\n      segmentationImageData,\n      derivedImage\n    );\n    viewport.render();\n\n    // This is put here to make sure that the segmentation is rendered\n    // for the initial image as well after that we don't need it since\n    // stack new image is called when changing slices\n    if (evt.type === Enums.Events.IMAGE_RENDERED) {\n      // unsubscribe after the initial render\n      viewport.element.removeEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        _imageChangeEventListener as EventListener\n      );\n    }\n  });\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import { state } from '../store';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nconst VIEWPORT_ELEMENT = 'viewport-element';\n\n/**\n * Returns the SVG drawing helper for the given HTML element.\n * @param element - The HTML element to get the SVG drawing helper for.\n * @private\n */\nfunction getSvgDrawingHelper(element: HTMLDivElement): SVGDrawingHelper {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId, renderingEngineId } = enabledElement;\n  const canvasHash = `${viewportId}:${renderingEngineId}`;\n  const svgLayerElement = _getSvgLayer(element);\n\n  // Reset touched\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n    state.svgNodeCache[canvasHash][cacheKey].touched = false;\n  });\n\n  return {\n    svgLayerElement: svgLayerElement,\n    svgNodeCacheForCanvas: state.svgNodeCache,\n    getSvgNode: getSvgNode.bind(this, canvasHash),\n    appendNode: appendNode.bind(this, svgLayerElement, canvasHash),\n    setNodeTouched: setNodeTouched.bind(this, canvasHash),\n    clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),\n  };\n}\n\n/**\n *\n * @param element\n * @private\n */\nfunction _getSvgLayer(element) {\n  const viewportElement = `.${VIEWPORT_ELEMENT}`;\n  const internalDivElement = element.querySelector(viewportElement);\n\n  // Using :scope to make sure the right svg layer is selected otherwise it\n  // may select one from a nested viewport (eg: AdvancedMagnifyTool).\n  const svgLayer = internalDivElement.querySelector(':scope > .svg-layer');\n\n  return svgLayer;\n}\n\nfunction getSvgNode(canvasHash, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\n    return state.svgNodeCache[canvasHash][cacheKey].domRef;\n  }\n}\n\nfunction appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return null;\n  }\n\n  state.svgNodeCache[canvasHash][cacheKey] = {\n    touched: true,\n    domRef: svgNode,\n  };\n\n  svgLayerElement.appendChild(svgNode);\n}\n\nfunction setNodeTouched(canvasHash, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\n    state.svgNodeCache[canvasHash][cacheKey].touched = true;\n  }\n}\n\nfunction clearUntouched(svgLayerElement, canvasHash) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n    const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];\n\n    if (!cacheEntry.touched && cacheEntry.domRef) {\n      svgLayerElement.removeChild(cacheEntry.domRef);\n      delete state.svgNodeCache[canvasHash][cacheKey];\n    }\n  });\n}\n\nexport default getSvgDrawingHelper;\n","import getSvgDrawingHelper from './getSvgDrawingHelper';\n\nfunction draw(\n  element: HTMLDivElement,\n  fn: (svgDrawingElement: any) => any\n): void {\n  const svgDrawingHelper = getSvgDrawingHelper(element);\n\n  // Save...\n  fn(svgDrawingHelper);\n  // Restore...\n\n  svgDrawingHelper.clearUntouched();\n}\n\nexport default draw;\n","import { ToolGroupManager } from '../store';\nimport { ToolModes } from '../enums';\nimport { getEnabledElement } from '@cornerstonejs/core';\n\ntype ModesFilter = Array<ToolModes>;\n\n/**\n * Finds the enabled element, and iterates over the tools inside its\n * toolGroup. Returns the list of tool instances that are valid based\n * on the provided tool mode.\n *\n * @param element Canvas element\n * @param modesFilter tool modes: active, passive, enabled, disabled\n * @returns enabled tool instances\n */\nexport default function getToolsWithModesForElement(\n  element: HTMLDivElement,\n  modesFilter: ModesFilter\n) {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return [];\n  }\n\n  const enabledTools = [];\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    /* filter out tools that don't have options */\n    if (!toolOptions) {\n      continue;\n    }\n\n    if (modesFilter.includes(toolOptions.mode)) {\n      const toolInstance = toolGroup.getToolInstance(toolName);\n      enabledTools.push(toolInstance);\n    }\n  }\n\n  return enabledTools;\n}\n","import {\n  getEnabledElement,\n  triggerEvent,\n  getRenderingEngine,\n} from '@cornerstonejs/core';\nimport { Events, ToolModes } from '../enums';\nimport { draw as drawSvg } from '../drawingSvg';\nimport getToolsWithModesForElement from './getToolsWithModesForElement';\nimport { AnnotationRenderedEventDetail } from '../types/EventTypes';\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * AnnotationRenderingEngine is a class that is responsible for rendering\n * annotations defined in the renderAnnotation method of annotation tools on the page.\n * It mimics the RenderingEngine in the Cornerstone Core. Here it uses requestAnimationFrame\n * is used to render annotations by calling renderAnnotations() on each enabled tool. Note: This\n * is a Singleton class and should not be instantiated directly. To trigger\n * an annotation render for an HTML element containing a viewport you can use\n *\n * ```\n * triggerAnnotationRender(element)\n * ```\n */\nclass AnnotationRenderingEngine {\n  public hasBeenDestroyed: boolean;\n  private _needsRender: Set<HTMLDivElement> = new Set();\n  private _animationFrameSet = false;\n  private _animationFrameHandle: number | null = null;\n  private _viewportElements: Map<string, HTMLDivElement>;\n\n  constructor() {\n    this._viewportElements = new Map();\n  }\n\n  /**\n   * Add the viewport's HTMLDivElement to the viewports for rendering. This method\n   * just informs the annotationRenderingEngine about the viewport and\n   * does not initiate a render.\n   * @param viewportId - Viewport Unique identifier\n   * @param element - HTMLDivElement\n   */\n  public addViewportElement(viewportId: string, element: HTMLDivElement) {\n    this._viewportElements.set(viewportId, element);\n  }\n\n  /**\n   * Remove the viewport's HTMLDivElement from subsequent annotation renders\n   * @param viewportId - Viewport Unique identifier\n   */\n  public removeViewportElement(viewportId: string, element: HTMLDivElement) {\n    this._viewportElements.delete(viewportId);\n\n    // delete element from needsRender if element exist\n    this._needsRender.delete(element);\n\n    // I don' think there is any disadvantage to canceling the animation frame\n    // and resetting the flags on viewport's element removal, since the removeVIewportElement\n    // might be as a result of reEnabling the element (in re-enable we disable first), hence the need to render the\n    // new one while removing the old one\n    this._reset();\n  }\n\n  /**\n   * It tells the AnnotationRenderingEngine to render the viewport element the next\n   * time it renders.\n   *\n   * @param element - The element to render.\n   */\n  public renderViewport(element: HTMLDivElement): void {\n    this._setViewportsToBeRenderedNextFrame([element]);\n  }\n\n  /**\n   * _throwIfDestroyed Throws an error if trying to interact with the `RenderingEngine`\n   * instance after its `destroy` method has been called.\n   */\n  private _throwIfDestroyed() {\n    if (this.hasBeenDestroyed) {\n      throw new Error(\n        'this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.'\n      );\n    }\n  }\n\n  private _renderFlaggedViewports = () => {\n    this._throwIfDestroyed();\n\n    const elements = Array.from(this._viewportElements.values());\n\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      if (this._needsRender.has(element)) {\n        this._triggerRender(element);\n\n        // This viewport has been rendered, we can remove it from the set\n        this._needsRender.delete(element);\n\n        // If there is nothing left that is flagged for rendering, stop here\n        // and allow RAF to be called again\n        if (this._needsRender.size === 0) {\n          this._animationFrameSet = false;\n          this._animationFrameHandle = null;\n          return;\n        }\n      }\n    }\n  };\n\n  private _setAllViewportsToBeRenderedNextFrame() {\n    const elements = [...this._viewportElements.values()];\n\n    elements.forEach((element) => {\n      this._needsRender.add(element);\n    });\n\n    this._renderFlaggedViewports();\n  }\n\n  private _setViewportsToBeRenderedNextFrame(elements: HTMLDivElement[]) {\n    const elementsEnabled = [...this._viewportElements.values()];\n\n    // Add the viewports to the set of flagged viewports\n    elements.forEach((element) => {\n      // only enabledElement need to render\n      if (elementsEnabled.indexOf(element) !== -1) {\n        this._needsRender.add(element);\n      }\n    });\n\n    // Render any flagged viewports\n    this._render();\n  }\n\n  /**\n   * _render Sets up animation frame if necessary\n   */\n  private _render() {\n    // If we have viewports that need rendering and we have not already\n    // set the RAF callback to run on the next frame.\n    if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n      this._animationFrameHandle = window.requestAnimationFrame(\n        this._renderFlaggedViewports\n      );\n\n      // Set the flag that we have already set up the next RAF call.\n      this._animationFrameSet = true;\n    }\n  }\n\n  _triggerRender(element) {\n    const enabledElement = getEnabledElement(element);\n\n    if (!enabledElement) {\n      console.warn('Element has been disabled');\n      return;\n    }\n\n    const renderingEngine = getRenderingEngine(\n      enabledElement.renderingEngineId\n    );\n    if (!renderingEngine) {\n      console.warn('rendering Engine has been destroyed');\n      return;\n    }\n\n    const enabledTools = getToolsWithModesForElement(element, [\n      Active,\n      Passive,\n      Enabled,\n    ]);\n\n    const { renderingEngineId, viewportId } = enabledElement;\n    const eventDetail: AnnotationRenderedEventDetail = {\n      element,\n      renderingEngineId,\n      viewportId,\n    };\n\n    // const enabledToolsWithAnnotations = enabledTools.filter((tool) => {\n    //   const annotations = getAnnotations(tool.getToolName(), {FrameOfReferenceUID});\n    //   return annotations && annotations.length;\n    // });\n\n    drawSvg(element, (svgDrawingHelper) => {\n      let anyRendered = false;\n      const handleDrawSvg = (tool) => {\n        if (tool.renderAnnotation) {\n          const rendered = tool.renderAnnotation(\n            enabledElement,\n            svgDrawingHelper\n          );\n          anyRendered = anyRendered || rendered;\n        }\n      };\n\n      /**\n       * We should be able to filter tools that don't have annotations, but\n       * currently some of tools have renderAnnotation method BUT\n       * don't keep annotation in the state, so if we do so, the tool will not be\n       * rendered.\n       */\n      enabledTools.forEach(handleDrawSvg);\n\n      if (anyRendered) {\n        triggerEvent(element, Events.ANNOTATION_RENDERED, { ...eventDetail });\n      }\n    });\n  }\n\n  /**\n   * _reset Resets the `RenderingEngine`\n   */\n  private _reset() {\n    window.cancelAnimationFrame(this._animationFrameHandle);\n\n    this._needsRender.clear();\n    this._animationFrameSet = false;\n    this._animationFrameHandle = null;\n\n    this._setAllViewportsToBeRenderedNextFrame();\n  }\n}\n\nconst annotationRenderingEngine = new AnnotationRenderingEngine();\n\n/**\n * It triggers the rendering of the annotations for the given HTML element using\n * the `AnnotationRenderingEngine`\n * @param element - The element to render the annotation on.\n */\nfunction triggerAnnotationRender(element: HTMLDivElement): void {\n  annotationRenderingEngine.renderViewport(element);\n}\n\nexport { annotationRenderingEngine, triggerAnnotationRender };\n\nexport default triggerAnnotationRender;\n","import { Enums, Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from '../utilities/triggerAnnotationRender';\n\n/**\n *  When the image is rendered, check what tools can be rendered for this element.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `renderAnnotation` method, then we render them.\n * - Note that these tools don't necessarily have to be instances of  `AnnotationTool`,\n *   Any tool may register a `renderAnnotation` method (e.g. a tool that displays an overlay).\n *\n * @param evt - The normalized IMAGE_RENDERED event.\n */\nconst onImageRendered = function (evt: Types.EventTypes.ImageRenderedEvent) {\n  // TODO: should we do this on camera modified instead of image rendered?\n  // e.g. no need to re-render annotations if only the VOI has changed\n  triggerAnnotationRender(evt.detail.element);\n};\n\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    onImageRendered as EventListener\n  );\n};\n\nconst disable = function (element: HTMLDivElement): void {\n  element.removeEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    onImageRendered as EventListener\n  );\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\n\ntype ModesFilter = Array<ToolModes>;\n\n/**\n * Given the normalized mouse event and a filter of modes,\n * find all the tools on the element that are in one of the specified modes.\n * If the evtButton is specified, only tools with a matching binding will be returned.\n * @param evt - The normalized mouseDown event.\n * @param modesFilter - An array of entries from the `ToolModes` enum.\n */\nexport default function getToolsWithModesForMouseEvent(\n  evt: EventTypes.MouseMoveEventType,\n  modesFilter: ModesFilter,\n  evtButton?: any\n) {\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return [];\n  }\n\n  const enabledTools = [];\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.toolOptions[toolName];\n\n    // tool has binding that matches the mouse button - we match those with\n    // any modifier keys too since they can be passively interacted with\n    const correctBinding =\n      evtButton != null && // not null or undefined\n      tool.bindings.length &&\n      tool.bindings.some((binding) => binding.mouseButton === evtButton);\n\n    if (\n      modesFilter.includes(tool.mode) &&\n      // Should not filter by event's button\n      // or should, and the tool binding includes the event's button\n      (!evtButton || correctBinding)\n    ) {\n      const toolInstance = toolGroup.getToolInstance(toolName);\n      enabledTools.push(toolInstance);\n    }\n  }\n\n  return enabledTools;\n}\n","import { Enums, Types } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * When the camera is modified, check what tools need to react to this.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `onCameraModified` method, we call it.\n *\n * @param evt - The normalized camera modified event.\n */\nconst onCameraModified = function (evt: Types.EventTypes.CameraModifiedEvent) {\n  // @ts-ignore\n  const enabledTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n    Enabled,\n  ]);\n\n  enabledTools.forEach((tool) => {\n    if (tool.onCameraModified) {\n      tool.onCameraModified(evt);\n    }\n  });\n};\n\nconst enable = function (element) {\n  element.addEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\n\nconst disable = function (element) {\n  element.removeEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import { Enums, Types } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * When image spacing is calibrated modify the annotations for all of its tools\n * to consider the new calibration info.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `onImageSpacingCalibrated` method, we call it.\n *\n * @param evt - The normalized image calibration event.\n */\nconst onImageSpacingCalibrated = function (\n  evt: Types.EventTypes.ImageSpacingCalibratedEvent\n) {\n  // @ts-ignore\n  const enabledTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n    Enabled,\n  ]);\n\n  enabledTools.forEach((tool) => {\n    if (tool.onImageSpacingCalibrated) {\n      tool.onImageSpacingCalibrated(evt);\n    }\n  });\n};\n\nconst enable = function (element: HTMLDivElement) {\n  element.addEventListener(\n    Enums.Events.IMAGE_SPACING_CALIBRATED,\n    onImageSpacingCalibrated as EventListener\n  );\n};\n\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(\n    Enums.Events.IMAGE_SPACING_CALIBRATED,\n    onImageSpacingCalibrated as EventListener\n  );\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import { state, ToolGroupManager } from '../../store';\nimport ToolModes from '../../enums/ToolModes';\n\nconst { Active } = ToolModes;\n\n/**\n * @function customCallbackHandler This is used as a generic event handler for tool events\n * on viewports. It:\n *\n * - Finds an \"active\" tool with:\n *    - A matching `handlerType`\n *    - A matching `customFunction` on its tool instance\n *\n * Then calls that custom function with raised event.\n *\n * @param handlerType - 'Mouse' | 'Touch' | 'MouseWheel'\n * @param customFunction - Function name that's expected to live on implementing\n *   (and event handling) active tool ex. 'doubleClickCallback'\n * @param evt\n */\nexport default function customCallbackHandler(\n  handlerType: string,\n  customFunction: string,\n  evt\n) {\n  if (state.isInteractingWithTool) {\n    return false;\n  }\n\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return false;\n  }\n\n  // TODO: Filter tools by interaction type?\n  /**\n   * Iterate tool group tools until we find a tool that is:\n   * - active\n   * - has the custom callback function\n   *\n   */\n  let activeTool;\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.toolOptions[toolName];\n    // TODO: Should be getter\n    const toolInstance = toolGroup.getToolInstance(toolName);\n\n    if (\n      // TODO: Should be enum?\n      tool.mode === Active &&\n      // TODO: Should be implements interface?\n      // Weird that we need concrete instance. Other options to filter / get callback?\n      typeof toolInstance[customFunction] === 'function'\n    ) {\n      activeTool = toolGroup.getToolInstance(toolName);\n      break;\n    }\n  }\n\n  if (!activeTool) {\n    return;\n  }\n\n  activeTool[customFunction](evt);\n}\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * mouseClick - Event handler for mouse click events. Uses `customCallbackHandler` to fire\n * the `mouseClickCallback` function on active tools.\n */\nconst mouseClick = customCallbackHandler.bind(\n  null,\n  'Mouse',\n  'mouseClickCallback'\n);\n\nexport default mouseClick;\n","import type { Types } from '@cornerstonejs/core';\n\nimport {\n  ToolAnnotationsPair,\n  ToolsWithMoveableHandles,\n} from '../types/InternalToolTypes';\n\n/**\n * Filters an array of tools, returning only tools with moveable handles at the mouse location that are not locked\n *\n * @param element - The element\n * @param ToolAndAnnotations - The input tool array.\n * @param canvasCoords - The coordinates of the mouse position.\n * @param interactionType - The type of interaction (e.g. 'mouse' or 'touch')\n * @returns The filtered array.\n */\nexport default function filterToolsWithMoveableHandles(\n  element: HTMLDivElement,\n  ToolAndAnnotations: ToolAnnotationsPair[],\n  canvasCoords: Types.Point2,\n  interactionType = 'mouse'\n): ToolsWithMoveableHandles[] {\n  const proximity = interactionType === 'touch' ? 36 : 6;\n  const toolsWithMoveableHandles = [];\n\n  ToolAndAnnotations.forEach(({ tool, annotations }) => {\n    for (const annotation of annotations) {\n      if (annotation.isLocked || !annotation.isVisible) {\n        continue;\n      }\n\n      const handle = tool.getHandleNearImagePoint(\n        element,\n        annotation,\n        canvasCoords,\n        proximity\n      );\n\n      if (handle) {\n        toolsWithMoveableHandles.push({\n          tool,\n          annotation,\n          handle,\n        });\n        break;\n      }\n    }\n  });\n\n  return toolsWithMoveableHandles;\n}\n","import { getAnnotations } from '../stateManagement/annotation/annotationState';\nimport { ToolAnnotationsPair } from '../types/InternalToolTypes';\nimport type AnnotationTool from '../tools/base/AnnotationTool';\nimport BaseTool from '../tools/base/BaseTool';\nimport { getEnabledElement } from '@cornerstonejs/core';\n\n/**\n * Filters an array of tools, returning only tools which have annotation.\n *\n * @param element - The cornerstone3D enabled element.\n * @param tools - The array of tools to check.\n *\n * @returns The array of tools with their found annotations.\n */\nexport default function filterToolsWithAnnotationsForElement(\n  element: HTMLDivElement,\n  tools: AnnotationTool[]\n): ToolAnnotationsPair[] {\n  const result = [];\n  for (let i = 0; i < tools.length; i++) {\n    const tool = tools[i];\n\n    if (!tool) {\n      console.warn('undefined tool in filterToolsWithAnnotationsForElement');\n      continue;\n    }\n\n    let annotations = getAnnotations(\n      (tool.constructor as typeof BaseTool).toolName,\n      element\n    );\n\n    if (!annotations?.length) {\n      continue;\n    }\n\n    if (typeof tool.filterInteractableAnnotationsForElement === 'function') {\n      // If the tool has a annotations filter (e.g. with in-plane-annotations-only filtering), use it.\n      annotations = tool.filterInteractableAnnotationsForElement(\n        element,\n        annotations\n      );\n    }\n\n    if (annotations.length > 0) {\n      result.push({ tool, annotations });\n    }\n  }\n\n  return result;\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport {\n  ToolAnnotationPair,\n  ToolAnnotationsPair,\n} from '../types/InternalToolTypes';\n\n/**\n * Filters an array of tools with annotations, returning the first annotation\n * for each tool that is moveable and at the mouse location. It results in\n * one annotation per tool.\n *\n *\n * @param element - The HTML element\n * @param ToolAndAnnotations - The input tool array.\n * @param canvasCoords - The coordinates of the mouse position.\n * @param interactionType - The type of interaction that is taking place.\n * @returns The filtered array containing ToolAndAnnotation\n */\nexport default function filterMoveableAnnotationTools(\n  element: HTMLDivElement,\n  ToolAndAnnotations: ToolAnnotationsPair[],\n  canvasCoords: Types.Point2,\n  interactionType = 'mouse'\n): ToolAnnotationPair[] {\n  const proximity = interactionType === 'touch' ? 36 : 6;\n\n  // TODO - This could get pretty expensive pretty quickly. We don't want to fetch the camera\n  // And do world to canvas on each coord.\n\n  // We want to produce a matrix from canvas to world for the viewport and just do a matrix operation on each handle.\n  // This could still be expensive for ROIs, but we probably shouldn't have \"handles\" for them anyway.\n\n  const moveableAnnotationTools = [];\n\n  ToolAndAnnotations.forEach(({ tool, annotations }) => {\n    for (const annotation of annotations) {\n      if (annotation.isLocked || !annotation.isVisible) {\n        continue;\n      }\n\n      const near = tool.isPointNearTool(\n        element,\n        annotation,\n        canvasCoords,\n        proximity,\n        interactionType\n      );\n\n      if (near) {\n        moveableAnnotationTools.push({\n          tool,\n          annotation,\n        });\n        break;\n      }\n    }\n  });\n\n  return moveableAnnotationTools;\n}\n","/**\n * Mouse This enum enumerates the different buttons returned by `.buttons` on the mouse event.\n * These values are used when setting a tool active in a tool group.\n *\n * See also: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n */\nenum MouseBindings {\n  /** usually the left button */\n  Primary = 1,\n  /** usually the right button */\n  Secondary = 2,\n  Primary_And_Secondary = 3,\n  /** usually mouse wheel button */\n  Auxiliary = 4,\n  Primary_And_Auxiliary = 5,\n  Secondary_And_Auxiliary = 6,\n  Primary_And_Secondary_And_Auxiliary = 7,\n  /** usually \"Browser Back\" button */\n  Fourth_Button = 8,\n  /** usually \"Browser Forward\" button */\n  Fifth_Button = 16,\n}\n\nenum KeyboardBindings {\n  Shift = 16,\n  Ctrl = 17,\n  Alt = 18,\n  Meta = 91,\n  ShiftCtrl = 1617,\n  ShiftAlt = 1618,\n  ShiftMeta = 1691,\n  CtrlAlt = 1718,\n  CtrlMeta = 1791,\n  AltMeta = 1891,\n}\n\nexport { MouseBindings, KeyboardBindings };\n","import { KeyboardBindings as kb } from '../../enums';\n\n/**\n * Gets the mouse modifier key from a mouse event.\n * Supports Shift, Ctrl, Alt, in singly and in combinations of 2\n * Supports Meta singly.\n */\nconst getMouseModifierKey = (evt) => {\n  // The logic is a hard coded key mapping\n  if (evt.shiftKey) {\n    if (evt.ctrlKey) {\n      return kb.ShiftCtrl;\n    }\n    if (evt.altKey) {\n      return kb.ShiftAlt;\n    }\n    if (evt.metaKey) {\n      return kb.ShiftMeta;\n    }\n    return kb.Shift;\n  }\n  if (evt.ctrlKey) {\n    if (evt.altKey) {\n      return kb.CtrlAlt;\n    }\n    if (evt.metaKey) {\n      return kb.CtrlMeta;\n    }\n    return kb.Ctrl;\n  }\n  if (evt.altKey) {\n    return (evt.metaKey && kb.AltMeta) || kb.Alt;\n  }\n  if (evt.metaKey) {\n    return kb.Meta;\n  }\n  return undefined;\n};\n\nexport default getMouseModifierKey;\n","import { ToolGroupManager } from '../../store';\nimport { MouseBindings, ToolModes } from '../../enums';\nimport { keyEventListener } from '../../eventListeners';\nimport { EventTypes } from '../../types';\nimport getMouseModifier from './getMouseModifier';\n\nconst { Active } = ToolModes;\n\n/**\n * Iterate tool group tools until we find a tool that has a \"ToolBinding\"\n * that matches our MouseEvent's `buttons`. It's possible there will be no match\n * (no active tool for that mouse button combination).\n *\n * @param evt - The event dispatcher mouse event.\n *\n * @returns tool\n */\nexport default function getActiveToolForMouseEvent(\n  evt: EventTypes.NormalizedMouseEventType\n) {\n  // Todo: we should refactor this to use getToolsWithModesForMouseEvent instead\n  const { renderingEngineId, viewportId } = evt.detail;\n  const mouseEvent = evt.detail.event;\n\n  // If any keyboard modifier key is also pressed - get the mouse version\n  // first since it handles combinations, while the key event handles non-modifier\n  // keys.\n  const modifierKey =\n    getMouseModifier(mouseEvent) || keyEventListener.getModifierKey();\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    // tool has binding that matches the mouse button, if mouseEvent is undefined\n    // it uses the primary button\n    const correctBinding =\n      toolOptions.bindings.length &&\n      toolOptions.bindings.some((binding) => {\n        return (\n          binding.mouseButton ===\n            (mouseEvent ? mouseEvent.buttons : defaultMousePrimary) &&\n          binding.modifierKey === modifierKey\n        );\n      });\n\n    if (toolOptions.mode === Active && correctBinding) {\n      return toolGroup.getToolInstance(toolName);\n    }\n  }\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\n\n// Util\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport filterMoveableAnnotationTools from '../../store/filterMoveableAnnotationTools';\nimport getToolsWithActionsForMouseEvent from '../shared/getToolsWithActionsForMouseEvent';\n\nconst { Active, Passive } = ToolModes;\n\n/**\n * Look for active or passive annotations with an action that could handle the\n * event based on the bindings and invoke the first one found.\n *\n * @param evt - The normalized mouseDown event.\n * @returns True if an action has executed or false otherwise\n */\nexport default function mouseDownAnnotationAction(\n  evt: EventTypes.MouseDownEventType\n): boolean {\n  // If a tool has locked the current state it is dealing with an interaction within its own eventLoop.\n  if (state.isInteractingWithTool) {\n    return false;\n  }\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { canvas: canvasCoords } = eventDetail.currentPoints;\n\n  if (!enabledElement) {\n    return false;\n  }\n\n  // Find all tools that might respond to this mouse down\n  const toolsWithActions = getToolsWithActionsForMouseEvent(evt, [\n    Active,\n    Passive,\n  ]);\n\n  const tools = Array.from(toolsWithActions.keys());\n\n  // Filter tools with annotations for this element\n  const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(\n    element,\n    tools\n  );\n\n  // Only moveable annotations (unlocked, visible and close to the canvas coordinates) may trigger actions\n  const moveableAnnotationTools = filterMoveableAnnotationTools(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords\n  );\n\n  // If there are annotation tools that are interactable, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (moveableAnnotationTools.length > 0) {\n    const { tool, annotation } = moveableAnnotationTools[0];\n    const action = toolsWithActions.get(tool);\n    const method =\n      typeof action.method === 'string' ? tool[action.method] : action.method;\n\n    method.call(tool, evt, annotation);\n\n    return true;\n  }\n\n  return false;\n}\n","import { state } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\nimport {\n  ToolAnnotationPair,\n  ToolsWithMoveableHandles,\n} from '../../types/InternalToolTypes';\n\nimport {\n  setAnnotationSelected,\n  isAnnotationSelected,\n} from '../../stateManagement/annotation/annotationSelection';\n\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\n\n// Util\nimport filterToolsWithMoveableHandles from '../../store/filterToolsWithMoveableHandles';\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport filterMoveableAnnotationTools from '../../store/filterMoveableAnnotationTools';\nimport getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport getToolsWithModesForMouseEvent from '../shared/getToolsWithModesForMouseEvent';\nimport mouseDownAnnotationAction from './mouseDownAnnotationAction';\n\nconst { Active, Passive } = ToolModes;\n\n/**\n * When the mouse is depressed we check which entities can process these events in the following manner:\n *\n * - First we get the `activeTool` for the mouse button pressed.\n * - If the `activeTool` has a `preMouseDownCallback`, this is called. If the callback returns `true`,\n *   the event does not propagate further.\n * - Next we get all tools which are active or passive (`activeAndPassiveTools`), as annotation. for these tools could\n *   possibly catch and handle these events. We then filter the `activeAndPassiveTools` using `filterToolsWithAnnotationsForElement`, which filters tools with annotations\n *   for this frame of reference. Optionally a tool can employ a further filtering (via a\n *   `filterInteractableAnnotationsForElement` callback) for tools interactable within the current camera view\n *   (e.g. tools that only render when viewed from a certain direction).\n * - Next we check if any handles are interactable for each tool (`filterToolsWithMoveableHandles`). If interactable\n *   handles are found, the first tool/handle found consumes the event and the event does not propagate further.\n * - Next we check any tools are interactable (e.g. moving an entire length annotation rather than one of its handles:\n *   `filterMoveableAnnotationTools`). If interactable tools are found, the first tool found consumes the event and the\n *   event does not propagate further.\n * - If the `activeTool` has `postMouseDownCallback`, this is called.  If the callback returns `true`,\n *   the event does not propagate further.\n * - Finally, look for annotations actions that could handle the event such as showing a dropdown to allow the user\n *   change the magnifying glass zoom factor.\n *\n * If the event is not consumed the event will bubble to the `mouseDownActivate` handler.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseDown(evt: EventTypes.MouseDownEventType) {\n  // If a tool has locked the current state it is dealing with an interaction within its own eventLoop.\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForMouseEvent(evt);\n\n  // Check for preMouseDownCallbacks,\n  // If the tool claims it consumed the event, prevent further checks.\n  if (activeTool && typeof activeTool.preMouseDownCallback === 'function') {\n    const consumedEvent = activeTool.preMouseDownCallback(evt);\n\n    if (consumedEvent) {\n      return;\n    }\n  }\n\n  // Find all tools that might respond to this mouse down\n  const isPrimaryClick = evt.detail.event.buttons === 1;\n  const activeToolsWithEventBinding = getToolsWithModesForMouseEvent(\n    evt,\n    [Active],\n    evt.detail.event.buttons\n  );\n  const passiveToolsIfEventWasPrimaryMouseButton = isPrimaryClick\n    ? getToolsWithModesForMouseEvent(evt, [Passive])\n    : undefined;\n  const applicableTools = [\n    ...(activeToolsWithEventBinding || []),\n    ...(passiveToolsIfEventWasPrimaryMouseButton || []),\n  ];\n\n  // Actions need to run before tool/handle selected callbacks otherwise actions\n  // like the one from SplineTool to remove/add control points would not work.\n  const actionExecuted = mouseDownAnnotationAction(evt);\n\n  if (actionExecuted) {\n    return;\n  }\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Filter tools with annotations for this element\n  const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(\n    element,\n    applicableTools\n  );\n\n  const canvasCoords = eventDetail.currentPoints.canvas;\n\n  // For the canvas coordinates, find all tools that might respond to this mouse down\n  // on their handles. This filter will call getHandleNearImagePoint for each tool\n  // instance (each annotation)\n  const annotationToolsWithMoveableHandles = filterToolsWithMoveableHandles(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'mouse'\n  );\n\n  // Preserve existing selections when shift key is pressed\n  const isMultiSelect = !!evt.detail.event.shiftKey;\n\n  // If there are annotation tools whose handle is near the mouse, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (annotationToolsWithMoveableHandles.length > 0) {\n    const { tool, annotation, handle } = getAnnotationForSelection(\n      annotationToolsWithMoveableHandles\n    ) as ToolsWithMoveableHandles;\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.handleSelectedCallback(evt, annotation, handle, 'Mouse');\n\n    return;\n  }\n\n  // If there were no annotation tools whose handle was near the mouse, try to check\n  // if any of the annotation tools are interactable (e.g. moving an entire length annotation)\n  const moveableAnnotationTools = filterMoveableAnnotationTools(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'mouse'\n  );\n\n  // If there are annotation tools that are interactable, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (moveableAnnotationTools.length > 0) {\n    const { tool, annotation } = getAnnotationForSelection(\n      moveableAnnotationTools\n    );\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.toolSelectedCallback(evt, annotation, 'Mouse', canvasCoords);\n\n    return;\n  }\n\n  // Run the postMouseDownCallback for the active tool if it exists\n  if (activeTool && typeof activeTool.postMouseDownCallback === 'function') {\n    const consumedEvent = activeTool.postMouseDownCallback(evt);\n\n    if (consumedEvent) {\n      // If the tool claims it consumed the event, prevent further checks.\n      return;\n    }\n  }\n\n  // Don't stop propagation so that mouseDownActivate can handle the event\n}\n\n/**\n * If there are multiple annotation tools, return the first one that isn't locked neither hidden.\n * If there's only one annotation tool, return it\n * @param annotationTools - An array of tools and annotation.\n * @returns The candidate for selection\n */\nfunction getAnnotationForSelection(\n  toolsWithMovableHandles: ToolAnnotationPair[]\n): ToolAnnotationPair {\n  return (\n    (toolsWithMovableHandles.length > 1 &&\n      toolsWithMovableHandles.find(\n        (item) =>\n          !isAnnotationLocked(item.annotation) &&\n          isAnnotationVisible(item.annotation.annotationUID)\n      )) ||\n    toolsWithMovableHandles[0]\n  );\n}\n\n/**\n * If the annotation is selected, deselect it. If it's not selected, select it\n * @param annotationUID - The AnnotationUID that we\n * want to toggle the selection of.\n * @param isMultiSelect - If true, the annotation. will be deselected if it is\n * already selected, or deselected if it is selected.\n */\nfunction toggleAnnotationSelection(\n  annotationUID: string,\n  isMultiSelect = false\n): void {\n  if (isMultiSelect) {\n    if (isAnnotationSelected(annotationUID)) {\n      setAnnotationSelected(annotationUID, false);\n    } else {\n      const preserveSelected = true;\n      setAnnotationSelected(annotationUID, true, preserveSelected);\n    }\n  } else {\n    const preserveSelected = false;\n    setAnnotationSelected(annotationUID, true, preserveSelected);\n  }\n}\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { ToolAction, EventTypes } from '../../types';\n\nimport { keyEventListener } from '../../eventListeners';\nimport getMouseModifier from './getMouseModifier';\n\n/**\n * Given the mouse event and a list of tool modes, find all tool instances\n * with actions that were added to the tool group associated with the viewport\n * that triggered the event.\n *\n * @param evt - mouseDown event triggered by a cornerstone viewport\n * @param toolModes - List of tool modes used to filter the tools registered\n *                    in the viewport's tool group\n */\nexport default function getToolsWithActionsForMouseEvent(\n  evt: EventTypes.MouseMoveEventType,\n  toolModes: ToolModes[]\n): Map<any, ToolAction> {\n  const toolsWithActions = new Map();\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return toolsWithActions;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n  const mouseEvent = evt.detail.event;\n  const mouseButton = mouseEvent?.buttons ?? defaultMousePrimary;\n  const modifierKey =\n    getMouseModifier(mouseEvent) || keyEventListener.getModifierKey();\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.getToolInstance(toolName);\n    const actionsConfig = tool.configuration?.actions ?? {};\n    const actions = Object.values(actionsConfig);\n\n    if (!actions?.length || !toolModes.includes(tool.mode)) {\n      continue;\n    }\n\n    const action = actions.find(\n      (action: any) =>\n        action.bindings.length &&\n        action.bindings.some(\n          (binding) =>\n            binding.mouseButton === mouseButton &&\n            binding.modifierKey === modifierKey\n        )\n    );\n\n    if (action) {\n      toolsWithActions.set(tool, action);\n    }\n  }\n\n  return toolsWithActions;\n}\n","import { state } from '../../store';\nimport getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\nimport { EventTypes } from '../../types';\n\n/**\n * If the `mouseDown` handler does not consume an event,\n * activate the creation loop of the active tool, if one is found for the\n * mouse button pressed.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseDownActivate(\n  evt: EventTypes.MouseDownActivateEventType\n) {\n  // If a tool has locked the current state it is dealing with an interaction within its own eventLoop.\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForMouseEvent(evt);\n\n  if (!activeTool) {\n    return;\n  }\n\n  if (state.isMultiPartToolActive) {\n    return;\n  }\n\n  if (activeTool.addNewAnnotation) {\n    const annotation = activeTool.addNewAnnotation(evt, 'mouse');\n    setAnnotationSelected(annotation.annotationUID);\n  }\n}\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * @function mouseDoubleClick - Event handler for mouse double click events. Uses `customCallbackHandler` to fire\n * the `doubleClickCallback` function on active tools.\n */\nconst mouseDoubleClick = customCallbackHandler.bind(\n  null,\n  'Mouse',\n  'doubleClickCallback'\n);\n\nexport default mouseDoubleClick;\n","import getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport { state } from '../../store';\nimport { MouseDragEventType } from '../../types/EventTypes';\n\n/**\n * mouseDrag - Event handler for mouse drag events. Fires the `mouseDragCallback`\n * function on active tools.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseDrag(evt: MouseDragEventType) {\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForMouseEvent(evt);\n\n  const noFoundToolOrDoesNotHaveMouseDragCallback =\n    !activeTool || typeof activeTool.mouseDragCallback !== 'function';\n  if (noFoundToolOrDoesNotHaveMouseDragCallback) {\n    return;\n  }\n\n  activeTool.mouseDragCallback(evt);\n}\n","// // State\nimport { state } from '../../store';\nimport { ToolModes } from '../../enums';\n\n// // Util\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport getToolsWithModesForMouseEvent from '../shared/getToolsWithModesForMouseEvent';\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\nimport { MouseMoveEventType } from '../../types/EventTypes';\n\nconst { Active, Passive } = ToolModes;\n\n/**\n * mouseMove - On mouse move when not dragging, fire tools `mouseMoveCallback`s.\n * This is mostly used to update the [un]hover state\n * of a tool.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseMove(evt: MouseMoveEventType) {\n  // Tool interactions when mouse moved are handled inside each tool.\n  // This function is mostly used to update the [un]hover state\n  if (state.isInteractingWithTool || state.isMultiPartToolActive) {\n    return;\n  }\n\n  const activeAndPassiveTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n  ]);\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Annotation tool specific\n  const toolsWithAnnotations = filterToolsWithAnnotationsForElement(\n    element,\n    activeAndPassiveTools\n  );\n\n  const toolsWithoutAnnotations = activeAndPassiveTools.filter((tool) => {\n    const doesNotHaveAnnotations = !toolsWithAnnotations.some(\n      (toolAndAnnotation) =>\n        toolAndAnnotation.tool.getToolName() === tool.getToolName()\n    );\n\n    return doesNotHaveAnnotations;\n  });\n\n  let annotationsNeedToBeRedrawn = false;\n\n  for (const { tool, annotations } of toolsWithAnnotations) {\n    if (typeof tool.mouseMoveCallback === 'function') {\n      annotationsNeedToBeRedrawn =\n        tool.mouseMoveCallback(evt, annotations) || annotationsNeedToBeRedrawn;\n    }\n  }\n\n  // Run mouse move handlers for non-annotation tools\n  toolsWithoutAnnotations.forEach((tool) => {\n    if (typeof tool.mouseMoveCallback === 'function') {\n      tool.mouseMoveCallback(evt);\n    }\n  });\n\n  // Annotation activation status changed, redraw the annotations\n  if (annotationsNeedToBeRedrawn === true) {\n    triggerAnnotationRender(element);\n  }\n}\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * mouseClick - Event handler for mouse up events. Uses `customCallbackHandler` to fire\n * the `mouseUpCallback` function on active tools.\n */\nconst mouseUp = customCallbackHandler.bind(null, 'Mouse', 'mouseUpCallback');\n\nexport default mouseUp;\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * Event handler for mouse wheel events. Uses `customCallbackHandler` to fire\n * the `mouseWheelCallback` function on active tools.\n */\nconst mouseWheel = customCallbackHandler.bind(\n  null,\n  'MouseWheel',\n  'mouseWheelCallback'\n);\n\nexport default mouseWheel;\n","import Events from '../enums/Events';\n\nimport {\n  mouseClick,\n  mouseDown,\n  mouseDownActivate,\n  mouseDoubleClick,\n  mouseDrag,\n  mouseMove,\n  mouseUp,\n  mouseWheel,\n} from './mouseEventHandlers';\n\n/**\n * Enable these listeners are emitted in order, and can be cancelled/prevented from bubbling\n * by any previous event.\n *\n * @param element - The element to add the event listeners to.\n */\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(Events.MOUSE_CLICK, mouseClick as EventListener);\n  element.addEventListener(Events.MOUSE_DOWN, mouseDown as EventListener);\n  element.addEventListener(\n    Events.MOUSE_DOWN_ACTIVATE,\n    mouseDownActivate as EventListener\n  );\n  element.addEventListener(\n    Events.MOUSE_DOUBLE_CLICK,\n    mouseDoubleClick as EventListener\n  );\n  element.addEventListener(Events.MOUSE_DRAG, mouseDrag as EventListener);\n  element.addEventListener(Events.MOUSE_MOVE, mouseMove as EventListener);\n  element.addEventListener(Events.MOUSE_UP, mouseUp as EventListener);\n  element.addEventListener(Events.MOUSE_WHEEL, mouseWheel as EventListener);\n};\n\n/**\n * Disable and Remove the MouseToolEventDispatcher handlers from the element.\n *\n * @param element - HTMLDivElement\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.MOUSE_CLICK, mouseClick as EventListener);\n  element.removeEventListener(Events.MOUSE_DOWN, mouseDown as EventListener);\n  element.removeEventListener(\n    Events.MOUSE_DOWN_ACTIVATE,\n    mouseDownActivate as EventListener\n  );\n  element.removeEventListener(\n    Events.MOUSE_DOUBLE_CLICK,\n    mouseDoubleClick as EventListener\n  );\n  element.removeEventListener(Events.MOUSE_DRAG, mouseDrag as EventListener);\n  element.removeEventListener(Events.MOUSE_MOVE, mouseMove as EventListener);\n  element.removeEventListener(Events.MOUSE_UP, mouseUp as EventListener);\n  element.removeEventListener(Events.MOUSE_WHEEL, mouseWheel as EventListener);\n};\n\nconst mouseToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default mouseToolEventDispatcher;\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { keyEventListener } from '../../eventListeners';\nimport { EventTypes } from '../../types';\nimport { getMouseButton } from '../../eventListeners/mouse/mouseDownListener';\n\nconst { Active } = ToolModes;\n\n/**\n * Iterate tool group tools until we find a tool that has a \"ToolBinding\"\n * that matches our Keyboard pressed keys. It's possible there will be no match\n * (no active tool for that mouse button combination).\n *\n * @param evt - The normalized keyboard event.\n *\n * @returns tool\n */\nexport default function getActiveToolForKeyboardEvent(\n  evt: EventTypes.KeyDownEventType\n) {\n  const { renderingEngineId, viewportId } = evt.detail;\n\n  // Get the current mouse button clicked\n  const mouseButton = getMouseButton();\n\n  // If any keyboard modifier key is also pressed\n  // TODO - get the real modifier key\n  const modifierKey = keyEventListener.getModifierKey();\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    if (toolOptions.mode !== Active) {\n      continue;\n    }\n    // tool has binding that matches the mouse button, if mouseEvent is undefined\n    // it uses the primary button\n    const correctBinding =\n      toolOptions.bindings.length &&\n      toolOptions.bindings.some(\n        (binding) =>\n          binding.mouseButton === (mouseButton ?? defaultMousePrimary) &&\n          binding.modifierKey === modifierKey\n      );\n\n    if (correctBinding) {\n      return toolGroup.getToolInstance(toolName);\n    }\n  }\n}\n","import { ToolGroupManager } from '../../store';\nimport getActiveToolForKeyboardEvent from '../shared/getActiveToolForKeyboardEvent';\nimport getToolsWithActionsForKeyboardEvent from '../shared/getToolsWithActionsForKeyboardEvents';\nimport { KeyDownEventType } from '../../types/EventTypes';\nimport ToolModes from '../../enums/ToolModes';\n\n/**\n * KeyDown event listener to handle viewport cursor icon changes\n *\n * @param evt - The KeyboardEvent\n */\nexport default function keyDown(evt: KeyDownEventType): void {\n  // get the active tool given the key and mouse button\n  const activeTool = getActiveToolForKeyboardEvent(evt);\n\n  if (activeTool) {\n    const { renderingEngineId, viewportId } = evt.detail;\n\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n      viewportId,\n      renderingEngineId\n    );\n\n    const toolName = activeTool.getToolName();\n    if (Object.keys(toolGroup.toolOptions).includes(toolName)) {\n      toolGroup.setViewportsCursorByToolName(toolName);\n    }\n  }\n\n  const activeToolsWithEventBinding = getToolsWithActionsForKeyboardEvent(evt, [\n    ToolModes.Active,\n  ]);\n\n  if (activeToolsWithEventBinding?.size) {\n    const { element } = evt.detail;\n    for (const [key, value] of [...activeToolsWithEventBinding.entries()]) {\n      // Calls the method that implements the action, which can be a string\n      // in which case it belongs to the tool instance, or a function\n      // Call it on the tool instance, with the element and configuration value\n      // so that the method can depend on the specific configuration in use.\n      const method =\n        typeof value.method === 'function' ? value.method : key[value.method];\n      method.call(key, element, value);\n    }\n  }\n}\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\n\n/**\n * Given the normalized mouse event and a filter of modes,\n * find all the tools on the element that are in one of the specified modes.\n * If the evtButton is specified, only tools with a matching binding will be returned.\n * @param evt - The normalized mouseDown event.\n * @param modesFilter - An array of entries from the `ToolModes` enum.\n */\nexport default function getToolsWithModesForKeyboardEvent(\n  evt: EventTypes.KeyDownEventType,\n  toolModes: ToolModes[]\n) {\n  const toolsWithActions = new Map();\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return toolsWithActions;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n  const key = evt.detail.key;\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.getToolInstance(toolName);\n    const actionsConfig = tool.configuration?.actions;\n    if (!actionsConfig) {\n      continue;\n    }\n    const actions = Object.values(actionsConfig);\n\n    if (!actions?.length || !toolModes.includes(tool.mode)) {\n      continue;\n    }\n\n    const action = actions.find((action: any) =>\n      action.bindings.some((binding) => binding.key === key)\n    );\n\n    if (action) {\n      toolsWithActions.set(tool, action);\n    }\n  }\n\n  return toolsWithActions;\n}\n","import { resetModifierKey } from '../../eventListeners/keyboard/keyDownListener';\nimport { ToolGroupManager } from '../../store';\nimport getActiveToolForKeyboardEvent from '../shared/getActiveToolForKeyboardEvent';\nimport { KeyDownEventType } from '../../types/EventTypes';\n\n/**\n * KeyDown event listener to handle viewport cursor icon changes\n *\n * @param evt - The KeyboardEvent\n */\nexport default function keyUp(evt: KeyDownEventType): void {\n  // get the active tool for the primary mouse button\n  const activeTool = getActiveToolForKeyboardEvent(evt);\n\n  if (!activeTool) {\n    return;\n  }\n\n  const { renderingEngineId, viewportId } = evt.detail;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  // Reset the modifier key\n  resetModifierKey();\n\n  const toolName = activeTool.getToolName();\n  if (Object.keys(toolGroup.toolOptions).includes(toolName)) {\n    toolGroup.setViewportsCursorByToolName(toolName);\n  }\n}\n","import Events from '../enums/Events';\nimport { keyDown, keyUp } from './keyboardEventHandlers';\n\n/**\n * Enable Key down and key up listeners\n *\n * @param element - The HTML element to attach the event listeners to.\n */\nconst enable = function (element: HTMLDivElement) {\n  element.addEventListener(Events.KEY_DOWN, keyDown as EventListener);\n  element.addEventListener(Events.KEY_UP, keyUp as EventListener);\n};\n\n/**\n * Disable Key down and key up listeners\n * @param element - The HTML element to attach the event listeners to.\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.KEY_DOWN, keyDown as EventListener);\n  element.removeEventListener(Events.KEY_UP, keyUp as EventListener);\n};\n\nconst keyboardToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default keyboardToolEventDispatcher;\n","import { ToolGroupManager } from '../../store';\nimport { MouseBindings, ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\nimport getMouseModifier from './getMouseModifier';\nimport { keyEventListener } from '../../eventListeners';\n\nconst { Active } = ToolModes;\n\n/**\n * Iterate tool group tools until we find a tool that has a \"ToolBinding\"\n * that matches our TouchEvent's `buttons`. It's possible there will be no match\n * (no active tool for that touch button combination).\n *\n * @param evt - The event dispatcher touch event.\n *\n * @returns tool\n */\nexport default function getActiveToolForTouchEvent(\n  evt: EventTypes.NormalizedTouchEventType\n) {\n  // Todo: we should refactor this to use getToolsWithModesForTouchEvent instead\n  const { renderingEngineId, viewportId } = evt.detail;\n  const touchEvent = evt.detail.event;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  const numTouchPoints = Object.keys(touchEvent.touches).length;\n\n  // If any keyboard modifier key is also pressed\n  const modifierKey =\n    getMouseModifier(touchEvent) || keyEventListener.getModifierKey();\n  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    const correctBinding =\n      toolOptions.bindings.length &&\n      /**\n       * TODO: setActiveTool treats MouseBindings.Primary in a special way\n       * which is analgous to numTouchPoints === 1 as the primary interaction\n       * for touch based applications. The ToolGroup set active and get active\n       * logic should be updated to account for numTouchPoints === 1\n       */\n      toolOptions.bindings.some(\n        (binding) =>\n          (binding.numTouchPoints === numTouchPoints ||\n            (numTouchPoints === 1 &&\n              binding.mouseButton === defaultMousePrimary)) &&\n          binding.modifierKey === modifierKey\n      );\n\n    if (toolOptions.mode === Active && correctBinding) {\n      return toolGroup.getToolInstance(toolName);\n    }\n  }\n}\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\n\ntype ModesFilter = Array<ToolModes>;\n\n/**\n * Given the normalized touch event and a filter of modes,\n * find all the tools on the element that are in one of the specified modes.\n * If the evtButton is specified, only tools with a matching binding will be returned.\n * @param evt - The normalized touchStart event.\n * @param modesFilter - An array of entries from the `ToolModes` enum.\n */\nexport default function getToolsWithModesForTouchEvent(\n  evt: EventTypes.NormalizedTouchEventType,\n  modesFilter: ModesFilter,\n  numTouchPoints?: number\n) {\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return [];\n  }\n\n  const enabledTools = [];\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.toolOptions[toolName];\n\n    const correctBinding =\n      numTouchPoints != null &&\n      tool.bindings.length &&\n      tool.bindings.some(\n        (binding) => binding.numTouchPoints === numTouchPoints\n      );\n\n    if (\n      modesFilter.includes(tool.mode) &&\n      (!numTouchPoints || correctBinding)\n    ) {\n      const toolInstance = toolGroup.getToolInstance(toolName);\n      enabledTools.push(toolInstance);\n    }\n  }\n\n  return enabledTools;\n}\n","import { state } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\nimport {\n  ToolAnnotationPair,\n  ToolsWithMoveableHandles,\n} from '../../types/InternalToolTypes';\n\nimport {\n  setAnnotationSelected,\n  isAnnotationSelected,\n} from '../../stateManagement/annotation/annotationSelection';\n\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\n\n// Util\nimport filterToolsWithMoveableHandles from '../../store/filterToolsWithMoveableHandles';\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport filterMoveableAnnotationTools from '../../store/filterMoveableAnnotationTools';\nimport getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\nimport getToolsWithModesForTouchEvent from '../shared/getToolsWithModesForTouchEvent';\n\nconst { Active, Passive } = ToolModes;\n\n/**\n * touchStart - Event handler for touchStart events. Uses `customCallbackHandler` to fire\n * the `touchStartCallback` function on active tools.\n */\nexport default function touchStart(evt: EventTypes.TouchStartEventType) {\n  if (state.isInteractingWithTool) {\n    return;\n  }\n  const activeTool = getActiveToolForTouchEvent(evt);\n\n  // Check for preTouchStartCallbacks,\n  // If the tool claims it consumed the event, prevent further checks.\n  if (activeTool && typeof activeTool.preTouchStartCallback === 'function') {\n    const consumedEvent = activeTool.preTouchStartCallback(evt);\n\n    if (consumedEvent) {\n      return;\n    }\n  }\n\n  const isPrimaryClick = Object.keys(evt.detail.event.touches).length === 1;\n  const activeToolsWithEventBinding = getToolsWithModesForTouchEvent(\n    evt,\n    [Active],\n    Object.keys(evt.detail.event.touches).length\n  );\n  const passiveToolsIfEventWasPrimaryTouchButton = isPrimaryClick\n    ? getToolsWithModesForTouchEvent(evt, [Passive])\n    : undefined;\n  const applicableTools = [\n    ...(activeToolsWithEventBinding || []),\n    ...(passiveToolsIfEventWasPrimaryTouchButton || []),\n    activeTool,\n  ];\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Filter tools with annotations for this element\n  const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(\n    element,\n    applicableTools\n  );\n\n  const canvasCoords = eventDetail.currentPoints.canvas;\n\n  // For the canvas coordinates, find all tools that might respond to this touch start\n  // on their handles. This filter will call getHandleNearImagePoint for each tool\n  // instance (each annotation)\n  const annotationToolsWithMoveableHandles = filterToolsWithMoveableHandles(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'touch'\n  );\n\n  const isMultiSelect = false;\n\n  // If there are annotation tools whose handle is near the touch, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (annotationToolsWithMoveableHandles.length > 0) {\n    const { tool, annotation, handle } = getAnnotationForSelection(\n      annotationToolsWithMoveableHandles\n    ) as ToolsWithMoveableHandles;\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.handleSelectedCallback(evt, annotation, handle, 'Touch');\n\n    return;\n  }\n\n  // If there were no annotation tools whose handle was near the touch, try to check\n  // if any of the annotation tools are interactable (e.g. moving an entire length annotation)\n  const moveableAnnotationTools = filterMoveableAnnotationTools(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'touch'\n  );\n\n  // If there are annotation tools that are interactable, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (moveableAnnotationTools.length > 0) {\n    const { tool, annotation } = getAnnotationForSelection(\n      moveableAnnotationTools\n    );\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.toolSelectedCallback(evt, annotation, 'Touch');\n\n    return;\n  }\n\n  // Run the postTouchStartCallback for the active tool if it exists\n  if (activeTool && typeof activeTool.postTouchStartCallback === 'function') {\n    const consumedEvent = activeTool.postTouchStartCallback(evt);\n\n    if (consumedEvent) {\n      // If the tool claims it consumed the event, prevent further checks.\n      return;\n    }\n  }\n\n  // Don't stop propagation so that touchStartActivate can handle the event\n}\n\n/**\n * If there are multiple annotation tools, return the first one that isn't locked neither hidden.\n * If there's only one annotation tool, return it\n * @param annotationTools - An array of tools and annotation.\n * @returns The candidate for selection\n */\nfunction getAnnotationForSelection(\n  toolsWithMovableHandles: ToolAnnotationPair[]\n): ToolAnnotationPair {\n  return (\n    (toolsWithMovableHandles.length > 1 &&\n      toolsWithMovableHandles.find(\n        (item) =>\n          !isAnnotationLocked(item.annotation) &&\n          isAnnotationVisible(item.annotation.annotationUID)\n      )) ||\n    toolsWithMovableHandles[0]\n  );\n}\n\n/**\n * If the annotation is selected, deselect it. If it's not selected, select it\n * @param annotationUID - The AnnotationUID that we\n * want to toggle the selection of.\n * @param isMultiSelect - If true, the annotation. will be deselected if it is\n * already selected, or deselected if it is selected.\n */\nfunction toggleAnnotationSelection(\n  annotationUID: string,\n  isMultiSelect = false\n): void {\n  if (isMultiSelect) {\n    if (isAnnotationSelected(annotationUID)) {\n      setAnnotationSelected(annotationUID, false);\n    } else {\n      const preserveSelected = true;\n      setAnnotationSelected(annotationUID, true, preserveSelected);\n    }\n  } else {\n    const preserveSelected = false;\n    setAnnotationSelected(annotationUID, true, preserveSelected);\n  }\n}\n","import { state } from '../../store';\nimport { EventTypes } from '../../types';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\n\nimport getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\n\n/**\n * If the `touchStart` handler does not consume an event,\n * activate the creation loop of the active tool, if one is found for the\n * touch button pressed.\n *\n * @param evt - The normalized touchStart event.\n */\nexport default function touchStartActivate(\n  evt: EventTypes.TouchStartActivateEventType\n) {\n  // If a tool has locked the current state it is dealing with an interaction within its own eventLoop.\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForTouchEvent(evt);\n\n  if (!activeTool) {\n    return;\n  }\n\n  if (state.isMultiPartToolActive) {\n    return;\n  }\n\n  if (activeTool.addNewAnnotation) {\n    const annotation = activeTool.addNewAnnotation(evt, 'touch');\n    setAnnotationSelected(annotation.annotationUID);\n  }\n}\n","import getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\nimport { state } from '../../store';\nimport { TouchDragEventType } from '../../types/EventTypes';\n\n/**\n * touchDrag - Event handler for touchDrag events. Uses `customCallbackHandler` to fire\n * the `touchDragCallback` function on active tools.\n */\nexport default function touchDrag(evt: TouchDragEventType) {\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForTouchEvent(evt);\n\n  const noFoundToolOrDoesNotHaveTouchDragCallback =\n    !activeTool || typeof activeTool.touchDragCallback !== 'function';\n  if (noFoundToolOrDoesNotHaveTouchDragCallback) {\n    return;\n  }\n\n  activeTool.touchDragCallback(evt);\n}\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * touchEnd - Event handler for touchEnd events. Uses `customCallbackHandler` to fire\n * the `touchEndCallback` function on active tools.\n */\nconst touchEnd = customCallbackHandler.bind(null, 'Touch', 'touchEndCallback');\n\nexport default touchEnd;\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * touchTap - Event handler for touch tap events. Uses `customCallbackHandler` to fire\n * the `touchTapCallback` function on active tools.\n */\nconst touchTap = customCallbackHandler.bind(null, 'Touch', 'touchTapCallback');\n\nexport default touchTap;\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * touchPress - Event handler for touch press events. Uses `customCallbackHandler` to fire\n * the `touchPressCallback` function on active tools.\n */\nconst touchPress = customCallbackHandler.bind(\n  null,\n  'Touch',\n  'touchPressCallback'\n);\n\nexport default touchPress;\n","import Events from '../enums/Events';\n\nimport {\n  touchStart,\n  touchStartActivate,\n  touchDrag,\n  touchEnd,\n  touchTap,\n  touchPress,\n} from './touchEventHandlers';\n\n/**\n * Enable these listeners are emitted in order, and can be cancelled/prevented from bubbling\n * by any previous event.\n *\n * @param element - The element to add the event listeners to.\n */\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(Events.TOUCH_START, touchStart as EventListener);\n  element.addEventListener(\n    Events.TOUCH_START_ACTIVATE,\n    touchStartActivate as EventListener\n  );\n  element.addEventListener(Events.TOUCH_DRAG, touchDrag as EventListener);\n  element.addEventListener(Events.TOUCH_END, touchEnd as EventListener);\n  element.addEventListener(Events.TOUCH_TAP, touchTap as EventListener);\n  element.addEventListener(Events.TOUCH_PRESS, touchPress as EventListener);\n};\n\n/**\n * Disable and Remove the MouseToolEventDispatcher handlers from the element.\n *\n * @param element - HTMLDivElement\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.TOUCH_START, touchStart as EventListener);\n  element.removeEventListener(\n    Events.TOUCH_START_ACTIVATE,\n    touchStartActivate as EventListener\n  );\n  element.removeEventListener(Events.TOUCH_DRAG, touchDrag as EventListener);\n  element.removeEventListener(Events.TOUCH_END, touchEnd as EventListener);\n  element.removeEventListener(Events.TOUCH_PRESS, touchPress as EventListener);\n};\n\nconst touchToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default touchToolEventDispatcher;\n","import { Types } from '@cornerstonejs/core';\nimport {\n  mouseEventListeners,\n  wheelEventListener,\n  touchEventListeners,\n  keyEventListener,\n  imageChangeEventListener,\n} from '../eventListeners';\nimport {\n  imageRenderedEventDispatcher,\n  cameraModifiedEventDispatcher,\n  mouseToolEventDispatcher,\n  touchToolEventDispatcher,\n  keyboardToolEventDispatcher,\n  imageSpacingCalibratedEventDispatcher,\n} from '../eventDispatchers';\nimport { state } from './state';\n\nimport { annotationRenderingEngine } from '../utilities/triggerAnnotationRender';\n\n/**\n * When an element is \"enabled\", add event listeners and dispatchers to it\n * so we can use interactions to affect tool behaviors\n *\n * @param evt - The ELEMENT_ENABLED event\n */\nexport default function addEnabledElement(\n  evt: Types.EventTypes.ElementEnabledEvent\n): void {\n  const { element, viewportId } = evt.detail;\n  const svgLayer = _createSvgAnnotationLayer(viewportId);\n\n  // Reset/Create svgNodeCache for element\n  _setSvgNodeCache(element);\n  _appendChild(svgLayer, element);\n\n  // Add this element to the annotation rendering engine\n  annotationRenderingEngine.addViewportElement(viewportId, element);\n\n  // Listeners\n  mouseEventListeners.enable(element);\n  wheelEventListener.enable(element);\n  touchEventListeners.enable(element);\n  keyEventListener.enable(element);\n  imageChangeEventListener.enable(element);\n\n  // Dispatchers: renderer\n  imageRenderedEventDispatcher.enable(element);\n  cameraModifiedEventDispatcher.enable(element);\n  imageSpacingCalibratedEventDispatcher.enable(element);\n  // Dispatchers: interaction\n  mouseToolEventDispatcher.enable(element);\n  keyboardToolEventDispatcher.enable(element);\n  touchToolEventDispatcher.enable(element);\n\n  // labelmap\n  // State\n  state.enabledElements.push(element);\n}\n\n/**\n *\n */\nfunction _createSvgAnnotationLayer(viewportId: string): SVGElement {\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgLayer = document.createElementNS(svgns, 'svg');\n\n  const svgLayerId = `svg-layer-${viewportId}`;\n  svgLayer.classList.add('svg-layer');\n  svgLayer.setAttribute('id', svgLayerId);\n  svgLayer.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n  svgLayer.style.width = '100%';\n  svgLayer.style.height = '100%';\n  svgLayer.style.pointerEvents = 'none';\n  svgLayer.style.position = 'absolute';\n  // TODO: we should test this on high-res monitors\n  //svgLayer.style.textRendering = 'optimizeSpeed'\n\n  // Single dropshadow config for now\n  const defs = document.createElementNS(svgns, 'defs');\n  const filter = document.createElementNS(svgns, 'filter');\n  const feOffset = document.createElementNS(svgns, 'feOffset');\n  const feColorMatrix = document.createElementNS(svgns, 'feColorMatrix');\n  const feBlend = document.createElementNS(svgns, 'feBlend');\n\n  //\n  filter.setAttribute('id', `shadow-${svgLayerId}`);\n  filter.setAttribute('filterUnits', 'userSpaceOnUse');\n\n  //\n  feOffset.setAttribute('result', 'offOut');\n  feOffset.setAttribute('in', 'SourceGraphic');\n  feOffset.setAttribute('dx', '0.5');\n  feOffset.setAttribute('dy', '0.5');\n\n  //\n  feColorMatrix.setAttribute('result', 'matrixOut');\n  feColorMatrix.setAttribute('in', 'offOut');\n  feColorMatrix.setAttribute('in2', 'matrix');\n  feColorMatrix.setAttribute(\n    'values',\n    '0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0'\n  );\n\n  //\n  feBlend.setAttribute('in', 'SourceGraphic');\n  feBlend.setAttribute('in2', 'matrixOut');\n  feBlend.setAttribute('mode', 'normal');\n\n  filter.appendChild(feOffset);\n  filter.appendChild(feColorMatrix);\n  filter.appendChild(feBlend);\n  defs.appendChild(filter);\n  svgLayer.appendChild(defs);\n\n  return svgLayer;\n}\n\nfunction _setSvgNodeCache(element) {\n  const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } =\n    element.dataset;\n  const elementHash = `${viewportId}:${renderingEngineId}`;\n\n  // Create or reset\n  // TODO: If... Reset, we should blow out any nodes in DOM\n  state.svgNodeCache[elementHash] = {};\n}\n\n/**\n *\n * @param newNode\n * @param referenceNode\n */\nfunction _appendChild(\n  newNode: SVGElement,\n  referenceNode: HTMLDivElement\n): void {\n  referenceNode.querySelector('div.viewport-element').appendChild(newNode);\n}\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * It returns all synchronizers that are not disabled and have a source viewport\n * with the given rendering engine Id and viewport Id\n * @param renderingEngineId - The Id of the rendering engine\n * @param viewportId - The Id of the viewport\n * @returns An array of synchronizers\n */\nfunction getSynchronizersForViewport(\n  viewportId: string,\n  renderingEngineId: string\n): Array<Synchronizer> {\n  const synchronizersFilteredByIds = [];\n\n  if (!renderingEngineId && !viewportId) {\n    throw new Error(\n      'At least one of renderingEngineId or viewportId should be given'\n    );\n  }\n\n  for (let i = 0; i < state.synchronizers.length; i++) {\n    const synchronizer = state.synchronizers[i];\n    const notDisabled = !synchronizer.isDisabled();\n    const hasSourceViewport = synchronizer.hasSourceViewport(\n      renderingEngineId,\n      viewportId\n    );\n\n    const hasTargetViewport = synchronizer.hasTargetViewport(\n      renderingEngineId,\n      viewportId\n    );\n\n    if (notDisabled && (hasSourceViewport || hasTargetViewport)) {\n      synchronizersFilteredByIds.push(synchronizer);\n    }\n  }\n\n  return synchronizersFilteredByIds;\n}\n\nexport default getSynchronizersForViewport;\n","import { getEnabledElement, Types } from '@cornerstonejs/core';\nimport {\n  mouseEventListeners,\n  wheelEventListener,\n  touchEventListeners,\n  keyEventListener,\n} from '../eventListeners';\nimport {\n  imageRenderedEventDispatcher,\n  cameraModifiedEventDispatcher,\n  mouseToolEventDispatcher,\n  keyboardToolEventDispatcher,\n  imageSpacingCalibratedEventDispatcher,\n  touchToolEventDispatcher,\n} from '../eventDispatchers';\n// ~~\n\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\nimport { state } from './state';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport { ToolModes } from '../enums';\nimport { removeAnnotation } from '../stateManagement';\nimport getSynchronizersForViewport from './SynchronizerManager/getSynchronizersForViewport';\nimport getToolGroupForViewport from './ToolGroupManager/getToolGroupForViewport';\nimport { annotationRenderingEngine } from '../utilities/triggerAnnotationRender';\nimport imageChangeEventListener from '../eventListeners/segmentation/imageChangeEventListener';\n\nconst VIEWPORT_ELEMENT = 'viewport-element';\n\nfunction removeEnabledElement(\n  elementDisabledEvt: Types.EventTypes.ElementDisabledEvent\n): void {\n  // Is DOM element\n  const { element, viewportId } = elementDisabledEvt.detail;\n\n  _resetSvgNodeCache(element);\n  _removeSvgNode(element);\n\n  // Remove this element from the annotation rendering engine\n  annotationRenderingEngine.removeViewportElement(viewportId, element);\n\n  // Listeners\n  mouseEventListeners.disable(element);\n  wheelEventListener.disable(element);\n  touchEventListeners.disable(element);\n  keyEventListener.disable(element);\n\n  // labelmap\n  imageChangeEventListener.disable(element);\n\n  // Dispatchers: renderer\n  imageRenderedEventDispatcher.disable(element);\n  cameraModifiedEventDispatcher.disable(element);\n  imageSpacingCalibratedEventDispatcher.disable(element);\n  // Dispatchers: interaction\n  mouseToolEventDispatcher.disable(element);\n  keyboardToolEventDispatcher.disable(element);\n  touchToolEventDispatcher.disable(element);\n\n  // State\n  // @TODO: We used to \"disable\" the tool before removal. Should we preserve the hook that would call on tools?\n  _removeViewportFromSynchronizers(element);\n  _removeViewportFromToolGroup(element);\n\n  // _removeAllToolsForElement(canvas)\n  _removeEnabledElement(element);\n}\n\nconst _removeViewportFromSynchronizers = (element: HTMLDivElement) => {\n  const enabledElement = getEnabledElement(element);\n\n  const synchronizers = getSynchronizersForViewport(\n    enabledElement.viewportId,\n    enabledElement.renderingEngineId\n  );\n  synchronizers.forEach((sync) => {\n    sync.remove(enabledElement);\n  });\n};\n\nconst _removeViewportFromToolGroup = (element: HTMLDivElement) => {\n  const { renderingEngineId, viewportId } = getEnabledElement(element);\n\n  const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n\n  if (toolGroup) {\n    toolGroup.removeViewports(renderingEngineId, viewportId);\n  }\n};\n\nconst _removeAllToolsForElement = function (element) {\n  const tools = getToolsWithModesForElement(element, [\n    ToolModes.Active,\n    ToolModes.Passive,\n  ]);\n\n  const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n  toolsWithData.forEach(({ annotations }) => {\n    annotations.forEach((annotation) => {\n      removeAnnotation(annotation.annotationUID);\n    });\n  });\n};\n\nfunction _resetSvgNodeCache(element: HTMLDivElement) {\n  const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } =\n    element.dataset;\n  const elementHash = `${viewportId}:${renderingEngineId}`;\n\n  delete state.svgNodeCache[elementHash];\n}\n\nfunction _removeSvgNode(element: HTMLDivElement) {\n  const internalViewportNode = element.querySelector(`div.${VIEWPORT_ELEMENT}`);\n  const svgLayer = internalViewportNode.querySelector('svg');\n  if (svgLayer) {\n    internalViewportNode.removeChild(svgLayer);\n  }\n}\n\n/**\n * @private\n * @param enabledElement\n */\nconst _removeEnabledElement = function (element: HTMLDivElement) {\n  const foundElementIndex = state.enabledElements.findIndex(\n    (el) => el === element\n  );\n\n  if (foundElementIndex > -1) {\n    state.enabledElements.splice(foundElementIndex, 1);\n  }\n};\n\nexport default removeEnabledElement;\n","import type { Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\n\nexport function triggerAnnotationRenderForViewportIds(\n  renderingEngine: Types.IRenderingEngine,\n  viewportIdsToRender: string[]\n): void {\n  if (!viewportIdsToRender.length) {\n    return;\n  }\n\n  viewportIdsToRender.forEach((viewportId) => {\n    const { element } = renderingEngine.getViewport(viewportId);\n    triggerAnnotationRender(element);\n  });\n}\n\nexport default triggerAnnotationRenderForViewportIds;\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\n/**\n * This is a callback function that is called when an annotation is modified.\n * Since we are throttling the cachedStats calculation for annotation tools,\n * we need to trigger a final render for the annotation. so that the annotation\n * textBox is updated.\n * Todo: This will trigger all the annotation tools to re-render, although DOM\n * will update those that have changed, but more efficient would be to only\n * update the changed annotation.\n * Todo: A better way is to extract the textBox render logic from the renderAnnotation\n * of all tools and just trigger a render for that (instead of the entire annotation., even if\n * no svg update happens since the attributes for handles are the same)\n */\nfunction annotationModifiedListener(evt): void {\n  const { viewportId, renderingEngineId } = evt.detail;\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n  triggerAnnotationRenderForViewportIds(renderingEngine, [viewportId]);\n}\n\nexport default annotationModifiedListener;\n","import { getRenderingEngines } from '@cornerstonejs/core';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\n\n/**\n * When an annotation is deselected, trigger an annotation render for all viewports.\n * The reason for this is that, drawing an annotation in a different viewport\n * should deselect all other annotations in other viewports. In order to achieve\n * this, we need to trigger an annotation render for all viewports.\n * Todo: Although this is inefficient, but since annotations are only rendered if necessary,\n * it's probably not going to have a noticeable impact on performance.\n * @param evt - The event object.\n */\nfunction annotationSelectionListener(evt): void {\n  const deselectedAnnotation = evt.detail.removed;\n\n  if (!deselectedAnnotation.length) {\n    return;\n  }\n\n  const renderingEngines = getRenderingEngines();\n\n  renderingEngines.forEach((renderingEngine) => {\n    const viewports = renderingEngine.getViewports();\n    const viewportIds = viewports.map((vp) => vp.id);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n  });\n}\n\nexport default annotationSelectionListener;\n","import { SegmentationModifiedEventType } from '../../types/EventTypes';\nimport {\n  getToolGroupIdsWithSegmentation,\n  getSegmentationRepresentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationRepresentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\n\n/** A function that listens to the `segmentationModified` event and triggers\n * the triggerSegmentationRepresentationModified on each toolGroup that\n * has a representation of the given segmentationId.\n */\nconst segmentationModifiedListener = function (\n  evt: SegmentationModifiedEventType\n): void {\n  const { segmentationId } = evt.detail;\n\n  const toolGroupIds = getToolGroupIdsWithSegmentation(segmentationId);\n\n  toolGroupIds.forEach((toolGroupId) => {\n    const segRepresentations = getSegmentationRepresentations(toolGroupId);\n    segRepresentations.forEach((representation) => {\n      if (representation.segmentationId === segmentationId) {\n        triggerSegmentationRepresentationModified(\n          toolGroupId,\n          representation.segmentationRepresentationUID\n        );\n      }\n    });\n  });\n};\n\nexport default segmentationModifiedListener;\n","import {\n  cache,\n  getEnabledElementByIds,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\n\nimport triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../stateManagement/segmentation/segmentationState';\nimport { SegmentationDataModifiedEventType } from '../../types/EventTypes';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\nimport { getToolGroup } from '../../store/ToolGroupManager';\n\n/** A callback function that is called when the segmentation data is modified which\n *  often is as a result of tool interactions e.g., scissors, eraser, etc.\n */\nconst onSegmentationDataModified = function (\n  evt: SegmentationDataModifiedEventType\n): void {\n  const { segmentationId, modifiedSlicesToUse } = evt.detail;\n\n  const { representationData, type } =\n    SegmentationState.getSegmentation(segmentationId);\n\n  const toolGroupIds =\n    SegmentationState.getToolGroupIdsWithSegmentation(segmentationId);\n\n  if (type !== SegmentationRepresentations.Labelmap) {\n    throw new Error(\n      `onSegmentationDataModified: representationType ${type} not supported yet`\n    );\n  }\n\n  if (isVolumeSegmentation(representationData[type])) {\n    // get the volume from cache, we need the openGLTexture to be updated to GPU\n    const segmentationVolume = cache.getVolume(\n      (representationData[type] as LabelmapSegmentationDataVolume).volumeId\n    );\n\n    if (!segmentationVolume) {\n      console.warn('segmentation not found in cache');\n      return;\n    }\n\n    const { imageData, vtkOpenGLTexture } = segmentationVolume;\n\n    // Update the texture for the volume in the GPU\n    let slicesToUpdate;\n    if (modifiedSlicesToUse && Array.isArray(modifiedSlicesToUse)) {\n      slicesToUpdate = modifiedSlicesToUse;\n    } else {\n      const numSlices = imageData.getDimensions()[2];\n      slicesToUpdate = [...Array(numSlices).keys()];\n    }\n\n    slicesToUpdate.forEach((i) => {\n      vtkOpenGLTexture.setUpdatedFrame(i);\n    });\n\n    // Trigger modified on the imageData to update the image\n    imageData.modified();\n  } else {\n    toolGroupIds.forEach((toolGroupId) => {\n      const toolGroupSegmentationRepresentations =\n        SegmentationState.getSegmentationRepresentations(toolGroupId);\n\n      const toolGroup = getToolGroup(toolGroupId);\n      const viewportsInfo = toolGroup.getViewportsInfo();\n\n      toolGroupSegmentationRepresentations.forEach((representation) => {\n        if (representation.segmentationId !== segmentationId) {\n          return;\n        }\n\n        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n          const viewport = getEnabledElementByIds(\n            viewportId,\n            renderingEngineId\n          ).viewport;\n\n          const actorEntry = viewport.getActor(\n            representation.segmentationRepresentationUID\n          );\n\n          if (!actorEntry) {\n            return;\n          }\n\n          const currentImageId = viewport.getCurrentImageId();\n\n          const segImageData = actorEntry.actor.getMapper().getInputData();\n\n          const { imageIdReferenceMap } = representationData[\n            type\n          ] as LabelmapSegmentationDataStack;\n\n          const currentSegmentationImageId =\n            imageIdReferenceMap.get(currentImageId);\n\n          const segmentationImage = cache.getImage(currentSegmentationImageId);\n          segImageData.modified();\n\n          // update the cache with the new image data\n          csUtils.updateVTKImageDataWithCornerstoneImage(\n            segImageData,\n            segmentationImage\n          );\n        });\n      });\n    });\n  }\n\n  toolGroupIds.forEach((toolGroupId) => {\n    triggerSegmentationRender(toolGroupId);\n  });\n};\n\nexport default onSegmentationDataModified;\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport { SegmentationRepresentationModifiedEventType } from '../../types/EventTypes';\n\n/** A function that listens to the `segmentationStateModified` event and triggers\n * the `triggerSegmentationRender` function. This function is called when the\n * segmentation state or config is modified.\n */\nconst segmentationRepresentationModifiedListener = function (\n  evt: SegmentationRepresentationModifiedEventType\n): void {\n  const { toolGroupId } = evt.detail;\n  triggerSegmentationRender(toolGroupId);\n};\n\nexport default segmentationRepresentationModifiedListener;\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport { SegmentationRepresentationRemovedEventType } from '../../types/EventTypes';\n\n/** A function that listens to the `segmentationRepresentationRemoved` event and triggers\n * the `triggerSegmentationRender` function. This function is called when the\n * segmentation state or config is modified.\n */\nconst segmentationRepresentationRemovedEventListener = function (\n  evt: SegmentationRepresentationRemovedEventType\n): void {\n  const { toolGroupId, segmentationRepresentationUID } = evt.detail;\n\n  triggerSegmentationRender(toolGroupId);\n};\n\nexport default segmentationRepresentationRemovedEventListener;\n","import SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { labelmapDisplay } from '../../tools/displayTools/Labelmap';\nimport { contourDisplay } from '../../tools/displayTools/Contour';\n\nimport {\n  getSegmentationRepresentations,\n  getSegmentationRepresentationByUID,\n} from './segmentationState';\n\n/**\n * Remove the segmentation representation (representation) from the viewports of the toolGroup.\n * @param toolGroupId - The Id of the toolGroup to remove the segmentation from.\n * @param segmentationRepresentationUIDs - The UIDs of the segmentation representations to remove.\n * @param immediate - if True the viewport will be re-rendered immediately.\n */\nfunction removeSegmentationsFromToolGroup(\n  toolGroupId: string,\n  segmentationRepresentationUIDs?: string[] | undefined,\n  immediate?: boolean\n): void {\n  const toolGroupSegRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  if (\n    !toolGroupSegRepresentations ||\n    toolGroupSegRepresentations.length === 0\n  ) {\n    return;\n  }\n\n  const toolGroupSegRepresentationUIDs = toolGroupSegRepresentations.map(\n    (representation) => representation.segmentationRepresentationUID\n  );\n\n  let segRepresentationUIDsToRemove = segmentationRepresentationUIDs;\n  if (segRepresentationUIDsToRemove) {\n    // make sure the segmentationDataUIDs that are going to be removed belong\n    // to the toolGroup\n    const invalidSegRepresentationUIDs = segmentationRepresentationUIDs.filter(\n      (segRepresentationUID) =>\n        !toolGroupSegRepresentationUIDs.includes(segRepresentationUID)\n    );\n\n    if (invalidSegRepresentationUIDs.length > 0) {\n      throw new Error(\n        `The following segmentationRepresentationUIDs are not part of the toolGroup: ${JSON.stringify(\n          invalidSegRepresentationUIDs\n        )}`\n      );\n    }\n  } else {\n    // remove all segmentation representations\n    segRepresentationUIDsToRemove = toolGroupSegRepresentationUIDs;\n  }\n\n  segRepresentationUIDsToRemove.forEach((segmentationDataUID) => {\n    _removeSegmentation(toolGroupId, segmentationDataUID, immediate);\n  });\n}\n\nfunction _removeSegmentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  immediate?: boolean\n): void {\n  const segmentationRepresentation = getSegmentationRepresentationByUID(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  const { type } = segmentationRepresentation;\n\n  if (type === SegmentationRepresentations.Labelmap) {\n    labelmapDisplay.removeSegmentationRepresentation(\n      toolGroupId,\n      segmentationRepresentationUID,\n      immediate\n    );\n  } else if (type === SegmentationRepresentations.Contour) {\n    contourDisplay.removeSegmentationRepresentation(\n      toolGroupId,\n      segmentationRepresentationUID,\n      immediate\n    );\n  } else {\n    throw new Error(`The representation ${type} is not supported yet`);\n  }\n}\n\nexport default removeSegmentationsFromToolGroup;\n","import { state } from '../index';\nimport { removeSegmentationsFromToolGroup } from '../../stateManagement/segmentation';\nimport { segmentationRenderingEngine } from '../../utilities/segmentation/triggerSegmentationRender';\n// ToolGroups function entirely by their \"state\" being queried and leveraged\n// removing a ToolGroup from state is equivalent to killing it\n\n/**\n * Given a tool group Id, destroy the toolGroup. It will also cleanup all segmentations\n * associated with that tool group too\n *\n * @param toolGroupId - The Id of the tool group to be destroyed.\n */\nfunction destroyToolGroup(toolGroupId: string): void {\n  const toolGroupIndex = state.toolGroups.findIndex(\n    (tg) => tg.id === toolGroupId\n  );\n\n  if (toolGroupIndex > -1) {\n    segmentationRenderingEngine.removeToolGroup(toolGroupId);\n    // Todo: this should not happen here)\n    removeSegmentationsFromToolGroup(toolGroupId);\n    state.toolGroups.splice(toolGroupIndex, 1);\n  }\n}\n\nexport default destroyToolGroup;\n","// `BaseManager` or IManager interface for duplicate API between ToolGroup/Synchronizer?\nimport { state as csToolsState } from '../index';\nimport destroyToolGroup from './destroyToolGroup';\n\n// ToolGroups function entirely by their \"state\" being queried and leveraged\n// removing a ToolGroup from state is equivalent to killing it. Calling\n// destroyToolGroup() to make sure the SegmentationDisplayTools\n// have been removed from the toolGroup Viewports. //Todo: this makes more sense\n// to be based on events, but we don't have any toolGroup created/removed events\n\n/**\n * Destroy all tool groups\n */\nfunction destroy(): void {\n  const toolGroups = [...csToolsState.toolGroups];\n\n  for (const toolGroup of toolGroups) {\n    destroyToolGroup(toolGroup.id);\n  }\n\n  csToolsState.toolGroups = [];\n}\n\nexport default destroy;\n","import { eventTarget, Enums } from '@cornerstonejs/core';\nimport { getAnnotationManager } from './stateManagement/annotation/annotationState';\nimport { getDefaultSegmentationStateManager } from './stateManagement/segmentation/segmentationState';\nimport { Events as TOOLS_EVENTS } from './enums';\nimport { addEnabledElement, removeEnabledElement } from './store';\nimport { resetCornerstoneToolsState } from './store/state';\nimport {\n  annotationSelectionListener,\n  segmentationDataModifiedEventListener,\n  segmentationRepresentationModifiedEventListener,\n  segmentationRepresentationRemovedEventListener,\n  segmentationModifiedListener,\n  annotationModifiedListener,\n} from './eventListeners';\n\nimport * as ToolGroupManager from './store/ToolGroupManager';\n\nlet csToolsInitialized = false;\n\n/**\n * Initialize the cornerstoneTools package. It will add event listeners for mouse\n * and keyboard events.\n * @param defaultConfiguration - A configuration object that will be used to\n * initialize the tool.\n */\nexport function init(defaultConfiguration = {}): void {\n  if (csToolsInitialized) {\n    return;\n  }\n\n  _addCornerstoneEventListeners();\n  _addCornerstoneToolsEventListeners();\n\n  csToolsInitialized = true;\n}\n\n/**\n * It destroys and cleanup state for cornerstone3DTools. It removes all the tools\n * that were added to the tool groups and restore states. It also removes all\n * event listeners.\n */\nexport function destroy(): void {\n  _removeCornerstoneEventListeners();\n  _removeCornerstoneToolsEventListeners();\n\n  // Important: destroy ToolGroups first, in order for cleanup to work correctly for the\n  // added tools.\n  ToolGroupManager.destroy();\n\n  // Remove all tools\n  resetCornerstoneToolsState();\n\n  // remove all annotation.\n  const annotationManager = getAnnotationManager();\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  annotationManager.restoreAnnotations({});\n  segmentationStateManager.resetState();\n  csToolsInitialized = false;\n}\n\n/**\n * Wires up event listeners for the Cornerstone#ElementDisabled and\n * Cornerstone#ElementEnabled events.\n *\n * @internal\n */\nfunction _addCornerstoneEventListeners(): void {\n  // Clear any listeners that may already be set\n  _removeCornerstoneEventListeners();\n\n  const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n  const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n\n  eventTarget.addEventListener(elementEnabledEvent, addEnabledElement);\n  eventTarget.addEventListener(elementDisabledEvent, removeEnabledElement);\n}\n\n/**\n * Removes event listeners for the Cornerstone#ElementDisabled and\n * Cornerstone#ElementEnabled events.\n *\n */\nfunction _removeCornerstoneEventListeners(): void {\n  const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n  const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n\n  eventTarget.removeEventListener(elementEnabledEvent, addEnabledElement);\n  eventTarget.removeEventListener(elementDisabledEvent, removeEnabledElement);\n}\n\n/**\n * It adds an event listener to the event target (the cornerstoneTools object) for\n * the annotation selected and annotation modified events.\n */\nfunction _addCornerstoneToolsEventListeners() {\n  // Clear any listeners that may already be set\n  _removeCornerstoneToolsEventListeners();\n\n  /**\n   * Annotation\n   */\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_MODIFIED,\n    annotationModifiedListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  /**\n   * Segmentation\n   */\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_MODIFIED,\n    segmentationModifiedListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED,\n    segmentationDataModifiedEventListener\n  );\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED,\n    segmentationRepresentationModifiedEventListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_REMOVED,\n    segmentationRepresentationRemovedEventListener\n  );\n}\n\n/**\n * Remove the event listener for the the annotation selected and annotation modified events.\n */\nfunction _removeCornerstoneToolsEventListeners() {\n  /**\n   * Annotation\n   */\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_MODIFIED,\n    annotationModifiedListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  /**\n   * Segmentation\n   */\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_MODIFIED,\n    segmentationModifiedListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED,\n    segmentationDataModifiedEventListener\n  );\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED,\n    segmentationRepresentationModifiedEventListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_REMOVED,\n    segmentationRepresentationRemovedEventListener\n  );\n}\n\nexport default init;\n","import { state } from './state';\n\n/**\n * Adds the tool class to the cornerstoneTools to be used later. This function\n * should be called before creating the toolGroups and adding tools and setting their mode.\n * The flow is:\n * - addTool(ToolClass) // where ToolClass is the tool constructor imported from CornerstoneTools or created by a 3rd party\n * - createToolGroup(toolGroupId)\n * - toolGroup.addTool(${toolName}) // NOT THE TOOL CLASS\n * - toolGroup.setToolActive(${toolName})\n *\n * @param ToolClass - A tool calls to instantiate.\n * @param toolOptions - The tool-specific configuration options for the tool.\n * @returns\n */\nexport function addTool(ToolClass): void {\n  // Check if tool exists and name is not undefined\n  const toolName = ToolClass.toolName;\n  const toolAlreadyAdded = state.tools[toolName] !== undefined;\n\n  if (!toolName) {\n    throw new Error(`No Tool Found for the ToolClass ${ToolClass.name}`);\n  }\n\n  if (toolAlreadyAdded) {\n    throw new Error(`${toolName} has already been added globally`);\n  }\n\n  // Stores the toolNames and ToolClass to be instantiated in the toolGroup on toolGroup.addTool\n  state.tools[toolName] = {\n    toolClass: ToolClass,\n  };\n}\n\n/**\n * Removes the tool class from the cornerstoneTools.\n *\n * @param ToolClass - A tool calls to instantiate.\n */\nexport function removeTool(ToolClass): void {\n  const toolName = ToolClass.toolName;\n\n  if (!toolName) {\n    throw new Error(`No tool found for: ${ToolClass.name}`);\n  }\n\n  if (!state.tools[toolName] !== undefined) {\n    delete state.tools[toolName];\n  } else {\n    throw new Error(\n      `${toolName} cannot be removed because it has not been added`\n    );\n  }\n}\n\nexport default addTool;\n","import { ToolModes } from '../enums';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\n\n/**\n * Cancel the current active manipulation that is being performed on the provided\n * element. It filters all the active and passive tools for the enabledElement\n * and calls cancel() method for all of them, and returns the tool that has executed its\n * cancellation (returned its annotationUID), since tools that are not being manipulated will\n * short circuit early. Note: not all tools currently implement a cancel method.\n *\n * @param element - canvas element\n * @returns annotationUID that is cancelled\n */\nexport default function cancelActiveManipulations(\n  element: HTMLDivElement\n): string | undefined {\n  const tools = getToolsWithModesForElement(element, [\n    ToolModes.Active,\n    ToolModes.Passive,\n  ]);\n\n  const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n  for (const { tool } of toolsWithData) {\n    const annotationUID = tool.cancel(element);\n    if (annotationUID) {\n      return annotationUID;\n    }\n  }\n}\n","import {\n  getRenderingEngine,\n  getEnabledElement,\n  Enums,\n  Types,\n} from '@cornerstonejs/core';\n\nimport { ISynchronizerEventHandler } from '../../types';\n\n/**\n * Synchronizer is a class that listens to a specific event on a specific source\n * targets and fires a specific event on a specific target elements. Use cases\n * include: synchronizing a camera between two viewports, synchronizing a\n * windowLevel between various viewports.\n */\nclass Synchronizer {\n  //\n  private _enabled: boolean;\n  private _eventName: string;\n  private _auxiliaryEventNames: string[];\n  private _eventHandler: ISynchronizerEventHandler;\n  private _ignoreFiredEvents: boolean;\n  private _sourceViewports: Array<Types.IViewportId>;\n  private _targetViewports: Array<Types.IViewportId>;\n  private _viewportOptions: Record<string, Record<string, unknown>> = {};\n  private _options: any;\n  public id: string;\n\n  constructor(\n    synchronizerId: string,\n    eventName: string,\n    eventHandler: ISynchronizerEventHandler,\n    options?: any\n  ) {\n    this._enabled = true;\n    this._eventName = eventName;\n    this._eventHandler = eventHandler;\n    this._ignoreFiredEvents = false;\n    this._sourceViewports = [];\n    this._targetViewports = [];\n    this._options = options || {};\n    this._auxiliaryEventNames = this._options.auxiliaryEventNames || [];\n\n    //\n    this.id = synchronizerId;\n  }\n\n  /**\n   * \"Returns true if the synchronizer is disabled.\"\n   * @returns A boolean value.\n   */\n  public isDisabled(): boolean {\n    return !this._enabled || !this._hasSourceElements();\n  }\n\n  /**\n   * Sets the options for the viewport id.  This can be used to\n   * provide configuration on a viewport basis for things like offsets\n   * to the general synchronization, or turn on/off synchronization of certain\n   * attributes.\n   */\n  public setOptions(\n    viewportId: string,\n    options: Record<string, unknown> = {}\n  ): void {\n    this._viewportOptions[viewportId] = options;\n  }\n\n  /** Gets the options for the given viewport id */\n  public getOptions(viewportId: string): Record<string, unknown> | undefined {\n    return this._viewportOptions[viewportId];\n  }\n\n  /**\n   * Add a viewport to the list of targets and sources both.\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public add(viewportInfo: Types.IViewportId): void {\n    this.addTarget(viewportInfo);\n    this.addSource(viewportInfo);\n  }\n\n  /**\n   * Add a viewport to the list of sources (source ONLY)\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public addSource(viewportInfo: Types.IViewportId): void {\n    if (_containsViewport(this._sourceViewports, viewportInfo)) {\n      return;\n    }\n\n    const { renderingEngineId, viewportId } = viewportInfo;\n\n    const viewport =\n      getRenderingEngine(renderingEngineId).getViewport(viewportId);\n\n    if (!viewport) {\n      console.warn(\n        `Synchronizer.addSource: No viewport for ${renderingEngineId} ${viewportId}`\n      );\n      return;\n    }\n\n    const element = viewport.element;\n\n    element.addEventListener(this._eventName, this._onEvent.bind(this));\n\n    if (this._auxiliaryEventNames.length) {\n      this._auxiliaryEventNames.forEach((eventName) => {\n        element.addEventListener(eventName, this._onEvent.bind(this));\n      });\n    }\n\n    this._updateDisableHandlers();\n\n    this._sourceViewports.push(viewportInfo);\n  }\n\n  /**\n   * Add a viewport to the list of viewports that will get the eventHandler\n   * executed when the event is fired on the source viewport.\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public addTarget(viewportInfo: Types.IViewportId): void {\n    if (_containsViewport(this._targetViewports, viewportInfo)) {\n      return;\n    }\n\n    this._targetViewports.push(viewportInfo);\n    this._updateDisableHandlers();\n  }\n\n  /**\n   * Get the list of source viewports (as {viewportId, renderingEngineId} objects)\n   * @returns An array of {viewportId, renderingEngineId} objects.\n   */\n  public getSourceViewports(): Array<Types.IViewportId> {\n    return this._sourceViewports;\n  }\n\n  /**\n   * Get the list of target viewports (as {viewportId, renderingEngineId} objects)\n   * @returns An array of {viewportId, renderingEngineId} objects.\n   */\n  public getTargetViewports(): Array<Types.IViewportId> {\n    return this._targetViewports;\n  }\n\n  public destroy(): void {\n    this._sourceViewports.forEach((s) => this.removeSource(s));\n    this._targetViewports.forEach((t) => this.removeTarget(t));\n  }\n\n  /**\n   * Remove the viewport from the list of targets and sources\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   */\n  public remove(viewportInfo: Types.IViewportId): void {\n    this.removeTarget(viewportInfo);\n    this.removeSource(viewportInfo);\n  }\n\n  /**\n   * Remove the viewport from the list of source viewports\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   */\n  public removeSource(viewportInfo: Types.IViewportId): void {\n    const index = _getViewportIndex(this._sourceViewports, viewportInfo);\n\n    if (index === -1) {\n      return;\n    }\n\n    const element = _getViewportElement(viewportInfo);\n\n    this._sourceViewports.splice(index, 1);\n\n    //@ts-ignore\n    element.removeEventListener(this._eventName, this._eventHandler);\n\n    if (this._auxiliaryEventNames) {\n      this._auxiliaryEventNames.forEach((eventName) => {\n        //@ts-ignore\n        element.removeEventListener(eventName, this._eventHandler);\n      });\n    }\n    this._updateDisableHandlers();\n  }\n\n  /**\n   * Remove the viewport from the list of viewports that are currently targeted by\n   * this handler\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   *\n   */\n  public removeTarget(viewportInfo: Types.IViewportId): void {\n    const index = _getViewportIndex(this._targetViewports, viewportInfo);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._targetViewports.splice(index, 1);\n    this._updateDisableHandlers();\n  }\n\n  public hasSourceViewport(\n    renderingEngineId: string,\n    viewportId: string\n  ): boolean {\n    return _containsViewport(this._sourceViewports, {\n      renderingEngineId,\n      viewportId,\n    });\n  }\n\n  public hasTargetViewport(\n    renderingEngineId: string,\n    viewportId: string\n  ): boolean {\n    return _containsViewport(this._targetViewports, {\n      renderingEngineId,\n      viewportId,\n    });\n  }\n\n  private fireEvent(sourceViewport: Types.IViewportId, sourceEvent: any): void {\n    if (this.isDisabled() || this._ignoreFiredEvents) {\n      return;\n    }\n\n    this._ignoreFiredEvents = true;\n    const promises = [];\n    try {\n      for (let i = 0; i < this._targetViewports.length; i++) {\n        const targetViewport = this._targetViewports[i];\n        const targetIsSource =\n          sourceViewport.viewportId === targetViewport.viewportId;\n\n        if (targetIsSource) {\n          continue;\n        }\n        const result = this._eventHandler(\n          this,\n          sourceViewport,\n          targetViewport,\n          sourceEvent,\n          this._options\n        );\n\n        // if the result is a promise, then add it to the list of promises\n        // to wait for before setting _ignoreFiredEvents to false\n        if (result instanceof Promise) {\n          promises.push(result);\n        }\n      }\n    } catch (ex) {\n      console.warn(`Synchronizer, for: ${this._eventName}`, ex);\n    } finally {\n      if (promises.length) {\n        Promise.allSettled(promises).then(() => {\n          this._ignoreFiredEvents = false;\n        });\n      } else {\n        this._ignoreFiredEvents = false;\n      }\n    }\n  }\n\n  private _onEvent = (evt: any): void => {\n    if (this._ignoreFiredEvents === true) {\n      return;\n    }\n\n    // If no target viewports, then return immediately, this is useful\n    // when switching between layouts, when previous layout has disabled\n    // its viewports, and the new layout has not yet enabled them.\n    // Right now we don't \"delete\" the synchronizer if all source and targets\n    // are removed, but we may want to do that in the future.\n    if (!this._targetViewports.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(evt.currentTarget);\n\n    if (!enabledElement) {\n      return;\n    }\n\n    const { renderingEngineId, viewportId } = enabledElement;\n\n    // If the viewport has been removed from the synchronizer before the event is\n    // fired, then return immediately.\n    if (!this._sourceViewports.find((s) => s.viewportId === viewportId)) {\n      return;\n    }\n\n    this.fireEvent(\n      {\n        renderingEngineId,\n        viewportId,\n      },\n      evt\n    );\n  };\n\n  private _hasSourceElements(): boolean {\n    return this._sourceViewports.length !== 0;\n  }\n\n  private _updateDisableHandlers(): void {\n    const viewports = _getUniqueViewports(\n      this._sourceViewports,\n      this._targetViewports\n    );\n    const _remove = this.remove;\n    const disableHandler = (elementDisabledEvent) => {\n      _remove(elementDisabledEvent.detail.element);\n    };\n\n    viewports.forEach(function (vUid) {\n      const renderingEngine = getRenderingEngine(\n        vUid.renderingEngineId\n      ).getViewport(vUid.viewportId);\n\n      if (!renderingEngine) {\n        return;\n      }\n\n      const { element } = renderingEngine;\n\n      element.removeEventListener(\n        Enums.Events.ELEMENT_DISABLED,\n        disableHandler\n      );\n      element.addEventListener(Enums.Events.ELEMENT_DISABLED, disableHandler);\n    });\n  }\n}\n\nfunction _getUniqueViewports(\n  vp1: Array<Types.IViewportId>,\n  vp2: Array<Types.IViewportId>\n): Array<Types.IViewportId> {\n  const unique = [];\n\n  const vps = vp1.concat(vp2);\n\n  for (let i = 0; i < vps.length; i++) {\n    const vp = vps[i];\n    if (\n      !unique.some(\n        (u) =>\n          vp.renderingEngineId === u.renderingEngineId &&\n          vp.viewportId === u.viewportId\n      )\n    ) {\n      unique.push(vp);\n    }\n  }\n\n  return unique;\n}\n\nfunction _getViewportIndex(\n  arr: Array<Types.IViewportId>,\n  vp: Types.IViewportId\n): number {\n  return arr.findIndex(\n    (ar) =>\n      vp.renderingEngineId === ar.renderingEngineId &&\n      vp.viewportId === ar.viewportId\n  );\n}\n\nfunction _containsViewport(\n  arr: Array<Types.IViewportId>,\n  vp: Types.IViewportId\n) {\n  return arr.some(\n    (ar) =>\n      ar.renderingEngineId === vp.renderingEngineId &&\n      ar.viewportId === vp.viewportId\n  );\n}\n\nfunction _getViewportElement(vp: Types.IViewportId): HTMLDivElement {\n  const renderingEngine = getRenderingEngine(vp.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(`No RenderingEngine for Id: ${vp.renderingEngineId}`);\n  }\n\n  return renderingEngine.getViewport(vp.viewportId).element;\n}\n\nexport default Synchronizer;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\nimport { ISynchronizerEventHandler } from '../../types';\n\n/**\n * Create a new synchronizer instance from Synchronizer class\n * @param synchronizerId - The id of the synchronizer.\n * @param eventName - The name of the event that will be emitted by the\n * synchronizer.\n * @param eventHandler - The event handler that will be\n * called when the event is emitted.\n * @param options - Options for the synchronizer.\n * @returns A reference to the synchronizer.\n */\nfunction createSynchronizer(\n  synchronizerId: string,\n  eventName: string,\n  eventHandler: ISynchronizerEventHandler,\n  options?: any\n): Synchronizer {\n  const synchronizerWithSameIdExists = state.synchronizers.some(\n    (sync) => sync.id === synchronizerId\n  );\n\n  if (synchronizerWithSameIdExists) {\n    throw new Error(`Synchronizer with id '${synchronizerId}' already exists.`);\n  }\n\n  // Create\n  const synchronizer = new Synchronizer(\n    synchronizerId,\n    eventName,\n    eventHandler,\n    options\n  );\n\n  // Update state\n  state.synchronizers.push(synchronizer);\n\n  // Return reference\n  return synchronizer;\n}\n\nexport default createSynchronizer;\n","import { state } from '../index';\n\n/**\n * \"Destroy all synchronizers.\"\n */\nfunction destroy(): void {\n  while (state.synchronizers.length > 0) {\n    const synchronizer = state.synchronizers.pop();\n\n    synchronizer.destroy();\n  }\n}\n\nexport default destroy;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * Get the synchronizer with the given id from the state.\n * @param synchronizerId - The id of the synchronizer to be retrieved.\n * @returns A synchronizer object.\n */\nfunction getSynchronizer(synchronizerId: string): Synchronizer | void {\n  return state.synchronizers.find((s) => s.id === synchronizerId);\n}\n\nexport default getSynchronizer;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * Return the array of synchronizers\n * @returns An array of synchronizers.\n */\nfunction getAllSynchronizers(): Array<Synchronizer> {\n  return state.synchronizers;\n}\n\nexport default getAllSynchronizers;\n","import { state } from '../index';\n\n// Synchronizers are a bit more tenacious. We need to make sure we remove\n// any attached events\n// We should probably just have a destroySynchronizer call\n// then use getByX to allow versatility in how we can call destroy\n\n/**\n * Destroy a synchronizer by its ID.\n * @param synchronizerId - The id of the synchronizer to destroy.\n */\nfunction destroySynchronizer(synchronizerId: string): void {\n  const synchronizerIndex = state.synchronizers.findIndex(\n    (sync) => sync.id === synchronizerId\n  );\n\n  if (synchronizerIndex > -1) {\n    const synchronizer = state.synchronizers[synchronizerIndex];\n\n    synchronizer.destroy();\n    state.synchronizers.splice(synchronizerIndex, 1);\n  }\n}\n\nexport default destroySynchronizer;\n","const DEFINED_CURSORS = Symbol('DefinedCursors');\nconst STANDARD_CURSORS = new Set([\n  'alias',\n  'all-scroll',\n  'auto',\n  'cell',\n  'col-resize',\n  'context-menu',\n  'copy',\n  'crosshair',\n  'default',\n  'e-resize',\n  'ew-resize',\n  'grab',\n  'grabbing',\n  'help',\n  'move',\n  'ne-resize',\n  'nesw-resize',\n  'no-drop',\n  'none',\n  'not-allowed',\n  'n-resize',\n  'ns-resize',\n  'nw-resize',\n  'nwse-resize',\n  'pointer',\n  'progress',\n  'row-resize',\n  'se-resize',\n  's-resize',\n  'sw-resize',\n  'text',\n  'vertical-text',\n  'wait',\n  'w-resize',\n  'zoom-in',\n  'zoom-out',\n]);\n\nexport default class MouseCursor {\n  private name: string;\n  private fallback: MouseCursor | undefined;\n\n  constructor(name: string, fallback?: MouseCursor | undefined) {\n    this.name = name + '';\n    this.fallback = fallback;\n  }\n\n  getName(): string {\n    return this.name + '';\n  }\n\n  addFallbackStyleProperty(style: string): string {\n    const { fallback } = this;\n    if (fallback instanceof MouseCursor) {\n      return `${style}, ${fallback.getStyleProperty()}`;\n    }\n    return style + '';\n  }\n\n  getStyleProperty(): string {\n    return this.addFallbackStyleProperty(this.name) + '';\n  }\n\n  static getDefinedCursor(name: string): MouseCursor | undefined {\n    const definedCursors = getDefinedCursors(\n      // @ts-ignore\n      MouseCursor as Record<symbol, Map<string, MouseCursor>>,\n      DEFINED_CURSORS\n    );\n    let mouseCursor = definedCursors.get(name);\n    if (mouseCursor instanceof MouseCursor) {\n      return mouseCursor;\n    }\n    if (STANDARD_CURSORS.has(name)) {\n      mouseCursor = new MouseCursor(name);\n      definedCursors.set(name, mouseCursor);\n      return mouseCursor;\n    }\n  }\n\n  static setDefinedCursor(name: string, cursor: MouseCursor): boolean {\n    if (cursor instanceof MouseCursor) {\n      const definedCursors = getDefinedCursors(\n        // @ts-ignore\n        MouseCursor as Record<symbol, Map<string, MouseCursor>>,\n        DEFINED_CURSORS\n      );\n      definedCursors.set(name, cursor);\n      return true;\n    }\n    return false;\n  }\n}\n\n/*\n * Helpers\n */\n\nfunction getDefinedCursors(\n  context: Record<symbol, Map<string, MouseCursor>>,\n  symbol: symbol\n): Map<string, MouseCursor> {\n  let definedCursors = context[symbol];\n  if (!(definedCursors instanceof Map)) {\n    definedCursors = new Map();\n    Object.defineProperty(context, symbol, { value: definedCursors });\n  }\n  return definedCursors;\n}\n\nconst standardCursorNames = STANDARD_CURSORS.values();\nexport { standardCursorNames };\n","/**\n * AnnotationStyleStates - This enum defines the 4 possible states available for\n *  a Annotation instance.\n *\n * Default:\n *   The default state for the annotation instance\n * Highlighted:\n *   The annotation should be rendered in \"highlighted\" mode in response to\n *   direct user interaction;\n * Selected:\n *   The annotation has been selected by the user;\n * Locked:\n *   The annotation has been locked;\n */\nenum AnnotationStyleStates {\n  Default = '',\n  Highlighted = 'Highlighted',\n  Selected = 'Selected',\n  Locked = 'Locked',\n}\n\nexport default AnnotationStyleStates;\n","import { utilities } from '@cornerstonejs/core';\nimport MouseCursor from './MouseCursor';\n\nconst DEFAULT_NAME = 'image-cursor';\n\nexport default class ImageMouseCursor extends MouseCursor {\n  private url: string;\n  private x: number;\n  private y: number;\n\n  constructor(\n    url: string,\n    x?: number,\n    y?: number,\n    name?: string | undefined,\n    fallback?: MouseCursor | undefined\n  ) {\n    super(\n      name || ImageMouseCursor.getUniqueInstanceName(DEFAULT_NAME),\n      fallback\n    );\n    this.url = url;\n    this.x = Number(x) || 0;\n    this.y = Number(y) || 0;\n  }\n\n  getStyleProperty(): string {\n    const { url, x, y } = this;\n    let style = `url('${url}')`;\n    if (x >= 0 && y >= 0 && (x > 0 || y > 0)) {\n      style += ` ${x} ${y}`;\n    }\n    return this.addFallbackStyleProperty(style);\n  }\n\n  static getUniqueInstanceName(prefix: string): string {\n    return `${prefix}-${utilities.getRuntimeId(ImageMouseCursor)}`;\n  }\n}\n","import { SVGCursorDescriptor } from '../types';\n\n/*\n * Definitions\n */\n\nconst BASE: SVGCursorDescriptor = {\n  iconContent: '',\n  iconSize: 16,\n  viewBox: {\n    x: 16,\n    y: 16,\n  },\n  mousePoint: {\n    x: 8,\n    y: 8,\n  },\n  mousePointerGroupString: `\n    <path stroke=\"{{color}}\" d=\"M8 16L8 0\"></path>\n    <path stroke=\"{{color}}\" d=\"M16 8L0 8\"></path>\n  `,\n};\n\nconst SEGMENTATION_CURSOR_BOUNDARIES = {\n  x: 127,\n  y: 60,\n};\n\nconst MINUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n`;\n\nconst PLUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n<rect fill=\"{{color}}\" x=\"95.84\" y=\"9.38\" width=\"15.85\" height=\"47.14\"/>\n`;\n\nconst SCISSOR_ICON = `<path fill=\"{{color}}\" d=\"M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z\" transform=\"translate(-1.17 -0.96)\"/>`;\nconst RECTANGLE_ICON = `<path fill=\"{{color}}\" d=\"M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z\" transform=\"translate(-8.86 -2.25)\"/>`;\nconst CIRCLE_ICON = `<path fill=\"{{color}}\" d=\"M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z\" transform=\"translate(-8.86 -2.25)\"/>`;\n\nconst CursorSVG: Record<string, SVGCursorDescriptor> = {\n  Angle: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50\n    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23\n    10l50 50q10 10 10 23z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  ArrowAnnotate: extend(BASE, {\n    iconContent: `<g id=\"arrowAnnotate-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"arrowAnnotate-arrow\" d=\"M23,7 l-15,15 M7,17 l0,6 6,0\" stroke-width=\"2\" />\n  </g>`,\n    viewBox: {\n      x: 24,\n      y: 24,\n    },\n  }),\n  Bidirectional: extend(BASE, {\n    iconContent: `<g fill=\"{{color}}\" stroke-width=\"3\" stroke=\"{{color}}\">\n    <path d=\"M27.63 3.21L3.12 28.81\"></path>\n    <path d=\"M27.63 15.75L15.27 4.43\"></path>\n    <path d=\"M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z\" ></path>\n    <path d=\"M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z\"></path>\n    <path d=\"M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z\"></path>\n    <path d=\"M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z\"></path>\n  </g>`,\n    viewBox: {\n      x: 48,\n      y: 48,\n    },\n  }),\n  CobbAngle: extend(BASE, {\n    iconContent: `<g stroke=\"{{color}}\" stroke-width=\"3\">\n    <path d=\"M28.59 2.34L3.82 12.32\"></path>\n    <path d=\"M28.59 29.66L3.82 19.68\"></path>\n    <path stroke-dasharray=\"2\" fill-opacity=\"0\" d=\"M12.37\n      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15\n      9.33C13.11 9.24 13.02 9 12.88 8.63\">\n    </path>\n  </g>`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  CircleROI: extend(BASE, {\n    iconContent: `<circle stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" cx=\"16\" cy=\"16\" r=\"14\" />`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  EllipticalROI: extend(BASE, {\n    iconContent: `<path stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" d=\"M30.74 15.76C30.74 20.99 24.14 25.23 16\n    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14\n    6.3 30.74 10.54 30.74 15.76Z\" />`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  FreehandROI: extend(BASE, {\n    iconContent: `<g fill=\"{{color}}\" stroke=\"{{color}}\" stroke-width=\"2\">\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_3\" cy=\"4.240343\" cx=\"14.306499\"/>\n    <line id=\"svg_4\" y2=\"3.58462\" x2=\"12.242186\" y1=\"3.997482\" x1=\"13.432202\"/>\n    <line id=\"svg_5\" y2=\"3.268901\" x2=\"10.857882\" y1=\"3.608906\" x1=\"12.387902\"/>\n    <line id=\"svg_6\" y2=\"3.147471\" x2=\"9.740724\" y1=\"3.293187\" x1=\"10.955026\"/>\n    <line id=\"svg_7\" y2=\"3.147471\" x2=\"8.089274\" y1=\"3.196043\" x1=\"9.983585\"/>\n    <line id=\"svg_8\" y2=\"3.268901\" x2=\"6.874972\" y1=\"3.123185\" x1=\"8.307848\"/>\n    <line id=\"svg_9\" y2=\"3.657478\" x2=\"5.587812\" y1=\"3.220329\" x1=\"7.020688\"/>\n    <line id=\"svg_10\" y2=\"4.046054\" x2=\"4.737801\" y1=\"3.560334\" x1=\"5.854959\"/>\n    <line id=\"svg_11\" y2=\"4.337487\" x2=\"4.300652\" y1=\"3.997482\" x1=\"4.834945\"/>\n    <line id=\"svg_12\" y2=\"4.726063\" x2=\"3.88779\" y1=\"4.191771\" x1=\"4.470655\"/>\n    <line id=\"svg_15\" y2=\"5.3575\" x2=\"3.377783\" y1=\"4.604633\" x1=\"3.960648\"/>\n    <line id=\"svg_16\" y2=\"6.183226\" x2=\"2.916348\" y1=\"5.138926\" x1=\"3.547785\"/>\n    <line id=\"svg_17\" y2=\"6.960379\" x2=\"2.770632\" y1=\"5.867507\" x1=\"3.037779\"/>\n    <line id=\"svg_18\" y2=\"7.713246\" x2=\"2.673488\" y1=\"6.741804\" x1=\"2.819204\"/>\n    <line id=\"svg_19\" y2=\"8.684687\" x2=\"2.697774\" y1=\"7.616102\" x1=\"2.673488\"/>\n    <line id=\"svg_20\" y2=\"9.753273\" x2=\"2.892062\" y1=\"8.611829\" x1=\"2.697774\"/>\n    <line id=\"svg_21\" y2=\"10.724714\" x2=\"3.134923\" y1=\"9.534698\" x1=\"2.84349\"/>\n    <line id=\"svg_23\" y2=\"11.647583\" x2=\"3.596357\" y1=\"10.578998\" x1=\"3.086351\"/>\n    <line id=\"svg_25\" y2=\"12.521881\" x2=\"4.276366\" y1=\"11.501867\" x1=\"3.499213\"/>\n    <line id=\"svg_26\" y2=\"13.930471\" x2=\"5.830673\" y1=\"12.376165\" x1=\"4.13065\"/>\n    <line id=\"svg_28\" y2=\"14.707624\" x2=\"7.263549\" y1=\"13.881899\" x1=\"5.733528\"/>\n    <line id=\"svg_29\" y2=\"15.339061\" x2=\"8.963571\" y1=\"14.61048\" x1=\"7.06926\"/>\n    <line id=\"svg_30\" y2=\"15.581921\" x2=\"10.882168\" y1=\"15.314775\" x1=\"8.817855\"/>\n    <line id=\"svg_31\" y2=\"15.460491\" x2=\"12.023612\" y1=\"15.581921\" x1=\"10.785024\"/>\n    <line id=\"svg_33\" y2=\"15.120487\" x2=\"13.092197\" y1=\"15.484777\" x1=\"11.877895\"/>\n    <line id=\"svg_34\" y2=\"14.586194\" x2=\"13.86935\" y1=\"15.217631\" x1=\"12.897909\"/>\n    <line id=\"svg_35\" y2=\"13.833327\" x2=\"14.597931\" y1=\"14.756196\" x1=\"13.699348\"/>\n    <line id=\"svg_37\" y2=\"12.716169\" x2=\"15.180796\" y1=\"13.881899\" x1=\"14.549359\"/>\n    <line id=\"svg_39\" y2=\"11.429009\" x2=\"15.520801\" y1=\"12.813313\" x1=\"15.15651\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_40\" cy=\"10.967574\" cx=\"15.520801\"/>\n  </g>`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  FreehandROISculptor: extend(BASE, {\n    iconContent: `<g id=\"icon-freehand-sculpt\" fill=\"none\" stroke-width=\"1.5\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <line id=\"svg_1\" y2=\"2.559367\" x2=\"10.184807\" y1=\"4.467781\" x1=\"8.81711\"/>\n    <line id=\"svg_4\" y2=\"1.493836\" x2=\"11.727442\" y1=\"2.766112\" x1=\"10.089386\"/>\n    <line id=\"svg_7\" y2=\"1.080346\" x2=\"13.047428\" y1=\"1.748291\" x1=\"11.345759\"/>\n    <line id=\"svg_8\" y2=\"1.000829\" x2=\"14.351511\" y1=\"1.112153\" x1=\"12.77707\"/>\n    <line id=\"svg_9\" y2=\"1.350705\" x2=\"15.242104\" y1=\"0.905408\" x1=\"13.969828\"/>\n    <line id=\"svg_10\" y2=\"2.098167\" x2=\"15.862339\" y1=\"1.14396\" x1=\"14.955842\"/>\n    <line id=\"svg_11\" y2=\"3.195505\" x2=\"16.41896\" y1=\"1.939133\" x1=\"15.766918\"/>\n    <line id=\"svg_12\" y2=\"4.292843\" x2=\"16.530284\" y1=\"2.925147\" x1=\"16.387153\"/>\n    <line id=\"svg_16\" y2=\"5.644637\" x2=\"16.196311\" y1=\"3.831643\" x1=\"16.593898\"/>\n    <line id=\"svg_18\" y2=\"7.266789\" x2=\"15.623787\" y1=\"5.19934\" x1=\"16.275829\"/>\n    <line id=\"svg_19\" y2=\"10.813258\" x2=\"14.526449\" y1=\"6.726071\" x1=\"15.766918\"/>\n    <line id=\"svg_20\" y2=\"5.056209\" x2=\"8.085552\" y1=\"4.181519\" x1=\"8.976145\"/>\n    <line id=\"svg_23\" y2=\"5.326568\" x2=\"7.481221\" y1=\"4.78585\" x1=\"8.403621\"/>\n    <line id=\"svg_24\" y2=\"5.565119\" x2=\"6.749662\" y1=\"5.294761\" x1=\"7.624352\"/>\n    <line id=\"svg_25\" y2=\"5.994512\" x2=\"5.429675\" y1=\"5.533312\" x1=\"6.956407\"/>\n    <line id=\"svg_27\" y2=\"6.551133\" x2=\"4.284627\" y1=\"5.962706\" x1=\"5.572807\"/>\n    <line id=\"svg_28\" y2=\"7.584858\" x2=\"3.044158\" y1=\"6.392099\" x1=\"4.427758\"/>\n    <line id=\"svg_29\" y2=\"8.84123\" x2=\"2.185372\" y1=\"7.489437\" x1=\"3.219096\"/>\n    <line id=\"svg_31\" y2=\"10.606513\" x2=\"1.644654\" y1=\"8.602678\" x1=\"2.280792\"/>\n    <line id=\"svg_32\" y2=\"13.214679\" x2=\"1.48562\" y1=\"10.352058\" x1=\"1.724171\"/>\n    <line id=\"svg_33\" y2=\"14.375631\" x2=\"1.676461\" y1=\"12.992031\" x1=\"1.453813\"/>\n    <line id=\"svg_34\" y2=\"15.298031\" x2=\"2.264889\" y1=\"14.152983\" x1=\"1.517427\"/>\n    <line id=\"svg_35\" y2=\"16.172721\" x2=\"3.521261\" y1=\"14.948155\" x1=\"1.915013\"/>\n    <line id=\"svg_36\" y2=\"16.824762\" x2=\"5.207027\" y1=\"15.997783\" x1=\"3.28271\"/>\n    <line id=\"svg_38\" y2=\"17.063314\" x2=\"7.035924\" y1=\"16.745245\" x1=\"4.968475\"/>\n    <line id=\"svg_39\" y2=\"16.888376\" x2=\"9.278311\" y1=\"17.047411\" x1=\"6.733758\"/>\n    <line id=\"svg_40\" y2=\"16.284045\" x2=\"10.661911\" y1=\"16.983797\" x1=\"8.992048\"/>\n    <line id=\"svg_41\" y2=\"15.313934\" x2=\"11.647925\" y1=\"16.395369\" x1=\"10.455166\"/>\n    <line id=\"svg_44\" y2=\"13.898527\" x2=\"12.82478\" y1=\"15.425259\" x1=\"11.504794\"/>\n    <line id=\"svg_45\" y2=\"12.037824\" x2=\"14.144766\" y1=\"14.312017\" x1=\"12.522614\"/>\n    <line id=\"svg_47\" y2=\"10.59061\" x2=\"14.605966\" y1=\"12.228665\" x1=\"13.953925\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_48\" cy=\"3.982726\" cx=\"13.460918\"/>\n  </g>`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  Length: extend(BASE, {\n    iconContent: `<g id=\"length-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"length-dashes\" d=\"m22.5,6 -16.5,16.5\" stroke-width=\"3\" stroke-dasharray=\"0.6666,5\" />\n  </g>`,\n    viewBox: {\n      x: 24,\n      y: 24,\n    },\n  }),\n  Probe: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75\n    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73\n    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5\n    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5\n    385.5-103 385.5 103 279.5 279.5 103 385.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  RectangleROI: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47\n    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0\n    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119\n    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  TextMarker: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M789 559l-170 450q33 0 136.5 2t160.5 2q19 0\n    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29\n    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15\n    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5\n    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0\n    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11\n    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0\n    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58\n    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Crosshairs: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26\n    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45\n    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26\n    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5\n    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32\n    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5\n    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26\n    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26\n    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161\n    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161\n    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Eraser: extend(BASE, {\n    iconContent: `<path transform=\"translate(0,1792) scale(1,-1)\" fill=\"{{color}}\" d=\"M960 1408l336-384h-768l-336 384h768zm1013-1077q15\n    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38\n    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38\n    0 69.5 20.5t47.5 54.5z\" />`,\n    viewBox: {\n      x: 2048,\n      y: 1792,\n    },\n  }),\n  Magnify: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />`,\n    viewBox: {\n      x: 512,\n      y: 512,\n    },\n  }),\n  Pan: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17\n    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355\n    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59\n    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12\n    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144\n    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19\n    45v448q0 42-39 59-13 5-25 5-26 0-45-19z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Rotate: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39\n    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5\n    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0\n    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109\n    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298\n    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14\n    39 17 39 59z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  StackScroll: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0\n    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547\n    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z\" />`,\n    viewBox: {\n      x: 24,\n      y: 28,\n    },\n  }),\n  WindowLevelRegion: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119\n    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5\n    84.5t84.5 203.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  WindowLevel: extend(BASE, {\n    iconContent: `\n    <path fill=\"{{color}}\" d=\"M14.5,3.5 a1 1 0 0 1 -11,11 Z\" stroke=\"none\" opacity=\"0.8\" />\n    <circle cx=\"9\" cy=\"9\" r=\"8\" fill=\"none\" stroke-width=\"2\" stroke=\"{{color}}\" />`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  Zoom: extend(BASE, {\n    iconContent: `\n  <path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />\n  <path fill=\"{{color}}\" transform=\"scale(0.22,0.22) translate(1400,0)\" d=\"M1216\n    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19\n    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26\n    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z\" />`,\n    viewBox: {\n      x: 640,\n      y: 512,\n    },\n  }),\n\n  /*\n   * Segmentation Cursors\n   */\n\n  SegmentationFreeHandEraseInside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandFillInside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandEraseOutside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandFillOutside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationRectangleEraseInside: extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  // Default Rectangle Scissors\n  RectangleScissor: extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.FILL_INSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.FILL_OUTSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.ERASE_INSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  CircleScissor: extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.FILL_INSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.ERASE_OUTSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.FILL_OUTSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n};\n\n/*\n * Utils\n */\n\nfunction extend(\n  base: SVGCursorDescriptor,\n  values: Record<string, unknown>\n): SVGCursorDescriptor {\n  return Object.assign(Object.create(base), values);\n}\n\n/**\n * Registers a cursor to the list, so that it will be used for the given `toolName`.\n * Overwrites the given cursor if it is already set.\n *\n * @param toolName - The name of the tool to assign a cursor to.\n * @param iconContent - The SVG icon content of the cursor.\n * @param viewBox - The viewBox of the cursor object.\n */\nfunction registerCursor(\n  toolName: string,\n  iconContent: string,\n  viewBox: { x: number; y: number }\n) {\n  CursorSVG[toolName] = extend(BASE, {\n    iconContent,\n    viewBox,\n  });\n}\n\nfunction getDefinedSVGCursorDescriptor(\n  name: string\n): SVGCursorDescriptor | undefined {\n  return CursorSVG[name];\n}\n\n/*\n * Exports\n */\nconst svgCursorNames = Object.keys(CursorSVG);\n\nexport {\n  getDefinedSVGCursorDescriptor,\n  registerCursor,\n  svgCursorNames,\n  CursorSVG,\n};\n","import {\n  StyleConfig,\n  ToolStyleConfig,\n  StyleSpecifier,\n  AnnotationStyle,\n} from '../../../types/AnnotationStyle';\n\n/**\n * This class handles the configuration of the tool style. You can use it to set\n * the style of a tool at various levels (annotation, viewport, toolGroup, global).\n *\n * The hierarchy of the configuration is as follows (each level falls back to the\n * next level if not specified):\n *\n * 1) Annotation-level styles (with annotationUID)\n *     2) Viewport-level tool styles\n *         - Per-tool: Length on the viewport with viewportId\n *         - Global: All tools on the viewport with viewportId\n *             3) ToolGroup tool styles\n *                 - Per-tool: Angle on toolGroupId in all viewports of the toolGroup\n *                 - Global: All tools in the toolGroupId for all viewports\n *                     4) Default level:\n *                         - Per-tool: Length styles\n *                         - Global: Opinionated styles by CornerstoneJS\n */\nclass ToolStyle {\n  config: StyleConfig;\n\n  constructor() {\n    const defaultConfig = {\n      color: 'rgb(255, 255, 0)',\n      colorHighlighted: 'rgb(0, 255, 0)',\n      colorSelected: 'rgb(0, 220, 0)',\n      colorLocked: 'rgb(255, 255, 0)',\n      lineWidth: '1',\n      lineDash: '',\n      shadow: true,\n      textBoxVisibility: true,\n      textBoxFontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n      textBoxFontSize: '14px',\n      textBoxColor: 'rgb(255, 255, 0)',\n      textBoxColorHighlighted: 'rgb(0, 255, 0)',\n      textBoxColorSelected: 'rgb(0, 255, 0)',\n      textBoxColorLocked: 'rgb(255, 255, 0)',\n      textBoxBackground: '',\n      textBoxLinkLineWidth: '1',\n      textBoxLinkLineDash: '2,3',\n      textBoxShadow: true,\n    };\n\n    this._initializeConfig(defaultConfig);\n  }\n\n  /**\n   * It returns the annotation-specific tool styles for the annotation with the given UID\n   * @param annotationUID - The unique identifier of the annotation.\n   * @returns The annotation tool styles for the annotation with the given UID.\n   */\n  getAnnotationToolStyles(annotationUID: string): AnnotationStyle {\n    return this.config.annotations && this.config.annotations[annotationUID];\n  }\n\n  /**\n   * It returns the styles for a given viewport. It includes tool-specific and\n   * global styles (all tools in the viewport)\n   * @param viewportId - The id of the viewport\n   * @returns The viewport tool styles for the given viewport id.\n   */\n  getViewportToolStyles(viewportId: string): ToolStyleConfig {\n    return this.config.viewports && this.config.viewports[viewportId];\n  }\n\n  /**\n   * It returns the tool style for the given toolGroup. It includes tool-specific and\n   * global styles (all tools in the toolGroup)\n   * @param toolGroupId - The id of the toolGroup.\n   * @returns The tool styles for the tool group with the given id.\n   */\n  getToolGroupToolStyles(toolGroupId: string): ToolStyleConfig {\n    return this.config.toolGroups && this.config.toolGroups[toolGroupId];\n  }\n\n  /**\n   * It returns the default tool styles from the config file. It includes tool-specific and\n   * global styles (all tools in all tooLGroups)\n   * @returns The default tool styles.\n   */\n  getDefaultToolStyles(): ToolStyleConfig {\n    return this.config.default;\n  }\n\n  /**\n   * It takes an annotationUID and a style object and sets the styles at\n   * the annotationLevel (highest priority in the hierarchy). The styles is an\n   * object with key value pairs.\n   * @param annotationUID - string - The unique identifier for the annotation.\n   * @param styles - ToolStyles\n   */\n  setAnnotationStyles(annotationUID: string, styles: AnnotationStyle) {\n    let annotationSpecificStyles = this.config.annotations;\n\n    if (!annotationSpecificStyles) {\n      this.config = {\n        ...this.config,\n        annotations: {},\n      };\n\n      annotationSpecificStyles = this.config.annotations;\n    }\n\n    annotationSpecificStyles[annotationUID] = styles;\n  }\n\n  /**\n   * It takes a viewportId and a ToolStyles object, and adds the ToolStyles object\n   * at the viewport level (second highest priority in the hierarchy after the annotation level).\n   * @param viewportId - The id of the viewport\n   * @param styles - style object including tool-specific and/or global styles (All tools in the viewport)\n   */\n  setViewportToolStyles(viewportId: string, styles: ToolStyleConfig) {\n    let viewportSpecificStyles = this.config.viewports;\n\n    if (!viewportSpecificStyles) {\n      this.config = {\n        ...this.config,\n        viewports: {},\n      };\n\n      viewportSpecificStyles = this.config.viewports;\n    }\n\n    viewportSpecificStyles[viewportId] = styles;\n  }\n\n  /**\n   * It takes a toolGroupId and a ToolStyles object, and it adds the ToolStyles object\n   * at the toolGroup level (third highest priority in the hierarchy after the viewport level).\n   * @param toolGroupId - The id of the toolGroup\n   * @param styles - style object including tool-specific (in all viewports of the toolGroup) and/or\n   * global styles (All tools in the toolGroup for all viewports)\n   */\n  setToolGroupToolStyles(toolGroupId: string, styles: ToolStyleConfig) {\n    let toolGroupSpecificStyles = this.config.toolGroups;\n\n    if (!toolGroupSpecificStyles) {\n      this.config = {\n        ...this.config,\n        toolGroups: {},\n      };\n\n      toolGroupSpecificStyles = this.config.toolGroups;\n    }\n\n    toolGroupSpecificStyles[toolGroupId] = styles;\n  }\n\n  /**\n   * Sets the default tool styles for the editor. It overrides the default styles for all tools.\n   * @param styles - style object including tool-specific (a tool in all toolGroups) and/or\n   * global styles (All tools in all tooLGroups)\n   */\n  setDefaultToolStyles(styles: ToolStyleConfig) {\n    this.config.default = styles;\n  }\n\n  /**\n   * It returns the value for a given style key, based on the provided specifications.\n   * It starts by looking at the annotation-specific styles, then at the viewport-specific styles,\n   * then at the toolGroup-specific styles, and finally at the default styles.\n   * @param styleKey - The key of the style.\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met\n   * @returns The value for the given style key.\n   */\n  getStyleProperty(toolStyle: string, specifications: StyleSpecifier) {\n    const { annotationUID, viewportId, toolGroupId, toolName } = specifications;\n\n    return this._getToolStyle(\n      toolStyle,\n      annotationUID,\n      viewportId,\n      toolGroupId,\n      toolName\n    );\n  }\n\n  private _getToolStyle(\n    property: string,\n    annotationUID: string,\n    viewportId: string,\n    toolGroupId: string,\n    toolName: string\n  ) {\n    if (annotationUID) {\n      const annotationToolStyles = this.getAnnotationToolStyles(annotationUID);\n\n      if (annotationToolStyles) {\n        // check first in the toolSpecific styles\n        if (annotationToolStyles[property] !== undefined) {\n          return annotationToolStyles[property];\n        }\n      }\n    }\n\n    if (viewportId) {\n      const viewportToolStyles = this.getViewportToolStyles(viewportId);\n\n      if (viewportToolStyles) {\n        // check if we have the viewportId specific style\n        // check first in the toolSpecific styles\n        if (\n          viewportToolStyles[toolName] &&\n          viewportToolStyles[toolName][property] !== undefined\n        ) {\n          return viewportToolStyles[toolName][property];\n        }\n\n        // check if we have the style in the viewport specific global viewportSpecificStyles\n        if (\n          viewportToolStyles.global &&\n          viewportToolStyles.global[property] !== undefined\n        ) {\n          return viewportToolStyles.global[property];\n        }\n      }\n    }\n\n    if (toolGroupId) {\n      const toolGroupToolStyles = this.getToolGroupToolStyles(toolGroupId);\n\n      if (toolGroupToolStyles) {\n        // check first in the toolSpecific styles\n        if (\n          toolGroupToolStyles[toolName] &&\n          toolGroupToolStyles[toolName][property] !== undefined\n        ) {\n          return toolGroupToolStyles[toolName][property];\n        }\n\n        // check if we have the style in the toolGroup specific global styles\n        if (\n          toolGroupToolStyles.global &&\n          toolGroupToolStyles.global[property] !== undefined\n        ) {\n          return toolGroupToolStyles.global[property];\n        }\n      }\n    }\n\n    const globalStyles = this.getDefaultToolStyles();\n\n    if (\n      globalStyles[toolName] &&\n      globalStyles[toolName][property] !== undefined\n    ) {\n      return globalStyles[toolName][property];\n    }\n\n    if (globalStyles.global && globalStyles.global[property] !== undefined) {\n      return globalStyles.global[property];\n    }\n  }\n\n  private _initializeConfig(config) {\n    const toolStyles = {};\n    for (const name in config) {\n      toolStyles[name] = config[name];\n    }\n\n    this.config = {\n      default: {\n        global: toolStyles as AnnotationStyle,\n      },\n    };\n  }\n}\n\nconst toolStyle = new ToolStyle();\n\nexport default toolStyle;\n","import { StyleSpecifier } from '../../../types/AnnotationStyle';\nimport { ToolModes, AnnotationStyleStates } from '../../../enums';\nimport toolStyle from './ToolStyle';\n\n/**\n * Build a list of hierarchal property names in ascending order of priority\n * @param property - The base property name -- e.g., 'color'\n * @param state - An optional state to determine the final property name\n * @param mode - An optional mode to determine the final property name\n * @returns A list of property names\n */\nfunction getHierarchalPropertyStyles(\n  property: string,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string[] {\n  const list = [`${property}`];\n  if (state) {\n    list.push(`${list[0]}${state}`);\n  }\n  if (mode) {\n    list.push(`${list[list.length - 1]}${mode}`);\n  }\n  return list;\n}\n\n/**\n * Get the value of a style property from the ToolStyle config\n * @param property - The name of the property to get.\n * @param styleSpecifier - An object containing the specifications such as viewportId,\n * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n * met (hierarchy is checked from most specific to least specific which is\n * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n * @param state - The state of the tool (Default, Locked etc.)\n * @param mode - The current tool mode. (Active, Passive etc.)\n * @returns The value of the property.\n */\nfunction getStyleProperty(\n  property: string,\n  styleSpecifier: StyleSpecifier,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string {\n  // Hierarchal property styles is a list of property names with priority in ascending\n  // order like: ['color', 'colorSelected', 'colorSelectedActive'], if in the toolStyle\n  // config, the `colorSelectedActive` property is defined, it will be used, otherwise\n  // the `colorSelected` property will be used, and if that is not defined, the `color`\n  // property will be used. This is done to ensure that the most specific property is used.\n  // Thus, we attempt resolving property names in reverse order\n  const alternatives = getHierarchalPropertyStyles(property, state, mode);\n  for (let i = alternatives.length - 1; i >= 0; --i) {\n    const style = toolStyle.getStyleProperty(alternatives[i], styleSpecifier);\n    if (style !== undefined) {\n      return style;\n    }\n  }\n}\n\nexport { getStyleProperty };\n","import { ToolModes, AnnotationStyleStates } from '../enums';\nimport MouseCursor from './MouseCursor';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport { getDefinedSVGCursorDescriptor } from './SVGCursorDescriptor';\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\n\nimport type { StyleSpecifier } from '../types/AnnotationStyle';\nimport type { SVGCursorDescriptor } from '../types';\n\nconst PROPERTY = 'color';\nconst STATE = AnnotationStyleStates.Highlighted;\nconst MODE = ToolModes.Active;\n\nexport default class SVGMouseCursor extends ImageMouseCursor {\n  constructor(\n    url: string,\n    x?: number,\n    y?: number,\n    name?: string | undefined,\n    fallback?: MouseCursor | undefined\n  ) {\n    super(url, x, y, name, fallback);\n  }\n\n  /**\n   * Get a shared instance of the SVGMouseCursor class satisfying the given parameters.\n   *\n   * @param name - The name of the cursor (defined in SVGCursorDescriptor.ts);\n   * @param pointer - Should be true to use the version of the cursor containing\n   * a mouse pointer. Defaults to false (which does not add a pointer to the cursor);\n   * @param color - The color of the cursor. Defaults to tool.style.colorHighlightedActive;\n   * @returns a SVGMouseCursor instance or\n   * undefined if no SVG cursor descriptor was found with the given name;\n   */\n  static getDefinedCursor(\n    name: string,\n    pointer = false,\n    color?: string\n  ): MouseCursor {\n    if (!color) {\n      color = getStyleProperty(PROPERTY, {} as StyleSpecifier, STATE, MODE);\n    }\n    const urn = getCursorURN(name, pointer, color);\n    let cursor = super.getDefinedCursor(urn);\n    if (!cursor) {\n      const descriptor = getDefinedSVGCursorDescriptor(name);\n      if (descriptor) {\n        cursor = createSVGMouseCursor(\n          descriptor,\n          urn,\n          pointer,\n          color,\n          super.getDefinedCursor('default')\n        );\n        super.setDefinedCursor(urn, cursor);\n      }\n    }\n    return cursor;\n  }\n}\n\n/*\n * Helpers\n */\n\nfunction format(template: string, dictionary: Record<string, unknown>): string {\n  const dict = Object(dictionary);\n  const defined = Object.prototype.hasOwnProperty.bind(dict);\n  return (template + '').replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => {\n    return defined(key) ? dict[key] + '' : '';\n  });\n}\n\nfunction getCursorURN(name: string, pointer: boolean, color: string) {\n  const type = pointer ? 'pointer' : 'cursor';\n  return `${type}:${name}/${color}`;\n}\n\nfunction createSVGMouseCursor(\n  descriptor: SVGCursorDescriptor,\n  name: string,\n  pointer: boolean,\n  color: string,\n  fallback: MouseCursor\n): SVGMouseCursor {\n  const { x, y } = descriptor.mousePoint;\n  return new SVGMouseCursor(\n    createSVGIconUrl(descriptor, pointer, { color }),\n    x,\n    y,\n    name,\n    fallback\n  );\n}\n\nfunction createSVGIconUrl(\n  descriptor: SVGCursorDescriptor,\n  pointer: boolean,\n  options: Record<string, unknown>\n): string {\n  return URL.createObjectURL(createSVGIconBlob(descriptor, pointer, options));\n}\n\nfunction createSVGIconBlob(\n  descriptor: SVGCursorDescriptor,\n  pointer: boolean,\n  options: Record<string, unknown>\n): Blob {\n  const svgString = (pointer ? createSVGIconWithPointer : createSVGIcon)(\n    descriptor,\n    options\n  );\n  return new Blob([svgString], { type: 'image/svg+xml' });\n}\n\nfunction createSVGIcon(\n  descriptor: SVGCursorDescriptor,\n  options: Record<string, unknown>\n): string {\n  const { iconContent, iconSize, viewBox } = descriptor;\n  const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${iconSize}\" height=\"${iconSize}\" viewBox=\"0 0\n      ${viewBox.x} ${viewBox.y}\">\n      ${iconContent}\n    </svg>`;\n  return format(svgString, options);\n}\n\nfunction createSVGIconWithPointer(\n  descriptor: SVGCursorDescriptor,\n  options: Record<string, unknown>\n) {\n  const { iconContent, iconSize, viewBox, mousePointerGroupString } =\n    descriptor;\n  const scale = iconSize / Math.max(viewBox.x, viewBox.y, 1);\n  const svgSize = 16 + iconSize;\n  const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${svgSize}\" height=\"${svgSize}\" viewBox=\"0 0 ${svgSize} ${svgSize}\">\n      <g>${mousePointerGroupString}</g>\n      <g transform=\"translate(16, 16) scale(${scale})\">${iconContent}</g>\n    </svg>`;\n  return format(svgString, options);\n}\n","import { MouseCursor } from '.';\n\nconst ELEMENT_CURSORS_MAP = Symbol('ElementCursorsMap');\n\n/*\n * Public Methods\n */\n\nfunction initElementCursor(\n  element: HTMLDivElement,\n  cursor: MouseCursor | null\n): void {\n  _getElementCursors(element)[0] = cursor;\n  _setElementCursor(element, cursor);\n}\n\nfunction _setElementCursor(\n  element: HTMLDivElement,\n  cursor: MouseCursor | null\n): void {\n  const cursors = _getElementCursors(element);\n  cursors[1] = cursors[0];\n  cursors[0] = cursor;\n  element.style.cursor = (\n    cursor instanceof MouseCursor\n      ? cursor\n      : MouseCursor.getDefinedCursor('auto')\n  ).getStyleProperty();\n}\n\nfunction resetElementCursor(element: HTMLDivElement): void {\n  _setElementCursor(element, _getElementCursors(element)[1]);\n}\n\nfunction hideElementCursor(element: HTMLDivElement): void {\n  _setElementCursor(element, MouseCursor.getDefinedCursor('none'));\n}\n\n/*\n * Helpers\n */\n\nfunction _getElementCursors(\n  element: HTMLDivElement\n): [MouseCursor | null, MouseCursor | null] {\n  let map = _getElementCursors[ELEMENT_CURSORS_MAP];\n  if (!(map instanceof WeakMap)) {\n    map = new WeakMap();\n    Object.defineProperty(_getElementCursors, ELEMENT_CURSORS_MAP, {\n      value: map,\n    });\n  }\n  let cursors = map.get(element);\n  if (!cursors) {\n    cursors = [null, null];\n    map.set(element, cursors);\n  }\n  return cursors;\n}\n\n/*\n * Exports\n */\nexport {\n  initElementCursor,\n  resetElementCursor,\n  hideElementCursor,\n  _setElementCursor as setElementCursor,\n};\n","import { MouseBindings, ToolModes } from '../../enums';\nimport cloneDeep from 'lodash.clonedeep';\nimport get from 'lodash.get';\nimport {\n  triggerEvent,\n  eventTarget,\n  getRenderingEngine,\n  getRenderingEngines,\n  getEnabledElementByIds,\n  Settings,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport {\n  ToolActivatedEventDetail,\n  ToolModeChangedEventDetail,\n} from '../../types/EventTypes';\nimport { ToolGroupManager, state } from '../index';\nimport {\n  IToolBinding,\n  IToolClassReference,\n  IToolGroup,\n  SetToolBindingsType,\n  ToolOptionsType,\n  ToolConfiguration,\n} from '../../types';\n\nimport { MouseCursor, SVGMouseCursor } from '../../cursors';\nimport { initElementCursor } from '../../cursors/elementCursor';\n\nconst { Active, Passive, Enabled, Disabled } = ToolModes;\n\n/**\n * ToolGroup class which is a container for tools and their modes and states.\n * In Cornerstone3DTools, you need to create a tool group in order to use the\n * tools. ToolGroup is a way to share tool configuration, state (enabled, disabled, etc.)\n * across a set of viewports. Tools can set to be activated, enabled or disabled\n * in a toolGroup. You should not directly instantiate a ToolGroup. You need to use\n * ToolGroupManager helpers to create a new toolGroup or get a reference to an existing toolGroup.\n *\n * ```js\n * const toolGroup = csTools.ToolGroupManager.createToolGroup('toolGroupId')\n * ```\n */\nexport default class ToolGroup implements IToolGroup {\n  id: string;\n  viewportsInfo = [];\n  toolOptions = {};\n  /**\n   * Options used for restoring a tool\n   */\n  restoreToolOptions = {};\n  _toolInstances = {};\n\n  constructor(id: string) {\n    this.id = id;\n  }\n\n  /**\n   * Get the viewport IDs of all the viewports in the current viewport\n   * @returns An array of viewport IDs.\n   */\n  getViewportIds(): string[] {\n    return this.viewportsInfo.map(({ viewportId }) => viewportId);\n  }\n\n  /**\n   * Returns the toolGroup viewports info which is an array of {viewportId, renderingEngineId}\n   */\n  getViewportsInfo(): Array<Types.IViewportId> {\n    return this.viewportsInfo.slice();\n  }\n\n  /**\n   * Get the tool instance for a given tool name in the toolGroup\n   * @param toolName - The name of the tool.\n   * @returns A tool instance.\n   */\n  public getToolInstance(toolInstanceName: string) {\n    const toolInstance = this._toolInstances[toolInstanceName];\n    if (!toolInstance) {\n      console.warn(\n        `'${toolInstanceName}' is not registered with this toolGroup (${this.id}).`\n      );\n      return;\n    }\n\n    return toolInstance;\n  }\n  /**\n   * Add a tool to the tool group with the given tool name and tool configuration.\n   * Note that adding a tool to a tool group will not automatically set the tool\n   * to be active. You must call setToolActive or setToolPassive and other methods\n   * to set the tool to be active or passive or in other states.\n   *\n   * @param toolName - string\n   * @param configuration - Tool configuration objects and a custom statistics calculator if needed\n   */\n  addTool(toolName: string, configuration: ToolConfiguration = {}): void {\n    const toolDefinition = state.tools[toolName];\n    const hasToolName = typeof toolName !== 'undefined' && toolName !== '';\n    const localToolInstance = this.toolOptions[toolName];\n\n    if (!hasToolName) {\n      console.warn(\n        'Tool with configuration did not produce a toolName: ',\n        configuration\n      );\n      return;\n    }\n\n    if (!toolDefinition) {\n      console.warn(\n        `'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`\n      );\n      return;\n    }\n\n    if (localToolInstance) {\n      console.warn(\n        `'${toolName}' is already registered for ToolGroup ${this.id}.`\n      );\n      return;\n    }\n\n    // Should these be renamed higher up, so we don't have to alias?\n    // Wrap in try-catch so 3rd party tools don't explode?\n    const { toolClass: ToolClass } = toolDefinition;\n\n    const toolProps = {\n      name: toolName,\n      toolGroupId: this.id,\n      configuration,\n    };\n\n    const instantiatedTool = new ToolClass(toolProps);\n\n    // API instead of directly exposing schema?\n    // Maybe not here, but feels like a \"must\" for any method outside of the ToolGroup itself\n    this._toolInstances[toolName] = instantiatedTool;\n  }\n\n  public addToolInstance(\n    toolName: string,\n    parentClassName: string,\n    configuration = {}\n  ): void {\n    let ToolClassToUse = state.tools[toolName]\n      ?.toolClass as IToolClassReference;\n\n    if (!ToolClassToUse) {\n      // get parent class constructor\n      const ParentClass = state.tools[parentClassName]\n        .toolClass as IToolClassReference;\n\n      // Todo: could not find a way to make this work with typescript\n      // @ts-ignore\n      class ToolInstance extends ParentClass {}\n      // @ts-ignore\n      ToolInstance.toolName = toolName;\n      // @ts-ignore\n      ToolClassToUse = ToolInstance;\n\n      state.tools[toolName] = {\n        toolClass: ToolInstance as IToolClassReference,\n      };\n    }\n\n    // add the tool to the toolGroup\n    // @ts-ignore\n    this.addTool(ToolClassToUse.toolName, configuration);\n  }\n\n  //   class InstanceTool extends parentClass;\n  // InstanceTool.constructor.toolName = name;\n  // addTool(InstanceTool,configuration)\n  /**\n   * Add a viewport to the ToolGroup. It accepts viewportId and optional\n   * renderingEngineId parameter. If renderingEngineId is not provided,\n   * it checks if cornerstone-core has more than one renderingEngine; If so,\n   * it will throw an error. If cornerstone-core has only one renderingEngine,\n   * it will use that renderingEngine.\n   *\n   * @param viewportId - The unique identifier for the viewport.\n   * @param renderingEngineId - The rendering engine to use.\n   */\n  public addViewport(viewportId: string, renderingEngineId?: string): void {\n    if (typeof viewportId !== 'string') {\n      throw new Error('viewportId must be defined and be a string');\n    }\n\n    const renderingEngines = getRenderingEngines();\n\n    if (!renderingEngineId && renderingEngines.length > 1) {\n      throw new Error(\n        'You must specify a renderingEngineId when there are multiple rendering engines.'\n      );\n    }\n\n    const renderingEngineUIDToUse = renderingEngineId || renderingEngines[0].id;\n\n    // Don't overwrite if it already exists\n    if (\n      !this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)\n    ) {\n      this.viewportsInfo.push({\n        viewportId,\n        renderingEngineId: renderingEngineUIDToUse,\n      });\n    }\n\n    // Handle the newly added viewport's mouse cursor\n    const toolName = this.getActivePrimaryMouseButtonTool();\n\n    const runtimeSettings = Settings.getRuntimeSettings();\n    if (runtimeSettings.get('useCursors')) {\n      this.setViewportsCursorByToolName(toolName);\n    }\n  }\n\n  /**\n   * Removes viewport from the toolGroup. If only renderingEngineId is defined\n   * it removes all the viewports with the same renderingEngineId, if viewportId\n   * is also provided, it will remove that specific viewport from the ToolGroup.\n   *\n   * @param renderingEngineId - renderingEngine id\n   * @param viewportId - viewport id\n   */\n  public removeViewports(renderingEngineId: string, viewportId?: string): void {\n    const indices = [];\n\n    this.viewportsInfo.forEach((vpInfo, index) => {\n      let match = false;\n      if (vpInfo.renderingEngineId === renderingEngineId) {\n        match = true;\n\n        if (viewportId && vpInfo.viewportId !== viewportId) {\n          match = false;\n        }\n      }\n      if (match) {\n        indices.push(index);\n      }\n    });\n\n    if (indices.length) {\n      // Note: Traverse the array backwards, such that when we remove items we\n      // do not immediately mess up our loop indicies.\n      for (let i = indices.length - 1; i >= 0; i--) {\n        this.viewportsInfo.splice(indices[i], 1);\n      }\n    }\n  }\n\n  public setActiveStrategy(toolName: string, strategyName: string) {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool configuration.`\n      );\n\n      return;\n    }\n\n    toolInstance.setActiveStrategy(strategyName);\n  }\n\n  setToolMode(\n    toolName: string,\n    mode: ToolModes,\n    options = {} as SetToolBindingsType\n  ): void {\n    if (!toolName) {\n      console.warn('setToolMode: toolName must be defined');\n      return;\n    }\n\n    if (mode === ToolModes.Active) {\n      this.setToolActive(\n        toolName,\n        options || this.restoreToolOptions[toolName]\n      );\n      return;\n    }\n\n    if (mode === ToolModes.Passive) {\n      this.setToolPassive(toolName);\n      return;\n    }\n\n    if (mode === ToolModes.Enabled) {\n      this.setToolEnabled(toolName);\n      return;\n    }\n\n    if (mode === ToolModes.Disabled) {\n      this.setToolDisabled(toolName);\n      return;\n    }\n\n    console.warn('setToolMode: mode must be defined');\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Active. This means the tool\n   * can be actively used by the defined bindings (e.g., Mouse primary click)\n   *\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\n   * - Can add data if an annotation tool.\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   *\n   * @param toolName - tool name\n   * @param toolBindingsOptions - tool bindings\n   */\n  public setToolActive(\n    toolName: string,\n    toolBindingsOptions = {} as SetToolBindingsType\n  ): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    if (!toolInstance) {\n      console.warn(\n        `'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`\n      );\n      return;\n    }\n\n    const prevBindings: IToolBinding[] = this.toolOptions[toolName]\n      ? this.toolOptions[toolName].bindings\n      : [];\n\n    const newBindings = toolBindingsOptions.bindings\n      ? toolBindingsOptions.bindings\n      : [];\n\n    // combine the new bindings with the previous bindings to avoid duplicates\n    // it allows duplicated mouse buttons as long as they don't have same\n    // modifier keys.\n    const bindingsToUse = [...prevBindings, ...newBindings].reduce(\n      (unique, binding) => {\n        const TouchBinding = binding.numTouchPoints !== undefined;\n        const MouseBinding = binding.mouseButton !== undefined;\n\n        if (\n          !unique.some((obj) => hasSameBinding(obj, binding)) &&\n          (TouchBinding || MouseBinding)\n        ) {\n          unique.push(binding);\n        }\n        return unique;\n      },\n      []\n    );\n\n    // We should not override the bindings if they are already set\n    const toolOptions: ToolOptionsType = {\n      bindings: bindingsToUse,\n      mode: Active,\n    };\n\n    this.toolOptions[toolName] = toolOptions;\n    this._toolInstances[toolName].mode = Active;\n\n    // reset the mouse cursor if tool has left click binding\n    const runtimeSettings = Settings.getRuntimeSettings();\n    const useCursor = runtimeSettings.get('useCursors');\n\n    if (this._hasMousePrimaryButtonBinding(toolBindingsOptions) && useCursor) {\n      this.setViewportsCursorByToolName(toolName);\n    } else {\n      // reset to default cursor only if there is no other tool with primary binding\n      const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();\n      if (!activeToolIdentifier && useCursor) {\n        const cursor = MouseCursor.getDefinedCursor('default');\n        this._setCursorForViewports(cursor);\n      }\n    }\n\n    if (typeof toolInstance.onSetToolActive === 'function') {\n      toolInstance.onSetToolActive();\n    }\n    this._renderViewports();\n\n    const eventDetail: ToolActivatedEventDetail = {\n      toolGroupId: this.id,\n      toolName,\n      toolBindingsOptions,\n    };\n\n    triggerEvent(eventTarget, Events.TOOL_ACTIVATED, eventDetail);\n    this._triggerToolModeChangedEvent(toolName, Active, toolBindingsOptions);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Passive.\n   *\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   *\n   * @param toolName - tool name\n   */\n  public setToolPassive(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    // We should only remove the primary button bindings and keep\n    // the other ones (Zoom on right click)\n    const prevToolOptions = this.getToolOptions(toolName);\n    const toolOptions = Object.assign(\n      {\n        bindings: prevToolOptions ? prevToolOptions.bindings : [],\n      },\n      prevToolOptions,\n      {\n        mode: Passive,\n      }\n    );\n\n    const defaultMousePrimary = this.getDefaultMousePrimary();\n\n    // Remove the primary button bindings without modifiers, if they exist\n    toolOptions.bindings = toolOptions.bindings.filter(\n      (binding) =>\n        binding.mouseButton !== defaultMousePrimary || binding.modifierKey\n    );\n    // If there are other bindings, set the tool to be active\n    let mode = Passive;\n    if (toolOptions.bindings.length !== 0) {\n      mode = Active;\n      toolOptions.mode = mode;\n    }\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = mode;\n\n    if (typeof toolInstance.onSetToolPassive === 'function') {\n      toolInstance.onSetToolPassive();\n    }\n    this._renderViewports();\n\n    // It would make sense to use `toolInstance.mode` as mode when setting a tool\n    // as passive because it can still be actived in the end but `Passive` must\n    // be used when synchronizing ToolGroups so that other ToolGroups can take the\n    // same action (update tool bindings). Should the event have two different modes\n    // to handle this special case?\n    this._triggerToolModeChangedEvent(toolName, Passive);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Enabled.\n   *\n   * - Renders data if the tool has a `renderAnnotation` method..\n   *\n   * @param toolName - tool name\n   */\n  public setToolEnabled(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    const toolOptions = {\n      bindings: [],\n      mode: Enabled,\n    };\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = Enabled;\n\n    if (typeof toolInstance.onSetToolEnabled === 'function') {\n      toolInstance.onSetToolEnabled();\n    }\n\n    this._renderViewports();\n    this._triggerToolModeChangedEvent(toolName, Enabled);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Disabled.\n   *\n   * - Annotation does not render.\n   *\n   * @param toolName - tool name\n   */\n  public setToolDisabled(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    const toolOptions = {\n      bindings: [],\n      mode: Disabled,\n    };\n\n    this.restoreToolOptions[toolName] = this.toolOptions[toolName];\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = Disabled;\n\n    if (typeof toolInstance.onSetToolDisabled === 'function') {\n      toolInstance.onSetToolDisabled();\n    }\n    this._renderViewports();\n    this._triggerToolModeChangedEvent(toolName, Disabled);\n  }\n\n  /**\n   * Get the options for a given tool\n   * @param toolName - The name of the tool.\n   * @returns the tool options\n   */\n  public getToolOptions(toolName: string): ToolOptionsType {\n    const toolOptionsForTool = this.toolOptions[toolName];\n\n    if (toolOptionsForTool === undefined) {\n      return;\n    }\n\n    return toolOptionsForTool;\n  }\n\n  /**\n   * Find the name of the tool that is Active and has a primary button binding\n   * (Mouse primary click)\n   *\n   * @returns The name of the tool\n   */\n  public getActivePrimaryMouseButtonTool(): string {\n    return Object.keys(this.toolOptions).find((toolName) => {\n      const toolOptions = this.toolOptions[toolName];\n      return (\n        toolOptions.mode === Active &&\n        this._hasMousePrimaryButtonBinding(toolOptions)\n      );\n    });\n  }\n\n  public setViewportsCursorByToolName(\n    toolName: string,\n    strategyName?: string\n  ): void {\n    const cursor = this._getCursor(toolName, strategyName);\n\n    this._setCursorForViewports(cursor);\n  }\n\n  private _getCursor(toolName: string, strategyName?: string): MouseCursor {\n    let cursorName;\n    let cursor;\n\n    if (strategyName) {\n      // Try combinations with strategyName first:\n      // Try with toolName and toolInstanceName first.\n      cursorName = `${toolName}.${strategyName}`;\n\n      cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n      if (cursor) {\n        return cursor;\n      }\n    }\n\n    // Try with toolName and toolInstanceName first.\n    cursorName = `${toolName}`;\n\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n    if (cursor) {\n      return cursor;\n    }\n\n    // Try with just toolName.\n    cursorName = toolName;\n\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n    if (cursor) {\n      return cursor;\n    }\n\n    return MouseCursor.getDefinedCursor('default');\n  }\n\n  _setCursorForViewports(cursor: MouseCursor): void {\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n      initElementCursor(viewport.element, cursor);\n    });\n  }\n\n  /**\n   * Set a configuration of a tool by the given toolName.\n   * Use overwrite as true in case you want to overwrite any existing configuration (be careful, depending on config change it might break the annotation flow).\n   */\n  public setToolConfiguration(\n    toolName: string,\n    configuration: ToolConfiguration,\n    overwrite?: boolean\n  ): boolean {\n    if (this._toolInstances[toolName] === undefined) {\n      console.warn(\n        `Tool ${toolName} not present, can't set tool configuration.`\n      );\n      return false;\n    }\n\n    let _configuration;\n\n    if (overwrite) {\n      _configuration = configuration;\n    } else {\n      // We should not deep copy here, it is the job of the application to\n      // deep copy the configuration before passing it to the toolGroup, otherwise\n      // some strange appending behaviour happens for the arrays\n      _configuration = Object.assign(\n        this._toolInstances[toolName].configuration,\n        configuration\n      );\n    }\n\n    this._toolInstances[toolName].configuration = _configuration;\n\n    this._renderViewports();\n\n    return true;\n  }\n\n  /**\n   * Returns the default mouse primary button.\n   *\n   */\n  public getDefaultMousePrimary(): MouseBindings {\n    return MouseBindings.Primary;\n  }\n\n  /**\n   * Get the configuration of tool. It returns only the config for the given path (in case exists).\n   * ConfigurationPath is the the path of the property to get separated by '.'.\n   *\n   * @example\n   * getToolConfiguration('LengthTool', 'firstLevel.secondLevel')\n   * // get from LengthTool instance the configuration value as being LengthToolInstance[configuration][firstLevel][secondLevel]\n   */\n  getToolConfiguration(toolName: string, configurationPath?: string): any {\n    if (this._toolInstances[toolName] === undefined) {\n      console.warn(\n        `Tool ${toolName} not present, can't set tool configuration.`\n      );\n      return;\n    }\n\n    const _configuration =\n      get(this._toolInstances[toolName].configuration, configurationPath) ||\n      this._toolInstances[toolName].configuration;\n\n    return cloneDeep(_configuration);\n  }\n\n  /**\n   *\n   * @param newToolGroupId - Id of the new (clone) tool group\n   * @param fnToolFilter - Function to filter which tools from this tool group\n   * should be added to the new (clone) one. Example: only annotations tools\n   * can be filtered and added to the new tool group.\n   * @returns A new tool group that is a clone of this one\n   */\n  public clone(\n    newToolGroupId,\n    fnToolFilter: (toolName: string) => void = null\n  ): IToolGroup {\n    let toolGroup = ToolGroupManager.getToolGroup(newToolGroupId);\n\n    if (toolGroup) {\n      console.warn(`ToolGroup ${newToolGroupId} already exists`);\n      return toolGroup;\n    }\n\n    toolGroup = ToolGroupManager.createToolGroup(newToolGroupId);\n    fnToolFilter = fnToolFilter ?? (() => true);\n\n    Object.keys(this._toolInstances)\n      .filter(fnToolFilter)\n      .forEach((toolName) => {\n        const sourceToolInstance = this._toolInstances[toolName];\n        const sourceToolOptions = this.toolOptions[toolName];\n        const sourceToolMode = sourceToolInstance.mode;\n\n        toolGroup.addTool(toolName);\n\n        (toolGroup as unknown as ToolGroup).setToolMode(\n          toolName,\n          sourceToolMode,\n          {\n            bindings: sourceToolOptions.bindings ?? [],\n          }\n        );\n      });\n\n    return toolGroup;\n  }\n\n  /**\n   * Check if the tool binding is set to be primary mouse button.\n   * @param toolOptions - The options for the tool mode.\n   * @returns A boolean value.\n   */\n  private _hasMousePrimaryButtonBinding(toolOptions) {\n    const defaultMousePrimary = this.getDefaultMousePrimary();\n\n    return toolOptions?.bindings?.some(\n      (binding) =>\n        binding.mouseButton === defaultMousePrimary &&\n        binding.modifierKey === undefined\n    );\n  }\n\n  /**\n   * It re-renders the viewports in the toolGroup\n   */\n  private _renderViewports(): void {\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      getRenderingEngine(renderingEngineId).renderViewport(viewportId);\n    });\n  }\n\n  /**\n   * Trigger ToolModeChangedEvent when changing the tool mode\n   * @param toolName - Tool name\n   * @param mode - Tool mode\n   * @param toolBindingsOptions - Binding options used when a tool is activated\n   */\n  private _triggerToolModeChangedEvent(\n    toolName: string,\n    mode: ToolModes,\n    toolBindingsOptions?: SetToolBindingsType\n  ): void {\n    const eventDetail: ToolModeChangedEventDetail = {\n      toolGroupId: this.id,\n      toolName,\n      mode,\n      toolBindingsOptions,\n    };\n\n    triggerEvent(eventTarget, Events.TOOL_MODE_CHANGED, eventDetail);\n  }\n}\n\nfunction hasSameBinding(\n  binding1: IToolBinding,\n  binding2: IToolBinding\n): boolean {\n  if (binding1.mouseButton !== binding2.mouseButton) {\n    return false;\n  }\n\n  return binding1.modifierKey === binding2.modifierKey;\n}\n","import { state } from '../index';\nimport ToolGroup from './ToolGroup';\nimport { IToolGroup } from '../../types';\n\n/**\n * Create a new tool group with the given name. ToolGroups are the new way\n * in Cornerstone3DTools to share tool configuration, state (enabled, disabled, etc.)\n * across a set of viewports.\n *\n * @param toolGroupId - The unique ID of the tool group.\n * @returns A reference to the tool group that was created.\n */\nfunction createToolGroup(toolGroupId: string): IToolGroup | undefined {\n  // Exit early if ID conflict\n  const toolGroupWithIdExists = state.toolGroups.some(\n    (tg) => tg.id === toolGroupId\n  );\n\n  if (toolGroupWithIdExists) {\n    console.warn(`'${toolGroupId}' already exists.`);\n    return;\n  }\n\n  const toolGroup = new ToolGroup(toolGroupId);\n\n  // Update state\n  state.toolGroups.push(toolGroup);\n\n  // Return reference\n  return toolGroup;\n}\n\nexport default createToolGroup;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Return the array of tool groups\n * @returns An array of tool groups.\n */\nfunction getAllToolGroups(): Array<IToolGroup> {\n  return state.toolGroups;\n}\n\nexport default getAllToolGroups;\n","/**\n * Cornerstone Color LUT used for Segmentations\n */\nconst CORNERSTONE_COLOR_LUT = [\n  [0, 0, 0, 0],\n  [221, 84, 84, 255],\n  [77, 228, 121, 255],\n  [166, 70, 235, 255],\n  [189, 180, 116, 255],\n  [109, 182, 196, 255],\n  [204, 101, 157, 255],\n  [123, 211, 94, 255],\n  [93, 87, 218, 255],\n  [225, 128, 80, 255],\n  [73, 232, 172, 255],\n  [181, 119, 186, 255],\n  [176, 193, 112, 255],\n  [105, 153, 200, 255],\n  [208, 97, 120, 255],\n  [90, 215, 101, 255],\n  [135, 83, 222, 255],\n  [229, 178, 76, 255],\n  [122, 183, 181, 255],\n  [190, 115, 171, 255],\n  [149, 197, 108, 255],\n  [100, 118, 205, 255],\n  [212, 108, 93, 255],\n  [86, 219, 141, 255],\n  [183, 79, 226, 255],\n  [233, 233, 72, 255],\n  [118, 167, 187, 255],\n  [194, 111, 146, 255],\n  [116, 201, 104, 255],\n  [115, 96, 209, 255],\n  [216, 147, 89, 255],\n  [82, 223, 188, 255],\n  [230, 75, 224, 255],\n  [163, 184, 121, 255],\n  [114, 143, 191, 255],\n  [198, 107, 114, 255],\n  [99, 206, 122, 255],\n  [153, 92, 213, 255],\n  [220, 192, 85, 255],\n  [78, 215, 227, 255],\n  [234, 71, 173, 255],\n  [141, 188, 117, 255],\n  [110, 113, 195, 255],\n  [202, 128, 103, 255],\n  [95, 210, 157, 255],\n  [195, 88, 217, 255],\n  [206, 224, 81, 255],\n  [74, 166, 231, 255],\n  [185, 120, 139, 255],\n  [113, 192, 113, 255],\n  [133, 106, 199, 255],\n  [207, 162, 98, 255],\n  [91, 214, 198, 255],\n  [221, 84, 198, 255],\n  [159, 228, 77, 255],\n  [70, 111, 235, 255],\n  [189, 119, 116, 255],\n  [109, 196, 138, 255],\n  [165, 101, 204, 255],\n  [211, 201, 94, 255],\n  [87, 191, 218, 255],\n  [225, 80, 153, 255],\n  [106, 232, 73, 255],\n  [124, 119, 186, 255],\n  [193, 142, 112, 255],\n  [105, 200, 168, 255],\n  [203, 97, 208, 255],\n  [184, 215, 90, 255],\n  [83, 147, 222, 255],\n  [229, 76, 101, 255],\n  [122, 183, 130, 255],\n  [146, 115, 190, 255],\n  [197, 171, 108, 255],\n  [100, 205, 205, 255],\n  [212, 93, 177, 255],\n  [141, 219, 86, 255],\n  [79, 97, 226, 255],\n  [233, 99, 72, 255],\n  [118, 187, 150, 255],\n  [173, 111, 194, 255],\n  [197, 201, 104, 255],\n  [96, 171, 209, 255],\n  [216, 89, 137, 255],\n  [94, 223, 82, 255],\n  [107, 75, 230, 255],\n  [184, 153, 121, 255],\n  [114, 191, 175, 255],\n  [198, 107, 191, 255],\n  [166, 206, 99, 255],\n  [92, 132, 213, 255],\n  [220, 85, 91, 255],\n  [78, 227, 115, 255],\n  [159, 71, 234, 255],\n  [188, 176, 117, 255],\n  [110, 185, 195, 255],\n  [202, 103, 161, 255],\n  [129, 210, 95, 255],\n  [88, 88, 217, 255],\n  [224, 123, 81, 255],\n  [74, 231, 166, 255],\n  [177, 120, 185, 255],\n  [179, 192, 113, 255],\n  [106, 156, 199, 255],\n  [207, 98, 125, 255],\n  [91, 214, 96, 255],\n  [130, 84, 221, 255],\n  [228, 171, 77, 255],\n  [70, 235, 221, 255],\n  [189, 116, 174, 255],\n  [153, 196, 109, 255],\n  [101, 123, 204, 255],\n  [211, 104, 94, 255],\n  [87, 218, 136, 255],\n  [177, 80, 225, 255],\n  [232, 225, 73, 255],\n  [119, 169, 186, 255],\n  [193, 112, 149, 255],\n  [121, 200, 105, 255],\n  [111, 97, 208, 255],\n  [215, 142, 90, 255],\n  [83, 222, 181, 255],\n  [229, 76, 229, 255],\n  [165, 183, 122, 255],\n  [115, 146, 190, 255],\n  [197, 108, 119, 255],\n  [100, 205, 118, 255],\n  [148, 93, 212, 255],\n  [219, 186, 86, 255],\n  [79, 220, 226, 255],\n  [233, 72, 179, 255],\n  [144, 187, 118, 255],\n  [111, 118, 194, 255],\n  [201, 124, 104, 255],\n  [96, 209, 153, 255],\n  [189, 89, 216, 255],\n  [211, 223, 82, 255],\n  [75, 172, 230, 255],\n  [184, 121, 142, 255],\n  [117, 191, 114, 255],\n  [130, 107, 198, 255],\n  [206, 157, 99, 255],\n  [92, 213, 193, 255],\n  [220, 85, 203, 255],\n  [165, 227, 78, 255],\n  [71, 118, 234, 255],\n  [188, 117, 117, 255],\n  [110, 195, 135, 255],\n  [161, 103, 202, 255],\n  [210, 195, 95, 255],\n  [88, 195, 217, 255],\n  [224, 81, 158, 255],\n  [113, 231, 74, 255],\n  [123, 120, 185, 255],\n  [192, 139, 113, 255],\n  [106, 199, 164, 255],\n  [198, 98, 207, 255],\n  [188, 214, 91, 255],\n  [84, 153, 221, 255],\n  [228, 77, 108, 255],\n  [70, 235, 84, 255],\n  [143, 116, 189, 255],\n  [196, 167, 109, 255],\n  [101, 204, 199, 255],\n  [211, 94, 182, 255],\n  [147, 218, 87, 255],\n  [80, 104, 225, 255],\n  [232, 93, 73, 255],\n  [119, 186, 147, 255],\n  [170, 112, 193, 255],\n  [200, 200, 105, 255],\n  [97, 175, 208, 255],\n  [215, 90, 142, 255],\n  [100, 222, 83, 255],\n  [101, 76, 229, 255],\n  [183, 150, 122, 255],\n  [115, 190, 171, 255],\n  [197, 108, 194, 255],\n  [170, 205, 100, 255],\n  [93, 138, 212, 255],\n  [219, 86, 97, 255],\n  [79, 226, 110, 255],\n  [153, 72, 233, 255],\n  [187, 173, 118, 255],\n  [111, 187, 194, 255],\n  [201, 104, 165, 255],\n  [134, 209, 96, 255],\n  [89, 95, 216, 255],\n  [223, 117, 82, 255],\n  [75, 230, 159, 255],\n  [174, 121, 184, 255],\n  [182, 191, 114, 255],\n  [107, 160, 198, 255],\n  [206, 99, 130, 255],\n  [92, 213, 92, 255],\n  [124, 85, 220, 255],\n  [227, 165, 78, 255],\n  [71, 234, 214, 255],\n  [188, 117, 176, 255],\n  [156, 195, 110, 255],\n  [103, 128, 202, 255],\n  [210, 100, 95, 255],\n  [88, 217, 131, 255],\n  [170, 81, 224, 255],\n  [231, 218, 74, 255],\n  [120, 172, 185, 255],\n  [192, 113, 153, 255],\n  [125, 199, 106, 255],\n  [107, 98, 207, 255],\n  [214, 137, 91, 255],\n  [84, 221, 175, 255],\n  [222, 77, 228, 255],\n  [194, 235, 70, 255],\n  [116, 149, 189, 255],\n  [196, 109, 123, 255],\n  [101, 204, 114, 255],\n  [143, 94, 211, 255],\n  [218, 180, 87, 255],\n  [80, 225, 225, 255],\n  [232, 73, 186, 255],\n  [147, 186, 119, 255],\n  [112, 122, 193, 255],\n  [200, 121, 105, 255],\n  [97, 208, 148, 255],\n  [184, 90, 215, 255],\n  [216, 222, 83, 255],\n  [76, 178, 229, 255],\n  [183, 122, 145, 255],\n  [121, 190, 115, 255],\n  [126, 108, 197, 255],\n  [205, 153, 100, 255],\n  [93, 212, 187, 255],\n  [219, 86, 208, 255],\n  [171, 226, 79, 255],\n  [72, 126, 233, 255],\n  [187, 118, 121, 255],\n  [111, 194, 132, 255],\n  [157, 104, 201, 255],\n  [209, 190, 96, 255],\n  [89, 200, 216, 255],\n  [223, 82, 164, 255],\n  [120, 230, 75, 255],\n  [121, 121, 184, 255],\n  [191, 136, 114, 255],\n  [107, 198, 160, 255],\n  [192, 99, 206, 255],\n  [193, 213, 92, 255],\n  [85, 158, 220, 255],\n  [227, 78, 115, 255],\n  [71, 234, 78, 255],\n  [141, 117, 188, 255],\n  [195, 163, 110, 255],\n  [103, 202, 194, 255],\n  [210, 95, 186, 255],\n  [153, 217, 88, 255],\n  [81, 111, 224, 255],\n];\n\nexport default CORNERSTONE_COLOR_LUT;\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\n\n/**\n * Synchronizer callback to synchronize the camera by updating all camera\n * values.  See also zoomPanSyncCallback\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, never\n *   the same as sourceViewport.\n * @param cameraModifiedEvent - The CAMERA_MODIFIED event.\n */\nexport default function cameraSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId,\n  cameraModifiedEvent: CustomEvent\n): void {\n  const { camera } = cameraModifiedEvent.detail;\n\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n\n  tViewport.setCamera(camera);\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport cameraSyncCallback from '../callbacks/cameraSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createCameraPositionSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const cameraPositionSynchronizer = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    cameraSyncCallback\n  );\n\n  return cameraPositionSynchronizer;\n}\n","import {\n  BaseVolumeViewport,\n  getRenderingEngine,\n  StackViewport,\n  Types,\n} from '@cornerstonejs/core';\n\n/**\n * Synchronizer callback to synchronize the voi of volumeActors of identical volumes\n * in different viewports.\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport.\n * @param voiModifiedEvent - The VOI_MODIFIED event.\n * @param options - Options for the synchronizer.\n */\nexport default function voiSyncCallback(\n  synchronizerInstance,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId,\n  voiModifiedEvent: Types.EventTypes.VoiModifiedEvent,\n  options?: any\n): void {\n  const eventDetail = voiModifiedEvent.detail;\n  const { volumeId, range, invertStateChanged, invert } = eventDetail;\n\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `Rendering Engine does not exist: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n  const tProperties:\n    | Types.VolumeViewportProperties\n    | Types.StackViewportProperties = {\n    voiRange: range,\n  };\n\n  if (options?.syncInvertState && invertStateChanged) {\n    tProperties.invert = invert;\n  }\n\n  if (tViewport instanceof BaseVolumeViewport) {\n    tViewport.setProperties(tProperties, volumeId);\n  } else if (tViewport instanceof StackViewport) {\n    tViewport.setProperties(tProperties);\n  } else {\n    throw new Error('Viewport type not supported.');\n  }\n\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport voiSyncCallback from '../callbacks/voiSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\ntype VOISynchronizerOptions = {\n  syncInvertState: boolean;\n};\n\n/**\n * A helper that creates a new `Synchronizer`\n * which listens to the `VOI_MODIFIED` rendering event and calls the `voiSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @param options - The options for the synchronizer. By default the voi\n * synchronizer will also sync the invert state of the volume, but this can be\n * disabled by setting `syncInvertState` to false.\n *\n * @returns A new `Synchronizer` instance.\n */\nexport default function createVOISynchronizer(\n  synchronizerName: string,\n  options = { syncInvertState: true } as VOISynchronizerOptions\n): Synchronizer {\n  const VOISynchronizer = createSynchronizer(\n    synchronizerName,\n    Enums.Events.VOI_MODIFIED,\n    voiSyncCallback,\n    options\n  );\n\n  return VOISynchronizer;\n}\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\n\n/**\n * Synchronizer callback to synchronize the camera. Synchronization\n *\n * targetViewport.options.syncZoom set to false to not sync the zoom\n * targetViewport.options.syncPan set to false to not sync the pan\n\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, different\n *   from sourceViewport\n */\nexport default function zoomPanSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId\n): void {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n\n  if (options?.syncZoom !== false) {\n    const srcZoom = sViewport.getZoom();\n    // Do the zoom first, as the pan is relative to the zoom level\n    tViewport.setZoom(srcZoom);\n  }\n  if (options?.syncPan !== false) {\n    const srcPan = sViewport.getPan();\n    tViewport.setPan(srcPan);\n  }\n\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport zoomPanSyncCallback from '../callbacks/zoomPanSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createZoomPanSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const zoomPanSynchronizer = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    zoomPanSyncCallback\n  );\n\n  return zoomPanSynchronizer;\n}\n","/**\n * Clips a value to an upper and lower bound.\n * @export @public @method\n * @name clip\n *\n * @param  {number} val  The value to clip.\n * @param  {number} low  The lower bound.\n * @param  {number} high The upper bound.\n * @returns {number}      The clipped value.\n */\nexport function clip(val, low, high) {\n  return Math.min(Math.max(low, val), high);\n}\n\n/**\n * Clips a value within a box.\n * @export @public @method\n * @name clipToBox\n *\n * @param  {Object} point The point to clip\n * @param  {Object} box   The bounding box to clip to.\n * @returns {Object}       The clipped point.\n */\nexport function clipToBox(point, box) {\n  // Clip an {x, y} point to a box of size {width, height}\n  point.x = clip(point.x, 0, box.width);\n  point.y = clip(point.y, 0, box.height);\n}\n\nexport default clip;\n","import {\n  StackViewport,\n  Types,\n  VolumeViewport,\n  eventTarget,\n  EVENTS,\n  utilities as csUtils,\n  getEnabledElement,\n  VideoViewport,\n} from '@cornerstonejs/core';\nimport { ScrollOptions, EventTypes } from '../types';\n\n/**\n * It scrolls one slice in the Stack or Volume Viewport, it uses the options provided\n * to determine the slice to scroll to. For Stack Viewport, it scrolls in the 1 or -1\n * direction, for Volume Viewport, it uses the camera and focal point to determine the\n * slice to scroll to based on the spacings.\n * @param viewport - The viewport in which to scroll\n * @param options - Options to use for scrolling, including direction, invert, and volumeId\n * @returns\n */\nexport default function scroll(\n  viewport: Types.IViewport,\n  options: ScrollOptions\n): void {\n  // check if viewport is disabled then throw error\n  const enabledElement = getEnabledElement(viewport.element);\n\n  if (!enabledElement) {\n    throw new Error('Scroll::Viewport is not enabled (it might be disabled)');\n  }\n\n  if (\n    viewport instanceof StackViewport &&\n    viewport.getImageIds().length === 0\n  ) {\n    throw new Error('Scroll::Stack Viewport has no images');\n  }\n\n  const { type: viewportType } = viewport;\n  const { volumeId, delta, scrollSlabs } = options;\n\n  if (viewport instanceof StackViewport) {\n    viewport.scroll(delta, options.debounceLoading, options.loop);\n  } else if (viewport instanceof VolumeViewport) {\n    scrollVolume(viewport, volumeId, delta, scrollSlabs);\n  } else if (viewport instanceof VideoViewport) {\n    viewport.scroll(delta);\n  } else {\n    throw new Error(`Not implemented for Viewport Type: ${viewportType}`);\n  }\n}\n\nexport function scrollVolume(\n  viewport: VolumeViewport,\n  volumeId: string,\n  delta: number,\n  scrollSlabs = false\n) {\n  const useSlabThickness = scrollSlabs;\n\n  const { numScrollSteps, currentStepIndex, sliceRangeInfo } =\n    csUtils.getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness);\n\n  if (!sliceRangeInfo) {\n    return;\n  }\n\n  const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;\n  const { focalPoint, viewPlaneNormal, position } = camera;\n\n  const { newFocalPoint, newPosition } = csUtils.snapFocalPointToSlice(\n    focalPoint,\n    position,\n    sliceRange,\n    viewPlaneNormal,\n    spacingInNormalDirection,\n    delta\n  );\n\n  viewport.setCamera({\n    focalPoint: newFocalPoint,\n    position: newPosition,\n  });\n  viewport.render();\n\n  const desiredStepIndex = currentStepIndex + delta;\n\n  if (\n    (desiredStepIndex > numScrollSteps || desiredStepIndex < 0) &&\n    viewport.getCurrentImageId() // Check that we are in the plane of acquistion\n  ) {\n    // One common use case of this trigger might be to load the next\n    // volume in a time series or the next segment of a partially loaded volume.\n\n    const VolumeScrollEventDetail = {\n      volumeId,\n      viewport,\n      delta,\n      desiredStepIndex,\n      currentStepIndex,\n      numScrollSteps,\n      currentImageId: viewport.getCurrentImageId(),\n    };\n\n    csUtils.triggerEvent(\n      eventTarget,\n      EVENTS.VOLUME_SCROLL_OUT_OF_BOUNDS,\n      VolumeScrollEventDetail as EventTypes.VolumeScrollOutOfBoundsEventDetail\n    );\n  }\n}\n","import {\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  utilities as csUtils,\n  Types,\n} from '@cornerstonejs/core';\nimport JumpToSliceOptions from '../../types/JumpToSliceOptions';\nimport clip from '../clip';\nimport scroll from '../scroll';\n\n/**\n * It uses the imageIndex in the Options to scroll to the slice that is intended.\n * It works for both Stack and Volume viewports. In VolumeViewports, the imageIndex\n * should be given with respect to the index in the 3D image in the view direction\n * (i.e. the index of the slice in Axial, Sagittal, Coronal, or Oblique).\n *\n * @param element - the HTML Div element scrolling inside\n * @param options - the options used for jumping to a slice\n * @returns Promise that resolves to ImageIdIndex\n */\nasync function jumpToSlice(\n  element: HTMLDivElement,\n  options = {} as JumpToSliceOptions\n): Promise<void> {\n  const { imageIndex, debounceLoading, volumeId } = options;\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error('Element has been disabled');\n  }\n\n  const { viewport } = enabledElement;\n\n  const { imageIndex: currentImageIndex, numberOfSlices } = _getImageSliceData(\n    viewport,\n    debounceLoading\n  );\n\n  const imageIndexToJump = _getImageIndexToJump(numberOfSlices, imageIndex);\n  const delta = imageIndexToJump - currentImageIndex;\n\n  scroll(viewport, { delta, debounceLoading, volumeId });\n}\n\nfunction _getImageSliceData(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  debounceLoading?: boolean\n): Types.ImageSliceData {\n  if (viewport instanceof StackViewport) {\n    return {\n      numberOfSlices: viewport.getImageIds().length,\n      imageIndex: debounceLoading\n        ? viewport.getTargetImageIdIndex()\n        : viewport.getCurrentImageIdIndex(),\n    };\n  } else if (viewport instanceof VolumeViewport) {\n    return csUtils.getImageSliceDataForVolumeViewport(viewport);\n  } else {\n    throw new Error('Unsupported viewport type');\n  }\n}\n\nfunction _getImageIndexToJump(\n  numberOfSlices: number,\n  imageIndex: number\n): number {\n  const lastSliceIndex = numberOfSlices - 1;\n\n  return clip(imageIndex, 0, lastSliceIndex);\n}\n\nexport default jumpToSlice;\n","import { vec3, mat4 } from 'gl-matrix';\nimport {\n  getRenderingEngine,\n  Types,\n  metaData,\n  utilities,\n  VolumeViewport,\n} from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\nimport { jumpToSlice } from '../../utilities';\nimport areViewportsCoplanar from './areViewportsCoplanar ';\n\nconst getSpatialRegistration = (targetId, sourceId) =>\n  utilities.spatialRegistrationMetadataProvider.get(\n    'spatialRegistrationModule',\n    targetId,\n    sourceId\n  );\n\n/**\n * Synchronizer callback to synchronize the source viewport image to the\n * target viewports closest image in its stack.\n *\n * This synchronizer does a setup (which can already be predefined as required)\n * to register the target and soruce viewports.  The registration will default\n * to the identity registration if the same FOR is present in both viewports,\n * unless the option `useInitialPosition` is set in the target viewport.\n *\n * The consuming apps using Cornerstone3D (OHIF, etc) MAY provide such data in\n * the registrationMetadataProvider to override the data here. This can be done\n * by various methods 1) Using spatialRegistrationModule inside dicom 2) assuming\n * the user has actually manually scrolled the target viewport to the correct\n * slice before initiating the synchronization 3) using some other method\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, never\n *   the same as sourceViewport.\n * @param cameraModifiedEvent - The CAMERA_MODIFIED event.\n */\nexport default async function imageSliceSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId\n): Promise<void> {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId) as\n    | Types.IVolumeViewport\n    | Types.IStackViewport;\n\n  const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n\n  if (options?.disabled) {\n    return;\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId) as\n    | Types.IVolumeViewport\n    | Types.IStackViewport;\n\n  const imageId1 = sViewport.getCurrentImageId();\n  const imagePlaneModule1 = metaData.get('imagePlaneModule', imageId1);\n  const sourceImagePositionPatient = imagePlaneModule1.imagePositionPatient;\n\n  const targetImageIds = tViewport.getImageIds();\n\n  if (!areViewportsCoplanar(sViewport, tViewport)) {\n    return;\n  }\n\n  // if the frame of reference is different we need to use the registrationMetadataProvider\n  // and add that to the imagePositionPatient of the source viewport to get the\n  // imagePositionPatient of the target viewport's closest image in its stack\n  let registrationMatrixMat4 = getSpatialRegistration(\n    targetViewport.viewportId,\n    sourceViewport.viewportId\n  );\n\n  if (!registrationMatrixMat4) {\n    const frameOfReferenceUID1 = sViewport.getFrameOfReferenceUID();\n    const frameOfReferenceUID2 = tViewport.getFrameOfReferenceUID();\n    if (\n      frameOfReferenceUID1 === frameOfReferenceUID2 &&\n      options?.useInitialPosition !== false\n    ) {\n      registrationMatrixMat4 = mat4.identity(mat4.create());\n    } else {\n      utilities.calculateViewportsSpatialRegistration(sViewport, tViewport);\n      registrationMatrixMat4 = getSpatialRegistration(\n        targetViewport.viewportId,\n        sourceViewport.viewportId\n      );\n    }\n    if (!registrationMatrixMat4) {\n      return;\n    }\n  }\n\n  // apply the registration matrix to the source viewport's imagePositionPatient\n  // to get the target viewport's imagePositionPatient\n  const targetImagePositionPatientWithRegistrationMatrix = vec3.transformMat4(\n    vec3.create(),\n    sourceImagePositionPatient,\n    registrationMatrixMat4\n  );\n\n  // find the closest image in the target viewport's stack to the\n  // targetImagePositionPatientWithRegistrationMatrix\n  const closestImageIdIndex2 = _getClosestImageIdIndex(\n    targetImagePositionPatientWithRegistrationMatrix,\n    targetImageIds\n  );\n\n  let imageIndexToSet = closestImageIdIndex2.index;\n  if (tViewport instanceof VolumeViewport) {\n    // since in case of volume viewport our stack is reversed, we should\n    // reverse the index as well\n    imageIndexToSet = targetImageIds.length - closestImageIdIndex2.index - 1;\n  }\n\n  if (\n    closestImageIdIndex2.index !== -1 &&\n    tViewport.getCurrentImageIdIndex() !== closestImageIdIndex2.index\n  ) {\n    await jumpToSlice(tViewport.element, {\n      imageIndex: imageIndexToSet,\n    });\n  }\n}\n\nfunction _getClosestImageIdIndex(targetPoint, imageIds) {\n  // todo: this does not assume orientation yet, but that can be added later\n  // todo: handle multiframe images\n  return imageIds.reduce(\n    (closestImageIdIndex, imageId, index) => {\n      const { imagePositionPatient } = metaData.get(\n        'imagePlaneModule',\n        imageId\n      );\n      const distance = vec3.distance(imagePositionPatient, targetPoint);\n\n      if (distance < closestImageIdIndex.distance) {\n        return {\n          distance,\n          index,\n        };\n      }\n      return closestImageIdIndex;\n    },\n    {\n      distance: Infinity,\n      index: -1,\n    }\n  );\n}\n","import { vec3 } from 'gl-matrix';\nimport { Types } from '@cornerstonejs/core';\n\nexport default function areViewportsCoplanar(\n  viewport1: Types.IStackViewport | Types.IVolumeViewport,\n  viewport2: Types.IStackViewport | Types.IVolumeViewport\n): boolean {\n  const { viewPlaneNormal: viewPlaneNormal1 } = viewport1.getCamera();\n  const { viewPlaneNormal: viewPlaneNormal2 } = viewport2.getCamera();\n  const dotProducts = vec3.dot(viewPlaneNormal1, viewPlaneNormal2);\n  return Math.abs(dotProducts) > 0.9;\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport imageSliceSyncCallback from '../callbacks/imageSliceSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { STACK_NEW_IMAGE, VOLUME_NEW_IMAGE } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `STACK_NEW_IMAGE`\n * rendering event and calls the `ImageSliceSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createImageSliceSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const stackImageSynchronizer = createSynchronizer(\n    synchronizerName,\n    STACK_NEW_IMAGE,\n    imageSliceSyncCallback,\n    {\n      auxiliaryEventNames: [VOLUME_NEW_IMAGE],\n    }\n  );\n\n  return stackImageSynchronizer;\n}\n","import createCameraPositionSynchronizer from './synchronizers/createCameraPositionSynchronizer';\nimport createVOISynchronizer from './synchronizers/createVOISynchronizer';\nimport createZoomPanSynchronizer from './synchronizers/createZoomPanSynchronizer';\nimport createImageSliceSynchronizer from './synchronizers/createImageSliceSynchronizer';\n\n// for backward compatibility\nconst createStackImageSynchronizer = createImageSliceSynchronizer;\n\nexport {\n  createCameraPositionSynchronizer,\n  createVOISynchronizer,\n  createZoomPanSynchronizer,\n  createImageSliceSynchronizer,\n  createStackImageSynchronizer,\n};\n","function _getHash(\n  annotationUID: string,\n  drawingElementType: string,\n  nodeUID: string\n): string {\n  return `${annotationUID}::${drawingElementType}::${nodeUID}`;\n}\n\nexport default _getHash;\n","export function setAttributesIfNecessary(attributes, svgNode) {\n  Object.keys(attributes).forEach((key) => {\n    const currentValue = svgNode.getAttribute(key);\n    const newValue = attributes[key];\n    if (newValue === undefined || newValue === '') {\n      svgNode.removeAttribute(key);\n    } else if (currentValue !== newValue) {\n      svgNode.setAttribute(key, newValue);\n    }\n  });\n}\n\nexport default setAttributesIfNecessary;\n","export function setNewAttributesIfValid(attributes, svgNode) {\n  Object.keys(attributes).forEach((key) => {\n    const newValue = attributes[key];\n    if (newValue !== undefined && newValue !== '') {\n      svgNode.setAttribute(key, newValue);\n    }\n  });\n}\n\nexport default setNewAttributesIfValid;\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\n\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\n\nfunction drawCircle(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  circleUID: string,\n  center: Types.Point2,\n  radius: number,\n  options = {},\n  dataId = ''\n): void {\n  const {\n    color,\n    fill,\n    width,\n    lineWidth,\n    lineDash,\n    fillOpacity,\n    strokeOpacity,\n  } = Object.assign(\n    {\n      color: 'dodgerblue',\n      fill: 'transparent',\n      width: '2',\n      lineDash: undefined,\n      lineWidth: undefined,\n      strokeOpacity: 1,\n      fillOpacity: 1,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  // variable for the namespace\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'circle', circleUID);\n  const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const attributes = {\n    cx: `${center[0]}`,\n    cy: `${center[1]}`,\n    r: `${radius}`,\n    stroke: color,\n    fill,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n    'fill-opacity': fillOpacity, // setting fill opacity\n    'stroke-opacity': strokeOpacity, // setting stroke opacity\n  };\n\n  if (existingCircleElement) {\n    setAttributesIfNecessary(attributes, existingCircleElement);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newCircleElement = document.createElementNS(svgns, 'circle');\n\n    if (dataId !== '') {\n      newCircleElement.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, newCircleElement);\n\n    svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);\n  }\n}\n\nexport default drawCircle;\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\n\nfunction drawEllipseByCoordinates(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  ellipseUID: string,\n  canvasCoordinates: [Types.Point2, Types.Point2, Types.Point2, Types.Point2],\n  options = {},\n  dataId = ''\n): void {\n  const { color, width, lineWidth, lineDash } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'ellipse', ellipseUID);\n  const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const [bottom, top, left, right] = canvasCoordinates;\n\n  const w = Math.hypot(left[0] - right[0], left[1] - right[1]);\n  const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);\n  const angle =\n    (Math.atan2(left[1] - right[1], left[0] - right[0]) * 180) / Math.PI;\n\n  const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];\n  const radiusX = w / 2;\n  const radiusY = h / 2;\n\n  const attributes = {\n    cx: `${center[0]}`,\n    cy: `${center[1]}`,\n    rx: `${radiusX}`,\n    ry: `${radiusY}`,\n    stroke: color,\n    fill: 'transparent',\n    transform: `rotate(${angle} ${center[0]} ${center[1]})`,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingEllipse) {\n    setAttributesIfNecessary(attributes, existingEllipse);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgEllipseElement = document.createElementNS(svgns, 'ellipse');\n\n    if (dataId !== '') {\n      svgEllipseElement.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, svgEllipseElement);\n\n    svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);\n  }\n}\n\nexport default drawEllipseByCoordinates;\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\nimport drawEllipseByCoordinates from './drawEllipseByCoordinates';\n\nfunction drawEllipse(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  ellipseUID: string,\n  corner1: Types.Point2,\n  corner2: Types.Point2,\n  options = {},\n  dataId = ''\n) {\n  const top: Types.Point2 = [(corner1[0] + corner2[0]) / 2, corner1[1]];\n  const bottom: Types.Point2 = [(corner1[0] + corner2[0]) / 2, corner2[1]];\n  const left: Types.Point2 = [corner1[0], (corner1[1] + corner2[1]) / 2];\n  const right: Types.Point2 = [corner2[0], (corner1[1] + corner2[1]) / 2];\n\n  drawEllipseByCoordinates(\n    svgDrawingHelper,\n    annotationUID,\n    ellipseUID,\n    [bottom, top, left, right],\n    (options = {}),\n    (dataId = '')\n  );\n}\n\nexport default drawEllipse;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\nfunction drawHandle(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  handleGroupUID: string,\n  handle: Types.Point2,\n  options = {},\n  uniqueIndex\n): void {\n  const { color, handleRadius, width, lineWidth, fill, type, opacity } =\n    Object.assign(\n      {\n        color: 'dodgerblue',\n        handleRadius: '6',\n        width: '2',\n        lineWidth: undefined,\n        fill: 'transparent',\n        type: 'circle',\n        opacity: 1,\n      },\n      options\n    );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  // variable for the namespace\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(\n    annotationUID,\n    'handle',\n    `hg-${handleGroupUID}-index-${uniqueIndex}`\n  );\n\n  let attributes;\n  if (type === 'circle') {\n    attributes = {\n      cx: `${handle[0]}`,\n      cy: `${handle[1]}`,\n      r: handleRadius,\n      stroke: color,\n      fill,\n      'stroke-width': strokeWidth,\n      opacity: opacity,\n    };\n  } else if (type === 'rect') {\n    const handleRadiusFloat = parseFloat(handleRadius);\n    const side = handleRadiusFloat * 1.5;\n    const x = handle[0] - side * 0.5;\n    const y = handle[1] - side * 0.5;\n\n    attributes = {\n      x: `${x}`,\n      y: `${y}`,\n      width: `${side}`,\n      height: `${side}`,\n      stroke: color,\n      fill,\n      'stroke-width': strokeWidth,\n      rx: `${side * 0.1}`,\n      opacity: opacity,\n    };\n  } else {\n    throw new Error(`Unsupported handle type: ${type}`);\n  }\n\n  const existingHandleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  if (existingHandleElement) {\n    setAttributesIfNecessary(attributes, existingHandleElement);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newHandleElement = document.createElementNS(svgns, type);\n\n    setNewAttributesIfValid(attributes, newHandleElement);\n\n    svgDrawingHelper.appendNode(newHandleElement, svgNodeHash);\n  }\n}\n\nexport default drawHandle;\n","import type { Types } from '@cornerstonejs/core';\n\nimport { SVGDrawingHelper } from '../types';\nimport drawHandle from './drawHandle';\n\nfunction drawHandles(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  handleGroupUID: string,\n  handlePoints: Array<Types.Point2>,\n  options = {}\n): void {\n  handlePoints.forEach((handle, i) => {\n    drawHandle(\n      svgDrawingHelper,\n      annotationUID,\n      handleGroupUID,\n      handle,\n      options,\n      i\n    );\n  });\n}\n\nexport default drawHandles;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\nexport default function drawLine(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  lineUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {},\n  dataId = ''\n): void {\n  // if length is NaN return\n  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n    return;\n  }\n\n  const { color, width, lineWidth, lineDash, shadow } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n      shadow: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'line', lineUID);\n  const existingLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n  const dropShadowStyle = shadow\n    ? `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`\n    : '';\n\n  const attributes = {\n    x1: `${start[0]}`,\n    y1: `${start[1]}`,\n    x2: `${end[0]}`,\n    y2: `${end[1]}`,\n    stroke: color,\n    style: dropShadowStyle,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingLine) {\n    // This is run to avoid re-rendering annotations that actually haven't changed\n    setAttributesIfNecessary(attributes, existingLine);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newLine = document.createElementNS(svgns, 'line');\n\n    if (dataId !== '') {\n      newLine.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, newLine);\n\n    svgDrawingHelper.appendNode(newLine, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\n/**\n * Draws an SVG polyline with the given points.\n *\n * The `connectLastToFirst` option, if true, draws a closed polyline, with the\n * last point connected to the first.\n */\nexport default function drawPolyline(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  polylineUID: string,\n  points: Types.Point2[],\n  options: {\n    color?: string;\n    fillColor?: string;\n    fillOpacity?: number;\n    width?: number;\n    lineWidth?: number;\n    lineDash?: string;\n    connectLastToFirst?: boolean;\n  }\n): void {\n  if (points.length < 2) {\n    return;\n  }\n\n  const { fillColor, fillOpacity, color, width, lineWidth, lineDash } =\n    Object.assign(\n      {\n        color: 'dodgerblue',\n        width: '2',\n        fillColor: 'none',\n        fillOpacity: 0,\n        lineWidth: undefined,\n        lineDash: undefined,\n        connectLastToFirst: false,\n      },\n      options\n    );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'polyline', polylineUID);\n  const existingPolyLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  let pointsAttribute = '';\n\n  for (const point of points) {\n    pointsAttribute += `${point[0]}, ${point[1]} `;\n  }\n\n  if (options.connectLastToFirst) {\n    const firstPoint = points[0];\n\n    pointsAttribute += `${firstPoint[0]}, ${firstPoint[1]}`;\n  }\n\n  const attributes = {\n    points: pointsAttribute,\n    stroke: color,\n    fill: fillColor,\n    'fill-opacity': fillOpacity,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingPolyLine) {\n    // This is run to avoid re-rendering annotations that actually haven't changed\n    setAttributesIfNecessary(attributes, existingPolyLine);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newPolyLine = document.createElementNS(svgns, 'polyline');\n\n    setNewAttributesIfValid(attributes, newPolyLine);\n\n    svgDrawingHelper.appendNode(newPolyLine, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\n\n/**\n * Draws a textBox.\n *\n * @param textLines - The text to display.\n * @param position - The x/y position of the textbox\n * @param options - Options for the textBox.\n * @returns Bounding box; can be used for isPointNearTool\n */\nfunction drawTextBox(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textUID: string,\n  textLines: Array<string>,\n  position: Types.Point2,\n  options = {}\n): SVGRect {\n  const mergedOptions = Object.assign(\n    {\n      fontFamily: 'Helvetica, Arial, sans-serif',\n      fontSize: '14px',\n      color: 'rgb(255, 255, 0)',\n      background: '',\n      padding: 25,\n      centerX: false,\n      centerY: true,\n    },\n    options\n  );\n\n  // Draw each of the text lines on top of the background box\n  const textGroupBoundingBox = _drawTextGroup(\n    svgDrawingHelper,\n    annotationUID,\n    textUID,\n    textLines,\n    position,\n    mergedOptions\n  );\n\n  return textGroupBoundingBox;\n}\n\nfunction _drawTextGroup(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textUID: string,\n  textLines: Array<string> = [''],\n  position: Types.Point2,\n  options: any\n): SVGRect {\n  const { padding, color, fontFamily, fontSize, background } = options;\n\n  let textGroupBoundingBox;\n  const [x, y] = [position[0] + padding, position[1] + padding];\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'text', textUID);\n  const existingTextGroup = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  // Todo: right now textBox gets a re-render even if the textBox has not changed\n  // and evenIf the attributes are not set again since they are the same.\n  if (existingTextGroup) {\n    // TODO: Iterate each node and update color? font-size?\n    const textElement = existingTextGroup.querySelector('text');\n    const textSpans = Array.from(textElement.children) as Array<SVGElement>;\n\n    for (let i = 0; i < textSpans.length; i++) {\n      const textSpanElement = textSpans[i];\n      const text = textLines[i] || '';\n\n      textSpanElement.textContent = text;\n    }\n\n    // if the textLines have changed size, we need to create textSpans for them\n    if (textLines.length > textSpans.length) {\n      for (let i = 0; i < textLines.length - textSpans.length; i++) {\n        const textLine = textLines[i + textSpans.length];\n        const textSpan = _createTextSpan(textLine);\n\n        textElement.appendChild(textSpan);\n      }\n\n      existingTextGroup.appendChild(textElement);\n      svgDrawingHelper.appendNode(existingTextGroup, svgNodeHash);\n    }\n\n    const textAttributes = {\n      fill: color,\n      'font-size': fontSize,\n      'font-family': fontFamily,\n    };\n\n    const textGroupAttributes = {\n      transform: `translate(${x} ${y})`,\n    };\n\n    // Todo: for some reason this does not work to not re-render the textBox\n    setAttributesIfNecessary(textAttributes, textElement);\n    setAttributesIfNecessary(textGroupAttributes, existingTextGroup);\n\n    textGroupBoundingBox = _drawTextBackground(existingTextGroup, background);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const textGroup = document.createElementNS(svgns, 'g');\n\n    textGroup.setAttribute('transform', `translate(${x} ${y})`);\n\n    //\n    const textElement = _createTextElement(svgDrawingHelper, options);\n    for (let i = 0; i < textLines.length; i++) {\n      const textLine = textLines[i];\n      const textSpan = _createTextSpan(textLine);\n\n      textElement.appendChild(textSpan);\n    }\n\n    textGroup.appendChild(textElement);\n    svgDrawingHelper.appendNode(textGroup, svgNodeHash);\n    textGroupBoundingBox = _drawTextBackground(textGroup, background);\n  }\n\n  // We translate the group using `position`\n  // which means we also need to pluck those values when returning\n  // the bounding box\n  return Object.assign({}, textGroupBoundingBox, {\n    x,\n    y,\n    height: textGroupBoundingBox.height + padding,\n    width: textGroupBoundingBox.width + padding,\n  });\n}\n\nfunction _createTextElement(\n  svgDrawingHelper: SVGDrawingHelper,\n  options: any\n): SVGElement {\n  const { color, fontFamily, fontSize } = options;\n  const svgns = 'http://www.w3.org/2000/svg';\n  const textElement = document.createElementNS(svgns, 'text');\n  const noSelectStyle =\n    'user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);';\n  const dropShadowStyle = `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`;\n  const combinedStyle = `${noSelectStyle}${dropShadowStyle}`;\n\n  // font-size=\"100\"\n  textElement.setAttribute('x', '0');\n  textElement.setAttribute('y', '0');\n  textElement.setAttribute('fill', color);\n  textElement.setAttribute('font-family', fontFamily);\n  textElement.setAttribute('font-size', fontSize);\n  textElement.setAttribute('style', combinedStyle);\n\n  return textElement;\n}\n\nfunction _createTextSpan(text): SVGElement {\n  const svgns = 'http://www.w3.org/2000/svg';\n  const textSpanElement = document.createElementNS(svgns, 'tspan');\n\n  // TODO: centerX\n  // (parent width / 2) - my width\n  // TODO: centerY\n\n  textSpanElement.setAttribute('x', '0');\n  textSpanElement.setAttribute('dy', '1.2em');\n  textSpanElement.textContent = text;\n\n  return textSpanElement;\n}\n\nfunction _drawTextBackground(group: SVGGElement, color: string) {\n  let element = group.querySelector('rect.background');\n\n  // If we have no background color, remove any element that exists and return\n  // the bounding box of the text\n  if (!color) {\n    if (element) {\n      group.removeChild(element);\n    }\n\n    return group.getBBox();\n  }\n\n  // Otherwise, check if we have a <rect> element. If not, create one\n  if (!element) {\n    element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n    element.setAttribute('class', 'background');\n    group.insertBefore(element, group.firstChild);\n  }\n\n  // Get the text groups's bounding box and use it to draw the background rectangle\n  const bBox = group.getBBox();\n\n  const attributes = {\n    x: `${bBox.x}`,\n    y: `${bBox.y}`,\n    width: `${bBox.width}`,\n    height: `${bBox.height}`,\n    fill: color,\n  };\n\n  setAttributesIfNecessary(attributes, element);\n\n  return bBox;\n}\n\nexport default drawTextBox;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Find the closest point to the target point\n *\n * @param sourcePoints - The potential source points.\n * @param targetPoint - The target point, used to find the closest source.\n * @returns The closest point in the array of point sources\n */\nexport default function findClosestPoint(\n  sourcePoints: Array<Types.Point2>,\n  targetPoint: Types.Point2\n): Types.Point2 {\n  let minPoint = [0, 0];\n  let minDistance = Number.MAX_SAFE_INTEGER;\n\n  sourcePoints.forEach(function (sourcePoint) {\n    const distance = _distanceBetween(targetPoint, sourcePoint);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      minPoint = [...sourcePoint];\n    }\n  });\n\n  return minPoint as Types.Point2;\n}\n\n/**\n *\n * @private\n * @param p1\n * @param p2\n */\nfunction _distanceBetween(p1: Types.Point2, p2: Types.Point2): number {\n  const [x1, y1] = p1;\n  const [x2, y2] = p2;\n\n  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport drawLine from './drawLine';\nimport findClosestPoint from '../utilities/math/vec2/findClosestPoint';\nimport { PlanarBoundingBox, SVGDrawingHelper } from '../types';\n\n/**\n * Draw a link between an annotation to a box.\n */\nfunction drawLink(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  linkUID: string,\n  // Find closest point to approx. bounding box\n  annotationAnchorPoints: Array<Types.Point2>,\n  refPoint: Types.Point2,\n  // Find bounding box point that's closest to our identified\n  // start point\n  boundingBox: PlanarBoundingBox,\n  options = {}\n): void {\n  // The closest anchor point (for the annotation) to the\n  // text box / bounding box\n  const start =\n    annotationAnchorPoints.length > 0\n      ? findClosestPoint(annotationAnchorPoints, refPoint)\n      : refPoint;\n\n  // Calculate the midpoints of the bounding box\n  const boundingBoxPoints = _boundingBoxPoints(boundingBox);\n  // Find the closest textBox midpoint to the annotation's anchor/start point\n  const end = findClosestPoint(boundingBoxPoints, start);\n\n  // Finally we draw the dashed linking line\n  const mergedOptions = Object.assign(\n    {\n      color: 'rgb(255, 255, 0)',\n      lineWidth: '1',\n      lineDash: '2,3',\n    },\n    options\n  );\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    `link-${linkUID}`,\n    start,\n    end,\n    mergedOptions\n  );\n}\n\n/**\n * Find potential anchor points for a given bounding box. For example, it may\n * look nicer to draw a line from the \"middle left\" of a bounding box to an\n * annotation (instead of from a corner). This function calculates those points\n *\n * @param boundingBox\n */\nfunction _boundingBoxPoints(\n  boundingBox: PlanarBoundingBox\n): Array<Types.Point2> {\n  const { x: left, y: top, height, width } = boundingBox;\n  const halfWidth = width / 2;\n  const halfHeight = height / 2;\n\n  const topMiddle = [left + halfWidth, top] as Types.Point2;\n  const leftMiddle = [left, top + halfHeight] as Types.Point2;\n  const bottomMiddle = [left + halfWidth, top + height] as Types.Point2;\n  const rightMiddle = [left + width, top + halfHeight] as Types.Point2;\n\n  return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];\n}\n\nexport default drawLink;\n","import type { Types } from '@cornerstonejs/core';\n\nimport drawTextBox from './drawTextBox';\nimport drawLink from './drawLink';\nimport { SVGDrawingHelper } from '../types';\n\nfunction drawLinkedTextBox(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textBoxUID: string,\n  //\n  textLines: Array<string>,\n  textBoxPosition: Types.Point2,\n  annotationAnchorPoints: Array<Types.Point2>,\n  textBox: unknown,\n  options = {}\n  // TODO: yCenter as an option\n): SVGRect {\n  const mergedOptions = Object.assign(\n    {\n      handleRadius: '6',\n      centering: {\n        x: false,\n        y: true, // yCenter,\n      },\n    },\n    options\n  );\n\n  // Draw the text box\n  const canvasBoundingBox = drawTextBox(\n    svgDrawingHelper,\n    annotationUID,\n    textBoxUID,\n    textLines,\n    textBoxPosition,\n    mergedOptions\n  );\n  // if (textBox.hasMoved) {\n  //   // Draw dashed link line between tool and text\n  drawLink(\n    svgDrawingHelper,\n    annotationUID,\n    textBoxUID,\n    annotationAnchorPoints, // annotationAnchorPoints\n    textBoxPosition, // refPoint (text)\n    canvasBoundingBox, // textBoxBoundingBox\n    mergedOptions\n  );\n  // }\n\n  // const { top, left, width, height } = canvasBoundingBox\n\n  // textBox.worldBoundingBox = {\n  //   topLeft: canvasToWorld([left, top]),\n  //   topRight: canvasToWorld([left + width, top]),\n  //   bottomLeft: canvasToWorld([left, top + height]),\n  //   bottomRight: canvasToWorld([left + width, top + height]),\n  // }\n\n  return canvasBoundingBox;\n}\n\nexport default drawLinkedTextBox;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport { SVGDrawingHelper } from '../types';\n\n// <rect x=\"120\" y=\"100\" width=\"100\" height=\"100\" />\nexport default function drawRect(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  rectangleUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {},\n  dataId = ''\n): void {\n  const {\n    color,\n    width: _width,\n    lineWidth,\n    lineDash,\n  } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || _width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n  const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n  const width = Math.abs(start[0] - end[0]);\n  const height = Math.abs(start[1] - end[1]);\n\n  const attributes = {\n    x: `${tlhc[0]}`,\n    y: `${tlhc[1]}`,\n    width: `${width}`,\n    height: `${height}`,\n    stroke: color,\n    fill: 'transparent',\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingRect) {\n    setAttributesIfNecessary(attributes, existingRect);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgRectElement = document.createElementNS(svgns, 'rect');\n\n    if (dataId !== '') {\n      svgRectElement.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, svgRectElement);\n\n    svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\nimport drawLine from './drawLine';\n\nexport default function drawArrow(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  arrowUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {}\n): void {\n  // if length is NaN return\n  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n    return;\n  }\n\n  const { color, width, lineWidth, lineDash } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // The line itself\n  drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, {\n    color,\n    width,\n    lineWidth,\n    lineDash,\n  });\n\n  // Drawing the head arrow with two lines\n  // Variables to be used when creating the arrow\n  const headLength = 10;\n  const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);\n\n  const firstLine = {\n    start: [\n      end[0] - headLength * Math.cos(angle - Math.PI / 7),\n      end[1] - headLength * Math.sin(angle - Math.PI / 7),\n    ] as Types.Point2,\n    end: end,\n  };\n\n  const secondLine = {\n    start: [\n      end[0] - headLength * Math.cos(angle + Math.PI / 7),\n      end[1] - headLength * Math.sin(angle + Math.PI / 7),\n    ] as Types.Point2,\n    end: end,\n  };\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    '2',\n    firstLine.start,\n    firstLine.end,\n    {\n      color,\n      width,\n      lineWidth,\n    }\n  );\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    '3',\n    secondLine.start,\n    secondLine.end,\n    {\n      color,\n      width,\n      lineWidth,\n    }\n  );\n}\n","import _getHash from './_getHash';\nimport _setAttributesIfNecessary from './setAttributesIfNecessary';\nimport _setNewAttributesIfValid from './setNewAttributesIfValid';\n\n// <rect x=\"120\" y=\"100\" width=\"100\" height=\"100\" />\nexport default function drawRedactionRect(\n  svgDrawingHelper: any,\n  annotationUID: string,\n  rectangleUID: string,\n  start: any,\n  end: any,\n  options = {}\n): void {\n  const {\n    color,\n    width: _width,\n    lineWidth,\n    lineDash,\n  } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || _width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n  const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n  const width = Math.abs(start[0] - end[0]);\n  const height = Math.abs(start[1] - end[1]);\n\n  const attributes = {\n    x: `${tlhc[0]}`,\n    y: `${tlhc[1]}`,\n    width: `${width}`,\n    height: `${height}`,\n    stroke: color,\n    fill: 'black',\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingRect) {\n    _setAttributesIfNecessary(attributes, existingRect);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgRectElement = document.createElementNS(svgns, 'rect');\n\n    _setNewAttributesIfValid(attributes, svgRectElement);\n\n    svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n  }\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool, BaseTool } from '../tools';\nimport { Annotation } from '../types';\nimport { getAnnotations } from '../stateManagement/annotation/annotationState';\nimport * as ToolGroupManager from '../store/ToolGroupManager';\n\n/**\n * Get the annotation that is close to the provided canvas point, it will return\n * the first annotation that is found.\n *\n * @param element - The element to search for an annotation on.\n * @param canvasPoint - The canvasPoint on the page where the user clicked.\n * @param proximity - The distance from the canvasPoint to the annotation.\n * @returns The annotation for the element\n */\nfunction getAnnotationNearPoint(\n  element: HTMLDivElement,\n  canvasPoint: Types.Point2,\n  proximity = 5\n): Annotation | null {\n  // Todo: this function should return closest annotation, BUT, we are not using\n  // the function anywhere.\n  const enabledElement = getEnabledElement(element);\n  if (!enabledElement) {\n    throw new Error('getAnnotationNearPoint: enabledElement not found');\n  }\n\n  return getAnnotationNearPointOnEnabledElement(\n    enabledElement,\n    canvasPoint,\n    proximity\n  );\n}\n\n/**\n * \"Find the annotation near the point on the enabled element.\" it will return the\n * first annotation that is found.\n *\n * @param enabledElement - The element that is currently active.\n * @param point - The point to search near.\n * @param proximity - The distance from the point that the annotation must\n * be within.\n * @returns A Annotation object.\n */\nfunction getAnnotationNearPointOnEnabledElement(\n  enabledElement: Types.IEnabledElement,\n  point: Types.Point2,\n  proximity: number\n): Annotation | null {\n  // Todo: this function should return closest annotation, BUT, we are not using\n  // the function anywhere.\n  const { renderingEngineId, viewportId } = enabledElement;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const { _toolInstances: tools } = toolGroup;\n  for (const name in tools) {\n    const found = findAnnotationNearPointByTool(\n      tools[name],\n      enabledElement,\n      point,\n      proximity\n    );\n    if (found) {\n      return found;\n    }\n  }\n\n  return null;\n}\n\n/**\n * For the provided toolClass, it will find the annotation that is near the point,\n * it will return the first annotation that is found.\n *\n * @param tool - AnnotationTool\n * @param enabledElement - The element that is currently active.\n * @param point - The point in the image where the user clicked.\n * @param proximity - The distance from the point that the tool must be\n * within to be considered \"near\" the point.\n * @returns The annotation object that is being returned is the annotation object that\n * is being used in the tool.\n */\nfunction findAnnotationNearPointByTool(\n  tool: AnnotationTool,\n  enabledElement: Types.IEnabledElement,\n  point: Types.Point2,\n  proximity: number\n): Annotation | null {\n  // Todo: this function does not return closest annotation. It just returns\n  // the first annotation that is found in the proximity. BUT, we are not using\n  // the function anywhere.\n  const { viewport } = enabledElement;\n\n  const annotations = getAnnotations(\n    (tool.constructor as typeof BaseTool).toolName,\n    viewport?.element\n  );\n  const currentId = viewport?.getCurrentImageId?.();\n  if (annotations?.length) {\n    const { element } = enabledElement.viewport;\n    for (const annotation of annotations) {\n      const referencedImageId = annotation.metadata?.referencedImageId;\n      if (\n        (currentId && referencedImageId && currentId !== referencedImageId) ||\n        !tool.isPointNearTool\n      ) {\n        continue;\n      }\n\n      if (\n        tool.isPointNearTool(element, annotation, point, proximity, '') ||\n        tool.getHandleNearImagePoint(element, annotation, point, proximity)\n      ) {\n        return annotation;\n      }\n    }\n  }\n  return null;\n}\n\nexport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement };\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @since 0.1.0\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * isObject({})\n * // => true\n *\n * isObject([1, 2, 3])\n * // => true\n *\n * isObject(Function)\n * // => true\n *\n * isObject(null)\n * // => false\n */\nfunction isObject(value) {\n  const type = typeof value;\n\n  return value !== null && (type === 'object' || type === 'function');\n}\n\nexport default isObject;\n","import isObject from './isObject';\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked, or until the next browser frame is drawn. The debounced function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * debounced function. Subsequent calls to the debounced function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `debounce` and `throttle`.\n *\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0]\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\n *  used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', debounce(calculateLayout, 150))\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }))\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * const debounced = debounce(batchLog, 250, { 'maxWait': 1000 })\n * const source = new EventSource('/stream')\n * jQuery(source).on('message', debounced)\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel)\n *\n * // Check for pending invocations.\n * const status = debounced.pending() ? \"Pending...\" : \"Ready\"\n */\nfunction debounce(func, wait, options) {\n  let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n\n  let lastInvokeTime = 0;\n  let leading = false;\n  let maxing = false;\n  let trailing = true;\n\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n  const useRAF =\n    !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  wait = Number(wait) || 0;\n  if (isObject(options)) {\n    leading = Boolean(options.leading);\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  function invokeFunc(time) {\n    const args = lastArgs;\n    const thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n\n    return result;\n  }\n\n  function startTimer(pendingFunc, wait) {\n    if (useRAF) {\n      return window.requestAnimationFrame(pendingFunc);\n    }\n\n    return setTimeout(pendingFunc, wait);\n  }\n\n  function cancelTimer(id) {\n    if (useRAF) {\n      return window.cancelAnimationFrame(id);\n    }\n    clearTimeout(id);\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = startTimer(timerExpired, wait);\n\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (\n      lastCallTime === undefined ||\n      timeSinceLastCall >= wait ||\n      timeSinceLastCall < 0 ||\n      (maxing && timeSinceLastInvoke >= maxWait)\n    );\n  }\n\n  function timerExpired() {\n    const time = Date.now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = startTimer(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      cancelTimer(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(Date.now());\n  }\n\n  function pending() {\n    return timerId !== undefined;\n  }\n\n  function debounced(...args) {\n    const time = Date.now();\n    const isInvoking = shouldInvoke(time);\n\n    lastArgs = args;\n    lastThis = this; // eslint-disable-line consistent-this\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = startTimer(timerExpired, wait);\n\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  debounced.pending = pending;\n\n  return debounced;\n}\n\nexport default debounce;\n","import debounce from './debounce';\nimport isObject from './isObject';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds (or once per browser frame). The throttled function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `throttle` and `debounce`.\n *\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0]\n *  The number of milliseconds to throttle invocations to; if omitted,\n *  `requestAnimationFrame` is used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', throttle(updatePosition, 100))\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * const throttled = throttle(renewToken, 300000, { 'trailing': false })\n * jQuery(element).on('click', throttled)\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel)\n */\nfunction throttle(func, wait, options) {\n  let leading = true;\n  let trailing = true;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? Boolean(options.leading) : leading;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  return debounce(func, wait, {\n    leading,\n    trailing,\n    maxWait: wait,\n  });\n}\n\nexport default throttle;\n","import { utilities, Enums } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nconst { calibratedPixelSpacingMetadataProvider } = utilities;\n\n/**\n * It adds the provided spacing to the Cornerstone internal calibratedPixelSpacing\n * metadata provider, then it invalidates all the tools that have the imageId as\n * their reference imageIds. Finally, it triggers a re-render for invalidated annotations.\n * @param imageId - ImageId for the calibrated image\n * @param rowPixelSpacing - Spacing in row direction\n * @param calibrationOrScale - either the calibration object or a scale value\n */\nexport default function calibrateImageSpacing(\n  imageId: string,\n  renderingEngine: Types.IRenderingEngine,\n  calibrationOrScale: Types.IImageCalibration | number\n): void {\n  // Handle simple parameter version\n  if (typeof calibrationOrScale === 'number') {\n    calibrationOrScale = {\n      type: Enums.CalibrationTypes.USER,\n      scale: calibrationOrScale,\n    };\n  }\n  // 1. Add the calibratedPixelSpacing metadata to the metadata\n  calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);\n\n  // 2. Update the actor for stackViewports\n  const viewports = renderingEngine.getStackViewports();\n\n  // 2.1 If imageId is already being used in a stackViewport -> update actor\n  viewports.forEach((viewport) => {\n    const imageIds = viewport.getImageIds();\n    if (imageIds.includes(imageId)) {\n      viewport.calibrateSpacing(imageId);\n    }\n  });\n\n  // 2.2 If imageId is cached but not being displayed in a viewport, stackViewport\n  // will handle using the calibratedPixelSpacing since it has been added\n  // to the provider\n}\n","import { Enums, utilities } from '@cornerstonejs/core';\n\nconst { CalibrationTypes } = Enums;\nconst PIXEL_UNITS = 'px';\n\nconst SUPPORTED_REGION_DATA_TYPES = [\n  1, // Tissue\n];\n\nconst SUPPORTED_LENGTH_VARIANT = [\n  '3,3', // x: cm  &  y:cm\n];\n\nconst SUPPORTED_PROBE_VARIANT = [\n  '4,3', // x: seconds  &  y : cm\n];\n\nconst UNIT_MAPPING = {\n  3: 'cm',\n  4: 'seconds',\n};\n\nconst EPS = 1e-3;\n\n/**\n * Extracts the length units and the type of calibration for those units\n * into the response.  The length units will typically be either mm or px\n * while the calibration type can be any of a number of different calibration types.\n *\n * Volumetric images have no calibration type, so are just the raw mm.\n *\n * TODO: Handle region calibration\n *\n * @param handles - used to detect if the spacing information is different\n *   between various points (eg angled ERMF or US Region).\n *   Currently unused, but needed for correct US Region handling\n * @param image - to extract the calibration from\n *        image.calibration - calibration value to extract units form\n * @returns String containing the units and type of calibration\n */\nconst getCalibratedLengthUnits = (handles, image): string => {\n  const { calibration, hasPixelSpacing } = image;\n  // Anachronistic - moving to using calibration consistently, but not completed yet\n  const units = hasPixelSpacing ? 'mm' : PIXEL_UNITS;\n  if (\n    !calibration ||\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\n  ) {\n    return units;\n  }\n  if (calibration.type === CalibrationTypes.UNCALIBRATED) {\n    return PIXEL_UNITS;\n  }\n  if (calibration.sequenceOfUltrasoundRegions) {\n    return 'US Region';\n  }\n  return `${units} ${calibration.type}`;\n};\n\nconst SQUARE = '\\xb2';\n/**\n *  Extracts the area units, including the squared sign plus calibration type.\n */\nconst getCalibratedAreaUnits = (handles, image): string => {\n  const { calibration, hasPixelSpacing } = image;\n  const units = (hasPixelSpacing ? 'mm' : PIXEL_UNITS) + SQUARE;\n  if (!calibration || !calibration.type) {\n    return units;\n  }\n  if (calibration.sequenceOfUltrasoundRegions) {\n    return 'US Region';\n  }\n  return `${units} ${calibration.type}`;\n};\n\n/**\n * Gets the scale divisor for converting from internal spacing to\n * image spacing for calibrated images.\n */\nconst getCalibratedScale = (image, handles = []) => {\n  if (image.calibration?.sequenceOfUltrasoundRegions) {\n    // image.spacing / image.us.space\n  } else if (image.calibration?.scale) {\n    return image.calibration.scale;\n  } else {\n    return 1;\n  }\n};\n\n/**\n * Extracts the calibrated length units, area units, and the scale\n * for converting from internal spacing to image spacing.\n *\n * @param handles - to detect if spacing information is different between points\n * @param image - to extract the calibration from\n * @returns Object containing the units, area units, and scale\n */\nconst getCalibratedLengthUnitsAndScale = (image, handles) => {\n  const [imageIndex1, imageIndex2] = handles;\n  const { calibration, hasPixelSpacing } = image;\n  let units = hasPixelSpacing ? 'mm' : PIXEL_UNITS;\n  const areaUnits = units + SQUARE;\n  let scale = 1;\n  let calibrationType = '';\n\n  if (\n    !calibration ||\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\n  ) {\n    return { units, areaUnits, scale };\n  }\n\n  if (calibration.type === CalibrationTypes.UNCALIBRATED) {\n    return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n  }\n\n  if (calibration.sequenceOfUltrasoundRegions) {\n    let regions = calibration.sequenceOfUltrasoundRegions.filter(\n      (region) =>\n        imageIndex1[0] >= region.regionLocationMinX0 &&\n        imageIndex1[0] <= region.regionLocationMaxX1 &&\n        imageIndex1[1] >= region.regionLocationMinY0 &&\n        imageIndex1[1] <= region.regionLocationMaxY1 &&\n        imageIndex2[0] >= region.regionLocationMinX0 &&\n        imageIndex2[0] <= region.regionLocationMaxX1 &&\n        imageIndex2[1] >= region.regionLocationMinY0 &&\n        imageIndex2[1] <= region.regionLocationMaxY1\n    );\n\n    // If we are not in a region at all we should show the underlying calibration\n    // which might be the mm spacing for the image\n    if (!regions?.length) {\n      return { units, areaUnits, scale };\n    }\n\n    // if we are in a region then it is the question of whether we support it\n    // or not. If we do not support it we should show px\n\n    regions = regions.filter(\n      (region) =>\n        SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n        SUPPORTED_LENGTH_VARIANT.includes(\n          `${region.physicalUnitXDirection},${region.physicalUnitYDirection}`\n        )\n    );\n\n    if (!regions.length) {\n      return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n    }\n\n    // Todo: expand on this logic\n    const region = regions[0];\n\n    const physicalDeltaX = Math.abs(region.physicalDeltaX);\n    const physicalDeltaY = Math.abs(region.physicalDeltaY);\n\n    // if we are in a supported region then we should check if the\n    // physicalDeltaX and physicalDeltaY are the same. If they are not\n    // then we should show px again, but if they are the same then we should\n    // show the units\n    const isSamePhysicalDelta = utilities.isEqual(\n      physicalDeltaX,\n      physicalDeltaY,\n      EPS\n    );\n\n    if (isSamePhysicalDelta) {\n      scale = 1 / (physicalDeltaX * physicalDeltaY * 100);\n      calibrationType = 'US Region';\n      units = 'mm';\n    } else {\n      return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n    }\n  } else if (calibration.scale) {\n    scale = calibration.scale;\n  }\n\n  return {\n    units: units + (calibrationType ? ` ${calibrationType}` : ''),\n    areaUnits: areaUnits + (calibrationType ? ` ${calibrationType}` : ''),\n    scale,\n  };\n};\n\nconst getCalibratedProbeUnitsAndValue = (image, handles) => {\n  const [imageIndex] = handles;\n  const { calibration } = image;\n  let units = ['raw'];\n  let values = [null];\n  let calibrationType = '';\n\n  if (\n    !calibration ||\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\n  ) {\n    return { units, values };\n    // Todo: add support for other scenarios\n  }\n\n  if (calibration.sequenceOfUltrasoundRegions) {\n    // for Probe tool\n    const supportedRegionsMetadata =\n      calibration.sequenceOfUltrasoundRegions.filter(\n        (region) =>\n          SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n          SUPPORTED_PROBE_VARIANT.includes(\n            `${region.physicalUnitXDirection},${region.physicalUnitYDirection}`\n          )\n      );\n\n    if (!supportedRegionsMetadata?.length) {\n      return { units, values };\n    }\n\n    const region = supportedRegionsMetadata.find(\n      (region) =>\n        imageIndex[0] >= region.regionLocationMinX0 &&\n        imageIndex[0] <= region.regionLocationMaxX1 &&\n        imageIndex[1] >= region.regionLocationMinY0 &&\n        imageIndex[1] <= region.regionLocationMaxY1\n    );\n\n    if (!region) {\n      return { units, values };\n    }\n\n    // Todo: I think this is a ok assumption for now that if the referencePixelX0 and referencePixelY0\n    // are not defined, then we can assume 0 for them\n    const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;\n    const { physicalDeltaX, physicalDeltaY } = region;\n\n    const yValue =\n      (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) *\n      physicalDeltaY;\n\n    const xValue =\n      (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) *\n      physicalDeltaX;\n\n    calibrationType = 'US Region';\n    values = [xValue, yValue];\n    units = [\n      UNIT_MAPPING[region.physicalUnitXDirection],\n      UNIT_MAPPING[region.physicalUnitYDirection],\n    ];\n  }\n\n  return {\n    units,\n    values,\n    calibrationType,\n  };\n};\n\n/** Gets the aspect ratio of the screen display relative to the image\n * display in order to square up measurement values.\n * That is, suppose the spacing on the image is 1, 0.5 (x,y spacing)\n * This is displayed at 1, 1 spacing on screen, then the\n * aspect value will be 1/0.5 = 2\n */\nconst getCalibratedAspect = (image) => image.calibration?.aspect || 1;\n\nexport default getCalibratedLengthUnits;\n\nexport {\n  getCalibratedAreaUnits,\n  getCalibratedLengthUnits,\n  getCalibratedLengthUnitsAndScale,\n  getCalibratedScale,\n  getCalibratedAspect,\n  getCalibratedProbeUnitsAndValue,\n};\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport BoundsIJK from '../types/BoundsIJK';\n\nexport type PointInShape = {\n  value: number;\n  index: number;\n  pointIJK: vec3;\n  pointLPS: vec3;\n};\n\nexport type PointInShapeCallback = ({\n  value,\n  index,\n  pointIJK,\n  pointLPS,\n}: {\n  value: number;\n  index: number;\n  pointIJK: vec3;\n  pointLPS: vec3;\n}) => void;\n\nexport type ShapeFnCriteria = (pointLPS: vec3, pointIJK: vec3) => boolean;\n\n/**\n * For each point in the image (If boundsIJK is not provided, otherwise, for each\n * point in the provided bounding box), It runs the provided callback IF the point\n * passes the provided criteria to be inside the shape (which is defined by the\n * provided pointInShapeFn)\n *\n * @param imageData - The image data object.\n * @param dimensions - The dimensions of the image.\n * @param pointInShapeFn - A function that takes a point in LPS space and returns\n * true if the point is in the shape and false if it is not.\n * @param callback - A function that will be called for\n * every point in the shape.\n * @param boundsIJK - The bounds of the volume in IJK coordinates.\n */\nexport default function pointInShapeCallback(\n  imageData: vtkImageData | Types.CPUImageData,\n  pointInShapeFn: ShapeFnCriteria,\n  callback?: PointInShapeCallback,\n  boundsIJK?: BoundsIJK\n): Array<PointInShape> {\n  let iMin, iMax, jMin, jMax, kMin, kMax;\n\n  let scalarData;\n\n  // if getScalarData is a method on imageData\n  if ((imageData as Types.CPUImageData).getScalarData) {\n    scalarData = (imageData as Types.CPUImageData).getScalarData();\n  } else {\n    scalarData = (imageData as vtkImageData)\n      .getPointData()\n      .getScalars()\n      .getData();\n  }\n\n  const dimensions = imageData.getDimensions();\n\n  if (!boundsIJK) {\n    iMin = 0;\n    iMax = dimensions[0];\n    jMin = 0;\n    jMax = dimensions[1];\n    kMin = 0;\n    kMax = dimensions[2];\n  } else {\n    [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = boundsIJK;\n  }\n\n  const start = vec3.fromValues(iMin, jMin, kMin);\n\n  const direction = imageData.getDirection();\n  const rowCosines = direction.slice(0, 3);\n  const columnCosines = direction.slice(3, 6);\n  const scanAxisNormal = direction.slice(6, 9);\n\n  const spacing = imageData.getSpacing();\n  const [rowSpacing, columnSpacing, scanAxisSpacing] = spacing;\n\n  // @ts-ignore will be fixed in vtk-master\n  const worldPosStart = imageData.indexToWorld(start);\n\n  const rowStep = vec3.fromValues(\n    rowCosines[0] * rowSpacing,\n    rowCosines[1] * rowSpacing,\n    rowCosines[2] * rowSpacing\n  );\n\n  const columnStep = vec3.fromValues(\n    columnCosines[0] * columnSpacing,\n    columnCosines[1] * columnSpacing,\n    columnCosines[2] * columnSpacing\n  );\n\n  const scanAxisStep = vec3.fromValues(\n    scanAxisNormal[0] * scanAxisSpacing,\n    scanAxisNormal[1] * scanAxisSpacing,\n    scanAxisNormal[2] * scanAxisSpacing\n  );\n\n  const xMultiple =\n    scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\n  const yMultiple = dimensions[0] * xMultiple;\n  const zMultiple = dimensions[1] * yMultiple;\n\n  const pointsInShape: Array<PointInShape> = [];\n\n  const currentPos = vec3.clone(worldPosStart);\n\n  for (let k = kMin; k <= kMax; k++) {\n    const startPosJ = vec3.clone(currentPos);\n\n    for (let j = jMin; j <= jMax; j++) {\n      const startPosI = vec3.clone(currentPos);\n\n      for (let i = iMin; i <= iMax; i++) {\n        const pointIJK: Types.Point3 = [i, j, k];\n\n        // The current world position (pointLPS) is now in currentPos\n        if (pointInShapeFn(currentPos as Types.Point3, pointIJK)) {\n          const index = k * zMultiple + j * yMultiple + i * xMultiple;\n          let value;\n          if (xMultiple > 2) {\n            value = [\n              scalarData[index],\n              scalarData[index + 1],\n              scalarData[index + 2],\n            ];\n          } else {\n            value = scalarData[index];\n          }\n\n          pointsInShape.push({ value, index, pointIJK, pointLPS: currentPos });\n          if (callback) {\n            callback({ value, index, pointIJK, pointLPS: currentPos });\n          }\n        }\n\n        // Increment currentPos by rowStep for the next iteration\n        vec3.add(currentPos, currentPos, rowStep);\n      }\n\n      // Reset currentPos to the start of the next J line and increment by columnStep\n      vec3.copy(currentPos, startPosI);\n      vec3.add(currentPos, currentPos, columnStep);\n    }\n\n    // Reset currentPos to the start of the next K slice and increment by scanAxisStep\n    vec3.copy(currentPos, startPosJ);\n    vec3.add(currentPos, currentPos, scanAxisStep);\n  }\n\n  return pointsInShape;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { CONSTANTS } from '@cornerstonejs/core';\n\nconst { EPSILON } = CONSTANTS;\n\n/** Bounding box type */\ntype BoundingBox =\n  | [Types.Point2, Types.Point2, null]\n  | [Types.Point2, Types.Point2, Types.Point2];\n\nfunction calculateBoundingBox(\n  points,\n  dimensions,\n  isWorld = false\n): BoundingBox {\n  let xMin = Infinity;\n  let xMax = isWorld ? -Infinity : 0;\n  let yMin = Infinity;\n  let yMax = isWorld ? -Infinity : 0;\n  let zMin = Infinity;\n  let zMax = isWorld ? -Infinity : 0;\n\n  const is3D = points[0]?.length === 3;\n\n  points.forEach((p) => {\n    xMin = Math.min(p[0], xMin);\n    xMax = Math.max(p[0], xMax);\n    yMin = Math.min(p[1], yMin);\n    yMax = Math.max(p[1], yMax);\n\n    if (is3D) {\n      zMin = Math.min(p[2] ?? zMin, zMin);\n      zMax = Math.max(p[2] ?? zMax, zMax);\n    }\n  });\n\n  if (dimensions) {\n    xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);\n    xMax = Math.min(\n      isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1,\n      xMax\n    );\n    yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);\n    yMax = Math.min(\n      isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1,\n      yMax\n    );\n\n    if (is3D && dimensions.length === 3) {\n      zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);\n      zMax = Math.min(\n        isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1,\n        zMax\n      );\n    }\n  } else if (!isWorld) {\n    // still need to bound to 0 and Infinity if no dimensions are provided for ijk\n    xMin = Math.max(0, xMin);\n    xMax = Math.min(Infinity, xMax);\n    yMin = Math.max(0, yMin);\n    yMax = Math.min(Infinity, yMax);\n\n    if (is3D) {\n      zMin = Math.max(0, zMin);\n      zMax = Math.min(Infinity, zMax);\n    }\n  }\n\n  return is3D\n    ? [\n        [xMin, xMax],\n        [yMin, yMax],\n        [zMin, zMax],\n      ]\n    : [[xMin, xMax], [yMin, yMax], null];\n}\n\n/**\n * With a given vertices (points) coordinates in 2D or 3D in IJK, it calculates the minimum and maximum\n * coordinate in each axis, and returns them. If clipBounds are provided it also\n * clip the min, max to the provided width, height and depth\n *\n * @param points - shape corner points coordinates either in IJK (image coordinate)\n * @param dimensions - bounds to clip the min, max\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\n */\nexport function getBoundingBoxAroundShapeIJK(\n  points: Types.Point2[] | Types.Point3[],\n  dimensions?: Types.Point2 | Types.Point3\n): BoundingBox {\n  return calculateBoundingBox(points, dimensions, false);\n}\n\n/**\n * With a given vertices (points) coordinates in 2D or 3D in World Coordinates, it calculates the minimum and maximum\n * coordinate in each axis, and returns them. If clipBounds are provided it also\n * clip the min, max to the provided width, height and depth\n *\n * @param points - shape corner points coordinates either in IJK (image coordinate)\n * @param clipBounds - bounds to clip the min, max\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\n */\nexport function getBoundingBoxAroundShapeWorld(\n  points: Types.Point2[] | Types.Point3[],\n  clipBounds?: Types.Point2 | Types.Point3\n): BoundingBox {\n  return calculateBoundingBox(points, clipBounds, true);\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { vec3 } from 'gl-matrix';\nimport { BoundsIJK } from '../types';\nimport { getBoundingBoxAroundShapeIJK } from './boundingBox';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * Given an imageData, and the great circle top and bottom points of a sphere,\n * this function will run the callback for each point of the imageData that is\n * within the sphere defined by the great circle points. If the viewport\n * is provided, region of interest will be an accurate approximation of the\n * sphere (using viewport camera), and the resulting performance will be\n * better.\n *\n * @privateRemarks great circle also known as orthodrome is the intersection of\n * the sphere and the plane that passes through the center of the sphere\n *\n * @param imageData - The volume imageData\n * @param circlePoints - bottom and top points of the great circle in world coordinates\n * @param callback - A callback function that will be called for each point in the shape.\n */\nfunction getSphereBoundsInfo(\n  circlePoints: [Types.Point3, Types.Point3],\n  imageData: vtkImageData,\n  viewport\n): {\n  boundsIJK: BoundsIJK;\n  centerWorld: Types.Point3;\n  radiusWorld: number;\n  topLeftWorld: Types.Point3;\n  bottomRightWorld: Types.Point3;\n} {\n  const [bottom, top] = circlePoints;\n\n  // Sphere center in world\n  const centerWorld = vec3.fromValues(\n    (bottom[0] + top[0]) / 2,\n    (bottom[1] + top[1]) / 2,\n    (bottom[2] + top[2]) / 2\n  );\n\n  // sphere radius in world\n  const radiusWorld = vec3.distance(bottom, top) / 2;\n\n  if (!viewport) {\n    throw new Error(\n      'viewport is required in order to calculate the sphere bounds'\n    );\n  }\n\n  const { boundsIJK, topLeftWorld, bottomRightWorld } =\n    _computeBoundsIJKWithCamera(\n      imageData,\n      viewport,\n      circlePoints,\n      centerWorld,\n      radiusWorld\n    );\n\n  return {\n    boundsIJK,\n    centerWorld: centerWorld as Types.Point3,\n    radiusWorld,\n    topLeftWorld: topLeftWorld as Types.Point3,\n    bottomRightWorld: bottomRightWorld as Types.Point3,\n  };\n}\n\nfunction _computeBoundsIJKWithCamera(\n  imageData,\n  viewport,\n  circlePoints,\n  centerWorld,\n  radiusWorld\n) {\n  const [bottom, top] = circlePoints;\n\n  const dimensions = imageData.getDimensions() as Types.Point3;\n\n  const camera = viewport.getCamera();\n\n  // Calculate viewRight from the camera, this will get used in order to\n  // calculate circles topLeft and bottomRight on different planes of intersection\n  // between sphere and viewPlane\n  const viewUp = vec3.fromValues(\n    camera.viewUp[0],\n    camera.viewUp[1],\n    camera.viewUp[2]\n  );\n  const viewPlaneNormal = vec3.fromValues(\n    camera.viewPlaneNormal[0],\n    camera.viewPlaneNormal[1],\n    camera.viewPlaneNormal[2]\n  );\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n  // we need to find the bounding box of the sphere in the image, e.g., the\n  // topLeftWorld and bottomRightWorld points of the bounding box.\n  // We go from the sphereCenter in the normal direction of amount radius, and\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\n  // in the opposite direction and go right to find the bottomRightWorld point\n  // of the bounding box.\n  const topLeftWorld = vec3.create();\n  const bottomRightWorld = vec3.create();\n\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n\n  // go in the direction of viewRight with the value of radius\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n\n  // In order to correctly come up with the boundsIJK, we need to consider\n  // all the points IJK to get the bounds, since the viewport might have\n  // rotate views and we cannot guarantee that the topLeft and bottomRight in the\n  // world, are the ones that will define the bounds in IJK\n  const topLeftIJK = transformWorldToIndex(\n    imageData,\n    topLeftWorld as Types.Point3\n  );\n  const bottomRightIJK = transformWorldToIndex(\n    imageData,\n    bottomRightWorld as Types.Point3\n  );\n\n  const pointsIJK = circlePoints.map((p) =>\n    transformWorldToIndex(imageData, p)\n  );\n\n  // get the bounding box of the sphere in the image\n  const boundsIJK = getBoundingBoxAroundShapeIJK(\n    [topLeftIJK, bottomRightIJK, ...pointsIJK],\n    dimensions\n  );\n\n  return { boundsIJK, topLeftWorld, bottomRightWorld };\n}\n\nexport { getSphereBoundsInfo };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport { Annotation } from '../types';\n\nexport type FramesRange = [number, number] | number;\n\n/**\n * This class handles the annotation frame range values for multiframes.\n * Mostly used for the Video viewport, it allows references to\n * a range of frame values.\n */\nexport default class AnnotationFrameRange {\n  protected static frameRangeExtractor =\n    /(\\/frames\\/|[&?]frameNumber=)([^/&?]*)/i;\n\n  protected static imageIdToFrames(imageId: string): FramesRange {\n    const match = imageId.match(this.frameRangeExtractor);\n    if (!match || !match[2]) {\n      return null;\n    }\n    const range = match[2].split('-').map((it) => Number(it));\n    if (range.length === 1) {\n      return range[0];\n    }\n    return range as FramesRange;\n  }\n\n  public static framesToString(range) {\n    if (Array.isArray(range)) {\n      return `${range[0]}-${range[1]}`;\n    }\n    return String(range);\n  }\n\n  protected static framesToImageId(\n    imageId: string,\n    range: FramesRange | string\n  ): string {\n    const match = imageId.match(this.frameRangeExtractor);\n    if (!match || !match[2]) {\n      return null;\n    }\n    const newRangeString = this.framesToString(range);\n    return imageId.replace(\n      this.frameRangeExtractor,\n      `${match[1]}${newRangeString}`\n    );\n  }\n\n  /**\n   * Sets the range of frames to associate with the given annotation.\n   * The range can be a single frame number (1 based according to DICOM),\n   * or a range of values in the format `min-max` where min, max are inclusive\n   * Modifies the referencedImageID to specify the updated URL.\n   */\n  public static setFrameRange(\n    annotation: Annotation,\n    range: FramesRange | string,\n    eventBase?: { viewportId; renderingEngineId }\n  ) {\n    const { referencedImageId } = annotation.metadata;\n    annotation.metadata.referencedImageId = this.framesToImageId(\n      referencedImageId,\n      range\n    );\n    const eventDetail = {\n      ...eventBase,\n      annotation,\n    };\n    triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\n  }\n\n  public static getFrameRange(\n    annotation: Annotation\n  ): number | [number, number] {\n    return this.imageIdToFrames(annotation.metadata.referencedImageId);\n  }\n}\n","function findNextLink(line, lines, contourPoints) {\n  let index = -1;\n  lines.forEach((cell, i) => {\n    if (index >= 0) {\n      return;\n    }\n\n    if (cell.a == line.b) {\n      index = i;\n    }\n  });\n\n  if (index >= 0) {\n    const nextLine = lines[index];\n    lines.splice(index, 1);\n\n    contourPoints.push(nextLine.b);\n\n    if (contourPoints[0] == nextLine.b) {\n      return {\n        remainingLines: lines,\n        contourPoints,\n        type: 'CLOSED_PLANAR',\n        //type: 'CLOSEDPLANAR_XOR',\n      };\n    }\n\n    return findNextLink(nextLine, lines, contourPoints);\n  }\n\n  return {\n    remainingLines: lines,\n    contourPoints,\n    type: 'OPEN_PLANAR',\n  };\n}\n\n/**\n *\n * @param {*} lines\n */\nexport function findContours(lines) {\n  if (lines.length == 0) {\n    return [];\n  }\n\n  const contourPoints = [];\n\n  const firstCell = lines.shift();\n  contourPoints.push(firstCell.a);\n  contourPoints.push(firstCell.b);\n  const result = findNextLink(firstCell, lines, contourPoints);\n\n  if (result.remainingLines.length == 0) {\n    return [\n      {\n        type: result.type,\n        contourPoints: result.contourPoints,\n      },\n    ];\n  } else {\n    const extraContours = findContours(result.remainingLines);\n    extraContours.push({\n      type: result.type,\n      contourPoints: result.contourPoints,\n    });\n    return extraContours;\n  }\n}\n\nexport function findContoursFromReducedSet(lines) {\n  return findContours(lines);\n}\n\nexport default {\n  findContours,\n  findContoursFromReducedSet,\n};\n","/**\n * Checks if point is within array\n * @param {*} array\n * @param {*} pt\n * @returns\n */\nfunction ptInArray(array, pt) {\n  let index = -1;\n  for (let i = 0; i < array.length; i++) {\n    if (isSamePoint(pt, array[i])) {\n      index = i;\n    }\n  }\n  return index;\n}\n\n/**\n * Checks if point A and point B contain same values\n * @param {*} ptA\n * @param {*} ptB\n * @returns\n */\nfunction isSamePoint(ptA, ptB) {\n  if (ptA[0] == ptB[0] && ptA[1] == ptB[1] && ptA[2] == ptB[2]) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Goes through linesArray and replaces all references of old index with new index\n * @param {*} linesArray\n * @param {*} oldIndex\n * @param {*} newIndex\n */\nfunction replacePointIndexReferences(linesArray, oldIndex, newIndex) {\n  for (let i = 0; i < linesArray.length; i++) {\n    const line = linesArray[i];\n    if (line.a == oldIndex) {\n      line.a = newIndex;\n    } else if (line.b == oldIndex) {\n      line.b = newIndex;\n    }\n  }\n}\n\n/**\n * Iterate through polyData from vtkjs and merge any points that are the same\n * then update merged point references within lines array\n * @param {*} polyData\n * @param {*} bypass\n * @returns\n */\nexport function removeDuplicatePoints(polyData, bypass = false) {\n  const points = polyData.getPoints();\n  const lines = polyData.getLines();\n\n  const pointsArray = [];\n  for (let i = 0; i < points.getNumberOfPoints(); i++) {\n    const pt = points.getPoint(i).slice();\n    pointsArray.push(pt);\n  }\n  const linesArray = [];\n  for (let i = 0; i < lines.getNumberOfCells(); i++) {\n    const cell = lines.getCell(i * 3).slice();\n    //console.log(JSON.stringify(cell));\n    const a = cell[0];\n    const b = cell[1];\n    const line = {\n      a,\n      b,\n    };\n    linesArray.push(line);\n  }\n\n  if (bypass) {\n    return { points: pointsArray, lines: linesArray };\n  }\n\n  // Iterate through points and replace any duplicates\n  const newPoints = [];\n  for (let i = 0; i < pointsArray.length; i++) {\n    const pt = pointsArray[i];\n    let index = ptInArray(newPoints, pt);\n\n    if (index >= 0) {\n      // Duplicate Point -> replace references in lines\n      replacePointIndexReferences(linesArray, i, index);\n    } else {\n      index = newPoints.length;\n      newPoints.push(pt);\n      replacePointIndexReferences(linesArray, i, index);\n    }\n  }\n\n  // Final pass through lines, remove any that refer to exact same point\n  const newLines = [];\n  linesArray.forEach((line) => {\n    if (line.a != line.b) {\n      newLines.push(line);\n    }\n  });\n\n  return { points: newPoints, lines: newLines };\n}\n\nexport default { removeDuplicatePoints };\n","/**\n * Functions for detecting and dealing with holes within contours.\n * Expected Contour format:\n * {\n *   type,\n *   contourPoints\n * }\n */\n\n/**\n * Checks if point is inside polygon defined by vertices array\n * Code from\n * https://stackoverflow.com/questions/22521982/check-if-point-is-inside-a-polygon\n * most original version based on:\n * https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html/pnpoly.html\n * @param {*} point\n * @param {*} vertices\n * @returns\n */\nconst getIsPointInsidePolygon = (point, vertices) => {\n  const x = point[0];\n  const y = point[1];\n\n  let inside = false;\n  for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {\n    const xi = vertices[i][0],\n      yi = vertices[i][1];\n    const xj = vertices[j][0],\n      yj = vertices[j][1];\n\n    const intersect =\n      yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\n    if (intersect) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n};\n\n/**\n * Check if inner contour is completely surrounded by outer contour.\n * @param {*} outerContour\n * @param {*} innerContour\n * @returns\n */\nfunction checkEnclosed(outerContour, innerContour, points) {\n  const vertices = [];\n  outerContour.contourPoints.forEach((point) => {\n    vertices.push([points[point][0], points[point][1]]);\n  });\n\n  let pointsNotEnclosed = 0;\n  innerContour.contourPoints.forEach((point) => {\n    const result = getIsPointInsidePolygon(\n      [points[point][0], points[point][1]],\n      vertices\n    );\n    //console.log(result);\n\n    if (!result) {\n      pointsNotEnclosed++;\n    }\n  });\n\n  return pointsNotEnclosed === 0;\n}\n\n/**\n * Check if contours have holes, if so update contour accordingly\n * @param {*} polyData\n * @param {*} bypass\n */\nexport function processContourHoles(contours, points, useXOR = true) {\n  //console.log(points);\n\n  // Add non-closed planars to contour list\n  const retContours = contours.filter(\n    (contour) => contour.type !== 'CLOSED_PLANAR'\n  );\n\n  // Find closed planar contours\n  const closedContours = contours.filter(\n    (contour) => contour.type === 'CLOSED_PLANAR'\n  );\n\n  // Iterate through each contour in list check for contours that have holes\n  const contourWithHoles = [];\n  let contourWithoutHoles = [];\n  closedContours.forEach((contour, index) => {\n    const holes = [];\n\n    // Check if any other contour is a hole surrounded by current contour\n    closedContours.forEach((hContour, hIndex) => {\n      if (index != hIndex) {\n        // Check if inner loop contour is a hole of outer loop contour\n        if (checkEnclosed(contour, hContour, points)) {\n          holes.push(hIndex);\n        }\n      }\n    });\n\n    // Check if holes were found\n    if (holes.length > 0) {\n      // Note current contour and reference of its holes\n      contourWithHoles.push({\n        contour,\n        holes,\n      });\n    } else {\n      // Note contour index without holes\n      contourWithoutHoles.push(index);\n    }\n  });\n\n  if (useXOR) {\n    // XOR method\n    contourWithHoles.forEach((contourHoleSet) => {\n      // Modify contour with hole to type CLOSEDPLANAR_XOR\n      contourHoleSet.contour.type = 'CLOSEDPLANAR_XOR';\n      retContours.push(contourHoleSet.contour);\n\n      contourHoleSet.holes.forEach((holeIndex) => {\n        // Modify hole type to CLOSEDPLANAR_XOR\n        // and add to contour list to be returned\n        closedContours[holeIndex].type = 'CLOSEDPLANAR_XOR';\n        retContours.push(closedContours[holeIndex]);\n\n        // Remove hole from list of contours without holes\n        contourWithoutHoles = contourWithoutHoles.filter((contourIndex) => {\n          return contourIndex !== holeIndex;\n        });\n      });\n    });\n\n    // Add remaining contours to list (neither hole nor have holes)\n    contourWithoutHoles.forEach((contourIndex) => {\n      retContours.push(closedContours[contourIndex]);\n    });\n  } else {\n    // Keyhole method, not implemented\n  }\n\n  return retContours;\n}\n\nexport default { processContourHoles };\n","import { cache as cornerstoneCache } from '@cornerstonejs/core';\nimport vtkImageMarchingSquares from '@kitware/vtk.js/Filters/General/ImageMarchingSquares';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\n\nimport { removeDuplicatePoints } from './mergePoints';\nimport { findContoursFromReducedSet } from './contourFinder';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\n\nconst { Labelmap } = SegmentationRepresentations;\n\nfunction generateContourSetsFromLabelmap({ segmentations }) {\n  const { representationData, segments = [0, 1] } = segmentations;\n  const { volumeId: segVolumeId } = representationData[Labelmap];\n\n  // Get segmentation volume\n  const vol = cornerstoneCache.getVolume(segVolumeId);\n  if (!vol) {\n    console.warn(`No volume found for ${segVolumeId}`);\n    return;\n  }\n\n  const numSlices = vol.dimensions[2];\n\n  // Get image volume segmentation references\n  const imageVol = cornerstoneCache.getVolume(vol.referencedVolumeId);\n  if (!imageVol) {\n    console.warn(`No volume found for ${vol.referencedVolumeId}`);\n    return;\n  }\n\n  // NOTE: Workaround for marching squares not finding closed contours at\n  // boundary of image volume, clear pixels along x-y border of volume\n  const segData = vol.imageData.getPointData().getScalars().getData();\n  const pixelsPerSlice = vol.dimensions[0] * vol.dimensions[1];\n\n  for (let z = 0; z < numSlices; z++) {\n    for (let y = 0; y < vol.dimensions[1]; y++) {\n      const index = y * vol.dimensions[0] + z * pixelsPerSlice;\n      segData[index] = 0;\n      segData[index + vol.dimensions[0] - 1] = 0;\n    }\n  }\n\n  // end workaround\n  //\n  //\n  const ContourSets = [];\n\n  const { FrameOfReferenceUID } = imageVol.metadata;\n  // Iterate through all segments in current segmentation set\n  const numSegments = segments.length;\n  for (let segIndex = 0; segIndex < numSegments; segIndex++) {\n    const segment = segments[segIndex];\n\n    // Skip empty segments\n    if (!segment) {\n      continue;\n    }\n\n    const sliceContours = [];\n    const scalars = vtkDataArray.newInstance({\n      name: 'Scalars',\n      numberOfComponents: 1,\n      size: pixelsPerSlice * numSlices,\n      dataType: 'Uint8Array',\n    });\n    const { containedSegmentIndices } = segment;\n    for (let sliceIndex = 0; sliceIndex < numSlices; sliceIndex++) {\n      // Check if the slice is empty before running marching cube\n      if (\n        isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex)\n      ) {\n        continue;\n      }\n      const frameStart = sliceIndex * pixelsPerSlice;\n\n      try {\n        // Modify segData for this specific segment directly\n        for (let i = 0; i < pixelsPerSlice; i++) {\n          const value = segData[i + frameStart];\n          if (value === segIndex || containedSegmentIndices?.has(value)) {\n            (scalars as any).setValue(i + frameStart, 1);\n          } else {\n            (scalars as any).setValue(i, 0);\n          }\n        }\n\n        const mSquares = vtkImageMarchingSquares.newInstance({\n          slice: sliceIndex,\n        });\n\n        // filter out the scalar data so that only it has background and\n        // the current segment index\n        const imageDataCopy = vtkImageData.newInstance();\n\n        imageDataCopy.shallowCopy(vol.imageData);\n        imageDataCopy.getPointData().setScalars(scalars);\n\n        // Connect pipeline\n        mSquares.setInputData(imageDataCopy);\n        const cValues = [1];\n        mSquares.setContourValues(cValues);\n        mSquares.setMergePoints(false);\n\n        // Perform marching squares\n        const msOutput = mSquares.getOutputData();\n\n        // Clean up output from marching squares\n        const reducedSet = removeDuplicatePoints(msOutput);\n        if (reducedSet.points?.length) {\n          const contours = findContoursFromReducedSet(reducedSet.lines);\n\n          sliceContours.push({\n            referencedImageId: imageVol.imageIds[sliceIndex],\n            contours,\n            polyData: reducedSet,\n            FrameNumber: sliceIndex + 1,\n            sliceIndex,\n            FrameOfReferenceUID,\n          });\n        }\n      } catch (e) {\n        console.warn(sliceIndex);\n        console.warn(e);\n      }\n    }\n\n    const metadata = {\n      referencedImageId: imageVol.imageIds[0], // just use 0 for overall\n      FrameOfReferenceUID,\n    };\n\n    const ContourSet = {\n      label: segment.label,\n      color: segment.color,\n      metadata,\n      sliceContours,\n    };\n\n    ContourSets.push(ContourSet);\n  }\n\n  return ContourSets;\n}\n\nfunction isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex) {\n  const startIdx = sliceIndex * pixelsPerSlice;\n  const endIdx = startIdx + pixelsPerSlice;\n\n  for (let i = startIdx; i < endIdx; i++) {\n    if (segData[i] === segIndex) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport { generateContourSetsFromLabelmap };\n","// comment\nclass RectangleROIStartEndThreshold {\n  static toolName: string;\n\n  constructor() {\n    // empty\n  }\n\n  static getContourSequence(toolData, metadataProvider) {\n    const { data } = toolData;\n    const { projectionPoints, projectionPointsImageIds } = data.cachedStats;\n\n    return projectionPoints.map((point, index) => {\n      const ContourData = getPointData(point);\n      const ContourImageSequence = getContourImageSequence(\n        projectionPointsImageIds[index],\n        metadataProvider\n      );\n\n      return {\n        NumberOfContourPoints: ContourData.length / 3,\n        ContourImageSequence,\n        ContourGeometricType: 'CLOSED_PLANAR',\n        ContourData,\n      };\n    });\n  }\n}\n\nRectangleROIStartEndThreshold.toolName = 'RectangleROIStartEndThreshold';\n\nfunction getPointData(points) {\n  // Since this is a closed contour, the order of the points is important.\n  // re-order the points to be in the correct order clockwise\n  // Spread to make sure Float32Arrays are converted to arrays\n  const orderedPoints = [\n    ...points[0],\n    ...points[1],\n    ...points[3],\n    ...points[2],\n  ];\n  const pointsArray = orderedPoints.flat();\n\n  // reduce the precision of the points to 2 decimal places\n  const pointsArrayWithPrecision = pointsArray.map((point) => {\n    return point.toFixed(2);\n  });\n\n  return pointsArrayWithPrecision;\n}\n\nfunction getContourImageSequence(imageId, metadataProvider) {\n  const sopCommon = metadataProvider.get('sopCommonModule', imageId);\n\n  return {\n    ReferencedSOPClassUID: sopCommon.sopClassUID,\n    ReferencedSOPInstanceUID: sopCommon.sopInstanceUID,\n  };\n}\nexport default RectangleROIStartEndThreshold;\n","import RectangleROIStartEndThreshold from './RectangleROIStartEndThreshold';\n\nfunction validateAnnotation(annotation) {\n  if (!annotation?.data) {\n    throw new Error('Tool data is empty');\n  }\n\n  if (!annotation.metadata || annotation.metadata.referenceImageId) {\n    throw new Error('Tool data is not associated with any imageId');\n  }\n}\n\nclass AnnotationToPointData {\n  static TOOL_NAMES: Record<string, any> = {};\n\n  constructor() {\n    // empty\n  }\n\n  static convert(annotation, index, metadataProvider) {\n    validateAnnotation(annotation);\n\n    const { toolName } = annotation.metadata;\n    const toolClass = AnnotationToPointData.TOOL_NAMES[toolName];\n\n    if (!toolClass) {\n      throw new Error(\n        `Unknown tool type: ${toolName}, cannot convert to RTSSReport`\n      );\n    }\n\n    // Each toolData should become a list of contours, ContourSequence\n    // contains a list of contours with their pointData, their geometry\n    // type and their length.\n    const ContourSequence = toolClass.getContourSequence(\n      annotation,\n      metadataProvider\n    );\n\n    // Todo: random rgb color for now, options should be passed in\n    const color = [\n      Math.floor(Math.random() * 255),\n      Math.floor(Math.random() * 255),\n      Math.floor(Math.random() * 255),\n    ];\n\n    return {\n      ReferencedROINumber: index + 1,\n      ROIDisplayColor: color,\n      ContourSequence,\n    };\n  }\n\n  static register(toolClass) {\n    AnnotationToPointData.TOOL_NAMES[toolClass.toolName] = toolClass;\n  }\n}\n\nAnnotationToPointData.register(RectangleROIStartEndThreshold);\n\nexport default AnnotationToPointData;\n","/**\n * Defines the names of the strategy callbacks used for performing enhanced\n * strategy operations.\n */\nenum StrategyCallbacks {\n  /**\n   * startStrategy is called at the start of a strategy, typically on mouse down\n   * Note this is separate from preview and the endings for preview, which could\n   * be called alternatively, but this may be nested within a preview.\n   */\n  OnInteractionStart = 'onInteractionStart',\n  /**\n   * finishStrategy is called at the end of a strategy being applied, usually on\n   * mouse up.\n   */\n  OnInteractionEnd = 'onInteractionEnd',\n  /**\n   * The preview can be used for tools to show what would happen on accepting\n   * before the change is actually done.  For example, a spline tool might\n   * show a preview state, and allow that to be accepted or rejected.\n   */\n  Preview = 'preview',\n  RejectPreview = 'rejectPreview',\n  AcceptPreview = 'acceptPreview',\n\n  /**\n   * Fills the given reygion\n   */\n  Fill = 'fill',\n\n  /**\n   * The default strategy function, often synonymous with fill\n   */\n  StrategyFunction = 'strategyFunction',\n\n  /**\n   * For threshold functions, this creates the thresold test.  Mostly an internal\n   * detail, but might be useful to share between strategies.\n   */\n  CreateIsInThreshold = 'createIsInThreshold',\n\n  /**\n   *  Some strategy functions need to initialize some data before being runnable.\n   * This is mostly an internal detail, just useful to have an enum here for this.\n   */\n  Initialize = 'initialize',\n\n  // Internal Details\n  INTERNAL_setValue = 'setValue',\n}\n\nexport default StrategyCallbacks;\n","import type { InitializedOperationData } from '../BrushStrategy';\nimport pointInShapeCallback from '../../../../utilities/pointInShapeCallback';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\n\n/**\n * This function determines whether to fill or erase based on what the user\n * initially clicks on.  The behaviour is:\n * 1. If the user clicks on an area that has no active segment index in it,\n *    then assume the user using the active segment index for filling\n * 2. Find the segment index of the pixel the user clicked on, and assume they\n *    want to fill with that segment index.  Use the given segment index for\n *    the fill colour.\n *    a. If the user clicks on the active segment index, then they will fill\n *       with the active segment\n *    b. If the user clicks on the 0 segment index, they will clear the segment\n *       index, erasing the segment.\n *    c. If the user clicks on another segment index, they will \"restore\" that\n *       segment index, so that they can push back the segment area.\n *\n */\nexport default {\n  [StrategyCallbacks.Initialize]: (operationData: InitializedOperationData) => {\n    const { strategySpecificConfiguration } = operationData;\n    if (!strategySpecificConfiguration) {\n      return;\n    }\n    const { centerSegmentIndex } = strategySpecificConfiguration;\n    if (centerSegmentIndex) {\n      operationData.segmentIndex = centerSegmentIndex.segmentIndex;\n    }\n  },\n\n  [StrategyCallbacks.OnInteractionStart]: (\n    operationData: InitializedOperationData\n  ) => {\n    const {\n      segmentIndex,\n      previewSegmentIndex,\n      segmentationVoxelManager: segmentationVoxelManager,\n      centerIJK,\n      strategySpecificConfiguration,\n      imageVoxelManager: imageVoxelManager,\n      segmentationImageData,\n      preview,\n    } = operationData;\n    if (!strategySpecificConfiguration?.useCenterSegmentIndex) {\n      return;\n    }\n    // Get rid of the previous data\n    delete strategySpecificConfiguration.centerSegmentIndex;\n\n    let hasSegmentIndex = false;\n    let hasPreviewIndex = false;\n    const callback = ({ value }) => {\n      hasSegmentIndex ||= value === segmentIndex;\n      hasPreviewIndex ||= value === previewSegmentIndex;\n    };\n\n    pointInShapeCallback(\n      segmentationImageData as unknown,\n      imageVoxelManager.isInObject,\n      callback,\n      segmentationVoxelManager.boundsIJK\n    );\n\n    if (!hasSegmentIndex && !hasPreviewIndex) {\n      return;\n    }\n\n    let existingValue = segmentationVoxelManager.getAtIJKPoint(centerIJK);\n    if (existingValue === previewSegmentIndex) {\n      if (preview) {\n        existingValue = preview.segmentIndex;\n      } else {\n        return;\n      }\n    } else if (hasPreviewIndex) {\n      // Clear the preview area\n      existingValue = null;\n    }\n    operationData.segmentIndex = existingValue;\n    strategySpecificConfiguration.centerSegmentIndex = {\n      segmentIndex: existingValue,\n    };\n  },\n};\n","import type { InitializedOperationData } from '../BrushStrategy';\nimport type BoundsIJK from '../../../../types/BoundsIJK';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\n\n/**\n * Initializes the threshold values for the dynamic threshold.\n * If the threshold is undefined/null, the threshold will be set\n * by looking at the area centered on the centerIJK, with a delta radius,\n * and taking the range of those pixel values.\n * If the threshold is already set, then the range will be extended by just the\n * center voxel at centerIJK.\n */\nexport default {\n  [StrategyCallbacks.Initialize]: (operationData: InitializedOperationData) => {\n    const {\n      centerIJK,\n      strategySpecificConfiguration,\n      segmentationVoxelManager: segmentationVoxelManager,\n      imageVoxelManager: imageVoxelManager,\n      segmentIndex,\n    } = operationData;\n    const { THRESHOLD } = strategySpecificConfiguration;\n\n    if (!THRESHOLD?.isDynamic || !centerIJK || !segmentIndex) {\n      return;\n    }\n\n    const { boundsIJK } = segmentationVoxelManager;\n    const { threshold: oldThreshold, dynamicRadius = 0 } = THRESHOLD;\n    const useDelta = oldThreshold ? 0 : dynamicRadius;\n    const nestedBounds = boundsIJK.map((ijk, idx) => {\n      const [min, max] = ijk;\n      return [\n        Math.max(min, centerIJK[idx] - useDelta),\n        Math.min(max, centerIJK[idx] + useDelta),\n      ];\n    }) as BoundsIJK;\n\n    const threshold = oldThreshold || [Infinity, -Infinity];\n    const callback = ({ value }) => {\n      threshold[0] = Math.min(value, threshold[0]);\n      threshold[1] = Math.max(value, threshold[1]);\n    };\n    imageVoxelManager.forEach(callback, { boundsIJK: nestedBounds });\n\n    operationData.strategySpecificConfiguration.THRESHOLD.threshold = threshold;\n  },\n  // Setup a clear threshold value on mouse/touch down\n  [StrategyCallbacks.OnInteractionStart]: (\n    operationData: InitializedOperationData\n  ) => {\n    const { strategySpecificConfiguration, preview } = operationData;\n    if (!strategySpecificConfiguration?.THRESHOLD?.isDynamic && !preview) {\n      return;\n    }\n    strategySpecificConfiguration.THRESHOLD.threshold = null;\n  },\n};\n","import type { InitializedOperationData } from '../BrushStrategy';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\n\n/**\n * Sets up a preview to erase/clear the segment values.\n */\nexport default {\n  [StrategyCallbacks.Initialize]: (operationData: InitializedOperationData) => {\n    operationData.segmentIndex = 0;\n  },\n};\n","import type {\n  FloodFillResult,\n  FloodFillGetter,\n  FloodFillOptions,\n} from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * floodFill.js - Taken from MIT OSS lib - https://github.com/tuzz/n-dimensional-flood-fill\n * Refactored to ES6.\n *\n * @param {function} getter The getter to the elements of your data structure,\n *                          e.g. getter(x,y) for a 2D interprettation of your structure.\n * @param {number[]} seed The seed for your fill. The dimensionality is infered\n *                        by the number of dimensions of the seed.\n * @param {function} [options.onFlood] An optional callback to execute when each pixel is flooded.\n *                             e.g. onFlood(x,y).\n * @param {function} [options.onBoundary] An optional callback to execute whenever a boundary is reached.\n *                                a boundary could be another segmentIndex, or the edge of your\n *                                data structure (i.e. when your getter returns undefined).\n * @param {function} [options.equals] An optional equality method for your datastructure.\n *                            Default is simply value1 = value2.\n * @param {boolean} [options.diagonals] Whether you allow flooding through diagonals. Defaults to false.\n *\n * @returns {Object}\n */\nfunction floodFill(\n  getter: FloodFillGetter,\n  seed: Types.Point2 | Types.Point3,\n  options: FloodFillOptions = {}\n): FloodFillResult {\n  const onFlood = options.onFlood;\n  const onBoundary = options.onBoundary;\n  const equals = options.equals || defaultEquals;\n  const diagonals = options.diagonals || false;\n  const startNode = get(seed);\n  const permutations = prunedPermutations();\n  const stack = [];\n  const flooded = [];\n  const visits = {};\n  const bounds = {};\n\n  stack.push({ currentArgs: seed });\n\n  while (stack.length > 0) {\n    flood(stack.pop());\n  }\n\n  return {\n    flooded,\n    boundaries: boundaries(),\n  };\n\n  function flood(job) {\n    const getArgs = job.currentArgs;\n    const prevArgs = job.previousArgs;\n\n    if (visited(getArgs)) {\n      return;\n    }\n    markAsVisited(getArgs);\n\n    if (member(getArgs)) {\n      markAsFlooded(getArgs);\n      pushAdjacent(getArgs);\n    } else {\n      markAsBoundary(prevArgs);\n    }\n  }\n\n  function visited(key) {\n    return visits[key] === true;\n  }\n\n  function markAsVisited(key) {\n    visits[key] = true;\n  }\n\n  function member(getArgs) {\n    const node = safely(get, [getArgs]);\n\n    return safely(equals, [node, startNode]);\n  }\n\n  function markAsFlooded(getArgs) {\n    flooded.push(getArgs);\n    if (onFlood) {\n      //@ts-ignore\n      onFlood(...getArgs);\n    }\n  }\n\n  function markAsBoundary(prevArgs) {\n    bounds[prevArgs] = prevArgs;\n    if (onBoundary) {\n      //@ts-ignore\n      onBoundary(...prevArgs);\n    }\n  }\n\n  function pushAdjacent(getArgs) {\n    for (let i = 0; i < permutations.length; i += 1) {\n      const perm = permutations[i];\n      const nextArgs = getArgs.slice(0);\n\n      for (let j = 0; j < getArgs.length; j += 1) {\n        nextArgs[j] += perm[j];\n      }\n\n      stack.push({\n        currentArgs: nextArgs,\n        previousArgs: getArgs,\n      });\n    }\n  }\n\n  function get(getArgs) {\n    //@ts-ignore\n    return getter(...getArgs);\n  }\n\n  function safely(f, args) {\n    try {\n      return f(...args);\n    } catch (error) {\n      return;\n    }\n  }\n\n  function prunedPermutations() {\n    const permutations = permute(seed.length);\n\n    return permutations.filter(function (perm) {\n      const count = countNonZeroes(perm);\n\n      return count !== 0 && (count === 1 || diagonals);\n    });\n  }\n\n  function permute(length) {\n    const perms = [];\n\n    const permutation = function (string) {\n      return string.split('').map(function (c) {\n        return parseInt(c, 10) - 1;\n      });\n    };\n\n    for (let i = 0; i < Math.pow(3, length); i += 1) {\n      const string = lpad(i.toString(3), '0', length);\n\n      perms.push(permutation(string));\n    }\n\n    return perms;\n  }\n\n  function boundaries() {\n    const array = [];\n\n    for (const key in bounds) {\n      if (bounds[key] !== undefined) {\n        array.unshift(bounds[key]);\n      }\n    }\n\n    return array;\n  }\n}\n\nfunction defaultEquals(a, b) {\n  return a === b;\n}\n\nfunction countNonZeroes(array) {\n  let count = 0;\n\n  for (let i = 0; i < array.length; i += 1) {\n    if (array[i] !== 0) {\n      count += 1;\n    }\n  }\n\n  return count;\n}\n\nfunction lpad(string, character, length) {\n  const array = new Array(length + 1);\n  const pad = array.join(character);\n\n  return (pad + string).slice(-length);\n}\n\nexport default floodFill;\n","import { utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\n\n/**\n * addColorLUT - Adds a new color LUT to the state at the given colorLUTIndex.\n * If no colorLUT is provided, a new color LUT is generated.\n *\n * @param colorLUTIndex - the index of the colorLUT in the state\n * @param colorLUT - An array of The colorLUT to set.\n * @returns\n */\nfunction addColorLUT(colorLUT: Types.ColorLUT, colorLUTIndex: number): void {\n  if (!colorLUT) {\n    throw new Error('addColorLUT: colorLUT is required');\n  }\n\n  // Append the \"zero\" (no label) color to the front of the LUT, if necessary.\n  if (!utilities.isEqual(colorLUT[0], [0, 0, 0, 0])) {\n    console.warn(\n      'addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it'\n    );\n    colorLUT.unshift([0, 0, 0, 0]);\n  }\n\n  SegmentationState.addColorLUT(colorLUT, colorLUTIndex);\n}\n\n/**\n * It sets the toolGroup's segmentationRepresentation to use the provided\n * colorLUT at the given colorLUTIndex.\n * @param toolGroupId - the id of the toolGroup that renders the representation\n * @param segmentationRepresentationUID - the representationUID for the segmentation\n * @param colorLUTIndex - the index of the colorLUT to use\n */\nfunction setColorLUT(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  colorLUTIndex: number\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    throw new Error(\n      `setColorLUT: could not find segmentation representation with UID ${segmentationRepresentationUID}`\n    );\n  }\n\n  if (!SegmentationState.getColorLUT(colorLUTIndex)) {\n    throw new Error(\n      `setColorLUT: could not find colorLUT with index ${colorLUTIndex}`\n    );\n  }\n\n  segRepresentation.colorLUTIndex = colorLUTIndex;\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Given a tool group UID, a segmentation representationUID, and a segment index, return the\n * color for that segment. It can be used for segmentation tools that need to\n * display the color of their annotation.\n *\n * @param toolGroupId - The Id of the tool group that owns the segmentation representation.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment in the segmentation\n * @returns A color.\n */\nfunction getColorForSegmentIndex(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): Types.Color {\n  const segmentationRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segmentationRepresentation) {\n    throw new Error(\n      `segmentation representation with UID ${segmentationRepresentationUID} does not exist for tool group ${toolGroupId}`\n    );\n  }\n\n  const { colorLUTIndex } = segmentationRepresentation;\n\n  // get colorLUT\n  const colorLUT = SegmentationState.getColorLUT(colorLUTIndex);\n  let colorValue = colorLUT[segmentIndex];\n  if (!colorValue) {\n    if (typeof segmentIndex !== 'number') {\n      throw new Error(`Can't create colour for LUT index ${segmentIndex}`);\n    }\n    colorValue = colorLUT[segmentIndex] = [0, 0, 0, 0];\n  }\n  return colorValue;\n}\n\nfunction setColorForSegmentIndex(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number,\n  color: Types.Color\n): void {\n  // Get the reference to the color in the colorLUT.\n  const colorReference = getColorForSegmentIndex(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n\n  // Modify the values by reference\n  for (let i = 0; i < color.length; i++) {\n    colorReference[i] = color[i];\n  }\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nexport {\n  getColorForSegmentIndex,\n  addColorLUT,\n  setColorLUT,\n  setColorForSegmentIndex,\n};\n","import type { Types } from '@cornerstonejs/core';\nimport type { InitializedOperationData } from '../BrushStrategy';\nimport { triggerSegmentationDataModified } from '../../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { config as segmentationConfig } from '../../../../stateManagement/segmentation';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\n\n/**\n * Sets up a preview to use an alternate set of colours.  First fills the\n * preview segment index with the final one for all pixels, then resets\n * the preview colours.\n * This is only activated when the preview segment index is defined, either\n * from the initial state or from the global state.\n */\nexport default {\n  [StrategyCallbacks.Preview]: function (\n    operationData: InitializedOperationData\n  ) {\n    const { previewColors, strategySpecificConfiguration, enabledElement } =\n      operationData;\n    if (!previewColors || !strategySpecificConfiguration) {\n      return;\n    }\n\n    // Clean up old preview data\n    if (operationData.preview) {\n      delete operationData.preview;\n    }\n    delete strategySpecificConfiguration.centerSegmentIndex;\n\n    // Now generate a normal preview as though the user had clicked, filled, released\n    this.onInteractionStart?.(enabledElement, operationData);\n    const preview = this.fill(enabledElement, operationData);\n    if (preview) {\n      preview.isPreviewFromHover = true;\n      operationData.preview = preview;\n      this.onInteractionEnd?.(enabledElement, operationData);\n    }\n    return preview;\n  },\n\n  [StrategyCallbacks.Initialize]: (operationData: InitializedOperationData) => {\n    const {\n      toolGroupId,\n      segmentIndex,\n      segmentationRepresentationUID,\n      previewSegmentIndex,\n      previewColors,\n      preview,\n    } = operationData;\n    if (previewColors === undefined) {\n      return;\n    }\n    if (preview) {\n      preview.previewVoxelManager.sourceVoxelManager =\n        operationData.segmentationVoxelManager;\n      // And use the preview data associated with this tracking object as needed\n      operationData.previewVoxelManager = preview.previewVoxelManager;\n    }\n\n    if (segmentIndex === null || !previewSegmentIndex) {\n      // Null means to reset the value, so we don't change the preview colour\n      return;\n    }\n\n    const configColor = previewColors?.[segmentIndex];\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n    if (!configColor && !segmentColor) {\n      return;\n    }\n    const previewColor = configColor || segmentColor.map((it) => it * 0.9);\n    segmentationConfig.color.setColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      previewSegmentIndex,\n      previewColor as Types.Color\n    );\n  },\n\n  [StrategyCallbacks.AcceptPreview]: (\n    operationData: InitializedOperationData\n  ) => {\n    const {\n      segmentationVoxelManager: segmentationVoxelManager,\n      previewVoxelManager: previewVoxelManager,\n      previewSegmentIndex,\n      preview,\n    } = operationData;\n    if (previewSegmentIndex === undefined) {\n      return;\n    }\n    const segmentIndex = preview?.segmentIndex ?? operationData.segmentIndex;\n    const tracking = previewVoxelManager;\n    if (!tracking || tracking.modifiedSlices.size === 0) {\n      return;\n    }\n\n    const callback = ({ index }) => {\n      const oldValue = segmentationVoxelManager.getAtIndex(index);\n      if (oldValue === previewSegmentIndex) {\n        segmentationVoxelManager.setAtIndex(index, segmentIndex);\n      }\n    };\n    tracking.forEach(callback, {});\n\n    triggerSegmentationDataModified(\n      operationData.segmentationId,\n      tracking.getArrayOfSlices()\n    );\n    tracking.clear();\n  },\n\n  [StrategyCallbacks.RejectPreview]: (\n    operationData: InitializedOperationData\n  ) => {\n    const {\n      previewVoxelManager: previewVoxelManager,\n      segmentationVoxelManager: segmentationVoxelManager,\n    } = operationData;\n    if (previewVoxelManager.modifiedSlices.size === 0) {\n      return;\n    }\n\n    const callback = ({ index, value }) => {\n      segmentationVoxelManager.setAtIndex(index, value);\n    };\n    previewVoxelManager.forEach(callback);\n\n    triggerSegmentationDataModified(\n      operationData.segmentationId,\n      previewVoxelManager.getArrayOfSlices()\n    );\n    previewVoxelManager.clear();\n  },\n};\n","import determineSegmentIndex from './determineSegmentIndex';\nimport dynamicThreshold from './dynamicThreshold';\nimport erase from './erase';\nimport islandRemoval from './islandRemoval';\nimport preview from './preview';\nimport regionFill from './regionFill';\nimport setValue from './setValue';\nimport threshold from './threshold';\n\nexport default {\n  determineSegmentIndex,\n  dynamicThreshold,\n  erase,\n  islandRemoval,\n  preview,\n  regionFill,\n  setValue,\n  threshold,\n};\n","import type { InitializedOperationData } from '../BrushStrategy';\nimport floodFill from '../../../../utilities/segmentation/floodFill';\nimport { triggerSegmentationDataModified } from '../../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\n\n/**\n * Removes external islands and fills internal islands.\n * External islands are areas of preview which are not connected via fill or\n * preview colours to the clicked/dragged over points.\n * Internal islands are areas of non-preview which are entirely surrounded by\n * colours connected to the clicked/dragged over points.\n */\nexport default {\n  [StrategyCallbacks.OnInteractionEnd]: (\n    operationData: InitializedOperationData\n  ) => {\n    const {\n      previewVoxelManager: previewVoxelManager,\n      segmentationVoxelManager: segmentationVoxelManager,\n      strategySpecificConfiguration,\n      previewSegmentIndex,\n      segmentIndex,\n    } = operationData;\n\n    if (!strategySpecificConfiguration.THRESHOLD || segmentIndex === null) {\n      return;\n    }\n\n    const clickedPoints = previewVoxelManager.getPoints();\n    if (!clickedPoints?.length) {\n      return;\n    }\n\n    if (previewSegmentIndex === undefined) {\n      return;\n    }\n\n    // Ensure the bounds includes the clicked points, otherwise the fill\n    // fails.\n    const boundsIJK = previewVoxelManager\n      .getBoundsIJK()\n      .map((bound, i) => [\n        Math.min(bound[0], ...clickedPoints.map((point) => point[i])),\n        Math.max(bound[1], ...clickedPoints.map((point) => point[i])),\n      ]);\n\n    if (boundsIJK.find((it) => it[0] < 0 || it[1] > 65535)) {\n      // Nothing done, so just skip this\n      return;\n    }\n\n    const floodedSet = new Set<number>();\n    // Returns true for new colour, and false otherwise\n    const getter = (i, j, k) => {\n      if (\n        i < boundsIJK[0][0] ||\n        i > boundsIJK[0][1] ||\n        j < boundsIJK[1][0] ||\n        j > boundsIJK[1][1] ||\n        k < boundsIJK[2][0] ||\n        k > boundsIJK[2][1]\n      ) {\n        return -1;\n      }\n      const index = segmentationVoxelManager.toIndex([i, j, k]);\n      if (floodedSet.has(index)) {\n        // Values already flooded\n        return -2;\n      }\n      const oldVal = segmentationVoxelManager.getAtIndex(index);\n      const isIn =\n        oldVal === previewSegmentIndex || oldVal === segmentIndex ? 1 : 0;\n      if (!isIn) {\n        segmentationVoxelManager.addPoint(index);\n      }\n      // 1 is values that are preview/segment index, 0 is everything else\n      return isIn;\n    };\n\n    let floodedCount = 0;\n\n    const onFlood = (i, j, k) => {\n      const index = segmentationVoxelManager.toIndex([i, j, k]);\n      if (floodedSet.has(index)) {\n        return;\n      }\n      // Fill this point with an indicator that this point is connected\n      previewVoxelManager.setAtIJK(i, j, k, previewSegmentIndex);\n      floodedSet.add(index);\n      floodedCount++;\n    };\n\n    clickedPoints.forEach((clickedPoint, index) => {\n      // @ts-ignore - need to ignore the spread appication to array params\n      if (getter(...clickedPoint) === 1) {\n        floodFill(getter, clickedPoint, {\n          onFlood,\n          diagonals: true,\n        });\n      }\n    });\n\n    let clearedCount = 0;\n    let previewCount = 0;\n\n    const callback = ({ index, pointIJK, value: trackValue }) => {\n      const value = segmentationVoxelManager.getAtIndex(index);\n      if (floodedSet.has(index)) {\n        previewCount++;\n        const newValue =\n          trackValue === segmentIndex ? segmentIndex : previewSegmentIndex;\n        previewVoxelManager.setAtIJKPoint(pointIJK, newValue);\n      } else if (value === previewSegmentIndex) {\n        clearedCount++;\n        const newValue = trackValue ?? 0;\n        previewVoxelManager.setAtIJKPoint(pointIJK, newValue);\n      }\n    };\n\n    previewVoxelManager.forEach(callback, {});\n\n    if (floodedCount - previewCount !== 0) {\n      console.warn(\n        'There were flooded=',\n        floodedCount,\n        'cleared=',\n        clearedCount,\n        'preview count=',\n        previewCount,\n        'not handled',\n        floodedCount - previewCount\n      );\n    }\n    const islandMap = new Set(segmentationVoxelManager.points || []);\n    floodedSet.clear();\n\n    for (const index of islandMap.keys()) {\n      if (floodedSet.has(index)) {\n        continue;\n      }\n      let isInternal = true;\n      const internalSet = new Set<number>();\n      const onFloodInternal = (i, j, k) => {\n        const floodIndex = previewVoxelManager.toIndex([i, j, k]);\n        floodedSet.add(floodIndex);\n        if (\n          (boundsIJK[0][0] !== boundsIJK[0][1] &&\n            (i === boundsIJK[0][0] || i === boundsIJK[0][1])) ||\n          (boundsIJK[1][0] !== boundsIJK[1][1] &&\n            (j === boundsIJK[1][0] || j === boundsIJK[1][1])) ||\n          (boundsIJK[2][0] !== boundsIJK[2][1] &&\n            (k === boundsIJK[2][0] || k === boundsIJK[2][1]))\n        ) {\n          isInternal = false;\n        }\n        if (isInternal) {\n          internalSet.add(floodIndex);\n        }\n      };\n      const pointIJK = previewVoxelManager.toIJK(index);\n      if (getter(...pointIJK) !== 0) {\n        continue;\n      }\n      floodFill(getter, pointIJK, {\n        onFlood: onFloodInternal,\n        diagonals: false,\n      });\n      if (isInternal) {\n        for (const index of internalSet) {\n          previewVoxelManager.setAtIndex(index, previewSegmentIndex);\n        }\n      }\n    }\n    triggerSegmentationDataModified(\n      operationData.segmentationId,\n      previewVoxelManager.getArrayOfSlices()\n    );\n  },\n};\n","import type { InitializedOperationData } from '../BrushStrategy';\nimport pointInShapeCallback from '../../../../utilities/pointInShapeCallback';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\n\n/**\n * Creates a fill strategy that uses the isWithinThreshold created by the\n * createIsInThreshold and the bounds specified in the boundsIJK to go over\n * the specified area, checking if in threshold, and if so, filling that area\n * with the new segment by calling the setValue function.\n */\nexport default {\n  [StrategyCallbacks.Fill]: (operationData: InitializedOperationData) => {\n    const {\n      segmentsLocked,\n      segmentationImageData,\n      segmentationVoxelManager: segmentationVoxelManager,\n      previewVoxelManager: previewVoxelManager,\n      imageVoxelManager: imageVoxelManager,\n      brushStrategy,\n      centerIJK,\n    } = operationData;\n    const isWithinThreshold =\n      brushStrategy.createIsInThreshold?.(operationData);\n    const { setValue } = brushStrategy;\n\n    const callback = isWithinThreshold\n      ? (data) => {\n          const { value, index } = data;\n          if (segmentsLocked.includes(value) || !isWithinThreshold(index)) {\n            return;\n          }\n          setValue(operationData, data);\n        }\n      : (data) => setValue(operationData, data);\n\n    pointInShapeCallback(\n      segmentationImageData as unknown,\n      imageVoxelManager.isInObject,\n      callback,\n      segmentationVoxelManager.boundsIJK\n    );\n\n    previewVoxelManager.addPoint(centerIJK);\n  },\n};\n","import type { InitializedOperationData } from '../BrushStrategy';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\n\n/**\n * Creates a set value function which will apply the specified segmentIndex\n * to the given location.\n * If segmentIndex is null, it will clear the given segment index instead\n * This is all done through the previewVoxelManager so that values can be recorded\n * as changed, and the original values remembered.\n */\nexport default {\n  [StrategyCallbacks.INTERNAL_setValue]: (\n    operationData: InitializedOperationData,\n    { value, index }\n  ) => {\n    const {\n      segmentsLocked,\n      segmentIndex,\n      previewVoxelManager: previewVoxelManager,\n      previewSegmentIndex,\n      segmentationVoxelManager: segmentationVoxelManager,\n    } = operationData;\n    const existingValue = segmentationVoxelManager.getAtIndex(index);\n    if (segmentIndex === null) {\n      const oldValue = previewVoxelManager.getAtIndex(index);\n      if (oldValue !== undefined) {\n        previewVoxelManager.setAtIndex(index, oldValue);\n      }\n      return;\n    }\n\n    if (existingValue === segmentIndex || segmentsLocked.includes(value)) {\n      return;\n    }\n    // Correct for preview data getting into the image area and not accepted/rejected\n    if (existingValue === previewSegmentIndex) {\n      if (previewVoxelManager.getAtIndex(index) === undefined) {\n        // Reset the value to ensure preview gets added to the indices\n        segmentationVoxelManager.setAtIndex(index, segmentIndex);\n      } else {\n        return;\n      }\n    }\n\n    // Now, just update the displayed value\n    const useSegmentIndex = previewSegmentIndex ?? segmentIndex;\n\n    previewVoxelManager.setAtIndex(index, useSegmentIndex);\n  },\n};\n","import type { InitializedOperationData } from '../BrushStrategy';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\n\n/**\n * Adds an isWithinThreshold to the operation data that checks that the\n * image value is within threshold[0]...threshold[1]\n * No-op if threshold not defined.\n */\nexport default {\n  [StrategyCallbacks.CreateIsInThreshold]: (\n    operationData: InitializedOperationData\n  ) => {\n    const {\n      imageVoxelManager: imageVoxelManager,\n      strategySpecificConfiguration,\n      segmentIndex,\n    } = operationData;\n    if (!strategySpecificConfiguration || !segmentIndex) {\n      return;\n    }\n    return (index) => {\n      const { THRESHOLD, THRESHOLD_INSIDE_CIRCLE } =\n        strategySpecificConfiguration;\n\n      const voxelValue = imageVoxelManager.getAtIndex(index);\n      // Prefer the generic version of the THRESHOLD configuration, but fallback\n      // to the older THRESHOLD_INSIDE_CIRCLE version.\n      const { threshold } = THRESHOLD || THRESHOLD_INSIDE_CIRCLE || {};\n      if (!threshold?.length) {\n        return true;\n      }\n      return threshold[0] <= voxelValue && voxelValue <= threshold[1];\n    };\n  },\n};\n","import { cache, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { isVolumeSegmentation } from './stackVolumeCheck';\nimport { LabelmapToolOperationDataStack } from '../../../../types';\n\nconst { VoxelManager } = utilities;\n\nfunction getStrategyData({ operationData, viewport }) {\n  let segmentationImageData, segmentationScalarData, imageScalarData;\n  let dimensions: Types.Point3;\n  if (isVolumeSegmentation(operationData)) {\n    const { volumeId, referencedVolumeId } = operationData;\n\n    const segmentationVolume = cache.getVolume(volumeId);\n    const imageVolume = cache.getVolume(referencedVolumeId);\n\n    if (!segmentationVolume || !imageVolume) {\n      return;\n    }\n\n    ({ imageData: segmentationImageData } = segmentationVolume);\n    segmentationScalarData = segmentationVolume.getScalarData();\n    imageScalarData = imageVolume.getScalarData();\n    dimensions = imageVolume.dimensions;\n  } else {\n    const { imageIdReferenceMap, segmentationRepresentationUID } =\n      operationData as LabelmapToolOperationDataStack;\n\n    if (!imageIdReferenceMap) {\n      return;\n    }\n\n    const currentImageId = viewport.getCurrentImageId();\n    if (!currentImageId) {\n      return;\n    }\n\n    // we know that the segmentationRepresentationUID is the name of the actor always\n    // and always circle modifies the current imageId which in fact is the imageData\n    // of that actor at that moment so we have the imageData already\n    const actor = viewport.getActor(segmentationRepresentationUID);\n    segmentationImageData = actor.actor.getMapper().getInputData();\n    const currentSegmentationImageId = imageIdReferenceMap.get(currentImageId);\n\n    const segmentationImage = cache.getImage(currentSegmentationImageId);\n    segmentationScalarData = segmentationImage.getPixelData();\n\n    const image = cache.getImage(currentImageId);\n\n    // VERY IMPORTANT\n    // This is the pixel data of the image that is being segmented in the cache\n    // and we need to use this to for the modification\n    imageScalarData = image.getPixelData();\n    dimensions = [image.columns, image.rows, 1];\n  }\n\n  return {\n    segmentationImageData,\n    segmentationScalarData,\n    segmentationVoxelManager: VoxelManager.createVolumeVoxelManager(\n      dimensions,\n      segmentationScalarData\n    ),\n    imageScalarData,\n    imageVoxelManager: VoxelManager.createVolumeVoxelManager(\n      dimensions,\n      imageScalarData\n    ),\n  };\n}\n\nexport { getStrategyData };\n","import type { Types } from '@cornerstonejs/core';\nimport { cache, utilities as csUtils } from '@cornerstonejs/core';\n\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport compositions from './compositions';\nimport { getStrategyData } from './utils/getStrategyData';\nimport { isVolumeSegmentation } from './utils/stackVolumeCheck';\nimport { StrategyCallbacks } from '../../../enums';\nimport type {\n  LabelmapToolOperationDataAny,\n  LabelmapToolOperationDataVolume,\n} from '../../../types/LabelmapToolOperationData';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\n\nconst { VoxelManager } = csUtils;\n\nexport type InitializedOperationData = LabelmapToolOperationDataAny & {\n  // Additional data for performing the strategy\n  enabledElement: Types.IEnabledElement;\n  centerIJK?: Types.Point3;\n  centerWorld: Types.Point3;\n  viewport: Types.IViewport;\n  imageVoxelManager: csUtils.VoxelManager<number>;\n  segmentationVoxelManager: csUtils.VoxelManager<number>;\n  segmentationImageData: vtkImageData;\n  previewVoxelManager: csUtils.VoxelManager<number>;\n  // The index to use for the preview segment.  Currently always undefined or 255\n  // but define it here for future expansion of LUT tables\n  previewSegmentIndex?: number;\n\n  brushStrategy: BrushStrategy;\n};\n\nexport type StrategyFunction = (\n  operationData: InitializedOperationData,\n  ...args\n) => unknown;\n\nexport type CompositionInstance = {\n  [callback in StrategyCallbacks]?: StrategyFunction;\n};\n\nexport type CompositionFunction = () => CompositionInstance;\n\nexport type Composition = CompositionFunction | CompositionInstance;\n\n/**\n * A brush strategy is a composition of individual parts which together form\n * the strategy for a brush tool.\n *\n * Parts of a strategy:\n * 1. Fill strategy - how the fill gets done (left/right, 3d, paint fill etc)\n * 2. Set value strategy - can clear values or set them, or something else?\n * 3. In object strategy - how to tell if a point is contained in the object\n *    * Bounding box getter for the object strategy\n * 4. threshold - how to determine if a point is within a threshold value\n * 5. preview - how to display preview information\n * 6. Various strategy customizations such as erase\n *\n * These combine to form an actual brush:\n *\n * Circle - convexFill, defaultSetValue, inEllipse/boundingbox ellipse, empty threshold\n * Rectangle - - convexFill, defaultSetValue, inRectangle/boundingbox rectangle, empty threshold\n * might also get parameter values from input,  init for setup of convexFill\n *\n * The pieces are combined to generate a strategyFunction, which performs\n * the actual strategy operation, as well as various callbacks for the strategy\n * to allow more control over behaviour in the specific strategy (such as displaying\n * preview)\n */\n\nexport default class BrushStrategy {\n  /**\n   * Provide some default initializers for various situations, mostly for\n   * external use to allow defining new brushes\n   */\n  public static COMPOSITIONS = compositions;\n\n  protected static childFunctions = {\n    [StrategyCallbacks.OnInteractionStart]: addListMethod(\n      StrategyCallbacks.OnInteractionStart,\n      StrategyCallbacks.Initialize\n    ),\n    [StrategyCallbacks.OnInteractionEnd]: addListMethod(\n      StrategyCallbacks.OnInteractionEnd,\n      StrategyCallbacks.Initialize\n    ),\n    [StrategyCallbacks.Fill]: addListMethod(StrategyCallbacks.Fill),\n    [StrategyCallbacks.Initialize]: addListMethod(StrategyCallbacks.Initialize),\n    [StrategyCallbacks.CreateIsInThreshold]: addSingletonMethod(\n      StrategyCallbacks.CreateIsInThreshold\n    ),\n    [StrategyCallbacks.AcceptPreview]: addListMethod(\n      StrategyCallbacks.AcceptPreview,\n      StrategyCallbacks.Initialize\n    ),\n    [StrategyCallbacks.RejectPreview]: addListMethod(\n      StrategyCallbacks.RejectPreview,\n      StrategyCallbacks.Initialize\n    ),\n    [StrategyCallbacks.INTERNAL_setValue]: addSingletonMethod(\n      StrategyCallbacks.INTERNAL_setValue\n    ),\n    [StrategyCallbacks.Preview]: addSingletonMethod(\n      StrategyCallbacks.Preview,\n      false\n    ),\n    // Add other exposed fields below\n    // initializers is exposed on the function to allow extension of the composition object\n    compositions: null,\n  };\n\n  public compositions: Composition[];\n  public strategyFunction: (enabledElement, operationData) => unknown;\n\n  protected configurationName: string;\n  protected _initialize = [];\n  protected _fill = [];\n  protected _acceptPreview: [];\n  protected _onInteractionStart = [];\n\n  constructor(name, ...initializers: Composition[]) {\n    this.configurationName = name;\n    this.compositions = initializers;\n    initializers.forEach((initializer) => {\n      const result =\n        typeof initializer === 'function' ? initializer() : initializer;\n      if (!result) {\n        return;\n      }\n      for (const key in result) {\n        if (!BrushStrategy.childFunctions[key]) {\n          throw new Error(`Didn't find ${key} as a brush strategy`);\n        }\n        BrushStrategy.childFunctions[key](this, result[key]);\n      }\n    });\n    this.strategyFunction = (enabledElement, operationData) =>\n      this.fill(enabledElement, operationData);\n\n    for (const key of Object.keys(BrushStrategy.childFunctions)) {\n      this.strategyFunction[key] = this[key];\n    }\n  }\n\n  /**\n   * Performs a fill of the given region.\n   * Returns the preview data if the fill performs a preview, and otherwise\n   * returns null.\n   */\n  public fill = (\n    enabledElement: Types.IEnabledElement,\n    operationData: LabelmapToolOperationDataAny\n  ) => {\n    const initializedData = this.initialize(enabledElement, operationData);\n\n    const { strategySpecificConfiguration = {}, centerIJK } = initializedData;\n    // Store the center IJK location so that we can skip an immediate same-point update\n    // TODO - move this to the BrushTool\n    if (csUtils.isEqual(centerIJK, strategySpecificConfiguration.centerIJK)) {\n      return operationData.preview;\n    } else {\n      strategySpecificConfiguration.centerIJK = centerIJK;\n    }\n\n    this._fill.forEach((func) => func(initializedData));\n\n    const {\n      segmentationVoxelManager,\n      previewVoxelManager,\n      previewSegmentIndex,\n    } = initializedData;\n\n    triggerSegmentationDataModified(\n      initializedData.segmentationId,\n      segmentationVoxelManager.getArrayOfSlices()\n    );\n    // We are only previewing if there is a preview index, and there is at\n    // least one slice modified\n    if (!previewSegmentIndex || !previewVoxelManager.modifiedSlices.size) {\n      return null;\n    }\n    // Use the original initialized data set to preserve preview info\n    return initializedData.preview || initializedData;\n  };\n\n  protected initialize(\n    enabledElement: Types.IEnabledElement,\n    operationData: LabelmapToolOperationDataAny\n  ): InitializedOperationData {\n    const { viewport } = enabledElement;\n    const data = getStrategyData({ operationData, viewport });\n\n    if (!data) {\n      console.warn('No data found for BrushStrategy');\n      return operationData.preview;\n    }\n\n    if (isVolumeSegmentation(operationData)) {\n      const { referencedVolumeId, volumeId } =\n        operationData as LabelmapToolOperationDataVolume;\n\n      const imageVolume = cache.getVolume(referencedVolumeId);\n      const segmentation = cache.getVolume(volumeId);\n\n      if (\n        !csUtils.isEqual(segmentation.dimensions, imageVolume.dimensions) ||\n        !csUtils.isEqual(segmentation.direction, imageVolume.direction)\n      ) {\n        throw new Error(\n          'Only source data the same dimensions/size/orientation as the segmentation currently supported.'\n        );\n      }\n    }\n\n    const {\n      imageVoxelManager,\n      segmentationVoxelManager,\n      segmentationImageData,\n    } = data;\n    const previewVoxelManager =\n      operationData.preview?.previewVoxelManager ||\n      VoxelManager.createHistoryVoxelManager(segmentationVoxelManager);\n    const previewEnabled = !!operationData.previewColors;\n    const previewSegmentIndex = previewEnabled ? 255 : undefined;\n\n    const initializedData: InitializedOperationData = {\n      previewSegmentIndex,\n      ...operationData,\n      enabledElement,\n      imageVoxelManager,\n      segmentationVoxelManager,\n      segmentationImageData,\n      previewVoxelManager,\n      viewport,\n\n      centerWorld: null,\n      brushStrategy: this,\n    };\n\n    this._initialize.forEach((func) => func(initializedData));\n\n    return initializedData;\n  }\n\n  /**\n   * Function called to initialize the start of the strategy.  Often this is\n   * on mouse down, so calling this initDown.\n   * Over-written by the strategy composition.\n   */\n  public onInteractionStart = (\n    enabledElement: Types.IEnabledElement,\n    operationData: LabelmapToolOperationDataAny\n  ) => {\n    const { preview } = operationData;\n    // Need to skip the init down if it has already occurred in teh preview\n    // That prevents resetting values which were used to determine the preview\n    if (preview?.isPreviewFromHover) {\n      preview.isPreviewFromHover = false;\n      return;\n    }\n    const initializedData = this.initialize(enabledElement, operationData);\n    this._onInteractionStart.forEach((func) =>\n      func.call(this, initializedData)\n    );\n  };\n\n  /**\n   * Function called when a strategy is complete in some way.\n   * Often called on mouse up, hence the name.\n   *\n   * Over-written by the strategy composition.\n   */\n  public onInteractionEnd: (\n    enabledElement: Types.IEnabledElement,\n    operationData: LabelmapToolOperationDataAny\n  ) => void;\n\n  /**\n   * Reject the preview.\n   * Over-written by the strategy composition.\n   */\n  public rejectPreview: (\n    enabledElement: Types.IEnabledElement,\n    operationData: LabelmapToolOperationDataAny\n  ) => void;\n\n  /**\n   * Accept the preview, making it part of the overall segmentation\n   *\n   * Over-written by the strategy composition.\n   */\n  public acceptPreview: (\n    enabledElement: Types.IEnabledElement,\n    operationData: LabelmapToolOperationDataAny\n  ) => void;\n\n  /**\n   * Display a preview at the current position.  This will typically\n   * using the onInteractionStart, fill and onInteractionEnd methods,\n   * plus optional use of a preview.\n   *\n   * Over-written by the strategy composition.\n   * @returns preview data if a preview is displayed.\n   */\n  public preview: (\n    enabledElement: Types.IEnabledElement,\n    operationData: LabelmapToolOperationDataAny\n  ) => unknown;\n\n  /**\n   * Over-written by the strategy composition.\n   */\n  public setValue: (operationData: InitializedOperationData, data) => void;\n\n  /**\n   * Over-written by the strategy composition.\n   */\n  public createIsInThreshold: (operationData: InitializedOperationData) => any;\n}\n\n/**\n * Adds a list method to the set of defined methods.\n */\nfunction addListMethod(name: string, createInitialized?: string) {\n  const listName = `_${name}`;\n  return (brushStrategy, func) => {\n    brushStrategy[listName] ||= [];\n    brushStrategy[listName].push(func);\n    brushStrategy[name] ||= createInitialized\n      ? (enabledElement, operationData) => {\n          const initializedData = brushStrategy[createInitialized](\n            enabledElement,\n            operationData\n          );\n          brushStrategy[listName].forEach((func) =>\n            func.call(brushStrategy, initializedData)\n          );\n        }\n      : (operationData) => {\n          brushStrategy[listName].forEach((func) =>\n            func.call(brushStrategy, operationData)\n          );\n        };\n  };\n}\n\n/**\n * Adds a singleton method, throwing an exception if it is already defined\n */\nfunction addSingletonMethod(name: string, isInitialized = true) {\n  return (brushStrategy, func) => {\n    if (brushStrategy[name]) {\n      throw new Error(`The singleton method ${name} already exists`);\n    }\n    brushStrategy[name] = isInitialized\n      ? func\n      : (enabledElement, operationData) => {\n          // Store the enabled element in the operation data so we can use single\n          // argument calls\n          operationData.enabledElement = enabledElement;\n          return func.call(brushStrategy, operationData);\n        };\n  };\n}\n","import type { Types } from '@cornerstonejs/core';\n\nexport type CanvasCoordinates = [\n  Types.Point2, // bottom\n  Types.Point2, // top\n  Types.Point2, // left\n  Types.Point2 // right\n];\n\n/**\n * It takes the canvas coordinates of the ellipse corners and returns the top left and bottom right\n * corners of it\n *\n * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasEllipseCorners(\n  ellipseCanvasPoints: CanvasCoordinates\n): Array<Types.Point2> {\n  const [bottom, top, left, right] = ellipseCanvasPoints;\n\n  const topLeft = <Types.Point2>[left[0], top[1]];\n  const bottomRight = <Types.Point2>[right[0], bottom[1]];\n\n  return [topLeft, bottomRight];\n}\n","import type { Types } from '@cornerstonejs/core';\ninterface Inverts {\n  invXRadiusSq?: number;\n  invYRadiusSq?: number;\n  invZRadiusSq?: number;\n  fast?: boolean;\n  /**\n   * If you call the pointInEllipse.precalculateInverts first, then you\n   * can call precalculated directly instead of having the extra time for\n   * the if conditions.\n   */\n  precalculated?: (pointLPS: Types.Point3) => boolean;\n}\n\n/**\n * Given an ellipse and a point, return true if the point is inside the ellipse\n * @param ellipse - The ellipse object to check against.\n * @param pointLPS - The point in LPS space to test.\n * @param inverts - An object to cache the inverted radius squared values, if you\n * are testing multiple points against the same ellipse then it is recommended to\n * pass in the same object to cache the values. However, there is a simpler way\n * to do this by passing in the fast flag as true, then on the first iteration\n * the values will be cached and on subsequent iterations the cached values will\n * be used.\n *\n * @returns A boolean value.\n */\nexport default function pointInEllipse(\n  ellipse,\n  pointLPS,\n  inverts: Inverts = {}\n) {\n  if (!inverts.precalculated) {\n    precalculatePointInEllipse(ellipse, inverts);\n  }\n  return inverts.precalculated(pointLPS);\n}\n\n/**\n * This will perform some precalculations to make things faster.\n * Ideally, use the 'precalculated' function inside inverts to call the\n * test function.  This minimizes re-reading of variables and only needs the\n * LPS passed each time.\n * That is:\n *\n * ```\n *    const inverts = precalculatePointInEllipse(ellipse);\n *    if( inverts.precalculated(pointLPS) ) ...\n * ```\n */\nconst precalculatePointInEllipse = (ellipse, inverts: Inverts = {}) => {\n  const { xRadius, yRadius, zRadius } = ellipse;\n\n  // This will run only once since we are caching the values in the same\n  // object that is passed in.\n  if (\n    inverts.invXRadiusSq === undefined ||\n    inverts.invYRadiusSq === undefined ||\n    inverts.invZRadiusSq === undefined\n  ) {\n    inverts.invXRadiusSq = xRadius !== 0 ? 1 / xRadius ** 2 : 0;\n    inverts.invYRadiusSq = yRadius !== 0 ? 1 / yRadius ** 2 : 0;\n    inverts.invZRadiusSq = zRadius !== 0 ? 1 / zRadius ** 2 : 0;\n  }\n\n  const { invXRadiusSq, invYRadiusSq, invZRadiusSq } = inverts;\n  const { center } = ellipse;\n  const [centerL, centerP, centerS] = center;\n\n  inverts.precalculated = (pointLPS) => {\n    // Calculate the sum of normalized squared distances\n    const dx = pointLPS[0] - centerL;\n    let inside = dx * dx * invXRadiusSq;\n    if (inside > 1) {\n      return false;\n    }\n\n    const dy = pointLPS[1] - centerP;\n    inside += dy * dy * invYRadiusSq;\n    if (inside > 1) {\n      return false;\n    }\n\n    const dz = pointLPS[2] - centerS;\n    inside += dz * dz * invZRadiusSq;\n\n    // Check if the point is inside the ellipse\n    return inside <= 1;\n  };\n\n  return inverts;\n};\n\nexport { precalculatePointInEllipse };\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCanvasEllipseCorners,\n  precalculatePointInEllipse,\n} from '../../../utilities/math/ellipse';\nimport { getBoundingBoxAroundShapeIJK } from '../../../utilities/boundingBox';\nimport BrushStrategy from './BrushStrategy';\nimport type { Composition, InitializedOperationData } from './BrushStrategy';\nimport type { CanvasCoordinates } from '../../../types';\nimport { StrategyCallbacks } from '../../../enums';\nimport compositions from './compositions';\nimport { pointInSphere } from '../../../utilities/math/sphere';\n\nconst { transformWorldToIndex, isEqual } = csUtils;\n\nconst initializeCircle = {\n  [StrategyCallbacks.Initialize]: (operationData: InitializedOperationData) => {\n    const {\n      points, // bottom, top, left, right\n      imageVoxelManager: imageVoxelManager,\n      viewport,\n      segmentationImageData,\n      segmentationVoxelManager: segmentationVoxelManager,\n    } = operationData;\n\n    // Happens on a preview setup\n    if (!points) {\n      return;\n    }\n    // Average the points to get the center of the ellipse\n    const center = vec3.fromValues(0, 0, 0);\n    points.forEach((point) => {\n      vec3.add(center, center, point);\n    });\n    vec3.scale(center, center, 1 / points.length);\n\n    operationData.centerWorld = center as Types.Point3;\n    operationData.centerIJK = transformWorldToIndex(\n      segmentationImageData,\n      center as Types.Point3\n    );\n\n    const canvasCoordinates = points.map((p) =>\n      viewport.worldToCanvas(p)\n    ) as CanvasCoordinates;\n\n    // 1. From the drawn tool: Get the ellipse (circle) topLeft and bottomRight\n    // corners in canvas coordinates\n    const [topLeftCanvas, bottomRightCanvas] =\n      getCanvasEllipseCorners(canvasCoordinates);\n\n    // 2. Find the extent of the ellipse (circle) in IJK index space of the image\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n\n    const circleCornersIJK = points.map((world) => {\n      return transformWorldToIndex(segmentationImageData, world);\n    });\n\n    // get the bounds from the circle points since in oblique images the\n    // circle will not be axis aligned\n    const boundsIJK = getBoundingBoxAroundShapeIJK(\n      circleCornersIJK,\n      segmentationImageData.getDimensions()\n    );\n\n    segmentationVoxelManager.boundsIJK = boundsIJK;\n    imageVoxelManager.isInObject = createPointInEllipse({\n      topLeftWorld,\n      bottomRightWorld,\n      center,\n    });\n  },\n} as Composition;\n\n/**\n * Creates a function that tells the user if the provided point in LPS space\n * is inside the ellipse.\n *\n * This will return a sphere test function if the bounds are a circle or\n * sphere shape (same radius in two or three dimensions), or an elliptical shape\n * if they differ.\n */\nfunction createPointInEllipse(worldInfo: {\n  topLeftWorld: Types.Point3;\n  bottomRightWorld: Types.Point3;\n  center: Types.Point3 | vec3;\n}) {\n  const { topLeftWorld, bottomRightWorld, center } = worldInfo;\n\n  const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;\n  const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;\n  const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;\n\n  const radius = Math.max(xRadius, yRadius, zRadius);\n  if (\n    isEqual(xRadius, radius) &&\n    isEqual(yRadius, radius) &&\n    isEqual(zRadius, radius)\n  ) {\n    const sphereObj = {\n      center,\n      radius,\n      radius2: radius * radius,\n    };\n    return (pointLPS) => pointInSphere(sphereObj, pointLPS);\n  }\n  // using circle as a form of ellipse\n  const ellipseObj = {\n    center: center as Types.Point3,\n    xRadius,\n    yRadius,\n    zRadius,\n  };\n\n  const { precalculated } = precalculatePointInEllipse(ellipseObj, {});\n  return precalculated;\n}\n\nconst CIRCLE_STRATEGY = new BrushStrategy(\n  'Circle',\n  compositions.regionFill,\n  compositions.setValue,\n  initializeCircle,\n  compositions.determineSegmentIndex,\n  compositions.preview\n);\n\nconst CIRCLE_THRESHOLD_STRATEGY = new BrushStrategy(\n  'CircleThreshold',\n  compositions.regionFill,\n  compositions.setValue,\n  initializeCircle,\n  compositions.determineSegmentIndex,\n  compositions.dynamicThreshold,\n  compositions.threshold,\n  compositions.preview,\n  compositions.islandRemoval\n);\n\n/**\n * Fill inside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels inside the defined circle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nconst fillInsideCircle = CIRCLE_STRATEGY.strategyFunction;\n\n/**\n * Fill inside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels inside the defined circle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nconst thresholdInsideCircle = CIRCLE_THRESHOLD_STRATEGY.strategyFunction;\n\n/**\n * Fill outside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels outside the  defined circle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nexport function fillOutsideCircle(): void {\n  throw new Error('Not yet implemented');\n}\n\nexport {\n  CIRCLE_STRATEGY,\n  CIRCLE_THRESHOLD_STRATEGY,\n  fillInsideCircle,\n  thresholdInsideCircle,\n  createPointInEllipse as createEllipseInPoint,\n};\n","import type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\ntype Sphere = {\n  center: Types.Point3 | vec3;\n  radius: number;\n  // Square of the radius\n  radius2?: number;\n};\n\n/**\n * Checks if a point is inside a sphere. Note: this is similar to the\n * `pointInEllipse` function, but since we don't need checks for the\n * ellipse's rotation in different views, we can use a simpler equation\n * which would be faster (no if statements).\n *\n * This is safe to call for point in circle as long as you don't call it with\n * anything off-plane - that is, a circle is a degenerate sphere that is\n * intersected with the primary plane.\n *\n * @param sphere - Sphere object with center and radius and radius squared\n *     as radius2 if you are calling this a huge number of times.\n * @param pointLPS - the point to check in world coordinates\n * @returns boolean\n */\nexport default function pointInSphere(sphere: Sphere, pointLPS: vec3): boolean {\n  const { center, radius } = sphere;\n  const radius2 = sphere.radius2 || radius * radius;\n\n  return (\n    (pointLPS[0] - center[0]) * (pointLPS[0] - center[0]) +\n      (pointLPS[1] - center[1]) * (pointLPS[1] - center[1]) +\n      (pointLPS[2] - center[2]) * (pointLPS[2] - center[2]) <=\n    radius2\n  );\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nimport BrushStrategy from './BrushStrategy';\nimport type { InitializedOperationData, Composition } from './BrushStrategy';\nimport compositions from './compositions';\nimport StrategyCallbacks from '../../../enums/StrategyCallbacks';\nimport { createEllipseInPoint } from './fillCircle';\nconst { transformWorldToIndex } = csUtils;\nimport { getSphereBoundsInfo } from '../../../utilities/getSphereBoundsInfo';\nconst sphereComposition = {\n  [StrategyCallbacks.Initialize]: (operationData: InitializedOperationData) => {\n    const {\n      points,\n      imageVoxelManager: imageVoxelManager,\n      viewport,\n      segmentationImageData,\n      segmentationVoxelManager: segmentationVoxelManager,\n    } = operationData;\n\n    // Happens on a preview setup\n    if (!points) {\n      return;\n    }\n    // Average the points to get the center of the ellipse\n    const center = vec3.fromValues(0, 0, 0);\n    points.forEach((point) => {\n      vec3.add(center, center, point);\n    });\n    vec3.scale(center, center, 1 / points.length);\n\n    operationData.centerWorld = center as Types.Point3;\n    operationData.centerIJK = transformWorldToIndex(\n      segmentationImageData,\n      center as Types.Point3\n    );\n\n    const {\n      boundsIJK: newBoundsIJK,\n      topLeftWorld,\n      bottomRightWorld,\n    } = getSphereBoundsInfo(\n      points.slice(0, 2) as [Types.Point3, Types.Point3],\n      segmentationImageData,\n      viewport\n    );\n\n    segmentationVoxelManager.boundsIJK = newBoundsIJK;\n\n    imageVoxelManager.isInObject = createEllipseInPoint({\n      topLeftWorld,\n      bottomRightWorld,\n      center,\n    });\n  },\n} as Composition;\n\nconst SPHERE_STRATEGY = new BrushStrategy(\n  'Sphere',\n  compositions.regionFill,\n  compositions.setValue,\n  sphereComposition,\n  compositions.determineSegmentIndex,\n  compositions.preview\n);\n\n/**\n * Fill inside a sphere with the given segment index in the given operation data. The\n * operation data contains the sphere required points.\n * @param enabledElement - The element that is enabled and selected.\n * @param operationData - OperationData\n */\nconst fillInsideSphere = SPHERE_STRATEGY.strategyFunction;\n\nconst SPHERE_THRESHOLD_STRATEGY = new BrushStrategy(\n  'SphereThreshold',\n  ...SPHERE_STRATEGY.compositions,\n  compositions.dynamicThreshold,\n  compositions.threshold,\n  compositions.islandRemoval\n);\n\n/**\n * Fill inside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels inside the defined circle.\n * @param enabledElement - The element for which the segment is being filled.\n * @param operationData - EraseOperationData\n */\n\nconst thresholdInsideSphere = SPHERE_THRESHOLD_STRATEGY.strategyFunction;\n\n/**\n * Fill outside a sphere with the given segment index in the given operation data. The\n * operation data contains the sphere required points.\n * @param enabledElement - The element that is enabled and selected.\n * @param operationData - OperationData\n */\nexport function fillOutsideSphere(): void {\n  throw new Error('fill outside sphere not implemented');\n}\n\nexport { fillInsideSphere, thresholdInsideSphere, SPHERE_STRATEGY };\n","import BrushStrategy from './BrushStrategy';\nimport { SPHERE_STRATEGY } from './fillSphere';\nimport compositions from './compositions';\n\nconst ERASE_SPHERE_STRATEGY = new BrushStrategy(\n  'EraseSphere',\n  compositions.erase,\n  ...SPHERE_STRATEGY.compositions\n);\n\nconst eraseInsideSphere = ERASE_SPHERE_STRATEGY.strategyFunction;\n\nexport { eraseInsideSphere };\n","import BrushStrategy from './BrushStrategy';\nimport { CIRCLE_STRATEGY } from './fillCircle';\nimport compositions from './compositions';\n\nconst ERASE_CIRCLE_STRATEGY = new BrushStrategy(\n  'EraseCircle',\n  compositions.erase,\n  ...CIRCLE_STRATEGY.compositions\n);\n\nconst eraseInsideCircle = ERASE_CIRCLE_STRATEGY.strategyFunction;\n\nexport { eraseInsideCircle };\n","import { ToolGroupSpecificRepresentation } from '../../types/SegmentationStateTypes';\nimport {\n  getDefaultSegmentationStateManager,\n  getSegmentation,\n} from './segmentationState';\nimport { triggerSegmentationRepresentationModified } from './triggerSegmentationEvents';\n\n/**\n * Get the active segmentation representation for the tool group with\n * the given toolGroupId.\n * @param toolGroupId - The Id of the tool group\n * @returns The active segmentation representation for the tool group.\n */\nfunction getActiveSegmentationRepresentation(\n  toolGroupId: string\n): ToolGroupSpecificRepresentation {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  const toolGroupSegmentationRepresentations =\n    segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n\n  if (!toolGroupSegmentationRepresentations) {\n    return;\n  }\n\n  const activeRepresentation = toolGroupSegmentationRepresentations.find(\n    (representation) => representation.active\n  );\n\n  return activeRepresentation;\n}\n\n/**\n * Retrieves the active segmentation for a given tool group.\n * @param toolGroupId - The ID of the tool group.\n * @returns The active segmentation Id, or undefined if no active segmentation is found.\n */\nfunction getActiveSegmentation(toolGroupId: string) {\n  const activeRepresentation = getActiveSegmentationRepresentation(toolGroupId);\n\n  if (!activeRepresentation) {\n    return;\n  }\n\n  const activeSegmentation = getSegmentation(\n    activeRepresentation.segmentationId\n  );\n\n  return activeSegmentation;\n}\n\n/**\n * Set the active segmentation for the given tool group for all its viewports\n *\n * @param toolGroupId - The Id of the tool group to set the active\n * segmentation for.\n * @param segmentationRepresentationUID - The id of the segmentation representation to set as\n * active.\n */\nfunction setActiveSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  segmentationStateManager.setActiveSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nexport {\n  // get\n  getActiveSegmentationRepresentation,\n  getActiveSegmentation,\n  // set\n  setActiveSegmentationRepresentation,\n};\n","import { getActiveSegmentationRepresentation } from './activeSegmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\n\n/**\n * Get the locked status for a segment index in a segmentation\n * @param segmentationId - The id of the segmentation that the segment\n * belongs to.\n * @param segmentIndex - The index of the segment\n * @returns A boolean value indicating whether the segment is locked or not.\n */\nfunction isSegmentIndexLocked(\n  segmentationId: string,\n  segmentIndex: number\n): boolean {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n  return segmentsLocked.has(segmentIndex);\n}\n\n/**\n * Set the locked status of a segment index in a segmentation\n * @param segmentationId - The id of the segmentation whose segment\n * index is being modified.\n * @param segmentIndex - The index of the segment to lock/unlock.\n */\nfunction setSegmentIndexLocked(\n  segmentationId: string,\n  segmentIndex: number,\n  locked = true\n): void {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n\n  if (locked) {\n    segmentsLocked.add(segmentIndex);\n  } else {\n    segmentsLocked.delete(segmentIndex);\n  }\n\n  triggerSegmentationModified(segmentationId);\n}\n\n/**\n * Get the locked segments for a segmentation\n * @param segmentationId - The id of the segmentation to get locked\n * segments for.\n * @returns An array of locked segment indices.\n */\nfunction getLockedSegments(segmentationId: string): number[] | [] {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n  return Array.from(segmentsLocked);\n}\n\nexport { isSegmentIndexLocked, setSegmentIndexLocked, getLockedSegments };\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport getBrushToolInstances from './utilities';\n\n/**\n * Invalidates the brush cursor for a specific tool group.\n * This function triggers the update of the brush being rendered.\n * It also triggers an annotation render for any viewports on the tool group.\n *\n * @param toolGroupId - The ID of the tool group.\n */\nexport function invalidateBrushCursor(toolGroupId: string): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n\n  brushBasedToolInstances.forEach((tool: BrushTool) => {\n    // Invalidate the brush being rendered so it can update.\n    tool.invalidateBrushCursor();\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  const viewportsInfoArray = Object.keys(viewportsInfo).map(\n    (key) => viewportsInfo[key]\n  );\n\n  if (!viewportsInfoArray.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfoArray[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n","import { invalidateBrushCursor } from '../../utilities/segmentation/';\nimport {\n  getSegmentation,\n  getToolGroupIdsWithSegmentation,\n} from './segmentationState';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\n\n/**\n * Set the active segment index for a segmentation Id. It fires a global state\n * modified event. Also it invalidates the brush cursor for all toolGroups that\n * has the segmentationId as active segment (since the brush cursor color\n * should change as well)\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param segmentationId - The id of the segmentation that the segment belongs to.\n * @param segmentIndex - The index of the segment to be activated.\n */\nfunction setActiveSegmentIndex(\n  segmentationId: string,\n  segmentIndex: number\n): void {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (segmentation?.activeSegmentIndex !== segmentIndex) {\n    segmentation.activeSegmentIndex = segmentIndex;\n\n    triggerSegmentationModified(segmentationId);\n  }\n\n  // get all toolGroups that has the segmentationId as active\n  // segment and call invalidateBrushCursor on them\n  const toolGroups = getToolGroupIdsWithSegmentation(segmentationId);\n  toolGroups.forEach((toolGroupId) => {\n    invalidateBrushCursor(toolGroupId);\n  });\n}\n\n/**\n * Get the active segment index for a segmentation in the global state\n * @param segmentationId - The id of the segmentation to get the active segment index from.\n * @returns The active segment index for the given segmentation.\n */\nfunction getActiveSegmentIndex(segmentationId: string): number | undefined {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (segmentation) {\n    return segmentation.activeSegmentIndex;\n  }\n}\n\nexport { getActiveSegmentIndex, setActiveSegmentIndex };\n","import { utilities as csUtils, getEnabledElement } from '@cornerstonejs/core';\nimport { vec3, vec2 } from 'gl-matrix';\n\nimport type { Types } from '@cornerstonejs/core';\nimport type {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { BaseTool } from '../base';\nimport {\n  fillInsideSphere,\n  thresholdInsideSphere,\n} from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport {\n  thresholdInsideCircle,\n  fillInsideCircle,\n} from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport {\n  Events,\n  ToolModes,\n  SegmentationRepresentations,\n  StrategyCallbacks,\n} from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  state as segmentationState,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\nimport {\n  LabelmapSegmentationDataVolume,\n  LabelmapSegmentationDataStack,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\n/**\n * A type for preview data/information, used to setup previews on hover, or\n * maintain the preview information.\n */\nexport type PreviewData = {\n  /**\n   *  The preview data returned from the strategy\n   */\n  preview: unknown;\n  timer?: number;\n  timerStart: number;\n  startPoint: Types.Point2;\n  element: HTMLDivElement;\n  isDrag: boolean;\n};\n\n/**\n * @public\n */\nclass BrushTool extends BaseTool {\n  static toolName;\n  private _editData: {\n    segmentsLocked: number[]; //\n    segmentationRepresentationUID?: string;\n    imageIdReferenceMap?: Map<string, string>;\n    volumeId?: string;\n    referencedVolumeId?: string;\n  } | null;\n  private _hoverData?: {\n    brushCursor: any;\n    segmentationId: string;\n    segmentIndex: number;\n    segmentationRepresentationUID: string;\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    centerCanvas?: Array<number>;\n  };\n\n  private _previewData?: PreviewData = {\n    preview: null,\n    element: null,\n    timerStart: 0,\n    timer: null,\n    startPoint: [NaN, NaN],\n    isDrag: false,\n  };\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE_CIRCLE: fillInsideCircle,\n          ERASE_INSIDE_CIRCLE: eraseInsideCircle,\n          FILL_INSIDE_SPHERE: fillInsideSphere,\n          ERASE_INSIDE_SPHERE: eraseInsideSphere,\n          THRESHOLD_INSIDE_CIRCLE: thresholdInsideCircle,\n          THRESHOLD_INSIDE_SPHERE: thresholdInsideSphere,\n        },\n        strategySpecificConfiguration: {\n          THRESHOLD: {\n            threshold: [-150, -70], // E.g. CT Fat // Only used during threshold strategies.\n          },\n        },\n        defaultStrategy: 'FILL_INSIDE_CIRCLE',\n        activeStrategy: 'FILL_INSIDE_CIRCLE',\n        brushSize: 25,\n        preview: {\n          // Have to enable the preview to use this\n          enabled: false,\n          previewColors: {},\n          // The time before showing a preview\n          previewTimeMs: 250,\n          // The distance to move to show a preview before preview time expired\n          previewMoveDistance: 8,\n          // The distance to drag before being considered a drag rather than click\n          dragMoveDistance: 4,\n          // The time to consider a mouse click a drag when moved less than dragMoveDistance\n          dragTimeMs: 500,\n        },\n        // Whether to show a center circle/position.  Set to null to not show\n        centerRadius: 2,\n        actions: {\n          [StrategyCallbacks.AcceptPreview]: {\n            method: StrategyCallbacks.AcceptPreview,\n            bindings: [\n              {\n                key: 'Enter',\n              },\n            ],\n          },\n          [StrategyCallbacks.RejectPreview]: {\n            method: StrategyCallbacks.RejectPreview,\n            bindings: [\n              {\n                key: 'Escape',\n              },\n            ],\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolPassive = (evt) => {\n    this.disableCursor();\n  };\n\n  onSetToolEnabled = () => {\n    this.disableCursor();\n  };\n\n  onSetToolDisabled = (evt) => {\n    this.disableCursor();\n  };\n\n  private disableCursor() {\n    this._hoverData = undefined;\n    this.rejectPreview();\n  }\n\n  createEditData(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create a segmentation representation before using the brush tool'\n      );\n    }\n\n    const { segmentationId, type, segmentationRepresentationUID } =\n      activeSegmentationRepresentation;\n\n    if (type === SegmentationRepresentations.Contour) {\n      throw new Error('Not implemented yet');\n    }\n\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const { representationData } =\n      segmentationState.getSegmentation(segmentationId);\n\n    const labelmapData =\n      representationData[SegmentationRepresentations.Labelmap];\n\n    if (isVolumeSegmentation(labelmapData)) {\n      const { volumeId } = representationData[\n        type\n      ] as LabelmapSegmentationDataVolume;\n      const actors = viewport.getActors();\n\n      // Note: For tools that need the source data. Assumed to use\n      // First volume actor for now.\n      const firstVolumeActorUID = actors[0].uid;\n\n      return {\n        volumeId,\n        referencedVolumeId: firstVolumeActorUID,\n        segmentsLocked,\n        segmentationRepresentationUID,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      const currentImageId = viewport.getCurrentImageId();\n\n      if (!imageIdReferenceMap.get(currentImageId)) {\n        // if there is no stack segmentation slice for the current image\n        // we should not allow the user to perform any operation\n        return;\n      }\n\n      // here we should identify if we can perform sphere manipulation\n      // for these stack of images, if the metadata is not present\n      // to create a volume or if there are inconsistencies between\n      // the image metadata we should not allow the sphere manipulation\n      // and should throw an error or maybe simply just allow circle manipulation\n      // and not sphere manipulation\n      if (this.configuration.activeStrategy.includes('SPHERE')) {\n        throw new Error(\n          'Sphere manipulation is not supported for stacks of image segmentations yet'\n        );\n        // Todo: add sphere (volumetric) manipulation support for stacks of images\n        // we should basically check if the stack constructs a valid volume\n        // meaning all the metadata is present and consistent\n        // then we use a VoxelManager mapping to map a volume like appearance\n        // for the stack data.\n        // csUtils.isValidVolume(referencedImageIds\n      }\n\n      return {\n        imageIdReferenceMap,\n        segmentsLocked,\n        segmentationRepresentationUID,\n      };\n    }\n  }\n\n  preMouseDownCallback = (\n    evt: EventTypes.MouseDownActivateEventType\n  ): boolean => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this._editData = this.createEditData(element);\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    // This might be a mouse down\n    this._previewData.isDrag = false;\n    this._previewData.timerStart = Date.now();\n\n    const hoverData = this._hoverData || this.createHoverData(element);\n\n    triggerAnnotationRenderForViewportUIDs(\n      renderingEngine,\n      hoverData.viewportIdsToRender\n    );\n\n    this.applyActiveStrategyCallback(\n      enabledElement,\n      this.getOperationData(element),\n      StrategyCallbacks.OnInteractionStart\n    );\n\n    return true;\n  };\n\n  /**\n   * This call will be made when the mouse moves and the tool is active, but\n   * not actually drawing at the moment.\n   * The behavior is:\n   *    1. Update the cursor\n   *    2. Call the active strategy event 'preview' and 'rejectPreview'\n   *       on the mouse cursor position on a periodic basis to create a preview\n   *       when configured to do so.\n   *\n   * The preview will be shown after the mouse has been stationary for 250 ms.\n   * Any preview will be cancelled (immediately) after moving outside the center\n   * distance.\n   * As well, if the mouse moves but stays inside the center area for 250 ms,\n   * then the cancel will happen with a new preview being added.\n   *\n   * See mouse up details for how the preview gets accepted.\n   *\n   * The preview also needs to be cancelled on changing tools.\n   */\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\n    if (this.mode === ToolModes.Active) {\n      this.updateCursor(evt);\n      if (!this.configuration.preview.enabled) {\n        return;\n      }\n      const { previewTimeMs, previewMoveDistance, dragMoveDistance } =\n        this.configuration.preview;\n      const { currentPoints, element } = evt.detail;\n      const { canvas } = currentPoints;\n\n      const { preview, startPoint, timer, timerStart, isDrag } =\n        this._previewData;\n      const delta = vec2.distance(canvas, startPoint);\n      const time = Date.now() - timerStart;\n      if (\n        delta > previewMoveDistance ||\n        (time > previewTimeMs && delta > dragMoveDistance)\n      ) {\n        if (timer) {\n          window.clearTimeout(timer);\n          this._previewData.timer = null;\n        }\n        if (preview && !isDrag) {\n          this.rejectPreview(element);\n        }\n      }\n      if (!this._previewData.timer) {\n        const timer = window.setTimeout(this.previewCallback, 250);\n        Object.assign(this._previewData, {\n          timerStart: Date.now(),\n          timer,\n          startPoint: canvas,\n          element,\n        });\n      }\n    }\n  };\n\n  previewCallback = () => {\n    if (this._previewData.preview) {\n      return;\n    }\n    this._previewData.timer = null;\n    this._previewData.preview = this.applyActiveStrategyCallback(\n      getEnabledElement(this._previewData.element),\n      this.getOperationData(this._previewData.element),\n      StrategyCallbacks.Preview\n    );\n  };\n\n  private createHoverData(element, centerCanvas?) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const viewportIdsToRender = [viewport.id];\n\n    const {\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      segmentColor,\n    } = this.getActiveSegmentationData() || {};\n\n    // Center of circle in canvas Coordinates\n    const brushCursor = {\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {},\n    };\n\n    return {\n      brushCursor,\n      centerCanvas,\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      segmentColor,\n      viewportIdsToRender,\n    };\n  }\n\n  private getActiveSegmentationData() {\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      console.warn(\n        'No active segmentation detected, create one before using the brush tool'\n      );\n      return;\n    }\n\n    const { segmentationRepresentationUID, segmentationId } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    return {\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      segmentColor,\n    };\n  }\n\n  /**\n   * Updates the cursor position and whether it is showing or not.\n   * Can be over-ridden to add more cursor details or a preview.\n   */\n  protected updateCursor(evt: EventTypes.InteractionEventType) {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const { currentPoints } = eventData;\n    const centerCanvas = currentPoints.canvas;\n    this._hoverData = this.createHoverData(element, centerCanvas);\n\n    this._calculateCursor(element, centerCanvas);\n\n    if (!this._hoverData) {\n      return;\n    }\n\n    triggerAnnotationRenderForViewportUIDs(\n      getEnabledElement(element).renderingEngine,\n      this._hoverData.viewportIdsToRender\n    );\n  }\n\n  private _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventData = evt.detail;\n    const { element, currentPoints } = eventData;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.updateCursor(evt);\n\n    const { viewportIdsToRender } = this._hoverData;\n\n    triggerAnnotationRenderForViewportUIDs(\n      renderingEngine,\n      viewportIdsToRender\n    );\n\n    const delta = vec2.distance(\n      currentPoints.canvas,\n      this._previewData.startPoint\n    );\n    const { dragTimeMs, dragMoveDistance } = this.configuration.preview;\n    if (\n      !this._previewData.isDrag &&\n      this._previewData.preview &&\n      Date.now() - this._previewData.timerStart < dragTimeMs &&\n      delta < dragMoveDistance\n    ) {\n      // If we are showing a preview, then don't start dragging quite immediately\n      // so that click up can accept the preview.\n      return;\n    }\n\n    this._previewData.preview = this.applyActiveStrategy(\n      enabledElement,\n      this.getOperationData()\n    );\n    this._previewData.element = element;\n    // Add a bit of time to the timer start so small accidental movements dont\n    // cause issues on clicking\n    this._previewData.timerStart = Date.now() + dragTimeMs;\n    this._previewData.isDrag = true;\n    this._previewData.startPoint = currentPoints.canvas;\n  };\n\n  protected getOperationData(element?) {\n    const editData = this._editData || this.createEditData(element);\n\n    const {\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      brushCursor,\n    } = this._hoverData || this.createHoverData(element);\n    const { data, metadata = {} } = brushCursor || {};\n    const { viewPlaneNormal, viewUp } = metadata;\n    const operationData = {\n      ...editData,\n      points: data?.handles?.points,\n      segmentIndex,\n      previewColors: this.configuration.preview.enabled\n        ? this.configuration.preview.previewColors\n        : null,\n      viewPlaneNormal,\n      toolGroupId: this.toolGroupId,\n      segmentationId,\n      segmentationRepresentationUID,\n      viewUp,\n      strategySpecificConfiguration:\n        this.configuration.strategySpecificConfiguration,\n      // Provide the preview information so that data can be used directly\n      preview: this._previewData?.preview,\n    };\n    return operationData;\n  }\n\n  private _calculateCursor(element, centerCanvas) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n    const camera = viewport.getCamera();\n    const { brushSize } = this.configuration;\n\n    const viewUp = vec3.fromValues(\n      camera.viewUp[0],\n      camera.viewUp[1],\n      camera.viewUp[2]\n    );\n    const viewPlaneNormal = vec3.fromValues(\n      camera.viewPlaneNormal[0],\n      camera.viewPlaneNormal[1],\n      camera.viewPlaneNormal[2]\n    );\n    const viewRight = vec3.create();\n\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n    // in the world coordinate system, the brushSize is the radius of the circle\n    // in mm\n    const centerCursorInWorld: Types.Point3 = canvasToWorld([\n      centerCanvas[0],\n      centerCanvas[1],\n    ]);\n\n    const bottomCursorInWorld = vec3.create();\n    const topCursorInWorld = vec3.create();\n    const leftCursorInWorld = vec3.create();\n    const rightCursorInWorld = vec3.create();\n\n    // Calculate the bottom and top points of the circle in world coordinates\n    for (let i = 0; i <= 2; i++) {\n      bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;\n      topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;\n      leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;\n      rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;\n    }\n\n    if (!this._hoverData) {\n      return;\n    }\n\n    const { brushCursor } = this._hoverData;\n    const { data } = brushCursor;\n\n    if (data.handles === undefined) {\n      data.handles = {};\n    }\n\n    data.handles.points = [\n      bottomCursorInWorld,\n      topCursorInWorld,\n      leftCursorInWorld,\n      rightCursorInWorld,\n    ];\n\n    data.invalidated = false;\n  }\n\n  /**\n   * The end callback call is made when the mouse is released.  This will\n   * perform another active strategy render event to render the final position.\n   * As well, the finish strategy callback will be made during this time.\n   */\n  private _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const enabledElement = getEnabledElement(element);\n\n    const operationData = this.getOperationData(element);\n    // Don't re-fill when the preview is showing and the user clicks again\n    // otherwise the new area of hover may get filled, which is unexpected\n    if (!this._previewData.preview && !this._previewData.isDrag) {\n      this.applyActiveStrategy(enabledElement, operationData);\n    }\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    this.updateCursor(evt);\n\n    this._editData = null;\n\n    this.applyActiveStrategyCallback(\n      enabledElement,\n      operationData,\n      StrategyCallbacks.OnInteractionEnd\n    );\n\n    if (!this._previewData.isDrag) {\n      this.acceptPreview(element);\n    }\n  };\n\n  /**\n   * Cancels any preview view being shown, resetting any segments being shown.\n   */\n  public rejectPreview(element = this._previewData.element) {\n    if (!element || !this._previewData.preview) {\n      return;\n    }\n    const enabledElement = getEnabledElement(element);\n    this.applyActiveStrategyCallback(\n      enabledElement,\n      this.getOperationData(element),\n      StrategyCallbacks.RejectPreview\n    );\n    this._previewData.preview = null;\n    this._previewData.isDrag = false;\n  }\n\n  /**\n   * Accepts a preview, marking it as the active segment.\n   */\n  public acceptPreview(element = this._previewData.element) {\n    if (!element) {\n      return;\n    }\n    const enabledElement = getEnabledElement(element);\n\n    this.applyActiveStrategyCallback(\n      enabledElement,\n      this.getOperationData(element),\n      StrategyCallbacks.AcceptPreview\n    );\n    this._previewData.isDrag = false;\n    this._previewData.preview = null;\n  }\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  private _activateDraw = (element: HTMLDivElement): void => {\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  private _deactivateDraw = (element: HTMLDivElement): void => {\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n  };\n\n  public invalidateBrushCursor() {\n    if (this._hoverData === undefined) {\n      return;\n    }\n    const { data } = this._hoverData.brushCursor;\n\n    data.invalidated = true;\n\n    // Todo: figure out if other brush metadata (other than segment color) should get updated\n    // during the brush cursor invalidation\n    const { segmentColor } = this.getActiveSegmentationData() || {};\n    this._hoverData.brushCursor.metadata.segmentColor = segmentColor;\n  }\n\n  renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): void {\n    if (!this._hoverData) {\n      return;\n    }\n\n    const { viewport } = enabledElement;\n\n    const viewportIdsToRender = this._hoverData.viewportIdsToRender;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return;\n    }\n\n    const brushCursor = this._hoverData.brushCursor;\n\n    if (brushCursor.data.invalidated === true) {\n      const { centerCanvas } = this._hoverData;\n      const { element } = viewport;\n\n      // This can be set true when changing the brush size programmatically\n      // whilst the cursor is being rendered.\n      this._calculateCursor(element, centerCanvas);\n    }\n\n    const toolMetadata = brushCursor.metadata;\n    if (!toolMetadata) {\n      return;\n    }\n\n    const annotationUID = toolMetadata.brushCursorUID;\n\n    const data = brushCursor.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor?.slice(0, 3) || [0, 0, 0]})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n\n    const { centerRadius } = this.configuration;\n    if (centerRadius >= 0) {\n      const circleUID1 = '1';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID1,\n        center as Types.Point2,\n        2,\n        {\n          color,\n        }\n      );\n    }\n  }\n}\n\nBrushTool.toolName = 'Brush';\nexport default BrushTool;\n","import { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\n\nexport type ThresholdInformation = {\n  volume: Types.IImageVolume;\n  lower: number;\n  upper: number;\n};\n\nexport default function getBrushToolInstances(\n  toolGroupId: string,\n  toolName?: string\n) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  if (toolName && toolInstances[toolName]) {\n    return [toolInstances[toolName]];\n  }\n\n  // For each tool that has BrushTool as base class, set the brush size.\n  const brushBasedToolInstances = Object.values(toolInstances).filter(\n    (toolInstance) => toolInstance instanceof BrushTool\n  ) as BrushTool[];\n\n  return brushBasedToolInstances;\n}\n\nconst equalsCheck = (a, b) => {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\n/**\n * Given the center of a voxel in world coordinates, calculate the voxel\n * corners in world coords to calculate the voxel overlap in another volume\n */\nexport function getVoxelOverlap(\n  imageData,\n  dimensions,\n  voxelSpacing,\n  voxelCenter\n) {\n  const voxelCornersWorld = [];\n  for (let i = 0; i < 2; i++) {\n    for (let j = 0; j < 2; j++) {\n      for (let k = 0; k < 2; k++) {\n        const point = [...voxelCenter]; // Create a new point from voxelCenter\n        point[0] = point[0] + ((i * 2 - 1) * voxelSpacing[0]) / 2;\n        point[1] = point[1] + ((j * 2 - 1) * voxelSpacing[1]) / 2;\n        point[2] = point[2] + ((k * 2 - 1) * voxelSpacing[2]) / 2;\n        voxelCornersWorld.push(point);\n      }\n    }\n  }\n  const voxelCornersIJK = voxelCornersWorld.map(\n    (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\n  );\n  const overlapBounds = getBoundingBoxAroundShapeIJK(\n    voxelCornersIJK,\n    dimensions\n  );\n\n  return overlapBounds;\n}\n\n/**\n * Prepare a list of volume information objects for callback functions\n */\nexport function processVolumes(\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[]\n) {\n  const { spacing: segmentationSpacing } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n\n  // prepare a list of volume information objects for callback functions\n  const volumeInfoList = [];\n  let baseVolumeIdx = 0;\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n    const { imageData, spacing, dimensions } =\n      thresholdVolumeInformation[i].volume;\n\n    const volumeSize =\n      thresholdVolumeInformation[i].volume.getScalarData().length;\n    // discover the index of the volume the segmentation data is based on\n    if (\n      volumeSize === scalarData.length &&\n      equalsCheck(spacing, segmentationSpacing)\n    ) {\n      baseVolumeIdx = i;\n    }\n\n    // prepare information used in callback functions\n    const referenceValues = imageData.getPointData().getScalars().getData();\n    const lower = thresholdVolumeInformation[i].lower;\n    const upper = thresholdVolumeInformation[i].upper;\n\n    volumeInfoList.push({\n      imageData,\n      referenceValues,\n      lower,\n      upper,\n      spacing,\n      dimensions,\n      volumeSize,\n    });\n  }\n\n  return {\n    volumeInfoList,\n    baseVolumeIdx,\n  };\n}\n","import { Types } from '@cornerstonejs/core';\nimport { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { BoundsIJK } from '../../types';\nimport {\n  getVoxelOverlap,\n  processVolumes,\n  ThresholdInformation,\n} from './utilities';\n\nexport type ThresholdRangeOptions = {\n  overwrite: boolean;\n  boundsIJK: BoundsIJK;\n  overlapType?: number;\n};\n\n/**\n * It thresholds a segmentation volume based on a set of threshold values with\n * respect to a list of volumes and respective threshold ranges.\n * @param segmentationVolume - the segmentation volume to be modified\n * @param thresholdVolumeInformation - array of objects containing volume data\n * and a range (lower and upper values) to threshold\n * @param options - the options for thresholding\n * As there is a chance the volumes might have different dimensions and spacing,\n * could be the case of no 1 to 1 mapping. So we need to work with the idea of\n * voxel overlaps (1 to many mappings). We consider all intersections valid, to\n * avoid the complexity to calculate a minimum voxel intersection percentage.\n * This function, given a voxel center and spacing, calculates the overlap of\n * the voxel with another volume and range check the voxels in the overlap.\n * Three situations can occur: all voxels pass the range check, some voxels pass\n * or none voxels pass. The overlapType parameter indicates if the user requires\n * all voxels pass (overlapType = 1) or any voxel pass (overlapType = 0)\n *\n * @returns segmented volume\n */\nfunction thresholdVolumeByRange(\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[],\n  options: ThresholdRangeOptions\n): Types.IImageVolume {\n  const { imageData: segmentationImageData } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n\n  const { overwrite, boundsIJK } = options;\n  const overlapType = options?.overlapType || 0;\n\n  // set the segmentation to all zeros\n  if (overwrite) {\n    for (let i = 0; i < scalarData.length; i++) {\n      scalarData[i] = 0;\n    }\n  }\n\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\n    segmentationVolume,\n    thresholdVolumeInformation\n  );\n\n  // global variables used in callbackOverlap function\n  let overlaps, total, range;\n\n  const testOverlapRange = (volumeInfo, voxelSpacing, voxelCenter) => {\n    /**\n     * This callback function will test all overlaps between a voxel in base\n     * volume (the reference for segmentation volume creation) and voxels in other\n     * volumes.\n     */\n    const callbackOverlap = ({ value }) => {\n      total = total + 1;\n      if (value >= range.lower && value <= range.upper) {\n        overlaps = overlaps + 1;\n      }\n    };\n\n    const { imageData, dimensions, lower, upper } = volumeInfo;\n\n    const overlapBounds = getVoxelOverlap(\n      imageData,\n      dimensions,\n      voxelSpacing,\n      voxelCenter\n    );\n\n    // reset global variables and setting the range check\n    total = 0;\n    overlaps = 0;\n    range = { lower, upper };\n\n    let overlapTest = false;\n\n    // check all voxel overlaps\n    pointInShapeCallback(imageData, () => true, callbackOverlap, overlapBounds);\n\n    if (overlapType === 0) {\n      overlapTest = overlaps > 0; // any voxel overlap is accepted\n    } else if (overlapType == 1) {\n      overlapTest = overlaps === total; // require all voxel overlaps\n    }\n    return overlapTest;\n  };\n\n  // range checks a voxel in a volume with same dimension as the segmentation\n  const testRange = (volumeInfo, pointIJK) => {\n    const { imageData, referenceValues, lower, upper } = volumeInfo;\n    const offset = imageData.computeOffsetIndex(pointIJK);\n\n    const value = referenceValues[offset];\n    if (value <= lower || value >= upper) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  /**\n   * This callback function will test all overlaps between a voxel in base\n   * volume (the reference for segmentation volume creation) and voxels in other\n   * volumes.\n   */\n  const callback = ({ index, pointIJK, pointLPS }) => {\n    let insert = volumeInfoList.length > 0;\n    for (let i = 0; i < volumeInfoList.length; i++) {\n      // if volume has the same size as segmentation volume, just range check\n      if (volumeInfoList[i].volumeSize === scalarData.length) {\n        insert = testRange(volumeInfoList[i], pointIJK);\n      } else {\n        // if not, need to calculate overlaps\n        insert = testOverlapRange(\n          volumeInfoList[i],\n          volumeInfoList[baseVolumeIdx].spacing,\n          pointLPS\n        );\n      }\n      if (!insert) {\n        break;\n      }\n    }\n\n    // Todo: make the segmentIndex a parameter\n    if (insert) {\n      scalarData[index] = 1;\n    }\n  };\n\n  pointInShapeCallback(segmentationImageData, () => true, callback, boundsIJK);\n\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n\n  return segmentationVolume;\n}\n\nexport default thresholdVolumeByRange;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Given an array of viewports, returns a list of viewports that are viewing a\n * world space with the given `FrameOfReferenceUID`.\n *\n * @param viewports - An array of viewports.\n * @param FrameOfReferenceUID - The UID defining a particular world space/Frame Of Reference.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithFrameOfReferenceUID(\n  viewports: Array<Types.IViewport>,\n  FrameOfReferenceUID: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n  const viewportsWithFrameOfReferenceUID = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {\n      viewportsWithFrameOfReferenceUID.push(viewport);\n    }\n  }\n\n  return viewportsWithFrameOfReferenceUID;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { IToolGroup } from '../../types';\nimport { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * Given an array of viewports, returns a list of viewports that have the the specified tool enabled.\n *\n * @param viewports - An array of viewports.\n * @param toolName - The name of the tool to filter on.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithToolEnabled(\n  viewports: Array<Types.IViewport>,\n  toolName: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n\n  const viewportsWithToolEnabled = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n      viewport.id,\n      viewport.renderingEngineId\n    );\n\n    if (!toolGroup) {\n      continue;\n    }\n\n    const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(\n      toolGroup,\n      toolName\n    );\n\n    if (hasTool) {\n      viewportsWithToolEnabled.push(viewport);\n    }\n  }\n\n  return viewportsWithToolEnabled;\n}\n\n/**\n * Given a toolGroup, return true if it contains the tool with the given `toolName` and it is\n * active, passive or enabled.\n *\n * @param toolGroup - The `toolGroup` to check.\n * @param toolName - The name of the tool.\n *\n * @returns True if the tool is enabled, passive or active in the `toolGroup`.\n */\nfunction _toolGroupHasActiveEnabledOrPassiveTool(\n  toolGroup: IToolGroup,\n  toolName: string\n) {\n  const { toolOptions } = toolGroup;\n  const tool = toolOptions[toolName];\n\n  if (!tool) {\n    return false;\n  }\n\n  const toolMode = tool.mode;\n\n  return toolMode === Active || toolMode === Passive || toolMode === Enabled;\n}\n","import { vec3 } from 'gl-matrix';\n\n/**\n * It filters the viewports that are looking in the same view as the camera\n * It basically checks if the viewPlaneNormal is parallel to the camera viewPlaneNormal\n * @param viewports - Array of viewports to filter\n * @param camera - Camera to compare against\n * @returns - Array of viewports with the same view\n */\nexport function filterViewportsWithParallelNormals(\n  viewports,\n  camera,\n  EPS = 0.999\n) {\n  return viewports.filter((viewport) => {\n    const vpCamera = viewport.getCamera();\n\n    const isParallel =\n      Math.abs(vec3.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) >\n      EPS;\n\n    return isParallel;\n  });\n}\n\nexport default filterViewportsWithParallelNormals;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\n\n/**\n * Given a cornerstone3D enabled `element`, and a `toolName`, find all viewportIds\n * looking at the same Frame Of Reference that have the tool with the given `toolName`\n * active, passive or enabled.\n *\n * @param element - The target cornerstone3D enabled element.\n * @param toolName - The string toolName.\n * @param requireParallelNormals - If true, only return viewports that have parallel normals.\n *\n * @returns An array of viewportIds.\n */\nexport default function getViewportIdsWithToolToRender(\n  element: HTMLDivElement,\n  toolName: string,\n  requireParallelNormals = true\n): string[] {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, FrameOfReferenceUID } = enabledElement;\n\n  let viewports = renderingEngine.getViewports();\n\n  viewports = filterViewportsWithFrameOfReferenceUID(\n    viewports,\n    FrameOfReferenceUID\n  );\n  viewports = filterViewportsWithToolEnabled(viewports, toolName);\n\n  const viewport = renderingEngine.getViewport(enabledElement.viewportId);\n\n  if (requireParallelNormals) {\n    viewports = filterViewportsWithParallelNormals(\n      viewports,\n      viewport.getCamera()\n    );\n  }\n\n  const viewportIds = viewports.map((vp) => vp.id);\n\n  return viewportIds;\n}\n","import { vec3 } from 'gl-matrix';\nimport { CONSTANTS, metaData } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { Annotations, Annotation } from '../../types';\nimport { debug } from 'console';\n\nconst { EPSILON } = CONSTANTS;\n\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\n\n/**\n * given some `Annotations`, and the slice defined by the camera's normal\n * direction and the spacing in the normal, filter the `Annotations` which\n * is within the slice.\n *\n * @param annotations - Annotations\n * @param camera - The camera\n * @param spacingInNormalDirection - The spacing in the normal direction\n * @returns The filtered `Annotations`.\n */\nexport default function filterAnnotationsWithinSlice(\n  annotations: Annotations,\n  camera: Types.ICamera,\n  spacingInNormalDirection: number\n): Annotations {\n  const { viewPlaneNormal } = camera;\n\n  // The reason we use parallel normals instead of actual orientation is that\n  // flipped action is done through camera API, so we can't rely on the\n  // orientation (viewplaneNormal and viewUp) since even the same image and\n  // same slice if flipped will have different orientation, but still rendering\n  // the same slice. Instead, we choose to use the parallel normals to filter\n  // the annotations and later we fine tune it with the annotation within slice\n  // logic down below.\n  const annotationsWithParallelNormals = annotations.filter(\n    (td: Annotation) => {\n      let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n\n      if (!annotationViewPlaneNormal) {\n        // This code is run to set the annotation view plane normal\n        // for historical data which was saved without the normal.\n        const { referencedImageId } = td.metadata;\n        const { imageOrientationPatient } = metaData.get(\n          'imagePlaneModule',\n          referencedImageId\n        );\n        const rowCosineVec = vec3.fromValues(\n          imageOrientationPatient[0],\n          imageOrientationPatient[1],\n          imageOrientationPatient[2]\n        );\n\n        const colCosineVec = vec3.fromValues(\n          imageOrientationPatient[3],\n          imageOrientationPatient[4],\n          imageOrientationPatient[5]\n        );\n\n        annotationViewPlaneNormal = vec3.create() as Types.Point3;\n\n        vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n        td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n      }\n      const isParallel =\n        Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n        PARALLEL_THRESHOLD;\n\n      return annotationViewPlaneNormal && isParallel;\n    }\n  );\n\n  // No in plane annotations.\n  if (!annotationsWithParallelNormals.length) {\n    return [];\n  }\n\n  // Annotation should be within the slice, which means that it should be between\n  // camera's focalPoint +/- spacingInNormalDirection.\n\n  const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n  const { focalPoint } = camera;\n\n  const annotationsWithinSlice = [];\n\n  for (const annotation of annotationsWithParallelNormals) {\n    const data = annotation.data;\n    const point = data.handles.points[0];\n\n    if (!annotation.isVisible) {\n      continue;\n    }\n    // A = point\n    // B = focal point\n    // P = normal\n\n    // B-A dot P  => Distance in the view direction.\n    // this should be less than half the slice distance.\n\n    const dir = vec3.create();\n\n    vec3.sub(dir, focalPoint, point);\n\n    const dot = vec3.dot(dir, viewPlaneNormal);\n\n    if (Math.abs(dot) < halfSpacingInNormalDirection) {\n      annotationsWithinSlice.push(annotation);\n    }\n  }\n\n  return annotationsWithinSlice;\n}\n","import {\n  StackViewport,\n  VolumeViewport,\n  VideoViewport,\n  Types,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\n\nimport filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nimport type { Annotations } from '../../types';\nimport annotationFrameRange from '../annotationFrameRange';\n\nconst baseUrlExtractor = /(videoId:|imageId:|volumeId:)([a-zA-Z]*:)/;\n\n/**\n * Given the viewport and the annotations, it filters the annotations array and only\n * return those annotation that should be displayed on the viewport\n * @param annotations - Annotations\n * @returns A filtered version of the annotations.\n */\nexport default function filterAnnotationsForDisplay(\n  viewport: Types.IViewport,\n  annotations: Annotations\n): Annotations {\n  if (viewport instanceof StackViewport) {\n    // 1. Get the currently displayed imageId from the StackViewport\n    const imageId = viewport.getCurrentImageId();\n\n    // 2. remove the dataLoader scheme since it might be an annotation that was\n    // created on the volumeViewport initially and has the volumeLoader scheme\n    // but shares the same imageId\n    const colonIndex = imageId.indexOf(':');\n    const imageURI = imageId.substring(colonIndex + 1);\n\n    // 3. Filter annotation in the frame of reference by the referenced image ID property\n    // Note: With the current implementation drawing on the stack (PT stack) will not\n    // show the annotation on a volume that does not share the same imageURIs (CT Volume),\n    // and we don't have a proper way to check distance either since a stack can be\n    // composed of multiple unrelated images\n    return annotations.filter((annotation) => {\n      if (!annotation.isVisible) {\n        return false;\n      }\n\n      const imageId = annotation.metadata.referencedImageId;\n\n      if (imageId === undefined) {\n        // This annotation was not drawn on a non-coplanar reformat, and such does\n        // not have a referenced imageId.\n        return false;\n      }\n\n      const colonIndex = imageId.indexOf(':');\n      const referenceImageURI = imageId.substring(colonIndex + 1);\n      return referenceImageURI === imageURI;\n    });\n  } else if (viewport instanceof VideoViewport) {\n    const frameOfReferenceUID: string = viewport.getFrameOfReferenceUID();\n\n    return annotations.filter((annotation) => {\n      if (!annotation.isVisible) {\n        return false;\n      }\n      if (annotation.metadata.FrameOfReferenceUID !== frameOfReferenceUID) {\n        return false;\n      }\n      const testURI = annotation.metadata.referencedImageId.replace(\n        baseUrlExtractor,\n        ''\n      );\n\n      if (!viewport.hasImageURI(testURI)) {\n        return false;\n      }\n      const range = annotationFrameRange.getFrameRange(annotation);\n      const frameNumber = viewport.getFrameNumber();\n      if (Array.isArray(range)) {\n        return frameNumber >= range[0] && frameNumber <= range[1];\n      }\n      // Arbitrary 5 frames of slop on the video for matching single frame\n      // number to position - this allows the annotation to display  when\n      // the video element is not exactly the same timing as expected or when\n      // playing video back.\n      return Math.abs(frameNumber - range) <= 5;\n    });\n  } else if (viewport instanceof VolumeViewport) {\n    const camera = viewport.getCamera();\n\n    const { spacingInNormalDirection } =\n      csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n\n    // Get data with same normal and within the same slice\n    return filterAnnotationsWithinSlice(\n      annotations,\n      camera,\n      spacingInNormalDirection\n    );\n  } else {\n    throw new Error(`Viewport Type ${viewport.type} not supported`);\n  }\n}\n","import { Annotation } from '../../../types';\nimport { isAnnotationLocked } from '../annotationLocking';\nimport { isAnnotationSelected } from '../annotationSelection';\nimport { AnnotationStyleStates } from '../../../enums';\n\n/**\n * Given a Annotation object, return the annotationStyle State that it\n * should be in based on its data\n * @param annotation - The annotation that we want to style.\n * @returns The state of the annotation whether it is Default, Highlighted, Locked, or Selected.\n */\nfunction getState(annotation?: Annotation): AnnotationStyleStates {\n  if (annotation) {\n    if (annotation.data && annotation.highlighted) {\n      return AnnotationStyleStates.Highlighted;\n    }\n    if (isAnnotationSelected(annotation.annotationUID)) {\n      return AnnotationStyleStates.Selected;\n    }\n\n    // Todo: make annotation lock api not to rely on the annotation itself\n    if (isAnnotationLocked(annotation)) {\n      return AnnotationStyleStates.Locked;\n    }\n  }\n\n  return AnnotationStyleStates.Default;\n}\n\nexport default getState;\n","import {\n  utilities,\n  getEnabledElement,\n  StackViewport,\n  cache,\n  VideoViewport,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport BaseTool from './BaseTool';\nimport { getAnnotationManager } from '../../stateManagement/annotation/annotationState';\nimport { Annotation, Annotations, SVGDrawingHelper } from '../../types';\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\nimport filterAnnotationsForDisplay from '../../utilities/planar/filterAnnotationsForDisplay';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nimport { getState } from '../../stateManagement/annotation/config';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**\n * Abstract class for tools which create and display annotations on the\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\n * tools that require drawing an annotation before running the segmentation strategy\n * for instance threshold segmentation based on an area and a threshold.\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\n *\n * To create a new annotation tool, derive from this class and implement the\n * abstract methods.\n */\nabstract class AnnotationDisplayTool extends BaseTool {\n  static toolName;\n\n  // ===================================================================\n  // Abstract Methods - Must be implemented.\n  // ===================================================================\n\n  /**\n   * @abstract renderAnnotation it used to draw the tool's annotation in each\n   * request animation frame\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  abstract renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  );\n\n  /**\n   * @virtual Given the element and annotations which is an array of annotation, it\n   * filters the annotations array to only include the annotation based on the viewportType.\n   * If the viewport is StackViewport, it filters based on the current imageId of the viewport,\n   * if the viewport is volumeViewport, it only returns those that are within the\n   * same slice as the current rendered slice in the volume viewport.\n   * imageId as the enabledElement.\n   * @param element - The HTML element\n   * @param annotations - The annotations to filter (array of annotation)\n   * @returns The filtered annotations\n   */\n  filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations | undefined {\n    if (!annotations || !annotations.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    return filterAnnotationsForDisplay(viewport, annotations);\n  }\n\n  /**\n   * On Image Calibration, take all the annotation from the AnnotationState manager,\n   * and invalidate them to force them to be re-rendered and their stats to be recalculated.\n   * Then use the old and new imageData (non-calibrated and calibrated) to calculate the\n   * new position for the annotations in the space of the new imageData.\n   *\n   * @param evt - The calibration event\n   *\n   */\n  public onImageSpacingCalibrated = (\n    evt: Types.EventTypes.ImageSpacingCalibratedEvent\n  ) => {\n    const { element, imageId } = evt.detail;\n\n    const imageURI = utilities.imageIdToURI(imageId);\n    const annotationManager = getAnnotationManager();\n    const framesOfReference = annotationManager.getFramesOfReference();\n\n    // For each frame Of Reference\n    framesOfReference.forEach((frameOfReference) => {\n      const frameOfReferenceSpecificAnnotations =\n        annotationManager.getAnnotations(frameOfReference);\n\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[this.getToolName()];\n\n      if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {\n        return;\n      }\n\n      // for this specific tool\n      toolSpecificAnnotations.forEach((annotation) => {\n        if (!annotation.metadata?.referencedImageId) {\n          return;\n        }\n\n        // if the annotation is drawn on the same imageId\n        const referencedImageURI = utilities.imageIdToURI(\n          annotation.metadata.referencedImageId\n        );\n\n        if (referencedImageURI === imageURI) {\n          // make them invalid since the image has been calibrated so that\n          // we can update the cachedStats and also rendering\n          annotation.invalidated = true;\n          annotation.data.cachedStats = {};\n        }\n      });\n      triggerAnnotationRender(element);\n    });\n  };\n\n  protected getReferencedImageId(\n    viewport: Types.IViewport,\n    worldPos: Types.Point3,\n    viewPlaneNormal: Types.Point3,\n    viewUp: Types.Point3\n  ): string {\n    const targetId = this.getTargetId(viewport);\n\n    let referencedImageId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    } else if (viewport instanceof VideoViewport) {\n      referencedImageId = targetId.split('videoId:')[1];\n    } else {\n      const volumeId = targetId.split('volumeId:')[1];\n      const imageVolume = cache.getVolume(volumeId);\n\n      referencedImageId = utilities.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    return referencedImageId;\n  }\n\n  /**\n   * It takes the property (color, lineDash, etc.) and based on the state of the\n   * annotation (selected, highlighted etc.) it returns the appropriate value\n   * based on the central toolStyle settings for each level of specification.\n   * @param property - The name of the style property to get.\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met (hierarchy is checked from most specific to least specific which is\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n   * @param annotation - The annotation for the tool that is\n   * currently active.\n   * @returns The value of the property.\n   */\n  public getStyle(\n    property: string,\n    specifications: StyleSpecifier,\n    annotation?: Annotation\n  ): unknown {\n    return getStyleProperty(\n      property,\n      specifications,\n      getState(annotation),\n      this.mode\n    );\n  }\n}\n\nAnnotationDisplayTool.toolName = 'AnnotationDisplayTool';\nexport default AnnotationDisplayTool;\n","import {\n  BaseVolumeViewport,\n  cache,\n  getEnabledElement,\n  metaData,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec2 } from 'gl-matrix';\n\nimport AnnotationDisplayTool from './AnnotationDisplayTool';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  Annotation,\n  Annotations,\n  EventTypes,\n  ToolHandle,\n  InteractionTypes,\n  ToolProps,\n  PublicToolProps,\n} from '../../types';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**-q\n * Abstract class for tools which create and display annotations on the\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\n * tools that require drawing an annotation before running the segmentation strategy\n * for instance threshold segmentation based on an area and a threshold.\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\n *\n * To create a new annotation tool, derive from this class and implement the\n * abstract methods.\n */\nabstract class AnnotationTool extends AnnotationDisplayTool {\n  static toolName;\n  // ===================================================================\n  // Abstract Methods - Must be implemented.\n  // ===================================================================\n\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    super(toolProps, defaultToolProps);\n\n    if (toolProps.configuration?.getTextLines) {\n      this.configuration.getTextLines = toolProps.configuration.getTextLines;\n    }\n\n    if (toolProps.configuration?.statsCalculator) {\n      this.configuration.statsCalculator =\n        toolProps.configuration.statsCalculator;\n    }\n  }\n\n  /**\n   * @abstract addNewAnnotation Creates a new annotation based on the clicked mouse position\n   *\n   * @param evt - The normalized mouse event\n   * @param interactionType -  The interaction type used to add the annotation.\n   */\n  abstract addNewAnnotation(\n    evt: EventTypes.InteractionEventType,\n    interactionType: InteractionTypes\n  ): Annotation;\n\n  /**\n   * @abstract cancel Used to cancel the ongoing tool drawing and manipulation\n   *\n   */\n  abstract cancel(element: HTMLDivElement);\n\n  /**\n   * handleSelectedCallback Custom callback for when a handle is selected.\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The annotation selected.\n   * @param handle - The selected handle (either Types.Point3 in space for annotations, or TextBoxHandle object for text boxes).\n   * @param interactionType - The interaction type the handle was selected with.\n   */\n  abstract handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    handle: ToolHandle,\n    interactionType: InteractionTypes\n  ): void;\n\n  /**\n   * Custom callback for when an annotation is selected\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The `Annotation` to check.\n   * @param interactionType - The interaction type used to select the tool.\n   */\n  abstract toolSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes,\n    canvasCoords?: Types.Point2\n  ): void;\n\n  /**\n   * Returns true if the provided canvas coordinate tool is near the annotation\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinate to check\n   * @param proximity - The minimum proximity to consider the point near\n   * @param interactionType - The interaction type used to select the tool.\n   *\n   * @returns boolean if the point is near.\n   */\n  abstract isPointNearTool(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number,\n    interactionType: string\n  ): boolean;\n\n  /**\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\n   *\n   *\n   * @param evt - The normalized mouse event\n   * @param filteredAnnotations - The annotations to check for hover interactions\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\n   */\n  public mouseMoveCallback = (\n    evt: EventTypes.MouseMoveEventType,\n    filteredAnnotations?: Annotations\n  ): boolean => {\n    if (!filteredAnnotations) {\n      return false;\n    }\n\n    const { element, currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n    let annotationsNeedToBeRedrawn = false;\n\n    for (const annotation of filteredAnnotations) {\n      // Do not do anything if the annotation is locked or hidden.\n      if (\n        isAnnotationLocked(annotation) ||\n        !isAnnotationVisible(annotation.annotationUID)\n      ) {\n        continue;\n      }\n\n      const { data } = annotation;\n      const activateHandleIndex = data.handles\n        ? data.handles.activeHandleIndex\n        : undefined;\n\n      // Perform tool specific imagePointNearToolOrHandle to determine if the mouse\n      // is near the tool or its handles or its textBox.\n      const near = this._imagePointNearToolOrHandle(\n        element,\n        annotation,\n        canvasCoords,\n        6 // Todo: This should come from the state\n      );\n\n      const nearToolAndNotMarkedActive = near && !annotation.highlighted;\n      const notNearToolAndMarkedActive = !near && annotation.highlighted;\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n        annotation.highlighted = !annotation.highlighted;\n        annotationsNeedToBeRedrawn = true;\n      } else if (\n        data.handles &&\n        data.handles.activeHandleIndex !== activateHandleIndex\n      ) {\n        // Active handle index has changed, re-render.\n        annotationsNeedToBeRedrawn = true;\n      }\n    }\n\n    return annotationsNeedToBeRedrawn;\n  };\n\n  /**\n   * It checks if the mouse click is near TextBoxHandle or AnnotationHandle itself, and\n   * return either it. It prioritize TextBoxHandle over AnnotationHandle. If\n   * the mouse click is not near any of the handles, it does not return anything.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points, textBox } = data.handles;\n\n    if (textBox) {\n      const { worldBoundingBox } = textBox;\n      if (worldBoundingBox) {\n        const canvasBoundingBox = {\n          topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),\n          topRight: viewport.worldToCanvas(worldBoundingBox.topRight),\n          bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),\n          bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),\n        };\n\n        if (\n          canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&\n          canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&\n          canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&\n          canvasCoords[1] <= canvasBoundingBox.bottomRight[1]\n        ) {\n          data.handles.activeHandleIndex = null;\n          return textBox as ToolHandle;\n        }\n      }\n    }\n\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n\n      const near =\n        vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n\n      if (near === true) {\n        data.handles.activeHandleIndex = i;\n        return point;\n      }\n    }\n\n    data.handles.activeHandleIndex = null;\n  }\n\n  /**\n   * It returns the style for the text box\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met (hierarchy is checked from most specific to least specific which is\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n   * @param annotation - The annotation for the tool that is\n   * currently active.\n   * @returns An object of the style settings for the text box.\n   */\n  public getLinkedTextBoxStyle(\n    specifications: StyleSpecifier,\n    annotation?: Annotation\n  ): Record<string, unknown> {\n    // Todo: this function can be used to set different styles for different toolMode\n    // for the textBox.\n\n    return {\n      visibility: this.getStyle(\n        'textBoxVisibility',\n        specifications,\n        annotation\n      ),\n      fontFamily: this.getStyle(\n        'textBoxFontFamily',\n        specifications,\n        annotation\n      ),\n      fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\n      color: this.getStyle('textBoxColor', specifications, annotation),\n      shadow: this.getStyle('textBoxShadow', specifications, annotation),\n      background: this.getStyle(\n        'textBoxBackground',\n        specifications,\n        annotation\n      ),\n      lineWidth: this.getStyle(\n        'textBoxLinkLineWidth',\n        specifications,\n        annotation\n      ),\n      lineDash: this.getStyle(\n        'textBoxLinkLineDash',\n        specifications,\n        annotation\n      ),\n    };\n  }\n\n  /**\n   * Returns true if the viewport is scaled to SUV units\n   * @param viewport - The viewport\n   * @param targetId - The annotation targetId\n   * @param imageId - The annotation imageId\n   * @returns\n   */\n  isSuvScaled(\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    targetId: string,\n    imageId?: string\n  ): boolean {\n    if (viewport instanceof BaseVolumeViewport) {\n      const volumeId = targetId.split('volumeId:')[1];\n      const volume = cache.getVolume(volumeId);\n      return volume.scaling?.PT !== undefined;\n    }\n    const scalingModule: Types.ScalingParameters | undefined =\n      imageId && metaData.get('scalingModule', imageId);\n    return typeof scalingModule?.suvbw === 'number';\n  }\n\n  /**\n   * Get the style that will be applied to all annotations such as length, cobb\n   * angle, arrow annotate, etc. when rendered on a canvas or svg layer\n   */\n  protected getAnnotationStyle(context: {\n    annotation: Annotation;\n    styleSpecifier: StyleSpecifier;\n  }) {\n    const { annotation, styleSpecifier } = context;\n    const getStyle = (property) =>\n      this.getStyle(property, styleSpecifier, annotation);\n    const { annotationUID } = annotation;\n    const visibility = isAnnotationVisible(annotationUID);\n    const locked = isAnnotationLocked(annotation);\n\n    const lineWidth = getStyle('lineWidth') as number;\n    const lineDash = getStyle('lineDash') as string;\n    const color = getStyle('color') as string;\n    const shadow = getStyle('shadow') as boolean;\n    const textboxStyle = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n\n    return {\n      visibility,\n      locked,\n      color,\n      lineWidth,\n      lineDash,\n      lineOpacity: 1,\n      fillColor: color,\n      fillOpacity: 0,\n      shadow,\n      textbox: textboxStyle,\n    };\n  }\n\n  /**\n   * Returns true if the `canvasCoords` are near a handle or selectable part of the tool\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinates to check\n   * @param proximity - The proximity to consider\n   *\n   * @returns If the point is near.\n   */\n  private _imagePointNearToolOrHandle(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean {\n    // Based on the tool instance type, check if the point is near the tool handles\n    const handleNearImagePoint = this.getHandleNearImagePoint(\n      element,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (handleNearImagePoint) {\n      return true;\n    }\n\n    // If the point is not near the handles, check if the point is near the tool\n    const toolNewImagePoint = this.isPointNearTool(\n      element,\n      annotation,\n      canvasCoords,\n      proximity,\n      'mouse'\n    );\n\n    if (toolNewImagePoint) {\n      return true;\n    }\n  }\n}\n\nAnnotationTool.toolName = 'AnnotationTool';\nexport default AnnotationTool;\n","import type { Types } from '@cornerstonejs/core';\n\ntype Point = Types.Point2 | Types.Point3;\n\n/**\n * Calculates the distance squared of a point to another point\n *\n * @param p1 - x,y or x,y,z of the point\n * @param p2 - x,y or x,y,z of the point\n * @returns distance\n */\nexport default function distanceToPointSquared(p1: Point, p2: Point): number {\n  if (p1.length !== p2.length) {\n    throw Error('Both points should have the same dimensionality');\n  }\n\n  const [x1, y1, z1 = 0] = p1;\n  const [x2, y2, z2 = 0] = p2;\n\n  return Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2) + Math.pow(z1 - z2, 2);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as math from '../';\n\n/**\n * Calculate the closest point and the squared distance between a reference point and a line segment.\n *\n * It projects the reference point onto the line segment but it shall be bounded by the\n * start/end points since this is a line segment and not a line which could be extended.\n *\n * @param lineStart - Start point of the line segment\n * @param lineEnd - End point of the line segment\n * @param point - Reference point\n * @returns Closest point and the squared distance between a `point` and a line\n *   segment defined by `lineStart` and `lineEnd` points\n */\nexport default function distanceToPointSquaredInfo(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): {\n  point: Types.Point2;\n  distanceSquared: number;\n} {\n  let closestPoint: Types.Point2;\n  const distanceSquared = math.point.distanceToPointSquared(lineStart, lineEnd);\n\n  // Check if lineStart is the same as lineEnd which means\n  if (lineStart[0] === lineEnd[0] && lineStart[1] === lineEnd[1]) {\n    closestPoint = lineStart;\n  }\n\n  if (!closestPoint) {\n    const dotProduct =\n      ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) +\n        (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) /\n      distanceSquared;\n\n    if (dotProduct < 0) {\n      closestPoint = lineStart;\n    } else if (dotProduct > 1) {\n      closestPoint = lineEnd;\n    } else {\n      closestPoint = [\n        lineStart[0] + dotProduct * (lineEnd[0] - lineStart[0]),\n        lineStart[1] + dotProduct * (lineEnd[1] - lineStart[1]),\n      ];\n    }\n  }\n\n  return {\n    point: [...closestPoint],\n    distanceSquared: math.point.distanceToPointSquared(point, closestPoint),\n  };\n}\n","import { Types } from '@cornerstonejs/core';\nimport distanceToPointSquaredInfo from './distanceToPointSquaredInfo';\n\n/**\n * Calculates the distance-squared of a point to a line segment\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance-squared\n */\nexport default function distanceToPointSquared(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  return distanceToPointSquaredInfo(lineStart, lineEnd, point).distanceSquared;\n}\n","import distanceToPointSquared from './distanceToPointSquared';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the distance of a point to a line\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance\n */\nexport default function distanceToPoint(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {\n    throw Error(\n      'lineStart, lineEnd, and point should have 2 elements of [x, y]'\n    );\n  }\n\n  return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as lineSegment from '../line';\n\ntype rectLineSegments = {\n  top: Types.Point2[];\n  right: Types.Point2[];\n  bottom: Types.Point2[];\n  left: Types.Point2[];\n};\n\n/**\n * Given a rectangle left, top, width and height, return an object containing the\n * line segments that make up the rectangle's four sides\n * @param left - The x-coordinate of the left edge of the rectangle.\n * @param top - The y-coordinate of the top edge of the rectangle.\n * @param width - The width of the rectangle.\n * @param height - The height of the rectangle.\n * @returns An object with four keys, each of which contains an array of two\n * points.\n */\nfunction rectToLineSegments(\n  left: number,\n  top: number,\n  width: number,\n  height: number\n): rectLineSegments {\n  const topLineStart: Types.Point2 = [left, top];\n  const topLineEnd: Types.Point2 = [left + width, top];\n\n  const rightLineStart: Types.Point2 = [left + width, top];\n  const rightLineEnd: Types.Point2 = [left + width, top + height];\n\n  const bottomLineStart: Types.Point2 = [left + width, top + height];\n  const bottomLineEnd: Types.Point2 = [left, top + height];\n\n  const leftLineStart: Types.Point2 = [left, top + height];\n  const leftLineEnd: Types.Point2 = [left, top];\n\n  const lineSegments = {\n    top: [topLineStart, topLineEnd],\n    right: [rightLineStart, rightLineEnd],\n    bottom: [bottomLineStart, bottomLineEnd],\n    left: [leftLineStart, leftLineEnd],\n  };\n\n  return lineSegments;\n}\n\n/**\n * Calculates distance of the point to the rectangle. It calculates the minimum\n * distance between the point and each line segment of the rectangle.\n *\n * @param rect - coordinates of the rectangle [left, top, width, height]\n * @param point - [x,y] coordinates of a point\n * @returns\n */\nexport default function distanceToPoint(\n  rect: number[],\n  point: Types.Point2\n): number {\n  if (rect.length !== 4 || point.length !== 2) {\n    throw Error(\n      'rectangle:[left, top, width, height] or point: [x,y] not defined correctly'\n    );\n  }\n\n  const [left, top, width, height] = rect;\n\n  let minDistance = 655535;\n  const lineSegments = rectToLineSegments(left, top, width, height);\n\n  Object.keys(lineSegments).forEach((segment) => {\n    const [lineStart, lineEnd] = lineSegments[segment];\n    const distance = lineSegment.distanceToPoint(lineStart, lineEnd, point);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n    }\n  });\n\n  return minDistance;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Determine the coordinates that will place the textbox to the right of the\n * annotation.\n *\n * @param annotationCanvasPoints - The canvas points of the annotation's handles.\n * @returns - The coordinates for default placement of the textbox.\n */\nexport default function getTextBoxCoordsCanvas(\n  annotationCanvasPoints: Array<Types.Point2>\n): Types.Point2 {\n  const corners = _determineCorners(annotationCanvasPoints);\n  const centerY = (corners.top[1] + corners.bottom[1]) / 2;\n  const textBoxCanvas = <Types.Point2>[corners.right[0], centerY];\n\n  return textBoxCanvas;\n}\n\n/**\n * Determine the handles that have the min/max x and y values.\n *\n * @param canvasPoints - The canvas points of the annotation's handles.\n * @returns - The top, left, bottom, and right handles.\n */\nfunction _determineCorners(canvasPoints: Array<Types.Point2>) {\n  const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);\n  const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);\n  const right = handlesLeftToRight[handlesLeftToRight.length - 1];\n  const top = handlesTopToBottom[0];\n  const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];\n\n  return {\n    top,\n    bottom,\n    right,\n  };\n\n  function _compareX(a, b) {\n    return a[0] < b[0] ? -1 : 1;\n  }\n  function _compareY(a, b) {\n    return a[1] < b[1] ? -1 : 1;\n  }\n}\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Given two world positions and an orthogonal view to an `imageVolume` defined\n * by a `viewPlaneNormal` and a `viewUp`, get the width and height in world coordinates\n * of the rectangle defined by the two points. The implementation works both with orthogonal\n * non-orthogonal rectangles.\n *\n * @param viewPlaneNormal - The normal of the view.\n * @param viewUp - The up direction of the view.\n * @param imageVolume - The imageVolume to use to measure.\n * @param topLeftWorld - The first world position.\n * @param bottomRightWorld - The second world position.\n *\n * @returns The `worldWidth` and `worldHeight`.\n */\nexport default function getWorldWidthAndHeightFromCorners(\n  viewPlaneNormal: Types.Point3,\n  viewUp: Types.Point3,\n  topLeftWorld: Types.Point3,\n  bottomRightWorld: Types.Point3\n): { worldWidth: number; worldHeight: number } {\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n  const pos1 = vec3.fromValues(...topLeftWorld);\n  const pos2 = vec3.fromValues(...bottomRightWorld);\n\n  const diagonal = vec3.create();\n  vec3.subtract(diagonal, pos1, pos2);\n\n  const diagonalLength = vec3.length(diagonal);\n\n  // When the two points are very close to each other return width as 0\n  // to avoid NaN the cosTheta formula calculation\n  if (diagonalLength < 0.0001) {\n    return { worldWidth: 0, worldHeight: 0 };\n  }\n\n  const cosTheta =\n    vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n\n  const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n\n  const worldWidth = sinTheta * diagonalLength;\n  const worldHeight = cosTheta * diagonalLength;\n\n  return { worldWidth, worldHeight };\n}\n","import { metaData } from '@cornerstonejs/core';\n\ntype ModalityUnitOptions = {\n  isPreScaled: boolean;\n  isSuvScaled: boolean;\n};\n\nfunction getModalityUnit(\n  modality: string,\n  imageId: string,\n  options: ModalityUnitOptions\n): string {\n  if (modality === 'CT') {\n    return 'HU';\n  } else if (modality === 'PT') {\n    return _handlePTModality(imageId, options);\n  } else {\n    return '';\n  }\n}\n\nfunction _handlePTModality(imageId: string, options: ModalityUnitOptions) {\n  if (!options.isPreScaled) {\n    return 'raw';\n  }\n\n  if (options.isSuvScaled) {\n    return 'SUV';\n  }\n\n  const generalSeriesModule = metaData.get('generalSeriesModule', imageId);\n\n  // it might be possible that the referenceImageId is not the one\n  // that is being displayed. So we need to get the modality from imageId again\n  if (generalSeriesModule?.modality === 'PT') {\n    const petSeriesModule = metaData.get('petSeriesModule', imageId);\n    return petSeriesModule?.units || 'unitless';\n  }\n}\n\nexport { getModalityUnit, ModalityUnitOptions };\n","import {\n  cache,\n  StackViewport,\n  Types,\n  BaseVolumeViewport,\n} from '@cornerstonejs/core';\n\nfunction isViewportPreScaled(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  targetId: string\n): boolean {\n  if (viewport instanceof BaseVolumeViewport) {\n    const targetIdTokens = targetId.split('volumeId:');\n    const volumeId =\n      targetIdTokens.length > 1 ? targetIdTokens[1] : targetIdTokens[0];\n    const volume = cache.getVolume(volumeId);\n    return !!volume?.scaling && Object.keys(volume.scaling).length > 0;\n  } else if (viewport instanceof StackViewport) {\n    const { preScale } = viewport.getImageData() || {};\n    return !!preScale?.scaled;\n  } else {\n    return false;\n  }\n}\n\nexport { isViewportPreScaled };\n","import { Statistics } from '../../../types';\n\nabstract class Calculator {\n  static run: ({ value }) => void;\n  static getStatistics: () => Statistics[];\n}\n\nexport default Calculator;\n","import { Statistics } from '../../../types';\nimport Calculator from './Calculator';\n\nexport default class BasicStatsCalculator extends Calculator {\n  private static max = [-Infinity];\n  private static sum = [0];\n  private static sumSquares = [0];\n  private static squaredDiffSum = [0];\n  private static count = 0;\n\n  /**\n   * This callback is used when we verify if the point is in the annotion drawn so we can get every point\n   * in the shape to calculate the statistics\n   * @param value of the point in the shape of the annotation\n   */\n  static statsCallback = ({ value: newValue }): void => {\n    if (\n      Array.isArray(newValue) &&\n      newValue.length > 1 &&\n      this.max.length === 1\n    ) {\n      this.max.push(this.max[0], this.max[0]);\n      this.sum.push(this.sum[0], this.sum[0]);\n      this.sumSquares.push(this.sumSquares[0], this.sumSquares[0]);\n      this.squaredDiffSum.push(this.squaredDiffSum[0], this.squaredDiffSum[0]);\n    }\n\n    const newArray = Array.isArray(newValue) ? newValue : [newValue];\n    this.count += 1;\n\n    this.max.forEach(\n      (it, idx) => (this.max[idx] = Math.max(it, newArray[idx]))\n    );\n    this.sum.map((it, idx) => (this.sum[idx] += newArray[idx]));\n    this.sumSquares.map(\n      (it, idx) => (this.sumSquares[idx] += newArray[idx] ** 2)\n    );\n    this.squaredDiffSum.map(\n      (it, idx) =>\n        (this.squaredDiffSum[idx] += Math.pow(\n          newArray[idx] - this.sum[idx] / this.count,\n          2\n        ))\n    );\n  };\n\n  /**\n   * Basic function that calculates statictics for a given array of points.\n   * @param points\n   * @returns An object that contains :\n   * max : The maximum value of the array\n   * mean : mean of the array\n   * stdDev : standard deviation of the array\n   * stdDevWithSumSquare : standard deviation of the array using sum\n   */\n\n  static getStatistics = (): Statistics[] => {\n    const mean = this.sum.map((sum) => sum / this.count);\n    const stdDev = this.squaredDiffSum.map((squaredDiffSum) =>\n      Math.sqrt(squaredDiffSum / this.count)\n    );\n    const stdDevWithSumSquare = this.sumSquares.map((it, idx) =>\n      Math.sqrt(this.sumSquares[idx] / this.count - mean[idx] ** 2)\n    );\n    const currentMax = this.max;\n\n    this.max = [-Infinity];\n    this.sum = [0];\n    this.sumSquares = [0];\n    this.squaredDiffSum = [0];\n    this.count = 0;\n\n    return [\n      { name: 'max', value: singleArrayAsNumber(currentMax), unit: null },\n      { name: 'mean', value: singleArrayAsNumber(mean), unit: null },\n      { name: 'stdDev', value: singleArrayAsNumber(stdDev), unit: null },\n      {\n        name: 'stdDevWithSumSquare',\n        value: singleArrayAsNumber(stdDevWithSumSquare),\n        unit: null,\n      },\n    ];\n  };\n}\n\nfunction singleArrayAsNumber(val: number[]) {\n  return val.length === 1 ? val[0] : val;\n}\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCalibratedAreaUnits,\n  getCalibratedScale,\n} from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  ToolProps,\n  PublicToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { pointInShapeCallback } from '../../utilities/';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * RectangleROIAnnotation let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of a Rectangular region of interest.\n * You can use RectangleROIAnnotation in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. RectangleROI tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(RectangleROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(RectangleROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(RectangleROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass RectangleROITool extends AnnotationTool {\n  static toolName;\n\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a RectangleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): RectangleROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: RectangleROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasPoint1 = viewport.worldToCanvas(points[0]);\n    const canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    const rect = this._getRectangleImageCoordinates([\n      canvasPoint1,\n      canvasPoint2,\n    ]);\n\n    const point = [canvasCoords[0], canvasCoords[1]];\n    const { left, top, width, height } = rect;\n\n    const distanceToPoint = rectangle.distanceToPoint(\n      [left, top, width, height],\n      point as Types.Point2\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: RectangleROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: RectangleROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - Move the text boxes world position\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - Moving tool, so move all points by the world points delta\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { points } = data.handles;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Moving handle.\n      const { currentPoints } = eventDetail;\n      const enabledElement = getEnabledElement(element);\n      const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n      const worldPos = currentPoints.world;\n\n      const { points } = data.handles;\n\n      // Move this handle.\n      points[handleIndex] = [...worldPos];\n\n      let bottomLeftCanvas;\n      let bottomRightCanvas;\n      let topLeftCanvas;\n      let topRightCanvas;\n\n      let bottomLeftWorld;\n      let bottomRightWorld;\n      let topLeftWorld;\n      let topRightWorld;\n\n      switch (handleIndex) {\n        case 0:\n        case 3:\n          // Moving bottomLeft or topRight\n\n          bottomLeftCanvas = worldToCanvas(points[0]);\n          topRightCanvas = worldToCanvas(points[3]);\n\n          bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n          topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n          bottomRightWorld = canvasToWorld(bottomRightCanvas);\n          topLeftWorld = canvasToWorld(topLeftCanvas);\n\n          points[1] = bottomRightWorld;\n          points[2] = topLeftWorld;\n\n          break;\n        case 1:\n        case 2:\n          // Moving bottomRight or topLeft\n          bottomRightCanvas = worldToCanvas(points[1]);\n          topLeftCanvas = worldToCanvas(points[2]);\n\n          bottomLeftCanvas = <Types.Point2>[\n            topLeftCanvas[0],\n            bottomRightCanvas[1],\n          ];\n          topRightCanvas = <Types.Point2>[\n            bottomRightCanvas[0],\n            topLeftCanvas[1],\n          ];\n\n          bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n          topRightWorld = canvasToWorld(topRightCanvas);\n\n          points[0] = bottomLeftWorld;\n          points[3] = topRightWorld;\n\n          break;\n      }\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Remove event handlers for the modify event loop, and enable default event propagation.\n   */\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the rectangleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as RectangleROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewPlaneNormal,\n          viewUp,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewPlaneNormal,\n          viewUp,\n          renderingEngine,\n          enabledElement\n        );\n\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related stackViewports data if\n        // they are not at the referencedImageId, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-rect`;\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _getRectangleImageCoordinates = (\n    points: Array<Types.Point2>\n  ): {\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n  } => {\n    const [point0, point1] = points;\n\n    return {\n      left: Math.min(point0[0], point1[0]),\n      top: Math.min(point0[1], point1[1]),\n      width: Math.abs(point0[0] - point1[0]),\n      height: Math.abs(point0[1] - point1[1]),\n    };\n  };\n\n  /**\n   * _calculateCachedStats - For each volume in the frame of reference that a\n   * tool instance in particular viewport defines as its target volume, find the\n   * volume coordinates (i,j,k) being probed by the two corners. One of i,j or k\n   * will be constant across the two points. In the other two directions iterate\n   * over the voxels and calculate the first and second-order statistics.\n   *\n   * @param data - The annotation tool-specific data.\n   * @param viewPlaneNormal - The normal vector of the camera.\n   * @param viewUp - The viewUp vector of the camera.\n   */\n  _calculateCachedStats = (\n    annotation,\n    viewPlaneNormal,\n    viewUp,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const { data } = annotation;\n    const { viewportId, renderingEngineId, viewport } = enabledElement;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[3];\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata } = image;\n      const scalarData =\n        'getScalarData' in image ? image.getScalarData() : image.scalarData;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n\n        // Calculate index bounds to iterate over\n\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n        const scale = getCalibratedScale(image);\n\n        const area = Math.abs(worldWidth * worldHeight) / (scale * scale);\n\n        const modalityUnitOptions = {\n          isPreScaled: isViewportPreScaled(viewport, targetId),\n\n          isSuvScaled: this.isSuvScaled(\n            viewport,\n            targetId,\n            annotation.metadata.referencedImageId\n          ),\n        };\n\n        const modalityUnit = getModalityUnit(\n          metadata.Modality,\n          annotation.metadata.referencedImageId,\n          modalityUnitOptions\n        );\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          () => true,\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        const stats = this.configuration.statsCalculator.getStatistics();\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean: stats[1]?.value,\n          stdDev: stats[2]?.value,\n          max: stats[0]?.value,\n          statsArray: stats,\n          pointsInShape: pointsInShape,\n          areaUnit: getCalibratedAreaUnits(null, image),\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n}\n\n/**\n * _getTextLines - Returns the Area, mean and std deviation of the area of the\n * target volume enclosed by the rectangle.\n *\n * @param data - The annotation tool-specific data.\n * @param targetId - The volumeId of the volume to display the stats for.\n */\nfunction defaultGetTextLines(data, targetId: string): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n\n  if (mean === undefined) {\n    return;\n  }\n\n  const textLines: string[] = [];\n\n  textLines.push(`Area: ${roundNumber(area)} ${areaUnit}`);\n  textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n\n  return textLines;\n}\n\nRectangleROITool.toolName = 'RectangleROI';\nexport default RectangleROITool;\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { Events } from '../../enums';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { AnnotationModifiedEventDetail } from '../../types/EventTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**\n * This tool is exactly the RectangleROITool but only draws a rectangle on the image,\n * and by using utility functions such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. This tool, however, does not calculate the statistics\n * as RectangleROITool does.\n */\nclass RectangleROIThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const targetId = this.getTargetId(viewport);\n    let referencedImageId, volumeId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    } else {\n      volumeId = targetId.split('volumeId:')[1];\n      const imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n    // Todo: how not to store enabledElement on the annotation, segmentationModule needs the element to\n    // decide on the active segmentIndex, active segmentationIndex etc.\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n      },\n      data: {\n        label: '',\n        handles: {\n          // No need a textBox\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        segmentationId: null,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * it is used to draw the RectangleROI Threshold annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, renderingEngineId } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as RectangleROIThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      // Todo: This is not correct way to add the event trigger,\n      // this will trigger on all mouse hover too. Problem is that we don't\n      // have a cached stats mechanism for this tool yet?\n      const eventType = Events.ANNOTATION_MODIFIED;\n\n      const eventDetail: AnnotationModifiedEventDetail = {\n        annotation,\n        viewportId: viewport.id,\n        renderingEngineId,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n}\n\nRectangleROIThresholdTool.toolName = 'RectangleROIThreshold';\nexport default RectangleROIThresholdTool;\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  metaData,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\nimport { Events } from '../../enums';\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport throttle from '../../utilities/throttle';\nimport { AnnotationModifiedEventDetail } from '../../types/EventTypes';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIStartEndThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * This tool is similar to the RectangleROIThresholdTool which\n * only draws a rectangle on the image, and by using utility functions\n * such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. The only difference is that it only acts on the\n * acquisition plane and not the 3D volume, and accepts a start and end\n * slice, and renders a dashed rectangle on the image between the start and end\n * but a solid rectangle on start and end slice. Utility functions should be used\n * to modify the start and end slice.\n * // Todo: right now only the first slice has grabbable handles, need to make\n * // it so that the handles are grabbable on all slices.\n */\nclass RectangleROIStartEndThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        numSlicesToPropagate: 10,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStatsTool,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    let referencedImageId, imageVolume, volumeId;\n    if (viewport instanceof StackViewport) {\n      throw new Error('Stack Viewport Not implemented');\n    } else {\n      const targetId = this.getTargetId(viewport);\n      volumeId = targetId.split('volumeId:')[1];\n      imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    if (!referencedImageId) {\n      throw new Error('This tool does not work on non-acquisition planes');\n    }\n\n    const startIndex = viewport.getCurrentImageIdIndex();\n    const spacingInNormal = csUtils.getSpacingInNormalDirection(\n      imageVolume,\n      viewPlaneNormal\n    );\n\n    // We cannot simply add numSlicesToPropagate to startIndex because\n    // the order of imageIds can be from top to bottom or bottom to top and\n    // we want to make sure it is always propagated in the direction of the\n    // view and also to make sure we don't go out of bounds.\n    const endIndex = this._getEndSliceIndex(\n      imageVolume,\n      worldPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n        spacingInNormal,\n      },\n      data: {\n        label: '',\n        startSlice: startIndex,\n        endSlice: endIndex,\n        cachedStats: {\n          projectionPoints: [],\n          projectionPointsImageIds: [referencedImageId],\n        },\n        handles: {\n          // No need a textBox\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        labelmapUID: null,\n      },\n    };\n\n    // update the projection points in 3D space, since we are projecting\n    // the points to the slice plane, we need to make sure the points are\n    // computed for later export\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  // Todo: make it work for planes other than acquisition planes\n  _computeProjectionPoints(\n    annotation: RectangleROIStartEndThresholdAnnotation,\n    imageVolume: Types.IImageVolume\n  ): void {\n    const { data, metadata } = annotation;\n    const { viewPlaneNormal, spacingInNormal } = metadata;\n    const { imageData } = imageVolume;\n    const { startSlice, endSlice } = data;\n    const { points } = data.handles;\n\n    const startIJK = transformWorldToIndex(imageData, points[0]);\n\n    if (startIJK[2] !== startSlice) {\n      throw new Error('Start slice does not match');\n    }\n\n    // substitute the end slice index 2 with startIJK index 2\n    const endIJK = vec3.fromValues(startIJK[0], startIJK[1], endSlice);\n\n    const startWorld = vec3.create();\n    imageData.indexToWorldVec3(startIJK, startWorld);\n\n    const endWorld = vec3.create();\n    imageData.indexToWorldVec3(endIJK, endWorld);\n\n    // distance between start and end slice in the world coordinate\n    const distance = vec3.distance(startWorld, endWorld);\n\n    // for each point inside points, navigate in the direction of the viewPlaneNormal\n    // with amount of spacingInNormal, and calculate the next slice until we reach the distance\n    const newProjectionPoints = [];\n    for (let dist = 0; dist < distance; dist += spacingInNormal) {\n      newProjectionPoints.push(\n        points.map((point) => {\n          const newPoint = vec3.create();\n          vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\n          return Array.from(newPoint);\n        })\n      );\n    }\n\n    data.cachedStats.projectionPoints = newProjectionPoints;\n\n    // Find the imageIds for the projection points\n    const projectionPointsImageIds = [];\n    for (const RectanglePoints of newProjectionPoints) {\n      const imageId = csUtils.getClosestImageId(\n        imageVolume,\n        RectanglePoints[0],\n        viewPlaneNormal\n      );\n      projectionPointsImageIds.push(imageId);\n    }\n\n    data.cachedStats.projectionPointsImageIds = projectionPointsImageIds;\n  }\n\n  _calculateCachedStatsTool(annotation, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId, viewport } = enabledElement;\n\n    const { cachedStats } = data;\n    const volumeId = this.getTargetId(viewport);\n    const imageVolume = cache.getVolume(volumeId.split('volumeId:')[1]);\n\n    // Todo: this shouldn't be here, this is a performance issue\n    // Since we are extending the RectangleROI class, we need to\n    // bring the logic for handle to some cachedStats calculation\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  }\n\n  /**\n   * it is used to draw the rectangleROIStartEnd annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const sliceIndex = viewport.getCurrentImageIdIndex();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[\n        i\n      ] as RectangleROIStartEndThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { startSlice, endSlice } = data;\n      const { points, activeHandleIndex } = data.handles;\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      // range of slices to render based on the start and end slice, like\n      // np.arange\n\n      // if indexIJK is outside the start/end slice, we don't render\n      if (\n        sliceIndex < Math.min(startSlice, endSlice) ||\n        sliceIndex > Math.max(startSlice, endSlice)\n      ) {\n        continue;\n      }\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n\n      if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(annotation, enabledElement);\n      }\n\n      // if it is inside the start/end slice, but not exactly the first or\n      // last slice, we render the line in dash, but not the handles\n      let firstOrLastSlice = false;\n      if (sliceIndex === startSlice || sliceIndex === endSlice) {\n        firstOrLastSlice = true;\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null &&\n        firstOrLastSlice\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      let lineDashToUse = lineDash;\n\n      if (!firstOrLastSlice) {\n        lineDashToUse = 2;\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash: lineDashToUse,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  _getEndSliceIndex(\n    imageVolume: Types.IImageVolume,\n    worldPos: Types.Point3,\n    spacingInNormal: number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n\n    // get end position by moving from worldPos in the direction of viewplaneNormal\n    // with amount of numSlicesToPropagate * spacingInNormal\n    const endPos = vec3.create();\n    vec3.scaleAndAdd(\n      endPos,\n      worldPos,\n      viewPlaneNormal,\n      numSlicesToPropagate * spacingInNormal\n    );\n\n    const halfSpacingInNormalDirection = spacingInNormal / 2;\n    // Loop through imageIds of the imageVolume and find the one that is closest to endPos\n    const { imageIds } = imageVolume;\n    let imageIdIndex;\n    for (let i = 0; i < imageIds.length; i++) {\n      const imageId = imageIds[i];\n\n      const { imagePositionPatient } = metaData.get(\n        'imagePlaneModule',\n        imageId\n      );\n\n      const dir = vec3.create();\n      vec3.sub(dir, endPos, imagePositionPatient);\n\n      const dot = vec3.dot(dir, viewPlaneNormal);\n\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\n        imageIdIndex = i;\n      }\n    }\n\n    return imageIdIndex;\n  }\n}\n\nRectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';\nexport default RectangleROIStartEndThresholdTool;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Uses the current bounds of the 2D rectangle and extends it in the view axis by numSlices\n * It compares min and max of each IJK to find the view axis (for axial, zMin === zMax) and\n * then calculates the extended range. It will assume the slice is relative to the\n * current slice and will add the given slices to the current max of the boundingBox.\n * @param boundsIJK - [[iMin, iMax], [jMin, jMax], [kMin, kMax]]\n * @param slices - number of slices to project before and after\n * @returns extended bounds\n */\nfunction extend2DBoundingBoxInViewAxis(\n  boundsIJK: [Types.Point2, Types.Point2, Types.Point2],\n  numSlicesToProject: number\n): [Types.Point2, Types.Point2, Types.Point2] {\n  // find which index in boundsIJK has the same first and last value\n  const sliceNormalIndex = boundsIJK.findIndex(([min, max]) => min === max);\n\n  if (sliceNormalIndex === -1) {\n    throw new Error('3D bounding boxes not supported in an oblique plane');\n  }\n\n  // get the index and subtract slices from the min and add to the max\n  boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;\n  boundsIJK[sliceNormalIndex][1] += numSlicesToProject;\n  return boundsIJK;\n}\n\nexport default extend2DBoundingBoxInViewAxis;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\nimport extend2DBoundingBoxInViewAxis from '../boundingBox/extend2DBoundingBoxInViewAxis';\n\ntype Options = {\n  numSlicesToProject?: number;\n};\n\nfunction getBoundsIJKFromRectangleAnnotations(\n  annotations,\n  referenceVolume,\n  options = {} as Options\n) {\n  const AllBoundsIJK = [];\n  annotations.forEach((annotation) => {\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const { imageData, dimensions } = referenceVolume;\n\n    let pointsToUse = points;\n    // If the tool is a 2D tool but has projection points, use them\n    if (data.cachedStats?.projectionPoints) {\n      const { projectionPoints } = data.cachedStats;\n      pointsToUse = [].concat(...projectionPoints); // cannot use flat() because of typescript compiler right now\n    }\n\n    const rectangleCornersIJK = pointsToUse.map(\n      (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\n    );\n    let boundsIJK = getBoundingBoxAroundShapeIJK(\n      rectangleCornersIJK,\n      dimensions\n    );\n\n    // If the tool is 2D but it is configured to project to X amount of slices\n    // Don't project the slices if projectionPoints have been used to define the extents\n    if (options.numSlicesToProject && !data.cachedStats?.projectionPoints) {\n      boundsIJK = extend2DBoundingBoxInViewAxis(\n        boundsIJK,\n        options.numSlicesToProject\n      );\n    }\n\n    AllBoundsIJK.push(boundsIJK);\n  });\n\n  if (AllBoundsIJK.length === 1) {\n    return AllBoundsIJK[0];\n  }\n\n  // Get the intersection of all the bounding boxes\n  // This is the bounding box that contains all the ROIs\n  const boundsIJK = AllBoundsIJK.reduce(\n    (accumulator, currentValue) => {\n      return {\n        iMin: Math.min(accumulator.iMin, currentValue.iMin),\n        jMin: Math.min(accumulator.jMin, currentValue.jMin),\n        kMin: Math.min(accumulator.kMin, currentValue.kMin),\n        iMax: Math.max(accumulator.iMax, currentValue.iMax),\n        jMax: Math.max(accumulator.jMax, currentValue.jMax),\n        kMax: Math.max(accumulator.kMax, currentValue.kMax),\n      };\n    },\n    {\n      iMin: Infinity,\n      jMin: Infinity,\n      kMin: Infinity,\n      iMax: -Infinity,\n      jMax: -Infinity,\n      kMax: -Infinity,\n    }\n  );\n\n  return boundsIJK;\n}\n\nexport default getBoundsIJKFromRectangleAnnotations;\n","import type { Types } from '@cornerstonejs/core';\nimport { state } from '../../stateManagement/annotation';\nimport {\n  RectangleROIStartEndThresholdTool,\n  RectangleROIThresholdTool,\n} from '../../tools';\n\nimport thresholdVolumeByRange from './thresholdVolumeByRange';\nimport getBoundsIJKFromRectangleAnnotations from '../rectangleROITool/getBoundsIJKFromRectangleAnnotations';\nimport { ThresholdInformation } from './utilities';\n\nexport type ThresholdOptions = {\n  numSlicesToProject?: number; // number of slices to project before and after current slice\n  overwrite: boolean;\n  overlapType?: number; // type of the voxel overlap\n};\n\nexport type AnnotationForThresholding = {\n  data: {\n    handles: {\n      points: Types.Point3[];\n    };\n    cachedStats?: {\n      projectionPoints?: Types.Point3[][];\n    };\n  };\n};\n\n/**\n * It uses the provided rectangleROI annotations (either RectangleROIThreshold, or\n * RectangleROIStartEndThreshold) to compute an ROI that is the intersection of\n * all the annotations. Then it uses the rectangleROIThreshold utility to threshold\n * the volume.\n * @param annotationUIDs - rectangleROI annotationsUIDs to use for ROI\n * @param segmentationVolume - the segmentation volume\n * @param thresholdVolumeInformation - object array containing the volume data and range threshold values\n * @param options - options for thresholding\n * @returns\n */\nfunction rectangleROIThresholdVolumeByRange(\n  annotationUIDs: string[],\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[],\n  options: ThresholdOptions\n): Types.IImageVolume {\n  const annotations = annotationUIDs.map((annotationUID) => {\n    return state.getAnnotation(annotationUID);\n  });\n\n  _validateAnnotations(annotations);\n\n  let boundsIJK;\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n    // make sure that the boundsIJK are generated by the correct volume\n    const volumeSize =\n      thresholdVolumeInformation[i].volume.getScalarData().length;\n    if (volumeSize === segmentationVolume.getScalarData().length || i === 0) {\n      boundsIJK = getBoundsIJKFromRectangleAnnotations(\n        annotations,\n        thresholdVolumeInformation[i].volume,\n        options\n      );\n    }\n  }\n\n  const outputSegmentationVolume = thresholdVolumeByRange(\n    segmentationVolume,\n    thresholdVolumeInformation,\n    { ...options, boundsIJK }\n  );\n\n  return outputSegmentationVolume;\n}\n\nfunction _validateAnnotations(annotations) {\n  const validToolNames = [\n    RectangleROIThresholdTool.toolName,\n    RectangleROIStartEndThresholdTool.toolName,\n  ];\n\n  for (const annotation of annotations) {\n    const name = annotation.metadata.toolName;\n    if (!validToolNames.includes(name)) {\n      throw new Error(\n        'rectangleROIThresholdVolumeByRange only supports RectangleROIThreshold and RectangleROIStartEndThreshold annotations'\n      );\n    }\n  }\n}\n\nexport default rectangleROIThresholdVolumeByRange;\n","import { Types } from '@cornerstonejs/core';\nimport { volumeLoader, utilities as csUtils } from '@cornerstonejs/core';\n\n/**\n * Given a list of labelmaps (with the possibility of overlapping regions), and\n * a segmentIndex it creates a new labelmap with the same dimensions as the input labelmaps,\n * but merges them into a single labelmap for the segmentIndex. It wipes out\n * all other segment Indices. This is useful for calculating statistics regarding\n * a specific segment when there are overlapping regions between labelmap (e.g. TMTV)\n *\n * @param labelmaps - Array of labelmaps\n * @param segmentIndex - The segment index to merge\n * @returns Merged labelmap\n */\nfunction createMergedLabelmapForIndex(\n  labelmaps: Array<Types.IImageVolume>,\n  segmentIndex = 1,\n  volumeId = 'mergedLabelmap'\n): Types.IImageVolume {\n  labelmaps.forEach(({ direction, dimensions, origin, spacing }) => {\n    if (\n      !csUtils.isEqual(dimensions, labelmaps[0].dimensions) ||\n      !csUtils.isEqual(direction, labelmaps[0].direction) ||\n      !csUtils.isEqual(spacing, labelmaps[0].spacing) ||\n      !csUtils.isEqual(origin, labelmaps[0].origin)\n    ) {\n      throw new Error('labelmaps must have the same size and shape');\n    }\n  });\n\n  const labelmap = labelmaps[0];\n\n  const arrayType = (labelmap.getScalarData() as any).constructor;\n  const outputData = new arrayType(labelmap.getScalarData().length);\n\n  labelmaps.forEach((labelmap) => {\n    const scalarData = labelmap.getScalarData();\n    for (let i = 0; i < scalarData.length; i++) {\n      if (scalarData[i] === segmentIndex) {\n        outputData[i] = segmentIndex;\n      }\n    }\n  });\n\n  const options = {\n    scalarData: outputData,\n    metadata: labelmap.metadata,\n    spacing: labelmap.spacing,\n    origin: labelmap.origin,\n    direction: labelmap.direction,\n    dimensions: labelmap.dimensions,\n  };\n\n  const preventCache = true;\n  // Todo: following should be async\n  const mergedVolume = volumeLoader.createLocalVolume(\n    options,\n    volumeId,\n    preventCache\n  );\n\n  return mergedVolume;\n}\n\nexport default createMergedLabelmapForIndex;\n","import { isValidLabelmapConfig } from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nimport { RepresentationConfig } from '../../types/SegmentationStateTypes';\n\n/**\n * Given a representation type and a configuration, return true if the\n * configuration is valid for that representation type\n * @param representationType - The type of segmentation representation\n * @param config - RepresentationConfig\n * @returns A boolean value.\n */\nexport default function isValidRepresentationConfig(\n  representationType: string,\n  config: RepresentationConfig\n): boolean {\n  switch (representationType) {\n    case SegmentationRepresentation.Labelmap:\n      return isValidLabelmapConfig(config);\n    default:\n      throw new Error(`Unknown representation type: ${representationType}`);\n  }\n}\n","import getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nimport { Segmentation } from '../../types/SegmentationStateTypes';\n\n/**\n * It returns a configuration object for the given representation type.\n * @param representationType - The type of segmentation representation\n * @returns A representation configuration object.\n */\nexport default function getDefaultRepresentationConfig(\n  segmentation: Segmentation\n) {\n  const { type: representationType } = segmentation;\n  switch (representationType) {\n    case SegmentationRepresentation.Labelmap:\n      return getDefaultLabelmapConfig();\n    default:\n      throw new Error(`Unknown representation type: ${representationType}`);\n  }\n}\n","import { _cloneDeep } from 'lodash.clonedeep';\nimport {\n  getEnabledElementByIds,\n  volumeLoader,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Create a new 3D segmentation volume from the default imageData presented in\n * the first actor of the viewport. It looks at the metadata of the imageData\n * to determine the volume dimensions and spacing if particular options are not provided.\n *\n * @param viewportId - The Id of the viewport from which to derive the volume from.\n * @param renderingEngineId - The Id of the rendering engine the viewport belongs to.\n * @param [segmentationId] - The Id to name the generated segmentation. Autogenerated if not given.\n * @param [options] - LabelmapOptions\n * @returns A promise that resolves to the Id of the new labelmap volume.\n */\nexport default async function createLabelmapVolumeForViewport(input: {\n  viewportId: string;\n  renderingEngineId: string;\n  segmentationId?: string;\n  options?: {\n    volumeId?: string;\n    scalarData?: Float32Array | Uint8Array | Uint16Array | Int16Array;\n    targetBuffer?: {\n      type: 'Float32Array' | 'Uint8Array' | 'Uint16Array' | 'Int8Array';\n    };\n    metadata?: any;\n    dimensions?: Types.Point3;\n    spacing?: Types.Point3;\n    origin?: Types.Point3;\n    direction?: Float32Array;\n  };\n}): Promise<string> {\n  const { viewportId, renderingEngineId, options } = input;\n  let { segmentationId } = input;\n  const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n\n  if (!enabledElement) {\n    throw new Error('element disabled');\n  }\n\n  const { viewport } = enabledElement;\n  if (!(viewport instanceof VolumeViewport)) {\n    throw new Error('Segmentation only supports VolumeViewport');\n  }\n\n  const { uid } = viewport.getDefaultActor();\n\n  if (segmentationId === undefined) {\n    // Name the segmentation volume with the viewport Id\n    segmentationId = `${uid}-based-segmentation-${\n      options?.volumeId ?? csUtils.uuidv4().slice(0, 8)\n    }`;\n  }\n\n  if (options) {\n    // create a new labelmap with its own properties\n    // This allows creation of a higher resolution labelmap vs reference volume\n    const properties = _cloneDeep(options);\n    await volumeLoader.createLocalVolume(properties, segmentationId);\n  } else {\n    // create a labelmap from a reference volume\n    const { uid: volumeId } = viewport.getDefaultActor();\n    await volumeLoader.createAndCacheDerivedSegmentationVolume(volumeId, {\n      volumeId: segmentationId,\n    });\n  }\n\n  return segmentationId;\n}\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport getBrushToolInstances from './utilities';\n\n/**\n * Sets the brush size for all brush-based tools in a given tool group.\n * @param toolGroupId - The ID of the tool group to set the brush size for.\n * @param brushSize - The new brush size to set.\n * @param toolName - The name of the specific tool to set the brush size for (optional)\n * If not provided, all brush-based tools in the tool group will be affected.\n */\nexport function setBrushSizeForToolGroup(\n  toolGroupId: string,\n  brushSize: number,\n  toolName?: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n\n  brushBasedToolInstances.forEach((tool: BrushTool) => {\n    tool.configuration.brushSize = brushSize;\n\n    // Invalidate the brush being rendered so it can update.\n    tool.invalidateBrushCursor();\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  const viewportsInfoArray = Object.keys(viewportsInfo).map(\n    (key) => viewportsInfo[key]\n  );\n\n  if (!viewportsInfoArray.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfoArray[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n\n/**\n * Gets the brush size for the first brush-based tool instance in a given tool group.\n * @param toolGroupId - The ID of the tool group to get the brush size for.\n * @param toolName - The name of the specific tool to get the brush size for (Optional)\n * If not provided, the first brush-based tool instance in the tool group will be used.\n * @returns The brush size of the selected tool instance, or undefined if no brush-based tool instance is found.\n */\nexport function getBrushSizeForToolGroup(\n  toolGroupId: string,\n  toolName?: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n\n  // one is enough as they share the same brush size\n  const brushToolInstance = brushBasedToolInstances[0];\n\n  if (!brushToolInstance) {\n    return;\n  }\n\n  // TODO -> Assumes the brush sizes are the same and set via these helpers.\n  return brushToolInstance.configuration.brushSize;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport getBrushToolInstances from './utilities';\n\nexport function setBrushThresholdForToolGroup(\n  toolGroupId: string,\n  threshold: Types.Point2,\n  otherArgs: Record<string, unknown> = { isDynamic: false }\n) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n  const configuration = {\n    ...otherArgs,\n    ...(threshold !== undefined && { threshold }),\n  };\n\n  brushBasedToolInstances.forEach((tool) => {\n    tool.configuration.strategySpecificConfiguration.THRESHOLD = {\n      ...tool.configuration.strategySpecificConfiguration.THRESHOLD,\n      ...configuration,\n    };\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  if (!viewportsInfo.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfo[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n\nexport function getBrushThresholdForToolGroup(toolGroupId: string) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n  const brushToolInstance = brushBasedToolInstances[0];\n\n  if (!brushToolInstance) {\n    return;\n  }\n\n  // TODO -> Assumes the\n  return brushToolInstance.configuration.strategySpecificConfiguration.THRESHOLD\n    .threshold;\n}\n","import { Types } from '@cornerstonejs/core';\nimport { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport {\n  getVoxelOverlap,\n  processVolumes,\n  ThresholdInformation,\n} from './utilities';\n\n/**\n * It thresholds a segmentation volume based on a set of threshold values with\n * respect to a list of volumes and respective threshold ranges.\n * @param segmentationVolume - the segmentation volume to be modified\n * @param segmentationIndex - the index of the segmentation to modify\n * @param thresholdVolumeInformation - array of objects containing volume data\n * and a range (lower and upper values) to threshold\n * @param overlapType - indicates if the user requires all voxels pass\n * (overlapType = 1) or any voxel pass (overlapType = 0)\n * @returns\n */\nfunction thresholdSegmentationByRange(\n  segmentationVolume: Types.IImageVolume,\n  segmentationIndex: number,\n  thresholdVolumeInformation: ThresholdInformation[],\n  overlapType: number\n): Types.IImageVolume {\n  const scalarData = segmentationVolume.getScalarData();\n\n  // prepare a list of volume information objects for callback functions\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\n    segmentationVolume,\n    thresholdVolumeInformation\n  );\n\n  /**\n   * This function will test all overlaps between a voxel in base volume\n   * (the reference for segmentation volume creation) and voxels in other\n   * volumes.\n   * If the segmentation volume and the image volume are the same size,\n   * checks if the scalar data at each point is within the threshold values.\n   * If the segmentation volume and the image volume are different sizes,\n   * checks the voxel overlap\n   */\n  volumeInfoList.forEach((volumeInfo) => {\n    const { volumeSize } = volumeInfo;\n\n    if (volumeSize === scalarData.length) {\n      _handleSameSizeVolume(scalarData, segmentationIndex, volumeInfo);\n    } else {\n      _handleDifferentSizeVolume(\n        scalarData,\n        segmentationIndex,\n        volumeInfo,\n        volumeInfoList,\n        baseVolumeIdx,\n        overlapType\n      );\n    }\n  });\n\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n\n  return segmentationVolume;\n}\n\nfunction _handleDifferentSizeVolume(\n  scalarData: Types.PixelDataTypedArray,\n  segmentationIndex: number,\n  volumeInfo: any,\n  volumeInfoList: any,\n  baseVolumeIdx: number,\n  overlapType: number\n) {\n  const { imageData, lower, upper, dimensions } = volumeInfo;\n\n  let total, overlaps, range;\n\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const overlapBounds = getVoxelOverlap(\n        imageData,\n        dimensions,\n        volumeInfoList[baseVolumeIdx].spacing,\n        volumeInfoList[baseVolumeIdx].imageData.getPoint(i)\n      );\n\n      const callbackOverlap = ({ value }) => {\n        total = total + 1;\n        if (value >= range.lower && value <= range.upper) {\n          overlaps = overlaps + 1;\n        }\n      };\n\n      total = 0;\n      overlaps = 0;\n      range = { lower, upper };\n      let overlapTest = false;\n\n      // check all voxel overlaps\n      pointInShapeCallback(\n        imageData,\n        () => true,\n        callbackOverlap,\n        overlapBounds\n      );\n\n      overlapTest = overlapType === 0 ? overlaps > 0 : overlaps === total;\n      scalarData[i] = overlapTest ? segmentationIndex : 0;\n    }\n  }\n  return { total, range, overlaps };\n}\n\nfunction _handleSameSizeVolume(\n  scalarData: Types.PixelDataTypedArray,\n  segmentationIndex: number,\n  volumeInfo: any\n) {\n  const { referenceValues, lower, upper } = volumeInfo;\n\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const value = referenceValues[i];\n      scalarData[i] = value >= lower && value <= upper ? segmentationIndex : 0;\n    }\n  }\n}\n\nexport default thresholdSegmentationByRange;\n","/**\n * Creates a map that associates each imageId with a set of segmentation imageIds.\n * Note that this function assumes that the imageIds and segmentationImageIds arrays\n * are the same length and same order.\n *\n * @param imageIdsArray - An array of imageIds.\n * @param segmentationImageIds - An array of segmentation imageIds.\n * @returns A map that maps each imageId to a set of segmentation imageIds.\n */\nfunction createImageIdReferenceMap(\n  imageIdsArray: string[],\n  segmentationImageIds: string[]\n): Map<string, string> {\n  const imageIdReferenceMap = new Map<string, string>(\n    imageIdsArray.map((imageId, index) => {\n      return [imageId, segmentationImageIds[index]];\n    })\n  );\n\n  return imageIdReferenceMap;\n}\n\nexport { createImageIdReferenceMap };\n","import type { Types } from '@cornerstonejs/core';\nimport { cache } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\n/**\n * Determines if there is a point between point1 and point2 which is not\n * contained in the segmentation\n */\nexport default function isLineInSegment(\n  point1: Types.Point3,\n  point2: Types.Point3,\n  isInSegment\n) {\n  const ijk1 = isInSegment.toIJK(point1);\n  const ijk2 = isInSegment.toIJK(point2);\n  const testPoint = vec3.create();\n  const { testIJK } = isInSegment;\n  const delta = vec3.sub(vec3.create(), ijk1, ijk2);\n\n  // Test once for index value between the two points, so the max of the\n  // difference in IJK values\n  const testSize = Math.round(Math.max(...delta.map(Math.abs)));\n  if (testSize < 2) {\n    // No need to test when there are only two points\n    return true;\n  }\n  const unitDelta = vec3.scale(vec3.create(), delta, 1 / testSize);\n\n  for (let i = 1; i < testSize; i++) {\n    vec3.scaleAndAdd(testPoint, ijk2, unitDelta, i);\n    if (!testIJK(testPoint)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Creates a function that tests to see if the provided line segment, specified\n * in LPS space (as endpoints) is contained in the segment\n */\nfunction createIsInSegment(\n  segVolumeId: string,\n  segmentIndex: number,\n  containedSegmentIndices?: Set<number>\n) {\n  // Get segmentation volume\n  const vol = cache.getVolume(segVolumeId);\n  if (!vol) {\n    console.warn(`No volume found for ${segVolumeId}`);\n    return;\n  }\n\n  const segData = vol.imageData.getPointData().getScalars().getData();\n  const width = vol.dimensions[0];\n  const pixelsPerSlice = width * vol.dimensions[1];\n\n  return {\n    /**\n     * Find the center point between point1 and point2, convert it to IJK space\n     * and test if the value at that location is in the segment\n     */\n    testCenter: (point1, point2) => {\n      const point = vec3.add(vec3.create(), point1, point2).map((it) => it / 2);\n      const ijk = vol.imageData.worldToIndex(point as vec3).map(Math.round);\n      const [i, j, k] = ijk;\n      const index = i + j * width + k * pixelsPerSlice;\n      const value = segData[index];\n      return value === segmentIndex || containedSegmentIndices?.has(value);\n    },\n\n    toIJK: (point) => vol.imageData.worldToIndex(point as vec3),\n\n    testIJK: (ijk) => {\n      const [i, j, k] = ijk;\n      const index =\n        Math.round(i) + Math.round(j) * width + Math.round(k) * pixelsPerSlice;\n      const value = segData[index];\n      return value === segmentIndex || containedSegmentIndices?.has(value);\n    },\n  };\n}\n\nexport { createIsInSegment, isLineInSegment };\n","import { vec3 } from 'gl-matrix';\n\nimport { createIsInSegment, isLineInSegment } from './isLineInSegment';\nimport type { BidirectionalData } from './createBidirectionalToolData';\n\nconst EPSILON = 1e-2;\n\n/**\n * Search in the contours for the given segment to find the largest bidirectional\n * that will fit entirely within the slice contours inside the contours object.\n * Assumptions/implementation details:\n *\n *   1. The major and minor bidirectional lines must not cross the contour\n *   2. The center point for both major and minor bidirectional lines must be\n *      within the segment, or the contained segment index.\n *   3. The major/minor axis must be orthogonal\n *\n * Note this does NOT test that the major/minor axis intersect.  Normally they will, but\n * it isn't a hard requirement.\n *\n * The way that islands within the contours are handled is to allow the island to be\n * coloured with something that is contained - that way both open and closed islands\n * can be handled correctly for finding the bidirectional  (an open island is a section\n * inside the segment that is open to the outside - this can happen at bone endpoints or when\n * one region flows into another)\n */\nexport default function findLargestBidirectional(\n  contours,\n  segVolumeId: string,\n  segment\n) {\n  const { sliceContours } = contours;\n  const { segmentIndex, containedSegmentIndices } = segment;\n  let maxBidirectional;\n  const isInSegment = createIsInSegment(\n    segVolumeId,\n    segmentIndex,\n    containedSegmentIndices\n  );\n  for (const sliceContour of sliceContours) {\n    const bidirectional = createBidirectionalForSlice(\n      sliceContour,\n      isInSegment,\n      maxBidirectional\n    );\n    if (!bidirectional) {\n      continue;\n    }\n    maxBidirectional = bidirectional;\n  }\n  if (maxBidirectional) {\n    Object.assign(maxBidirectional, segment);\n  }\n  return maxBidirectional;\n}\n\n/**\n * This function creates a bidirectional data object for the given slice and\n * slice contour, only when the major distance is larger than currentMax, or\n * equal to current max and the minor is larger than currentMax's minor.\n * It does this by looking at every pair of distances in sliceCountour to find\n * those larger than the currentMax, and then finds the minor distance for those\n * major distances.\n *\n */\nfunction createBidirectionalForSlice(\n  sliceContour,\n  isInSegment,\n  currentMax = { maxMajor: 0, maxMinor: 0 }\n) {\n  const { points } = sliceContour.polyData;\n  const { maxMinor: currentMaxMinor, maxMajor: currentMaxMajor } = currentMax;\n  let maxMajor = currentMaxMajor * currentMaxMajor;\n  let maxMinor = currentMaxMinor * currentMaxMinor;\n  let maxMajorPoints;\n  for (let index1 = 0; index1 < points.length; index1++) {\n    for (let index2 = index1 + 1; index2 < points.length; index2++) {\n      const point1 = points[index1];\n      const point2 = points[index2];\n      const distance2 = vec3.sqrDist(point1, point2);\n      if (distance2 < maxMajor) {\n        continue;\n      }\n      if (distance2 - EPSILON < maxMajor + EPSILON && maxMajorPoints) {\n        // Consider adding to the set of points rather than continuing here\n        // so that all minor axis can be tested\n        continue;\n      }\n      if (!isInSegment.testCenter(point1, point2)) {\n        // Center between the two points has to be in the segment, otherwise\n        // this is out of bounds.\n        continue;\n      }\n      if (!isLineInSegment(point1, point2, isInSegment)) {\n        // If the line intersects the segment boundary, then skip it\n        continue;\n      }\n      maxMajor = distance2 - EPSILON;\n      maxMajorPoints = [index1, index2];\n      maxMinor = 0;\n    }\n  }\n  if (!maxMajorPoints) {\n    return;\n  }\n\n  maxMajor = Math.sqrt(maxMajor + EPSILON);\n  const handle0 = points[maxMajorPoints[0]];\n  const handle1 = points[maxMajorPoints[1]];\n  const unitMajor = vec3.sub(vec3.create(), handle0, handle1);\n  vec3.scale(unitMajor, unitMajor, 1 / maxMajor);\n\n  let maxMinorPoints;\n\n  for (let index1 = 0; index1 < points.length; index1++) {\n    for (let index2 = index1 + 1; index2 < points.length; index2++) {\n      const point1 = points[index1];\n      const point2 = points[index2];\n      const distance2 = vec3.sqrDist(point1, point2);\n      if (distance2 <= maxMinor) {\n        continue;\n      }\n      const delta = vec3.sub(vec3.create(), point1, point2);\n\n      const dot = Math.abs(vec3.dot(delta, unitMajor)) / Math.sqrt(distance2);\n      if (dot > EPSILON) {\n        continue;\n      }\n\n      if (!isInSegment.testCenter(point1, point2)) {\n        // Center between the two points has to be in the segment, otherwise\n        // this is out of bounds.\n        continue;\n      }\n      if (!isLineInSegment(point1, point2, isInSegment)) {\n        continue;\n      }\n      maxMinor = distance2;\n      maxMinorPoints = [index1, index2];\n    }\n  }\n\n  if (!maxMinorPoints) {\n    // Didn't find a larger minor distance\n    return;\n  }\n  maxMinor = Math.sqrt(maxMinor);\n  const handle2 = points[maxMinorPoints[0]];\n  const handle3 = points[maxMinorPoints[1]];\n\n  const bidirectional = {\n    majorAxis: [handle0, handle1],\n    minorAxis: [handle2, handle3],\n    maxMajor,\n    maxMinor,\n    ...sliceContour,\n  } as BidirectionalData;\n  return bidirectional;\n}\n","import { generateContourSetsFromLabelmap } from '../contours';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport findLargestBidirectional from './findLargestBidirectional';\n\nconst EPSILON = 1e-2;\nconst { Labelmap } = SegmentationRepresentations;\n\n/**\n * Generates a contour object over the segment, and then uses the contouring to\n * find the largest bidirectional object that can be applied within the acquisition\n * plane that is within the segment index, or the contained segment indices.\n *\n * @param segmentation.segments - a list of segments to apply the contour to.\n * @param segmentation.segments.containedSegmentIndices - a set of segment indexes equivalent to the primary segment\n * @param segmentation.segments.label - the label for the segment\n * @param segmentation.segments.color - the color to use for the segment label\n */\nexport default function contourAndFindLargestBidirectional(segmentation) {\n  const contours = generateContourSetsFromLabelmap({\n    segmentations: segmentation,\n  });\n\n  if (!contours?.length || !contours[0].sliceContours.length) {\n    return;\n  }\n\n  const {\n    representationData,\n    segments = [\n      null,\n      { label: 'Unspecified', color: null, containedSegmentIndices: null },\n    ],\n  } = segmentation;\n  const { volumeId: segVolumeId } = representationData[Labelmap];\n\n  const segmentIndex = segments.findIndex((it) => !!it);\n  if (segmentIndex === -1) {\n    return;\n  }\n  segments[segmentIndex].segmentIndex = segmentIndex;\n  return findLargestBidirectional(\n    contours[0],\n    segVolumeId,\n    segments[segmentIndex]\n  );\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { Annotation } from '../../types/AnnotationTypes';\n\nexport type BidirectionalData = {\n  majorAxis: [Types.Point3, Types.Point3];\n  minorAxis: [Types.Point3, Types.Point3];\n  maxMajor: number;\n  maxMinor: number;\n  segmentIndex: number;\n  label?: string;\n  color?: string | number[];\n  referencedImageId: string;\n  FrameOfReferenceUID: string;\n};\n\n/**\n * Creates data suitable for the BidirectionalTool from the basic bidirectional\n * data object.\n */\nexport default function createBidirectionalToolData(\n  bidirectionalData: BidirectionalData,\n  viewport\n): Annotation {\n  const {\n    majorAxis,\n    minorAxis,\n    label = '',\n    FrameOfReferenceUID,\n    referencedImageId,\n  } = bidirectionalData;\n  const [major0, major1] = majorAxis;\n  const [minor0, minor1] = minorAxis;\n\n  const { viewUp, viewPlaneNormal } = viewport.getCamera();\n  const points = [major0, major1, minor0, minor1];\n  const bidirectionalToolData = {\n    highlighted: true,\n    invalidated: true,\n    metadata: {\n      toolName: 'Bidirectional',\n      viewPlaneNormal,\n      viewUp,\n      FrameOfReferenceUID,\n      referencedImageId,\n    },\n    data: {\n      handles: {\n        points,\n        textBox: {\n          hasMoved: false,\n          worldPosition: [0, 0, 0] as Types.Point3,\n          worldBoundingBox: {\n            topLeft: [0, 0, 0] as Types.Point3,\n            topRight: [0, 0, 0] as Types.Point3,\n            bottomLeft: [0, 0, 0] as Types.Point3,\n            bottomRight: [0, 0, 0] as Types.Point3,\n          },\n        },\n        activeHandleIndex: null,\n      },\n      label,\n      cachedStats: {},\n    },\n    isLocked: false,\n    isVisible: true,\n  };\n  return bidirectionalToolData;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n// Returns sign of number\nfunction sign(x: any) {\n  return typeof x === 'number'\n    ? x\n      ? x < 0\n        ? -1\n        : 1\n      : x === x\n      ? 0\n      : NaN\n    : NaN;\n}\n\n/**\n * Calculates the intersection point between two lines in the 2D plane\n *\n * @param line1Start - x,y coordinates of the start of the first line\n * @param line1End - x,y coordinates of the end of the first line\n * @param line2Start - x,y coordinates of the start of the second line\n * @param line2End - x,y coordinates of the end of the second line\n * @returns [x,y] - point x,y of the point\n */\n\nexport default function intersectLine(\n  line1Start: Types.Point2,\n  line1End: Types.Point2,\n  line2Start: Types.Point2,\n  line2End: Types.Point2\n): number[] {\n  const [x1, y1] = line1Start;\n  const [x2, y2] = line1End;\n  const [x3, y3] = line2Start;\n  const [x4, y4] = line2End;\n\n  // Compute a1, b1, c1, where line joining points 1 and 2 is \"a1 x  +  b1 y  +  c1  =  0\"\n  const a1 = y2 - y1;\n  const b1 = x1 - x2;\n  const c1 = x2 * y1 - x1 * y2;\n\n  // Compute r3 and r4\n  const r3 = a1 * x3 + b1 * y3 + c1;\n  const r4 = a1 * x4 + b1 * y4 + c1;\n\n  /* Check signs of r3 and r4.  If both point 3 and point 4 lie on\n   * same side of line 1, the line segments do not intersect.\n   */\n\n  if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\n    return;\n  }\n\n  // Compute a2, b2, c2\n  const a2 = y4 - y3;\n  const b2 = x3 - x4;\n  const c2 = x4 * y3 - x3 * y4;\n\n  // Compute r1 and r2\n  const r1 = a2 * x1 + b2 * y1 + c2;\n  const r2 = a2 * x2 + b2 * y2 + c2;\n\n  /* Check signs of r1 and r2.  If both point 1 and point 2 lie\n   * on same side of second line segment, the line segments do\n   * not intersect.\n   */\n\n  if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\n    return;\n  }\n\n  /* Line segments intersect: compute intersection point.\n   */\n\n  const denom = a1 * b2 - a2 * b1;\n  let num;\n\n  /* The denom/2 is to get rounding instead of truncating.  It\n   * is added or subtracted to the numerator, depending upon the\n   * sign of the numerator.\n   */\n\n  num = b1 * c2 - b2 * c1;\n  const x = num / denom;\n\n  num = a2 * c1 - a1 * c2;\n  const y = num / denom;\n\n  const intersectionPoint = [x, y];\n\n  return intersectionPoint;\n}\n","import { vec2, vec3 } from 'gl-matrix';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCalibratedLengthUnits,\n  getCalibratedScale,\n} from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  drawLine as drawLineSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as lineSegment from '../../utilities/math/line';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { BidirectionalAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n  MouseDragEventType,\n  MouseMoveEventType,\n} from '../../types/EventTypes';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * BidirectionalTool let you draw annotations that measures the length and\n * width at the same time in `mm` unit. It is consisted of two perpendicular lines and\n * a text box. You can use the BidirectionalTool in all planes even in oblique\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(BidirectionalTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(BidirectionalTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(BidirectionalTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass BidirectionalTool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n  preventHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Bidirectional Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation(\n    evt: EventTypes.InteractionEventType\n  ): BidirectionalAnnotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: BidirectionalAnnotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [\n            // long\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            // short\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          activeHandleIndex: null,\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  }\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: BidirectionalAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // Check long axis\n    let canvasPoint1 = viewport.worldToCanvas(points[0]);\n    let canvasPoint2 = viewport.worldToCanvas(points[1]);\n\n    let line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    let distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    // Check short axis\n    canvasPoint1 = viewport.worldToCanvas(points[2]);\n    canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Handles the toolSelected callback for bidirectional tool\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Executes the callback for when mouse has selected a handle (anchor point) of\n   * the bidirectional tool or when the text box has been selected.\n   *\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param handle - Handle index or selected textBox information\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const data = annotation.data;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    hideElementCursor(element);\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Handles the mouse up action for the bidirectional tool. It can be at the end\n   * of the annotation drawing (MouseUpEventType) or when the user clicks and release\n   * the mouse button instantly which let to the annotation to draw without holding\n   * the mouse button (MouseClickEventType).\n   *\n   * @param evt - mouse up or mouse click event types\n   */\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (this.editData.handleIndex !== undefined) {\n      const { points } = data.handles;\n      const firstLineSegmentLength = vec3.distance(points[0], points[1]);\n      const secondLineSegmentLength = vec3.distance(points[2], points[3]);\n\n      if (secondLineSegmentLength > firstLineSegmentLength) {\n        // Switch points so [0,1] is the long axis and [2,3] is the short axis.\n\n        const longAxis = [[...points[2]], [...points[3]]];\n\n        const shortAxisPoint0 = [...points[0]];\n        const shortAxisPoint1 = [...points[1]];\n\n        // shortAxis[0->1] should be perpendicular (counter-clockwise) to longAxis[0->1]\n        const longAxisVector = vec2.create();\n\n        vec2.set(\n          longAxisVector,\n          longAxis[1][0] - longAxis[0][0],\n          longAxis[1][1] - longAxis[1][0]\n        );\n\n        const counterClockWisePerpendicularToLongAxis = vec2.create();\n\n        vec2.set(\n          counterClockWisePerpendicularToLongAxis,\n          -longAxisVector[1],\n          longAxisVector[0]\n        );\n\n        const currentShortAxisVector = vec2.create();\n\n        vec2.set(\n          currentShortAxisVector,\n          shortAxisPoint1[0] - shortAxisPoint0[0],\n          shortAxisPoint1[1] - shortAxisPoint0[0]\n        );\n\n        let shortAxis;\n\n        if (\n          vec2.dot(\n            currentShortAxisVector,\n            counterClockWisePerpendicularToLongAxis\n          ) > 0\n        ) {\n          shortAxis = [shortAxisPoint0, shortAxisPoint1];\n        } else {\n          shortAxis = [shortAxisPoint1, shortAxisPoint0];\n        }\n\n        data.handles.points = [\n          longAxis[0],\n          longAxis[1],\n          shortAxis[0],\n          shortAxis[1],\n        ];\n      }\n    }\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  /**\n   * @param evt - mouse move event type or mouse drag\n   */\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    const worldPos = currentPoints.world;\n\n    // Update first move handle\n    data.handles.points[handleIndex] = [...worldPos];\n\n    const canvasCoordPoints = data.handles.points.map(worldToCanvas);\n\n    const canvasCoords = {\n      longLineSegment: {\n        start: {\n          x: canvasCoordPoints[0][0],\n          y: canvasCoordPoints[0][1],\n        },\n        end: {\n          x: canvasCoordPoints[1][0],\n          y: canvasCoordPoints[1][1],\n        },\n      },\n      shortLineSegment: {\n        start: {\n          x: canvasCoordPoints[2][0],\n          y: canvasCoordPoints[2][1],\n        },\n        end: {\n          x: canvasCoordPoints[3][0],\n          y: canvasCoordPoints[3][1],\n        },\n      },\n    };\n\n    // ~~ calculate worldPos of our short axis handles\n    // short axis is perpendicular to long axis, and we set its length to be 2/3 of long axis\n    // (meaning each)\n    const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\n\n    const shortAxisDistFromCenter = dist / 3;\n    // Calculate long line's incline\n    const dx =\n      canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\n    const dy =\n      canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    const vectorX = dx / length;\n    const vectorY = dy / length;\n    // middle point between long line segment's points\n    const xMid =\n      (canvasCoords.longLineSegment.start.x +\n        canvasCoords.longLineSegment.end.x) /\n      2;\n    const yMid =\n      (canvasCoords.longLineSegment.start.y +\n        canvasCoords.longLineSegment.end.y) /\n      2;\n    // short points 1/3 distance from center of long points\n    const startX = xMid + shortAxisDistFromCenter * vectorY;\n    const startY = yMid - shortAxisDistFromCenter * vectorX;\n    const endX = xMid - shortAxisDistFromCenter * vectorY;\n    const endY = yMid + shortAxisDistFromCenter * vectorX;\n\n    // Update perpendicular line segment's points\n    data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\n    data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\n\n    annotation.invalidated = true;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData.hasMoved = true;\n  };\n\n  /**\n   * Mouse drag to edit annotation callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragModifyHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  /**\n   * Mouse dragging a handle callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, handleIndex: movingHandleIndex } = this.editData;\n    const { data } = annotation;\n\n    // Moving handle\n    const worldPos = currentPoints.world;\n    const canvasCoordHandlesCurrent = [\n      viewport.worldToCanvas(data.handles.points[0]),\n      viewport.worldToCanvas(data.handles.points[1]),\n      viewport.worldToCanvas(data.handles.points[2]),\n      viewport.worldToCanvas(data.handles.points[3]),\n    ];\n\n    const firstLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[0][0],\n        y: canvasCoordHandlesCurrent[0][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[1][0],\n        y: canvasCoordHandlesCurrent[1][1],\n      },\n    };\n    const secondLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[2][0],\n        y: canvasCoordHandlesCurrent[2][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[3][0],\n        y: canvasCoordHandlesCurrent[3][1],\n      },\n    };\n\n    // Handle we've selected's proposed point\n    const proposedPoint = <Types.Point3>[...worldPos];\n    const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\n\n    if (movingHandleIndex === 0 || movingHandleIndex === 1) {\n      const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\n\n      const fixedHandleCanvasCoord =\n        canvasCoordHandlesCurrent[fixedHandleIndex];\n\n      const fixedHandleToProposedCoordVec = vec2.set(\n        vec2.create(),\n        proposedCanvasCoord[0] - fixedHandleCanvasCoord[0],\n        proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]\n      );\n\n      const fixedHandleToOldCoordVec = vec2.set(\n        vec2.create(),\n        canvasCoordHandlesCurrent[movingHandleIndex][0] -\n          fixedHandleCanvasCoord[0],\n        canvasCoordHandlesCurrent[movingHandleIndex][1] -\n          fixedHandleCanvasCoord[1]\n      );\n\n      // normalize vector\n      vec2.normalize(\n        fixedHandleToProposedCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n      vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\n\n      // Check whether this\n      const proposedFirstLineSegment = {\n        start: {\n          x: fixedHandleCanvasCoord[0],\n          y: fixedHandleCanvasCoord[1],\n        },\n        end: {\n          x: proposedCanvasCoord[0],\n          y: proposedCanvasCoord[1],\n        },\n      };\n\n      // Note: this is the case when we are modifying the long axis line segment\n      // and we make it shorter and shorter until its second half size becomes zero\n      // which basically means that any more modification would make the long axis\n      // second half disappear. In this case, we just bail out and do not update\n      // since we don't want to disrupt the bidirectional shape.\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          proposedFirstLineSegment,\n          secondLineSegment\n        )\n      ) {\n        return;\n      }\n\n      const centerOfRotation = fixedHandleCanvasCoord;\n\n      const angle = this._getSignedAngle(\n        fixedHandleToOldCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n\n      // rotate handles around the center of rotation, first translate to origin,\n      // then rotate, then translate back\n      let firstPointX = canvasCoordHandlesCurrent[2][0];\n      let firstPointY = canvasCoordHandlesCurrent[2][1];\n\n      let secondPointX = canvasCoordHandlesCurrent[3][0];\n      let secondPointY = canvasCoordHandlesCurrent[3][1];\n\n      // translate to origin\n      firstPointX -= centerOfRotation[0];\n      firstPointY -= centerOfRotation[1];\n\n      secondPointX -= centerOfRotation[0];\n      secondPointY -= centerOfRotation[1];\n\n      // rotate\n      const rotatedFirstPoint =\n        firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\n      const rotatedFirstPointY =\n        firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\n\n      const rotatedSecondPoint =\n        secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\n      const rotatedSecondPointY =\n        secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\n\n      // translate back\n      firstPointX = rotatedFirstPoint + centerOfRotation[0];\n      firstPointY = rotatedFirstPointY + centerOfRotation[1];\n\n      secondPointX = rotatedSecondPoint + centerOfRotation[0];\n      secondPointY = rotatedSecondPointY + centerOfRotation[1];\n\n      // update handles\n      const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\n      const newSecondPoint = viewport.canvasToWorld([\n        secondPointX,\n        secondPointY,\n      ]);\n\n      // the fixed handle is the one that is not being moved so we\n      // don't need to update it\n      data.handles.points[movingHandleIndex] = proposedPoint;\n      data.handles.points[2] = newFirstPoint;\n      data.handles.points[3] = newSecondPoint;\n    } else {\n      // Translation manipulator\n      const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\n\n      const canvasCoordsCurrent = {\n        longLineSegment: {\n          start: firstLineSegment.start,\n          end: firstLineSegment.end,\n        },\n        shortLineSegment: {\n          start: secondLineSegment.start,\n          end: secondLineSegment.end,\n        },\n      };\n\n      const longLineSegmentVec = vec2.subtract(\n        vec2.create(),\n        [\n          canvasCoordsCurrent.longLineSegment.end.x,\n          canvasCoordsCurrent.longLineSegment.end.y,\n        ],\n        [\n          canvasCoordsCurrent.longLineSegment.start.x,\n          canvasCoordsCurrent.longLineSegment.start.y,\n        ]\n      );\n\n      const longLineSegmentVecNormalized = vec2.normalize(\n        vec2.create(),\n        longLineSegmentVec\n      );\n\n      const proposedToCurrentVec = vec2.subtract(\n        vec2.create(),\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [\n          canvasCoordHandlesCurrent[movingHandleIndex][0],\n          canvasCoordHandlesCurrent[movingHandleIndex][1],\n        ]\n      );\n\n      const movementLength = vec2.length(proposedToCurrentVec);\n\n      const angle = this._getSignedAngle(\n        longLineSegmentVecNormalized,\n        proposedToCurrentVec\n      );\n\n      const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\n\n      const newTranslatedPoint = vec2.scaleAndAdd(\n        vec2.create(),\n        [\n          canvasCoordHandlesCurrent[translateHandleIndex][0],\n          canvasCoordHandlesCurrent[translateHandleIndex][1],\n        ],\n        longLineSegmentVecNormalized,\n        movementAlongLineSegmentLength\n      );\n\n      // don't update if it passes through the other line segment\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          {\n            start: {\n              x: proposedCanvasCoord[0],\n              y: proposedCanvasCoord[1],\n            },\n            end: {\n              x: newTranslatedPoint[0],\n              y: newTranslatedPoint[1],\n            },\n          },\n          {\n            start: {\n              x: canvasCoordsCurrent.longLineSegment.start.x,\n              y: canvasCoordsCurrent.longLineSegment.start.y,\n            },\n            end: {\n              x: canvasCoordsCurrent.longLineSegment.end.x,\n              y: canvasCoordsCurrent.longLineSegment.end.y,\n            },\n          }\n        )\n      ) {\n        return;\n      }\n\n      const intersectionPoint = lineSegment.intersectLine(\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [newTranslatedPoint[0], newTranslatedPoint[1]],\n        [firstLineSegment.start.x, firstLineSegment.start.y],\n        [firstLineSegment.end.x, firstLineSegment.end.y]\n      );\n\n      // don't update if it doesn't intersect\n      if (!intersectionPoint) {\n        return;\n      }\n\n      data.handles.points[translateHandleIndex] = viewport.canvasToWorld(\n        newTranslatedPoint as Types.Point2\n      );\n      data.handles.points[movingHandleIndex] = proposedPoint;\n    }\n  };\n\n  /**\n   * Cancels an ongoing drawing of a bidirectional annotation\n   * @param element - HTML Element\n   */\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the bidirectional annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = true;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as BidirectionalAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].unit == null\n      ) {\n        data.cachedStats[targetId] = {\n          length: null,\n          width: null,\n          unit: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId1 = `${annotationUID}-line-1`;\n      const dataId2 = `${annotationUID}-line-2`;\n\n      const lineUID = '0';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId1\n      );\n\n      const secondLineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        secondLineUID,\n        canvasCoordinates[2],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId2\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _movingLongAxisWouldPutItThroughShortAxis = (\n    firstLineSegment,\n    secondLineSegment\n  ) => {\n    const vectorInSecondLineDirection = vec2.create();\n\n    vec2.set(\n      vectorInSecondLineDirection,\n      secondLineSegment.end.x - secondLineSegment.start.x,\n      secondLineSegment.end.y - secondLineSegment.start.y\n    );\n\n    vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\n\n    const extendedSecondLineSegment = {\n      start: {\n        x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\n      },\n      end: {\n        x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\n      },\n    };\n\n    // Add some buffer in the secondLineSegment when finding the proposedIntersectionPoint\n    // Of points to stop us getting stack when rotating quickly.\n\n    const proposedIntersectionPoint = lineSegment.intersectLine(\n      [extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y],\n      [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y],\n      [firstLineSegment.start.x, firstLineSegment.start.y],\n      [firstLineSegment.end.x, firstLineSegment.end.y]\n    );\n\n    const wouldPutThroughShortAxis = !proposedIntersectionPoint;\n\n    return wouldPutThroughShortAxis;\n  };\n\n  _calculateLength(pos1, pos2) {\n    const dx = pos1[0] - pos2[0];\n    const dy = pos1[1] - pos2[1];\n    const dz = pos1[2] - pos2[2];\n\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  _calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\n    const { data } = annotation;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const worldPos3 = data.handles.points[2];\n    const worldPos4 = data.handles.points[3];\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, dimensions } = image;\n      const scale = getCalibratedScale(image);\n      const dist1 = this._calculateLength(worldPos1, worldPos2) / scale;\n      const dist2 = this._calculateLength(worldPos3, worldPos4) / scale;\n      const length = dist1 > dist2 ? dist1 : dist2;\n      const width = dist1 > dist2 ? dist2 : dist1;\n\n      const index1 = transformWorldToIndex(imageData, worldPos1);\n      const index2 = transformWorldToIndex(imageData, worldPos2);\n      const index3 = transformWorldToIndex(imageData, worldPos3);\n      const index4 = transformWorldToIndex(imageData, worldPos4);\n\n      this._isInsideVolume(index1, index2, index3, index4, dimensions)\n        ? (this.isHandleOutsideImage = false)\n        : (this.isHandleOutsideImage = true);\n\n      cachedStats[targetId] = {\n        length,\n        width,\n        unit: getCalibratedLengthUnits(null, image),\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, index3, index4, dimensions): boolean => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions) &&\n      csUtils.indexWithinDimensions(index3, dimensions) &&\n      csUtils.indexWithinDimensions(index4, dimensions)\n    );\n  };\n\n  _getSignedAngle = (vector1, vector2) => {\n    return Math.atan2(\n      vector1[0] * vector2[1] - vector1[1] * vector2[0],\n      vector1[0] * vector2[0] + vector1[1] * vector2[1]\n    );\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const { cachedStats, label } = data;\n  const { length, width, unit } = cachedStats[targetId];\n\n  const textLines = [];\n  if (label) {\n    textLines.push(label);\n  }\n  if (length === undefined) {\n    return textLines;\n  }\n\n  // spaceBetweenSlices & pixelSpacing &\n  // magnitude in each direction? Otherwise, this is \"px\"?\n  textLines.push(\n    `L: ${roundNumber(length)} ${unit}`,\n    `W: ${roundNumber(width)} ${unit}`\n  );\n\n  return textLines;\n}\n\nBidirectionalTool.toolName = 'Bidirectional';\nexport default BidirectionalTool;\n","import { getEnabledElement, type Types } from '@cornerstonejs/core';\n\nimport type { Annotation } from '../../types/AnnotationTypes';\nimport * as segmentation from '../../stateManagement/segmentation';\nimport {\n  state as annotationState,\n  config as annotationConfig,\n} from '../../stateManagement/annotation';\nimport { jumpToSlice } from '../viewport';\nimport contourAndFindLargestBidirectional from './contourAndFindLargestBidirectional';\nimport createBidirectionalToolData from './createBidirectionalToolData';\nimport BidirectionalTool from '../../tools/annotation/BidirectionalTool';\n\nexport type Segment = {\n  segmentationId: string;\n  segmentIndex: number;\n  label: string;\n\n  style?: any;\n  containedSegmentIndices?: (number) => boolean;\n};\n\nexport type SegmentContourActionConfiguration = {\n  getSegment?: (\n    enabledElement: Types.IEnabledElement,\n    configuration: SegmentContourActionConfiguration\n  ) => Segment;\n\n  /**\n   * Optional map for data about each segment\n   */\n  segmentationId?: string;\n  segmentIndex?: number;\n  segmentData?: Map<number, Segment>;\n  toolGroupId?: string;\n};\n\nexport default function segmentContourAction(\n  element: HTMLDivElement,\n  configuration\n) {\n  const { data: configurationData } = configuration;\n  const enabledElement = getEnabledElement(element);\n  const segment = (configurationData.getSegment || defaultGetSegment)(\n    enabledElement,\n    configurationData\n  );\n  if (!segment) {\n    return;\n  }\n  const FrameOfReferenceUID = enabledElement.viewport.getFrameOfReferenceUID();\n  const segmentationsList = segmentation.state.getSegmentations();\n  const { segmentIndex, segmentationId } = segment;\n  const bidirectionals = annotationState.getAnnotations(\n    this.toolName || BidirectionalTool.toolName,\n    FrameOfReferenceUID\n  );\n  let hasExistingActiveSegment = false;\n  const existingLargestBidirectionals = bidirectionals.filter(\n    (existingBidirectionalItem) => {\n      const { segment } = existingBidirectionalItem.data;\n      if (!segment) {\n        return;\n      }\n      if (\n        segment.segmentationId === segmentationId &&\n        segment.segmentIndex === segmentIndex\n      ) {\n        hasExistingActiveSegment = true;\n        existingBidirectionalItem.data.segment = segment;\n      }\n      return !!segment;\n    }\n  );\n  if (!hasExistingActiveSegment) {\n    // Just create a dummy annotation object containing just enough information\n    // to create a real one.\n    existingLargestBidirectionals.push({\n      data: { segment },\n    } as unknown as Annotation);\n  }\n\n  let newBidirectional;\n  existingLargestBidirectionals.forEach((existingLargestBidirectional) => {\n    const segments = [];\n    const { segment: updateSegment } = existingLargestBidirectional.data;\n    const { segmentIndex, segmentationId } = updateSegment;\n    segments[segmentIndex] = updateSegment;\n    annotationState.removeAnnotation(\n      existingLargestBidirectional.annotationUID\n    );\n    const bidirectionalData = contourAndFindLargestBidirectional({\n      ...segmentationsList.find(\n        (segmentation) => segmentation.segmentationId === segmentationId\n      ),\n      segments,\n    });\n\n    if (!bidirectionalData) {\n      return;\n    }\n    const bidirectionalToolData = createBidirectionalToolData(\n      bidirectionalData,\n      enabledElement.viewport\n    );\n    bidirectionalToolData.annotationUID =\n      existingLargestBidirectional.annotationUID;\n    bidirectionalToolData.data.segment = updateSegment;\n\n    const annotationUID = annotationState.addAnnotation(\n      bidirectionalToolData,\n      FrameOfReferenceUID\n    );\n\n    if (\n      updateSegment.segmentIndex === segment.segmentIndex &&\n      updateSegment.segmentationId === segment.segmentationId\n    ) {\n      newBidirectional = bidirectionalData;\n      const { style } = segment;\n      if (style) {\n        annotationConfig.style.setAnnotationStyles(annotationUID, style);\n      }\n    }\n  });\n\n  if (newBidirectional) {\n    const { referencedImageId } = newBidirectional;\n    const imageIds = enabledElement.viewport.getImageIds();\n    const imageIndex = imageIds.findIndex(\n      (imageId) => imageId === referencedImageId\n    );\n\n    // TODO - figure out why this is reversed\n    jumpToSlice(element, {\n      imageIndex: imageIds.length - 1 - imageIndex,\n    });\n    enabledElement.viewport.render();\n  } else {\n    console.warn('No bidirectional found');\n  }\n\n  return newBidirectional;\n}\n\nexport function defaultGetSegment(\n  enabledElement: Types.IEnabledElement,\n  configuration: SegmentContourActionConfiguration\n): Segment {\n  const segmentationsList = segmentation.state.getSegmentations();\n  if (!segmentationsList.length) {\n    return;\n  }\n  const segmentationId =\n    configuration.segmentationId || segmentationsList[0].segmentationId;\n  const segmentIndex =\n    configuration.segmentIndex ??\n    segmentation.segmentIndex.getActiveSegmentIndex(segmentationId);\n  if (!segmentIndex) {\n    return;\n  }\n  const segmentData = configuration.segmentData?.get(segmentIndex);\n  return {\n    label: `Segment ${segmentIndex}`,\n    segmentIndex,\n    segmentationId,\n    ...segmentData,\n  };\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the distance of a point to an AABB using 2D Box SDF (Signed Distance Field)\n *\n * The SDF of a Box\n * https://www.youtube.com/watch?v=62-pRVZuS5c\n *\n * @param aabb - Axis-aligned bound box\n * @param point - 2D point\n * @returns The closest distance between the 2D point and the AABB\n */\nexport default function distanceToPointSquared(\n  aabb: Types.AABB2,\n  point: Types.Point2\n): number {\n  const aabbWidth = aabb.maxX - aabb.minX;\n  const aabbHeight = aabb.maxY - aabb.minY;\n  const aabbSize = [aabbWidth, aabbHeight];\n  const aabbCenter: Types.Point2 = [\n    aabb.minX + aabbWidth / 2,\n    aabb.minY + aabbHeight / 2,\n  ];\n\n  // Translates the point as the center of the AABB is the new origin.\n  // THe point is also mirroed to the first quadrant to simplify the math.\n  const translatedPoint = [\n    Math.abs(point[0] - aabbCenter[0]),\n    Math.abs(point[1] - aabbCenter[1]),\n  ];\n\n  // Calculate the distance from the point to the vertical and horizontal AABB borders\n  const dx = translatedPoint[0] - aabbSize[0] * 0.5;\n  const dy = translatedPoint[1] - aabbSize[1] * 0.5;\n\n  // dx >  0 && dy >  0: diagonal line connecting the point to AABB's corner\n  // dx >  0 && dy <= 0: a line parallel to x-axis connecting the point to AABB's right side\n  // dx <= 0 && dy >  0: a line parallel to y-axis connecting the point to AABB's top side\n  // dx <= 0 && dy <= 0: the point is inside the AABB\n  if (dx > 0 && dy > 0) {\n    return dx * dx + dy * dy;\n  }\n\n  const dist = Math.max(dx, 0) + Math.max(dy, 0);\n\n  return dist * dist;\n}\n","import { Types } from '@cornerstonejs/core';\nimport distanceToPointSquared from './distanceToPointSquared';\n\n/**\n * Calculates the squared distance of a point to an AABB using\n * 2D Box SDF (Signed Distance Field)\n *\n * The SDF of a Box\n * https://www.youtube.com/watch?v=62-pRVZuS5c\n *\n * @param aabb - Axis-aligned bound box (minX, minY, maxX and maxY)\n * @param point - 2D point\n * @returns The squared distance between the 2D point and the AABB\n */\nexport default function distanceToPoint(\n  aabb: Types.AABB2,\n  point: Types.Point2\n): number {\n  return Math.sqrt(distanceToPointSquared(aabb, point));\n}\n","import type { Types } from '@cornerstonejs/core';\nimport distanceToPointSquared from './distanceToPointSquared';\n\ntype Point = Types.Point2 | Types.Point3;\n\n/**\n * Calculates the distance of a point to another point\n *\n * @param p1 - x,y or x,y,z of the point\n * @param p2 - x,y or x,y,z of the point\n * @returns distance\n */\nexport default function distanceToPoint(p1: Point, p2: Point): number {\n  return Math.sqrt(distanceToPointSquared(p1, p2));\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Get a mirrored point along the line created by two points where one of them\n * is the static (\"anchor\") point and the other one is the point to be mirroed.\n * @param mirrorPoint - 2D Point to be mirroed\n * @param staticPoint - Static 2D point\n * @returns Mirroed 2D point\n */\nexport default function mirror(\n  mirrorPoint: Types.Point2,\n  staticPoint: Types.Point2\n): Types.Point2 {\n  const [x1, y1] = mirrorPoint;\n  const [x2, y2] = staticPoint;\n\n  const newX = 2 * x2 - x1;\n  const newY = 2 * y2 - y1;\n\n  return [newX, newY];\n}\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Orientation algoritm to determine if two lines cross.\n * Credit and details: geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n */\n\nfunction getAllIntersectionsWithPolyline(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2[] {\n  let initialI;\n  let j;\n  const intersections: Types.Point2[] = [];\n\n  if (closed) {\n    j = points.length - 1;\n    initialI = 0;\n  } else {\n    j = 0;\n    initialI = 1;\n  }\n\n  for (let i = initialI; i < points.length; i++) {\n    const p2 = points[j];\n    const q2 = points[i];\n\n    if (doesIntersect(p1, q1, p2, q2)) {\n      intersections.push([j, i]);\n    }\n\n    j = i;\n  }\n\n  return intersections;\n}\n\n/**\n * Returns all intersections points\n * between a line and a polyline\n */\nfunction getIntersectionCoordinatesWithPolyline(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2[] {\n  const result = [];\n  const polylineIndexes = getAllIntersectionsWithPolyline(\n    points,\n    p1,\n    q1,\n    closed\n  );\n\n  for (let i = 0; i < polylineIndexes.length; i++) {\n    const p2 = points[polylineIndexes[i][0]];\n    const q2 = points[polylineIndexes[i][1]];\n    const intersection = getIntersection(p1, q1, p2, q2);\n    result.push(intersection);\n  }\n  return result;\n}\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the first value.\n */\nfunction getFirstIntersectionWithPolyline(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2 | undefined {\n  let initialI;\n  let j;\n\n  if (closed) {\n    j = points.length - 1;\n    initialI = 0;\n  } else {\n    j = 0;\n    initialI = 1;\n  }\n\n  for (let i = initialI; i < points.length; i++) {\n    const p2 = points[j];\n    const q2 = points[i];\n\n    if (doesIntersect(p1, q1, p2, q2)) {\n      return [j, i];\n    }\n\n    j = i;\n  }\n}\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the closest value.\n */\nfunction getClosestIntersectionWithPolyline(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): { segment: Types.Point2; distance: number } | undefined {\n  let initialI;\n  let j;\n\n  if (closed) {\n    j = points.length - 1;\n    initialI = 0;\n  } else {\n    j = 0;\n    initialI = 1;\n  }\n\n  const intersections = [];\n\n  for (let i = initialI; i < points.length; i++) {\n    const p2 = points[j];\n    const q2 = points[i];\n\n    if (doesIntersect(p1, q1, p2, q2)) {\n      intersections.push([j, i]);\n    }\n\n    j = i;\n  }\n\n  if (intersections.length === 0) {\n    return;\n  }\n\n  // Find intersection closest to the start point\n  const distances = [];\n\n  intersections.forEach((intersection) => {\n    const intersectionPoints = [\n      points[intersection[0]],\n      points[intersection[1]],\n    ];\n\n    const midpoint = [\n      (intersectionPoints[0][0] + intersectionPoints[1][0]) / 2,\n      (intersectionPoints[0][1] + intersectionPoints[1][1]) / 2,\n    ];\n\n    distances.push(vec2.distance(<vec2>midpoint, p1));\n  });\n\n  const minDistance = Math.min(...distances);\n  const indexOfMinDistance = distances.indexOf(minDistance);\n\n  return {\n    segment: intersections[indexOfMinDistance],\n    distance: minDistance,\n  };\n}\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects the line (`p2`,`q2`) via an orientation algorithm.\n */\nfunction doesIntersect(\n  p1: Types.Point2,\n  q1: Types.Point2,\n  p2: Types.Point2,\n  q2: Types.Point2\n): boolean {\n  let result = false;\n\n  const orient = [\n    orientation(p1, q1, p2),\n    orientation(p1, q1, q2),\n    orientation(p2, q2, p1),\n    orientation(p2, q2, q1),\n  ];\n\n  // General Case\n  if (orient[0] !== orient[1] && orient[2] !== orient[3]) {\n    return true;\n  }\n\n  // Special Cases\n  if (orient[0] === 0 && onSegment(p1, p2, q1)) {\n    // If p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    result = true;\n  } else if (orient[1] === 0 && onSegment(p1, q2, q1)) {\n    // If p1, q1 and p2 are colinear and q2 lies on segment p1q1\n    result = true;\n  } else if (orient[2] === 0 && onSegment(p2, p1, q2)) {\n    // If p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    result = true;\n  } else if (orient[3] === 0 && onSegment(p2, q1, q2)) {\n    // If p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    result = true;\n  }\n\n  return result;\n}\n\n/**\n * Checks the orientation of 3 points, returns a 0, 1 or 2 based on\n * the orientation of the points.\n */\nfunction orientation(\n  p: Types.Point2,\n  q: Types.Point2,\n  r: Types.Point2\n): number {\n  const orientationValue =\n    (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n\n  if (orientationValue === 0) {\n    return 0; // Colinear\n  }\n\n  return orientationValue > 0 ? 1 : 2;\n}\n\n/**\n * Checks if point `q` lies on the segment (`p`,`r`).\n */\nfunction onSegment(p: Types.Point2, q: Types.Point2, r: Types.Point2): boolean {\n  if (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Gets the intersection between the line (`p1`,`q1`) and the line (`p2`,`q2`)\n * http://jsfiddle.net/justin_c_rounds/Gd2S2/light/\n * https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\n */\nfunction getIntersection(\n  p1: Types.Point2,\n  q1: Types.Point2,\n  p2: Types.Point2,\n  q2: Types.Point2\n): Types.Point2 {\n  const denominator =\n    (q2[1] - p2[1]) * (q1[0] - p1[0]) - (q2[0] - p2[0]) * (q1[1] - p1[1]);\n  if (denominator == 0) {\n    return;\n  }\n  let a = p1[1] - p2[1];\n  let b = p1[0] - p2[0];\n  const numerator1 = (q2[0] - p2[0]) * a - (q2[1] - p2[1]) * b;\n  const numerator2 = (q1[0] - p1[0]) * a - (q1[1] - p1[1]) * b;\n  a = numerator1 / denominator;\n  b = numerator2 / denominator;\n\n  const resultX = p1[0] + a * (q1[0] - p1[0]);\n  const resultY = p1[1] + a * (q1[1] - p1[1]);\n\n  return [resultX, resultY];\n}\n\nexport {\n  getAllIntersectionsWithPolyline,\n  getFirstIntersectionWithPolyline,\n  getClosestIntersectionWithPolyline,\n  getIntersectionCoordinatesWithPolyline,\n};\n","import { StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nconst EPSILON = 1e-3;\n\n/**\n * Gets the desired spacing for points in the polyline for the\n * `PlanarFreehandROITool` in the x and y canvas directions, as well as\n * returning these canvas directions in world space.\n *\n * @param viewport - The Cornerstone3D `StackViewport` or `VolumeViewport`.\n * @param subPixelResolution - The number to divide the image pixel spacing by\n * to get the sub pixel spacing. E.g. `10` will return spacings 10x smaller than\n * the native image spacing.\n * @returns The spacings of the X and Y directions, and the 3D directions of the\n * x and y directions.\n */\nconst getSubPixelSpacingAndXYDirections = (\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  subPixelResolution: number\n): { spacing: Types.Point2; xDir: Types.Point3; yDir: Types.Point3 } => {\n  let spacing;\n  let xDir;\n  let yDir;\n\n  if (viewport instanceof StackViewport) {\n    // Check XY directions\n    const imageData = viewport.getImageData();\n\n    xDir = imageData.direction.slice(0, 3);\n    yDir = imageData.direction.slice(3, 6);\n\n    spacing = imageData.spacing;\n  } else {\n    // Check volume directions\n    const imageData = viewport.getImageData();\n    const { direction, spacing: volumeSpacing } = imageData;\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    // Calculate size of spacing vector in normal direction\n    const iVector = direction.slice(0, 3) as Types.Point3;\n    const jVector = direction.slice(3, 6) as Types.Point3;\n    const kVector = direction.slice(6, 9) as Types.Point3;\n\n    const viewRight = vec3.create(); // Get the X direction of the viewport\n\n    vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n    const absViewRightDotI = Math.abs(vec3.dot(viewRight, iVector));\n    const absViewRightDotJ = Math.abs(vec3.dot(viewRight, jVector));\n    const absViewRightDotK = Math.abs(vec3.dot(viewRight, kVector));\n\n    // Get X spacing\n    let xSpacing;\n    if (Math.abs(1 - absViewRightDotI) < EPSILON) {\n      xSpacing = volumeSpacing[0];\n      xDir = iVector;\n    } else if (Math.abs(1 - absViewRightDotJ) < EPSILON) {\n      xSpacing = volumeSpacing[1];\n      xDir = jVector;\n    } else if (Math.abs(1 - absViewRightDotK) < EPSILON) {\n      xSpacing = volumeSpacing[2];\n      xDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    const absViewUpDotI = Math.abs(vec3.dot(viewUp, iVector));\n    const absViewUpDotJ = Math.abs(vec3.dot(viewUp, jVector));\n    const absViewUpDotK = Math.abs(vec3.dot(viewUp, kVector));\n\n    // Get Y spacing\n    let ySpacing;\n    if (Math.abs(1 - absViewUpDotI) < EPSILON) {\n      ySpacing = volumeSpacing[0];\n      yDir = iVector;\n    } else if (Math.abs(1 - absViewUpDotJ) < EPSILON) {\n      ySpacing = volumeSpacing[1];\n      yDir = jVector;\n    } else if (Math.abs(1 - absViewUpDotK) < EPSILON) {\n      ySpacing = volumeSpacing[2];\n      yDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    spacing = [xSpacing, ySpacing];\n  }\n\n  const subPixelSpacing: Types.Point2 = [\n    spacing[0] / subPixelResolution,\n    spacing[1] / subPixelResolution,\n  ];\n\n  return { spacing: subPixelSpacing, xDir, yDir };\n};\n\nexport default getSubPixelSpacingAndXYDirections;\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Returns true if points `p1` and `p2` are within `closeContourProximity`.\n */\nconst pointsAreWithinCloseContourProximity = (\n  p1: Types.Point2,\n  p2: Types.Point2,\n  closeContourProximity: number\n): boolean => {\n  return vec2.dist(p1, p2) < closeContourProximity;\n};\n\nexport default pointsAreWithinCloseContourProximity;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec2, vec3 } from 'gl-matrix';\nimport { PlanarFreehandROICommonData } from './planarFreehandROIInternalTypes';\n\n/**\n * Adds one or more points to the array at a resolution defined by the underlying image.\n */\nconst addCanvasPointsToArray = (\n  element: HTMLDivElement,\n  canvasPoints: Types.Point2[],\n  newCanvasPoint: Types.Point2,\n  commonData: PlanarFreehandROICommonData\n): number => {\n  const { xDir, yDir, spacing } = commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const lastWorldPos = viewport.canvasToWorld(\n    canvasPoints[canvasPoints.length - 1]\n  );\n  const newWorldPos = viewport.canvasToWorld(newCanvasPoint);\n\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, newWorldPos, lastWorldPos);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  const numPointsToAdd = Math.max(\n    Math.floor(xDist / spacing[0]),\n    Math.floor(yDist / spacing[0])\n  );\n\n  if (numPointsToAdd > 1) {\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n\n    const canvasDist = vec2.dist(lastCanvasPoint, newCanvasPoint);\n\n    const canvasDir = vec2.create();\n\n    vec2.subtract(canvasDir, newCanvasPoint, lastCanvasPoint);\n\n    vec2.set(canvasDir, canvasDir[0] / canvasDist, canvasDir[1] / canvasDist);\n\n    const distPerPoint = canvasDist / numPointsToAdd;\n\n    for (let i = 1; i <= numPointsToAdd; i++) {\n      canvasPoints.push([\n        lastCanvasPoint[0] + distPerPoint * canvasDir[0] * i,\n        lastCanvasPoint[1] + distPerPoint * canvasDir[1] * i,\n      ]);\n    }\n  } else {\n    canvasPoints.push(newCanvasPoint);\n  }\n\n  return numPointsToAdd;\n};\n\nexport default addCanvasPointsToArray;\n","import type { Types } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\n\n/**\n * Returns `true` if the point `p` can project onto point (`p1`, `p2`), and if\n * this projected point is less than `proximity` units away.\n */\nconst pointCanProjectOnLine = (\n  p: Types.Point2,\n  p1: Types.Point2,\n  p2: Types.Point2,\n  proximity: number\n): boolean => {\n  // Perfom checks in order of computational complexity.\n  const p1p = [p[0] - p1[0], p[1] - p1[1]];\n  const p1p2 = [p2[0] - p1[0], p2[1] - p1[1]];\n\n  const dot = p1p[0] * p1p2[0] + p1p[1] * p1p2[1];\n\n  // Dot product needs to be positive to be a candidate for projection onto line segment.\n  if (dot < 0) {\n    return false;\n  }\n\n  const p1p2Mag = Math.sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1]);\n\n  if (p1p2Mag === 0) {\n    return false;\n  }\n\n  const projectionVectorMag = dot / p1p2Mag;\n  const p1p2UnitVector = [p1p2[0] / p1p2Mag, p1p2[1] / p1p2Mag];\n  const projectionVector = [\n    p1p2UnitVector[0] * projectionVectorMag,\n    p1p2UnitVector[1] * projectionVectorMag,\n  ];\n  const projectionPoint = <Types.Point2>[\n    p1[0] + projectionVector[0],\n    p1[1] + projectionVector[1],\n  ];\n\n  const distance = vec2.distance(p, projectionPoint);\n\n  if (distance > proximity) {\n    // point is too far away.\n    return false;\n  }\n\n  // Check projects onto line segment.\n  if (vec2.distance(p1, projectionPoint) > vec2.distance(p1, p2)) {\n    return false;\n  }\n\n  return true;\n};\n\nexport default pointCanProjectOnLine;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the area of an array of `Point2` points using the shoelace algorithm.\n *\n * The units of the area are in the same units as the points are in. E.g. if\n * the points are in canvas, then the result is in canvas pixels ^2; If they are\n * in mm, then the result is in mm^2; etc.\n */\nexport default function calculateAreaOfPoints(points: Types.Point2[]): number {\n  // Shoelace algorithm.\n  const n = points.length;\n  let area = 0.0;\n  let j = n - 1;\n\n  for (let i = 0; i < n; i++) {\n    area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\n    j = i; // j is previous vertex to i\n  }\n\n  // Return absolute value of half the sum (half as summing up traingles).\n  return Math.abs(area / 2.0);\n}\n","// Pulled from source: https://github.com/w8r/liang-barsky\n// MIT Licensed.\n\n/**\n * Fast, destructive implementation of Liang-Barsky line clipping algorithm.\n * It clips a 2D segment by a rectangle.\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n */\n\nconst EPSILON = 1e-6;\nconst INSIDE = 1;\nconst OUTSIDE = 0;\n\nfunction clipT(num, denom, c) {\n  const [tE, tL] = c;\n  if (Math.abs(denom) < EPSILON) {\n    return num < 0;\n  }\n  const t = num / denom;\n\n  if (denom > 0) {\n    if (t > tL) {\n      return 0;\n    }\n    if (t > tE) {\n      c[0] = t;\n    }\n  } else {\n    if (t < tE) {\n      return 0;\n    }\n    if (t < tL) {\n      c[1] = t;\n    }\n  }\n  return 1;\n}\n\n/**\n * @param  {Point} a\n * @param  {Point} b\n * @param  {BoundingBox} box [xmin, ymin, xmax, ymax]\n * @param  {Point?} [da]\n * @param  {Point?} [db]\n * @return {number}\n */\nexport default function clip(a, b, box, da?, db?) {\n  const [x1, y1] = a;\n  const [x2, y2] = b;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n\n  if (da === undefined || db === undefined) {\n    da = a;\n    db = b;\n  } else {\n    da[0] = a[0];\n    da[1] = a[1];\n    db[0] = b[0];\n    db[1] = b[1];\n  }\n\n  if (\n    Math.abs(dx) < EPSILON &&\n    Math.abs(dy) < EPSILON &&\n    x1 >= box[0] &&\n    x1 <= box[2] &&\n    y1 >= box[1] &&\n    y1 <= box[3]\n  ) {\n    return INSIDE;\n  }\n\n  const c = [0, 1];\n  if (\n    clipT(box[0] - x1, dx, c) &&\n    clipT(x1 - box[2], -dx, c) &&\n    clipT(box[1] - y1, dy, c) &&\n    clipT(y1 - box[3], -dy, c)\n  ) {\n    const [tE, tL] = c;\n    if (tL < 1) {\n      db[0] = x1 + tL * dx;\n      db[1] = y1 + tL * dy;\n    }\n    if (tE > 0) {\n      da[0] += tE * dx;\n      da[1] += tE * dy;\n    }\n    return INSIDE;\n  }\n  return OUTSIDE;\n}\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n/**\n * Returns a point based on some criteria (e.g., minimum or maximum intensity) in\n * the line of sight (on the line between the passed worldPosition and camera position).\n * It iterated over the points with a step size on the line.\n *\n * @param viewport - Volume viewport\n * @param worldPos - World coordinates of the clicked location\n * @param targetVolumeId - target Volume ID in the viewport\n * @param criteriaFunction - A function that returns the point if it passes a certain\n * written logic, for instance, it can be a maxValue function that keeps the\n * records of all intensity values, and only return the point if its intensity\n * is greater than the maximum intensity of the points passed before.\n * @param stepsSize - Percentage of the spacing in the normal direction, default value\n * is 0.25 which means steps = 1/4 of the spacing in the normal direction.\n * @returns the World pos of the point that passes the criteriaFunction\n */\nexport default function getPointInLineOfSightWithCriteria(\n  viewport: Types.IVolumeViewport,\n  worldPos: Types.Point3,\n  targetVolumeId: string,\n  criteriaFunction: (intensity: number, point: Types.Point3) => Types.Point3,\n  stepSize = 0.25\n): Types.Point3 {\n  // 1. Getting the camera from the event details\n  const camera = viewport.getCamera();\n  const { position: cameraPosition } = camera;\n\n  // 2. Calculating the spacing in the normal direction, this will get\n  // used as the step size for iterating over the points in the line of sight\n  const { spacingInNormalDirection } =\n    csUtils.getTargetVolumeAndSpacingInNormalDir(\n      viewport,\n      camera,\n      targetVolumeId\n    );\n  // 2.1 Making sure, we are not missing any point\n  const step = spacingInNormalDirection * stepSize;\n\n  // 3. Getting the bounds of the viewports. Search for brightest point is\n  // limited to the visible bound\n  // Todo: this might be a problem since bounds will change to spatial bounds.\n  const bounds = viewport.getBounds();\n  const xMin = bounds[0];\n  const xMax = bounds[1];\n\n  // 5. Calculating the line, we use a parametric line definition\n  const vector = <Types.Point3>[0, 0, 0];\n\n  // 5.1 Point coordinate on the line\n  let point = <Types.Point3>[0, 0, 0];\n\n  // 5.2 Calculating the line direction, and storing in vector\n  vtkMath.subtract(worldPos, cameraPosition, vector);\n\n  let pickedPoint;\n\n  // 6. Iterating over the line from the lower bound to the upper bound, with the\n  // specified step size\n  for (let pointT = xMin; pointT <= xMax; pointT = pointT + step) {\n    // 6.1 Calculating the point x location\n    point = [pointT, 0, 0];\n    // 6.2 Calculating the point y,z location based on the line equation\n    const t = (pointT - cameraPosition[0]) / vector[0];\n    point[1] = t * vector[1] + cameraPosition[1];\n    point[2] = t * vector[2] + cameraPosition[2];\n\n    // 6.3 Checking if the points is inside the bounds\n    if (_inBounds(point, bounds)) {\n      // 6.4 Getting the intensity of the point\n      const intensity = viewport.getIntensityFromWorld(point);\n      // 6.5 Passing the intensity to the maximum value functions which decides\n      // whether the current point is of interest based on some criteria\n      const pointToPick = criteriaFunction(intensity, point);\n      if (pointToPick) {\n        pickedPoint = pointToPick;\n      }\n    }\n  }\n\n  return pickedPoint;\n}\n\n/**\n * Returns whether the point in the world is inside the bounds of the viewport\n * @param point - coordinates in the world\n * @returns boolean\n */\nconst _inBounds = function (\n  point: Types.Point3,\n  bounds: Array<number>\n): boolean {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  return (\n    point[0] > xMin &&\n    point[0] < xMax &&\n    point[1] > yMin &&\n    point[1] < yMax &&\n    point[2] > zMin &&\n    point[2] < zMax\n  );\n};\n","import filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nimport getWorldWidthAndHeightFromCorners from './getWorldWidthAndHeightFromCorners';\nimport filterAnnotationsForDisplay from './filterAnnotationsForDisplay';\nimport getPointInLineOfSightWithCriteria from './getPointInLineOfSightWithCriteria';\n\nexport default {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n};\n\nexport {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n};\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the orientation of the vector in the patient coordinate system.\n * @public\n *\n * @param vector - Input array\n * @returns The orientation in the patient coordinate system.\n */\nexport default function getOrientationStringLPS(vector: Types.Point3): string {\n  // Thanks to David Clunie\n  // https://sites.google.com/site/dicomnotes/\n\n  let orientation = '';\n  const orientationX = vector[0] < 0 ? 'R' : 'L';\n  const orientationY = vector[1] < 0 ? 'A' : 'P';\n  const orientationZ = vector[2] < 0 ? 'F' : 'H';\n\n  // Should probably make this a function vector3.abs\n  const abs = [Math.abs(vector[0]), Math.abs(vector[1]), Math.abs(vector[2])];\n\n  const MIN = 0.0001;\n\n  for (let i = 0; i < 3; i++) {\n    if (abs[0] > MIN && abs[0] > abs[1] && abs[0] > abs[2]) {\n      orientation += orientationX;\n      abs[0] = 0;\n    } else if (abs[1] > MIN && abs[1] > abs[0] && abs[1] > abs[2]) {\n      orientation += orientationY;\n      abs[1] = 0;\n    } else if (abs[2] > MIN && abs[2] > abs[0] && abs[2] > abs[1]) {\n      orientation += orientationZ;\n      abs[2] = 0;\n    } else if (abs[0] > MIN && abs[1] > MIN && abs[0] === abs[1]) {\n      orientation += orientationX + orientationY;\n      abs[0] = 0;\n      abs[1] = 0;\n    } else if (abs[0] > MIN && abs[2] > MIN && abs[0] === abs[2]) {\n      orientation += orientationX + orientationZ;\n      abs[0] = 0;\n      abs[2] = 0;\n    } else if (abs[1] > MIN && abs[2] > MIN && abs[1] === abs[2]) {\n      orientation += orientationY + orientationZ;\n      abs[1] = 0;\n      abs[2] = 0;\n    } else {\n      break;\n    }\n  }\n\n  return orientation;\n}\n","/**\n * Inverts an orientation string.\n * @public\n *\n * @param orientationString - The orientation.\n * @returns The inverted orientationString.\n */\nexport default function invertOrientationStringLPS(\n  orientationString: string\n): string {\n  let inverted = orientationString.replace('H', 'f');\n\n  inverted = inverted.replace('F', 'h');\n  inverted = inverted.replace('R', 'l');\n  inverted = inverted.replace('L', 'r');\n  inverted = inverted.replace('A', 'p');\n  inverted = inverted.replace('P', 'a');\n  inverted = inverted.toUpperCase();\n\n  return inverted;\n}\n","/**\n * CINE Tool Events\n */\nenum Events {\n  CLIP_STOPPED = 'CORNERSTONE_CINE_TOOL_STOPPED',\n  CLIP_STARTED = 'CORNERSTONE_CINE_TOOL_STARTED',\n}\n\nexport default Events;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { CINETypes } from '../../types';\n\nconst state: Record<string, CINETypes.ToolData> = {};\n\nfunction addToolState(element: HTMLDivElement, data: CINETypes.ToolData): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  state[viewportId] = data;\n}\n\nfunction getToolState(element: HTMLDivElement): CINETypes.ToolData | undefined {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  return state[viewportId];\n}\n\nexport { addToolState, getToolState };\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport {\n  utilities as csUtils,\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  cache,\n  BaseVolumeViewport,\n  Enums,\n} from '@cornerstonejs/core';\n\nimport { Types } from '@cornerstonejs/core';\nimport CINE_EVENTS from './events';\nimport { addToolState, getToolState } from './state';\nimport { CINETypes } from '../../types';\nimport scroll from '../scroll';\n\nconst { ViewportStatus } = Enums;\nconst { triggerEvent } = csUtils;\n\nconst debounced = true;\nconst loop = true;\nconst dynamicVolumesPlayingMap = new Map();\n\n/**\n * Starts playing a clip or adjusts the frame rate of an already playing clip.  framesPerSecond is\n * optional and defaults to 30 if not specified.  A negative framesPerSecond will play the clip in reverse.\n * The element must be a stack of images\n * @param element - HTML Element\n * @param framesPerSecond - Number of frames per second\n */\nfunction playClip(\n  element: HTMLDivElement,\n  playClipOptions: CINETypes.PlayClipOptions\n): void {\n  let playClipTimeouts;\n  let playClipIsTimeVarying;\n\n  if (element === undefined) {\n    throw new Error('playClip: element must not be undefined');\n  }\n\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error(\n      'playClip: element must be a valid Cornerstone enabled element'\n    );\n  }\n\n  // 4D Cine is enabled by default\n  playClipOptions.dynamicCineEnabled =\n    playClipOptions.dynamicCineEnabled ?? true;\n\n  const { viewport } = enabledElement;\n  const volume = _getVolumeFromViewport(viewport);\n  const playClipContext = _createCinePlayContext(viewport, playClipOptions);\n  let playClipData = getToolState(element);\n\n  const isDynamicCinePlaying =\n    playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume();\n\n  // If user is trying to play CINE for a 4D volume it first needs\n  // to stop CINE that has may be playing for any other viewport.\n  if (isDynamicCinePlaying) {\n    _stopDynamicVolumeCine(element);\n  }\n\n  if (!playClipData) {\n    playClipData = {\n      intervalId: undefined,\n      framesPerSecond: 30,\n      lastFrameTimeStamp: undefined,\n      ignoreFrameTimeVector: false,\n      usingFrameTimeVector: false,\n      frameTimeVector: playClipOptions.frameTimeVector ?? undefined,\n      speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,\n      reverse: playClipOptions.reverse ?? false,\n      loop: playClipOptions.loop ?? true,\n    };\n    addToolState(element, playClipData);\n  } else {\n    // Make sure the specified clip is not running before any property update.\n    // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n    // prevent stopping a 4D CINE in case it is playing on another viewport.\n    _stopClip(element, isDynamicCinePlaying);\n  }\n\n  playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;\n\n  // If a framesPerSecond is specified and is valid, update the playClipData now\n  if (\n    playClipOptions.framesPerSecond < 0 ||\n    playClipOptions.framesPerSecond > 0\n  ) {\n    playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);\n    playClipData.reverse = playClipData.framesPerSecond < 0;\n    // If framesPerSecond is given, frameTimeVector will be ignored...\n    playClipData.ignoreFrameTimeVector = true;\n  }\n\n  // Determine if frame time vector should be used instead of a fixed frame rate...\n  if (\n    playClipData.ignoreFrameTimeVector !== true &&\n    playClipData.frameTimeVector &&\n    playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&\n    playClipContext.frameTimeVectorEnabled\n  ) {\n    const { timeouts, isTimeVarying } = _getPlayClipTimeouts(\n      playClipData.frameTimeVector,\n      playClipData.speed\n    );\n\n    playClipTimeouts = timeouts;\n    playClipIsTimeVarying = isTimeVarying;\n  }\n\n  // This function encapsulates the frame rendering logic...\n  const playClipAction = () => {\n    const { numScrollSteps, currentStepIndex } = playClipContext;\n    let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n    const newStepIndexOutOfRange =\n      newStepIndex < 0 || newStepIndex >= numScrollSteps;\n\n    if (!loop && newStepIndexOutOfRange) {\n      // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n      // prevent stopping a 4D CINE in case it is playing on another viewport.\n      _stopClip(element, isDynamicCinePlaying);\n\n      const eventDetail = { element };\n\n      triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, eventDetail);\n      return;\n    }\n\n    // Loop around if newStepIndex is out of range\n    if (newStepIndex >= numScrollSteps) {\n      newStepIndex = 0;\n    } else if (newStepIndex < 0) {\n      newStepIndex = numScrollSteps - 1;\n    }\n\n    const delta = newStepIndex - currentStepIndex;\n\n    if (delta) {\n      playClipContext.scroll(delta);\n    }\n  };\n\n  if (isDynamicCinePlaying) {\n    dynamicVolumesPlayingMap.set(volume.volumeId, element);\n  }\n\n  // If playClipTimeouts array is available, not empty and its elements are NOT uniform ...\n  // ... (at least one timeout is different from the others), use alternate setTimeout implementation\n  if (\n    playClipTimeouts &&\n    playClipTimeouts.length > 0 &&\n    playClipIsTimeVarying\n  ) {\n    playClipData.usingFrameTimeVector = true;\n    playClipData.intervalId = window.setTimeout(\n      function playClipTimeoutHandler() {\n        playClipData.intervalId = window.setTimeout(\n          playClipTimeoutHandler,\n          playClipTimeouts[playClipContext.currentStepIndex]\n        );\n        playClipAction();\n      },\n      0\n    );\n  } else {\n    // ... otherwise user setInterval implementation which is much more efficient.\n    playClipData.usingFrameTimeVector = false;\n    playClipData.intervalId = window.setInterval(\n      playClipAction,\n      1000 / Math.abs(playClipData.framesPerSecond)\n    );\n  }\n\n  const eventDetail = {\n    element,\n  };\n\n  triggerEvent(element, CINE_EVENTS.CLIP_STARTED, eventDetail);\n}\n\n/**\n * Stops an already playing clip.\n * @param element - HTML Element\n */\nfunction stopClip(element: HTMLDivElement): void {\n  _stopClip(element, true);\n}\n\nfunction _stopClip(element: HTMLDivElement, stopDynamicCine: boolean): void {\n  const enabledElement = getEnabledElement(element);\n  if (!enabledElement) {\n    return;\n  }\n  const { viewport } = enabledElement;\n  const cineToolData = getToolState(viewport.element);\n\n  if (cineToolData) {\n    _stopClipWithData(cineToolData);\n  }\n\n  if (stopDynamicCine && viewport instanceof BaseVolumeViewport) {\n    _stopDynamicVolumeCine(element);\n  }\n}\n\n/**\n * [private] Stops any CINE playing for the dynamic volume loaded on this viewport\n * @param element - HTML Element\n */\nfunction _stopDynamicVolumeCine(element) {\n  const { viewport } = getEnabledElement(element);\n  const volume = _getVolumeFromViewport(viewport);\n\n  // If the current viewport has a 4D volume loaded it may be playing\n  // if it is also loaded on another viewport and user has started CINE\n  // for that one. This guarantees the other viewport will also be stopped.\n  if (volume?.isDynamicVolume()) {\n    const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);\n\n    dynamicVolumesPlayingMap.delete(volume.volumeId);\n\n    if (dynamicCineElement && dynamicCineElement !== element) {\n      stopClip(<HTMLDivElement>dynamicCineElement);\n    }\n  }\n}\n\n/**\n * [private] Turns a Frame Time Vector (0018,1065) array into a normalized array of timeouts. Each element\n * ... of the resulting array represents the amount of time each frame will remain on the screen.\n * @param vector - A Frame Time Vector (0018,1065) as specified in section C.7.6.5.1.2 of DICOM standard.\n * @param speed - A speed factor which will be applied to each element of the resulting array.\n * @returns An array with timeouts for each animation frame.\n */\nfunction _getPlayClipTimeouts(vector: number[], speed: number) {\n  let i;\n  let sample;\n  let delay;\n  let sum = 0;\n  const limit = vector.length;\n  const timeouts = [];\n\n  // Initialize time varying to false\n  let isTimeVarying = false;\n\n  if (typeof speed !== 'number' || speed <= 0) {\n    speed = 1;\n  }\n\n  // First element of a frame time vector must be discarded\n  for (i = 1; i < limit; i++) {\n    // eslint-disable-next-line no-bitwise\n    delay = (Number(vector[i]) / speed) | 0; // Integral part only\n    timeouts.push(delay);\n    if (i === 1) {\n      // Use first item as a sample for comparison\n      sample = delay;\n    } else if (delay !== sample) {\n      isTimeVarying = true;\n    }\n\n    sum += delay;\n  }\n\n  if (timeouts.length > 0) {\n    if (isTimeVarying) {\n      // If it's a time varying vector, make the last item an average...\n      // eslint-disable-next-line no-bitwise\n      delay = (sum / timeouts.length) | 0;\n    } else {\n      delay = timeouts[0];\n    }\n\n    timeouts.push(delay);\n  }\n\n  return { timeouts, isTimeVarying };\n}\n\n/**\n * [private] Performs the heavy lifting of stopping an ongoing animation.\n * @param element - HTML Element\n * @param playClipData - The data from playClip that needs to be stopped.\n */\nfunction _stopClipWithData(playClipData) {\n  const id = playClipData.intervalId;\n\n  if (typeof id !== 'undefined') {\n    playClipData.intervalId = undefined;\n    if (playClipData.usingFrameTimeVector) {\n      clearTimeout(id);\n    } else {\n      clearInterval(id);\n    }\n  }\n}\n\nfunction _getVolumesFromViewport(viewport): Types.IImageVolume[] {\n  return viewport\n    .getActors()\n    .map((actor) => cache.getVolume(actor.uid))\n    .filter((volume) => !!volume);\n}\n\nfunction _getVolumeFromViewport(viewport): Types.IImageVolume {\n  const volumes = _getVolumesFromViewport(viewport);\n  const dynamicVolume = volumes.find((volume) => volume.isDynamicVolume());\n\n  return dynamicVolume ?? volumes[0];\n}\n\nfunction _createStackViewportCinePlayContext(\n  viewport: StackViewport,\n  waitForRendered: number\n): CINETypes.CinePlayContext {\n  const imageIds = viewport.getImageIds();\n\n  return {\n    get numScrollSteps(): number {\n      return imageIds.length;\n    },\n    get currentStepIndex(): number {\n      return viewport.getTargetImageIdIndex();\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // It is always in acquired orientation\n      return true;\n    },\n    waitForRenderedCount: 0,\n    scroll(delta: number): void {\n      if (\n        this.waitForRenderedCount <= waitForRendered &&\n        viewport.viewportStatus !== ViewportStatus.RENDERED\n      ) {\n        this.waitForRenderedCount++;\n        return;\n      }\n      this.waitForRenderedCount = 0;\n      scroll(viewport, { delta, debounceLoading: debounced });\n    },\n  };\n}\n\nfunction _createVolumeViewportCinePlayContext(\n  viewport: VolumeViewport,\n  volume: Types.IImageVolume\n): CINETypes.CinePlayContext {\n  const { volumeId } = volume;\n  const cachedScrollInfo = {\n    viewPlaneNormal: vec3.create(),\n    scrollInfo: null,\n  };\n\n  const getScrollInfo = () => {\n    const camera = viewport.getCamera();\n    const updateCache =\n      !cachedScrollInfo.scrollInfo ||\n      !vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);\n\n    // Number of steps would change only after rotating the volume so it\n    // caches the result and recomputes only when necessary. Until it is\n    // rotated the current frame is updated locally\n    if (updateCache) {\n      const scrollInfo = csUtils.getVolumeViewportScrollInfo(\n        viewport,\n        volumeId\n      );\n\n      cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;\n      cachedScrollInfo.scrollInfo = scrollInfo;\n    }\n\n    return cachedScrollInfo.scrollInfo;\n  };\n\n  return {\n    get numScrollSteps(): number {\n      return getScrollInfo().numScrollSteps;\n    },\n    get currentStepIndex(): number {\n      return getScrollInfo().currentStepIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      const camera = viewport.getCamera();\n      const volumeViewPlaneNormal = volume.direction\n        .slice(6, 9)\n        .map((x) => -x) as Types.Point3;\n      const dot = vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);\n\n      // Check if the volume is in acquired orientation\n      // it may be flipped or rotated in plane\n      return glMatrix.equals(dot, 1);\n    },\n    scroll(delta: number): void {\n      getScrollInfo().currentStepIndex += delta;\n      scroll(viewport, { delta });\n    },\n  };\n}\n\nfunction _createDynamicVolumeViewportCinePlayContext(\n  volume: Types.IDynamicImageVolume\n): CINETypes.CinePlayContext {\n  return {\n    get numScrollSteps(): number {\n      return volume.numTimePoints;\n    },\n    get currentStepIndex(): number {\n      return volume.timePointIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // Looping throught time does not uses frameTimeVector\n      return false;\n    },\n    scroll(delta: number): void {\n      // Updating this property (setter) makes it move to the desired time point\n      volume.timePointIndex += delta;\n    },\n  };\n}\n\nfunction _createCinePlayContext(\n  viewport,\n  playClipOptions: CINETypes.PlayClipOptions\n): CINETypes.CinePlayContext {\n  if (viewport instanceof StackViewport) {\n    return _createStackViewportCinePlayContext(\n      viewport,\n      playClipOptions.waitForRendered ?? 30\n    );\n  }\n\n  if (viewport instanceof VolumeViewport) {\n    const volume = _getVolumeFromViewport(viewport);\n\n    if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {\n      return _createDynamicVolumeViewportCinePlayContext(\n        <Types.IDynamicImageVolume>volume\n      );\n    }\n\n    return _createVolumeViewportCinePlayContext(viewport, volume);\n  }\n\n  throw new Error('Unknown viewport type');\n}\n\nexport { playClip, stopClip };\n","export function basis(t1, v0, v1, v2, v3) {\n  var t2 = t1 * t1, t3 = t2 * t1;\n  return ((1 - 3 * t1 + 3 * t2 - t3) * v0\n      + (4 - 6 * t2 + 3 * t3) * v1\n      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2\n      + t3 * v3) / 6;\n}\n\nexport default function(values) {\n  var n = values.length - 1;\n  return function(t) {\n    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),\n        v1 = values[i],\n        v2 = values[i + 1],\n        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,\n        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;\n    return basis((t - i / n) * n, v0, v1, v2, v3);\n  };\n}\n","export default function(interpolator, n) {\n  var samples = new Array(n);\n  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));\n  return samples;\n}\n","import min from \"./min.js\";\n\nexport default function transpose(matrix) {\n  if (!(n = matrix.length)) return [];\n  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {\n    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n      row[j] = matrix[j][i];\n    }\n  }\n  return transpose;\n}\n\nfunction length(d) {\n  return d.length;\n}\n","import transpose from \"./transpose.js\";\n\nexport default function zip() {\n  return transpose(arguments);\n}\n","export default function min(values, valueof) {\n  let min;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value;\n      }\n    }\n  }\n  return min;\n}\n","import { Types } from '@cornerstonejs/core';\nimport { interpolatePoints } from './algorithms/bspline';\n\n/**\n * Returns a list of uniform distributed values. This list contains the max amount of values which has at least a minimum distance between two consecutive values.\n * minDistributionDistance means the min distance between two consecutive distributed values.\n * Closed interval contains the min/max values.\n *\n * Formula for reference\n * For given {x  R | x  0} and {minDis  R | minDis  0},  D(x) where D(x)  a and D(x)  b  =>\n *         |\n * D(x)  = |                  (b - a)\n *         |  round( ------------------------ * x  )   + a\n *         |                (b - a + 1)\n *         |        round( -----------  )\n *         |                 minDis\n */\nfunction getContinuousUniformDistributionValues(\n  minDistributionDistance: number,\n  closedInterval: [number, number]\n): number[] {\n  const result = [];\n  const [intervalIni, intervalEnd] = closedInterval;\n\n  const intervalSize = intervalEnd - intervalIni + 1;\n  const intensity = Math.floor(intervalSize / minDistributionDistance);\n\n  let x = 0;\n  let continuosDistributionValue =\n    Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n\n  while (continuosDistributionValue <= intervalEnd) {\n    result.push(continuosDistributionValue);\n    x++;\n    continuosDistributionValue =\n      Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n  }\n\n  return result;\n}\n\n/**\n * Interpolates a segment of points from iniIndex until endIndex.\n * The process of interpolation considers the param knotsRatioPercentage as being the percentage of points from Segment that are likely to be considered.\n * By default it uses b-spline algorithm.\n * The result total of points is equal to original points.\n */\nexport default function interpolateSegmentPoints(\n  points: (Types.Point2 | Types.Point3)[],\n  iniIndex: number,\n  endIndex: number,\n  knotsRatioPercentage: number\n): (Types.Point2 | Types.Point3)[] {\n  const segmentSize = endIndex - iniIndex + 1;\n\n  const amountOfKnots =\n    Math.floor((knotsRatioPercentage / 100) * segmentSize) ?? 1;\n  const minKnotDistance = Math.floor(segmentSize / amountOfKnots) ?? 1;\n\n  if (isNaN(segmentSize) || !segmentSize || !minKnotDistance) {\n    return points;\n  }\n\n  // segment should be at least the double of desired minKnot distance. This will ensure at there will enough knots to interpolate.\n  if (segmentSize / minKnotDistance < 2) {\n    return points;\n  }\n\n  const interpolationIniIndex = Math.max(0, iniIndex);\n  const interpolationEndIndex = Math.min(points.length - 1, endIndex);\n  const segmentPointsUnchangedBeg = points.slice(0, interpolationIniIndex);\n\n  const segmentPointsUnchangedEnd = points.slice(\n    interpolationEndIndex + 1,\n    points.length\n  );\n\n  const knotsIndexes = getContinuousUniformDistributionValues(minKnotDistance, [\n    interpolationIniIndex,\n    interpolationEndIndex,\n  ]);\n\n  const interpolatedPoints = interpolatePoints(points, knotsIndexes);\n\n  return [\n    ...segmentPointsUnchangedBeg,\n    ...interpolatedPoints,\n    ...segmentPointsUnchangedEnd,\n  ];\n}\n","import {\n  interpolateBasis as d3InterpolateBasis,\n  quantize as d3Quantize,\n} from 'd3-interpolate';\nimport { zip as d3Zip } from 'd3-array';\nimport { Types } from '@cornerstonejs/core';\n\nfunction isPoints3D(\n  points: (Types.Point2 | Types.Point3)[]\n): points is Types.Point3[] {\n  return (points as Types.Point3[])[0]?.length === 3;\n}\n\n/**\n * Returns an array of the originalPoints length containing the interpolated data.\n * It interpolates a set of points indexed by knotsIndexes.\n * That is, it DISCARDS all points except those in knotsIndexes. Then, a new set of points is created by using a b-spline on the remaining points, in order to re-create a new set of points.\n */\nexport function interpolatePoints(\n  originalPoints: (Types.Point2 | Types.Point3)[],\n  knotsIndexes: number[]\n): (Types.Point2 | Types.Point3)[] {\n  if (\n    !knotsIndexes ||\n    knotsIndexes.length === 0 ||\n    knotsIndexes.length === originalPoints.length\n  ) {\n    return originalPoints;\n  }\n\n  const n = knotsIndexes[knotsIndexes.length - 1] - knotsIndexes[0] + 1;\n  const xInterpolator = d3InterpolateBasis(\n    knotsIndexes.map((k) => originalPoints[k][0])\n  );\n  const yInterpolator = d3InterpolateBasis(\n    knotsIndexes.map((k) => originalPoints[k][1])\n  );\n\n  if (isPoints3D(originalPoints)) {\n    const zInterpolator = d3InterpolateBasis(\n      knotsIndexes.map((k) => originalPoints[k][2])\n    );\n    return <Types.Point3[]>(\n      d3Zip(\n        d3Quantize(xInterpolator, n),\n        d3Quantize(yInterpolator, n),\n        d3Quantize(zInterpolator, n)\n      )\n    );\n  } else {\n    return <Types.Point2[]>(\n      d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n))\n    );\n  }\n}\n","import { Types } from '@cornerstonejs/core';\nimport { point } from '../math';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\n\nexport function shouldInterpolate(configuration: Record<any, any>): boolean {\n  return (\n    configuration?.interpolation?.interpolateOnAdd === true ||\n    configuration?.interpolation?.interpolateOnEdit === true\n  );\n}\n\n/**\n * Tells whether two points are equal by proximity or not as far as interpolation goes.\n */\nfunction isEqualByProximity(pointA, pointB) {\n  return point.distanceToPoint(pointA, pointB) < 0.001;\n}\n\n/**\n * Tells whether two points are strictly equal or not as far as interpolation goes.\n */\nfunction isEqual(pointA, pointB) {\n  return point.distanceToPoint(pointA, pointB) === 0;\n}\n\n/**\n * Finds the indexes of points list and otherPoints list that points are identical.\n */\nfunction findMatchIndexes(\n  points: Types.Point2[],\n  otherPoints: Types.Point2[]\n): [number, number] | undefined {\n  for (let i = 0; i < points.length; i++) {\n    for (let j = 0; j < otherPoints.length; j++) {\n      if (isEqual(points[i], otherPoints[j])) {\n        return [i, j];\n      }\n    }\n  }\n}\n/**\n * Returns the following index value (on circular basis) of index param on the given direction.\n */\nfunction followingIndex(\n  index: number,\n  size: number,\n  direction: number\n): number {\n  return (index + size + direction) % size;\n}\n/**\n * Array of params to be used on circular find next index.\n * The values respresent start index, indexDelimiter, list of points\n */\ntype ListParamsType = [number, number, Types.Point2[]];\n\n/**\n * Circular finding that returns the next index for two list where the criteria is met.\n *\n * It can compare two lists out of sync considering it does a circular iteration over them.\n *\n * @example\n *\n * ```\n * const pointsA = [[0, 1], [1, 3], [1, 5], [1,2]];\n * const pointsB = [[1, 2], [1, 5], [1, 3], [0,0]];\n * let firstParam = [0, 0, pointsA]\n * let secondParam = [1, 1, pointsB]\n * const criteria = (pointA, pointB) => areSamePosition(pointA, pointB)\n * const direction = 1;\n * let result = circularFindNextIndexBy(firstParam, secondParam, criteria,direction);\n * console.log(result);\n * // prints [1, 2]\n * // use this result and find again\n * firstParam = [result[0]+1, result[0], pointsA]\n * secondParam = [result[1]+1, result[1], pointsB]\n * result = circularFindNextIndexBy(firstParam, secondParam, criteria,direction);\n * * // prints [3, 0]\n *\n */\nfunction circularFindNextIndexBy(\n  listParams: ListParamsType,\n  otherListParams: ListParamsType,\n  criteria: (pointA: Types.Point2, pointB: Types.Point2) => boolean,\n  direction: number\n): [number | undefined, number | undefined] {\n  const [, indexDelimiter, points] = listParams;\n  const [, otherIndexDelimiter, otherPoints] = otherListParams;\n\n  const pointsLength = points.length;\n  const otherPointsLength = otherPoints.length;\n\n  let startIndex = listParams[0];\n  let otherStartIndex = otherListParams[0];\n\n  if (\n    !points[startIndex] ||\n    !otherPoints[otherStartIndex] ||\n    !points[indexDelimiter] ||\n    !otherPoints[otherIndexDelimiter]\n  ) {\n    return [undefined, undefined];\n  }\n\n  while (\n    startIndex !== indexDelimiter &&\n    otherStartIndex !== otherIndexDelimiter\n  ) {\n    if (criteria(otherPoints[otherStartIndex], points[startIndex])) {\n      return [startIndex, otherStartIndex];\n    }\n\n    startIndex = followingIndex(startIndex, pointsLength, direction);\n    otherStartIndex = followingIndex(\n      otherStartIndex,\n      otherPointsLength,\n      direction\n    );\n  }\n\n  return [undefined, undefined];\n}\n\n/**\n * Given two list it will find the first and last index of segment from points that diverges from previousPoints\n */\nfunction findChangedSegment(\n  points: Types.Point2[],\n  previousPoints: Types.Point2[]\n): [number, number] {\n  const [firstMatchIndex, previousFirstMatchIndex] =\n    findMatchIndexes(points, previousPoints) || [];\n\n  const toBeNotEqualCriteria = (pointA, pointB) =>\n    isEqualByProximity(pointA, pointB) === false;\n\n  const [lowDiffIndex, lowOtherDiffIndex] = circularFindNextIndexBy(\n    [\n      followingIndex(firstMatchIndex, points.length, 1),\n      firstMatchIndex,\n      points,\n    ],\n    [\n      followingIndex(previousFirstMatchIndex, previousPoints.length, 1),\n      previousFirstMatchIndex,\n      previousPoints,\n    ],\n    toBeNotEqualCriteria,\n    1\n  );\n\n  const [highIndex] = circularFindNextIndexBy(\n    [followingIndex(lowDiffIndex, points.length, -1), lowDiffIndex, points],\n    [\n      followingIndex(lowOtherDiffIndex, previousPoints.length, -1),\n      lowOtherDiffIndex,\n      previousPoints,\n    ],\n    toBeNotEqualCriteria,\n    -1\n  );\n\n  return [lowDiffIndex, highIndex];\n}\n\n/**\n * Interpolates the given list of points. In case there is a pointsOfReference the interpolation will occur only on segment disjoint of two list. I.e list of points from param points that are not on list of points from param pointsOfReference.\n */\nexport function getInterpolatedPoints(\n  configuration: Record<any, any>,\n  points: Types.Point2[],\n  pointsOfReference?: Types.Point2[]\n): Types.Point2[] {\n  const { interpolation } = configuration;\n\n  const result = points;\n\n  if (interpolation) {\n    const {\n      knotsRatioPercentageOnAdd,\n      knotsRatioPercentageOnEdit,\n      interpolateOnAdd = false,\n      interpolateOnEdit = false,\n    } = interpolation;\n\n    const knotsRatioPercentage = pointsOfReference\n      ? knotsRatioPercentageOnEdit\n      : knotsRatioPercentageOnAdd;\n    const isEnabled = pointsOfReference ? interpolateOnEdit : interpolateOnAdd;\n\n    if (isEnabled) {\n      // partial or total interpolation\n      const [changedIniIndex, changedEndIndex] = pointsOfReference\n        ? findChangedSegment(points, pointsOfReference)\n        : [0, points.length - 1];\n\n      // do not interpolate if there is no valid segment\n      if (!points[changedIniIndex] || !points[changedEndIndex]) {\n        return points;\n      }\n\n      return <Types.Point2[]>(\n        interpolateSegmentPoints(\n          points,\n          changedIniIndex,\n          changedEndIndex,\n          knotsRatioPercentage\n        )\n      );\n    }\n  }\n\n  return result;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport { vec2 } from 'gl-matrix';\n\n/**\n * Finds the length of the longest line from the midpoint of the line\n * that joins the start and end of the open contour, to the surface of the\n * open contour.\n */\nexport default function findOpenUShapedContourVectorToPeak(\n  canvasPoints: Types.Point2[],\n  viewport: Types.IStackViewport | Types.IVolumeViewport\n): Types.Point3[] {\n  // Find chord from first to last point.\n  const first = canvasPoints[0];\n  const last = canvasPoints[canvasPoints.length - 1];\n\n  const firstToLastUnitVector = vec2.create();\n\n  vec2.set(firstToLastUnitVector, last[0] - first[0], last[1] - first[1]);\n  vec2.normalize(firstToLastUnitVector, firstToLastUnitVector);\n\n  // Get the two possible normal vector to this vector\n  // Note: Use the identity that the perpendicular line must have a gradient of\n  // 1 / gradient of the line.\n\n  const normalVector1 = vec2.create();\n  const normalVector2 = vec2.create();\n\n  vec2.set(normalVector1, -firstToLastUnitVector[1], firstToLastUnitVector[0]);\n  vec2.set(normalVector2, firstToLastUnitVector[1], -firstToLastUnitVector[0]);\n\n  // Find the center of the chord.\n  const centerOfFirstToLast: Types.Point2 = [\n    (first[0] + last[0]) / 2,\n    (first[1] + last[1]) / 2,\n  ];\n\n  // Get furthest point.\n\n  const furthest = {\n    dist: 0,\n    index: null,\n  };\n\n  for (let i = 0; i < canvasPoints.length; i++) {\n    const canvasPoint = canvasPoints[i];\n\n    const distance = vec2.dist(canvasPoint, <vec2>centerOfFirstToLast);\n\n    if (distance > furthest.dist) {\n      furthest.dist = distance;\n      furthest.index = i;\n    }\n  }\n\n  const toFurthest: [Types.Point2, Types.Point2] = [\n    canvasPoints[furthest.index],\n    centerOfFirstToLast,\n  ];\n  const toFurthestWorld = toFurthest.map(viewport.canvasToWorld);\n\n  return toFurthestWorld;\n}\n\nexport function findOpenUShapedContourVectorToPeakOnRender(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation\n): Types.Point3[] {\n  const { viewport } = enabledElement;\n  const canvasPoints = annotation.data.contour.polyline.map(\n    viewport.worldToCanvas\n  );\n\n  return findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../../cursors/elementCursor';\nimport { Events } from '../../../enums';\nimport { EventTypes } from '../../../types';\nimport { state } from '../../../store';\nimport { vec3 } from 'gl-matrix';\nimport {\n  shouldInterpolate,\n  getInterpolatedPoints,\n} from '../../../utilities/planarFreehandROITool/interpolatePoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { polyline } from '../../../utilities/math';\nimport { removeAnnotation } from '../../../stateManagement/annotation/annotationState';\n\nconst {\n  addCanvasPointsToArray,\n  pointsAreWithinCloseContourProximity,\n  getFirstIntersectionWithPolyline,\n  getSubPixelSpacingAndXYDirections,\n} = polyline;\n\n/**\n * Activates the contour drawing event loop.\n */\nfunction activateDraw(\n  evt: EventTypes.InteractionEventType,\n  annotation: PlanarFreehandROIAnnotation,\n  viewportIdsToRender: string[]\n): void {\n  this.isDrawing = true;\n\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  this.drawData = {\n    canvasPoints: [canvasPos],\n    polylineIndex: 0,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n    movingTextBox: false,\n  };\n\n  state.isInteractingWithTool = true;\n\n  element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n  element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n\n  hideElementCursor(element);\n}\n/**\n * Dectivates and cleans up the contour drawing event loop.\n */\nfunction deactivateDraw(element: HTMLDivElement): void {\n  state.isInteractingWithTool = false;\n\n  element.removeEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n  element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n  element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n  element.removeEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n  element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n  element.removeEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n\n  resetElementCursor(element);\n}\n\n/**\n * Adds points to a set of preview canvas points of the contour being created.\n * Checks if crossing of lines means early completion and editing needs to be started.\n */\nfunction mouseDragDrawCallback(evt: EventTypes.InteractionEventType): void {\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const worldPos = currentPoints.world;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n\n  const {\n    annotation,\n    viewportIdsToRender,\n    xDir,\n    yDir,\n    spacing,\n    movingTextBox,\n  } = this.commonData;\n  const { polylineIndex, canvasPoints } = this.drawData;\n\n  const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n  const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  // Check that we have moved at least one voxel in each direction.\n  if (xDist <= spacing[0] && yDist <= spacing[1]) {\n    // Haven't changed world point enough, don't render\n    return;\n  }\n\n  if (movingTextBox) {\n    this.isDrawing = false;\n\n    // Drag mode - Move the text boxes world position\n    const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n    const worldPosDelta = deltaPoints.world;\n\n    const { textBox } = annotation.data.handles;\n    const { worldPosition } = textBox;\n\n    worldPosition[0] += worldPosDelta[0];\n    worldPosition[1] += worldPosDelta[1];\n    worldPosition[2] += worldPosDelta[2];\n\n    textBox.hasMoved = true;\n  } else {\n    const crossingIndex = this.findCrossingIndexDuringCreate(evt);\n\n    if (crossingIndex !== undefined) {\n      // If we have crossed our drawing line, create a closed contour and then\n      // start an edit.\n      this.applyCreateOnCross(evt, crossingIndex);\n    } else {\n      const numPointsAdded = addCanvasPointsToArray(\n        element,\n        canvasPoints,\n        canvasPos,\n        this.commonData\n      );\n\n      this.drawData.polylineIndex = polylineIndex + numPointsAdded;\n    }\n  }\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Completes the contour on mouse up. If the `allowOpenContours` configuration\n * option is `true`, checks if we should create an open or closed contour.\n * If the `allowOpenContours` configuration option is `false`, always creates a\n * closed contour.\n */\nfunction mouseUpDrawCallback(evt: EventTypes.InteractionEventType): void {\n  const { allowOpenContours } = this.configuration;\n  const { canvasPoints } = this.drawData;\n  const firstPoint = canvasPoints[0];\n  const lastPoint = canvasPoints[canvasPoints.length - 1];\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  if (\n    allowOpenContours &&\n    !pointsAreWithinCloseContourProximity(\n      firstPoint,\n      lastPoint,\n      this.configuration.closeContourProximity\n    )\n  ) {\n    this.completeDrawOpenContour(element);\n  } else {\n    this.completeDrawClosedContour(element);\n  }\n}\n\n/**\n * Completes the contour being drawn, creating a closed contour annotation. It will return true if contour is completed or false in case contour drawing is halted.\n */\nfunction completeDrawClosedContour(element: HTMLDivElement): boolean {\n  this.removeCrossedLinesOnCompleteDraw();\n  const { canvasPoints } = this.drawData;\n\n  // check and halt if necessary the drawing process, last chance to complete drawing and fire events.\n  if (this.haltDrawing(element, canvasPoints)) {\n    return false;\n  }\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  // Convert annotation to world coordinates\n  addCanvasPointsToArray(\n    element,\n    canvasPoints,\n    canvasPoints[0],\n    this.commonData\n  );\n  // Remove last point which will be a duplicate now.\n  canvasPoints.pop();\n\n  const updatedPoints = shouldInterpolate(this.configuration)\n    ? getInterpolatedPoints(this.configuration, canvasPoints)\n    : canvasPoints;\n\n  // Note: -> This is pretty expensive and may not scale well with hundreds of\n  // contours. A future optimisation if we use this for segmentation is to re-do\n  // this rendering with the GPU rather than SVG.\n  const worldPoints = updatedPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.contour.polyline = worldPoints;\n  annotation.data.contour.closed = true;\n  const { textBox } = annotation.data.handles;\n\n  if (!textBox.hasMoved) {\n    this.triggerAnnotationCompleted(annotation);\n  }\n\n  this.isDrawing = false;\n  this.drawData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateDraw(element);\n\n  return true;\n}\n\n/**\n * If lines are crossed during the draw loop, remove the points drawn over the\n * crossing.\n */\nfunction removeCrossedLinesOnCompleteDraw(): void {\n  const { canvasPoints } = this.drawData;\n  const numPoints = canvasPoints.length;\n\n  const endToStart = [canvasPoints[0], canvasPoints[numPoints - 1]];\n  const canvasPointsMinusEnds = canvasPoints.slice(0, -1).slice(1);\n\n  const lineSegment = getFirstIntersectionWithPolyline(\n    canvasPointsMinusEnds,\n    endToStart[0],\n    endToStart[1],\n    false\n  );\n\n  if (lineSegment) {\n    const indexToRemoveUpTo = lineSegment[1];\n\n    this.drawData.canvasPoints = canvasPoints.splice(0, indexToRemoveUpTo);\n  }\n}\n\n/**\n * Completes the contour being drawn, creating an open contour annotation. It will return true if contour is completed or false in case contour drawing is halted.\n */\nfunction completeDrawOpenContour(element: HTMLDivElement): boolean {\n  const { canvasPoints } = this.drawData;\n\n  // check and halt if necessary the drawing process, last chance to complete drawing and fire events.\n  if (this.haltDrawing(element, canvasPoints)) {\n    return false;\n  }\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const updatedPoints = shouldInterpolate(this.configuration)\n    ? getInterpolatedPoints(this.configuration, canvasPoints)\n    : canvasPoints;\n\n  // Note: -> This is pretty expensive and may not scale well with hundreds of\n  // contours. A future optimisation if we use this for segmentation is to re-do\n  // this rendering with the GPU rather than SVG.\n  const worldPoints = updatedPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.contour.polyline = worldPoints;\n  annotation.data.contour.closed = false;\n  const { textBox } = annotation.data.handles;\n\n  // Add the first and last points to the list of handles. These means they\n  // will render handles on mouse hover.\n  annotation.data.handles.points = [\n    worldPoints[0],\n    worldPoints[worldPoints.length - 1],\n  ];\n\n  // If the annotation is an open U-shaped annotation, find the annotation vector.\n  if (annotation.data.isOpenUShapeContour) {\n    annotation.data.openUShapeContourVectorToPeak =\n      findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n  }\n\n  if (!textBox.hasMoved) {\n    this.triggerAnnotationCompleted(annotation);\n  }\n\n  this.isDrawing = false;\n  this.drawData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateDraw(element);\n\n  return true;\n}\n\n/**\n * Searches for a crossing of the contour during create. If found, returns the\n * index of the point just before the lines cross.\n */\nfunction findCrossingIndexDuringCreate(\n  evt: EventTypes.InteractionEventType\n): number | undefined {\n  // Note as we super sample the added points, we need to check the whole last mouse move, not the points\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n\n  const { canvasPoints } = this.drawData;\n  const pointsLessLastOne = canvasPoints.slice(0, -1);\n\n  const lineSegment = getFirstIntersectionWithPolyline(\n    pointsLessLastOne,\n    canvasPos,\n    lastCanvasPoint,\n    false\n  );\n\n  if (lineSegment === undefined) {\n    return;\n  }\n\n  const crossingIndex = lineSegment[0];\n\n  return crossingIndex;\n}\n\n/**\n * On crossing of the draw line, create a closed contour, and then start an edit\n * since this occurs during a mouse drag.\n */\nfunction applyCreateOnCross(\n  evt: EventTypes.InteractionEventType,\n  crossingIndex: number\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const { canvasPoints } = this.drawData;\n  const { annotation, viewportIdsToRender } = this.commonData;\n\n  // Add points between the end point and crossing point\n  addCanvasPointsToArray(\n    element,\n    canvasPoints,\n    canvasPoints[crossingIndex],\n    this.commonData\n  );\n  // Remove last point which will be a duplicate now.\n  canvasPoints.pop();\n\n  // Remove points up to just before the crossing index\n  for (let i = 0; i < crossingIndex; i++) {\n    canvasPoints.shift();\n  }\n\n  if (this.completeDrawClosedContour(element)) {\n    // pos complete operation\n    this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n  }\n}\n\n/**\n * Completes the contour on a cancel method call during the draw loop.\n */\nfunction cancelDrawing(element: HTMLElement) {\n  const { allowOpenContours } = this.configuration;\n  const { canvasPoints } = this.drawData;\n  const firstPoint = canvasPoints[0];\n  const lastPoint = canvasPoints[canvasPoints.length - 1];\n\n  if (\n    allowOpenContours &&\n    !pointsAreWithinCloseContourProximity(\n      firstPoint,\n      lastPoint,\n      this.configuration.closeContourProximity\n    )\n  ) {\n    this.completeDrawOpenContour(element);\n  } else {\n    this.completeDrawClosedContour(element);\n  }\n}\n\n/**\n * Tell whether a drawing should be halted or not. It will be true when canvas points is less than the minimum required.\n */\nfunction shouldHaltDrawing(\n  canvasPoints: any,\n  subPixelResolution: number\n): boolean {\n  const minPoints = Math.max(\n    /**\n     * The number of points to span 3 voxels in length, this is a realistically\n     * smallest open contour one could reasonably define (2 voxels should probably be a line).\n     */\n    subPixelResolution * 3,\n    /**\n     * Minimum 3 points, there are other annotations for one point (probe)\n     * or 2 points (line), so this comes only from a mistake in practice.\n     */\n    3\n  );\n  return canvasPoints.length < minPoints;\n}\n\n/**\n * Check and halt a drawing for a given event. It returns true in case drawing is halted, otherswise false.\n */\nfunction haltDrawing(element: HTMLDivElement, canvasPoints: any): boolean {\n  const { subPixelResolution } = this.configuration;\n\n  if (shouldHaltDrawing(canvasPoints, subPixelResolution)) {\n    // Remove annotation instead of completing it.\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    removeAnnotation(annotation.annotationUID);\n\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.deactivateDraw(element);\n\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Registers the contour drawing loop to the tool instance.\n */\nfunction registerDrawLoop(toolInstance): void {\n  toolInstance.activateDraw = activateDraw.bind(toolInstance);\n  toolInstance.deactivateDraw = deactivateDraw.bind(toolInstance);\n\n  toolInstance.applyCreateOnCross = applyCreateOnCross.bind(toolInstance);\n  toolInstance.findCrossingIndexDuringCreate =\n    findCrossingIndexDuringCreate.bind(toolInstance);\n  toolInstance.completeDrawOpenContour =\n    completeDrawOpenContour.bind(toolInstance);\n  toolInstance.removeCrossedLinesOnCompleteDraw =\n    removeCrossedLinesOnCompleteDraw.bind(toolInstance);\n  toolInstance.mouseDragDrawCallback = mouseDragDrawCallback.bind(toolInstance);\n  toolInstance.mouseUpDrawCallback = mouseUpDrawCallback.bind(toolInstance);\n  toolInstance.completeDrawClosedContour =\n    completeDrawClosedContour.bind(toolInstance);\n  toolInstance.cancelDrawing = cancelDrawing.bind(toolInstance);\n  toolInstance.haltDrawing = haltDrawing.bind(toolInstance);\n}\n\nexport default registerDrawLoop;\n","import { Types } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\nimport { polyline } from '../../../utilities/math';\nimport { EventTypes } from '../../../types';\n\nconst { addCanvasPointsToArray, getFirstIntersectionWithPolyline } = polyline;\n\n/**\n * Check if the `editCanvasPoints` have crossed the `prevCanvasPoints` during\n * an edit.\n *\n * @privateRemarks The following tricks are required to make the UX smooth and\n * the editing not very picky on exactly where you click:\n * - If we don't cross after 2 points, but projecting the line backwards the\n * proximity distance means we cross, extend the line back.\n * - If we travel the full proximity in canvas points but don't cross a line, we\n * are likely drawing along the line, which is intuitive to the user. At this point\n * snap the start of the edit to the closest place on the `prevCanvasPoints`,\n * so that the edit can be executed in-line.\n */\nfunction checkForFirstCrossing(\n  evt: EventTypes.InteractionEventType,\n  isClosedContour: boolean\n): void {\n  const eventDetail = evt.detail;\n  const { element, currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n  const { editCanvasPoints, prevCanvasPoints } = this.editData;\n\n  const crossedLineSegment = getFirstIntersectionWithPolyline(\n    prevCanvasPoints,\n    canvasPos,\n    lastCanvasPoint,\n    isClosedContour\n  );\n\n  if (crossedLineSegment) {\n    this.editData.startCrossingIndex = crossedLineSegment[0];\n\n    // On the first crossing, remove the first lines prior to the crossing\n    this.removePointsUpUntilFirstCrossing(isClosedContour);\n    // prevent continue if there are not the minimum of points for this op.\n  } else if (prevCanvasPoints.length >= 2) {\n    if (\n      editCanvasPoints.length >\n      this.configuration.checkCanvasEditFallbackProximity\n    ) {\n      // At this point, likely we are drawing along the line, we are past the proximity for grabbing.\n      // Search for nearest line segment to the start of the edit.\n      // Set the crossing index to the lower index of the segment.\n\n      const firstEditCanvasPoint = editCanvasPoints[0];\n\n      const distanceIndexPairs = [];\n\n      for (let i = 0; i < prevCanvasPoints.length; i++) {\n        const prevCanvasPoint = prevCanvasPoints[i];\n        const distance = vec2.distance(prevCanvasPoint, firstEditCanvasPoint);\n\n        distanceIndexPairs.push({ distance, index: i });\n      }\n\n      distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n\n      const twoClosestDistanceIndexPairs = [\n        distanceIndexPairs[0],\n        distanceIndexPairs[1],\n      ];\n\n      const lowestIndex = Math.min(\n        twoClosestDistanceIndexPairs[0].index,\n        twoClosestDistanceIndexPairs[1].index\n      );\n\n      this.editData.startCrossingIndex = lowestIndex;\n    } else {\n      // Check if extending a line back 6 (Proximity) canvas pixels would cross a line.\n\n      // Extend point back 6 canvas pixels from first point.\n      const dir = vec2.create();\n\n      vec2.subtract(dir, editCanvasPoints[1], editCanvasPoints[0]);\n      vec2.normalize(dir, dir);\n\n      const proximity = 6;\n\n      const extendedPoint: Types.Point2 = [\n        editCanvasPoints[0][0] - dir[0] * proximity,\n        editCanvasPoints[0][1] - dir[1] * proximity,\n      ];\n\n      const crossedLineSegmentFromExtendedPoint =\n        getFirstIntersectionWithPolyline(\n          prevCanvasPoints,\n          extendedPoint,\n          editCanvasPoints[0],\n          isClosedContour\n        );\n\n      if (crossedLineSegmentFromExtendedPoint) {\n        // Add points.\n        const pointsToPrepend = [extendedPoint];\n\n        addCanvasPointsToArray(\n          element,\n          pointsToPrepend,\n          editCanvasPoints[0],\n          this.commonData\n        );\n\n        editCanvasPoints.unshift(...pointsToPrepend);\n\n        this.removePointsUpUntilFirstCrossing(isClosedContour);\n\n        this.editData.editIndex = editCanvasPoints.length - 1;\n        this.editData.startCrossingIndex =\n          crossedLineSegmentFromExtendedPoint[0];\n      }\n    }\n  }\n}\n\n/**\n * Removes the points from the `editCanvasPoints` up until the first crossing of\n * the `prevCanvasPoints`. This is so we can just insert this line segment\n * into the contour.\n */\nfunction removePointsUpUntilFirstCrossing(isClosedContour: boolean): void {\n  const { editCanvasPoints, prevCanvasPoints } = this.editData;\n  let numPointsToRemove = 0;\n\n  for (let i = 0; i < editCanvasPoints.length - 1; i++) {\n    const firstLine = [editCanvasPoints[i], editCanvasPoints[i + 1]];\n\n    const didCrossLine = !!getFirstIntersectionWithPolyline(\n      prevCanvasPoints,\n      firstLine[0],\n      firstLine[1],\n      isClosedContour\n    );\n\n    // Remove last element\n    numPointsToRemove++;\n\n    if (didCrossLine) {\n      break;\n    }\n  }\n\n  // Remove the points\n  editCanvasPoints.splice(0, numPointsToRemove);\n\n  this.editData.editIndex = editCanvasPoints.length - 1;\n}\n\n/**\n * Returns `true` if the `editCanvasPoints` crosses the `prevCanvasPoints` a\n * second time.\n */\nfunction checkForSecondCrossing(\n  evt: EventTypes.InteractionEventType,\n  isClosedContour: boolean\n): boolean {\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n  const { prevCanvasPoints } = this.editData;\n\n  // Note this method is looking for the first corssing found of\n  // *the lines given* to it. The parameters given to it are specified to search\n  // for the second crossing of the prevCanvasPoints, by checking if the last\n  // mouse drag crossed these. This class method is only called if the edit loop\n  // has already has a crossing earlier in the edit.\n  const crossedLineSegment = getFirstIntersectionWithPolyline(\n    prevCanvasPoints,\n    canvasPos,\n    lastCanvasPoint,\n    isClosedContour\n  );\n\n  if (!crossedLineSegment) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Removes the points from the `editCanvasPoints` after the second crossing of\n * the `prevCanvasPoints`. This is so we can just insert this line segment\n * into the contour.\n */\nfunction removePointsAfterSecondCrossing(isClosedContour: boolean): void {\n  const { prevCanvasPoints, editCanvasPoints } = this.editData;\n\n  // Remove points after the crossing\n  for (let i = editCanvasPoints.length - 1; i > 0; i--) {\n    const lastLine = [editCanvasPoints[i], editCanvasPoints[i - 1]];\n\n    const didCrossLine = !!getFirstIntersectionWithPolyline(\n      prevCanvasPoints,\n      lastLine[0],\n      lastLine[1],\n      isClosedContour\n    );\n\n    // Remove last element\n    editCanvasPoints.pop();\n\n    if (didCrossLine) {\n      break;\n    }\n  }\n}\n\n/**\n * During an edit, finds the index on the `prevCanvasPoints` that the\n * `editCanvasPoints` should snap to to create one continuous contour.\n *\n * Returns the index, but returns -1 if there is no index on the\n * `prevCanvasPoints` that can be snapped to with causing a crossing of the\n * `editCanvasPoints`.\n */\nfunction findSnapIndex(): number {\n  const { editCanvasPoints, prevCanvasPoints, startCrossingIndex } =\n    this.editData;\n\n  if (\n    startCrossingIndex === undefined // Haven't crossed line yet\n  ) {\n    return;\n  }\n\n  const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n\n  const distanceIndexPairs = [];\n\n  for (let i = 0; i < prevCanvasPoints.length; i++) {\n    const prevCanvasPoint = prevCanvasPoints[i];\n    const distance = vec2.distance(prevCanvasPoint, lastEditCanvasPoint);\n\n    distanceIndexPairs.push({ distance, index: i });\n  }\n\n  distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n\n  // Search through from shortest distance and check which snap line doesn't\n  // Cross the edit line, in most cases the snap index will just be the first one.\n  const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -1);\n\n  for (let i = 0; i < distanceIndexPairs.length; i++) {\n    const { index } = distanceIndexPairs[i];\n    const snapCanvasPosition = prevCanvasPoints[index];\n    const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n\n    const crossedLineSegment = getFirstIntersectionWithPolyline(\n      editCanvasPointsLessLastOne,\n      snapCanvasPosition,\n      lastEditCanvasPoint,\n      false // The edit line is not a closed contour\n    );\n\n    if (!crossedLineSegment) {\n      return index;\n    }\n  }\n\n  // If all of the lines caused a crossing, this means we should start a new edit.\n  // Use -1 to signify this.\n  return -1;\n}\n\n/**\n * Checks if the `editCanvasPoints` cross themselves. If they do, remove the\n * region after the cross index, these removes isolated \"island\" loops that the\n * user can draw which make closed contours no longer simple polygons, or open\n * contours twisted.\n */\nfunction checkAndRemoveCrossesOnEditLine(\n  evt: EventTypes.InteractionEventType\n): number | undefined {\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n\n  const { editCanvasPoints } = this.editData;\n\n  const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -2);\n\n  const crossedLineSegment = getFirstIntersectionWithPolyline(\n    editCanvasPointsLessLastOne,\n    canvasPos,\n    lastCanvasPoint,\n    false\n  );\n\n  if (!crossedLineSegment) {\n    return;\n  }\n\n  // We have found a crossing, remove points after the crossing, cutting off\n  // the \"island\" loop drawn.\n\n  const editIndexCrossed = crossedLineSegment[0];\n  const numPointsToRemove = editCanvasPoints.length - editIndexCrossed;\n\n  for (let i = 0; i < numPointsToRemove; i++) {\n    editCanvasPoints.pop();\n  }\n}\n\n/**\n * Registers the contour drawing loop to the tool instance.\n */\nfunction registerEditLoopCommon(toolInstance) {\n  toolInstance.checkForFirstCrossing = checkForFirstCrossing.bind(toolInstance);\n  toolInstance.removePointsUpUntilFirstCrossing =\n    removePointsUpUntilFirstCrossing.bind(toolInstance);\n  toolInstance.checkForSecondCrossing =\n    checkForSecondCrossing.bind(toolInstance);\n  toolInstance.findSnapIndex = findSnapIndex.bind(toolInstance);\n  toolInstance.removePointsAfterSecondCrossing =\n    removePointsAfterSecondCrossing.bind(toolInstance);\n  toolInstance.checkAndRemoveCrossesOnEditLine =\n    checkAndRemoveCrossesOnEditLine.bind(toolInstance);\n}\n\nexport default registerEditLoopCommon;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../../cursors/elementCursor';\nimport { EventTypes } from '../../../types';\nimport { polyline } from '../../../utilities/math';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport {\n  getInterpolatedPoints,\n  shouldInterpolate,\n} from '../../../utilities/planarFreehandROITool/interpolatePoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\n\nconst {\n  getSubPixelSpacingAndXYDirections,\n  addCanvasPointsToArray,\n  calculateAreaOfPoints,\n} = polyline;\n\n/**\n * Activates the closed contour edit event loop.\n */\nfunction activateClosedContourEdit(\n  evt: EventTypes.InteractionEventType,\n  annotation: PlanarFreehandROIAnnotation,\n  viewportIdsToRender: string[]\n): void {\n  this.isEditingClosed = true;\n\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const prevCanvasPoints = annotation.data.contour.polyline.map(\n    viewport.worldToCanvas\n  );\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  this.editData = {\n    prevCanvasPoints,\n    editCanvasPoints: [canvasPos],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n    movingTextBox: false,\n  };\n\n  state.isInteractingWithTool = true;\n\n  element.addEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  element.addEventListener(\n    Events.TOUCH_END,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  hideElementCursor(element);\n}\n\n/**\n * Dectivates and cleans up the closed contour edit event loop.\n */\nfunction deactivateClosedContourEdit(element: HTMLDivElement): void {\n  state.isInteractingWithTool = false;\n\n  element.removeEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  element.removeEventListener(\n    Events.TOUCH_END,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  resetElementCursor(element);\n}\n\n/**\n * Adds points to the edit line and calculates the preview of the edit to render.\n * Checks if an edit needs to be completed by crossing of lines, or by editing in\n * a way that requires a new edit to keep the contour a simple polygon.\n */\nfunction mouseDragClosedContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): Types.Point2[] {\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const worldPos = currentPoints.world;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n\n  const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n  const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n\n  const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n  const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  // Check that we have moved at least one voxel in each direction.\n  if (xDist <= spacing[0] && yDist <= spacing[1]) {\n    // Haven't changed world point enough, don't render\n    return;\n  }\n\n  if (startCrossingIndex !== undefined) {\n    // Edge case: If the edit line itself crosses, remove part of that edit line so we don't\n    // Get isolated regions.\n    this.checkAndRemoveCrossesOnEditLine(evt);\n  }\n\n  const numPointsAdded = addCanvasPointsToArray(\n    element,\n    editCanvasPoints,\n    canvasPos,\n    this.commonData\n  );\n\n  const currentEditIndex = editIndex + numPointsAdded;\n\n  this.editData.editIndex = currentEditIndex;\n\n  if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n    // If we haven't found the index of the first crossing yet,\n    // see if we can find it.\n    this.checkForFirstCrossing(evt, true);\n  }\n\n  this.editData.snapIndex = this.findSnapIndex();\n\n  if (this.editData.snapIndex === -1) {\n    // No point on the prevCanvasPoints for the editCanvasPoints line to\n    // snap to. Apply edit, and start a new edit as we've gone back on ourselves.\n    this.finishEditAndStartNewEdit(evt);\n    return;\n  }\n\n  this.editData.fusedCanvasPoints = this.fuseEditPointsWithClosedContour(evt);\n\n  if (\n    startCrossingIndex !== undefined &&\n    this.checkForSecondCrossing(evt, true)\n  ) {\n    // Crossed a second time, apply edit, and start a new edit from the crossing.\n    this.removePointsAfterSecondCrossing(true);\n    this.finishEditAndStartNewEdit(evt);\n  }\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Finish the current edit, and start a new one.\n */\nfunction finishEditAndStartNewEdit(evt: EventTypes.InteractionEventType): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n\n  const worldPoints = fusedCanvasPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.contour.polyline = worldPoints;\n  annotation.data.contour.closed = true;\n\n  this.triggerAnnotationModified(annotation, enabledElement);\n\n  const lastEditCanvasPoint = editCanvasPoints.pop();\n\n  this.editData = {\n    prevCanvasPoints: fusedCanvasPoints,\n    editCanvasPoints: [lastEditCanvasPoint],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n    snapIndex: undefined,\n  };\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * This method combines the contour before editing (prevCanvasPoints) with\n * the current edit (editCanvasPoints), to produce a renderable preview of the\n * edit. Upon finishing the contour, the preview generated here is written back\n * into the contour state.\n *\n * @privateRemarks In this method we combine a few tricks to find the optimal\n * contour:\n * - As the contour is closed, our edit might stradle the boundary between the\n * last and 0th point of the contour, e.g. a small edit might go from e.g. index\n * 960 to index 4. We therefore calculate two possible contours, and find the\n * one with the biggest area, which will define the actual edit the user desired.\n * - As the contour and the edit can be drawn with different chiralities, we find if\n * the edit line aligns better with the intended cross points in its current order\n * or reversed. We do this by minimising the distance between its ends and the\n * intended crossing points.\n */\nfunction fuseEditPointsWithClosedContour(\n  evt: EventTypes.InteractionEventType\n): Types.Point2[] {\n  const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } =\n    this.editData;\n\n  if (startCrossingIndex === undefined || snapIndex === undefined) {\n    return;\n  }\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Augment the editCanvasPoints array, between the end of edit and the snap index.\n  const augmentedEditCanvasPoints = [...editCanvasPoints];\n\n  addCanvasPointsToArray(\n    element,\n    augmentedEditCanvasPoints,\n    prevCanvasPoints[snapIndex],\n    this.commonData\n  );\n\n  if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n    // If any points added, remove the last point, which will be a clone of the snapIndex\n    augmentedEditCanvasPoints.pop();\n  }\n\n  // Calculate the distances between the first and last edit points and the origin of the\n  // Contour with the snap point. These will be used to see which way around the edit array should be\n  // Placed within the preview.\n  let lowIndex;\n  let highIndex;\n\n  if (startCrossingIndex > snapIndex) {\n    lowIndex = snapIndex;\n    highIndex = startCrossingIndex;\n  } else {\n    lowIndex = startCrossingIndex;\n    highIndex = snapIndex;\n  }\n\n  const distanceBetweenLowAndFirstPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenLowAndLastPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  const distanceBetweenHighAndFirstPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenHighAndLastPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  // Generate two possible contours that could be intepreted from the edit:\n  //\n  // pointSet1 => 0 -> low -> edit -> high - max.\n  // pointSet2 => low -> high -> edit\n  //\n  // Depending on the placement of the edit and the origin, either of these could be the intended edit.\n  // We'll choose the one with the largest area, as edits are considered to be changes to the original area with\n  // A relative change of much less than unity.\n\n  // Point Set 1\n  const pointSet1 = [];\n\n  // Add points from the orignal contour origin up to the low index.\n  for (let i = 0; i < lowIndex; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  // Check which orientation of the edit line minimizes the distance between the\n  // origial contour low/high points and the start/end nodes of the edit line.\n\n  let inPlaceDistance =\n    distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n\n  let reverseDistance =\n    distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n\n  if (inPlaceDistance < reverseDistance) {\n    for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  // Add points from the orignal contour's high index up to to its end point.\n  for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  // Point Set 2\n  const pointSet2 = [];\n\n  for (let i = lowIndex; i < highIndex; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  inPlaceDistance =\n    distanceBetweenHighAndFirstPoint + distanceBetweenLowAndLastPoint;\n\n  reverseDistance =\n    distanceBetweenHighAndLastPoint + distanceBetweenLowAndFirstPoint;\n\n  if (inPlaceDistance < reverseDistance) {\n    for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  const areaPointSet1 = calculateAreaOfPoints(pointSet1);\n  const areaPointSet2 = calculateAreaOfPoints(pointSet2);\n\n  const pointsToRender: Types.Point2[] =\n    areaPointSet1 > areaPointSet2 ? pointSet1 : pointSet2;\n\n  return pointsToRender;\n}\n\n/**\n * Completes the edit of the closed contour when the mouse button is released.\n */\nfunction mouseUpClosedContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  this.completeClosedContourEdit(element);\n}\n\n/**\n * Completes the edit of the closed contour when the mouse button is released.\n */\nfunction completeClosedContourEdit(element: HTMLDivElement) {\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints) {\n    const updatedPoints = shouldInterpolate(this.configuration)\n      ? getInterpolatedPoints(\n          this.configuration,\n          fusedCanvasPoints,\n          prevCanvasPoints\n        )\n      : fusedCanvasPoints;\n\n    const worldPoints = updatedPoints.map((canvasPoint) =>\n      viewport.canvasToWorld(canvasPoint)\n    );\n    annotation.data.contour.polyline = worldPoints;\n    annotation.data.contour.closed = true;\n\n    annotation.invalidated = true;\n\n    this.triggerAnnotationModified(annotation, enabledElement);\n  }\n\n  this.isEditingClosed = false;\n  this.editData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateClosedContourEdit(element);\n}\n\n/**\n * Completes the edit on a cancel method call during the closed\n * contour edit loop.\n */\nfunction cancelClosedContourEdit(element: HTMLDivElement) {\n  this.completeClosedContourEdit(element);\n}\n\n/**\n * Registers the closed contour edit loop to the tool instance.\n */\nfunction registerClosedContourEditLoop(toolInstance): void {\n  toolInstance.activateClosedContourEdit =\n    activateClosedContourEdit.bind(toolInstance);\n  toolInstance.deactivateClosedContourEdit =\n    deactivateClosedContourEdit.bind(toolInstance);\n  toolInstance.mouseDragClosedContourEditCallback =\n    mouseDragClosedContourEditCallback.bind(toolInstance);\n  toolInstance.mouseUpClosedContourEditCallback =\n    mouseUpClosedContourEditCallback.bind(toolInstance);\n  toolInstance.finishEditAndStartNewEdit =\n    finishEditAndStartNewEdit.bind(toolInstance);\n  toolInstance.fuseEditPointsWithClosedContour =\n    fuseEditPointsWithClosedContour.bind(toolInstance);\n  toolInstance.cancelClosedContourEdit =\n    cancelClosedContourEdit.bind(toolInstance);\n  toolInstance.completeClosedContourEdit =\n    completeClosedContourEdit.bind(toolInstance);\n}\n\nexport default registerClosedContourEditLoop;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../../cursors/elementCursor';\nimport type { EventTypes } from '../../../types';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { polyline } from '../../../utilities/math';\nimport {\n  shouldInterpolate,\n  getInterpolatedPoints,\n} from '../../../utilities/planarFreehandROITool/interpolatePoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\n\nconst { addCanvasPointsToArray, getSubPixelSpacingAndXYDirections } = polyline;\n\n/**\n * Activates the open contour edit event loop.\n */\nfunction activateOpenContourEdit(\n  evt: EventTypes.InteractionEventType,\n  annotation: PlanarFreehandROIAnnotation,\n  viewportIdsToRender: string[]\n): void {\n  this.isEditingOpen = true;\n\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const prevCanvasPoints = annotation.data.contour.polyline.map(\n    viewport.worldToCanvas\n  );\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  this.editData = {\n    prevCanvasPoints,\n    editCanvasPoints: [canvasPos],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n    movingTextBox: false,\n  };\n\n  state.isInteractingWithTool = true;\n\n  element.addEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpOpenContourEditCallback\n  );\n\n  element.addEventListener(\n    Events.TOUCH_END,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpOpenContourEditCallback\n  );\n  hideElementCursor(element);\n}\n\n/**\n * Deactivates and cleans up the closed contour edit event loop.\n */\nfunction deactivateOpenContourEdit(element: HTMLDivElement) {\n  state.isInteractingWithTool = false;\n\n  element.removeEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpOpenContourEditCallback\n  );\n\n  element.removeEventListener(\n    Events.TOUCH_END,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpOpenContourEditCallback\n  );\n  resetElementCursor(element);\n}\n\n/**\n * Adds points to the edit line and calculates the preview of the edit to render.\n * Checks if an edit needs to be completed by crossing of lines, or by dragging\n * the edit line past the end of the open contour.\n */\nfunction mouseDragOpenContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): boolean {\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const worldPos = currentPoints.world;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n\n  const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n  const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n\n  const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n  const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  // Get pixel spacing in the direction.\n  // Check that we have moved at least one voxel in each direction.\n\n  if (xDist <= spacing[0] && yDist <= spacing[1]) {\n    // Haven't changed world point enough, don't render\n    return;\n  }\n\n  if (startCrossingIndex !== undefined) {\n    // Edge case: If the edit line itself crosses, remove part of that edit line so we don't\n    // Get isolated regions.\n    this.checkAndRemoveCrossesOnEditLine(evt);\n  }\n\n  const numPointsAdded = addCanvasPointsToArray(\n    element,\n    editCanvasPoints,\n    canvasPos,\n    this.commonData\n  );\n\n  const currentEditIndex = editIndex + numPointsAdded;\n\n  this.editData.editIndex = currentEditIndex;\n\n  if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n    this.checkForFirstCrossing(evt, false);\n  }\n\n  this.editData.snapIndex = this.findSnapIndex();\n\n  this.editData.fusedCanvasPoints = this.fuseEditPointsWithOpenContour(evt);\n\n  if (\n    startCrossingIndex !== undefined &&\n    this.checkForSecondCrossing(evt, false)\n  ) {\n    this.removePointsAfterSecondCrossing(false);\n    this.finishEditOpenOnSecondCrossing(evt);\n  } else if (this.checkIfShouldOverwriteAnEnd(evt)) {\n    this.openContourEditOverwriteEnd(evt);\n  }\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Overwrite the end of the contour with the edit, and then switch to the\n * open contour end edit loop.\n */\nfunction openContourEditOverwriteEnd(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const fusedCanvasPoints = this.fuseEditPointsForOpenContourEndEdit();\n\n  const worldPoints = fusedCanvasPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.contour.polyline = worldPoints;\n  annotation.data.contour.closed = false;\n  // Note: Contours generate from fusedCanvasPoints will be in the direction\n  // with the last point being the current mouse position\n  annotation.data.handles.points = [\n    worldPoints[0],\n    worldPoints[worldPoints.length - 1],\n  ];\n  annotation.data.handles.activeHandleIndex = 1;\n\n  this.triggerAnnotationModified(annotation, enabledElement);\n\n  this.isEditingOpen = false;\n  this.editData = undefined;\n  this.commonData = undefined;\n\n  // Jump to a normal line edit now.\n  this.deactivateOpenContourEdit(element);\n  this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, null);\n}\n\n/**\n * Checks if we are moving the `editCanvasPoints` past the end of one of the\n * open contour's `prevCanvasPoint`s.\n */\nfunction checkIfShouldOverwriteAnEnd(\n  evt: EventTypes.InteractionEventType\n): boolean {\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPos = lastPoints.canvas;\n\n  const { snapIndex, prevCanvasPoints, startCrossingIndex } = this.editData;\n\n  if (startCrossingIndex === undefined || snapIndex === undefined) {\n    // Edit not started\n    return false;\n  }\n\n  // No snap index can be found, so contour is being edited away from line.\n  if (snapIndex === -1) {\n    return true;\n  }\n\n  if (snapIndex !== 0 && snapIndex !== prevCanvasPoints.length - 1) {\n    // Not snapping to final index\n    return false;\n  }\n\n  // Work out the angle between the last mouse move and\n  // And the current point to the snapped point.\n  const p1 = canvasPos;\n  const p2 = lastCanvasPos;\n  const p3 = prevCanvasPoints[snapIndex];\n\n  const a = vec2.create();\n  const b = vec2.create();\n\n  vec2.set(a, p1[0] - p2[0], p1[1] - p2[1]);\n  vec2.set(b, p1[0] - p3[0], p1[1] - p3[1]);\n\n  const aDotb = vec2.dot(a, b);\n  const magA = Math.sqrt(a[0] * a[0] + a[1] * a[1]);\n  const magB = Math.sqrt(b[0] * b[0] + b[1] * b[1]);\n\n  const theta = Math.acos(aDotb / (magA * magB));\n\n  if (theta < Math.PI / 2) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * This method combines the contour before editing (prevCanvasPoints) with\n * the current edit (editCanvasPoints), to produce a single contour ready for\n * end editing.\n *\n * @privateRemarks In this method we use the following trick to find the\n * optimal contour:\n * - As the contour and the edit can be drawn with different chiralities, we find if\n * the edit line aligns better with the intended cross points in its current order\n * or reversed. We do this by minimising the distance between its ends and the\n * intended crossing points.\n */\nfunction fuseEditPointsForOpenContourEndEdit(): Types.Point2[] {\n  const { snapIndex, prevCanvasPoints, editCanvasPoints, startCrossingIndex } =\n    this.editData;\n\n  const newCanvasPoints = [];\n\n  // Note: Generated contours will both be in the direction with the\n  // last point being the current mouse position\n\n  if (snapIndex === 0) {\n    // end -> crossingpoint -> edit\n    // Add points from the end of the previous contour, to the crossing point.\n    for (let i = prevCanvasPoints.length - 1; i >= startCrossingIndex; i--) {\n      const canvasPoint = prevCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    // start -> crossingpoint -> edit\n    // Add points from the orignal contour origin up to the low index.\n    for (let i = 0; i < startCrossingIndex; i++) {\n      const canvasPoint = prevCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  const distanceBetweenCrossingIndexAndFirstPoint = vec2.distance(\n    prevCanvasPoints[startCrossingIndex],\n    editCanvasPoints[0]\n  );\n\n  const distanceBetweenCrossingIndexAndLastPoint = vec2.distance(\n    prevCanvasPoints[startCrossingIndex],\n    editCanvasPoints[editCanvasPoints.length - 1]\n  );\n\n  if (\n    distanceBetweenCrossingIndexAndFirstPoint <\n    distanceBetweenCrossingIndexAndLastPoint\n  ) {\n    // In order\n    for (let i = 0; i < editCanvasPoints.length; i++) {\n      const canvasPoint = editCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    // reverse\n    for (let i = editCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = editCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  return newCanvasPoints;\n}\n\n/**\n * This method combines the contour before editing (prevCanvasPoints) with\n * the current edit (editCanvasPoints), to produce a renderable preview of the\n * edit. Upon finishing the contour, the preview generated here is written back\n * into the contour state.\n *\n * @privateRemarks In this method we use the following trick to find the\n * optimal contour:\n * - As the contour and the edit can be drawn with different chiralities, we find if\n * the edit line aligns better with the intended cross points in its current order\n * or reversed. We do this by minimising the distance between its ends and the\n * intended crossing points.\n */\nfunction fuseEditPointsWithOpenContour(\n  evt: EventTypes.InteractionEventType\n): Types.Point2[] {\n  const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } =\n    this.editData;\n\n  if (startCrossingIndex === undefined || snapIndex === undefined) {\n    return undefined;\n  }\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Augment the editCanvasPoints array, between the end of edit and the snap index.\n  const augmentedEditCanvasPoints = [...editCanvasPoints];\n\n  addCanvasPointsToArray(\n    element,\n    augmentedEditCanvasPoints,\n    prevCanvasPoints[snapIndex],\n    this.commonData\n  );\n\n  if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n    // If any points added, remove the last point, which will be a clone of the snapIndex\n    augmentedEditCanvasPoints.pop();\n  }\n\n  // Calculate the distances between the first and last edit points and the origin of the\n  // Contour with the snap point. These will be used to see which way around the edit array should be\n  // Placed within the preview.\n\n  let lowIndex;\n  let highIndex;\n\n  if (startCrossingIndex > snapIndex) {\n    lowIndex = snapIndex;\n    highIndex = startCrossingIndex;\n  } else {\n    lowIndex = startCrossingIndex;\n    highIndex = snapIndex;\n  }\n\n  const distanceBetweenLowAndFirstPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenLowAndLastPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  const distanceBetweenHighAndFirstPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenHighAndLastPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  const pointsToRender = [];\n\n  // Add points from the orignal contour origin up to the low index.\n  for (let i = 0; i < lowIndex; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  // Check which orientation of the edit line minimizes the distance between the\n  // origial contour low/high points and the start/end nodes of the edit line.\n\n  const inPlaceDistance =\n    distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n\n  const reverseDistance =\n    distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n\n  if (inPlaceDistance < reverseDistance) {\n    for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  // Add points from the original contour's high index up to to its end point.\n  for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  return pointsToRender;\n}\n\n/**\n * On a second crossing, apply edit, and start a new edit from the crossing.\n */\nfunction finishEditOpenOnSecondCrossing(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n\n  const worldPoints = fusedCanvasPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.contour.polyline = worldPoints;\n  annotation.data.contour.closed = false;\n  annotation.data.handles.points = [\n    worldPoints[0],\n    worldPoints[worldPoints.length - 1],\n  ];\n\n  this.triggerAnnotationModified(annotation, enabledElement);\n\n  const lastEditCanvasPoint = editCanvasPoints.pop();\n\n  this.editData = {\n    prevCanvasPoints: fusedCanvasPoints,\n    editCanvasPoints: [lastEditCanvasPoint],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n  };\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Completes the edit of the open contour when the mouse button is released.\n */\nfunction mouseUpOpenContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  this.completeOpenContourEdit(element);\n}\n\n/**\n * Completes the edit of the open contour.\n */\nfunction completeOpenContourEdit(element: HTMLDivElement) {\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints) {\n    const updatedPoints = shouldInterpolate(this.configuration)\n      ? getInterpolatedPoints(\n          this.configuration,\n          fusedCanvasPoints,\n          prevCanvasPoints\n        )\n      : fusedCanvasPoints;\n\n    const worldPoints = updatedPoints.map((canvasPoint) =>\n      viewport.canvasToWorld(canvasPoint)\n    );\n    annotation.data.contour.polyline = worldPoints;\n    annotation.data.contour.closed = false;\n    annotation.data.handles.points = [\n      worldPoints[0],\n      worldPoints[worldPoints.length - 1],\n    ];\n\n    // If the annotation is an open U-shaped annotation, find the annotation vector.\n    if (annotation.data.isOpenUShapeContour) {\n      annotation.data.openUShapeContourVectorToPeak =\n        findOpenUShapedContourVectorToPeak(fusedCanvasPoints, viewport);\n    }\n\n    annotation.invalidated = true;\n\n    this.triggerAnnotationModified(annotation, enabledElement);\n  }\n\n  this.isEditingOpen = false;\n  this.editData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateOpenContourEdit(element);\n}\n\n/**\n * Completes the edit on a cancel method call during the open\n * contour edit loop.\n */\nfunction cancelOpenContourEdit(element: HTMLDivElement) {\n  this.completeOpenContourEdit(element);\n}\n\n/**\n * Registers the open contour edit loop to the tool instance.\n */\nfunction registerOpenContourEditLoop(toolInstance) {\n  toolInstance.activateOpenContourEdit =\n    activateOpenContourEdit.bind(toolInstance);\n  toolInstance.deactivateOpenContourEdit =\n    deactivateOpenContourEdit.bind(toolInstance);\n  toolInstance.mouseDragOpenContourEditCallback =\n    mouseDragOpenContourEditCallback.bind(toolInstance);\n  toolInstance.mouseUpOpenContourEditCallback =\n    mouseUpOpenContourEditCallback.bind(toolInstance);\n  toolInstance.fuseEditPointsWithOpenContour =\n    fuseEditPointsWithOpenContour.bind(toolInstance);\n  toolInstance.finishEditOpenOnSecondCrossing =\n    finishEditOpenOnSecondCrossing.bind(toolInstance);\n  toolInstance.checkIfShouldOverwriteAnEnd =\n    checkIfShouldOverwriteAnEnd.bind(toolInstance);\n  toolInstance.fuseEditPointsForOpenContourEndEdit =\n    fuseEditPointsForOpenContourEndEdit.bind(toolInstance);\n  toolInstance.openContourEditOverwriteEnd =\n    openContourEditOverwriteEnd.bind(toolInstance);\n  toolInstance.cancelOpenContourEdit = cancelOpenContourEdit.bind(toolInstance);\n  toolInstance.completeOpenContourEdit =\n    completeOpenContourEdit.bind(toolInstance);\n}\n\nexport default registerOpenContourEditLoop;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport { hideElementCursor } from '../../../cursors/elementCursor';\nimport type {\n  EventTypes,\n  Annotation,\n  ToolHandle,\n  TextBoxHandle,\n} from '../../../types';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport { polyline } from '../../../utilities/math';\n\nconst { getSubPixelSpacingAndXYDirections } = polyline;\n\n/**\n * Activates the open contour end edit. This actually just sets up the state so\n * that the tool thinks we are mid draw, and then jumps into the drawing loop.\n */\nfunction activateOpenContourEndEdit(\n  evt: EventTypes.InteractionEventType,\n  annotation: PlanarFreehandROIAnnotation,\n  viewportIdsToRender: string[],\n  handle: ToolHandle | null\n): void {\n  this.isDrawing = true;\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  const canvasPoints = annotation.data.contour.polyline.map(\n    viewport.worldToCanvas\n  );\n  const handleIndexGrabbed = annotation.data.handles.activeHandleIndex;\n\n  // If 0, invert point direction, if 1, keep point direction the same.\n  // This is so we can just jump as into the state as if the annotation was just being drawn.\n  if (handleIndexGrabbed === 0) {\n    canvasPoints.reverse();\n  }\n\n  let movingTextBox = false;\n  if ((handle as TextBoxHandle).worldPosition) {\n    movingTextBox = true;\n  }\n\n  this.drawData = {\n    canvasPoints: canvasPoints,\n    polylineIndex: canvasPoints.length - 1,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n    movingTextBox,\n  };\n\n  state.isInteractingWithTool = true;\n\n  // Jump into drawing loop.\n  element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n  element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n\n  hideElementCursor(element);\n}\n\n/**\n * Registers the open contour end edit loop to the tool instance.\n */\nfunction registerOpenContourEndEditLoop(toolInstance): void {\n  toolInstance.activateOpenContourEndEdit =\n    activateOpenContourEndEdit.bind(toolInstance);\n}\n\nexport default registerOpenContourEndEditLoop;\n","import type { Types } from '@cornerstonejs/core';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawPolyline as drawPolylineSvg,\n} from '../../../drawingSvg';\nimport { polyline } from '../../../utilities/math';\nimport { findOpenUShapedContourVectorToPeakOnRender } from './findOpenUShapedContourVectorToPeak';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../../types/AnnotationStyle';\nimport { SVGDrawingHelper } from '../../../types';\n\nconst { pointsAreWithinCloseContourProximity } = polyline;\n\ntype PlanarFreehandROIRenderOptions = {\n  color?: string;\n  width?: number;\n  connectFirstToLast?: boolean;\n};\n\nfunction _getRenderingOptions(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation\n): PlanarFreehandROIRenderOptions {\n  const styleSpecifier: StyleSpecifier = {\n    toolGroupId: this.toolGroupId,\n    toolName: this.getToolName(),\n    viewportId: enabledElement.viewport.id,\n    annotationUID: annotation.annotationUID,\n  };\n\n  const { lineWidth, lineDash, color, fillColor, fillOpacity } =\n    this.getAnnotationStyle({\n      annotation,\n      styleSpecifier,\n    });\n\n  const { closed: isClosedContour } = annotation.data.contour;\n\n  const options = {\n    color,\n    width: lineWidth,\n    lineDash,\n    fillColor,\n    fillOpacity,\n    connectLastToFirst: isClosedContour,\n  };\n\n  return options;\n}\n\n/**\n * Renders a `PlanarFreehandROIAnnotation` that is not currently being drawn or edited.\n */\nfunction renderContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  // prevent drawing or further calculation in case viewport data is not ready yet\n  if (!enabledElement?.viewport?.getImageData()) {\n    return;\n  }\n  // Check if the contour is an open contour\n  if (annotation.data.contour.closed) {\n    this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n  } else {\n    // If its an open contour, check i its a U-shaped contour\n    if (annotation.data.isOpenUShapeContour) {\n      calculateUShapeContourVectorToPeakIfNotPresent(\n        enabledElement,\n        annotation\n      );\n\n      this.renderOpenUShapedContour(\n        enabledElement,\n        svgDrawingHelper,\n        annotation\n      );\n    } else {\n      // If not a U-shaped contour, render standard open contour.\n      this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n    }\n  }\n}\n\n/**\n * If the open U-shaped contour does not have a peak.\n */\nfunction calculateUShapeContourVectorToPeakIfNotPresent(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  if (!annotation.data.openUShapeContourVectorToPeak) {\n    // Annotation just been set to be an open U-shaped contour.\n    // calculate its peak vector here.\n    annotation.data.openUShapeContourVectorToPeak =\n      findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation);\n  }\n}\n\n/**\n * Renders an closed `PlanarFreehandROIAnnotation` annotation.\n */\nfunction renderClosedContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const { viewport } = enabledElement;\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  // Its unfortunate that we have to do this for each annotation,\n  // Even if its unchanged. In the future we could cache the canvas points per\n  // element on the tool? That feels very weird also as we'd need to manage\n  // it/clean them up. Its a pre-optimisation for now and we can tackle it if it\n  // becomes a problem.\n  const canvasPoints = annotation.data.contour.polyline.map((worldPos) =>\n    viewport.worldToCanvas(worldPos)\n  );\n\n  const polylineUID = '1';\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUID,\n    canvasPoints,\n    options\n  );\n}\n\n/**\n * Renders an open `PlanarFreehandROIAnnotation` annotation.\n */\nfunction renderOpenContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const { viewport } = enabledElement;\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  const canvasPoints = annotation.data.contour.polyline.map((worldPos) =>\n    viewport.worldToCanvas(worldPos)\n  );\n\n  const polylineUID = '1';\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUID,\n    canvasPoints,\n    options\n  );\n\n  const activeHandleIndex = annotation.data.handles.activeHandleIndex;\n\n  if (this.configuration.alwaysRenderOpenContourHandles?.enabled === true) {\n    const radius = this.configuration.alwaysRenderOpenContourHandles.radius;\n\n    // Draw highlighted points\n    const handleGroupUID = '0';\n\n    // We already mapped all the points, so don't do the mapping again.\n    // The activeHandleIndex can only be one of two points.\n    const handlePoints = [\n      canvasPoints[0],\n      canvasPoints[canvasPoints.length - 1],\n    ];\n\n    // Don't render a hovered handle, as this will be rendered larger in\n    // the next block.\n    if (activeHandleIndex === 0) {\n      handlePoints.shift();\n    } else if (activeHandleIndex === 1) {\n      handlePoints.pop();\n    }\n\n    drawHandlesSvg(\n      svgDrawingHelper,\n      annotation.annotationUID,\n      handleGroupUID,\n      handlePoints,\n      {\n        color: options.color,\n        handleRadius: radius,\n      }\n    );\n  }\n\n  if (activeHandleIndex !== null) {\n    // Draw highlighted points\n    const handleGroupUID = '1';\n\n    // We already mapped all the points, so don't do the mapping again.\n    // The activeHandleIndex can only be one of two points.\n    const indexOfCanvasPoints =\n      activeHandleIndex === 0 ? 0 : canvasPoints.length - 1;\n\n    const handlePoint = canvasPoints[indexOfCanvasPoints];\n\n    drawHandlesSvg(\n      svgDrawingHelper,\n      annotation.annotationUID,\n      handleGroupUID,\n      [handlePoint],\n      { color: options.color }\n    );\n  }\n}\n\nfunction renderOpenUShapedContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const { viewport } = enabledElement;\n  const { openUShapeContourVectorToPeak } = annotation.data;\n  const { polyline } = annotation.data.contour;\n\n  this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n\n  // prevent rendering u shape in case openUShapeContourVectorToPeak is not set yet\n  if (!openUShapeContourVectorToPeak) {\n    return;\n  }\n\n  const firstCanvasPoint = viewport.worldToCanvas(polyline[0]);\n  const lastCanvasPoint = viewport.worldToCanvas(polyline[polyline.length - 1]);\n\n  const openUShapeContourVectorToPeakCanvas = [\n    viewport.worldToCanvas(openUShapeContourVectorToPeak[0]),\n    viewport.worldToCanvas(openUShapeContourVectorToPeak[1]),\n  ];\n\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  // Join first and last points\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    'first-to-last',\n    [firstCanvasPoint, lastCanvasPoint],\n    {\n      color: options.color,\n      width: options.width,\n      connectLastToFirst: false,\n      lineDash: '2,2',\n    }\n  );\n\n  // Render midpoint to open contour surface line\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    'midpoint-to-open-contour',\n    [\n      openUShapeContourVectorToPeakCanvas[0],\n      openUShapeContourVectorToPeakCanvas[1],\n    ],\n    {\n      color: options.color,\n      width: options.width,\n      connectLastToFirst: false,\n      lineDash: '2,2',\n    }\n  );\n}\n\n/**\n * Renders a new `PlanarFreehandROIAnnotation` annotation during\n * creation/drawing.\n */\nfunction renderContourBeingDrawn(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  const { allowOpenContours } = this.configuration;\n  const { canvasPoints } = this.drawData;\n\n  // Override rendering whilst drawing the contour, we don't know if its open\n  // or closed yet\n  options.connectLastToFirst = false;\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    '1',\n    canvasPoints,\n    options\n  );\n\n  if (allowOpenContours) {\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n\n    // Check if start and end are within close proximity\n    if (\n      pointsAreWithinCloseContourProximity(\n        firstPoint,\n        lastPoint,\n        this.configuration.closeContourProximity\n      )\n    ) {\n      // Preview join last points\n      drawPolylineSvg(\n        svgDrawingHelper,\n        annotation.annotationUID,\n        '2',\n        [lastPoint, firstPoint],\n        options\n      );\n    } else {\n      // Draw start point\n      const handleGroupUID = '0';\n\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotation.annotationUID,\n        handleGroupUID,\n        [firstPoint],\n        { color: options.color, handleRadius: 2 }\n      );\n    }\n  }\n}\n\n/**\n * Renders a closed `PlanarFreehandROIAnnotation` being edited.\n */\nfunction renderClosedContourBeingEdited(\n  enabledElement,\n  svgDrawingHelper,\n  annotation\n): void {\n  const { fusedCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints === undefined) {\n    // No edit to render yet, render closed contour.\n    this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n\n    return;\n  }\n\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  const polylineUIDToRender = 'preview-1';\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUIDToRender,\n    fusedCanvasPoints,\n    options\n  );\n}\n\n/**\n * Renders an open `PlanarFreehandROIAnnotation` being edited.\n */\nfunction renderOpenContourBeingEdited(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const { fusedCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints === undefined) {\n    // No edit to render yet, render closed contour.\n    this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n\n    return;\n  }\n\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  const polylineUIDToRender = 'preview-1';\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUIDToRender,\n    fusedCanvasPoints,\n    options\n  );\n}\n\n/**\n * Registers the render methods of various contour states to the tool instance.\n */\nfunction registerRenderMethods(toolInstance) {\n  toolInstance.renderContour = renderContour.bind(toolInstance);\n  toolInstance.renderClosedContour = renderClosedContour.bind(toolInstance);\n  toolInstance.renderOpenContour = renderOpenContour.bind(toolInstance);\n  toolInstance.renderOpenUShapedContour =\n    renderOpenUShapedContour.bind(toolInstance);\n\n  toolInstance.renderContourBeingDrawn =\n    renderContourBeingDrawn.bind(toolInstance);\n\n  toolInstance.renderClosedContourBeingEdited =\n    renderClosedContourBeingEdited.bind(toolInstance);\n  toolInstance.renderOpenContourBeingEdited =\n    renderOpenContourBeingEdited.bind(toolInstance);\n  toolInstance._getRenderingOptions = _getRenderingOptions.bind(toolInstance);\n}\n\nexport default registerRenderMethods;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../../stateManagement/annotation/annotationState';\nimport {\n  Annotation,\n  ContourAnnotation,\n  EventTypes,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { drawPolyline as drawPolylineSvg } from '../../drawingSvg';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport AnnotationTool from './AnnotationTool';\n\n/**\n * A contour base class responsible for rendering contour instances such as\n * spline, freehand and livewire.\n */\nabstract class ContourBaseTool extends AnnotationTool {\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * it is used to draw the annotation in each request animation frame. It\n   * calculates the updated cached statistics if data is invalidated and cache it.\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  public renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as Annotation;\n\n      styleSpecifier.annotationUID = annotation.annotationUID;\n\n      const annotationStyle = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      if (!annotationStyle.visibility) {\n        continue;\n      }\n\n      const annotationRendered = this.renderAnnotationInstance({\n        enabledElement,\n        targetId,\n        annotation,\n        annotationStyle,\n        svgDrawingHelper,\n      });\n\n      renderStatus ||= annotationRendered;\n      annotation.invalidated = false;\n    }\n\n    return renderStatus;\n  }\n\n  protected createAnnotation(evt: EventTypes.InteractionEventType): Annotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const { world: worldPos } = currentPoints;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    return <ContourAnnotation>{\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        contour: {\n          polyline: [],\n          closed: false,\n        },\n      },\n    };\n  }\n\n  /**\n   * Add the annotation to the annotation manager.\n   * @param annotation - Contour annotation that is being added\n   * @param element - HTMLDivElement\n   */\n  protected addAnnotation(\n    annotation: Annotation,\n    element: HTMLDivElement\n  ): string {\n    // Just to give a chance for child classes to override it\n    return addAnnotation(annotation, element);\n  }\n\n  /**\n   * Cancel an annotation when drawing.\n   * @param annotation - Contour annotation that is being added\n   * @param element - HTMLDivElement\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected cancelAnnotation(annotation: Annotation): void {\n    // noop method just to give a chance for child classes to override it\n  }\n\n  /**\n   * Get polyline points in world space.\n   * Just to give a chance for child classes to override it.\n   * @param annotation - Contour annotation\n   * @returns Polyline points in world space\n   */\n  protected getPolylinePoints(annotation: ContourAnnotation): Types.Point3[] {\n    // Attenttion: `contour.polyline` is the new way to store a polyline but it\n    // may be undefined because it was `data.polyline` before (fallback)\n    return annotation.data.contour?.polyline ?? annotation.data.polyline;\n  }\n\n  /**\n   * Render a contour segmentation instance\n   */\n  protected renderAnnotationInstance(renderContext: {\n    enabledElement: Types.IEnabledElement;\n    targetId: string;\n    annotation: Annotation;\n    annotationStyle: Record<string, any>;\n    svgDrawingHelper: SVGDrawingHelper;\n  }): boolean {\n    const { enabledElement, annotationStyle, svgDrawingHelper } = renderContext;\n    const annotation = renderContext.annotation as ContourAnnotation;\n    const { annotationUID } = annotation;\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const polylineCanvasPoints = this.getPolylinePoints(annotation).map(\n      (point) => worldToCanvas(point)\n    );\n    const { lineWidth, lineDash, color, fillColor, fillOpacity } =\n      annotationStyle;\n\n    drawPolylineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      'contourPolyline',\n      polylineCanvasPoints,\n      {\n        color,\n        lineDash,\n        lineWidth: Math.max(0.1, lineWidth),\n        fillColor: fillColor,\n        fillOpacity,\n      }\n    );\n\n    return true;\n  }\n}\n\nexport { ContourBaseTool as default, ContourBaseTool };\n","import { utilities } from '@cornerstonejs/core';\nimport {\n  Annotation,\n  EventTypes,\n  PublicToolProps,\n  ToolProps,\n} from '../../types';\nimport {\n  config as segmentationConfig,\n  state as segmentationState,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\nimport { ContourSegmentationAnnotation } from '../../types/ContourSegmentationAnnotation';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { SegmentationRepresentations } from '../../enums';\nimport ContourBaseTool from './ContourBaseTool';\n\n/**\n * A base contour segmentation class responsible for rendering, registering\n * and unregistering contour segmentation annotations.\n */\nabstract class ContourSegmentationBaseTool extends ContourBaseTool {\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Allow children classes inherit from this one and disable contour segmentation\n   * behavior and children classes shall work like a normal contour instance which\n   * is useful for \"hybrid\" classes such as splineROI/splineSeg, livewire/livewireSeg,\n   * freehandROI/freehandSeg. When this method returns false:\n   *   - contour segmentation data is not added to new annotations\n   *   - annotations are not registered/unregistered as segmentations\n   *   - annotation style shall not contain any segmentation style\n   * @returns True if it is a contour segmentation class or false otherwise\n   */\n  protected isContourSegmentationTool(): boolean {\n    return true;\n  }\n\n  protected createAnnotation(evt: EventTypes.InteractionEventType): Annotation {\n    const { toolGroupId } = this;\n    const contourAnnotation = super.createAnnotation(evt);\n\n    if (!this.isContourSegmentationTool()) {\n      return contourAnnotation;\n    }\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { type: segmentationType } = activeSegmentationRepresentation;\n\n    if (segmentationType !== SegmentationRepresentations.Contour) {\n      throw new Error(`A contour segmentation must be active`);\n    }\n\n    const { segmentationId, segmentationRepresentationUID } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n\n    return <ContourSegmentationAnnotation>utilities.deepMerge(\n      contourAnnotation,\n      {\n        data: {\n          segmentation: {\n            segmentationId,\n            segmentIndex,\n            segmentationRepresentationUID,\n          },\n        },\n      }\n    );\n  }\n\n  protected addAnnotation(\n    annotation: Annotation,\n    element: HTMLDivElement\n  ): string {\n    const annotationUID = super.addAnnotation(annotation, element);\n\n    if (this.isContourSegmentationTool()) {\n      this._registerContourSegmentationAnnotation(\n        annotation as ContourSegmentationAnnotation\n      );\n    }\n\n    return annotationUID;\n  }\n\n  /**\n   * Unregister the segmentation when the annotation is canceled\n   * @param annotation - Contour segmentation annotation\n   */\n  protected cancelAnnotation(annotation: Annotation): void {\n    if (this.isContourSegmentationTool()) {\n      this._unregisterContourSegmentationAnnotation(\n        annotation as ContourSegmentationAnnotation\n      );\n    }\n\n    super.cancelAnnotation(annotation);\n  }\n\n  /**\n   * Get the annotation style that may or may not be merged with segmentation\n   * style so that it can be used by ROI and contour segmentation annotations\n   * when rendered on a canvas or svg layer.\n   *\n   * Segmentation style shall be a combination of four different configurations\n   * from different levels (global, toolGroup, segmentation and segment) and it\n   * shall not be used when isContourSegmentationTool() is overwritten and changed\n   * by a child class to return `false` when that class should work only as an ROI.\n   */\n  protected getAnnotationStyle(context: {\n    annotation: Annotation;\n    styleSpecifier: StyleSpecifier;\n  }) {\n    const annotationStyle = super.getAnnotationStyle(context);\n\n    if (!this.isContourSegmentationTool()) {\n      return annotationStyle;\n    }\n\n    const contourSegmentationStyle = this._getContourSegmentationStyle(context);\n\n    return utilities.deepMerge(annotationStyle, contourSegmentationStyle);\n  }\n\n  /**\n   * Return the annotation style based on global, toolGroup, segmentation\n   * and segment segmentation configurations.\n   */\n  private _getContourSegmentationStyle(context: {\n    annotation: Annotation;\n    styleSpecifier: StyleSpecifier;\n  }): Record<string, any> {\n    const { toolGroupId } = this;\n    const annotation = context.annotation as ContourSegmentationAnnotation;\n    const { segmentationRepresentationUID, segmentationId, segmentIndex } =\n      annotation.data.segmentation;\n    const segmentationRepresentation =\n      segmentationState.getSegmentationRepresentationByUID(\n        toolGroupId,\n        segmentationRepresentationUID\n      );\n\n    const { active } = segmentationRepresentation;\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n    const annotationLocked = segmentsLocked.includes(segmentIndex as never);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const segmentationVisible =\n      segmentationConfig.visibility.getSegmentationVisibility(\n        toolGroupId,\n        segmentationRepresentationUID\n      );\n\n    const globalConfig = segmentationConfig.getGlobalConfig();\n\n    const toolGroupConfig =\n      segmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n\n    const segmentationRepresentationConfig =\n      segmentationConfig.getSegmentationRepresentationSpecificConfig(\n        toolGroupId,\n        segmentationRepresentationUID\n      );\n\n    const segmentConfig = segmentationConfig.getSegmentSpecificConfig(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const segmentVisible = segmentationConfig.visibility.getSegmentVisibility(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    // Merge the configurations from different levels based on its precedence\n    const mergedConfig = Object.assign(\n      {},\n      globalConfig?.representations?.CONTOUR ?? {},\n      toolGroupConfig?.representations?.CONTOUR ?? {},\n      segmentationRepresentationConfig?.CONTOUR ?? {},\n      segmentConfig?.CONTOUR ?? {}\n    );\n\n    let lineWidth = 1;\n    let lineDash = undefined;\n    let lineOpacity = 1;\n    let fillOpacity = 0;\n\n    if (active) {\n      lineWidth = mergedConfig.outlineWidthActive ?? lineWidth;\n      lineDash = mergedConfig.outlineDashActive ?? lineDash;\n      lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;\n      fillOpacity = mergedConfig.fillAlpha ?? fillOpacity;\n    } else {\n      lineWidth = mergedConfig.outlineWidthInactive ?? lineWidth;\n      lineDash = mergedConfig.outlineDashInactive ?? lineDash;\n      lineOpacity = mergedConfig.outlineOpacityInactive ?? lineOpacity;\n      fillOpacity = mergedConfig.fillAlphaInactive ?? fillOpacity;\n    }\n\n    lineWidth = mergedConfig.renderOutline ? lineWidth : 0;\n    fillOpacity = mergedConfig.renderFill ? fillOpacity : 0;\n\n    const color = `rgba(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]}, ${lineOpacity})`;\n    const fillColor = `rgb(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]})`;\n\n    return {\n      color,\n      fillColor,\n      lineWidth,\n      fillOpacity,\n      lineDash,\n      textbox: {\n        color,\n      },\n      visibility: segmentationVisible && segmentVisible,\n      locked: annotationLocked,\n    };\n  }\n\n  private _registerContourSegmentationAnnotation(\n    annotation: ContourSegmentationAnnotation\n  ) {\n    const { segmentationId, segmentIndex } = annotation.data.segmentation;\n    const segmentation = segmentationState.getSegmentation(segmentationId);\n    const { annotationUIDsMap } = segmentation.representationData.CONTOUR;\n\n    let annotationsUIDsSet = annotationUIDsMap.get(segmentIndex);\n\n    if (!annotationsUIDsSet) {\n      annotationsUIDsSet = new Set();\n      annotationUIDsMap.set(segmentIndex, annotationsUIDsSet);\n    }\n\n    annotationsUIDsSet.add(annotation.annotationUID);\n  }\n\n  private _unregisterContourSegmentationAnnotation(\n    annotation: ContourSegmentationAnnotation\n  ) {\n    const { segmentationId, segmentIndex } = annotation.data.segmentation;\n    const segmentation = segmentationState.getSegmentation(segmentationId);\n    const { annotationUIDsMap } = segmentation.representationData.CONTOUR;\n    const annotationsUIDsSet = annotationUIDsMap.get(segmentIndex);\n\n    annotationsUIDsSet.delete(annotation.annotationUID);\n\n    // Delete segmentIndex Set if there is no more annotations\n    if (!annotationsUIDsSet.size) {\n      annotationUIDsMap.delete(segmentIndex);\n    }\n  }\n}\n\nexport { ContourSegmentationBaseTool as default, ContourSegmentationBaseTool };\n","import {\n  CONSTANTS,\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nimport {\n  getCalibratedAreaUnits,\n  getCalibratedScale,\n} from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport { Events } from '../../enums';\nimport { polyline } from '../../utilities/math';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport registerDrawLoop from './planarFreehandROITool/drawLoop';\nimport registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';\nimport registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';\nimport registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';\nimport registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';\nimport registerRenderMethods from './planarFreehandROITool/renderMethods';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\nimport {\n  EventTypes,\n  ToolHandle,\n  Annotation,\n  Annotations,\n  AnnotationStyle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { drawLinkedTextBox } from '../../drawingSvg';\nimport { PlanarFreehandROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { PlanarFreehandROICommonData } from '../../utilities/math/polyline/planarFreehandROIInternalTypes';\n\nimport { getIntersectionCoordinatesWithPolyline } from '../../utilities/math/polyline/getIntersectionWithPolyline';\nimport pointInShapeCallback from '../../utilities/pointInShapeCallback';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\n\nconst { pointCanProjectOnLine } = polyline;\nconst { EPSILON } = CONSTANTS;\n\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\n/**\n * PlanarFreehandROITool lets you draw annotations that define an arbitrarily drawn region.\n * You can use the PlanarFreehandROITool in all perpendicular views (axial, sagittal, coronal),\n * support for oblique views is possible, but not yet supported, due to the implementation of\n * `getSubPixelSpacingAndXYDirections`.\n *\n * The resulting annotation's data and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * PlanarFreehandROITool annotation can be smoothed on drawing completion. This is a configured based approach.\n * The interpolation process uses b-spline algorithm and consider 4 configurations properties:\n * - interpolation.interpolateOnAdd: to tell whether it should be interpolated or not (for editing it is considered the property interpolateOnEdit) (default: false)\n * - interpolation.interpolateOnEdit: to tell whether it should be interpolated or not when editing (default: false)\n * - interpolation.knotsRatioPercentageOnAdd: percentage of points from Segment that are likely to be considered knots during interpolation (for editing it is considered the property knotsRatioPercentageOnEdit) ( default: 40)\n * - interpolation.knotsRatioPercentageOnEdit: same as knotsRatioPercentageOnAdd but applicable only when editing the tool (default: 40)\n *\n * So, with that said the interpolation might occur when:\n * - drawing is done (i.e mouse is released) and interpolation.interpolateOnAdd is true. Interpolation algorithm uses knotsRatioPercentageOnAdd\n * - edit drawing is done (i.e mouse is released) and interpolation.interpolateOnEdit is true. Interpolation algorithm uses knotsRatioPercentageOnEdit and its only applied to changed segment\n * Interpolation does not occur when:\n * - interpolation.interpolateOnAdd is false and drawing is completed\n * - interpolation.interpolateOnEdit is false and edit is completed\n * - drawing still happening (editing or not)\n *\n * The result of interpolation will be a smoother set of segments.\n * Changing tool configuration (see below) you can fine-tune the interpolation process by changing knotsRatioPercentageOnAdd and knotsRatioPercentageOnEdit value, which smaller values produces a more agressive interpolation.\n * A smaller value of knotsRatioPercentageOnAdd/knotsRatioPercentageOnEdit produces a more agressive interpolation.\n *\n * ```js\n * cornerstoneTools.addTool(PlanarFreehandROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(PlanarFreehandROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(PlanarFreehandROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // set interpolation agressiveness while adding new annotation (ps: this does not change if interpolation is ON or OFF)\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\n *   interpolation: { knotsRatioPercentageOnAdd: 30 },\n * });\n *\n * // set interpolation to be ON while editing only\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\n *   interpolation: { interpolateOnAdd: false, interpolateOnEdit: true  },\n * });\n * ```\n *\n *\n * Read more in the Docs section of the website.\n */\n\nclass PlanarFreehandROITool extends ContourSegmentationBaseTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  private commonData?: PlanarFreehandROICommonData;\n  isDrawing = false;\n  isEditingClosed = false;\n  isEditingOpen = false;\n\n  private activateDraw: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateClosedContourEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateOpenContourEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateOpenContourEndEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[],\n    handle: ToolHandle | null\n  ) => void;\n  private cancelDrawing: (element: HTMLDivElement) => void;\n  private cancelClosedContourEdit: (element: HTMLDivElement) => void;\n  private cancelOpenContourEdit: (element: HTMLDivElement) => void;\n\n  private renderContour: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderContourBeingDrawn: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderClosedContourBeingEdited: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderOpenContourBeingEdited: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        alwaysRenderOpenContourHandles: {\n          // When true, always render end points when you have an open contour, rather\n          // than just rendering a line.\n          enabled: false,\n          // When enabled, use this radius to draw the endpoints whilst not hovering.\n          radius: 2,\n        },\n        allowOpenContours: true,\n        // Proximity in canvas coordinates used to join contours.\n        closeContourProximity: 10,\n        // The proximity at which we fallback to the simplest grabbing logic for\n        // determining what index of the contour to start editing.\n        checkCanvasEditFallbackProximity: 6,\n        // The relative distance that points should be dropped along the polyline\n        // in units of the image pixel spacing. A value of 1 means that nodes must\n        // be placed no closed than the image spacing apart. A value of 4 means that 4\n        // nodes should be placed within the space of one image pixel size. A higher\n        // value gives more finese to the tool/smoother lines, but the value cannot\n        // be infinite as the lines become very computationally expensive to draw.\n        subPixelResolution: 4,\n        interpolation: {\n          interpolateOnAdd: false,\n          interpolateOnEdit: false, // used for edit only\n          knotsRatioPercentageOnAdd: 40,\n          knotsRatioPercentageOnEdit: 40,\n        },\n        calculateStats: false,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    // Register event loops and rendering logic, which are stored in different\n    // Files due to their complexity/size.\n    registerDrawLoop(this);\n    registerEditLoopCommon(this);\n    registerClosedContourEditLoop(this);\n    registerOpenContourEditLoop(this);\n    registerOpenContourEndEditLoop(this);\n    registerRenderMethods(this);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current image, creates\n   * a `PlanarFreehandROIAnnotation` and stores it in the annotationManager.\n   *\n   * @param evt - `EventTypes.NormalizedMouseEventType`\n   * @returns The `PlanarFreehandROIAnnotation` object.\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): PlanarFreehandROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const annotation = this.createAnnotation(\n      evt\n    ) as PlanarFreehandROIAnnotation;\n\n    this.addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.activateDraw(evt, annotation, viewportIdsToRender);\n    evt.preventDefault();\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * Begins an edit of an open contour, when the mouse has selected a handle\n   * (end) of the open contour.\n   *\n   * @param evt - `EventTypes.MouseDownEventType`\n   * @param annotation - `PlanarFreehandROIAnnotation` annotation.\n   * @param handle - The handle index, 0 for the start and 1 for the end.\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.activateOpenContourEndEdit(\n      evt,\n      annotation,\n      viewportIdsToRender,\n      handle\n    );\n  };\n\n  /**\n   * Edits the open or closed contour when the line is grabbed and dragged.\n   */\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    if (annotation.data.contour.closed) {\n      this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n    } else {\n      this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);\n    }\n  };\n\n  /**\n   * Returns if the canvas point is near the line of the given annotation in the\n   * provided element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - The `PlanarFreehandROIAnnotation`.\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: PlanarFreehandROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const points = annotation.data.contour.polyline;\n\n    // NOTE: It is implemented this way so that we do not double calculate\n    // points when number crunching adjacent line segments.\n    let previousPoint = viewport.worldToCanvas(points[0]);\n\n    for (let i = 1; i < points.length; i++) {\n      const p1 = previousPoint;\n      const p2 = viewport.worldToCanvas(points[i]);\n      const canProject = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);\n\n      if (canProject) {\n        return true;\n      }\n\n      previousPoint = p2;\n    }\n\n    if (!annotation.data.contour.closed) {\n      // Contour is open, don't check last point to first point.\n      return false;\n    }\n\n    // check last point to first point\n    const pStart = viewport.worldToCanvas(points[0]);\n    const pEnd = viewport.worldToCanvas(points[points.length - 1]);\n\n    return pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);\n  };\n\n  cancel = (element: HTMLDivElement): void => {\n    const isDrawing = this.isDrawing;\n    const isEditingOpen = this.isEditingOpen;\n    const isEditingClosed = this.isEditingClosed;\n\n    if (isDrawing) {\n      this.cancelDrawing(element);\n    } else if (isEditingOpen) {\n      this.cancelOpenContourEdit(element);\n    } else if (isEditingClosed) {\n      this.cancelClosedContourEdit(element);\n    }\n  };\n\n  /**\n   * Triggers an annotation modified event.\n   */\n  triggerAnnotationModified = (\n    annotation: PlanarFreehandROIAnnotation,\n    enabledElement: Types.IEnabledElement\n  ): void => {\n    const { viewportId, renderingEngineId } = enabledElement;\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n  };\n\n  /**\n   * Triggers an annotation completed event.\n   */\n  triggerAnnotationCompleted = (\n    annotation: PlanarFreehandROIAnnotation\n  ): void => {\n    const eventType = Events.ANNOTATION_COMPLETED;\n\n    const eventDetail: AnnotationCompletedEventDetail = {\n      annotation,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n  };\n\n  /**\n   * @override We need to override this method as the tool doesn't always have\n   * `handles`, which means `filterAnnotationsForDisplay` fails inside\n   * `filterAnnotationsWithinSlice`.\n   */\n  filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations | undefined {\n    if (!annotations || !annotations.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    let annotationsToDisplay;\n\n    if (viewport instanceof VolumeViewport) {\n      const camera = viewport.getCamera();\n\n      const { spacingInNormalDirection } =\n        csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n\n      // Get data with same normal and within the same slice\n      annotationsToDisplay = this.filterAnnotationsWithinSlice(\n        annotations,\n        camera,\n        spacingInNormalDirection\n      );\n    } else {\n      // Use the default `filterAnnotationsForDisplay` utility, as the stack\n      // path doesn't require handles.\n      annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);\n    }\n\n    return annotationsToDisplay;\n  }\n\n  /**\n   * Altered version of the `utilities.planar.filterAnnotationsWithinSlice`,\n   * which uses the polyline position rather than the handle. As the polyline is\n   * always present.\n   */\n  private filterAnnotationsWithinSlice(\n    annotations: Annotations,\n    camera: Types.ICamera,\n    spacingInNormalDirection: number\n  ): Annotations {\n    const { viewPlaneNormal } = camera;\n\n    const annotationsWithParallelNormals = annotations.filter(\n      (td: Annotation) => {\n        const annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n\n        const isParallel =\n          Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n          PARALLEL_THRESHOLD;\n\n        return annotationViewPlaneNormal && isParallel;\n      }\n    ) as PlanarFreehandROIAnnotation[];\n\n    // No in plane annotations.\n    if (!annotationsWithParallelNormals.length) {\n      return [];\n    }\n\n    // Annotation should be within the slice, which means that it should be between\n    // camera's focalPoint +/- spacingInNormalDirection.\n\n    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n    const { focalPoint } = camera;\n\n    const annotationsWithinSlice = [];\n\n    for (const annotation of annotationsWithParallelNormals) {\n      const data = annotation.data;\n      const point = data.contour.polyline[0];\n\n      if (!annotation.isVisible) {\n        continue;\n      }\n\n      // A = point\n      // B = focal point\n      // P = normal\n\n      // B-A dot P  => Distance in the view direction.\n      // this should be less than half the slice distance.\n\n      const dir = vec3.create();\n\n      vec3.sub(dir, focalPoint, point);\n\n      const dot = vec3.dot(dir, viewPlaneNormal);\n\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\n        annotationsWithinSlice.push(annotation);\n      }\n    }\n\n    return annotationsWithinSlice;\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Disable contour segmenatation behavior because it shall be activated only\n    // for PlanarFreehandContourSegmentationTool\n    return false;\n  }\n\n  protected createAnnotation(evt: EventTypes.InteractionEventType): Annotation {\n    const worldPos = evt.detail.currentPoints.world;\n    const contourAnnotation = super.createAnnotation(evt);\n\n    return <PlanarFreehandROIAnnotation>csUtils.deepMerge(contourAnnotation, {\n      data: {\n        contour: {\n          polyline: [<Types.Point3>[...worldPos]],\n        },\n        label: '',\n        cachedStats: {},\n      },\n    });\n  }\n\n  protected getAnnotationStyle(context) {\n    // This method exists only because `super` cannot be called from\n    // _getRenderingOptions() which is in an external file.\n    return super.getAnnotationStyle(context);\n  }\n\n  protected renderAnnotationInstance(renderContext: {\n    enabledElement: Types.IEnabledElement;\n    targetId: string;\n    annotation: Annotation;\n    annotationStyle: Record<string, any>;\n    svgDrawingHelper: SVGDrawingHelper;\n  }): boolean {\n    const { enabledElement, targetId, svgDrawingHelper, annotationStyle } =\n      renderContext;\n    const annotation = renderContext.annotation as PlanarFreehandROIAnnotation;\n\n    let renderStatus = false;\n    const { viewport, renderingEngine } = enabledElement;\n\n    const isDrawing = this.isDrawing;\n    const isEditingOpen = this.isEditingOpen;\n    const isEditingClosed = this.isEditingClosed;\n\n    if (!(isDrawing || isEditingOpen || isEditingClosed)) {\n      // No annotations are currently being modified, so we can just use the\n      // render contour method to render all of them\n      this.renderContour(enabledElement, svgDrawingHelper, annotation);\n    } else {\n      // The active annotation will need special rendering treatment. Render all\n      // other annotations not being interacted with using the standard renderContour\n      // rendering path.\n      const activeAnnotationUID = this.commonData.annotation.annotationUID;\n\n      if (annotation.annotationUID === activeAnnotationUID) {\n        if (isDrawing) {\n          this.renderContourBeingDrawn(\n            enabledElement,\n            svgDrawingHelper,\n            annotation\n          );\n        } else if (isEditingClosed) {\n          this.renderClosedContourBeingEdited(\n            enabledElement,\n            svgDrawingHelper,\n            annotation\n          );\n        } else if (isEditingOpen) {\n          this.renderOpenContourBeingEdited(\n            enabledElement,\n            svgDrawingHelper,\n            annotation\n          );\n        } else {\n          throw new Error(\n            `Unknown ${this.getToolName()} annotation rendering state`\n          );\n        }\n      } else {\n        this.renderContour(enabledElement, svgDrawingHelper, annotation);\n      }\n\n      // Todo: return boolean flag for each rendering route in the planar tool.\n      renderStatus = true;\n    }\n\n    if (!this.configuration.calculateStats) {\n      return;\n    }\n\n    this._calculateStatsIfActive(\n      annotation,\n      targetId,\n      viewport,\n      renderingEngine,\n      enabledElement\n    );\n\n    this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);\n\n    return renderStatus;\n  }\n\n  _calculateStatsIfActive(\n    annotation: PlanarFreehandROIAnnotation,\n    targetId: string,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) {\n    const activeAnnotationUID = this.commonData?.annotation.annotationUID;\n\n    if (\n      annotation.annotationUID === activeAnnotationUID &&\n      !this.commonData?.movingTextBox\n    ) {\n      return;\n    }\n\n    if (!this.commonData?.movingTextBox) {\n      const { data } = annotation;\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      }\n    }\n  }\n\n  private _calculateCachedStats = (\n    annotation,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const { data } = annotation;\n    const { cachedStats } = data;\n    const { polyline: points } = data.contour;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, metadata } = image;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // Using an arbitrary start point (canvasPoint), calculate the\n      // mm spacing for the canvas in the X and Y directions.\n      const canvasPoint = canvasCoordinates[0];\n      const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n      const deltaXPoint = viewport.canvasToWorld([\n        canvasPoint[0] + 1,\n        canvasPoint[1],\n      ]);\n      const deltaYPoint = viewport.canvasToWorld([\n        canvasPoint[0],\n        canvasPoint[1] + 1,\n      ]);\n\n      const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n      const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n\n      const scale = getCalibratedScale(image);\n      let area =\n        polyline.calculateAreaOfPoints(canvasCoordinates) / scale / scale;\n      // Convert from canvas_pixels ^2 to mm^2\n      area *= deltaInX * deltaInY;\n\n      const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[0]);\n      worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n      worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n      worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n\n      let iMin = worldPosIndex[0];\n      let iMax = worldPosIndex[0];\n\n      let jMin = worldPosIndex[1];\n      let jMax = worldPosIndex[1];\n\n      let kMin = worldPosIndex[2];\n      let kMax = worldPosIndex[2];\n\n      for (let j = 1; j < points.length; j++) {\n        const worldPosIndex = csUtils.transformWorldToIndex(\n          imageData,\n          points[j]\n        );\n        worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n        worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n        worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n        iMin = Math.min(iMin, worldPosIndex[0]);\n        iMax = Math.max(iMax, worldPosIndex[0]);\n\n        jMin = Math.min(jMin, worldPosIndex[1]);\n        jMax = Math.max(jMax, worldPosIndex[1]);\n\n        kMin = Math.min(kMin, worldPosIndex[2]);\n        kMax = Math.max(kMax, worldPosIndex[2]);\n      }\n\n      // Expand bounding box\n      const iDelta = 0.01 * (iMax - iMin);\n      const jDelta = 0.01 * (jMax - jMin);\n      const kDelta = 0.01 * (kMax - kMin);\n\n      iMin = Math.floor(iMin - iDelta);\n      iMax = Math.ceil(iMax + iDelta);\n      jMin = Math.floor(jMin - jDelta);\n      jMax = Math.ceil(jMax + jDelta);\n      kMin = Math.floor(kMin - kDelta);\n      kMax = Math.ceil(kMax + kDelta);\n\n      const boundsIJK = [\n        [iMin, iMax],\n        [jMin, jMax],\n        [kMin, kMax],\n      ] as [Types.Point2, Types.Point2, Types.Point2];\n\n      const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);\n      const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);\n\n      let curRow = 0;\n      let intersections = [];\n      let intersectionCounter = 0;\n      const pointsInShape = pointInShapeCallback(\n        imageData,\n        (pointLPS, pointIJK) => {\n          let result = true;\n          const point = viewport.worldToCanvas(pointLPS);\n          if (point[1] != curRow) {\n            intersectionCounter = 0;\n            curRow = point[1];\n            intersections = getIntersectionCoordinatesWithPolyline(\n              canvasCoordinates,\n              point,\n              [canvasPosEnd[0], point[1]]\n            );\n            intersections.sort(\n              (function (index) {\n                return function (a, b) {\n                  return a[index] === b[index]\n                    ? 0\n                    : a[index] < b[index]\n                    ? -1\n                    : 1;\n                };\n              })(0)\n            );\n          }\n          if (intersections.length && point[0] > intersections[0][0]) {\n            intersections.shift();\n            intersectionCounter++;\n          }\n          if (intersectionCounter % 2 === 0) {\n            result = false;\n          }\n          return result;\n        },\n        this.configuration.statsCalculator.statsCallback,\n        boundsIJK\n      );\n\n      const modalityUnitOptions = {\n        isPreScaled: isViewportPreScaled(viewport, targetId),\n        isSuvScaled: this.isSuvScaled(\n          viewport,\n          targetId,\n          annotation.metadata.referencedImageId\n        ),\n      };\n\n      const modalityUnit = getModalityUnit(\n        metadata.Modality,\n        annotation.metadata.referencedImageId,\n        modalityUnitOptions\n      );\n\n      const stats = this.configuration.statsCalculator.getStatistics();\n\n      cachedStats[targetId] = {\n        Modality: metadata.Modality,\n        area,\n        mean: stats[1]?.value,\n        max: stats[0]?.value,\n        stdDev: stats[3]?.value,\n        statsArray: stats,\n        pointsInShape: pointsInShape,\n        areaUnit: getCalibratedAreaUnits(null, image),\n        modalityUnit,\n      };\n    }\n\n    this.triggerAnnotationModified(annotation, enabledElement);\n\n    annotation.invalidated = false;\n\n    return cachedStats;\n  };\n\n  private _renderStats = (\n    annotation,\n    viewport,\n    enabledElement,\n    svgDrawingHelper\n  ) => {\n    const { data } = <PlanarFreehandROIAnnotation>annotation;\n    const targetId = this.getTargetId(viewport);\n\n    const styleSpecifier: AnnotationStyle.StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n    if (!options.visibility) {\n      return;\n    }\n\n    const textLines = this.configuration.getTextLines(data, targetId);\n    if (!textLines || textLines.length === 0) {\n      return;\n    }\n\n    const canvasCoordinates = data.contour.polyline.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n    if (!data.handles.textBox.hasMoved) {\n      const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n      data.handles.textBox.worldPosition =\n        viewport.canvasToWorld(canvasTextBoxCoords);\n    }\n\n    const textBoxPosition = viewport.worldToCanvas(\n      data.handles.textBox.worldPosition\n    );\n\n    const textBoxUID = '1';\n    const boundingBox = drawLinkedTextBox(\n      svgDrawingHelper,\n      annotation.annotationUID ?? '',\n      textBoxUID,\n      textLines,\n      textBoxPosition,\n      canvasCoordinates,\n      {},\n      options\n    );\n\n    const { x: left, y: top, width, height } = boundingBox;\n\n    data.handles.textBox.worldBoundingBox = {\n      topLeft: viewport.canvasToWorld([left, top]),\n      topRight: viewport.canvasToWorld([left + width, top]),\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\n    };\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit } =\n    cachedVolumeStats;\n\n  const textLines: string[] = [];\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n    textLines.push(areaLine);\n  }\n\n  if (mean) {\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  }\n\n  if (max) {\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  }\n\n  if (stdDev) {\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nPlanarFreehandROITool.toolName = 'PlanarFreehandROI';\nexport default PlanarFreehandROITool;\n","import { Types } from '@cornerstonejs/core';\nimport { PlanarFreehandROITool } from '../../tools';\nimport { ToolGroupManager } from '../../store';\nimport { PlanarFreehandROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\n\nfunction shouldPreventInterpolation(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation,\n  knotsRatioPercentage: number\n): boolean {\n  if (!annotation?.data?.polyline || knotsRatioPercentage <= 0) {\n    return true;\n  }\n\n  if (!enabledElement.viewport) {\n    return true;\n  }\n\n  const { renderingEngineId, viewportId, FrameOfReferenceUID } = enabledElement;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (annotation.metadata.FrameOfReferenceUID !== FrameOfReferenceUID) {\n    return true;\n  }\n\n  if (!toolGroup) {\n    return true;\n  }\n\n  const toolInstance = toolGroup.getToolInstance(annotation.metadata.toolName);\n\n  // strategy to prevent non PlanarFreehandTool\n  if (!(toolInstance instanceof PlanarFreehandROITool)) {\n    return true;\n  }\n\n  return (\n    toolInstance.isDrawing ||\n    toolInstance.isEditingOpen ||\n    toolInstance.isEditingClosed\n  );\n}\n/**\n * Interpolates a given annotation from a given enabledElement.\n * It mutates annotation param.\n * The param knotsRatioPercentage defines the percentage of points to be considered as knots on the interpolation process.\n * Interpolation will be skipped in case: annotation is not present in enabledElement (or there is no toolGroup associated with it), related tool is being modified.\n */\nexport default function interpolateAnnotation(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation,\n  knotsRatioPercentage: number\n): boolean {\n  // prevent running while there is any tool annotation being modified\n  if (\n    shouldPreventInterpolation(enabledElement, annotation, knotsRatioPercentage)\n  ) {\n    return false;\n  }\n\n  const { viewport } = enabledElement;\n  // use only 2 dimensions on interpolation (what visually matters),\n  // otherwise a 3d interpolation might have a totally different output as it consider one more dimension.\n  const canvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n  const interpolatedCanvasPoints = <Types.Point2[]>(\n    interpolateSegmentPoints(\n      canvasPoints,\n      0,\n      canvasPoints.length,\n      knotsRatioPercentage\n    )\n  );\n\n  if (interpolatedCanvasPoints === canvasPoints) {\n    return false;\n  }\n\n  annotation.data.polyline = interpolatedCanvasPoints.map(\n    viewport.canvasToWorld\n  );\n\n  return true;\n}\n","import interpolateAnnotation from './interpolateAnnotation';\n\nexport default {\n  interpolateAnnotation,\n};\n\nexport { interpolateAnnotation };\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\n\nconst { isEqual } = csUtils;\n\nconst iAxis = vec3.fromValues(1, 0, 0);\nconst jAxis = vec3.fromValues(0, 1, 0);\nconst kAxis = vec3.fromValues(0, 0, 1);\n\nconst axisList = [iAxis, jAxis, kAxis];\n\n/**\n * Determines whether a given rectangle in a 3D space (defined by its corner\n * points in IJK coordinates) is aligned with the IJK axes.\n * @param rectangleCornersIJK - The corner points of the rectangle in IJK coordinates\n * @returns True if the rectangle is aligned with the IJK axes, false otherwise\n */\nfunction isAxisAlignedRectangle(rectangleCornersIJK) {\n  const rectangleVec1 = vec3.subtract(\n    vec3.create(),\n    rectangleCornersIJK[0],\n    rectangleCornersIJK[1]\n  );\n\n  const rectangleVec2 = vec3.subtract(\n    vec3.create(),\n    rectangleCornersIJK[0],\n    rectangleCornersIJK[2]\n  );\n\n  // Calculate the angles with IJK axes for both vectors\n  const anglesVec1 = calculateAnglesWithAxes(rectangleVec1, axisList);\n  const anglesVec2 = calculateAnglesWithAxes(rectangleVec2, axisList);\n\n  // Check if all angles are aligned (0, 90, 180, or 270 degrees)\n  // we could do csUtils.isEqual(angle % 90, 0) but this is more explicit for reading\n  const isAligned = [...anglesVec1, ...anglesVec2].every(\n    (angle) =>\n      isEqual(angle, 0) ||\n      isEqual(angle, 90) ||\n      isEqual(angle, 180) ||\n      isEqual(angle, 270)\n  );\n\n  return isAligned;\n}\n\n// Function to calculate angle with IJK axes\nfunction calculateAnglesWithAxes(vec, axes) {\n  return axes.map((axis) => (vec3.angle(vec, axis) * 180) / Math.PI);\n}\n\nexport { isAxisAlignedRectangle };\n","import { getEnabledElement } from '@cornerstonejs/core';\n\nconst state: Record<number, any> = {};\n\nfunction addToolState(element: HTMLDivElement, data): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  state[viewportId] = data;\n}\n\nfunction getToolState(element: HTMLDivElement): any {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  return state[viewportId];\n}\n\nexport { addToolState, getToolState };\n","import { getEnabledElement, StackViewport, Enums } from '@cornerstonejs/core';\nimport { getToolState } from './state';\n\nexport const requestType = Enums.RequestType.Prefetch;\nexport const priority = 0;\n\nexport function range(lowEnd, highEnd) {\n  // Javascript version of Python's range function\n  // http://stackoverflow.com/questions/3895478/does-javascript-have-a-method-like-range-to-generate-an-array-based-on-suppl\n  lowEnd = Math.round(lowEnd) || 0;\n  highEnd = Math.round(highEnd) || 0;\n\n  const arr = [];\n  let c = highEnd - lowEnd + 1;\n\n  if (c <= 0) {\n    return arr;\n  }\n\n  while (c--) {\n    arr[c] = highEnd--;\n  }\n\n  return arr;\n}\n\nexport function nearestIndex(arr, x) {\n  // Return index of nearest values in array\n  // http://stackoverflow.com/questions/25854212/return-index-of-nearest-values-in-an-array\n  let low = 0;\n  let high = arr.length - 1;\n\n  arr.forEach((v, idx) => {\n    if (v < x) {\n      low = Math.max(idx, low);\n    } else if (v > x) {\n      high = Math.min(idx, high);\n    }\n  });\n\n  return { low, high };\n}\n\nexport function getStackData(element) {\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    // Can be not valid if the data is changed part way through prefetch\n    return null;\n  }\n\n  const { viewport } = enabledElement;\n\n  if (!(viewport instanceof StackViewport)) {\n    // we shouldn't throw error here, since the viewport might have\n    // changed from stack to volume during prefetch\n    console.warn(\n      'stackPrefetch: element must be a StackViewport, VolumeViewport stackPrefetch not yet implemented'\n    );\n\n    return null;\n  }\n\n  return {\n    currentImageIdIndex: viewport.getCurrentImageIdIndex(),\n    imageIds: viewport.getImageIds(),\n  };\n}\n\nexport function getPromiseRemovedHandler(element) {\n  return function (e) {\n    const eventData = e.detail;\n\n    // When an imagePromise has been pushed out of the cache, re-add its index\n    // It to the indicesToRequest list so that it will be retrieved later if the\n    // CurrentImageIdIndex is changed to an image nearby\n    let stackData;\n\n    try {\n      // It will throw an exception in some cases (eg: thumbnails)\n      stackData = getStackData(element);\n    } catch (error) {\n      return;\n    }\n\n    if (!stackData || !stackData.imageIds || stackData.imageIds.length === 0) {\n      return;\n    }\n\n    const stack = stackData;\n    const imageIdIndex = stack.imageIds.indexOf(eventData.imageId);\n\n    // Make sure the image that was removed is actually in this stack\n    // Before adding it to the indicesToRequest array\n    if (imageIdIndex < 0) {\n      return;\n    }\n\n    const stackPrefetchData = getToolState(element);\n\n    if (\n      !stackPrefetchData ||\n      !stackPrefetchData.data ||\n      !stackPrefetchData.data.length\n    ) {\n      return;\n    }\n\n    stackPrefetchData.indicesToRequest.push(imageIdIndex);\n  };\n}\n\nexport const clearFromImageIds = (stack) => {\n  const imageIdSet = new Set<string>(stack.imageIds);\n  return (requestDetails) =>\n    requestDetails.type !== requestType ||\n    !imageIdSet.has(requestDetails.additionalDetails.imageId);\n};\n","import {\n  imageLoader,\n  Enums,\n  eventTarget,\n  imageLoadPoolManager,\n  cache,\n  getConfiguration as getCoreConfiguration,\n} from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport {\n  getStackData,\n  requestType,\n  priority,\n  getPromiseRemovedHandler,\n  nearestIndex,\n  range,\n} from './stackPrefetchUtils';\n\nlet configuration = {\n  maxImagesToPrefetch: Infinity,\n  // Preserving the existing pool should be the default behaviour, as there might\n  // be a volume of the same series already being loaded in the pool, and we don't want\n  // to cancel it middle of the way when the other stack viewport mounts. Worst case scenario\n  // there will be a few extra images in the pool but by the time that their turn comes\n  // we will have already loaded the volume and it will get read from the CACHE,\n  // so who cares\n  preserveExistingPool: true,\n};\n\nlet resetPrefetchTimeout;\nconst resetPrefetchDelay = 10;\n\nfunction prefetch(element) {\n  // Get the stackPrefetch tool data\n  const stackPrefetchData = getToolState(element);\n\n  if (!stackPrefetchData) {\n    return;\n  }\n\n  const stackPrefetch = stackPrefetchData || {};\n  const stack = getStackData(element);\n\n  if (!stack?.imageIds?.length) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  const { currentImageIdIndex } = stack;\n\n  // If all the requests are complete, disable the stackPrefetch tool\n  stackPrefetch.enabled &&= stackPrefetch.indicesToRequest?.length;\n\n  // Make sure the tool is still enabled\n  if (stackPrefetch.enabled === false) {\n    return;\n  }\n\n  // Remove an imageIdIndex from the list of indices to request\n  // This fires when the individual image loading deferred is resolved\n  function removeFromList(imageIdIndex) {\n    const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n\n    if (index > -1) {\n      // Don't remove last element if imageIdIndex not found\n      stackPrefetch.indicesToRequest.splice(index, 1);\n    }\n  }\n\n  // Remove all already cached images from the\n  // IndicesToRequest array\n  stackPrefetchData.indicesToRequest.sort((a, b) => a - b);\n  const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n\n  indicesToRequestCopy.forEach(function (imageIdIndex) {\n    const imageId = stack.imageIds[imageIdIndex];\n\n    if (!imageId) {\n      return;\n    }\n\n    const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n    // For nearby objects, ensure the last accessed time is updated\n    // by using getImageLoadObject.\n    // For more distant objects, just check if available, but dont\n    // change the access time.\n    // This allows throwing data that hasn't been accessed and is not\n    // nearby.\n    const imageCached =\n      distance < 6\n        ? cache.getImageLoadObject(imageId)\n        : cache.isLoaded(imageId);\n\n    if (imageCached) {\n      // Already in cache\n      removeFromList(imageIdIndex);\n    }\n  });\n\n  // Stop here if there are no images left to request\n  // After those in the cache have been removed\n  if (!stackPrefetch.indicesToRequest.length) {\n    return;\n  }\n\n  // Clear the requestPool of prefetch requests, if needed.\n  if (!configuration.preserveExistingPool) {\n    imageLoadPoolManager.clearRequestStack(requestType);\n  }\n\n  // Identify the nearest imageIdIndex to the currentImageIdIndex\n  const nearest = nearestIndex(\n    stackPrefetch.indicesToRequest,\n    stack.currentImageIdIndex\n  );\n\n  let imageId;\n  let nextImageIdIndex;\n  const preventCache = false;\n\n  function doneCallback(image) {\n    console.log('prefetch done: %s', image.imageId);\n    const imageIdIndex = stack.imageIds.indexOf(image.imageId);\n\n    removeFromList(imageIdIndex);\n  }\n\n  // Prefetch images around the current image (before and after)\n  let lowerIndex = nearest.low;\n  let higherIndex = nearest.high;\n  const imageIdsToPrefetch = [];\n\n  while (\n    lowerIndex >= 0 ||\n    higherIndex < stackPrefetch.indicesToRequest.length\n  ) {\n    const currentIndex = stack.currentImageIdIndex;\n    const shouldSkipLower =\n      currentIndex - stackPrefetch.indicesToRequest[lowerIndex] >\n      configuration.maxImagesToPrefetch;\n    const shouldSkipHigher =\n      stackPrefetch.indicesToRequest[higherIndex] - currentIndex >\n      configuration.maxImagesToPrefetch;\n\n    const shouldLoadLower = !shouldSkipLower && lowerIndex >= 0;\n    const shouldLoadHigher =\n      !shouldSkipHigher && higherIndex < stackPrefetch.indicesToRequest.length;\n\n    if (!shouldLoadHigher && !shouldLoadLower) {\n      break;\n    }\n\n    if (shouldLoadLower) {\n      nextImageIdIndex = stackPrefetch.indicesToRequest[lowerIndex--];\n      imageId = stack.imageIds[nextImageIdIndex];\n      imageIdsToPrefetch.push(imageId);\n    }\n\n    if (shouldLoadHigher) {\n      nextImageIdIndex = stackPrefetch.indicesToRequest[higherIndex++];\n      imageId = stack.imageIds[nextImageIdIndex];\n      imageIdsToPrefetch.push(imageId);\n    }\n  }\n\n  const requestFn = (imageId, options) =>\n    imageLoader.loadAndCacheImage(imageId, options);\n\n  const { useNorm16Texture } = getCoreConfiguration().rendering;\n\n  imageIdsToPrefetch.forEach((imageId) => {\n    // IMPORTANT: Request type should be passed if not the 'interaction'\n    // highest priority will be used for the request type in the imageRetrievalPool\n    const options = {\n      targetBuffer: {\n        type: useNorm16Texture ? undefined : 'Float32Array',\n      },\n      preScale: {\n        enabled: true,\n      },\n      requestType,\n    };\n\n    imageLoadPoolManager.addRequest(\n      requestFn.bind(null, imageId, options),\n      requestType,\n      // Additional details\n      {\n        imageId,\n      },\n      priority\n      // addToBeginning\n    );\n  });\n}\n\nfunction onImageUpdated(e) {\n  // Start prefetching again (after a delay)\n  // When the user has scrolled to a new image\n  clearTimeout(resetPrefetchTimeout);\n  resetPrefetchTimeout = setTimeout(function () {\n    const element = e.target;\n\n    // If playClip is enabled and the user loads a different series in the viewport\n    // An exception will be thrown because the element will not be enabled anymore\n    try {\n      prefetch(element);\n    } catch (error) {\n      return;\n    }\n  }, resetPrefetchDelay);\n}\n\nfunction enable(element) {\n  const stack = getStackData(element);\n\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  // Use the currentImageIdIndex from the stack as the initialImageIdIndex\n  const stackPrefetchData = {\n    indicesToRequest: range(0, stack.imageIds.length - 1),\n    enabled: true,\n    direction: 1,\n  };\n\n  // Remove the currentImageIdIndex from the list to request\n  const indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(\n    stack.currentImageIdIndex\n  );\n\n  stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);\n\n  addToolState(element, stackPrefetchData);\n\n  prefetch(element);\n\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n  element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n  eventTarget.addEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n}\n\nfunction disable(element) {\n  clearTimeout(resetPrefetchTimeout);\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n\n  const stackPrefetchData = getToolState(element);\n  // If there is actually something to disable, disable it\n\n  if (stackPrefetchData && stackPrefetchData.indicesToRequest.length) {\n    stackPrefetchData.enabled = false;\n\n    // Clear current prefetch requests from the requestPool\n    imageLoadPoolManager.clearRequestStack(requestType);\n  }\n}\n\nfunction getConfiguration() {\n  return configuration;\n}\n\nfunction setConfiguration(config) {\n  configuration = config;\n}\n\nconst stackPrefetch = { enable, disable, getConfiguration, setConfiguration };\n\nexport default stackPrefetch;\n","import {\n  imageLoader,\n  Enums,\n  eventTarget,\n  imageLoadPoolManager,\n  cache,\n  getConfiguration as getCoreConfiguration,\n} from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport {\n  getStackData,\n  requestType,\n  priority,\n  clearFromImageIds,\n  getPromiseRemovedHandler,\n} from './stackPrefetchUtils';\nimport { roundNumber } from '../../utilities';\n\nlet configuration = {\n  maxImagesToPrefetch: Infinity,\n  // Fetch up to 2 image before and after\n  minBefore: 2,\n  maxAfter: 2,\n  // Increment the cache size by 10 images\n  directionExtraImages: 10,\n  preserveExistingPool: false,\n};\n\nlet resetPrefetchTimeout;\n// Starting the prefetch quickly isn't an issue as the main image is already being\n// loaded, so a 5 ms prefetch delay is fine\nconst resetPrefetchDelay = 5;\n\n/**\n * Call this to enable stack context sensitive prefetch.  Should be called\n * before stack data is set in order to start prefetch after load first image.\n * This will add a STACK_NEW_IMAGE to detect when a new image is displayed, and then\n * update the prefetch stack.  The context sensitive prefetch reacts to the\n * initial display, or significant moves, the already loaded images, the\n * cache size and the direction of navigation.  The behaviour is:\n *\n * 1. On navigating to a new image initially, or one that is at a different position:\n *  * Fetch the next/previous 2 images\n * 2. If the user is navigating forward/backward by less than 5 images, then\n *  * Prefetch additional images in the direction of navigation, up to 100\n * 3. If all the images in a given prefetch have completed, then:\n *  * Use the last prefetched image size as an image size for the stack\n *  * Fetch up to 1/4 of the cache size images near the current image\n *\n * This is designed to:\n *   * Get nearby images immediately so that they are available for navigation\n *     * Under the assumption that users might click and view an image, then\n *       navigate to next/previous image to see the exact image they want\n *   * Not interfere with loading other viewports if they are still loading\n *     * Load priority is prefetch, and minimal images are requested initially\n *   * Load an entire series if it will fit in memory\n *     * Allows navigating to other parts of the series and display images immediately\n *   * Have images available for CINE/navigation in one direction even when\n *     there is more image data than will fit in memory.\n *     * Up to 100 images in the direction of travel will be prefetched\n *\n * @param element - to prefetch on\n */\nconst enable = (element): void => {\n  const stack = getStackData(element);\n\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  updateToolState(element);\n\n  prefetch(element);\n\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n  element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n  eventTarget.addEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n};\n\nfunction prefetch(element) {\n  const stack = getStackData(element);\n  if (!stack?.imageIds?.length) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  // Get the stackPrefetch tool data\n  const stackPrefetchData = getToolState(element);\n\n  if (!stackPrefetchData) {\n    return;\n  }\n\n  const stackPrefetch = stackPrefetchData || {};\n\n  // If all the requests are complete, disable the stackPrefetch tool\n  stackPrefetch.enabled &&= stackPrefetch.indicesToRequest?.length;\n\n  // Make sure the tool is still enabled\n  if (stackPrefetch.enabled === false) {\n    return;\n  }\n\n  // Remove an imageIdIndex from the list of indices to request\n  // This fires when the individual image loading deferred is resolved\n  function removeFromList(imageIdIndex) {\n    const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n\n    if (index > -1) {\n      // Don't remove last element if imageIdIndex not found\n      stackPrefetch.indicesToRequest.splice(index, 1);\n    }\n  }\n\n  // Remove all already cached images from the\n  // IndicesToRequest array.\n  const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n  const { currentImageIdIndex } = stack;\n\n  indicesToRequestCopy.forEach((imageIdIndex) => {\n    const imageId = stack.imageIds[imageIdIndex];\n\n    if (!imageId) {\n      return;\n    }\n\n    const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n    // For nearby objects, ensure the last accessed time is updated\n    // by using getImageLoadObject.\n    // For more distant objects, just check if available, but dont\n    // change the access time.\n    // This allows throwing data that hasn't been accessed and is not\n    // nearby.\n    const imageCached =\n      distance < 6\n        ? cache.getImageLoadObject(imageId)\n        : cache.isLoaded(imageId);\n\n    if (imageCached) {\n      // Already in cache\n      removeFromList(imageIdIndex);\n    }\n  });\n\n  // Stop here if there are no images left to request\n  // After those in the cache have been removed\n  if (!stackPrefetch.indicesToRequest.length) {\n    return;\n  }\n\n  // Clear the requestPool of prefetch requests, if needed.\n  if (!configuration.preserveExistingPool) {\n    imageLoadPoolManager.filterRequests(clearFromImageIds(stack));\n  }\n\n  function doneCallback(imageId) {\n    const imageIdIndex = stack.imageIds.indexOf(imageId);\n\n    removeFromList(imageIdIndex);\n    const image = cache.getCachedImageBasedOnImageURI(imageId);\n    const { stats } = stackPrefetch;\n    const decodeTimeInMS = image?.image?.decodeTimeInMS || 0;\n    if (decodeTimeInMS) {\n      stats.imageIds.set(imageId, decodeTimeInMS);\n      stats.decodeTimeInMS += decodeTimeInMS;\n      const loadTimeInMS = image?.image?.loadTimeInMS || 0;\n      stats.loadTimeInMS += loadTimeInMS;\n    }\n\n    if (!stackPrefetch.indicesToRequest.length) {\n      if (image?.sizeInBytes) {\n        const { sizeInBytes } = image;\n        const usage = cache.getMaxCacheSize() / 4 / sizeInBytes;\n        if (!stackPrefetch.cacheFill) {\n          stats.initialTime = Date.now() - stats.start;\n          stats.initialSize = stats.imageIds.size;\n          updateToolState(element, usage);\n          prefetch(element);\n        } else if (stats.imageIds.size) {\n          stats.fillTime = Date.now() - stats.start;\n          const { size } = stats.imageIds;\n          stats.fillSize = size;\n          console.log(\n            'Done cache fill',\n            stats.fillTime,\n            'ms',\n            size,\n            'items',\n            'average total time',\n            roundNumber(stats.fillTime / size),\n            'ms',\n            'average load',\n            roundNumber(stats.loadTimeInMS / size),\n            'ms',\n            'average decode',\n            roundNumber(stats.decodeTimeInMS / size),\n            'ms'\n          );\n        }\n      }\n    }\n  }\n\n  const requestFn = (imageId, options) =>\n    imageLoader\n      .loadAndCacheImage(imageId, options)\n      .then(() => doneCallback(imageId));\n\n  const { useNorm16Texture } = getCoreConfiguration().rendering;\n\n  indicesToRequestCopy.forEach((imageIdIndex) => {\n    const imageId = stack.imageIds[imageIdIndex];\n    // IMPORTANT: Request type should be passed if not the 'interaction'\n    // highest priority will be used for the request type in the imageRetrievalPool\n    const options = {\n      targetBuffer: {\n        type: useNorm16Texture ? undefined : 'Float32Array',\n      },\n      preScale: {\n        enabled: true,\n      },\n      requestType,\n    };\n\n    imageLoadPoolManager.addRequest(\n      requestFn.bind(null, imageId, options),\n      requestType,\n      // Additional details\n      {\n        imageId,\n      },\n      priority\n      // addToBeginning\n    );\n  });\n}\n\nfunction onImageUpdated(e) {\n  // Start prefetching again (after a delay)\n  // When the user has scrolled to a new image\n  clearTimeout(resetPrefetchTimeout);\n  resetPrefetchTimeout = setTimeout(function () {\n    const element = e.target;\n\n    // If playClip is enabled and the user loads a different series in the viewport\n    // An exception will be thrown because the element will not be enabled anymore\n    try {\n      updateToolState(element);\n      prefetch(element);\n    } catch (error) {\n      return;\n    }\n  }, resetPrefetchDelay);\n}\n\n// Not a full signum, but good enough for direction.\nconst signum = (x) => (x < 0 ? -1 : 1);\n\nconst updateToolState = (element, usage?: number) => {\n  const stack = getStackData(element);\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  const { currentImageIdIndex } = stack;\n  let { maxAfter = 2, minBefore = 2 } = configuration;\n  const { directionExtraImages = 10 } = configuration;\n  // Use the currentImageIdIndex from the stack as the initialImageIdIndex\n  const stackPrefetchData = getToolState(element) || {\n    indicesToRequest: [],\n    currentImageIdIndex,\n    stackCount: 0,\n    enabled: true,\n    direction: 1,\n    stats: {\n      start: Date.now(),\n      imageIds: new Map(),\n      decodeTimeInMS: 0,\n      loadTimeInMS: 0,\n      totalBytes: 0,\n    },\n  };\n  const delta = currentImageIdIndex - stackPrefetchData.currentImageIdIndex;\n  stackPrefetchData.direction = signum(delta);\n  stackPrefetchData.currentImageIdIndex = currentImageIdIndex;\n  stackPrefetchData.enabled = true;\n\n  if (stackPrefetchData.stackCount < 100) {\n    stackPrefetchData.stackCount += directionExtraImages;\n  }\n\n  if (Math.abs(delta) > maxAfter || !delta) {\n    // Not incrementing by 1, so stop increasing the data size\n    // TODO - consider reversing the CINE playback\n    stackPrefetchData.stackCount = 0;\n    if (usage) {\n      // The usage of the cache that this stack can use\n      const positionFraction = currentImageIdIndex / stack.imageIds.length;\n      minBefore = Math.ceil(usage * positionFraction);\n      maxAfter = Math.ceil(usage * (1 - positionFraction));\n      stackPrefetchData.cacheFill = true;\n    } else {\n      stackPrefetchData.cacheFill = false;\n    }\n  } else if (delta < 0) {\n    minBefore += stackPrefetchData.stackCount;\n    maxAfter = 0;\n  } else {\n    maxAfter += stackPrefetchData.stackCount;\n    minBefore = 0;\n  }\n\n  const minIndex = Math.max(0, currentImageIdIndex - minBefore);\n\n  const maxIndex = Math.min(\n    stack.imageIds.length - 1,\n    currentImageIdIndex + maxAfter\n  );\n\n  // Order these correctly initially\n  const indicesToRequest = [];\n  for (let i = currentImageIdIndex + 1; i <= maxIndex; i++) {\n    indicesToRequest.push(i);\n  }\n  for (let i = currentImageIdIndex - 1; i >= minIndex; i--) {\n    indicesToRequest.push(i);\n  }\n  stackPrefetchData.indicesToRequest = indicesToRequest;\n\n  addToolState(element, stackPrefetchData);\n};\n\nfunction disable(element) {\n  clearTimeout(resetPrefetchTimeout);\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n\n  const stackPrefetchData = getToolState(element);\n  // If there is actually something to disable, disable it\n\n  if (stackPrefetchData && stackPrefetchData.data.length) {\n    stackPrefetchData.enabled = false;\n    // Don't worry about clearing the requests - there aren't that many too be bothersome\n  }\n}\n\nfunction getConfiguration() {\n  return configuration;\n}\n\nfunction setConfiguration(config) {\n  configuration = config;\n}\n\nconst stackContextPrefetch = {\n  enable,\n  disable,\n  getConfiguration,\n  setConfiguration,\n};\n\nexport default stackContextPrefetch;\n","import { VolumeViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\n\n// Todo: merge this utility functionality with Crosshair _jump\n/**\n * Uses the viewport's current camera to jump to a specific world coordinate\n * @param enabledElement - enabled element\n * @param jumpWorld - location in the world to jump to\n * @returns True if successful\n */\nexport default function jumpToWorld(\n  viewport: Types.IVolumeViewport,\n  jumpWorld: Types.Point3\n): true | undefined {\n  // if not instance of volumeViewport, return\n  if (!(viewport instanceof VolumeViewport)) {\n    return;\n  }\n\n  const { focalPoint } = viewport.getCamera();\n\n  const delta: Types.Point3 = [0, 0, 0];\n  vec3.sub(delta, jumpWorld, focalPoint);\n\n  _applyShift(viewport, delta);\n\n  return true;\n}\n\nfunction _applyShift(viewport, delta) {\n  const camera = viewport.getCamera();\n  const normal = camera.viewPlaneNormal;\n\n  const dotProd = vec3.dot(delta, normal);\n  const projectedDelta = vec3.fromValues(normal[0], normal[1], normal[2]);\n\n  vec3.scale(projectedDelta, projectedDelta, dotProd);\n\n  if (\n    Math.abs(projectedDelta[0]) > 1e-3 ||\n    Math.abs(projectedDelta[1]) > 1e-3 ||\n    Math.abs(projectedDelta[2]) > 1e-3\n  ) {\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newPosition: Types.Point3 = [0, 0, 0];\n\n    vec3.add(newFocalPoint, camera.focalPoint, projectedDelta);\n    vec3.add(newPosition, camera.position, projectedDelta);\n\n    viewport.setCamera({\n      focalPoint: newFocalPoint,\n      position: newPosition,\n    });\n    viewport.render();\n  }\n}\n","import { utilities, cache, Types } from '@cornerstonejs/core';\nimport { getVoxelOverlap } from '../segmentation/utilities';\nimport pointInShapeCallback from '../pointInShapeCallback';\n\n/**\n * Gets the scalar data for a series of time points for either a single\n * coordinate or a segmentation mask, it will return the an array of scalar\n * data for a single coordinate or an array of arrays for a segmentation.\n *\n * @param dynamicVolume - 4D volume to compute time point data from\n * @param options - frameNumbers: which frames to use as timepoints, if left\n * blank, gets data timepoints over all frames\n * maskVolumeId: segmentationId to get timepoint data of\n * imageCoordinate: world coordinate to get timepoint data of\n * @returns\n */\nfunction getDataInTime(\n  dynamicVolume: Types.IDynamicImageVolume,\n  options: {\n    frameNumbers?;\n    maskVolumeId?;\n    imageCoordinate?;\n  }\n): number[] | number[][] {\n  let dataInTime;\n\n  // if frameNumbers is not provided, all frames are selected\n  const frames = options.frameNumbers || [\n    ...Array(dynamicVolume.numTimePoints).keys(),\n  ];\n\n  // You only need to provide either maskVolumeId OR imageCoordinate.\n  // Throws error if neither maskVolumeId or imageCoordinate is given,\n  // throws error if BOTH maskVolumeId and imageCoordinate is given\n  if (!options.maskVolumeId && !options.imageCoordinate) {\n    throw new Error(\n      'You should provide either maskVolumeId or imageCoordinate'\n    );\n  }\n\n  if (options.maskVolumeId && options.imageCoordinate) {\n    throw new Error('You can only use one of maskVolumeId or imageCoordinate');\n  }\n\n  if (options.maskVolumeId) {\n    const segmentationVolume = cache.getVolume(options.maskVolumeId);\n\n    const [dataInTime, ijkCoords] = _getTimePointDataMask(\n      frames,\n      dynamicVolume,\n      segmentationVolume\n    );\n\n    return [dataInTime, ijkCoords];\n  }\n\n  if (options.imageCoordinate) {\n    const dataInTime = _getTimePointDataCoordinate(\n      frames,\n      options.imageCoordinate,\n      dynamicVolume\n    );\n\n    return dataInTime;\n  }\n\n  return dataInTime;\n}\n\nfunction _getTimePointDataCoordinate(frames, coordinate, volume) {\n  const { dimensions, imageData } = volume;\n  const index = imageData.worldToIndex(coordinate);\n\n  index[0] = Math.floor(index[0]);\n  index[1] = Math.floor(index[1]);\n  index[2] = Math.floor(index[2]);\n\n  if (!utilities.indexWithinDimensions(index, dimensions)) {\n    throw new Error('outside bounds');\n  }\n\n  // calculate offset for index\n  const yMultiple = dimensions[0];\n  const zMultiple = dimensions[0] * dimensions[1];\n  const allScalarData = volume.getScalarDataArrays();\n  const value = [];\n\n  frames.forEach((frame) => {\n    const activeScalarData = allScalarData[frame];\n    const scalarIndex = index[2] * zMultiple + index[1] * yMultiple + index[0];\n    value.push(activeScalarData[scalarIndex]);\n  });\n\n  return value;\n}\n\nfunction _getTimePointDataMask(frames, dynamicVolume, segmentationVolume) {\n  const { imageData: maskImageData } = segmentationVolume;\n  const segScalarData = segmentationVolume.getScalarData();\n\n  const len = segScalarData.length;\n\n  // Pre-allocate memory for array\n  const nonZeroVoxelIndices = [];\n  nonZeroVoxelIndices.length = len;\n  const ijkCoords = [];\n\n  const dimensions = segmentationVolume.dimensions;\n\n  // Get the index of every non-zero voxel in mask\n  let actualLen = 0;\n  for (let i = 0, len = segScalarData.length; i < len; i++) {\n    if (segScalarData[i] !== 0) {\n      ijkCoords.push([\n        i % dimensions[0],\n        Math.floor((i / dimensions[0]) % dimensions[1]),\n        Math.floor(i / (dimensions[0] * dimensions[1])),\n      ]);\n      nonZeroVoxelIndices[actualLen++] = i;\n    }\n  }\n\n  // Trim the array to actual size\n  nonZeroVoxelIndices.length = actualLen;\n\n  const dynamicVolumeScalarDataArray = dynamicVolume.getScalarDataArrays();\n  const values = [];\n  const isSameVolume =\n    dynamicVolumeScalarDataArray[0].length === len &&\n    JSON.stringify(dynamicVolume.spacing) ===\n      JSON.stringify(segmentationVolume.spacing);\n\n  // if the segmentation mask is the same size as the dynamic volume (one frame)\n  // means we can just return the scalar data for the non-zero voxels\n  if (isSameVolume) {\n    for (let i = 0; i < nonZeroVoxelIndices.length; i++) {\n      const indexValues = [];\n      frames.forEach((frame) => {\n        const activeScalarData = dynamicVolumeScalarDataArray[frame];\n        indexValues.push(activeScalarData[nonZeroVoxelIndices[i]]);\n      });\n      values.push(indexValues);\n    }\n\n    return [values, ijkCoords];\n  }\n\n  // In case that the segmentation mask is not the same size as the dynamic volume (one frame)\n  // then we need to consider each voxel in the segmentation mask and check if it\n  // overlaps with the other volume, and if so we need to average the values of the\n  // overlapping voxels.\n  const callback = ({\n    pointLPS: segPointLPS,\n    value: segValue,\n    pointIJK: segPointIJK,\n  }) => {\n    // see if the value is non-zero\n    if (segValue === 0) {\n      // not interested\n      return;\n    }\n\n    // Then for each non-zero voxel in the segmentation mask, we should\n    // again perform the pointInShapeCallback to run the averaging callback\n    // function to get the average value of the overlapping voxels.\n    const overlapIJKMinMax = getVoxelOverlap(\n      dynamicVolume.imageData,\n      dynamicVolume.dimensions,\n      dynamicVolume.spacing,\n      segPointLPS\n    );\n\n    // count represents the number of voxels of the dynamic volume that represents\n    // one voxel of the segmentation mask\n    let count = 0;\n    const perFrameSum = new Map();\n\n    // Pre-initialize the Map\n    frames.forEach((frame) => perFrameSum.set(frame, 0));\n\n    const averageCallback = ({ index }) => {\n      for (let i = 0; i < frames.length; i++) {\n        const value = dynamicVolumeScalarDataArray[i][index];\n        const frame = frames[i];\n        perFrameSum.set(frame, perFrameSum.get(frame) + value);\n      }\n      count++;\n    };\n\n    pointInShapeCallback(\n      dynamicVolume.imageData,\n      () => true,\n      averageCallback,\n      overlapIJKMinMax\n    );\n\n    // average the values\n    const averageValues = [];\n    perFrameSum.forEach((sum) => {\n      averageValues.push(sum / count);\n    });\n\n    ijkCoords.push(segPointIJK);\n    values.push(averageValues);\n  };\n\n  // Since we have the non-zero voxel indices of the segmentation mask,\n  // we theoretically can use them, however, we kind of need to compute the\n  // pointLPS for each of the non-zero voxel indices, which is a bit of a pain.\n  // Todo: consider using the nonZeroVoxelIndices to compute the pointLPS\n  pointInShapeCallback(maskImageData, () => true, callback);\n\n  return [values, ijkCoords];\n}\n\nexport default getDataInTime;\n","import { Enums, Types } from '@cornerstonejs/core';\n\n/**\n * Gets the scalar data for a series of time frames from a 4D volume, returns an\n * array of scalar data after performing AVERAGE, SUM or SUBTRACT to be used to\n * create a 3D volume\n *\n * @param dynamicVolume4D - volume to compute time frame data from\n * @param operation - operation to perform on time frame data, operations include\n * SUM, AVERAGE, and SUBTRACT (can only be used with 2 time frames provided)\n * @param frameNumbers - an array of frame indices to perform the operation on, if\n * left empty, all frames will be used\n * @returns\n */\nfunction generateImageFromTimeData(\n  dynamicVolume: Types.IDynamicImageVolume,\n  operation: string,\n  frameNumbers?: number[]\n) {\n  // If no time frames provided, use all time frames\n  const frames = frameNumbers || [...Array(dynamicVolume.numTimePoints).keys()];\n  const numFrames = frames.length;\n\n  if (frames.length <= 1) {\n    throw new Error('Please provide two or more time points');\n  }\n\n  // Gets scalar data for all time frames\n  const typedArrays = dynamicVolume.getScalarDataArrays();\n\n  const arrayLength = typedArrays[0].length;\n  const finalArray = new Float32Array(arrayLength);\n\n  if (operation === Enums.DynamicOperatorType.SUM) {\n    for (let i = 0; i < numFrames; i++) {\n      const currentArray = typedArrays[frames[i]];\n      for (let j = 0; j < arrayLength; j++) {\n        finalArray[j] += currentArray[j];\n      }\n    }\n    return finalArray;\n  }\n\n  if (operation === Enums.DynamicOperatorType.SUBTRACT) {\n    if (frames.length > 2) {\n      throw new Error('Please provide only 2 time points for subtraction.');\n    }\n    for (let j = 0; j < arrayLength; j++) {\n      finalArray[j] += typedArrays[frames[0]][j] - typedArrays[frames[1]][j];\n    }\n    return finalArray;\n  }\n\n  if (operation === Enums.DynamicOperatorType.AVERAGE) {\n    for (let i = 0; i < numFrames; i++) {\n      const currentArray = typedArrays[frames[i]];\n      for (let j = 0; j < arrayLength; j++) {\n        finalArray[j] += currentArray[j];\n      }\n    }\n    for (let k = 0; k < arrayLength; k++) {\n      finalArray[k] = finalArray[k] / numFrames;\n    }\n    return finalArray;\n  }\n}\n\nexport default generateImageFromTimeData;\n","import vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\n\n/**\n * Gets a point from an array of numbers given its index\n * @param points array of number, each point defined by three consecutive numbers\n * @param idx index of the point to retrieve\n * @returns\n */\nexport function getPoint(points, idx) {\n  if (idx < points.length / 3) {\n    return [points[idx * 3], points[idx * 3 + 1], points[idx * 3 + 2]];\n  }\n}\n\n/**\n * Extract contour point sets from the outline of a poly data actor\n * @param polyData - vtk polyData\n * @returns\n */\nexport function getPolyDataPointIndexes(polyData: vtkPolyData) {\n  const linesData = polyData.getLines().getData();\n  let idx = 0;\n  const lineSegments = new Map<number, number[]>();\n\n  // Populate lineSegments map\n  while (idx < linesData.length) {\n    const segmentSize = linesData[idx++];\n    const segment = [];\n    for (let i = 0; i < segmentSize; i++) {\n      segment.push(linesData[idx + i]);\n    }\n    lineSegments.set(segment[0], segment);\n    idx += segmentSize;\n  }\n\n  const contours = [];\n\n  // Function to find an available starting point\n  const findStartingPoint = (map) => {\n    for (const [key, value] of map.entries()) {\n      if (value !== undefined) {\n        return key;\n      }\n    }\n    return -1;\n  };\n\n  // Build contours\n  let startPoint = findStartingPoint(lineSegments);\n  while (startPoint !== -1) {\n    const contour = [startPoint];\n    while (lineSegments.has(startPoint)) {\n      const nextPoint = lineSegments.get(startPoint)[1];\n      if (lineSegments.has(nextPoint)) {\n        contour.push(nextPoint);\n      }\n      lineSegments.delete(startPoint);\n      startPoint = nextPoint;\n    }\n    contours.push(contour);\n    startPoint = findStartingPoint(lineSegments);\n  }\n\n  return contours.length ? contours : undefined;\n}\n\n/**\n * Extract contour points from a poly data object\n * @param polyData - vtk polyData\n * @returns\n */\nexport function getPolyDataPoints(polyData: vtkPolyData) {\n  const contoursIndexes = getPolyDataPointIndexes(polyData);\n  if (!contoursIndexes) {\n    return;\n  }\n\n  const rawPointsData = polyData.getPoints().getData();\n  return contoursIndexes.map((contourIndexes) =>\n    contourIndexes.map((index) => getPoint(rawPointsData, index))\n  );\n}\n","/**\n * Specify the position of the text/ticks.\n * Left/Right are the valid options for a vertical colorbars and Top/Bottom\n * for the horizontal ones.\n */\nexport enum ColorbarRangeTextPosition {\n  Top = 'top',\n  Left = 'left',\n  Bottom = 'bottom',\n  Right = 'right',\n}\n","import type { ColorbarImageRange } from '../types/ColorbarImageRange';\n\nconst isRangeValid = (range: ColorbarImageRange) => {\n  return range && range.upper > range.lower;\n};\n\nexport { isRangeValid as default, isRangeValid };\n","import type { ColorbarImageRange } from '../types/ColorbarImageRange';\n\nconst areColorbarRangesEqual = (\n  a: ColorbarImageRange,\n  b: ColorbarImageRange\n) => {\n  return !!a && !!b && a.lower === b.lower && a.upper === b.upper;\n};\n\nexport { areColorbarRangesEqual as default, areColorbarRangesEqual };\n","import type { ColorbarSize } from '../types/ColorbarSize';\n\nconst isColorbarSizeValid = (size: ColorbarSize) => {\n  return !!size && size.width > 0 && size.height > 0;\n};\n\nexport { isColorbarSizeValid as default, isColorbarSizeValid };\n","import type { ColorbarSize } from '../types/ColorbarSize';\n\nconst areColorbarSizesEqual = (a: ColorbarSize, b: ColorbarSize) => {\n  return !!a && !!b && a.width === b.width && a.height === b.height;\n};\n\nexport { areColorbarSizesEqual as default, areColorbarSizesEqual };\n","import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\nimport { utilities } from '@cornerstonejs/core';\nimport interpolateVec3 from '../../math/vec3/interpolateVec3';\nimport { ColorbarCanvasProps } from './types/ColorbarCanvasProps';\nimport type { ColorbarImageRange, ColorbarVOIRange } from './types';\nimport type { ColorbarSize } from './types/ColorbarSize';\nimport {\n  isRangeValid,\n  areColorbarRangesEqual,\n  isColorbarSizeValid,\n  areColorbarSizesEqual,\n} from './common';\n\nconst { clamp } = utilities;\n\n/**\n * Canvas referenced by the color bar where the colormap is rendered. It may\n * show the full image range or only the VOI range.\n */\nclass ColorbarCanvas {\n  private _canvas: HTMLCanvasElement;\n  private _imageRange: ColorbarImageRange;\n  private _voiRange: ColorbarVOIRange;\n  private _colormap: IColorMapPreset;\n  private _showFullImageRange: boolean;\n\n  constructor(props: ColorbarCanvasProps) {\n    ColorbarCanvas.validateProps(props);\n\n    const {\n      colormap,\n      size = { width: 20, height: 100 },\n      imageRange = { lower: 0, upper: 1 },\n      voiRange = { lower: 0, upper: 1 },\n      container,\n      showFullPixelValueRange = false,\n    } = props;\n\n    this._colormap = colormap;\n    this._imageRange = imageRange;\n    this._voiRange = voiRange;\n    this._showFullImageRange = showFullPixelValueRange;\n    this._canvas = this._createRootElement(size);\n\n    if (container) {\n      this.appendTo(container);\n    }\n  }\n\n  public get colormap(): IColorMapPreset {\n    return this._colormap;\n  }\n\n  public set colormap(colormap: IColorMapPreset) {\n    this._colormap = colormap;\n    this.render();\n  }\n\n  public get size(): ColorbarSize {\n    const { width, height } = this._canvas;\n    return { width, height };\n  }\n\n  public set size(size: ColorbarSize) {\n    const { _canvas: canvas } = this;\n\n    if (!isColorbarSizeValid(size) || areColorbarSizesEqual(canvas, size)) {\n      return;\n    }\n\n    this._setCanvasSize(canvas, size);\n    this.render();\n  }\n\n  public get imageRange(): ColorbarImageRange {\n    return { ...this._imageRange };\n  }\n\n  public set imageRange(imageRange: ColorbarImageRange) {\n    if (\n      !isRangeValid(imageRange) ||\n      areColorbarRangesEqual(imageRange, this._imageRange)\n    ) {\n      return;\n    }\n\n    this._imageRange = imageRange;\n    this.render();\n  }\n\n  public get voiRange(): ColorbarVOIRange {\n    return { ...this._voiRange };\n  }\n\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, this._voiRange)\n    ) {\n      return;\n    }\n\n    this._voiRange = voiRange;\n    this.render();\n  }\n\n  public get showFullImageRange(): boolean {\n    return this._showFullImageRange;\n  }\n\n  public set showFullImageRange(showFullImageRange: boolean) {\n    if (showFullImageRange === this._showFullImageRange) {\n      return;\n    }\n\n    this._showFullImageRange = showFullImageRange;\n    this.render();\n  }\n\n  public appendTo(container: HTMLElement) {\n    container.appendChild(this._canvas);\n    this.render();\n  }\n\n  public dispose() {\n    const { _canvas: canvas } = this;\n    const { parentElement } = canvas;\n\n    parentElement?.removeChild(canvas);\n  }\n\n  private static validateProps(props: ColorbarCanvasProps) {\n    const { size, imageRange, voiRange } = props;\n\n    if (size && !isColorbarSizeValid(size)) {\n      throw new Error('Invalid \"size\"');\n    }\n\n    if (imageRange && !isRangeValid(imageRange)) {\n      throw new Error('Invalid \"imageRange\"');\n    }\n\n    if (voiRange && !isRangeValid(voiRange)) {\n      throw new Error('Invalid \"voiRange\"');\n    }\n  }\n\n  private _setCanvasSize(canvas: HTMLCanvasElement, size: ColorbarSize) {\n    const { width, height } = size;\n\n    canvas.width = width;\n    canvas.height = height;\n\n    Object.assign(canvas.style, {\n      width: `${width}px`,\n      height: `${height}px`,\n    });\n  }\n\n  private _createRootElement(size: ColorbarSize) {\n    const canvas = document.createElement('canvas');\n\n    Object.assign(canvas.style, {\n      position: 'absolute',\n      top: '0',\n      left: '0',\n      pointerEvents: 'none',\n      boxSizing: 'border-box',\n    });\n\n    this._setCanvasSize(canvas, size);\n\n    return canvas;\n  }\n\n  private render(): void {\n    if (!this._canvas.isConnected) {\n      return;\n    }\n\n    const { _colormap: colormap } = this;\n    const { RGBPoints: rgbPoints } = colormap;\n    const colorsCount = rgbPoints.length / 4;\n\n    // Returns a color point from rgbPoints. Each point has position, red,\n    // green and blue components which means each point has an offset equal\n    // to `4 * index`\n    const getColorPoint = (index) => {\n      const offset = 4 * index;\n\n      // It can get out of bounds when `voiRange.upper` is smaller than\n      // `imageRange.upper`. It's also checking if is smaller than zero\n      // for safety only because that should never happens.\n      if (index < 0 || index >= colorsCount) {\n        return;\n      }\n\n      return {\n        index,\n        position: rgbPoints[offset],\n        color: [\n          rgbPoints[offset + 1],\n          rgbPoints[offset + 2],\n          rgbPoints[offset + 3],\n        ],\n      };\n    };\n\n    const { width, height } = this._canvas;\n    const canvasContext = this._canvas.getContext('2d');\n    const isHorizontal = width > height;\n    const maxValue = isHorizontal ? width : height;\n    const { _voiRange: voiRange } = this;\n    const range = this._showFullImageRange ? this._imageRange : { ...voiRange };\n\n    const { windowWidth } = utilities.windowLevel.toWindowLevel(\n      voiRange.lower,\n      voiRange.upper\n    );\n\n    let previousColorPoint = undefined;\n    let currentColorPoint = getColorPoint(0);\n\n    // Starts from `range.lower` incrementing by incRawPixelValue on each iteration\n    const incRawPixelValue = (range.upper - range.lower) / (maxValue - 1);\n    let rawPixelValue = range.lower;\n\n    for (let i = 0; i < maxValue; i++) {\n      const tVoiRange = (rawPixelValue - voiRange.lower) / windowWidth;\n\n      // Find the color in a linear way (O(n) complexity).\n      // currentColorPoint shall move to the next color until tVoiRange is smaller\n      // than or equal to next color position.\n      if (currentColorPoint) {\n        for (let i = currentColorPoint.index; i < colorsCount; i++) {\n          if (tVoiRange <= currentColorPoint.position) {\n            break;\n          }\n\n          previousColorPoint = currentColorPoint;\n          currentColorPoint = getColorPoint(i + 1);\n        }\n      }\n\n      let normColor;\n\n      // For:\n      //   - firstColorPoint = getColorPoint(0)\n      //   - secondColorPoint = getColorPoint(1)\n      //   - lastColorPoint = getColorPoint(colorsCount - 1)\n      // Then\n      //   - previousColorPoint shall be undefined when tVoiRange < firstColorPoint.position\n      //   - currentColorPoint shall be undefined when tVoiRange > lastColorPoint.position\n      //   - previousColorPoint and currentColorPoint will be defined when\n      //     currentColorPoint.position is between secondColorPoint.position and\n      //     lastColorPoint.position.\n      if (!previousColorPoint) {\n        normColor = [...currentColorPoint.color];\n      } else if (!currentColorPoint) {\n        normColor = [...previousColorPoint.color];\n      } else {\n        const tColorRange =\n          (tVoiRange - previousColorPoint.position) /\n          (currentColorPoint.position - previousColorPoint.position);\n\n        normColor = interpolateVec3(\n          previousColorPoint.color,\n          currentColorPoint.color,\n          tColorRange\n        );\n      }\n\n      const color = normColor.map((color) =>\n        clamp(Math.round(color * 255), 0, 255)\n      );\n\n      canvasContext.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;\n\n      if (isHorizontal) {\n        canvasContext.fillRect(i, 0, 1, height);\n      } else {\n        canvasContext.fillRect(0, height - i - 1, width, 1);\n      }\n\n      rawPixelValue += incRawPixelValue;\n    }\n  }\n}\n\nexport { ColorbarCanvas as default, ColorbarCanvas };\n","/**\n * Linear interpolation between two vec3.\n * Can be used, for example, to interpolate between two RGB colors.\n * @param a - First vec3\n * @param b - Second vec3\n * @param t - Time \"t\".\n *   - Vector A is returned for values smaller than or equel to 0.\n *   - Vector B is returned for values greater than or equal to 1.\n *   - An interpolation between vectors A and B is returned otherwise.\n * @returns\n */\nconst interpolateVec3 = (a, b, t) => {\n  return [\n    a[0] * (1 - t) + b[0] * t,\n    a[1] * (1 - t) + b[1] * t,\n    a[2] * (1 - t) + b[2] * t,\n  ];\n};\n\nexport { interpolateVec3 as default, interpolateVec3 };\n","import type {\n  ColorbarImageRange,\n  ColorbarVOIRange,\n  ColorbarSize,\n  ColorbarTicksProps,\n} from './types';\nimport {\n  isColorbarSizeValid,\n  isRangeValid,\n  areColorbarRangesEqual,\n  areColorbarSizesEqual,\n} from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\n\nconst DEFAULTS = {\n  FONT: '10px Arial',\n  COLOR: 'white',\n  TICK_SIZE: 5,\n  TICK_WIDTH: 1,\n  TICK_LABEL_MARGIN: 3,\n  MAX_NUM_TICKS: 8,\n\n  // Must start with 1 and end with 10\n  TICKS_STEPS: [1, 2.5, 5, 10],\n};\n\nclass ColorbarTicks {\n  private _canvas: HTMLCanvasElement;\n  private _imageRange: ColorbarImageRange;\n  private _voiRange: ColorbarVOIRange;\n  private _color: string;\n  private _tickSize: number;\n  private _tickWidth: number;\n  private _labelMargin: number;\n  private _maxNumTicks: number;\n  private _rangeTextPosition: ColorbarRangeTextPosition;\n  private _showFullPixelValueRange: boolean;\n  private _font: string;\n\n  constructor(props: ColorbarTicksProps) {\n    ColorbarTicks.validateProps(props);\n\n    const {\n      top = 0,\n      left = 0,\n      size = { width: 20, height: 100 },\n      imageRange = { lower: 0, upper: 1 },\n      voiRange = { lower: 0, upper: 1 },\n      ticks: ticksProps,\n      container,\n      showFullPixelValueRange = false,\n    } = props;\n\n    const { style: ticksStyle, position: rangeTextPosition } = ticksProps ?? {};\n\n    this._imageRange = imageRange;\n    this._voiRange = voiRange;\n    this._font = ticksStyle?.font ?? DEFAULTS.FONT;\n    this._color = ticksStyle?.color ?? DEFAULTS.COLOR;\n    this._tickSize = ticksStyle?.tickSize ?? DEFAULTS.TICK_SIZE;\n    this._tickWidth = ticksStyle?.tickWidth ?? DEFAULTS.TICK_WIDTH;\n    this._labelMargin = ticksStyle?.labelMargin ?? DEFAULTS.TICK_LABEL_MARGIN;\n    this._maxNumTicks = ticksStyle?.maxNumTicks ?? DEFAULTS.MAX_NUM_TICKS;\n    this._rangeTextPosition =\n      rangeTextPosition ?? ColorbarRangeTextPosition.Right;\n    this._showFullPixelValueRange = showFullPixelValueRange;\n    this._canvas = this._createCanvasElement(size, top, left);\n\n    if (container) {\n      this.appendTo(container);\n    }\n  }\n\n  public get size(): ColorbarSize {\n    const { width, height } = this._canvas;\n    return { width, height };\n  }\n\n  public set size(size: ColorbarSize) {\n    const { _canvas: canvas } = this;\n\n    if (!isColorbarSizeValid(size) || areColorbarSizesEqual(canvas, size)) {\n      return;\n    }\n\n    this._setCanvasSize(canvas, size);\n    this.render();\n  }\n\n  /**\n   * Canvas top position (pixels)\n   */\n  public get top(): number {\n    return Number.parseInt(this._canvas.style.top);\n  }\n\n  /**\n   * Change the canvas top position (pixels)\n   */\n  public set top(top: number) {\n    const { _canvas: canvas } = this;\n    const currentTop = this.top;\n\n    if (top === currentTop) {\n      return;\n    }\n\n    canvas.style.top = `${top}px`;\n    this.render();\n  }\n\n  /**\n   * Canvas left position (pixels)\n   */\n  public get left(): number {\n    return Number.parseInt(this._canvas.style.left);\n  }\n\n  /**\n   * Change the canvas left position (pixels)\n   */\n  public set left(left: number) {\n    const { _canvas: canvas } = this;\n    const currentLeft = this.left;\n\n    if (left === currentLeft) {\n      return;\n    }\n\n    canvas.style.left = `${left}px`;\n    this.render();\n  }\n\n  /**\n   * Image range\n   */\n  public get imageRange() {\n    return { ...this._imageRange };\n  }\n\n  /**\n   * Set the image range that should goes from minPixelValue to maxPixelValue\n   */\n  public set imageRange(imageRange: ColorbarVOIRange) {\n    if (\n      !isRangeValid(imageRange) ||\n      areColorbarRangesEqual(imageRange, this._imageRange)\n    ) {\n      return;\n    }\n\n    this._imageRange = imageRange;\n    this.render();\n  }\n\n  /**\n   * VOI range\n   * (lower: wc - ww / 2, upper: wc + ww / 2)\n   */\n  public get voiRange() {\n    return { ...this._voiRange };\n  }\n\n  /**\n   * Set the VOI Range\n   * (lower: wc - ww / 2, upper: wc + ww / 2)\n   */\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, this._voiRange)\n    ) {\n      return;\n    }\n\n    this._voiRange = voiRange;\n    this.render();\n  }\n\n  /**\n   * Tick size (pixels)\n   */\n  public get tickSize(): number {\n    return this._tickSize;\n  }\n\n  /**\n   * Set the tick size\n   */\n  public set tickSize(tickSize: number) {\n    if (tickSize === this._tickSize) {\n      return;\n    }\n\n    this._tickSize = tickSize;\n    this.render();\n  }\n\n  /**\n   * Tick width (pixels)\n   */\n  public get tickWidth(): number {\n    return this._tickWidth;\n  }\n\n  /**\n   * Set the tick width. This width is used as `lineWidth` by CanvasRenderingContext2D.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineWidth\n   */\n  public set tickWidth(tickWidth: number) {\n    if (tickWidth === this._tickWidth) {\n      return;\n    }\n\n    this._tickWidth = tickWidth;\n    this.render();\n  }\n\n  /**\n   * Color used for ticks and labels.\n   */\n  public get color(): string {\n    return this._color;\n  }\n\n  /**\n   * Set the color used for ticks and labels. This color is used as `strokeStyle`\n   * and `fillStyle` by CanvasRenderingContext2D.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle\n   */\n  public set color(color: string) {\n    if (color === this._color) {\n      return;\n    }\n\n    this._color = color;\n    this.render();\n  }\n\n  /**\n   * Return `true` when the ticks displayed are in the range from `imageRange.lower`\n   * to `imageRange.upper` or `false` when they are in the range from `voiRange.lower`\n   * to `voiRange.upper`\n   */\n  public get showFullPixelValueRange(): boolean {\n    return this._showFullPixelValueRange;\n  }\n\n  /**\n   * Change which range should be used when rendering the ticks. Set it to `true`\n   * to show from `imageRange.lower` to `imageRange.upper` or `false` show from\n   * `voiRange.lower` to `voiRange.upper`.\n   */\n  public set showFullPixelValueRange(showFullRange: boolean) {\n    if (showFullRange === this._showFullPixelValueRange) {\n      return;\n    }\n\n    this._showFullPixelValueRange = showFullRange;\n    this.render();\n  }\n\n  /**\n   * Ticks visibility\n   */\n  public get visible() {\n    return this._canvas.style.display === 'block';\n  }\n\n  /**\n   * Show/Hide the ticks\n   */\n  public set visible(visible) {\n    if (visible === this.visible) {\n      return;\n    }\n\n    this._canvas.style.display = visible ? 'block' : 'none';\n\n    if (visible) {\n      this.render();\n    }\n  }\n\n  /**\n   * Append the canvas to its parent element\n   * @param container - HTML element where the canvas should be added to\n   */\n  public appendTo(container: HTMLElement) {\n    container.appendChild(this._canvas);\n    this.render();\n  }\n\n  private static validateProps(props: ColorbarTicksProps) {\n    const { size, imageRange, voiRange } = props;\n\n    if (size && !isColorbarSizeValid(size)) {\n      throw new Error('Invalid \"size\"');\n    }\n\n    if (imageRange && !isRangeValid(imageRange)) {\n      throw new Error('Invalid \"imageRange\"');\n    }\n\n    if (voiRange && !isRangeValid(voiRange)) {\n      throw new Error('Invalid \"voiRange\"');\n    }\n  }\n\n  private _setCanvasSize(canvas: HTMLCanvasElement, size: ColorbarSize) {\n    const { width, height } = size;\n\n    canvas.width = width;\n    canvas.height = height;\n\n    Object.assign(canvas.style, {\n      width: `${width}px`,\n      height: `${height}px`,\n    });\n  }\n\n  private _createCanvasElement(\n    size: ColorbarSize,\n    top: number,\n    left: number\n  ): HTMLCanvasElement {\n    const canvas = document.createElement('canvas');\n\n    Object.assign(canvas.style, {\n      display: 'none',\n      position: 'absolute',\n      boxSizing: 'border-box',\n      top: `${top}px`,\n      left: `${left}px`,\n    });\n\n    this._setCanvasSize(canvas, size);\n\n    return canvas;\n  }\n\n  /**\n   * Calculate how many ticks can be displayed on the screen based on the\n   * pre-defined steps (`TICKS_STEPS`) as follow:\n   *   1. Calculate what should be the step (`roughStep`) based on the range and\n   *   the number of desired steps (`maxNumTicks`).\n   *   2. Find a number power of 10 (eg: 0.1, 1, 10, 100, etc.) that can be used\n   *   to multiply `roughStep` and return a number between 1 and 10 which is\n   *   called `roughtStepNormalized`.\n   *   3. Find in the TICKS_STEPS array a number that is bigger than or equal to\n   *   the `roughtStepNormalized` value (`normalizedStep`).\n   *   4. Multiply the `normalizedStep` to move it to the real range.\n   *\n   * @param range - Range with \"lower\" and \"upper\" values\n   */\n  private _getTicks(range) {\n    const { lower, upper } = range;\n    const rangeValue = upper - lower;\n\n    // First approximation based on the max number of ticks\n    const roughStep = rangeValue / (this._maxNumTicks - 1);\n\n    // Normalize rough step to find the normalized one that fits best\n    const stepPower = Math.pow(\n      10,\n      -Math.floor(Math.log10(Math.abs(roughStep)))\n    );\n\n    // Get a number between 1 and 10\n    const roughtStepNormalized = roughStep * stepPower;\n\n    // Find a normalize step that is greater than or equal to `roughtStepNormalized`\n    const normalizedStep = DEFAULTS.TICKS_STEPS.find(\n      (n) => n >= roughtStepNormalized\n    );\n\n    // Move `normalizedStep` to the real range\n    const step = normalizedStep / stepPower;\n\n    // Determine the scale limits based on the chosen step.\n    const scaleMax = Math.ceil(upper / step) * step;\n    const scaleMin = Math.floor(lower / step) * step;\n\n    // Find a possible tick values for the `step` computed\n    const ticksCount = Math.round((scaleMax - scaleMin) / step) + 1;\n    const ticks = [];\n\n    for (let i = 0; i < ticksCount; i++) {\n      ticks.push(scaleMin + i * step);\n    }\n\n    return { scaleMin, scaleMax, step, ticks };\n  }\n\n  private _getLeftTickInfo({ position, labelMeasure }) {\n    const { width } = this._canvas;\n    const labelX =\n      width - this.tickSize - labelMeasure.width - this._labelMargin;\n    const labelPoint = [labelX, position];\n    const tickPoints = {\n      start: [width - this._tickSize, position],\n      end: [width, position],\n    };\n\n    return { labelPoint, tickPoints };\n  }\n\n  private _getRightTickInfo({ position }) {\n    const labelPoint = [this._tickSize + this._labelMargin, position];\n    const tickPoints = {\n      start: [0, position],\n      end: [this._tickSize, position],\n    };\n\n    return { labelPoint, tickPoints };\n  }\n\n  private _getTopTickInfo({ position, labelMeasure }) {\n    throw new Error('Not implemented');\n  }\n\n  private _getBottomTickInfo({ position, labelMeasure }) {\n    throw new Error('Not implemented');\n  }\n\n  private render() {\n    const { _canvas: canvas } = this;\n\n    if (!canvas.isConnected || !this.visible) {\n      return;\n    }\n\n    const { width, height } = canvas;\n    const isHorizontal = width >= height;\n    const maxCanvasPixelValue = isHorizontal ? width : height;\n    const canvasContext = canvas.getContext('2d');\n    const { _voiRange: voiRange } = this;\n    const range = this._showFullPixelValueRange\n      ? this._imageRange\n      : { ...voiRange };\n    const rangeWidth = range.upper - range.lower;\n    const { ticks } = this._getTicks(range);\n\n    canvasContext.clearRect(0, 0, width, height);\n    canvasContext.font = this._font;\n    canvasContext.textBaseline = 'middle';\n    canvasContext.fillStyle = this._color;\n    canvasContext.strokeStyle = this._color;\n    canvasContext.lineWidth = this.tickWidth;\n\n    ticks.forEach((tick) => {\n      let position = Math.round(\n        maxCanvasPixelValue * ((tick - range.lower) / rangeWidth)\n      );\n\n      // Zero at the bottom and max at the top on vertical colorbars\n      if (!isHorizontal) {\n        position = height - position;\n      }\n\n      if (position < 0 || position > maxCanvasPixelValue) {\n        return;\n      }\n\n      const label = tick.toString();\n      const labelMeasure = canvasContext.measureText(label);\n      let tickInfo;\n\n      if (isHorizontal) {\n        if (this._rangeTextPosition === ColorbarRangeTextPosition.Top) {\n          tickInfo = this._getTopTickInfo({ position, labelMeasure });\n        } else {\n          tickInfo = this._getBottomTickInfo({ position, labelMeasure });\n        }\n      } else {\n        if (this._rangeTextPosition === ColorbarRangeTextPosition.Left) {\n          tickInfo = this._getLeftTickInfo({ position, labelMeasure });\n        } else {\n          tickInfo = this._getRightTickInfo({ position });\n        }\n      }\n\n      const { labelPoint, tickPoints } = tickInfo;\n      const { start: tickStart, end: tickEnd } = tickPoints;\n\n      canvasContext.beginPath();\n      canvasContext.moveTo(tickStart[0], tickStart[1]);\n      canvasContext.lineTo(tickEnd[0], tickEnd[1]);\n      canvasContext.fillText(label, labelPoint[0], labelPoint[1]);\n      canvasContext.stroke();\n\n      return position;\n    });\n  }\n}\n\nexport { ColorbarTicks as default, ColorbarTicks };\n","import type { WidgetProps, WidgetSize } from './types';\n\n/**\n * Base class for any widget that can be added to cornerstone. Currently it is\n * responsible only for holding the `rootElement`, contains a method that allows\n * adding it to the DOM and it also listens to container's size changes when the\n * widget is already added to the DOM. `dispose` must be called to destroy the\n * widget because it removes the widget from the DOM and stop listening to\n * container changes.\n *\n * You can apply some styles to widgets using the widget id or the `widget` class.\n *\n * Example:\n *   type ColorPickerProps = WidgetProps & {\n *     selectedColor: string;\n *   }\n *\n *   class ColorPicker extends Widget {\n *     constructor(props: ColorPickerProps) {\n *       super(props);\n *       // [code]\n *     }\n *\n *     public show() {\n *       console.log('Show color picker');\n *     }\n *\n *     protected containerResized() {\n *       console.log('New container size: ', this.containerSize);\n *     }\n *   }\n *\n *   const colorPicker = new ColorPicker({\n *     container: document.body,\n *     selectedColor: '#000';\n *   });\n *\n *   // another way to add the color picker to the DOM\n *   colorPicker.appendTo(document.body)\n *\n *   // Show color picker\n *   colorPicker.show();\n */\nabstract class Widget {\n  private _id: string;\n  private _rootElement: HTMLElement;\n  private _containerSize: WidgetSize;\n  private _containerResizeObserver: ResizeObserver;\n\n  constructor({ id, container }: WidgetProps) {\n    this._id = id;\n    this._containerSize = { width: 0, height: 0 };\n    this._rootElement = this.createRootElement(id);\n    this._containerResizeObserver = new ResizeObserver(\n      this._containerResizeCallback\n    );\n\n    if (container) {\n      this.appendTo(container);\n    }\n  }\n\n  /**\n   * Widget id\n   */\n  public get id() {\n    return this._id;\n  }\n\n  /**\n   * Widget's root element\n   */\n  public get rootElement(): HTMLElement {\n    return this._rootElement;\n  }\n\n  /**\n   * Append the widget to a parent element\n   * @param container - HTML element where the widget should be added to\n   */\n  public appendTo(container: HTMLElement) {\n    const {\n      _rootElement: rootElement,\n      _containerResizeObserver: resizeObserver,\n    } = this;\n    const { parentElement: currentContainer } = rootElement;\n\n    if (!container || container === currentContainer) {\n      return;\n    }\n\n    if (currentContainer) {\n      resizeObserver.unobserve(currentContainer);\n    }\n\n    container.appendChild(rootElement);\n    resizeObserver.observe(container);\n  }\n\n  /**\n   * Removes the widget from the DOM and stop listening to DOM events\n   */\n  public destroy() {\n    const {\n      _rootElement: rootElement,\n      _containerResizeObserver: resizeObserver,\n    } = this;\n    const { parentElement } = rootElement;\n\n    parentElement?.removeChild(rootElement);\n    resizeObserver.disconnect();\n  }\n\n  protected get containerSize(): WidgetSize {\n    // Returns a copy to prevent any external change\n    return { ...this._containerSize };\n  }\n\n  /**\n   * Creates the root element which is a div by default\n   * @param id - Root element id\n   * @returns A new HTML element where all other elements should be added to\n   */\n  protected createRootElement(id: string): HTMLElement {\n    const rootElement = document.createElement('div');\n\n    rootElement.id = id;\n    rootElement.classList.add('widget');\n\n    Object.assign(rootElement.style, {\n      width: '100%',\n      height: '100%',\n    });\n\n    return rootElement;\n  }\n\n  /**\n   * Method called every time widget's container is resize giving the\n   * opportunity to children classes to act when that happens.\n   */\n  protected onContainerResize() {\n    // no-op\n  }\n\n  private _containerResizeCallback = (entries: ResizeObserverEntry[]): void => {\n    let width;\n    let height;\n\n    const { contentRect, contentBoxSize } = entries[0];\n\n    // `contentRect` is better supported than `borderBoxSize` or `contentBoxSize`,\n    // but it is left over from an earlier implementation of the Resize Observer API\n    // and may be deprecated in future versions.\n    // https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry/contentRect\n    if (contentRect) {\n      width = contentRect.width;\n      height = contentRect.height;\n    } else if (contentBoxSize?.length) {\n      width = contentBoxSize[0].inlineSize;\n      height = contentBoxSize[0].blockSize;\n    }\n\n    this._containerSize = { width, height };\n    this.onContainerResize();\n  };\n}\n\nexport { Widget as default, Widget };\n","import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\nimport { vec2 } from 'gl-matrix';\nimport { utilities as csUtils, Types } from '@cornerstonejs/core';\nimport type { ColorbarProps, ColorbarVOIRange } from './types';\nimport { isRangeValid, areColorbarRangesEqual } from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\nimport { ColorbarCanvas } from './ColorbarCanvas';\nimport { ColorbarTicks } from './ColorbarTicks';\nimport isRangeTextPositionValid from './common/isRangeTextPositionValid';\nimport Widget from '../../../widgets/Widget';\n\nconst DEFAULTS = {\n  MULTIPLIER: 1,\n  RANGE_TEXT_POSITION: ColorbarRangeTextPosition.Right,\n  TICKS_BAR_SIZE: 50,\n};\n\ntype ColorbarPoints = {\n  page: Types.Point2;\n  client: Types.Point2;\n  local: Types.Point2;\n};\n\n/**\n * A base colorbar class that is not associated with any viewport. It is\n * possible to click and drag to change the VOI range, shows the ticks during\n * interaction and it can show full image range or VOI range.\n */\nclass Colorbar extends Widget {\n  private _colormaps: Map<string, IColorMapPreset>;\n  private _activeColormapName: string;\n  private _eventListenersManager: csUtils.eventListener.MultiTargetEventListenerManager;\n  private _canvas: ColorbarCanvas;\n  private _ticksBar: ColorbarTicks;\n  private _rangeTextPosition: ColorbarRangeTextPosition;\n\n  private _isMouseOver = false;\n  private _isInteracting = false;\n\n  constructor(props: ColorbarProps) {\n    super(props);\n\n    this._eventListenersManager =\n      new csUtils.eventListener.MultiTargetEventListenerManager();\n    this._colormaps = Colorbar.getColormapsMap(props);\n    this._activeColormapName = Colorbar.getInitialColormapName(props);\n    this._canvas = this._createCanvas(props);\n    this._ticksBar = this._createTicksBar(props);\n    this._rangeTextPosition =\n      props.ticks?.position ?? DEFAULTS.RANGE_TEXT_POSITION;\n\n    this._canvas.appendTo(this.rootElement);\n    this._ticksBar.appendTo(this.rootElement);\n\n    this._addRootElementEventListeners();\n  }\n\n  /**\n   * Returns the active LUT name\n   */\n  public get activeColormapName() {\n    return this._activeColormapName;\n  }\n\n  /**\n   * Set the current active LUT name and re-renders the color bar\n   */\n  public set activeColormapName(colormapName: string) {\n    if (colormapName === this._activeColormapName) {\n      return;\n    }\n\n    const colormap = this._colormaps.get(colormapName);\n\n    if (!colormap) {\n      console.warn(`Invalid colormap name (${colormapName})`);\n      return;\n    }\n\n    this._activeColormapName = colormapName;\n    this._canvas.colormap = colormap;\n  }\n\n  public get imageRange() {\n    return this._canvas.imageRange;\n  }\n\n  public set imageRange(imageRange: ColorbarVOIRange) {\n    this._canvas.imageRange = imageRange;\n    this._ticksBar.imageRange = imageRange;\n  }\n\n  public get voiRange() {\n    return this._canvas.voiRange;\n  }\n\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    const { voiRange: currentVoiRange } = this._canvas;\n\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, currentVoiRange)\n    ) {\n      return;\n    }\n\n    this._canvas.voiRange = voiRange;\n    this._ticksBar.voiRange = voiRange;\n    this.onVoiChange(voiRange);\n  }\n\n  public get showFullImageRange() {\n    return this._canvas.showFullImageRange;\n  }\n\n  public set showFullImageRange(value: boolean) {\n    this._canvas.showFullImageRange = value;\n    this._ticksBar.showFullPixelValueRange = value;\n  }\n\n  public destroy() {\n    super.destroy();\n    this._eventListenersManager.reset();\n  }\n\n  protected createRootElement(): HTMLElement {\n    const rootElement = document.createElement('div');\n\n    Object.assign(rootElement.style, {\n      position: 'relative',\n      fontSize: '0',\n      width: '100%',\n      height: '100%',\n    });\n\n    return rootElement;\n  }\n\n  protected onContainerResize() {\n    super.onContainerResize();\n    this.updateTicksBar();\n    this._canvas.size = this.containerSize;\n  }\n\n  protected getVOIMultipliers(): [number, number] {\n    return [DEFAULTS.MULTIPLIER, DEFAULTS.MULTIPLIER];\n  }\n\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\n    // no-op\n  }\n\n  protected showTicks() {\n    this.updateTicksBar();\n    this._ticksBar.visible = true;\n  }\n\n  protected hideTicks() {\n    if (this._isInteracting || this._isMouseOver) {\n      return;\n    }\n\n    this._ticksBar.visible = false;\n  }\n\n  private static getColormapsMap(props: ColorbarProps) {\n    const { colormaps } = props;\n\n    return colormaps.reduce(\n      (items, item) => items.set(item.Name, item),\n      new Map<string, IColorMapPreset>()\n    );\n  }\n\n  private static getInitialColormapName(props: ColorbarProps) {\n    const { activeColormapName, colormaps } = props;\n    const colormapExists =\n      !!activeColormapName &&\n      colormaps.some((cm) => cm.Name === activeColormapName);\n\n    return colormapExists ? activeColormapName : colormaps[0].Name;\n  }\n\n  private _createCanvas(props: ColorbarProps) {\n    const { imageRange, voiRange, showFullPixelValueRange } = props;\n    const colormap = this._colormaps.get(this._activeColormapName);\n\n    return new ColorbarCanvas({\n      colormap,\n      imageRange,\n      voiRange: voiRange,\n      showFullPixelValueRange,\n    });\n  }\n\n  public _createTicksBar(props: ColorbarProps): ColorbarTicks {\n    const ticksProps = props.ticks;\n\n    return new ColorbarTicks({\n      imageRange: props.imageRange,\n      voiRange: props.voiRange,\n      ticks: ticksProps,\n      showFullPixelValueRange: props.showFullPixelValueRange,\n    });\n  }\n\n  private _getPointsFromMouseEvent(evt: MouseEvent): ColorbarPoints {\n    const { rootElement: element } = this;\n    const clientPoint: Types.Point2 = [evt.clientX, evt.clientY];\n    const pagePoint: Types.Point2 = [evt.pageX, evt.pageY];\n    const rect = element.getBoundingClientRect();\n    const localPoints: Types.Point2 = [\n      pagePoint[0] - rect.left - window.pageXOffset,\n      pagePoint[1] - rect.top - window.pageYOffset,\n    ];\n\n    return { client: clientPoint, page: pagePoint, local: localPoints };\n  }\n\n  private updateTicksBar() {\n    const { width: containerWidth, height: containerHeight } =\n      this.containerSize;\n\n    // ResizeObserver have not triggered any event when this happen\n    if (containerWidth === 0 && containerHeight === 0) {\n      return;\n    }\n\n    const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;\n    const isHorizontal = containerWidth >= containerHeight;\n    const width = isHorizontal ? containerWidth : DEFAULTS.TICKS_BAR_SIZE;\n    const height = isHorizontal ? DEFAULTS.TICKS_BAR_SIZE : containerHeight;\n\n    if (\n      !isRangeTextPositionValid(\n        containerWidth,\n        containerHeight,\n        rangeTextPosition\n      )\n    ) {\n      throw new Error(\n        'Invalid rangeTextPosition value for the current colobar orientation'\n      );\n    }\n\n    let ticksBarTop;\n    let ticksBarLeft;\n\n    ticksBar.size = { width, height };\n\n    if (isHorizontal) {\n      ticksBarLeft = 0;\n      ticksBarTop =\n        rangeTextPosition === ColorbarRangeTextPosition.Top\n          ? -height\n          : containerHeight;\n    } else {\n      ticksBarTop = 0;\n      ticksBarLeft =\n        rangeTextPosition === ColorbarRangeTextPosition.Left\n          ? -width\n          : containerWidth;\n    }\n\n    ticksBar.top = ticksBarTop;\n    ticksBar.left = ticksBarLeft;\n  }\n\n  private _mouseOverCallback = (evt) => {\n    this._isMouseOver = true;\n    this.showTicks();\n    evt.stopPropagation();\n  };\n\n  private _mouseOutCallback = (evt) => {\n    this._isMouseOver = false;\n    this.hideTicks();\n    evt.stopPropagation();\n  };\n\n  private _mouseDownCallback = (evt: MouseEvent) => {\n    this._isInteracting = true;\n    this.showTicks();\n    this._addVOIEventListeners(evt);\n    evt.stopPropagation();\n  };\n\n  private _mouseDragCallback = (evt, initialState) => {\n    const multipliers = this.getVOIMultipliers();\n    const currentPoints = this._getPointsFromMouseEvent(evt);\n    const { points: startPoints, voiRange: startVOIRange } = initialState;\n    const canvasDelta = vec2.sub(\n      vec2.create(),\n      currentPoints.local,\n      startPoints.local\n    );\n\n    const wwDelta = canvasDelta[0] * multipliers[0];\n    const wcDelta = canvasDelta[1] * multipliers[1];\n\n    if (!wwDelta && !wcDelta) {\n      return;\n    }\n\n    const { lower: voiLower, upper: voiUpper } = startVOIRange;\n    let { windowWidth, windowCenter } = csUtils.windowLevel.toWindowLevel(\n      voiLower,\n      voiUpper\n    );\n\n    windowWidth = Math.max(windowWidth + wwDelta, 1);\n    windowCenter += wcDelta;\n\n    const newVoiRange = csUtils.windowLevel.toLowHighRange(\n      windowWidth,\n      windowCenter\n    );\n\n    this.voiRange = newVoiRange;\n    evt.stopPropagation();\n    evt.preventDefault();\n  };\n\n  private _mouseUpCallback = (evt) => {\n    this._isInteracting = false;\n    this.hideTicks();\n    this._removeVOIEventListeners();\n    evt.stopPropagation();\n  };\n\n  private _addRootElementEventListeners() {\n    const { _eventListenersManager: manager } = this;\n    const { rootElement: element } = this;\n\n    manager.addEventListener(element, 'mouseover', this._mouseOverCallback);\n    manager.addEventListener(element, 'mouseout', this._mouseOutCallback);\n    manager.addEventListener(\n      element,\n      'mousedown',\n      this._mouseDownCallback as EventListener\n    );\n  }\n\n  private _addVOIEventListeners(evt: MouseEvent) {\n    const { _eventListenersManager: manager } = this;\n    const points = this._getPointsFromMouseEvent(evt);\n    const voiRange = { ...this._canvas.voiRange };\n    const initialDragState = { points, voiRange };\n\n    this._removeVOIEventListeners();\n\n    manager.addEventListener(document, 'voi.mouseup', this._mouseUpCallback);\n    manager.addEventListener(document, 'voi.mousemove', (evt) =>\n      this._mouseDragCallback(evt, initialDragState)\n    );\n  }\n\n  private _removeVOIEventListeners() {\n    const { _eventListenersManager: manager } = this;\n\n    manager.removeEventListener(document, 'voi.mouseup');\n    manager.removeEventListener(document, 'voi.mousemove');\n  }\n}\n\nexport { Colorbar as default, Colorbar };\n","import { ColorbarRangeTextPosition } from '../enums';\n\nfunction isRangeTextPositionValid(\n  colorbarWidth: number,\n  colorbarHeight: number,\n  rangeTextPosition: ColorbarRangeTextPosition\n) {\n  const isHorizontal = colorbarWidth >= colorbarHeight;\n  const validRangeTextPositions = isHorizontal\n    ? [ColorbarRangeTextPosition.Top, ColorbarRangeTextPosition.Bottom]\n    : [ColorbarRangeTextPosition.Left, ColorbarRangeTextPosition.Right];\n\n  return validRangeTextPositions.includes(rangeTextPosition);\n}\n\nexport { isRangeTextPositionValid as default, isRangeTextPositionValid };\n","import {\n  eventTarget,\n  VolumeViewport,\n  StackViewport,\n  Types,\n  Enums,\n  utilities,\n  getEnabledElement,\n} from '@cornerstonejs/core';\nimport { Colorbar } from './Colorbar';\nimport type { ViewportColorbarProps, ColorbarVOIRange } from './types';\nimport { getVOIMultipliers } from '../../getVOIMultipliers';\n\nconst { Events } = Enums;\nconst defaultImageRange = { lower: -1000, upper: 1000 };\n/**\n * A colorbar associated with a viewport that updates automatically when the\n * viewport VOI changes or when the stack/volume are updated..\n */\nclass ViewportColorbar extends Colorbar {\n  private _element: HTMLDivElement;\n  private _volumeId: string;\n\n  private _hideTicksTime: number;\n  private _hideTicksTimeoutId: number;\n\n  constructor(props: ViewportColorbarProps) {\n    const { element, volumeId } = props;\n    const imageRange = ViewportColorbar._getImageRange(element, volumeId);\n    const voiRange = ViewportColorbar._getVOIRange(element, volumeId);\n\n    super({ ...props, imageRange, voiRange });\n\n    this._element = element;\n    this._volumeId = volumeId;\n\n    this._addCornerstoneEventListener();\n  }\n\n  public get element() {\n    return this._element;\n  }\n\n  public get enabledElement() {\n    return getEnabledElement(this._element);\n  }\n\n  protected getVOIMultipliers(): [number, number] {\n    const { viewport } = this.enabledElement;\n    return getVOIMultipliers(viewport, this._volumeId);\n  }\n\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\n    super.onVoiChange(voiRange);\n\n    const { viewport } = this.enabledElement;\n\n    if (viewport instanceof StackViewport) {\n      viewport.setProperties({\n        voiRange: voiRange,\n      });\n      viewport.render();\n    } else if (viewport instanceof VolumeViewport) {\n      const { _volumeId: volumeId } = this;\n      const viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(\n        volumeId,\n        viewport.renderingEngineId\n      );\n\n      viewport.setProperties({ voiRange }, volumeId);\n      viewportsContainingVolumeUID.forEach((vp) => vp.render());\n    }\n  }\n\n  private static _getImageRange(element, volumeId?) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const actor = volumeId\n      ? viewport.getActor(volumeId)\n      : viewport.getDefaultActor();\n\n    if (!actor) {\n      return defaultImageRange;\n    }\n\n    const imageData = actor.actor.getMapper().getInputData();\n    const imageRange = imageData.getPointData().getScalars().getRange();\n\n    return imageRange[0] === 0 && imageRange[1] === 0\n      ? defaultImageRange\n      : { lower: imageRange[0], upper: imageRange[1] };\n  }\n\n  private static _getVOIRange(element, volumeId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const volumeActor = volumeId\n      ? viewport.getActor(volumeId)\n      : viewport.getDefaultActor();\n\n    if (!volumeActor || !utilities.isImageActor(volumeActor)) {\n      return defaultImageRange;\n    }\n\n    const voiRange = (volumeActor.actor as Types.ImageActor)\n      .getProperty()\n      .getRGBTransferFunction(0)\n      .getRange();\n\n    return voiRange[0] === 0 && voiRange[1] === 0\n      ? defaultImageRange\n      : { lower: voiRange[0], upper: voiRange[1] };\n  }\n\n  private autoHideTicks = () => {\n    // Avoiding calling setTimeout multiple times when manipulating the VOI\n    // via WindowLevel tool for better performance\n    if (this._hideTicksTimeoutId) {\n      return;\n    }\n\n    const timeLeft = this._hideTicksTime - Date.now();\n\n    if (timeLeft <= 0) {\n      this.hideTicks();\n    } else {\n      this._hideTicksTimeoutId = window.setTimeout(() => {\n        // Recursive call until there is no more time left\n        this._hideTicksTimeoutId = 0;\n        this.autoHideTicks();\n      }, timeLeft);\n    }\n  };\n\n  private showAndAutoHideTicks(interval = 1000) {\n    this._hideTicksTime = Date.now() + interval;\n    this.showTicks();\n    this.autoHideTicks();\n  }\n\n  private _stackNewImageCallback = () => {\n    this.imageRange = ViewportColorbar._getImageRange(this._element);\n  };\n\n  private _imageVolumeModifiedCallback = (\n    evt: Types.EventTypes.ImageVolumeModifiedEvent\n  ) => {\n    const { volumeId } = evt.detail.imageVolume;\n\n    if (volumeId !== this._volumeId) {\n      return;\n    }\n\n    const { _element: element } = this;\n    this.imageRange = ViewportColorbar._getImageRange(element, volumeId);\n  };\n\n  private _viewportVOIModifiedCallback = (\n    evt: Types.EventTypes.VoiModifiedEvent\n  ) => {\n    const { viewportId, volumeId, range: voiRange } = evt.detail;\n    const { viewport } = this.enabledElement;\n\n    if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n      return;\n    }\n\n    this.voiRange = voiRange;\n    this.showAndAutoHideTicks();\n  };\n\n  private _addCornerstoneEventListener() {\n    const { _element: element } = this;\n\n    eventTarget.addEventListener(\n      Events.IMAGE_VOLUME_MODIFIED,\n      this._imageVolumeModifiedCallback\n    );\n\n    element.addEventListener(\n      Events.STACK_NEW_IMAGE,\n      this._stackNewImageCallback\n    );\n\n    element.addEventListener(\n      Events.VOI_MODIFIED,\n      this._viewportVOIModifiedCallback as EventListener\n    );\n  }\n}\n\nexport { ViewportColorbar as default, ViewportColorbar };\n","import { Types, utilities as csUtils } from '@cornerstonejs/core';\nimport { isViewportPreScaled } from './viewport';\n\nconst DEFAULT_MULTIPLIER = 4;\n\nfunction getVOIMultipliers(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  volumeId?: string,\n  options?: {\n    fixedPTWindowWidth?: boolean;\n  }\n): [number, number] {\n  const modality = csUtils.getViewportModality(viewport, volumeId);\n\n  if (modality === 'PT') {\n    const { clientWidth, clientHeight } = viewport.element;\n    const ptMultiplier = 5 / Math.max(clientWidth, clientHeight);\n    const isPreScaled = isViewportPreScaled(viewport, volumeId);\n    const { fixedPTWindowWidth = true } = options ?? {};\n\n    // Set the \"X\" multiplier equal to zero in order to do not allow\n    // any change to the window width (0 * cursorDeltaX = 0)\n    const xMultiplier = fixedPTWindowWidth ? 0 : ptMultiplier;\n\n    return isPreScaled\n      ? [xMultiplier, ptMultiplier]\n      : [xMultiplier, DEFAULT_MULTIPLIER];\n  }\n\n  return [DEFAULT_MULTIPLIER, DEFAULT_MULTIPLIER];\n}\n\nexport { getVOIMultipliers as default, getVOIMultipliers };\n","import { utilities } from '@cornerstonejs/core';\n\nimport {\n  getAnnotationNearPoint,\n  getAnnotationNearPointOnEnabledElement,\n} from './getAnnotationNearPoint';\n\n// Lodash/common JS functionality\nimport debounce from './debounce';\nimport throttle from './throttle';\nimport isObject from './isObject';\nimport clip from './clip';\nimport calibrateImageSpacing from './calibrateImageSpacing';\nimport {\n  getCalibratedLengthUnits,\n  getCalibratedAreaUnits,\n  getCalibratedScale,\n} from './getCalibratedUnits';\nimport triggerAnnotationRenderForViewportIds from './triggerAnnotationRenderForViewportIds';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport jumpToSlice from './viewport/jumpToSlice';\n\nimport pointInShapeCallback from './pointInShapeCallback';\nimport { getSphereBoundsInfo } from './getSphereBoundsInfo';\nimport scroll from './scroll';\nimport { pointToString } from './pointToString';\nimport annotationFrameRange from './annotationFrameRange';\n\n// name spaces\nimport * as contours from './contours';\nimport * as segmentation from './segmentation';\nimport * as drawing from './drawing';\nimport * as math from './math';\nimport * as planar from './planar';\nimport * as viewportFilters from './viewportFilters';\nimport * as orientation from './orientation';\nimport * as cine from './cine';\nimport * as boundingBox from './boundingBox';\nimport * as planarFreehandROITool from './planarFreehandROITool';\nimport * as rectangleROITool from './rectangleROITool';\nimport { stackPrefetch, stackContextPrefetch } from './stackPrefetch';\nimport * as viewport from './viewport';\nimport * as touch from './touch';\nimport * as dynamicVolume from './dynamicVolume';\nimport * as polyDataUtils from './polyData/utils';\nimport * as voi from './voi';\n\nconst roundNumber = utilities.roundNumber;\n\n// Events\nimport { triggerEvent } from '@cornerstonejs/core';\n\nexport {\n  math,\n  planar,\n  viewportFilters,\n  drawing,\n  debounce,\n  dynamicVolume,\n  throttle,\n  orientation,\n  isObject,\n  touch,\n  triggerEvent,\n  calibrateImageSpacing,\n  getCalibratedLengthUnits,\n  getCalibratedAreaUnits,\n  getCalibratedScale,\n  segmentation,\n  contours,\n  triggerAnnotationRenderForViewportIds,\n  triggerAnnotationRender,\n  pointInShapeCallback,\n  getSphereBoundsInfo,\n  getAnnotationNearPoint,\n  getAnnotationNearPointOnEnabledElement,\n  jumpToSlice,\n  viewport,\n  cine,\n  clip,\n  boundingBox,\n  rectangleROITool,\n  planarFreehandROITool,\n  stackPrefetch,\n  stackContextPrefetch,\n  scroll,\n  roundNumber,\n  pointToString,\n  polyDataUtils,\n  voi,\n  annotationFrameRange,\n};\n","import { setElementCursor } from './elementCursor';\nimport MouseCursor from './MouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\n\n/**\n * Set the cursor for an HTML element. cursorNames can be either\n * cornerstone3DTools cursors or standard cursors.\n *\n * @param element - The element to set the cursor on.\n * @param cursorName - The name of the cursor to set. This can be\n * any cursor name either Cornerstone-specific cursor names or the standard\n * CSS cursor names.\n */\nfunction setCursorForElement(\n  element: HTMLDivElement,\n  cursorName: string\n): void {\n  let cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n  if (!cursor) {\n    cursor = MouseCursor.getDefinedCursor(cursorName);\n  }\n\n  if (!cursor) {\n    console.log(\n      `Cursor ${cursorName} is not defined either as SVG or as a standard cursor.`\n    );\n    cursor = MouseCursor.getDefinedCursor(cursorName);\n  }\n\n  setElementCursor(element, cursor);\n}\n\nexport default setCursorForElement;\n","import MouseCursor, { standardCursorNames } from './MouseCursor';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\nimport * as elementCursor from './elementCursor';\nimport setCursorForElement from './setCursorForElement';\nimport {\n  registerCursor,\n  svgCursorNames,\n  CursorSVG,\n} from './SVGCursorDescriptor';\n\n// Todo: this should be enum\nconst CursorNames = [...svgCursorNames, ...standardCursorNames];\n\nexport {\n  MouseCursor,\n  ImageMouseCursor,\n  SVGMouseCursor,\n  elementCursor,\n  registerCursor,\n  CursorNames,\n  CursorSVG,\n  setCursorForElement,\n};\n","import { ToolModes, AnnotationStyleStates } from '../../../enums';\nimport { getStyleProperty } from './helpers';\nimport { StyleSpecifier } from '../../../types/AnnotationStyle';\n\n/**\n * getFont - Returns a font string of the form \"{fontSize}px fontName\" used by `canvas`.\n * @param styleSpecifier - An object containing the specifications such as viewportId,\n * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n * met (hierarchy is checked from most specific to least specific which is\n * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n * @param state - An optional state to determine the final property name\n * @param mode - An optional mode to determine the final property name\n * @returns The font string.\n */\nfunction getFont(\n  styleSpecifier: StyleSpecifier,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string {\n  const fontSize = getStyleProperty(\n    'textBoxFontSize',\n    styleSpecifier,\n    state,\n    mode\n  );\n  const fontFamily = getStyleProperty(\n    'textBoxFontFamily',\n    styleSpecifier,\n    state,\n    mode\n  );\n\n  return `${fontSize}px ${fontFamily}`;\n}\n\nexport default getFont;\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport { getAnnotation } from './annotationState';\n\nexport type BaseEventDetail = {\n  viewportId: string;\n  renderingEngineId: string;\n};\n\n/**\n * An annotation group\n */\n\nexport default class AnnotationGroup {\n  private annotationUIDs = new Set<string>();\n  private _isVisible = true;\n\n  public visibleFilter: (uid: string) => boolean;\n\n  constructor() {\n    this.visibleFilter = this.unboundVisibleFilter.bind(this);\n  }\n\n  /**\n   * Returns true if other groups are free to hide this annotation.\n   * That is, if the annotation is not a member or is hidden.\n   */\n  protected unboundVisibleFilter(uid: string): boolean {\n    return !this._isVisible || !this.annotationUIDs.has(uid);\n  }\n\n  public has(uid: string): boolean {\n    return this.annotationUIDs.has(uid);\n  }\n  /**\n   * Sets whether annotations belonging to this group are visible or not.\n   * If there are multiple groups, then the set visible false should be called\n   * before before re-enabling the other groups with setVisible true.\n   */\n  public setVisible(\n    isVisible = true,\n    baseEvent: BaseEventDetail,\n    filter?: (annotationUID: string) => boolean\n  ) {\n    if (this._isVisible === isVisible) {\n      return;\n    }\n    this._isVisible = isVisible;\n    this.annotationUIDs.forEach((uid) => {\n      const annotation = getAnnotation(uid);\n      if (!annotation) {\n        this.annotationUIDs.delete(uid);\n        return;\n      }\n      if (annotation.isVisible === isVisible) {\n        return;\n      }\n      if (!isVisible && filter?.(uid) === false) {\n        return;\n      }\n      annotation.isVisible = isVisible;\n      const eventDetail = {\n        ...baseEvent,\n        annotation,\n      };\n      triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\n    });\n  }\n\n  public get isVisible() {\n    return this._isVisible;\n  }\n\n  /** Finds the nearby/next annotation in the given direction */\n  public findNearby(uid: string, direction: 1) {\n    const uids = [...this.annotationUIDs];\n    if (uids.length === 0) {\n      return null;\n    }\n    if (!uid) {\n      return uids[direction === 1 ? 0 : uids.length - 1];\n    }\n    const index = uids.indexOf(uid);\n    if (\n      index === -1 ||\n      index + direction < 0 ||\n      index + direction >= uids.length\n    ) {\n      return null;\n    }\n    return uids[index + direction];\n  }\n\n  /**\n   * Adds the annotation to the group\n   * Does NOT change the visibility status of the annotation.\n   */\n  public add(...annotationUIDs: string[]) {\n    annotationUIDs.forEach((annotationUID) =>\n      this.annotationUIDs.add(annotationUID)\n    );\n  }\n\n  /**\n   * Removes the annotation from the group.\n   * Does not affect the visibility status of the annotation.\n   */\n  public remove(...annotationUIDs: string[]) {\n    annotationUIDs.forEach((annotationUID) =>\n      this.annotationUIDs.delete(annotationUID)\n    );\n  }\n\n  /**\n   * Removes everything from the group.\n   */\n  public clear() {\n    this.annotationUIDs.clear();\n  }\n}\n","import { SegmentationPublicInput } from '../../../types/SegmentationStateTypes';\nimport { cache } from '@cornerstonejs/core';\nimport type {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataVolume,\n} from '../../../types/LabelmapTypes';\n\nfunction validate(segmentationInput: SegmentationPublicInput): void {\n  if (!segmentationInput.representation.data) {\n    throw new Error(\n      'The segmentationInput.representationData.data is undefined, please provide a valid representationData.data'\n    );\n  }\n\n  const representationData = segmentationInput.representation\n    .data as LabelmapSegmentationData;\n\n  if ('volumeId' in representationData) {\n    // volumetric labelmap\n    const cachedVolume = cache.getVolume(\n      (representationData as LabelmapSegmentationDataVolume).volumeId\n    );\n\n    if (!cachedVolume) {\n      throw new Error(\n        `volumeId of ${\n          (representationData as LabelmapSegmentationDataVolume).volumeId\n        } not found in cache, you should load and cache volume before adding segmentation`\n      );\n    }\n  } else {\n    // I don't think we need this check since there is no guarantee that the stack is cached.\n  }\n}\n\nexport default validate;\n","import * as Enums from '../../../enums';\nimport { SegmentationPublicInput } from '../../../types/SegmentationStateTypes';\nimport validateLabelmap from '../../../tools/displayTools/Labelmap/validateRepresentationData';\n\n/**\n * Checks if the segmentationInputArray is valid meaning it contains\n * correct representationProps for the representation type that is being used.\n *\n * @param segmentationInputArray - Array of segmentation inputs\n * @internal\n */\nfunction validateSegmentationInput(\n  segmentationInputArray: SegmentationPublicInput[]\n): void {\n  if (!segmentationInputArray || !segmentationInputArray.length) {\n    throw new Error('The segmentationInputArray is undefined or empty array');\n  }\n\n  segmentationInputArray.forEach((segmentationInput) => {\n    if (segmentationInput.segmentationId === undefined) {\n      throw new Error(\n        'The segmentationInput.segmentationId is undefined, please provide a valid segmentationId'\n      );\n    }\n\n    if (segmentationInput.representation === undefined) {\n      throw new Error(\n        'The segmentationInput.representation is undefined, please provide a valid representation'\n      );\n    }\n\n    if (\n      segmentationInput.representation.type ===\n      Enums.SegmentationRepresentations.Labelmap\n    ) {\n      validateLabelmap(segmentationInput);\n    }\n  });\n}\n\nexport default validateSegmentationInput;\n","import _cloneDeep from 'lodash.clonedeep';\nimport { SegmentationPublicInput } from '../../types/SegmentationStateTypes';\nimport { validateSegmentationInput } from './helpers';\nimport { addSegmentation as addSegmentationToState } from './segmentationState';\n/**\n * Adds the segmentation to the cornerstone3D segmentation state. It should be\n * noted that segmentations are not added to any toolGroup's viewports. In order to\n * do so, you should add a \"representation\" of the segmentation to the toolGroup\n * using addSegmentationRepresentations helper. The reason for this is that there\n * can be multiple representations of the same segmentation (e.g. Labelmap and\n * Contour, etc. - Currently only Labelmap representations is supported).\n * @param segmentationInputArray - The array of segmentation input, each of which\n * defining the segmentationId and the main representation data for the segmentation.\n */\nfunction addSegmentations(\n  segmentationInputArray: SegmentationPublicInput[]\n): void {\n  validateSegmentationInput(segmentationInputArray);\n\n  segmentationInputArray.map((segInput) => {\n    const segmentationInput = _cloneDeep(segInput);\n\n    addSegmentationToState(segmentationInput);\n  });\n}\n\nexport default addSegmentations;\n","import SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\nimport { RepresentationPublicInput } from '../../../types';\nimport { getRepresentationRenderingConfig as getLabelmapRenderingConfig } from '../../../tools/displayTools/Labelmap/labelmapDisplay';\n\nexport function getRepresentationSpecificConfig(\n  representationInput: RepresentationPublicInput\n) {\n  const { type } = representationInput;\n\n  if (type === SegmentationRepresentations.Labelmap) {\n    return getLabelmapRenderingConfig();\n  } else {\n    return {};\n  }\n}\n","import {\n  SegmentationRepresentationConfig,\n  RepresentationPublicInput,\n} from '../../types/SegmentationStateTypes';\nimport { getToolGroup } from '../../store/ToolGroupManager';\n\nimport { addSegmentationRepresentation } from './addSegmentationRepresentation';\n\n/**\n * Set the specified segmentation representations on the viewports of the specified\n * toolGroup. It accepts a second argument which is a toolGroup specific representation\n * configuration.\n *\n * @param toolGroupId - The Id of the toolGroup to add the segmentation representations to\n * @param representationInputArray - An array of segmentation representations to add to the toolGroup\n * @param toolGroupSpecificRepresentationConfig - The toolGroup specific configuration\n * for the segmentation representations\n */\nasync function addSegmentationRepresentations(\n  toolGroupId: string,\n  representationInputArray: RepresentationPublicInput[],\n  toolGroupSpecificRepresentationConfig?: SegmentationRepresentationConfig\n): Promise<string[]> {\n  // Check if there exists a toolGroup with the toolGroupId\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (!toolGroup) {\n    throw new Error(`No tool group found for toolGroupId: ${toolGroupId}`);\n  }\n\n  const promises = representationInputArray.map((representationInput) => {\n    return addSegmentationRepresentation(\n      toolGroupId,\n      representationInput,\n      toolGroupSpecificRepresentationConfig\n    );\n  });\n\n  const segmentationRepresentationUIDs = await Promise.all(promises);\n\n  return segmentationRepresentationUIDs;\n}\n\nexport default addSegmentationRepresentations;\n","import { utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  SegmentationRepresentationConfig,\n  RepresentationPublicInput,\n  ToolGroupSpecificRepresentation,\n} from '../../types/SegmentationStateTypes';\nimport * as SegmentationConfig from './config/segmentationConfig';\nimport {\n  addSegmentationRepresentation as addSegmentationRepresentationToState,\n  getNextColorLUTIndex,\n  addColorLUT,\n} from './segmentationState';\nimport { getRepresentationSpecificConfig } from './helpers/getRepresentationSpecificConfig';\nimport CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\n\nasync function addSegmentationRepresentation(\n  toolGroupId: string,\n  representationInput: RepresentationPublicInput,\n  toolGroupSpecificConfig?: SegmentationRepresentationConfig\n): Promise<string> {\n  const { segmentationId, options = {} } = representationInput;\n  const segmentationRepresentationUID = utilities.uuidv4();\n\n  // Todo: make segmentsHidden also an option that can get passed by\n  // the user\n  const segmentsHidden = new Set() as Set<number>;\n\n  const colorLUTOrIndexInput = options.colorLUTOrIndex;\n  let colorLUTIndexToUse;\n\n  if (typeof colorLUTOrIndexInput === 'number') {\n    colorLUTIndexToUse = colorLUTOrIndexInput;\n  } else {\n    const nextIndex = getNextColorLUTIndex();\n    const colorLUTToAdd = Array.isArray(colorLUTOrIndexInput)\n      ? colorLUTOrIndexInput\n      : CORNERSTONE_COLOR_LUT;\n    addColorLUT(colorLUTToAdd as Types.ColorLUT, nextIndex);\n    colorLUTIndexToUse = nextIndex;\n  }\n\n  const toolGroupSpecificRepresentation: ToolGroupSpecificRepresentation = {\n    segmentationId,\n    segmentationRepresentationUID,\n    type: representationInput.type,\n    segmentsHidden,\n    colorLUTIndex: colorLUTIndexToUse,\n    active: true,\n    segmentationRepresentationSpecificConfig: {},\n    segmentSpecificConfig: {},\n    config: getRepresentationSpecificConfig(representationInput),\n  };\n\n  // Update the toolGroup specific configuration\n  if (toolGroupSpecificConfig) {\n    // Since setting configuration on toolGroup will trigger a segmentationRepresentation\n    // update event, we don't want to trigger the event twice, so we suppress\n    // the first one\n    const currentToolGroupConfig =\n      SegmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n\n    const mergedConfig = utilities.deepMerge(\n      currentToolGroupConfig,\n      toolGroupSpecificConfig\n    );\n\n    SegmentationConfig.setToolGroupSpecificConfig(toolGroupId, {\n      renderInactiveSegmentations:\n        mergedConfig.renderInactiveSegmentations || true,\n      representations: {\n        ...mergedConfig.representations,\n      },\n    });\n  }\n\n  addSegmentationRepresentationToState(\n    toolGroupId,\n    toolGroupSpecificRepresentation\n  );\n\n  return segmentationRepresentationUID;\n}\n\nexport { addSegmentationRepresentation };\n","import {\n  volumeLoader,\n  utilities as csUtils,\n  eventTarget,\n} from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport addSegmentations from './addSegmentations';\nimport addSegmentationRepresentations from './addSegmentationRepresentations';\nimport { triggerSegmentationRender } from '../../utilities/segmentation';\nimport { getSegmentation, removeSegmentation } from './segmentationState';\nimport { LabelmapSegmentationDataStack } from '../../types/LabelmapTypes';\nimport { triggerSegmentationDataModified } from './triggerSegmentationEvents';\n\n/**\n * Converts a stack-based segmentation to a volume-based segmentation.\n *\n * @param params - The parameters for the conversion.\n * @param params.segmentationId - The segmentationId to convert.\n * @param [params.options] - The conversion options.\n * @param params.options.toolGroupId - The new toolGroupId to use for the segmentation.\n * @param [params.options.volumeId] - the new volumeId to use for the segmentation. If not provided, a new ID will be generated.\n * @param [params.options.newSegmentationId] - the new segmentationId to use for the segmentation. If not provided, a new ID will be generated.\n * @param [params.options.removeOriginal] - Whether or not to remove the original segmentation. Defaults to true.\n *\n * @returns A promise that resolves when the conversion is complete.\n */\nasync function convertStackToVolumeSegmentation({\n  segmentationId,\n  options,\n}: {\n  segmentationId: string;\n  options?: {\n    toolGroupId: string;\n    volumeId?: string;\n    newSegmentationId?: string;\n    removeOriginal?: boolean;\n  };\n}): Promise<void> {\n  const segmentation = getSegmentation(segmentationId);\n  const { toolGroupId } = options;\n  const data = segmentation.representationData\n    .LABELMAP as LabelmapSegmentationDataStack;\n\n  const imageIdReferenceMap = data.imageIdReferenceMap;\n\n  // Get the imageIds from the imageIdReferenceMap\n  const segmentationImageIds = Array.from(imageIdReferenceMap.values());\n\n  const additionalDetails = {\n    imageIdReferenceMap,\n  };\n\n  // Since segmentations are already cached and are not\n  // loaded like volumes, we can create a volume out of their images\n  const volumeId = options?.volumeId;\n\n  await volumeLoader.createAndCacheVolumeFromImages(\n    volumeId,\n    segmentationImageIds,\n    {\n      additionalDetails,\n    }\n  );\n\n  const newSegmentationId = options?.newSegmentationId ?? csUtils.uuidv4();\n\n  if (options?.removeOriginal ?? true) {\n    removeSegmentation(segmentationId);\n  }\n\n  await addSegmentations([\n    {\n      segmentationId: newSegmentationId,\n      representation: {\n        type: SegmentationRepresentations.Labelmap,\n        data: {\n          volumeId,\n        },\n      },\n    },\n  ]);\n\n  await addSegmentationRepresentations(toolGroupId, [\n    {\n      segmentationId: newSegmentationId,\n      type: SegmentationRepresentations.Labelmap,\n    },\n  ]);\n\n  triggerSegmentationRender(toolGroupId);\n  // Note: It is crucial to trigger the data modified event. This ensures that the\n  // old texture is updated to the GPU, especially in scenarios where it may not be getting updated.\n  eventTarget.addEventListenerOnce(Events.SEGMENTATION_RENDERED, () =>\n    triggerSegmentationDataModified(newSegmentationId)\n  );\n}\n\nexport { convertStackToVolumeSegmentation };\n","import {\n  Types,\n  cache,\n  utilities as csUtils,\n  eventTarget,\n} from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport addSegmentations from './addSegmentations';\nimport addSegmentationRepresentations from './addSegmentationRepresentations';\nimport {\n  triggerSegmentationRender,\n  createImageIdReferenceMap,\n} from '../../utilities/segmentation';\nimport { getSegmentation, removeSegmentation } from './segmentationState';\nimport { LabelmapSegmentationDataVolume } from '../../types/LabelmapTypes';\nimport { triggerSegmentationDataModified } from './triggerSegmentationEvents';\n\n/**\n * Converts a volume segmentation to a stack segmentation.\n *\n * @param params - The parameters for the conversion.\n * @param params.segmentationId - The segmentationId to convert.\n * @param [params.options] - The conversion options.\n * @param params.options.toolGroupId - The new toolGroupId that the new segmentation will belong to.\n * @param [params.options.newSegmentationId] -  The new segmentationId to use for the segmentation. If not provided, a new ID will be generated.\n * @param [params.options.removeOriginal] - Whether or not to remove the original segmentation. Defaults to true.\n *\n * @returns A promise that resolves when the conversion is complete.\n */\nexport async function convertVolumeToStackSegmentation({\n  segmentationId,\n  options,\n}: {\n  segmentationId: string;\n  options?: {\n    toolGroupId: string;\n    newSegmentationId?: string;\n    removeOriginal?: boolean;\n  };\n}): Promise<void> {\n  const segmentation = getSegmentation(segmentationId);\n\n  const { toolGroupId } = options;\n  const data = segmentation.representationData\n    .LABELMAP as LabelmapSegmentationDataVolume;\n\n  const segmentationVolume = cache.getVolume(\n    data.volumeId\n  ) as Types.IImageVolume;\n\n  const imageIdReferenceMap =\n    _getImageIdReferenceMapForStackSegmentation(segmentationVolume);\n\n  const newSegmentationId = options?.newSegmentationId ?? csUtils.uuidv4();\n\n  if (options?.removeOriginal ?? true) {\n    removeSegmentation(segmentationId);\n  }\n\n  await addSegmentations([\n    {\n      segmentationId: newSegmentationId,\n      representation: {\n        type: SegmentationRepresentations.Labelmap,\n        data: {\n          imageIdReferenceMap,\n        },\n      },\n    },\n  ]);\n  // Add the segmentation representation to the toolgroup\n  await addSegmentationRepresentations(toolGroupId, [\n    {\n      segmentationId: newSegmentationId,\n      type: SegmentationRepresentations.Labelmap,\n    },\n  ]);\n\n  triggerSegmentationRender(toolGroupId);\n  // Note: It is crucial to trigger the data modified event. This ensures that the\n  // old texture is updated to the GPU, especially in scenarios where it may not be getting updated.\n  eventTarget.addEventListenerOnce(Events.SEGMENTATION_RENDERED, () =>\n    triggerSegmentationDataModified(newSegmentationId)\n  );\n}\n\nfunction _getImageIdReferenceMapForStackSegmentation(\n  segmentationVolume: Types.IImageVolume\n) {\n  // There might be or might not be segmentationImageIds, if it is a volume\n  // segmentation converted from stack segmentation, there will be segmentationImageIds\n  // otherwise, if it is empty volume segmentation derived from\n  // a volume that is not a stack, there will be no segmentationImageIds\n  const segmentationImageIds = segmentationVolume.imageIds;\n\n  if (segmentationVolume.additionalDetails?.imageIdReferenceMap) {\n    // this means the segmentation volume is derived from a stack segmentation\n    // and we can use the imageIdReferenceMap from the additionalDetails\n    return segmentationVolume.additionalDetails.imageIdReferenceMap;\n  } else if (\n    segmentationVolume.referencedImageIds?.length &&\n    !segmentationVolume.referencedImageIds[0].startsWith('derived')\n  ) {\n    // this means the segmentation volume is derived from a stack segmentation\n    // and we can use the referencedImageIds from the segmentationVolume\n    const referencedImageIds = segmentationVolume.referencedImageIds;\n\n    return createImageIdReferenceMap(referencedImageIds, segmentationImageIds);\n  } else {\n    // check if the segmentation volume is derived from another volume and\n    // whether if that volume has imageIds\n    const referencedVolumeId = segmentationVolume.referencedVolumeId;\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n\n    if (!referencedVolume) {\n      throw new Error(\n        'Cannot convert volumetric segmentation without referenced volume to stack segmentation yet'\n      );\n    }\n\n    if (!referencedVolume?.imageIds?.length) {\n      throw new Error(\n        'Cannot convert volumetric segmentation without imageIds to stack segmentation yet'\n      );\n    }\n\n    if (referencedVolume.imageIds?.[0].startsWith('derived')) {\n      throw new Error(\n        `Cannot convert volume segmentation that is derived from another segmentation\n         to stack segmentation yet, include the additionalDetails.imageIdReferenceMap\n         in the volume segmentation in case you need it for the conversion`\n      );\n    }\n\n    // if the referenced volume has imageIds, and itself is not derived from\n    // another segmentation then we can use the imageIds from the referenced volume\n    const referencedImageIds = referencedVolume.imageIds;\n\n    let segmentationImageIdsToUse = segmentationVolume.imageIds;\n    if (!segmentationImageIdsToUse?.length) {\n      // If segmentation Ids don't exist it means that the segmentation is literally\n      // just a volume so we need to assume imageIds and decache it to the _imageCache\n      // so that it can be used for the conversion\n      segmentationImageIdsToUse =\n        segmentationVolume.convertToImageSlicesAndCache();\n    }\n\n    return createImageIdReferenceMap(\n      referencedImageIds,\n      segmentationImageIdsToUse\n    );\n  }\n}\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\n\n/**\n * Tool that pans the camera in the plane defined by the viewPlaneNormal and the viewUp.\n */\nclass PanTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n\n    const deltaPointsWorld = deltaPoints.world;\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    enabledElement.viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n    enabledElement.viewport.render();\n  }\n}\n\nPanTool.toolName = 'Pan';\nexport default PanTool;\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\n\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\nimport { BaseTool } from './base';\n\n/**\n * Tool that rotates the camera in the plane defined by the viewPlaneNormal and the viewUp.\n */\nclass TrackballRotateTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  mouseDragCallback: (evt: EventTypes.InteractionEventType) => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        rotateIncrementDegrees: 2,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this.touchDragCallback = this._dragCallback.bind(this);\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  rotateCamera = (viewport, centerWorld, axis, angle) => {\n    const vtkCamera = viewport.getVtkActiveCamera();\n    const viewUp = vtkCamera.getViewUp();\n    const focalPoint = vtkCamera.getFocalPoint();\n    const position = vtkCamera.getPosition();\n\n    const newPosition: Types.Point3 = [0, 0, 0];\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newViewUp: Types.Point3 = [0, 0, 0];\n\n    const transform = mat4.identity(new Float32Array(16));\n    mat4.translate(transform, transform, centerWorld);\n    mat4.rotate(transform, transform, angle, axis);\n    mat4.translate(transform, transform, [\n      -centerWorld[0],\n      -centerWorld[1],\n      -centerWorld[2],\n    ]);\n    vec3.transformMat4(newPosition, position, transform);\n    vec3.transformMat4(newFocalPoint, focalPoint, transform);\n\n    mat4.identity(transform);\n    mat4.rotate(transform, transform, angle, axis);\n    vec3.transformMat4(newViewUp, viewUp, transform);\n\n    viewport.setCamera({\n      position: newPosition,\n      viewUp: newViewUp,\n      focalPoint: newFocalPoint,\n    });\n  };\n\n  // pseudocode inspired from\n  // https://github.com/kitware/vtk-js/blob/HEAD/Sources/Interaction/Manipulators/MouseCameraUnicamRotateManipulator/index.js\n  _dragCallback(evt: EventTypes.InteractionEventType): void {\n    const { element, currentPoints, lastPoints } = evt.detail;\n    const currentPointsCanvas = currentPoints.canvas;\n    const lastPointsCanvas = lastPoints.canvas;\n    const { rotateIncrementDegrees } = this.configuration;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const camera = viewport.getCamera();\n    const width = element.clientWidth;\n    const height = element.clientHeight;\n\n    const normalizedPosition = [\n      currentPointsCanvas[0] / width,\n      currentPointsCanvas[1] / height,\n    ];\n\n    const normalizedPreviousPosition = [\n      lastPointsCanvas[0] / width,\n      lastPointsCanvas[1] / height,\n    ];\n\n    const center: Types.Point2 = [width * 0.5, height * 0.5];\n    // NOTE: centerWorld corresponds to the focal point in cornerstone3D\n    const centerWorld = viewport.canvasToWorld(center);\n    const normalizedCenter = [0.5, 0.5];\n\n    const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\n    const op = [normalizedPreviousPosition[0], 0, 0];\n    const oe = [normalizedPosition[0], 0, 0];\n\n    const opsq = op[0] ** 2;\n    const oesq = oe[0] ** 2;\n\n    const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\n    const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\n\n    const nop: Types.Point3 = [op[0], 0, lop];\n    vtkMath.normalize(nop);\n    const noe: Types.Point3 = [oe[0], 0, loe];\n    vtkMath.normalize(noe);\n\n    const dot = vtkMath.dot(nop, noe);\n    if (Math.abs(dot) > 0.0001) {\n      const angleX =\n        -2 *\n        Math.acos(vtkMath.clampValue(dot, -1.0, 1.0)) *\n        Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *\n        rotateIncrementDegrees;\n\n      const upVec = camera.viewUp;\n      const atV = camera.viewPlaneNormal;\n      const rightV: Types.Point3 = [0, 0, 0];\n      const forwardV: Types.Point3 = [0, 0, 0];\n\n      vtkMath.cross(upVec, atV, rightV);\n      vtkMath.normalize(rightV);\n\n      vtkMath.cross(atV, rightV, forwardV);\n      vtkMath.normalize(forwardV);\n      vtkMath.normalize(upVec);\n\n      this.rotateCamera(viewport, centerWorld, forwardV, angleX);\n\n      const angleY =\n        (normalizedPreviousPosition[1] - normalizedPosition[1]) *\n        rotateIncrementDegrees;\n\n      this.rotateCamera(viewport, centerWorld, rightV, angleY);\n\n      viewport.render();\n    }\n  }\n}\n\nTrackballRotateTool.toolName = 'TrackballRotate';\nexport default TrackballRotateTool;\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport { vec2 } from 'gl-matrix';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { roundNumber } from '../../utilities';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { ProbeAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport {\n  ModalityUnitOptions,\n  getModalityUnit,\n} from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * ProbeTool let you get the underlying voxel value by putting a probe in that\n * location. It will give index of the location and value of the voxel.\n * You can use ProbeTool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Probe tool's text box are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * To use the ProbeTool, you first need to add it to cornerstoneTools, then create\n * a toolGroup and add the ProbeTool to it. Finally, setToolActive on the toolGroup\n *\n * ```js\n * cornerstoneTools.addTool(ProbeTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(ProbeTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(ProbeTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n *\n */\n\nclass ProbeTool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    newAnnotation?: boolean;\n  } | null;\n  eventDispatchDetail: {\n    viewportId: string;\n    renderingEngineId: string;\n  };\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  // Not necessary for this tool but needs to be defined since it's an abstract\n  // method from the parent class.\n  isPointNearTool(): boolean {\n    return false;\n  }\n\n  toolSelectedCallback() {}\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Probe Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: { points: [<Types.Point3>[...worldPos]] },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      newAnnotation: true,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It checks if the mouse click is near ProveTool, it overwrites the baseAnnotationTool\n   * getHandleNearImagePoint method.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: ProbeAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const point = data.handles.points[0];\n    const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n\n    const near =\n      vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n\n    if (near === true) {\n      return point;\n    }\n  }\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: ProbeAnnotation\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    // Find viewports to render on drag.\n\n    this.editData = {\n      //handle, // This would be useful for other tools with more than one handle\n      annotation,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const { viewportId } = enabledElement;\n    this.eventDispatchDetail = {\n      viewportId,\n      renderingEngineId: renderingEngine.id,\n    };\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n  };\n\n  _dragCallback = (evt) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n\n    data.handles.points[0] = [...worldPos];\n    annotation.invalidated = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the probe annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ProbeAnnotation;\n      const annotationUID = annotation.annotationUID;\n      const data = annotation.data;\n      const point = data.handles.points[0];\n      const canvasCoordinates = viewport.worldToCanvas(point);\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color } = this.getAnnotationStyle({ annotation, styleSpecifier });\n\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].value == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          index: null,\n          value: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related stackViewports data if\n        // they are not at the referencedImageId, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      const handleGroupUID = '0';\n\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        [canvasCoordinates],\n        { color }\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (textLines) {\n        const textCanvasCoordinates = [\n          canvasCoordinates[0] + 6,\n          canvasCoordinates[1] - 6,\n        ];\n\n        const textUID = '0';\n        drawTextBoxSvg(\n          svgDrawingHelper,\n          annotationUID,\n          textUID,\n          textLines,\n          [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n          options\n        );\n      }\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId, viewport } = enabledElement;\n\n    const worldPos = data.handles.points[0];\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const modalityUnitOptions = {\n        isPreScaled: isViewportPreScaled(viewport, targetId),\n        isSuvScaled: this.isSuvScaled(\n          viewport,\n          targetId,\n          annotation.metadata.referencedImageId\n        ),\n      };\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata } = image;\n      const scalarData =\n        'getScalarData' in image ? image.getScalarData() : image.scalarData;\n\n      const modality = metadata.Modality;\n      const index = transformWorldToIndex(imageData, worldPos);\n\n      index[0] = Math.round(index[0]);\n      index[1] = Math.round(index[1]);\n      index[2] = Math.round(index[2]);\n\n      const samplesPerPixel =\n        scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\n\n      if (csUtils.indexWithinDimensions(index, dimensions)) {\n        this.isHandleOutsideImage = false;\n        const yMultiple = dimensions[0] * samplesPerPixel;\n        const zMultiple = dimensions[0] * dimensions[1] * samplesPerPixel;\n\n        const baseIndex =\n          index[2] * zMultiple +\n          index[1] * yMultiple +\n          index[0] * samplesPerPixel;\n        let value =\n          samplesPerPixel > 2\n            ? [\n                scalarData[baseIndex],\n                scalarData[baseIndex + 1],\n                scalarData[baseIndex + 2],\n              ]\n            : scalarData[baseIndex];\n\n        // Index[2] for stackViewport is always 0, but for visualization\n        // we reset it to be imageId index\n        if (targetId.startsWith('imageId:')) {\n          const imageId = targetId.split('imageId:')[1];\n          const imageURI = csUtils.imageIdToURI(imageId);\n          const viewports = csUtils.getViewportsWithImageURI(\n            imageURI,\n            renderingEngineId\n          );\n\n          const viewport = viewports[0];\n\n          index[2] = viewport.getCurrentImageIdIndex();\n        }\n\n        let modalityUnit;\n\n        if (modality === 'US') {\n          const calibratedResults = getCalibratedProbeUnitsAndValue(image, [\n            index,\n          ]);\n\n          const hasEnhancedRegionValues = calibratedResults.values.every(\n            (value) => value !== null\n          );\n\n          value = hasEnhancedRegionValues ? calibratedResults.values : value;\n          modalityUnit = hasEnhancedRegionValues\n            ? calibratedResults.units\n            : 'raw';\n        } else {\n          modalityUnit = getModalityUnit(\n            modality,\n            annotation.metadata.referencedImageId,\n            modalityUnitOptions\n          );\n        }\n\n        cachedStats[targetId] = {\n          index,\n          value,\n          Modality: modality,\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetId] = {\n          index,\n          Modality: modality,\n        };\n      }\n\n      annotation.invalidated = false;\n\n      // Dispatching annotation modified\n      const eventType = Events.ANNOTATION_MODIFIED;\n\n      const eventDetail: AnnotationModifiedEventDetail = {\n        annotation,\n        viewportId,\n        renderingEngineId,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    return cachedStats;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { index, value, modalityUnit } = cachedVolumeStats;\n\n  if (value === undefined) {\n    return;\n  }\n\n  const textLines = [];\n\n  textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n\n  if (value instanceof Array && modalityUnit instanceof Array) {\n    for (let i = 0; i < value.length; i++) {\n      textLines.push(`${roundNumber(value[i])} ${modalityUnit[i]}`);\n    }\n  } else {\n    textLines.push(`${roundNumber(value)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nProbeTool.toolName = 'Probe';\nexport default ProbeTool;\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  PublicToolProps,\n  SVGDrawingHelper,\n  ToolProps,\n} from '../../types';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport ProbeTool from './ProbeTool';\nimport { ProbeAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\n\nclass DragProbeTool extends ProbeTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    newAnnotation?: boolean;\n  } | null;\n  eventDispatchDetail: {\n    viewportId: string;\n    renderingEngineId: string;\n  };\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  postMouseDownCallback = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotation: ProbeAnnotation = {\n      invalidated: true,\n      highlighted: true,\n      isVisible: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: { points: [<Types.Point3>[...worldPos]] },\n        cachedStats: {},\n      },\n    };\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      newAnnotation: true,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  postTouchStartCallback = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    return this.postMouseDownCallback(evt);\n  };\n\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const annotations = this.filterInteractableAnnotationsForElement(\n      viewport.element,\n      [this.editData.annotation]\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const annotation = this.editData.annotation;\n    const annotationUID = annotation.annotationUID;\n    const data = annotation.data;\n    const point = data.handles.points[0];\n    const canvasCoordinates = viewport.worldToCanvas(point);\n\n    styleSpecifier.annotationUID = annotationUID;\n\n    const { color } = this.getAnnotationStyle({\n      annotation,\n      styleSpecifier,\n    });\n\n    const modalityUnitOptions = {\n      isPreScaled: isViewportPreScaled(viewport, targetId),\n\n      isSuvScaled: this.isSuvScaled(\n        viewport,\n        targetId,\n        annotation.metadata.referencedImageId\n      ),\n    };\n\n    if (\n      !data.cachedStats[targetId] ||\n      data.cachedStats[targetId].value == null\n    ) {\n      data.cachedStats[targetId] = {\n        Modality: null,\n        index: null,\n        value: null,\n      };\n\n      this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n    } else if (annotation.invalidated) {\n      this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n    }\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const handleGroupUID = '0';\n\n    drawHandlesSvg(\n      svgDrawingHelper,\n      annotationUID,\n      handleGroupUID,\n      [canvasCoordinates],\n      { color }\n    );\n\n    renderStatus = true;\n\n    const textLines = this.configuration.getTextLines(data, targetId);\n    if (textLines) {\n      const textCanvasCoordinates = [\n        canvasCoordinates[0] + 6,\n        canvasCoordinates[1] - 6,\n      ];\n\n      const textUID = '0';\n      drawTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textUID,\n        textLines,\n        [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n        this.getLinkedTextBoxStyle(styleSpecifier, annotation)\n      );\n    }\n\n    return renderStatus;\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { index, value, modalityUnit } = cachedVolumeStats;\n\n  if (value === undefined) {\n    return;\n  }\n\n  const textLines = [];\n\n  textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n\n  textLines.push(`${value.toFixed(2)} ${modalityUnit}`);\n\n  return textLines;\n}\n\nDragProbeTool.toolName = 'DragProbe';\nexport default DragProbeTool;\n","import { BaseTool } from './base';\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  StackViewport,\n  utilities,\n  cache,\n  Types,\n} from '@cornerstonejs/core';\nimport { EventTypes } from '../types';\n\n// Todo: should move to configuration\nconst DEFAULT_MULTIPLIER = 4;\nconst DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;\nconst PT = 'PT';\n\n/**\n * WindowLevel tool manipulates the windowLevel applied to a viewport. It\n * provides a way to set the windowCenter and windowWidth of a viewport\n * by dragging mouse over the image.\n *\n */\nclass WindowLevelTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this.mouseDragCallback(evt);\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n\n    let volumeId,\n      lower,\n      upper,\n      modality,\n      newRange,\n      viewportsContainingVolumeUID;\n    let isPreScaled = false;\n\n    const properties = viewport.getProperties();\n    if (viewport instanceof VolumeViewport) {\n      const targetId = this.getTargetId(viewport as Types.IVolumeViewport);\n      volumeId = targetId.split('volumeId:')[1];\n      viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(\n        volumeId,\n        renderingEngine.id\n      );\n      ({ lower, upper } = properties.voiRange);\n      const volume = cache.getVolume(volumeId);\n      if (!volume) {\n        throw new Error('Volume not found ' + volumeId);\n      }\n      modality = volume.metadata.Modality;\n      isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;\n    } else if (properties.voiRange) {\n      modality = (viewport as any).modality;\n      ({ lower, upper } = properties.voiRange);\n      const { preScale = { scaled: false } } = viewport.getImageData?.() || {};\n      isPreScaled =\n        preScale.scaled && preScale.scalingParameters?.suvbw !== undefined;\n    } else {\n      throw new Error('Viewport is not a valid type');\n    }\n\n    // If modality is PT an the viewport is pre-scaled (SUV),\n    // treat it special to not include the canvas delta in\n    // the x direction. For other modalities, use the canvas delta in both\n    // directions, and if the viewport is a volumeViewport, the multiplier\n    // is calculate using the volume min and max.\n    if (modality === PT && isPreScaled) {\n      newRange = this.getPTScaledNewRange({\n        deltaPointsCanvas: deltaPoints.canvas,\n        lower,\n        upper,\n        clientHeight: element.clientHeight,\n        isPreScaled,\n        viewport,\n        volumeId,\n      });\n    } else {\n      newRange = this.getNewRange({\n        viewport,\n        deltaPointsCanvas: deltaPoints.canvas,\n        volumeId,\n        lower,\n        upper,\n      });\n    }\n\n    viewport.setProperties({\n      voiRange: newRange,\n    });\n\n    viewport.render();\n\n    if (viewport instanceof VolumeViewport) {\n      viewportsContainingVolumeUID.forEach((vp) => {\n        if (viewport !== vp) {\n          vp.render();\n        }\n      });\n      return;\n    }\n  }\n\n  getPTScaledNewRange({\n    deltaPointsCanvas,\n    lower,\n    upper,\n    clientHeight,\n    viewport,\n    volumeId,\n    isPreScaled,\n  }) {\n    let multiplier = DEFAULT_MULTIPLIER;\n\n    if (isPreScaled) {\n      multiplier = 5 / clientHeight;\n    } else {\n      multiplier =\n        this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n        DEFAULT_MULTIPLIER;\n    }\n\n    const deltaY = deltaPointsCanvas[1];\n    const wcDelta = deltaY * multiplier;\n\n    upper -= wcDelta;\n    upper = isPreScaled ? Math.max(upper, 0.1) : upper;\n\n    return { lower, upper };\n  }\n\n  getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {\n    const multiplier =\n      this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n      DEFAULT_MULTIPLIER;\n\n    const wwDelta = deltaPointsCanvas[0] * multiplier;\n    const wcDelta = deltaPointsCanvas[1] * multiplier;\n\n    let { windowWidth, windowCenter } = utilities.windowLevel.toWindowLevel(\n      lower,\n      upper\n    );\n\n    windowWidth += wwDelta;\n    windowCenter += wcDelta;\n\n    windowWidth = Math.max(windowWidth, 1);\n\n    // Convert back to range\n    return utilities.windowLevel.toLowHighRange(windowWidth, windowCenter);\n  }\n\n  _getMultiplierFromDynamicRange(viewport, volumeId) {\n    let imageDynamicRange;\n\n    if (volumeId) {\n      const imageVolume = cache.getVolume(volumeId);\n      const { dimensions } = imageVolume;\n      const scalarData = imageVolume.getScalarData();\n      const calculatedDynamicRange = this._getImageDynamicRangeFromMiddleSlice(\n        scalarData,\n        dimensions\n      );\n      const BitsStored = imageVolume?.metadata?.BitsStored;\n      const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;\n      // Burned in Pixels often use pixel values above the BitsStored.\n      // This results in a multiplier which is way higher than what you would\n      // want in practice. Thus we take the min between the metadata dynamic\n      // range and actual middel slice dynamic range.\n      imageDynamicRange = Math.min(\n        calculatedDynamicRange,\n        metadataDynamicRange\n      );\n    } else {\n      imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);\n    }\n\n    const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;\n\n    return ratio > 1 ? Math.round(ratio) : ratio;\n  }\n\n  _getImageDynamicRangeFromViewport(viewport) {\n    const { imageData } = viewport.getImageData();\n    const dimensions = imageData.getDimensions();\n\n    if (imageData.getRange) {\n      return imageData.getRange();\n    }\n    let scalarData;\n    // if getScalarData is a method on imageData\n    if (imageData.getScalarData) {\n      scalarData = imageData.getScalarData();\n    } else {\n      scalarData = imageData.getPointData().getScalars();\n    }\n\n    if (dimensions[2] !== 1) {\n      return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);\n    }\n\n    let range;\n    if (scalarData.getRange) {\n      range = scalarData.getRange();\n    } else {\n      const { min, max } = this._getMinMax(scalarData, scalarData.length);\n      range = [min, max];\n    }\n\n    return range[1] - range[0];\n  }\n\n  _getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {\n    const middleSliceIndex = Math.floor(dimensions[2] / 2);\n\n    const frameLength = dimensions[0] * dimensions[1];\n    let bytesPerVoxel;\n    let TypedArrayConstructor;\n\n    if (scalarData instanceof Float32Array) {\n      bytesPerVoxel = 4;\n      TypedArrayConstructor = Float32Array;\n    } else if (scalarData instanceof Uint8Array) {\n      bytesPerVoxel = 1;\n      TypedArrayConstructor = Uint8Array;\n    } else if (scalarData instanceof Uint16Array) {\n      bytesPerVoxel = 2;\n      TypedArrayConstructor = Uint16Array;\n    } else if (scalarData instanceof Int16Array) {\n      bytesPerVoxel = 2;\n      TypedArrayConstructor = Int16Array;\n    }\n\n    const buffer = scalarData.buffer;\n    const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;\n    const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);\n\n    const { max, min } = this._getMinMax(frame, frameLength);\n\n    return max - min;\n  };\n\n  private _getMinMax(frame: Uint8Array | Float32Array, frameLength: number) {\n    let min = Infinity;\n    let max = -Infinity;\n\n    for (let i = 0; i < frameLength; i++) {\n      const voxel = frame[i];\n\n      if (voxel < min) {\n        min = voxel;\n      }\n\n      if (voxel > max) {\n        max = voxel;\n      }\n    }\n    return { max, min };\n  }\n}\n\nWindowLevelTool.toolName = 'WindowLevel';\nexport default WindowLevelTool;\n","import { vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { getEnabledElement, Types } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\n\n/**\n * ZoomTool tool manipulates the camera zoom applied to a viewport. It\n * provides a way to set the zoom of a viewport by dragging mouse over the image.\n *\n */\nclass ZoomTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  mouseDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  initialMousePosWorld: Types.Point3;\n  dirVec: Types.Point3;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        // whether zoom to the center of the image OR zoom to the mouse position\n        zoomToCenter: false,\n        minZoomScale: 0.1,\n        maxZoomScale: 30,\n        pinchToZoom: true,\n        pan: true,\n        invert: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.initialMousePosWorld = [0, 0, 0];\n    this.dirVec = [0, 0, 0];\n    if (this.configuration.pinchToZoom) {\n      this.touchDragCallback = this._pinchCallback.bind(this);\n    } else {\n      this.touchDragCallback = this._dragCallback.bind(this);\n    }\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventData = evt.detail;\n    const { element, currentPoints } = eventData;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint } = camera;\n\n    this.initialMousePosWorld = worldPos;\n\n    // The direction vector from the clicked location to the focal point\n    // which would act as the vector to translate the image (if zoomToCenter is false)\n    let dirVec = vec3.fromValues(\n      focalPoint[0] - worldPos[0],\n      focalPoint[1] - worldPos[1],\n      focalPoint[2] - worldPos[2]\n    );\n\n    dirVec = vec3.normalize(vec3.create(), dirVec);\n\n    this.dirVec = dirVec as Types.Point3;\n\n    // we should not return true here, returning true in the preMouseDownCallback\n    // means that the event is handled by the tool and no other methods\n    // can claim the event, which will result in a bug where having Zoom on primary\n    // and clicking on an annotation will not manipulate the annotation, but will\n    // instead zoom the image (which is not what we want), so we return false here\n    return false;\n  };\n\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    if (!this.configuration.pinchToZoom) {\n      return this.preMouseDownCallback(evt);\n    }\n  };\n\n  _pinchCallback(evt: EventTypes.InteractionEventType) {\n    const pointsList = (evt as EventTypes.TouchStartEventType).detail\n      .currentPointsList;\n\n    if (pointsList.length > 1) {\n      const { element, currentPoints } = evt.detail;\n      const enabledElement = getEnabledElement(element);\n      const { viewport } = enabledElement;\n      const camera = viewport.getCamera();\n      const worldPos = currentPoints.world;\n      const { focalPoint } = camera;\n      this.initialMousePosWorld = worldPos;\n      // The direction vector from the clicked location to the focal point\n      // which would act as the vector to translate the image (if zoomToCenter is false)\n      let dirVec = vec3.fromValues(\n        focalPoint[0] - worldPos[0],\n        focalPoint[1] - worldPos[1],\n        focalPoint[2] - worldPos[2]\n      );\n      dirVec = vec3.normalize(vec3.create(), dirVec);\n\n      this.dirVec = dirVec as Types.Point3;\n      if (camera.parallelProjection) {\n        this._dragParallelProjection(evt, viewport, camera, true);\n      } else {\n        this._dragPerspectiveProjection(evt, viewport, camera, true);\n      }\n      viewport.render();\n    }\n\n    if (this.configuration.pan) {\n      this._panCallback(evt);\n    }\n  }\n\n  // Takes ICornerstoneEvent, Mouse or Touch\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { element } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n\n    if (camera.parallelProjection) {\n      this._dragParallelProjection(evt, viewport, camera);\n    } else {\n      this._dragPerspectiveProjection(evt, viewport, camera);\n    }\n\n    viewport.render();\n  }\n\n  _dragParallelProjection = (\n    evt: EventTypes.InteractionEventType,\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    camera: Types.ICamera,\n    pinch = false\n  ): void => {\n    const { element, deltaPoints } = evt.detail;\n    const deltaY = pinch\n      ? (evt as EventTypes.TouchDragEventType).detail.deltaDistance.canvas\n      : deltaPoints.canvas[1];\n\n    const size = [element.clientWidth, element.clientHeight];\n    const { parallelScale, focalPoint, position } = camera;\n\n    const zoomScale = 5 / size[1];\n    const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);\n\n    const parallelScaleToSet = (1.0 - k) * parallelScale;\n\n    let focalPointToSet = focalPoint;\n    let positionToSet = position;\n\n    // if we're not zooming to the center, we need to adjust the focal point\n    // and position to set the focal point and position to the value that\n    // would simulate the zoom to the mouse position\n    if (!this.configuration.zoomToCenter) {\n      // Distance of the initial mouse position (world) to the focal point\n      // which is always the center of the canvas.\n      const distanceToCanvasCenter = vec3.distance(\n        focalPoint,\n        this.initialMousePosWorld\n      );\n\n      positionToSet = vec3.scaleAndAdd(\n        vec3.create(),\n        position,\n        this.dirVec,\n        -distanceToCanvasCenter * k\n      ) as Types.Point3;\n\n      focalPointToSet = vec3.scaleAndAdd(\n        vec3.create(),\n        focalPoint,\n        this.dirVec,\n        -distanceToCanvasCenter * k\n      ) as Types.Point3;\n    }\n\n    // If it is a regular GPU accelerated viewport, then parallel scale\n    // has a physical meaning and we can use that to determine the threshold\n    // Added spacing preset in case there is no imageData on viewport\n    const imageData = viewport.getImageData();\n    let spacing = [1, 1, 1];\n    if (imageData) {\n      spacing = imageData.spacing;\n    }\n\n    const { minZoomScale, maxZoomScale } = this.configuration;\n\n    const t = element.clientHeight * spacing[1] * 0.5;\n    const scale = t / parallelScaleToSet;\n\n    let cappedParallelScale = parallelScaleToSet;\n    let thresholdExceeded = false;\n\n    if (imageData) {\n      if (scale < minZoomScale) {\n        cappedParallelScale = t / minZoomScale;\n        thresholdExceeded = true;\n      } else if (scale >= maxZoomScale) {\n        cappedParallelScale = t / maxZoomScale;\n        thresholdExceeded = true;\n      }\n    }\n\n    viewport.setCamera({\n      parallelScale: cappedParallelScale,\n      focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,\n      position: thresholdExceeded ? position : positionToSet,\n    });\n  };\n\n  _dragPerspectiveProjection = (\n    evt: EventTypes.InteractionEventType,\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    camera: Types.ICamera,\n    pinch = false\n  ): void => {\n    const { element, deltaPoints } = evt.detail;\n    const deltaY = pinch\n      ? (evt as EventTypes.TouchDragEventType).detail.deltaDistance.canvas\n      : deltaPoints.canvas[1];\n\n    const size = [element.clientWidth, element.clientHeight];\n    const { position, focalPoint, viewPlaneNormal } = camera;\n\n    const distance = vtkMath.distance2BetweenPoints(position, focalPoint);\n    const zoomScale = Math.sqrt(distance) / size[1];\n\n    const directionOfProjection = [\n      -viewPlaneNormal[0],\n      -viewPlaneNormal[1],\n      -viewPlaneNormal[2],\n    ];\n\n    const k = this.configuration.invert\n      ? deltaY / zoomScale\n      : deltaY * zoomScale;\n\n    let tmp = k * directionOfProjection[0];\n    position[0] += tmp;\n    focalPoint[0] += tmp;\n\n    tmp = k * directionOfProjection[1];\n    position[1] += tmp;\n    focalPoint[1] += tmp;\n\n    tmp = k * directionOfProjection[2];\n    position[2] += tmp;\n    focalPoint[2] += tmp;\n\n    viewport.setCamera({ position, focalPoint });\n  };\n\n  _panCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n\n    const deltaPointsWorld = deltaPoints.world;\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    enabledElement.viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n    enabledElement.viewport.render();\n  }\n}\n\nZoomTool.toolName = 'Zoom';\nexport default ZoomTool;\n","import { getEnabledElementByIds, VolumeViewport } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { scroll } from '../utilities';\nimport { PublicToolProps, ToolProps, EventTypes } from '../types';\n\n/**\n * The StackScrollTool is a tool that allows the user to scroll through a\n * stack of images by pressing the mouse click and dragging\n */\nclass StackScrollTool extends BaseTool {\n  static toolName;\n  deltaY: number;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        invert: false,\n        debounceIfNotLoaded: true,\n        loop: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.deltaY = 1;\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { deltaPoints, viewportId, renderingEngineId } = evt.detail;\n    const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n\n    const targetId = this.getTargetId(viewport);\n    const { debounceIfNotLoaded, invert, loop } = this.configuration;\n\n    const deltaPointY = deltaPoints.canvas[1];\n    let volumeId;\n    if (viewport instanceof VolumeViewport) {\n      volumeId = targetId.split('volumeId:')[1];\n    }\n\n    const pixelsPerImage = this._getPixelPerImage(viewport);\n    const deltaY = deltaPointY + this.deltaY;\n\n    if (!pixelsPerImage) {\n      return;\n    }\n\n    if (Math.abs(deltaY) >= pixelsPerImage) {\n      const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);\n\n      scroll(viewport, {\n        delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,\n        volumeId,\n        debounceLoading: debounceIfNotLoaded,\n        loop: loop,\n      });\n\n      this.deltaY = deltaY % pixelsPerImage;\n    } else {\n      this.deltaY = deltaY;\n    }\n  }\n\n  _getPixelPerImage(viewport) {\n    const { element } = viewport;\n    const numberOfSlices = viewport.getNumberOfSlices();\n\n    // The Math.max here makes it easier to mouseDrag-scroll small or really large image stacks\n    return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));\n  }\n}\n\nStackScrollTool.toolName = 'StackScroll';\nexport default StackScrollTool;\n","import type { Types } from '@cornerstonejs/core';\nimport { vec2, vec3 } from 'gl-matrix';\n\ntype Line2D = [Types.Point2, Types.Point2];\ntype Line3D = [Types.Point3, Types.Point3];\ntype Line = Line2D | Line3D;\n\n/**\n * Calculates the angle between two 3D lines.\n */\nfunction angleBetween3DLines(line1: Line3D, line2: Line3D): number {\n  const [p1, p2] = line1;\n  const [p3, p4] = line2;\n\n  const v1 = vec3.sub(vec3.create(), p2, p1);\n  const v2 = vec3.sub(vec3.create(), p3, p4);\n\n  const dot = vec3.dot(v1, v2);\n\n  const v1Length = vec3.length(v1);\n  const v2Length = vec3.length(v2);\n\n  const cos = dot / (v1Length * v2Length);\n\n  const radian = Math.acos(cos);\n\n  return (radian * 180) / Math.PI;\n}\n\n/**\n * Calculates the angle between two 2D lines.\n */\nfunction angleBetween2DLines(line1: Line2D, line2: Line2D): number {\n  const [p1, p2] = line1;\n  const [p3, p4] = line2;\n\n  const v1 = vec2.sub(vec2.create(), p2, p1);\n  const v2 = vec2.sub(vec2.create(), p3, p4);\n\n  const dot = vec2.dot(v1, v2);\n  const v1Length = vec2.length(v1);\n  const v2Length = vec2.length(v2);\n\n  const cos = dot / (v1Length * v2Length);\n  return Math.acos(cos) * (180 / Math.PI);\n}\n\n/**\n * Returns the angle between two lines in degrees.\n * The angle measured is that between the vectors\n * line1[1]->line1[0] AND line2[0]->line2[1].\n * @param line1 - Line = [p1, p2]\n * @param line2 - Line = [p3, p4]\n * @returns The angle between two lines in degrees.\n */\nexport default function angleBetweenLines(line1: Line, line2: Line): number {\n  const is3D = line1[0].length === 3;\n  return is3D\n    ? angleBetween3DLines(line1 as Line3D, line2 as Line3D)\n    : angleBetween2DLines(line1 as Line2D, line2 as Line2D);\n}\n","import {\n  BaseVolumeViewport,\n  getEnabledElement,\n  Types,\n} from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport angleBetweenLines from '../utilities/math/angle/angleBetweenLines';\nimport { PublicToolProps, ToolProps, EventTypes } from '../types';\n\n/**\n * The PlanarRotateTool is a tool that allows the user to rotate\n * the image by pressing the mouse click and dragging\n */\nclass PlanarRotateTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.MouseDragEventType) => void;\n  mouseDragCallback: (evt: EventTypes.MouseDragEventType) => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this.touchDragCallback = this._dragCallback.bind(this);\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  _dragCallback(evt: EventTypes.MouseDragEventType) {\n    const { element, currentPoints, startPoints } = evt.detail;\n    const currentPointWorld = currentPoints.world;\n    const startPointWorld = startPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const camera = viewport.getCamera();\n    const width = element.clientWidth;\n    const height = element.clientHeight;\n\n    const centerCanvas: Types.Point2 = [width * 0.5, height * 0.5];\n    const centerWorld = viewport.canvasToWorld(centerCanvas);\n\n    let angle = angleBetweenLines(\n      [startPointWorld, centerWorld],\n      [centerWorld, currentPointWorld]\n    );\n\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const v1 = vec3.sub(vec3.create(), centerWorld, startPointWorld);\n    const v2 = vec3.sub(vec3.create(), centerWorld, currentPointWorld);\n    const cross = vec3.cross(vec3.create(), v1, v2);\n    if (vec3.dot(viewPlaneNormal, cross) > 0) {\n      angle = -angle;\n    }\n\n    if (Number.isNaN(angle)) {\n      return;\n    }\n\n    if (viewport instanceof BaseVolumeViewport) {\n      const rotAngle = (angle * Math.PI) / 180;\n      const rotMat = mat4.identity(new Float32Array(16));\n      mat4.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);\n      const rotatedViewUp = vec3.transformMat4(vec3.create(), viewUp, rotMat);\n      viewport.setCamera({ viewUp: rotatedViewUp as Types.Point3 });\n    } else {\n      const { rotation } = (viewport as Types.IStackViewport).getProperties();\n      viewport.setProperties({ rotation: rotation + angle });\n    }\n\n    viewport.render();\n  }\n}\n\nPlanarRotateTool.toolName = 'PlanarRotate';\nexport default PlanarRotateTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { MouseWheelEventType } from '../types/EventTypes';\nimport scroll from '../utilities/scroll';\n\n/**\n * The StackScrollMouseWheelTool is a tool that allows the user to scroll through a\n * stack of images using the mouse wheel\n */\nclass StackScrollMouseWheelTool extends BaseTool {\n  static toolName;\n\n  _configuration: any;\n\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        invert: false,\n        debounceIfNotLoaded: true,\n        loop: false,\n        scrollSlabs: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  mouseWheelCallback(evt: MouseWheelEventType): void {\n    const { wheel, element } = evt.detail;\n    const { direction } = wheel;\n    const { invert } = this.configuration;\n    const { viewport } = getEnabledElement(element);\n    const delta = direction * (invert ? -1 : 1);\n\n    const targetId = this.getTargetId(viewport);\n    const volumeId = targetId.split('volumeId:')[1];\n\n    scroll(viewport, {\n      delta,\n      debounceLoading: this.configuration.debounceIfNotLoaded,\n      loop: this.configuration.loop,\n      volumeId,\n      scrollSlabs: this.configuration.scrollSlabs,\n    });\n  }\n}\n\nStackScrollMouseWheelTool.toolName = 'StackScrollMouseWheel';\nexport default StackScrollMouseWheelTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { mat4, vec3 } from 'gl-matrix';\nimport { PublicToolProps, ToolProps } from '../types';\nimport { MouseWheelEventType } from '../types/EventTypes';\n\nconst DIRECTIONS = {\n  X: [1, 0, 0],\n  Y: [0, 1, 0],\n  Z: [0, 0, 1],\n  CUSTOM: [],\n};\n\n/**\n * Tool that rotates the camera on mouse wheel.\n * It rotates the camera around the focal point, and around a defined axis. Default\n * axis is set to be Z axis, but it can be configured to any custom normalized axis.\n *\n */\nclass VolumeRotateMouseWheelTool extends BaseTool {\n  static toolName;\n  _configuration: any;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        direction: DIRECTIONS.Z,\n        rotateIncrementDegrees: 30,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  mouseWheelCallback(evt: MouseWheelEventType) {\n    // https://github.com/kitware/vtk-js/blob/HEAD/Sources/Interaction/Manipulators/MouseCameraUnicamRotateManipulator/index.js#L73\n    const { element, wheel } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { direction, rotateIncrementDegrees } = this.configuration;\n\n    const camera = viewport.getCamera();\n    const { viewUp, position, focalPoint } = camera;\n\n    const { direction: deltaY } = wheel;\n\n    const [cx, cy, cz] = focalPoint;\n    const [ax, ay, az] = direction;\n\n    //Calculate angle in radian as glmatrix rotate is in radian\n    const angle = (deltaY * (rotateIncrementDegrees * Math.PI)) / 180;\n\n    // position[3] = 1.0\n    // focalPoint[3] = 1.0\n    // viewUp[3] = 0.0\n\n    const newPosition: Types.Point3 = [0, 0, 0];\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newViewUp: Types.Point3 = [0, 0, 0];\n\n    const transform = mat4.identity(new Float32Array(16));\n    mat4.translate(transform, transform, [cx, cy, cz]);\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\n    mat4.translate(transform, transform, [-cx, -cy, -cz]);\n    vec3.transformMat4(newPosition, position, transform);\n    vec3.transformMat4(newFocalPoint, focalPoint, transform);\n\n    mat4.identity(transform);\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\n    vec3.transformMat4(<Types.Point3>newViewUp, viewUp, transform);\n\n    viewport.setCamera({\n      position: newPosition,\n      viewUp: newViewUp,\n      focalPoint: newFocalPoint,\n    });\n\n    viewport.render();\n  }\n}\n\nVolumeRotateMouseWheelTool.toolName = 'VolumeRotateMouseWheel';\nexport default VolumeRotateMouseWheelTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { getPointInLineOfSightWithCriteria } from '../utilities/planar';\nimport jumpToWorld from '../utilities/viewport/jumpToWorld';\nimport { PublicToolProps, ToolProps } from '../types';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\n\n/**\n * On a Maximum Intensity Projection (MIP) viewport, MIPJumpToClickTool allows the\n * user to click on a point in the MIP and the targetViewportIdS (provided in the\n * tool configuration) will be scrolled (jumped) to the location of the point with\n * the highest intensity value in the MIP.\n */\nclass MIPJumpToClickTool extends BaseTool {\n  static toolName;\n\n  _bounds: any;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        targetViewportIds: [],\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Handles the click event, and move the camera's focal point the brightest\n   * point that is in the line of sight of camera. This function 1) search for the\n   * brightest point in the line of sight, 2) move the camera to that point,\n   * this triggers a cameraModified event which then 4) moves all other synced\n   * viewports and their crosshairs.\n   *\n   * @param evt - click event\n   */\n  mouseClickCallback(evt): void {\n    const { element, currentPoints } = evt.detail;\n\n    // 1. Getting the enabled element\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    // 2. Getting the target volume that is clicked on\n    const targetId = this.getTargetId(viewport as Types.IVolumeViewport);\n\n    if (!targetId.startsWith('volumeId')) {\n      throw new Error(\n        `MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`\n      );\n    }\n\n    const volumeId = targetId.split('volumeId:')[1];\n\n    // 3. Criteria function to search for the point (maximum intensity)\n    let maxIntensity = -Infinity;\n    const maxFn = (intensity, point) => {\n      if (intensity > maxIntensity) {\n        maxIntensity = intensity;\n        return point;\n      }\n    };\n\n    // 4. Search for the brightest point location in the line of sight\n    const brightestPoint = getPointInLineOfSightWithCriteria(\n      viewport as Types.IVolumeViewport,\n      currentPoints.world,\n      volumeId,\n      maxFn\n    );\n\n    if (!brightestPoint || !brightestPoint.length) {\n      return;\n    }\n\n    const { targetViewportIds, toolGroupId } = this.configuration;\n    // TODO - consider making this a utility\n    const viewports = renderingEngine.getViewports().filter((vp) => {\n      if (targetViewportIds?.indexOf(vp.id) >= 0) {\n        return true;\n      }\n      const foundToolGroup = getToolGroupForViewport(vp.id, renderingEngine.id);\n      if (toolGroupId && toolGroupId === foundToolGroup?.id) {\n        return true;\n      }\n      return false;\n    });\n\n    // 6. Update all the targetedViewports to jump\n    viewports.forEach((viewport) => {\n      // Todo: current limitation is that we cannot jump in viewports\n      // that don't belong to the renderingEngine of the source clicked viewport\n      if (viewport instanceof VolumeViewport) {\n        jumpToWorld(viewport, brightestPoint);\n      } else {\n        console.warn(\n          'Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport'\n        );\n      }\n    });\n  }\n}\n\nMIPJumpToClickTool.toolName = 'MIPJumpToClickTool';\nexport default MIPJumpToClickTool;\n","import { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport * as lineSegment from '../../utilities/math/line';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { LengthAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * LengthTool let you draw annotations that measures the length of two drawing\n * points on a slice. You can use the LengthTool in all imaging planes even in oblique\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(LengthTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(LengthTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(LengthTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n\n */\n\nclass LengthTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): LengthAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: LengthAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: LengthAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: LengthAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as LengthAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      let activeHandleCanvasCoords;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].unit == null\n      ) {\n        data.cachedStats[targetId] = {\n          length: null,\n          unit: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-line`;\n      const lineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        dataId\n      );\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n\n      // Need to update to sync with annotation while unlinked/not moved\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateLength(pos1, pos2) {\n    const dx = pos1[0] - pos2[0];\n    const dy = pos1[1] - pos2[1];\n    const dz = pos1[2] - pos2[2];\n\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    // TODO clean up, this doesn't need a length per volume, it has no stats derived from volumes.\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, dimensions } = image;\n\n      const index1 = transformWorldToIndex(imageData, worldPos1);\n      const index2 = transformWorldToIndex(imageData, worldPos2);\n      const handles = [index1, index2];\n      const { scale, units } = getCalibratedLengthUnitsAndScale(image, handles);\n\n      const length = this._calculateLength(worldPos1, worldPos2) / scale;\n\n      this._isInsideVolume(index1, index2, dimensions)\n        ? (this.isHandleOutsideImage = false)\n        : (this.isHandleOutsideImage = true);\n\n      // TODO -> Do we instead want to clip to the bounds of the volume and only include that portion?\n      // Seems like a lot of work for an unrealistic case. At the moment bail out of stat calculation if either\n      // corner is off the canvas.\n\n      // todo: add insideVolume calculation, for removing tool if outside\n      cachedStats[targetId] = {\n        length,\n        unit: units,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  }\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { length, unit } = cachedVolumeStats;\n\n  // Can be null on load\n  if (length === undefined || length === null || isNaN(length)) {\n    return;\n  }\n\n  const textLines = [`${roundNumber(length)} ${unit}`];\n\n  return textLines;\n}\n\nLengthTool.toolName = 'Length';\nexport default LengthTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport vtkMatrixBuilder from '@kitware/vtk.js/Common/Core/MatrixBuilder';\n\nimport { AnnotationTool } from './base';\n\nimport {\n  getEnabledElementByIds,\n  getEnabledElement,\n  utilities as csUtils,\n  Enums,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getToolGroup,\n  getToolGroupForViewport,\n} from '../store/ToolGroupManager';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../stateManagement/annotation/annotationState';\n\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n} from '../drawingSvg';\nimport { state } from '../store';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../cursors/elementCursor';\nimport liangBarksyClip from '../utilities/math/vec2/liangBarksyClip';\n\nimport * as lineSegment from '../utilities/math/line';\nimport {\n  Annotation,\n  Annotations,\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../types';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { CONSTANTS } from '@cornerstonejs/core';\n\nconst { RENDERING_DEFAULTS } = CONSTANTS;\n\n// TODO: nested config is weird\ninterface ToolConfiguration {\n  configuration?: {\n    getReferenceLineColor?: (viewportId: string) => string;\n    getReferenceLineControllable?: (viewportId: string) => boolean;\n    getReferenceLineDraggableRotatable?: (viewportId: string) => boolean;\n    getReferenceLineSlabThicknessControlsOn?: (viewportId: string) => boolean;\n    referenceLinesCenterGapRadius?: number;\n    shadow?: boolean;\n    autopan?: {\n      enabled: boolean;\n      panSize: number;\n    };\n    mobile?: {\n      enabled: boolean;\n      opacity: number;\n      handleRadius: number;\n    };\n  };\n}\n\ninterface CrosshairsAnnotation extends Annotation {\n  data: {\n    handles: {\n      rotationPoints: any[]; // rotation handles, used for rotation interactions\n      slabThicknessPoints: any[]; // slab thickness handles, used for setting the slab thickness\n      activeOperation: number | null; // 0 translation, 1 rotation handles, 2 slab thickness handles\n      toolCenter: Types.Point3;\n    };\n    activeViewportIds: string[]; // a list of the viewport ids connected to the reference lines being translated\n    viewportId: string;\n  };\n}\n\nfunction defaultReferenceLineColor() {\n  return 'rgb(0, 200, 0)';\n}\n\nfunction defaultReferenceLineControllable() {\n  return true;\n}\n\nfunction defaultReferenceLineDraggableRotatable() {\n  return true;\n}\n\nfunction defaultReferenceLineSlabThicknessControlsOn() {\n  return true;\n}\n\nconst OPERATION = {\n  DRAG: 1,\n  ROTATE: 2,\n  SLAB: 3,\n};\n\nconst EPSILON = 1e-3;\n\n/**\n * CrosshairsTool is a tool that provides reference lines between different viewports\n * of a toolGroup. Using crosshairs, you can jump to a specific location in one\n * viewport and the rest of the viewports in the toolGroup will be aligned to that location.\n * Crosshairs have grababble handles that can be used to rotate and translate the\n * reference lines. They can also be used to set the slab thickness of the viewports\n * by modifying the slab thickness handles.\n *\n */\nclass CrosshairsTool extends AnnotationTool {\n  static toolName;\n\n  toolCenter: Types.Point3 = [0, 0, 0]; // NOTE: it is assumed that all the active/linked viewports share the same crosshair center.\n  // This because the rotation operation rotates also all the other active/intersecting reference lines of the same angle\n  _getReferenceLineColor?: (viewportId: string) => string;\n  _getReferenceLineControllable?: (viewportId: string) => boolean;\n  _getReferenceLineDraggableRotatable?: (viewportId: string) => boolean;\n  _getReferenceLineSlabThicknessControlsOn?: (viewportId: string) => boolean;\n  editData: {\n    annotation: any;\n  } | null;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse'],\n      configuration: {\n        shadow: true,\n        // renders a colored circle on top right of the viewports whose color\n        // matches the color of the reference line\n        viewportIndicators: true,\n        // Auto pan is a configuration which will update pan\n        // other viewports in the toolGroup if the center of the crosshairs\n        // is outside of the viewport. This might be useful for the case\n        // when the user is scrolling through an image (usually in the zoomed view)\n        // and the crosshairs will eventually get outside of the viewport for\n        // the other viewports.\n        autoPan: {\n          enabled: false,\n          panSize: 10,\n        },\n        // radius of the area around the intersection of the planes, in which\n        // the reference lines will not be rendered. This is only used when\n        // having 3 viewports in the toolGroup.\n        referenceLinesCenterGapRadius: 20,\n        // actorUIDs for slabThickness application, if not defined, the slab thickness\n        // will be applied to all actors of the viewport\n        filterActorUIDsToSetSlabThickness: [],\n        // blend mode for slabThickness modifications\n        slabThicknessBlendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n        mobile: {\n          enabled: false,\n          opacity: 0.8,\n          handleRadius: 9,\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._getReferenceLineColor =\n      toolProps.configuration?.getReferenceLineColor ||\n      defaultReferenceLineColor;\n    this._getReferenceLineControllable =\n      toolProps.configuration?.getReferenceLineControllable ||\n      defaultReferenceLineControllable;\n    this._getReferenceLineDraggableRotatable =\n      toolProps.configuration?.getReferenceLineDraggableRotatable ||\n      defaultReferenceLineDraggableRotatable;\n    this._getReferenceLineSlabThicknessControlsOn =\n      toolProps.configuration?.getReferenceLineSlabThicknessControlsOn ||\n      defaultReferenceLineSlabThicknessControlsOn;\n  }\n\n  /**\n   * Gets the camera from the viewport, and adds crosshairs annotation for the viewport\n   * to the annotationManager. If any annotation is found in the annotationManager, it\n   * overwrites it.\n   * @param viewportInfo - The viewportInfo for the viewport to add the crosshairs\n   * @returns viewPlaneNormal and center of viewport canvas in world space\n   */\n  initializeViewport = ({\n    renderingEngineId,\n    viewportId,\n  }: Types.IViewportId): {\n    normal: Types.Point3;\n    point: Types.Point3;\n  } => {\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    const { FrameOfReferenceUID, viewport } = enabledElement;\n    const { element } = viewport;\n    const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();\n\n    // Check if there is already annotation for this viewport\n    let annotations = this._getAnnotations(enabledElement);\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (annotations.length) {\n      // If found, it will override it by removing the annotation and adding it later\n      removeAnnotation(annotations[0].annotationUID);\n    }\n\n    const annotation = {\n      highlighted: false,\n      metadata: {\n        cameraPosition: <Types.Point3>[...position],\n        cameraFocalPoint: <Types.Point3>[...focalPoint],\n        FrameOfReferenceUID,\n        toolName: this.getToolName(),\n      },\n      data: {\n        handles: {\n          rotationPoints: [], // rotation handles, used for rotation interactions\n          slabThicknessPoints: [], // slab thickness handles, used for setting the slab thickness\n          toolCenter: this.toolCenter,\n        },\n        activeOperation: null, // 0 translation, 1 rotation handles, 2 slab thickness handles\n        activeViewportIds: [], // a list of the viewport ids connected to the reference lines being translated\n        viewportId,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    return {\n      normal: viewPlaneNormal,\n      point: viewport.canvasToWorld([\n        viewport.canvas.clientWidth / 2,\n        viewport.canvas.clientHeight / 2,\n      ]),\n    };\n  };\n\n  _getViewportsInfo = () => {\n    const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    return viewports;\n  };\n\n  onSetToolActive() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    // Upon new setVolumes on viewports we need to update the crosshairs\n    // reference points in the new space, so we subscribe to the event\n    // and update the reference points accordingly.\n    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n    this._subscribeToViewportNewVolumeSet(viewportsInfo);\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolPassive() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolEnabled() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolDisabled() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n\n    // Crosshairs annotations in the state\n    // has no value when the tool is disabled\n    // since viewports can change (zoom, pan, scroll)\n    // between disabled and enabled/active states.\n    // so we just remove the annotations from the state\n    viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const annotations = this._getAnnotations(enabledElement);\n\n      if (annotations?.length) {\n        annotations.forEach((annotation) => {\n          removeAnnotation(annotation.annotationUID);\n        });\n      }\n    });\n  }\n\n  /**\n   * When activated, it initializes the crosshairs. It begins by computing\n   * the intersection of viewports associated with the crosshairs instance.\n   * When all three views are accessible, the intersection (e.g., crosshairs tool centre)\n   * will be an exact point in space; however, with two viewports, because the\n   * intersection of two planes is a line, it assumes the last view is between the centre\n   * of the two rendering viewports.\n   * @param viewportsInfo Array of viewportInputs which each item containing {viewportId, renderingEngineId}\n   */\n  computeToolCenter = (viewportsInfo): void => {\n    if (!viewportsInfo.length || viewportsInfo.length === 1) {\n      throw new Error(\n        'For crosshairs to operate, at least two viewports must be given.'\n      );\n    }\n\n    // Todo: handle two same view viewport, or more than 3 viewports\n    const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;\n\n    // Initialize first viewport\n    const { normal: normal1, point: point1 } =\n      this.initializeViewport(firstViewport);\n\n    // Initialize second viewport\n    const { normal: normal2, point: point2 } =\n      this.initializeViewport(secondViewport);\n\n    let normal3 = <Types.Point3>[0, 0, 0];\n    let point3 = vec3.create();\n\n    // If there are three viewports\n    if (thirdViewport) {\n      ({ normal: normal3, point: point3 } =\n        this.initializeViewport(thirdViewport));\n    } else {\n      // If there are only two views (viewport) associated with the crosshairs:\n      // In this situation, we don't have a third information to find the\n      // exact intersection, and we \"assume\" the third view is looking at\n      // a location in between the first and second view centers\n      vec3.add(point3, point1, point2);\n      vec3.scale(point3, point3, 0.5);\n      vec3.cross(normal3, normal1, normal2);\n    }\n\n    // Planes of each viewport\n    const firstPlane = csUtils.planar.planeEquation(normal1, point1);\n    const secondPlane = csUtils.planar.planeEquation(normal2, point2);\n    const thirdPlane = csUtils.planar.planeEquation(normal3, point3);\n\n    // Calculating the intersection of 3 planes\n    // prettier-ignore\n    this.toolCenter = csUtils.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane)\n\n    // assuming all viewports are in the same rendering engine\n    const { renderingEngine } = getEnabledElementByIds(\n      viewportsInfo[0].viewportId,\n      viewportsInfo[0].renderingEngineId\n    );\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportsInfo.map(({ viewportId }) => viewportId)\n    );\n  };\n\n  /**\n   * addNewAnnotation acts as jump for the crosshairs tool. It is called when\n   * the user clicks on the image. It does not store the annotation in the stateManager though.\n   *\n   * @param evt - The mouse event\n   * @param interactionType - The type of interaction (e.g., mouse, touch, etc.)\n   * @returns Crosshairs annotation\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): CrosshairsAnnotation => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { currentPoints } = eventDetail;\n    const jumpWorld = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    this._jump(enabledElement, jumpWorld);\n\n    const annotations = this._getAnnotations(enabledElement);\n    const filteredAnnotations = this.filterInteractableAnnotationsForElement(\n      viewport.element,\n      annotations\n    );\n\n    // viewport Annotation\n    const { data } = filteredAnnotations[0];\n\n    const { rotationPoints } = data.handles;\n    const viewportIdArray = [];\n    // put all the draggable reference lines in the viewportIdArray\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      if (!viewportControllable || !viewportDraggableRotatable) {\n        continue;\n      }\n      viewportIdArray.push(otherViewport.id);\n      // rotation handles are two per viewport\n      i++;\n    }\n\n    data.activeViewportIds = [...viewportIdArray];\n    // set translation operation\n    data.handles.activeOperation = OPERATION.DRAG;\n\n    evt.preventDefault();\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n    return filteredAnnotations[0];\n  };\n\n  cancel = () => {\n    console.log('Not implemented yet');\n  };\n\n  /**\n   * It checks if the mouse click is near crosshairs handles, if yes\n   * it returns the handle location. If the mouse click is not near any\n   * of the handles, it does not return anything.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    let point = this._getRotationHandleNearImagePoint(\n      viewport,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (point !== null) {\n      return point;\n    }\n\n    point = this._getSlabThicknessHandleNearImagePoint(\n      viewport,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (point !== null) {\n      return point;\n    }\n  }\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    annotation.highlighted = true;\n\n    // NOTE: handle index or coordinates are not used when dragging.\n    // This because the handle points are actually generated in the renderTool and they are a derivative\n    // from the camera variables of the viewports and of the slab thickness variable.\n    // Remember that the translation and rotation operations operate on the camera\n    // variables and not really on the handles. Similar for the slab thickness.\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * It returns if the canvas point is near the provided crosshairs annotation in the\n   * provided element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CrosshairsAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    if (this._pointNearTool(element, annotation, canvasCoords, 6)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    annotation.highlighted = true;\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  onCameraModified = (evt) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const viewport = enabledElement.viewport as Types.IVolumeViewport;\n\n    const annotations = this._getAnnotations(enabledElement);\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport that the camera modified is originating from\n    const viewportAnnotation =\n      filteredToolAnnotations[0] as CrosshairsAnnotation;\n\n    if (!viewportAnnotation) {\n      return;\n    }\n\n    // -- Update the camera of other linked viewports containing the same volumeId that\n    //    have the same camera in case of translation\n    // -- Update the crosshair center in world coordinates in annotation.\n    // This is necessary because other tools can modify the position of the slices,\n    // e.g. stackScroll tool at wheel scroll. So we update the coordinates of the center always here.\n    // NOTE: rotation and slab thickness handles are created/updated in renderTool.\n    const currentCamera = viewport.getCamera();\n    const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;\n    const deltaCameraPosition: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(\n      currentCamera.position,\n      oldCameraPosition,\n      deltaCameraPosition\n    );\n\n    const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;\n    const deltaCameraFocalPoint: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(\n      currentCamera.focalPoint,\n      oldCameraFocalPoint,\n      deltaCameraFocalPoint\n    );\n\n    // updated cached \"previous\" camera position and focal point\n    viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];\n    viewportAnnotation.metadata.cameraFocalPoint = [\n      ...currentCamera.focalPoint,\n    ];\n\n    const viewportControllable = this._getReferenceLineControllable(\n      viewport.id\n    );\n    const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(\n      viewport.id\n    );\n    if (\n      !csUtils.isEqual(currentCamera.position, oldCameraPosition, 1e-3) &&\n      viewportControllable &&\n      viewportDraggableRotatable\n    ) {\n      // Is camera Modified a TRANSLATION or ROTATION?\n      let isRotation = false;\n\n      // This is guaranteed to be the same diff for both position and focal point\n      // if the camera is modified by pan, zoom, or scroll BUT for rotation of\n      // crosshairs handles it will be different.\n      const cameraModifiedSameForPosAndFocalPoint = csUtils.isEqual(\n        deltaCameraPosition,\n        deltaCameraFocalPoint,\n        1e-3\n      );\n\n      // NOTE: it is a translation if the the focal point and camera position shifts are the same\n      if (!cameraModifiedSameForPosAndFocalPoint) {\n        isRotation = true;\n      }\n\n      const cameraModifiedInPlane =\n        Math.abs(\n          vtkMath.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)\n        ) < 1e-2;\n\n      // TRANSLATION\n      // NOTE1: if the camera modified is a result of a pan or zoom don't update the crosshair center\n      // NOTE2: rotation handles are updates in renderTool\n      if (!isRotation && !cameraModifiedInPlane) {\n        this.toolCenter[0] += deltaCameraPosition[0];\n        this.toolCenter[1] += deltaCameraPosition[1];\n        this.toolCenter[2] += deltaCameraPosition[2];\n      }\n    }\n\n    // AutoPan modification\n    if (this.configuration.autoPan?.enabled) {\n      const toolGroup = getToolGroupForViewport(\n        viewport.id,\n        renderingEngine.id\n      );\n\n      const otherViewportIds = toolGroup\n        .getViewportIds()\n        .filter((id) => id !== viewport.id);\n\n      otherViewportIds.forEach((viewportId) => {\n        this._autoPanViewportIfNecessary(viewportId, renderingEngine);\n      });\n    }\n\n    const requireSameOrientation = false;\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      requireSameOrientation\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  mouseMoveCallback = (\n    evt: EventTypes.MouseMoveEventType,\n    filteredToolAnnotations: Annotations\n  ): boolean => {\n    const { element, currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n    let imageNeedsUpdate = false;\n\n    for (let i = 0; i < filteredToolAnnotations.length; i++) {\n      const annotation = filteredToolAnnotations[i] as CrosshairsAnnotation;\n\n      if (isAnnotationLocked(annotation)) {\n        continue;\n      }\n\n      const { data, highlighted } = annotation;\n      if (!data.handles) {\n        continue;\n      }\n\n      const previousActiveOperation = data.handles.activeOperation;\n      const previousActiveViewportIds =\n        data.activeViewportIds && data.activeViewportIds.length > 0\n          ? [...data.activeViewportIds]\n          : [];\n\n      // This init are necessary, because when we move the mouse they are not cleaned by _endCallback\n      data.activeViewportIds = [];\n      data.handles.activeOperation = null;\n\n      const handleNearImagePoint = this.getHandleNearImagePoint(\n        element,\n        annotation,\n        canvasCoords,\n        6\n      );\n\n      let near = false;\n      if (handleNearImagePoint) {\n        near = true;\n      } else {\n        near = this._pointNearTool(element, annotation, canvasCoords, 6);\n      }\n\n      const nearToolAndNotMarkedActive = near && !highlighted;\n      const notNearToolAndMarkedActive = !near && highlighted;\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n        annotation.highlighted = !highlighted;\n        imageNeedsUpdate = true;\n      } else if (\n        data.handles.activeOperation !== previousActiveOperation ||\n        !this._areViewportIdArraysEqual(\n          data.activeViewportIds,\n          previousActiveViewportIds\n        )\n      ) {\n        imageNeedsUpdate = true;\n      }\n    }\n\n    return imageNeedsUpdate;\n  };\n\n  filterInteractableAnnotationsForElement = (element, annotations) => {\n    if (!annotations || !annotations.length) {\n      return [];\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewportId } = enabledElement;\n\n    const viewportUIDSpecificCrosshairs = annotations.filter(\n      (annotation) => annotation.data.viewportId === viewportId\n    );\n\n    return viewportUIDSpecificCrosshairs;\n  };\n\n  /**\n   * renders the crosshairs lines and handles in the requestAnimationFrame callback\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, renderingEngine } = enabledElement;\n    const { element } = viewport;\n    const annotations = this._getAnnotations(enabledElement);\n    const camera = viewport.getCamera();\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport Annotation\n    const viewportAnnotation = filteredToolAnnotations[0];\n    if (!annotations?.length || !viewportAnnotation?.data) {\n      // No annotations yet, and didn't just create it as we likely don't have a FrameOfReference/any data loaded yet.\n      return renderStatus;\n    }\n\n    const annotationUID = viewportAnnotation.annotationUID;\n\n    // Get cameras/canvases for each of these.\n    // -- Get two world positions for this canvas in this line (e.g. the diagonal)\n    // -- Convert these world positions to this canvas.\n    // -- Extend/confine this line to fit in this canvas.\n    // -- Render this line.\n    const { clientWidth, clientHeight } = viewport.canvas;\n    const canvasDiagonalLength = Math.sqrt(\n      clientWidth * clientWidth + clientHeight * clientHeight\n    );\n    const canvasMinDimensionLength = Math.min(clientWidth, clientHeight);\n\n    const data = viewportAnnotation.data;\n    const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n\n    const otherViewportAnnotations =\n      this._filterAnnotationsByUniqueViewportOrientations(\n        enabledElement,\n        annotations\n      );\n\n    const referenceLines = [];\n\n    // get canvas information for points and lines (canvas box, canvas horizontal distances)\n    const canvasBox = [0, 0, clientWidth, clientHeight];\n\n    otherViewportAnnotations.forEach((annotation) => {\n      const { data } = annotation;\n\n      data.handles.toolCenter = this.toolCenter;\n\n      const otherViewport = renderingEngine.getViewport(\n        data.viewportId\n      ) as Types.IVolumeViewport;\n\n      const otherCamera = otherViewport.getCamera();\n\n      const otherViewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const otherViewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      const otherViewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n      // get coordinates for the reference line\n      const { clientWidth, clientHeight } = otherViewport.canvas;\n      const otherCanvasDiagonalLength = Math.sqrt(\n        clientWidth * clientWidth + clientHeight * clientHeight\n      );\n      const otherCanvasCenter: Types.Point2 = [\n        clientWidth * 0.5,\n        clientHeight * 0.5,\n      ];\n      const otherViewportCenterWorld =\n        otherViewport.canvasToWorld(otherCanvasCenter);\n\n      const direction: Types.Point3 = [0, 0, 0];\n      vtkMath.cross(\n        camera.viewPlaneNormal,\n        otherCamera.viewPlaneNormal,\n        direction\n      );\n      vtkMath.normalize(direction);\n      vtkMath.multiplyScalar(\n        <Types.Point3>direction,\n        otherCanvasDiagonalLength\n      );\n\n      const pointWorld0: Types.Point3 = [0, 0, 0];\n      vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);\n\n      const pointWorld1: Types.Point3 = [0, 0, 0];\n      vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);\n\n      const pointCanvas0 = viewport.worldToCanvas(pointWorld0);\n\n      const otherViewportCenterCanvas = viewport.worldToCanvas(\n        otherViewportCenterWorld\n      );\n\n      const canvasUnitVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasUnitVectorFromCenter,\n        pointCanvas0,\n        otherViewportCenterCanvas\n      );\n      vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n\n      // Graphic:\n      // Mid -> SlabThickness handle\n      // Short -> Rotation handle\n      //                           Long\n      //                            |\n      //                            |\n      //                            |\n      //                           Mid\n      //                            |\n      //                            |\n      //                            |\n      //                          Short\n      //                            |\n      //                            |\n      //                            |\n      // Long --- Mid--- Short--- Center --- Short --- Mid --- Long\n      //                            |\n      //                            |\n      //                            |\n      //                          Short\n      //                            |\n      //                            |\n      //                            |\n      //                           Mid\n      //                            |\n      //                            |\n      //                            |\n      //                           Long\n      const canvasVectorFromCenterLong = vec2.create();\n\n      vec2.scale(\n        canvasVectorFromCenterLong,\n        canvasUnitVectorFromCenter,\n        canvasDiagonalLength * 100\n      );\n      const canvasVectorFromCenterMid = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterMid,\n        canvasUnitVectorFromCenter,\n        // to maximize the visibility of the controls, they need to be\n        // placed at most at half the length of the shortest side of the canvas.\n        // Chosen 0.4 to have some margin to the edge.\n        canvasMinDimensionLength * 0.4\n      );\n      const canvasVectorFromCenterShort = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterShort,\n        canvasUnitVectorFromCenter,\n        // Chosen 0.2 because is half of 0.4.\n        canvasMinDimensionLength * 0.2\n      );\n      const canvasVectorFromCenterStart = vec2.create();\n      const centerGap = this.configuration.referenceLinesCenterGapRadius;\n      vec2.scale(\n        canvasVectorFromCenterStart,\n        canvasUnitVectorFromCenter,\n        // Don't put a gap if the the third view is missing\n        otherViewportAnnotations.length === 2 ? centerGap : 0\n      );\n\n      // Computing Reference start and end (4 lines per viewport in case of 3 view MPR)\n      const refLinePointOne = vec2.create();\n      const refLinePointTwo = vec2.create();\n      const refLinePointThree = vec2.create();\n      const refLinePointFour = vec2.create();\n\n      let refLinesCenter = vec2.clone(crosshairCenterCanvas);\n      if (!otherViewportDraggableRotatable || !otherViewportControllable) {\n        refLinesCenter = vec2.clone(otherViewportCenterCanvas);\n      }\n\n      vec2.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);\n      vec2.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);\n      vec2.subtract(\n        refLinePointThree,\n        refLinesCenter,\n        canvasVectorFromCenterStart\n      );\n      vec2.subtract(\n        refLinePointFour,\n        refLinesCenter,\n        canvasVectorFromCenterLong\n      );\n\n      // Clipping lines to be only included in a box (canvas), we don't want\n      // the lines goes beyond canvas\n      liangBarksyClip(refLinePointOne, refLinePointTwo, canvasBox);\n      liangBarksyClip(refLinePointThree, refLinePointFour, canvasBox);\n\n      // Computing rotation handle positions\n      const rotHandleOne = vec2.create();\n      vec2.subtract(\n        rotHandleOne,\n        crosshairCenterCanvas,\n        canvasVectorFromCenterMid\n      );\n\n      const rotHandleTwo = vec2.create();\n      vec2.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);\n\n      // Computing SlabThickness (st below) position\n\n      // SlabThickness center in canvas\n      let stHandlesCenterCanvas = vec2.clone(crosshairCenterCanvas);\n      if (\n        !otherViewportDraggableRotatable &&\n        otherViewportSlabThicknessControlsOn\n      ) {\n        stHandlesCenterCanvas = vec2.clone(otherViewportCenterCanvas);\n      }\n\n      // SlabThickness center in world\n      let stHandlesCenterWorld: Types.Point3 = [...this.toolCenter];\n      if (\n        !otherViewportDraggableRotatable &&\n        otherViewportSlabThicknessControlsOn\n      ) {\n        stHandlesCenterWorld = [...otherViewportCenterWorld];\n      }\n\n      const worldUnitVectorFromCenter: Types.Point3 = [0, 0, 0];\n      vtkMath.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);\n      vtkMath.normalize(worldUnitVectorFromCenter);\n\n      const { viewPlaneNormal } = camera;\n      // @ts-ignore // Todo: fix after vtk pr merged\n      const { matrix } = vtkMatrixBuilder\n        .buildFromDegree()\n        // @ts-ignore fix after vtk pr merged\n        .rotate(90, viewPlaneNormal);\n\n      const worldUnitOrthoVectorFromCenter: Types.Point3 = [0, 0, 0];\n      vec3.transformMat4(\n        worldUnitOrthoVectorFromCenter,\n        worldUnitVectorFromCenter,\n        matrix\n      );\n\n      const slabThicknessValue = otherViewport.getSlabThickness();\n      const worldOrthoVectorFromCenter: Types.Point3 = [\n        ...worldUnitOrthoVectorFromCenter,\n      ];\n      vtkMath.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);\n\n      const worldVerticalRefPoint: Types.Point3 = [0, 0, 0];\n      vtkMath.add(\n        stHandlesCenterWorld,\n        worldOrthoVectorFromCenter,\n        worldVerticalRefPoint\n      );\n\n      // convert vertical world distances in canvas coordinates\n      const canvasVerticalRefPoint = viewport.worldToCanvas(\n        worldVerticalRefPoint\n      );\n\n      // points for slab thickness lines\n      const canvasOrthoVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasOrthoVectorFromCenter,\n        stHandlesCenterCanvas,\n        canvasVerticalRefPoint\n      );\n\n      const stLinePointOne = vec2.create();\n      vec2.subtract(\n        stLinePointOne,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);\n\n      const stLinePointTwo = vec2.create();\n      vec2.add(\n        stLinePointTwo,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);\n\n      liangBarksyClip(stLinePointOne, stLinePointTwo, canvasBox);\n\n      const stLinePointThree = vec2.create();\n      vec2.add(\n        stLinePointThree,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.subtract(\n        stLinePointThree,\n        stLinePointThree,\n        canvasOrthoVectorFromCenter\n      );\n\n      const stLinePointFour = vec2.create();\n      vec2.subtract(\n        stLinePointFour,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.subtract(\n        stLinePointFour,\n        stLinePointFour,\n        canvasOrthoVectorFromCenter\n      );\n\n      liangBarksyClip(stLinePointThree, stLinePointFour, canvasBox);\n\n      // points for slab thickness handles\n      const stHandleOne = vec2.create();\n      const stHandleTwo = vec2.create();\n      const stHandleThree = vec2.create();\n      const stHandleFour = vec2.create();\n\n      vec2.subtract(\n        stHandleOne,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);\n      vec2.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n      vec2.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);\n      vec2.subtract(\n        stHandleThree,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);\n      vec2.add(\n        stHandleFour,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);\n\n      referenceLines.push([\n        otherViewport,\n        refLinePointOne,\n        refLinePointTwo,\n        refLinePointThree,\n        refLinePointFour,\n        stLinePointOne,\n        stLinePointTwo,\n        stLinePointThree,\n        stLinePointFour,\n        rotHandleOne,\n        rotHandleTwo,\n        stHandleOne,\n        stHandleTwo,\n        stHandleThree,\n        stHandleFour,\n      ]);\n    });\n\n    const newRtpoints = [];\n    const newStpoints = [];\n    const viewportColor = this._getReferenceLineColor(viewport.id);\n    const color =\n      viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n    referenceLines.forEach((line, lineIndex) => {\n      // get color for the reference line\n      const otherViewport = line[0];\n      const viewportColor = this._getReferenceLineColor(otherViewport.id);\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id) ||\n        this.configuration.mobile?.enabled;\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) ||\n        this.configuration.mobile?.enabled;\n      const selectedViewportId = data.activeViewportIds.find(\n        (id) => id === otherViewport.id\n      );\n\n      let color =\n        viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n      let lineWidth = 1;\n\n      const lineActive =\n        data.handles.activeOperation !== null &&\n        data.handles.activeOperation === OPERATION.DRAG &&\n        selectedViewportId;\n\n      if (lineActive) {\n        lineWidth = 2.5;\n      }\n\n      let lineUID = `${lineIndex}`;\n      if (viewportControllable && viewportDraggableRotatable) {\n        lineUID = `${lineIndex}One`;\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[1],\n          line[2],\n          {\n            color,\n            lineWidth,\n          }\n        );\n\n        lineUID = `${lineIndex}Two`;\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[3],\n          line[4],\n          {\n            color,\n            lineWidth,\n          }\n        );\n      } else {\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[2],\n          line[4],\n          {\n            color,\n            lineWidth,\n          }\n        );\n      }\n\n      if (viewportControllable) {\n        color =\n          viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n        const rotHandlesActive =\n          data.handles.activeOperation === OPERATION.ROTATE;\n        const rotationHandles = [line[9], line[10]];\n\n        const rotHandleWorldOne = [\n          viewport.canvasToWorld(line[9]),\n          otherViewport,\n          line[1],\n          line[2],\n        ];\n        const rotHandleWorldTwo = [\n          viewport.canvasToWorld(line[10]),\n          otherViewport,\n          line[3],\n          line[4],\n        ];\n        newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);\n\n        const slabThicknessHandlesActive =\n          data.handles.activeOperation === OPERATION.SLAB;\n        const slabThicknessHandles = [line[11], line[12], line[13], line[14]];\n\n        const slabThicknessHandleWorldOne = [\n          viewport.canvasToWorld(line[11]),\n          otherViewport,\n          line[5],\n          line[6],\n        ];\n        const slabThicknessHandleWorldTwo = [\n          viewport.canvasToWorld(line[12]),\n          otherViewport,\n          line[5],\n          line[6],\n        ];\n        const slabThicknessHandleWorldThree = [\n          viewport.canvasToWorld(line[13]),\n          otherViewport,\n          line[7],\n          line[8],\n        ];\n        const slabThicknessHandleWorldFour = [\n          viewport.canvasToWorld(line[14]),\n          otherViewport,\n          line[7],\n          line[8],\n        ];\n        newStpoints.push(\n          slabThicknessHandleWorldOne,\n          slabThicknessHandleWorldTwo,\n          slabThicknessHandleWorldThree,\n          slabThicknessHandleWorldFour\n        );\n\n        if (\n          (lineActive || this.configuration.mobile?.enabled) &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportDraggableRotatable &&\n          viewportSlabThicknessControlsOn\n        ) {\n          // draw all handles inactive (rotation and slab thickness)\n          let handleUID = `${lineIndex}One`;\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'circle',\n            }\n          );\n          handleUID = `${lineIndex}Two`;\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'rect',\n            }\n          );\n        } else if (\n          lineActive &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportDraggableRotatable\n        ) {\n          const handleUID = `${lineIndex}`;\n          // draw rotation handles inactive\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'circle',\n            }\n          );\n        } else if (\n          selectedViewportId &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportSlabThicknessControlsOn\n        ) {\n          const handleUID = `${lineIndex}`;\n          // draw slab thickness handles inactive\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'rect',\n            }\n          );\n        } else if (rotHandlesActive && viewportDraggableRotatable) {\n          const handleUID = `${lineIndex}`;\n          // draw all rotation handles as active\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: 2,\n              fill: color,\n              type: 'circle',\n            }\n          );\n        } else if (\n          slabThicknessHandlesActive &&\n          selectedViewportId &&\n          viewportSlabThicknessControlsOn\n        ) {\n          // draw only the slab thickness handles for the active viewport as active\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: 2,\n              fill: color,\n              type: 'rect',\n            }\n          );\n        }\n        const slabThicknessValue = otherViewport.getSlabThickness();\n        if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {\n          // draw slab thickness reference lines\n          lineUID = `${lineIndex}STOne`;\n          drawLineSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            line[5],\n            line[6],\n            {\n              color,\n              width: 1,\n              lineDash: [2, 3],\n            }\n          );\n\n          lineUID = `${lineIndex}STTwo`;\n          drawLineSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            line[7],\n            line[8],\n            {\n              color,\n              width: line,\n              lineDash: [2, 3],\n            }\n          );\n        }\n      }\n    });\n\n    renderStatus = true;\n\n    // Save new handles points in annotation\n    data.handles.rotationPoints = newRtpoints;\n    data.handles.slabThicknessPoints = newStpoints;\n\n    if (this.configuration.viewportIndicators) {\n      // render a circle to pin point the viewport color\n      // TODO: This should not be part of the tool, and definitely not part of the renderAnnotation loop\n      const referenceColorCoordinates = [\n        clientWidth * 0.95,\n        clientHeight * 0.05,\n      ] as Types.Point2;\n      const circleRadius = canvasDiagonalLength * 0.01;\n\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        referenceColorCoordinates,\n        circleRadius,\n        { color, fill: color }\n      );\n    }\n\n    return renderStatus;\n  };\n\n  _getAnnotations = (enabledElement: Types.IEnabledElement) => {\n    const { viewport } = enabledElement;\n    const annotations =\n      getAnnotations(this.getToolName(), viewport.element) || [];\n    const viewportIds = this._getViewportsInfo().map(\n      ({ viewportId }) => viewportId\n    );\n\n    // filter the annotations to only keep that are for this toolGroup\n    const toolGroupAnnotations = annotations.filter((annotation) => {\n      const { data } = annotation;\n      return viewportIds.includes(data.viewportId);\n    });\n\n    return toolGroupAnnotations;\n  };\n\n  _onNewVolume = (e: any) => {\n    const viewportsInfo = this._getViewportsInfo();\n    this.computeToolCenter(viewportsInfo);\n  };\n\n  _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const { viewport } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      const { element } = viewport;\n\n      element.removeEventListener(\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n        this._onNewVolume\n      );\n    });\n  }\n\n  _subscribeToViewportNewVolumeSet(viewports) {\n    viewports.forEach(({ viewportId, renderingEngineId }) => {\n      const { viewport } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      const { element } = viewport;\n\n      element.addEventListener(\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n        this._onNewVolume\n      );\n    });\n  }\n\n  _autoPanViewportIfNecessary(\n    viewportId: string,\n    renderingEngine: Types.IRenderingEngine\n  ): void {\n    // 1. Check if the toolCenter is outside the viewport\n    // 2. If it is outside, pan the viewport to fit in the toolCenter\n\n    const viewport = renderingEngine.getViewport(viewportId);\n    const { clientWidth, clientHeight } = viewport.canvas;\n\n    const toolCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n\n    // pan the viewport to fit the toolCenter in the direction\n    // that is out of bounds\n    const pan = this.configuration.autoPan.panSize;\n\n    const visiblePointCanvas = <Types.Point2>[\n      toolCenterCanvas[0],\n      toolCenterCanvas[1],\n    ];\n\n    if (toolCenterCanvas[0] < 0) {\n      visiblePointCanvas[0] = pan;\n    } else if (toolCenterCanvas[0] > clientWidth) {\n      visiblePointCanvas[0] = clientWidth - pan;\n    }\n\n    if (toolCenterCanvas[1] < 0) {\n      visiblePointCanvas[1] = pan;\n    } else if (toolCenterCanvas[1] > clientHeight) {\n      visiblePointCanvas[1] = clientHeight - pan;\n    }\n\n    if (\n      visiblePointCanvas[0] === toolCenterCanvas[0] &&\n      visiblePointCanvas[1] === toolCenterCanvas[1]\n    ) {\n      return;\n    }\n\n    const visiblePointWorld = viewport.canvasToWorld(visiblePointCanvas);\n\n    const deltaPointsWorld = [\n      visiblePointWorld[0] - this.toolCenter[0],\n      visiblePointWorld[1] - this.toolCenter[1],\n      visiblePointWorld[2] - this.toolCenter[2],\n    ];\n\n    const camera = viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n\n    viewport.render();\n  }\n\n  _areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {\n    if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {\n      return false;\n    }\n\n    viewportIdArrayOne.forEach((id) => {\n      let itemFound = false;\n      for (let i = 0; i < viewportIdArrayTwo.length; ++i) {\n        if (id === viewportIdArrayTwo[i]) {\n          itemFound = true;\n          break;\n        }\n      }\n      if (itemFound === false) {\n        return false;\n      }\n    });\n\n    return true;\n  };\n\n  // It filters the viewports with crosshairs and only return viewports\n  // that have different camera.\n  _getAnnotationsForViewportsWithDifferentCameras = (\n    enabledElement,\n    annotations\n  ) => {\n    const { viewportId, renderingEngine, viewport } = enabledElement;\n\n    const otherViewportAnnotations = annotations.filter(\n      (annotation) => annotation.data.viewportId !== viewportId\n    );\n\n    if (!otherViewportAnnotations || !otherViewportAnnotations.length) {\n      return [];\n    }\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, position } = camera;\n\n    const viewportsWithDifferentCameras = otherViewportAnnotations.filter(\n      (annotation) => {\n        const { viewportId } = annotation.data;\n        const targetViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfTarget = targetViewport.getCamera();\n\n        return !(\n          csUtils.isEqual(\n            cameraOfTarget.viewPlaneNormal,\n            viewPlaneNormal,\n            1e-2\n          ) && csUtils.isEqual(cameraOfTarget.position, position, 1)\n        );\n      }\n    );\n\n    return viewportsWithDifferentCameras;\n  };\n\n  _filterViewportWithSameOrientation = (\n    enabledElement,\n    referenceAnnotation,\n    annotations\n  ) => {\n    const { renderingEngine } = enabledElement;\n    const { data } = referenceAnnotation;\n    const viewport = renderingEngine.getViewport(data.viewportId);\n\n    const linkedViewportAnnotations = annotations.filter((annotation) => {\n      const { data } = annotation;\n      const otherViewport = renderingEngine.getViewport(data.viewportId);\n      const otherViewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n\n      return otherViewportControllable === true;\n    });\n\n    if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {\n      return [];\n    }\n\n    const camera = viewport.getCamera();\n    const viewPlaneNormal = camera.viewPlaneNormal;\n    vtkMath.normalize(viewPlaneNormal);\n\n    const otherViewportsAnnotationsWithSameCameraDirection =\n      linkedViewportAnnotations.filter((annotation) => {\n        const { viewportId } = annotation.data;\n        const otherViewport = renderingEngine.getViewport(viewportId);\n        const otherCamera = otherViewport.getCamera();\n        const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n        vtkMath.normalize(otherViewPlaneNormal);\n\n        return (\n          csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&\n          csUtils.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2)\n        );\n      });\n\n    return otherViewportsAnnotationsWithSameCameraDirection;\n  };\n\n  _filterAnnotationsByUniqueViewportOrientations = (\n    enabledElement,\n    annotations\n  ) => {\n    const { renderingEngine, viewport } = enabledElement;\n    const camera = viewport.getCamera();\n    const viewPlaneNormal = camera.viewPlaneNormal;\n    vtkMath.normalize(viewPlaneNormal);\n\n    const otherLinkedViewportAnnotationsFromSameScene = annotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const otherViewportControllable = this._getReferenceLineControllable(\n          otherViewport.id\n        );\n\n        return (\n          viewport !== otherViewport &&\n          // scene === otherScene &&\n          otherViewportControllable === true\n        );\n      }\n    );\n\n    const otherViewportsAnnotationsWithUniqueCameras = [];\n    // Iterate first on other viewport from the same scene linked\n    for (\n      let i = 0;\n      i < otherLinkedViewportAnnotationsFromSameScene.length;\n      ++i\n    ) {\n      const annotation = otherLinkedViewportAnnotationsFromSameScene[i];\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const otherViewportControllable = this._getReferenceLineControllable(\n          otherViewport.id\n        );\n\n        return (\n          viewport !== otherViewport &&\n          // scene === otherScene &&\n          otherViewportControllable !== true\n        );\n      }\n    );\n\n    // Iterate second on other viewport from the same scene non linked\n    for (\n      let i = 0;\n      i < otherNonLinkedViewportAnnotationsFromSameScene.length;\n      ++i\n    ) {\n      const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    // Iterate on all the viewport\n    const otherViewportAnnotations =\n      this._getAnnotationsForViewportsWithDifferentCameras(\n        enabledElement,\n        annotations\n      );\n\n    for (let i = 0; i < otherViewportAnnotations.length; ++i) {\n      const annotation = otherViewportAnnotations[i];\n      if (\n        otherViewportsAnnotationsWithUniqueCameras.some(\n          (element) => element === annotation\n        )\n      ) {\n        continue;\n      }\n\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    return otherViewportsAnnotationsWithUniqueCameras;\n  };\n\n  _checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {\n    const actors = viewport.getActors();\n    const otherViewportActors = otherViewport.getActors();\n\n    let sameScene = true;\n\n    actors.forEach((actor) => {\n      if (\n        actors.length !== otherViewportActors.length ||\n        otherViewportActors.find(({ uid }) => uid === actor.uid) === undefined\n      ) {\n        sameScene = false;\n      }\n    });\n\n    return sameScene;\n  };\n\n  _jump = (enabledElement, jumpWorld) => {\n    state.isInteractingWithTool = true;\n    const { viewport, renderingEngine } = enabledElement;\n\n    const annotations = this._getAnnotations(enabledElement);\n\n    const delta: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(jumpWorld, this.toolCenter, delta);\n\n    // TRANSLATION\n    // get the annotation of the other viewport which are parallel to the delta shift and are of the same scene\n    const otherViewportAnnotations =\n      this._getAnnotationsForViewportsWithDifferentCameras(\n        enabledElement,\n        annotations\n      );\n\n    const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n\n        const sameScene = this._checkIfViewportsRenderingSameScene(\n          viewport,\n          otherViewport\n        );\n\n        return (\n          this._getReferenceLineControllable(otherViewport.id) &&\n          this._getReferenceLineDraggableRotatable(otherViewport.id) &&\n          sameScene\n        );\n      }\n    );\n\n    if (viewportsAnnotationsToUpdate.length === 0) {\n      state.isInteractingWithTool = false;\n      return false;\n    }\n\n    this._applyDeltaShiftToSelectedViewportCameras(\n      renderingEngine,\n      viewportsAnnotationsToUpdate,\n      delta\n    );\n\n    state.isInteractingWithTool = false;\n\n    return true;\n  };\n\n  _activateModify = (element) => {\n    // mobile sometimes has lingering interaction even when touchEnd triggers\n    // this check allows for multiple handles to be active which doesn't affect\n    // tool usage.\n    state.isInteractingWithTool = !this.configuration.mobile?.enabled;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    this.editData.annotation.data.handles.activeOperation = null;\n    this.editData.annotation.data.activeViewportIds = [];\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    this.editData = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const requireSameOrientation = false;\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      requireSameOrientation\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const delta = eventDetail.deltaPoints.world;\n\n    if (\n      Math.abs(delta[0]) < 1e-3 &&\n      Math.abs(delta[1]) < 1e-3 &&\n      Math.abs(delta[2]) < 1e-3\n    ) {\n      return;\n    }\n\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const annotations = this._getAnnotations(\n      enabledElement\n    ) as CrosshairsAnnotation[];\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport Annotation\n    const viewportAnnotation = filteredToolAnnotations[0];\n    if (!viewportAnnotation) {\n      return;\n    }\n\n    const { handles } = viewportAnnotation.data;\n    const { currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n\n    if (handles.activeOperation === OPERATION.DRAG) {\n      // TRANSLATION\n      // get the annotation of the other viewport which are parallel to the delta shift and are of the same scene\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportDraggableRotatable =\n            this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportDraggableRotatable === true &&\n            viewportAnnotation.data.activeViewportIds.find(\n              (id) => id === otherViewport.id\n            )\n          );\n        }\n      );\n\n      this._applyDeltaShiftToSelectedViewportCameras(\n        renderingEngine,\n        viewportsAnnotationsToUpdate,\n        delta\n      );\n    } else if (handles.activeOperation === OPERATION.ROTATE) {\n      // ROTATION\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportDraggableRotatable =\n            this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportDraggableRotatable === true\n          );\n        }\n      );\n\n      const dir1 = vec2.create();\n      const dir2 = vec2.create();\n\n      const center: Types.Point3 = [\n        this.toolCenter[0],\n        this.toolCenter[1],\n        this.toolCenter[2],\n      ];\n\n      const centerCanvas = viewport.worldToCanvas(center);\n\n      const finalPointCanvas = eventDetail.currentPoints.canvas;\n      const originalPointCanvas = vec2.create();\n      vec2.sub(\n        originalPointCanvas,\n        finalPointCanvas,\n        eventDetail.deltaPoints.canvas\n      );\n      vec2.sub(dir1, originalPointCanvas, <vec2>centerCanvas);\n      vec2.sub(dir2, finalPointCanvas, <vec2>centerCanvas);\n\n      let angle = vec2.angle(dir1, dir2);\n\n      if (\n        this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)\n      ) {\n        angle *= -1;\n      }\n\n      // Rounding the angle to allow rotated handles to be undone\n      // If we don't round and rotate handles clockwise by 0.0131233 radians,\n      // there's no assurance that the counter-clockwise rotation occurs at\n      // precisely -0.0131233, resulting in the drawn annotations being lost.\n      angle = Math.round(angle * 100) / 100;\n\n      const rotationAxis = viewport.getCamera().viewPlaneNormal;\n      // @ts-ignore : vtkjs incorrect typing\n      const { matrix } = vtkMatrixBuilder\n        .buildFromRadian()\n        .translate(center[0], center[1], center[2])\n        // @ts-ignore\n        .rotate(angle, rotationAxis) //todo: why we are passing\n        .translate(-center[0], -center[1], -center[2]);\n\n      const otherViewportsIds = [];\n      // update camera for the other viewports.\n      // NOTE: The lines then are rendered by the onCameraModified\n      viewportsAnnotationsToUpdate.forEach((annotation) => {\n        const { data } = annotation;\n        data.handles.toolCenter = center;\n\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const camera = otherViewport.getCamera();\n        const { viewUp, position, focalPoint } = camera;\n\n        viewUp[0] += position[0];\n        viewUp[1] += position[1];\n        viewUp[2] += position[2];\n\n        vec3.transformMat4(focalPoint, focalPoint, matrix);\n        vec3.transformMat4(position, position, matrix);\n        vec3.transformMat4(viewUp, viewUp, matrix);\n\n        viewUp[0] -= position[0];\n        viewUp[1] -= position[1];\n        viewUp[2] -= position[2];\n\n        otherViewport.setCamera({\n          position,\n          viewUp,\n          focalPoint,\n        });\n        otherViewportsIds.push(otherViewport.id);\n      });\n      renderingEngine.renderViewports(otherViewportsIds);\n    } else if (handles.activeOperation === OPERATION.SLAB) {\n      // SLAB THICKNESS\n      // this should be just the active one under the mouse,\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const referenceAnnotations = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportSlabThicknessControlsOn =\n            this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportSlabThicknessControlsOn === true &&\n            viewportAnnotation.data.activeViewportIds.find(\n              (id) => id === otherViewport.id\n            )\n          );\n        }\n      );\n\n      if (referenceAnnotations.length === 0) {\n        return;\n      }\n      const viewportsAnnotationsToUpdate =\n        this._filterViewportWithSameOrientation(\n          enabledElement,\n          referenceAnnotations[0],\n          annotations\n        );\n\n      const viewportsIds = [];\n      viewportsIds.push(viewport.id);\n      viewportsAnnotationsToUpdate.forEach(\n        (annotation: CrosshairsAnnotation) => {\n          const { data } = annotation;\n\n          const otherViewport = renderingEngine.getViewport(\n            data.viewportId\n          ) as Types.IVolumeViewport;\n          const camera = otherViewport.getCamera();\n          const normal = camera.viewPlaneNormal;\n\n          const dotProd = vtkMath.dot(delta, normal);\n          const projectedDelta: Types.Point3 = [...normal];\n          vtkMath.multiplyScalar(projectedDelta, dotProd);\n\n          if (\n            Math.abs(projectedDelta[0]) > 1e-3 ||\n            Math.abs(projectedDelta[1]) > 1e-3 ||\n            Math.abs(projectedDelta[2]) > 1e-3\n          ) {\n            const mod = Math.sqrt(\n              projectedDelta[0] * projectedDelta[0] +\n                projectedDelta[1] * projectedDelta[1] +\n                projectedDelta[2] * projectedDelta[2]\n            );\n\n            const currentPoint = eventDetail.lastPoints.world;\n            const direction: Types.Point3 = [0, 0, 0];\n\n            const currentCenter: Types.Point3 = [\n              this.toolCenter[0],\n              this.toolCenter[1],\n              this.toolCenter[2],\n            ];\n\n            // use this.toolCenter only if viewportDraggableRotatable\n            const viewportDraggableRotatable =\n              this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportDraggableRotatable) {\n              const { rotationPoints } = this.editData.annotation.data.handles;\n              // Todo: what is a point uid?\n              const otherViewportRotationPoints = rotationPoints.filter(\n                (point) => point[1].uid === otherViewport.id\n              );\n              if (otherViewportRotationPoints.length === 2) {\n                const point1 = viewport.canvasToWorld(\n                  otherViewportRotationPoints[0][3]\n                );\n                const point2 = viewport.canvasToWorld(\n                  otherViewportRotationPoints[1][3]\n                );\n                vtkMath.add(point1, point2, currentCenter);\n                vtkMath.multiplyScalar(<Types.Point3>currentCenter, 0.5);\n              }\n            }\n\n            vtkMath.subtract(currentPoint, currentCenter, direction);\n            const dotProdDirection = vtkMath.dot(direction, normal);\n            const projectedDirection: Types.Point3 = [...normal];\n            vtkMath.multiplyScalar(projectedDirection, dotProdDirection);\n            const normalizedProjectedDirection: Types.Point3 = [\n              projectedDirection[0],\n              projectedDirection[1],\n              projectedDirection[2],\n            ];\n            vec3.normalize(\n              normalizedProjectedDirection,\n              normalizedProjectedDirection\n            );\n            const normalizedProjectedDelta: Types.Point3 = [\n              projectedDelta[0],\n              projectedDelta[1],\n              projectedDelta[2],\n            ];\n            vec3.normalize(normalizedProjectedDelta, normalizedProjectedDelta);\n\n            let slabThicknessValue = otherViewport.getSlabThickness();\n            if (\n              csUtils.isOpposite(\n                normalizedProjectedDirection,\n                normalizedProjectedDelta,\n                1e-3\n              )\n            ) {\n              slabThicknessValue -= mod;\n            } else {\n              slabThicknessValue += mod;\n            }\n\n            slabThicknessValue = Math.abs(slabThicknessValue);\n            slabThicknessValue = Math.max(\n              RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS,\n              slabThicknessValue\n            );\n\n            const near = this._pointNearReferenceLine(\n              viewportAnnotation,\n              canvasCoords,\n              6,\n              otherViewport\n            );\n\n            if (near) {\n              slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;\n            }\n\n            // We want to set the slabThickness for the viewport's actors but\n            // since the crosshairs tool instance has configuration regarding which\n            // actorUIDs (in case of volume -> actorUID = volumeIds) to set the\n            // slabThickness for, we need to delegate the slabThickness setting\n            // to the crosshairs tool instance of the toolGroup since configurations\n            // exist on the toolInstance and each toolGroup has its own crosshairs\n            // tool instance (Otherwise, we would need to set this filterActorUIDsToSetSlabThickness at\n            // the viewport level which makes tool and viewport state convoluted).\n            const toolGroup = getToolGroupForViewport(\n              otherViewport.id,\n              renderingEngine.id\n            );\n            const crosshairsInstance = toolGroup.getToolInstance(\n              this.getToolName()\n            );\n            crosshairsInstance.setSlabThickness(\n              otherViewport,\n              slabThicknessValue\n            );\n\n            viewportsIds.push(otherViewport.id);\n          }\n        }\n      );\n      renderingEngine.renderViewports(viewportsIds);\n    }\n  };\n\n  setSlabThickness(viewport, slabThickness) {\n    let actorUIDs;\n    const { filterActorUIDsToSetSlabThickness } = this.configuration;\n    if (\n      filterActorUIDsToSetSlabThickness &&\n      filterActorUIDsToSetSlabThickness.length > 0\n    ) {\n      actorUIDs = filterActorUIDsToSetSlabThickness;\n    }\n\n    let blendModeToUse = this.configuration.slabThicknessBlendMode;\n    if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {\n      blendModeToUse = Enums.BlendModes.COMPOSITE;\n    }\n\n    const immediate = false;\n    viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);\n    viewport.setSlabThickness(slabThickness, actorUIDs);\n  }\n\n  _isClockWise(a, b, c) {\n    // return true if the rotation is clockwise\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;\n  }\n\n  _applyDeltaShiftToSelectedViewportCameras(\n    renderingEngine,\n    viewportsAnnotationsToUpdate,\n    delta\n  ) {\n    // update camera for the other viewports.\n    // NOTE1: The lines then are rendered by the onCameraModified\n    // NOTE2: crosshair center are automatically updated in the onCameraModified event\n    viewportsAnnotationsToUpdate.forEach((annotation) => {\n      this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);\n    });\n  }\n\n  _applyDeltaShiftToViewportCamera(\n    renderingEngine: Types.IRenderingEngine,\n    annotation,\n    delta\n  ) {\n    // update camera for the other viewports.\n    // NOTE1: The lines then are rendered by the onCameraModified\n    // NOTE2: crosshair center are automatically updated in the onCameraModified event\n    const { data } = annotation;\n\n    const viewport = renderingEngine.getViewport(data.viewportId);\n    const camera = viewport.getCamera();\n    const normal = camera.viewPlaneNormal;\n\n    // Project delta over camera normal\n    // (we don't need to pan, we need only to scroll the camera as in the wheel stack scroll tool)\n    const dotProd = vtkMath.dot(delta, normal);\n    const projectedDelta: Types.Point3 = [...normal];\n    vtkMath.multiplyScalar(projectedDelta, dotProd);\n\n    if (\n      Math.abs(projectedDelta[0]) > 1e-3 ||\n      Math.abs(projectedDelta[1]) > 1e-3 ||\n      Math.abs(projectedDelta[2]) > 1e-3\n    ) {\n      const newFocalPoint: Types.Point3 = [0, 0, 0];\n      const newPosition: Types.Point3 = [0, 0, 0];\n\n      vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);\n      vtkMath.add(camera.position, projectedDelta, newPosition);\n\n      viewport.setCamera({\n        focalPoint: newFocalPoint,\n        position: newPosition,\n      });\n      viewport.render();\n    }\n  }\n\n  _pointNearReferenceLine = (\n    annotation,\n    canvasCoords,\n    proximity,\n    lineViewport\n  ) => {\n    const { data } = annotation;\n    const { rotationPoints } = data.handles;\n\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      if (otherViewport.id !== lineViewport.id) {\n        continue;\n      }\n\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const lineSegment1 = {\n        start: {\n          x: rotationPoints[i][2][0],\n          y: rotationPoints[i][2][1],\n        },\n        end: {\n          x: rotationPoints[i][3][0],\n          y: rotationPoints[i][3][1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: rotationPoints[i + 1][2][0],\n          y: rotationPoints[i + 1][2][1],\n        },\n        end: {\n          x: rotationPoints[i + 1][3][0],\n          y: rotationPoints[i + 1][3][1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        return true;\n      }\n\n      // rotation handles are two for viewport\n      i++;\n    }\n\n    return false;\n  };\n\n  _getRotationHandleNearImagePoint(\n    viewport,\n    annotation,\n    canvasCoords,\n    proximity\n  ) {\n    const { data } = annotation;\n    const { rotationPoints } = data.handles;\n\n    for (let i = 0; i < rotationPoints.length; i++) {\n      const point = rotationPoints[i][0];\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      if (!viewportDraggableRotatable) {\n        continue;\n      }\n\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n      if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n        data.handles.activeOperation = OPERATION.ROTATE;\n\n        this.editData = {\n          annotation,\n        };\n\n        return point;\n      }\n    }\n\n    return null;\n  }\n\n  _getSlabThicknessHandleNearImagePoint(\n    viewport,\n    annotation,\n    canvasCoords,\n    proximity\n  ) {\n    const { data } = annotation;\n    const { slabThicknessPoints } = data.handles;\n\n    for (let i = 0; i < slabThicknessPoints.length; i++) {\n      const point = slabThicknessPoints[i][0];\n      const otherViewport = slabThicknessPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n      if (!viewportSlabThicknessControlsOn) {\n        continue;\n      }\n\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n      if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n        data.handles.activeOperation = OPERATION.SLAB;\n\n        data.activeViewportIds = [otherViewport.id];\n\n        this.editData = {\n          annotation,\n        };\n\n        return point;\n      }\n    }\n\n    return null;\n  }\n\n  _pointNearTool(element, annotation, canvasCoords, proximity) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { clientWidth, clientHeight } = viewport.canvas;\n    const canvasDiagonalLength = Math.sqrt(\n      clientWidth * clientWidth + clientHeight * clientHeight\n    );\n    const { data } = annotation;\n\n    const { rotationPoints } = data.handles;\n    const { slabThicknessPoints } = data.handles;\n    const viewportIdArray = [];\n\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n      if (!viewportControllable || !viewportDraggableRotatable) {\n        continue;\n      }\n\n      const lineSegment1 = {\n        start: {\n          x: rotationPoints[i][2][0],\n          y: rotationPoints[i][2][1],\n        },\n        end: {\n          x: rotationPoints[i][3][0],\n          y: rotationPoints[i][3][1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: rotationPoints[i + 1][2][0],\n          y: rotationPoints[i + 1][2][1],\n        },\n        end: {\n          x: rotationPoints[i + 1][3][0],\n          y: rotationPoints[i + 1][3][1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        viewportIdArray.push(otherViewport.id);\n        data.handles.activeOperation = OPERATION.DRAG;\n      }\n\n      // rotation handles are two for viewport\n      i++;\n    }\n\n    for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {\n      const otherViewport = slabThicknessPoints[i][1];\n      if (viewportIdArray.find((id) => id === otherViewport.id)) {\n        continue;\n      }\n\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n      if (!viewportControllable || !viewportSlabThicknessControlsOn) {\n        continue;\n      }\n\n      const stPointLineCanvas1 = slabThicknessPoints[i][2];\n      const stPointLineCanvas2 = slabThicknessPoints[i][3];\n\n      const centerCanvas = vec2.create();\n      vec2.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);\n      vec2.scale(centerCanvas, centerCanvas, 0.5);\n\n      const canvasUnitVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasUnitVectorFromCenter,\n        stPointLineCanvas1,\n        centerCanvas\n      );\n      vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n\n      const canvasVectorFromCenterStart = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterStart,\n        canvasUnitVectorFromCenter,\n        canvasDiagonalLength * 0.05\n      );\n\n      const stPointLineCanvas1Start = vec2.create();\n      const stPointLineCanvas2Start = vec2.create();\n      vec2.add(\n        stPointLineCanvas1Start,\n        centerCanvas,\n        canvasVectorFromCenterStart\n      );\n      vec2.subtract(\n        stPointLineCanvas2Start,\n        centerCanvas,\n        canvasVectorFromCenterStart\n      );\n\n      const lineSegment1 = {\n        start: {\n          x: stPointLineCanvas1Start[0],\n          y: stPointLineCanvas1Start[1],\n        },\n        end: {\n          x: stPointLineCanvas1[0],\n          y: stPointLineCanvas1[1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: stPointLineCanvas2Start[0],\n          y: stPointLineCanvas2Start[1],\n        },\n        end: {\n          x: stPointLineCanvas2[0],\n          y: stPointLineCanvas2[1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        viewportIdArray.push(otherViewport.id); // we still need this to draw inactive slab thickness handles\n        data.handles.activeOperation = null; // no operation\n      }\n\n      // slab thickness handles are in couples\n      i++;\n    }\n\n    data.activeViewportIds = [...viewportIdArray];\n\n    this.editData = {\n      annotation,\n    };\n\n    return data.handles.activeOperation === OPERATION.DRAG ? true : false;\n  }\n}\n\nCrosshairsTool.toolName = 'Crosshairs';\nexport default CrosshairsTool;\n","import { vec3 } from 'gl-matrix';\nimport {\n  getRenderingEngines,\n  CONSTANTS,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\n\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { PublicToolProps, ToolProps, SVGDrawingHelper } from '../types';\nimport { ReferenceLineAnnotation } from '../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\n\nconst { EPSILON } = CONSTANTS;\n\n/**\n * @public\n */\n\nclass ReferenceLines extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    renderingEngine: any;\n    sourceViewport: any;\n    annotation: ReferenceLineAnnotation;\n  } | null = {} as any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        sourceViewportId: '',\n        showFullDimension: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    // this._throttledCalculateCachedStats = throttle(\n    //   this._calculateCachedStats,\n    //   100,\n    //   { trailing: true }\n    // );\n  }\n\n  _init = (): void => {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    // Todo: handle this case where it is too soon to get the rendering engine\n    if (!renderingEngine) {\n      return;\n    }\n\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n\n    const sourceViewport = renderingEngine.getViewport(\n      this.configuration.sourceViewportId\n    ) as Types.IVolumeViewport;\n\n    if (!sourceViewport || !sourceViewport.getImageData()) {\n      return;\n    }\n\n    const { element } = sourceViewport;\n    const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();\n\n    const sourceViewportCanvasCornersInWorld =\n      csUtils.getViewportImageCornersInWorld(sourceViewport);\n\n    let annotation = this.editData.annotation;\n    const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();\n\n    if (!annotation) {\n      const newAnnotation: ReferenceLineAnnotation = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n          toolName: this.getToolName(),\n          viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n          viewUp: <Types.Point3>[...viewUp],\n          FrameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          handles: {\n            points: sourceViewportCanvasCornersInWorld,\n          },\n        },\n      };\n\n      addAnnotation(newAnnotation, element);\n      annotation = newAnnotation;\n    } else {\n      this.editData.annotation.data.handles.points =\n        sourceViewportCanvasCornersInWorld;\n    }\n\n    this.editData = {\n      sourceViewport,\n      renderingEngine,\n      annotation,\n    };\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewports\n        .filter((viewport) => viewport.id !== sourceViewport.id)\n        .map((viewport) => viewport.id)\n    );\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    // If the camera is modified, we need to update the reference lines\n    // we really don't care which viewport triggered the\n    // camera modification, since we want to update all of them\n    // with respect to the targetViewport\n    this._init();\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const { viewport: targetViewport } = enabledElement;\n    const { annotation, sourceViewport } = this.editData;\n\n    let renderStatus = false;\n\n    if (!sourceViewport) {\n      return renderStatus;\n    }\n\n    if (sourceViewport.id === targetViewport.id) {\n      // If the source viewport is the same as the current viewport, we don't need to render\n      return renderStatus;\n    }\n\n    if (!annotation || !annotation?.data?.handles?.points) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // top left world, top right world, bottom right world, bottom left world\n    const topLeft = annotation.data.handles.points[0];\n    const topRight = annotation.data.handles.points[1];\n    const bottomLeft = annotation.data.handles.points[2];\n    const bottomRight = annotation.data.handles.points[3];\n\n    const { focalPoint, viewPlaneNormal, viewUp } = targetViewport.getCamera();\n    const { viewPlaneNormal: sourceViewPlaneNormal } =\n      sourceViewport.getCamera();\n\n    if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {\n      // If the source and target viewports are parallel, we don't need to render\n      return renderStatus;\n    }\n\n    const targetViewportPlane = csUtils.planar.planeEquation(\n      viewPlaneNormal,\n      focalPoint\n    );\n\n    // check if the topLeft and bottomLeft line is parallel to the viewUp\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n    const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n\n    let pointSetToUse = pointSet1;\n\n    let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n    topBottomVec = vec3.normalize(vec3.create(), topBottomVec) as Types.Point3;\n\n    let topRightVec = vec3.subtract(vec3.create(), pointSet1[2], pointSet1[0]);\n    topRightVec = vec3.normalize(vec3.create(), topRightVec);\n\n    const newNormal = vec3.cross(\n      vec3.create(),\n      topBottomVec,\n      topRightVec\n    ) as Types.Point3;\n\n    if (this.isParallel(newNormal, viewPlaneNormal)) {\n      return renderStatus;\n    }\n\n    // check if it is perpendicular to the viewPlaneNormal which means\n    // the line does not intersect the viewPlaneNormal\n    if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n      // 'use pointSet2';\n      pointSetToUse = pointSet2;\n    }\n\n    const lineStartWorld = csUtils.planar.linePlaneIntersection(\n      pointSetToUse[0],\n      pointSetToUse[1],\n      targetViewportPlane\n    );\n\n    const lineEndWorld = csUtils.planar.linePlaneIntersection(\n      pointSetToUse[2],\n      pointSetToUse[3],\n      targetViewportPlane\n    );\n    const { annotationUID } = annotation;\n\n    styleSpecifier.annotationUID = annotationUID;\n    const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n    const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n    const color = this.getStyle('color', styleSpecifier, annotation);\n    const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n    let canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) =>\n      targetViewport.worldToCanvas(world)\n    );\n\n    if (this.configuration.showFullDimension) {\n      canvasCoordinates = this.handleFullDimension(\n        targetViewport,\n        lineStartWorld,\n        viewPlaneNormal,\n        viewUp,\n        lineEndWorld,\n        canvasCoordinates\n      );\n    }\n\n    const dataId = `${annotationUID}-line`;\n    const lineUID = '1';\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      lineUID,\n      canvasCoordinates[0],\n      canvasCoordinates[1],\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      dataId\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n\n  isPerpendicular = (vec1: Types.Point3, vec2: Types.Point3): boolean => {\n    const dot = vec3.dot(vec1, vec2);\n    return Math.abs(dot) < EPSILON;\n  };\n\n  private handleFullDimension(\n    targetViewport: Types.IStackViewport | Types.IVolumeViewport,\n    lineStartWorld: Types.Point3,\n    viewPlaneNormal: Types.Point3,\n    viewUp: Types.Point3,\n    lineEndWorld: Types.Point3,\n    canvasCoordinates: Types.Point2[]\n  ) {\n    const renderingEngine = targetViewport.getRenderingEngine();\n    const targetId = this.getTargetId(targetViewport);\n    const targetImage = this.getTargetIdImage(targetId, renderingEngine);\n\n    const referencedImageId = this.getReferencedImageId(\n      targetViewport,\n      lineStartWorld,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    if (referencedImageId && targetImage) {\n      try {\n        const { imageData, dimensions } = targetImage;\n\n        // Calculate bound image coordinates\n        const [\n          topLeftImageCoord,\n          topRightImageCoord,\n          bottomRightImageCoord,\n          bottomLeftImageCoord,\n        ] = [\n          imageData.indexToWorld([0, 0, 0]) as Types.Point3,\n          imageData.indexToWorld([dimensions[0] - 1, 0, 0]) as Types.Point3,\n          imageData.indexToWorld([\n            dimensions[0] - 1,\n            dimensions[1] - 1,\n            0,\n          ]) as Types.Point3,\n          imageData.indexToWorld([0, dimensions[1] - 1, 0]) as Types.Point3,\n        ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n\n        // Calculate line start and end image coordinates\n        const [lineStartImageCoord, lineEndImageCoord] = [\n          lineStartWorld,\n          lineEndWorld,\n        ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n\n        // Calculate intersection points between line and image bounds\n        canvasCoordinates = [\n          [topLeftImageCoord, topRightImageCoord],\n          [topRightImageCoord, bottomRightImageCoord],\n          [bottomLeftImageCoord, bottomRightImageCoord],\n          [topLeftImageCoord, bottomLeftImageCoord],\n        ]\n          .map(([start, end]) =>\n            this.intersectInfiniteLines(\n              start,\n              end,\n              lineStartImageCoord,\n              lineEndImageCoord\n            )\n          )\n          .filter((point) => point && this.isInBound(point, dimensions))\n          .map((point) => {\n            const world = csUtils.imageToWorldCoords(\n              referencedImageId,\n              point as Types.Point2\n            );\n            return targetViewport.worldToCanvas(world);\n          });\n      } catch (err) {\n        console.log(err);\n      }\n    }\n    return canvasCoordinates;\n  }\n\n  // get the intersection point between two infinite lines, not line segments\n  intersectInfiniteLines(\n    line1Start: Types.Point2,\n    line1End: Types.Point2,\n    line2Start: Types.Point2,\n    line2End: Types.Point2\n  ) {\n    const [x1, y1] = line1Start;\n    const [x2, y2] = line1End;\n    const [x3, y3] = line2Start;\n    const [x4, y4] = line2End;\n\n    // Compute a1, b1, c1, where line joining points 1 and 2 is \"a1 x  +  b1 y  +  c1  =  0\"\n    const a1 = y2 - y1;\n    const b1 = x1 - x2;\n    const c1 = x2 * y1 - x1 * y2;\n\n    // Compute a2, b2, c2\n    const a2 = y4 - y3;\n    const b2 = x3 - x4;\n    const c2 = x4 * y3 - x3 * y4;\n\n    if (Math.abs(a1 * b2 - a2 * b1) < EPSILON) {\n      return;\n    }\n\n    const x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n    const y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1);\n\n    return [x, y];\n  }\n\n  isParallel(vec1: Types.Point3, vec2: Types.Point3): boolean {\n    return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n  }\n\n  isInBound(point: number[], dimensions: Types.Point3): boolean {\n    return (\n      point[0] >= 0 &&\n      point[0] <= dimensions[0] &&\n      point[1] >= 0 &&\n      point[1] <= dimensions[1]\n    );\n  }\n}\n\nReferenceLines.toolName = 'ReferenceLines';\nexport default ReferenceLines;\n","import { vec3 } from 'gl-matrix';\nimport {\n  metaData,\n  CONSTANTS,\n  getRenderingEngine,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\n\nimport { getToolGroup } from '../store/ToolGroupManager';\n\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  Annotation,\n} from '../types';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\n\nconst { EPSILON } = CONSTANTS;\n\nexport interface OverlayGridAnnotation extends Annotation {\n  data: {\n    viewportData: Map<string, object>;\n    pointSets: Array<object>;\n  };\n}\n\n/**\n * @public\n */\nclass OverlayGridTool extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        sourceImageIds: [],\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onSetToolActive = (): void => {\n    this._init();\n  };\n\n  _init = (): void => {\n    const sourceImageIds = this.configuration.sourceImageIds;\n    if (!sourceImageIds?.length) {\n      console.warn(\n        'OverlayGridTool: No sourceImageIds provided in configuration'\n      );\n      return;\n    }\n\n    const imagePlaneModule = metaData.get(\n      'imagePlaneModule',\n      sourceImageIds[0]\n    );\n\n    if (!imagePlaneModule) {\n      console.warn(\n        'OverlayGridTool: No imagePlaneModule found for sourceImageIds'\n      );\n      return;\n    }\n\n    const { frameOfReferenceUID } = imagePlaneModule;\n\n    const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    if (!viewportsInfo?.length) {\n      console.warn('OverlayGridTool: No viewports found');\n      return;\n    }\n\n    const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n\n    if (!annotations?.length) {\n      const pointSets = sourceImageIds.map((id) => {\n        // check if pointSets for the imageId was calculated. If not calculate and store\n        return this.calculateImageIdPointSets(id);\n      });\n\n      const newAnnotation: OverlayGridAnnotation = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n          toolName: this.getToolName(),\n          FrameOfReferenceUID: frameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          viewportData: new Map(),\n          pointSets,\n        },\n      };\n\n      addAnnotation(newAnnotation, frameOfReferenceUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      getRenderingEngine(viewportsInfo[0].renderingEngineId),\n      viewportsInfo.map(({ viewportId }) => viewportId)\n    );\n  };\n\n  /**\n   * Calculates the point sets based on the image corners relative to an imageId\n   * @param imageId - The imageId to calculate the point sets for\n   * @returns\n   */\n  calculateImageIdPointSets = (imageId: string) => {\n    const {\n      imagePositionPatient,\n      rows,\n      columns,\n      rowCosines,\n      columnCosines,\n      rowPixelSpacing,\n      columnPixelSpacing,\n    } = metaData.get('imagePlaneModule', imageId);\n\n    // top left world, top right world, bottom right world, bottom left world\n    const topLeft = <Types.Point3>[...imagePositionPatient];\n    const topRight = <Types.Point3>[...imagePositionPatient];\n    const bottomLeft = <Types.Point3>[...imagePositionPatient];\n    const bottomRight = <Types.Point3>[...imagePositionPatient];\n\n    vec3.scaleAndAdd(\n      topRight,\n      imagePositionPatient,\n      columnCosines,\n      columns * columnPixelSpacing\n    );\n    vec3.scaleAndAdd(\n      bottomLeft,\n      imagePositionPatient,\n      rowCosines,\n      rows * rowPixelSpacing\n    );\n\n    vec3.scaleAndAdd(\n      bottomRight,\n      bottomLeft,\n      columnCosines,\n      columns * columnPixelSpacing\n    );\n\n    // check if the topLeft and bottomLeft line is parallel to the viewUp\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n    const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n\n    return { pointSet1, pointSet2 };\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const sourceImageIds = this.configuration.sourceImageIds;\n\n    let renderStatus = false;\n    if (!sourceImageIds?.length) {\n      return renderStatus;\n    }\n\n    const { viewport: targetViewport, FrameOfReferenceUID } = enabledElement;\n    const targetImageIds = targetViewport.getImageIds();\n    if (targetImageIds.length < 2) {\n      return renderStatus;\n    }\n\n    const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n    const annotation = annotations[0];\n    const { annotationUID } = annotation;\n\n    const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n    const imageIdNormal = <Types.Point3>(\n      this.getImageIdNormal(sourceImageIds[0])\n    );\n\n    if (this.isParallel(viewPlaneNormal, imageIdNormal)) {\n      // If the source and target viewports are parallel, we don't need to render\n      return renderStatus;\n    }\n\n    const targetViewportPlane = csUtils.planar.planeEquation(\n      viewPlaneNormal,\n      focalPoint\n    );\n\n    const pointSets = annotation.data.pointSets;\n    const viewportData = annotation.data.viewportData;\n    for (let i = 0; i < sourceImageIds.length; i++) {\n      // check if pointSets for the imageId was calculated. If not calculate and store\n      const { pointSet1, pointSet2 } = pointSets[i];\n\n      const targetData =\n        viewportData.get(targetViewport.id) ||\n        this.initializeViewportData(viewportData, targetViewport.id);\n\n      // check if pointSetToUse was calculated. If not calculate and store\n      if (!targetData.pointSetsToUse[i]) {\n        let pointSetToUse = pointSet1;\n\n        let topBottomVec = vec3.subtract(\n          vec3.create(),\n          pointSet1[0],\n          pointSet1[1]\n        );\n        topBottomVec = vec3.normalize(\n          vec3.create(),\n          topBottomVec\n        ) as Types.Point3;\n\n        // check if it is perpendicular to the viewPlaneNormal which means\n        // the line does not intersect the viewPlaneNormal\n        if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n          // 'use pointSet2';\n          pointSetToUse = pointSet2;\n        }\n\n        targetData.pointSetsToUse[i] = pointSetToUse;\n\n        targetData.lineStartsWorld[i] = csUtils.planar.linePlaneIntersection(\n          pointSetToUse[0],\n          pointSetToUse[1],\n          targetViewportPlane\n        );\n\n        targetData.lineEndsWorld[i] = csUtils.planar.linePlaneIntersection(\n          pointSetToUse[2],\n          pointSetToUse[3],\n          targetViewportPlane\n        );\n      }\n\n      const lineStartWorld = targetData.lineStartsWorld[i];\n      const lineEndWorld = targetData.lineEndsWorld[i];\n\n      styleSpecifier.annotationUID = annotationUID;\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n      const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) =>\n        targetViewport.worldToCanvas(world)\n      );\n\n      const dataId = `${annotationUID}-line`;\n      const lineUID = `${i}`;\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        dataId\n      );\n    }\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n\n  private initializeViewportData = (viewportData, id) => {\n    viewportData.set(id, {\n      pointSetsToUse: [],\n      lineStartsWorld: [],\n      lineEndsWorld: [],\n    });\n\n    return viewportData.get(id);\n  };\n\n  private isPerpendicular = (\n    vec1: Types.Point3,\n    vec2: Types.Point3\n  ): boolean => {\n    const dot = vec3.dot(vec1, vec2);\n    return Math.abs(dot) < EPSILON;\n  };\n\n  private isParallel(vec1: Types.Point3, vec2: Types.Point3): boolean {\n    return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n  }\n\n  private getImageIdNormal(imageId: string): vec3 {\n    const { imageOrientationPatient } = metaData.get(\n      'imagePlaneModule',\n      imageId\n    );\n    const rowCosineVec = vec3.fromValues(\n      imageOrientationPatient[0],\n      imageOrientationPatient[1],\n      imageOrientationPatient[2]\n    );\n    const colCosineVec = vec3.fromValues(\n      imageOrientationPatient[3],\n      imageOrientationPatient[4],\n      imageOrientationPatient[5]\n    );\n    return vec3.cross(vec3.create(), rowCosineVec, colCosineVec);\n  }\n}\n\nOverlayGridTool.toolName = 'OverlayGrid';\nexport default OverlayGridTool;\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport { drawPolyline } from '../drawingSvg';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { PublicToolProps, ToolProps, SVGDrawingHelper } from '../types';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { Annotation } from '../types';\nimport { distanceToPoint } from '../utilities/math/point';\nimport { pointToString } from '../utilities/pointToString';\nimport { polyDataUtils } from '../utilities';\n\nexport interface SegmentationIntersectionAnnotation extends Annotation {\n  data: {\n    actorsWorldPointsMap: Map<string, Map<string, object>>;\n  };\n}\n\nclass SegmentationIntersectionTool extends AnnotationDisplayTool {\n  static toolName;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        opacity: 0.5,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Initialize the annotation data and calculates surface intersections\n   * @returns\n   */\n  _init = (): void => {\n    const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    if (!viewportsInfo?.length) {\n      console.warn(this.getToolName() + 'Tool: No viewports found');\n      return;\n    }\n\n    const firstViewport = getRenderingEngine(\n      viewportsInfo[0].renderingEngineId\n    )?.getViewport(viewportsInfo[0].viewportId);\n\n    if (!firstViewport) {\n      return;\n    }\n    const frameOfReferenceUID = firstViewport.getFrameOfReferenceUID();\n    const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n\n    if (!annotations?.length) {\n      const actorsWorldPointsMap = new Map();\n      calculateSurfaceSegmentationIntersections(\n        actorsWorldPointsMap,\n        viewportsInfo\n      );\n      const newAnnotation: SegmentationIntersectionAnnotation = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n          toolName: this.getToolName(),\n          FrameOfReferenceUID: frameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          actorsWorldPointsMap,\n        },\n      };\n\n      addAnnotation(newAnnotation, frameOfReferenceUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      getRenderingEngine(viewportsInfo[0].renderingEngineId),\n      viewportsInfo.map(({ viewportId }) => viewportId)\n    );\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    this._init();\n  };\n\n  /**\n   * Renders the surface intersections\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const { viewport, FrameOfReferenceUID } = enabledElement;\n\n    let renderStatus = false;\n\n    const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n    const annotation = annotations[0];\n    const { annotationUID } = annotation;\n    const actorsWorldPointsMap = annotation.data.actorsWorldPointsMap;\n\n    calculateSurfaceSegmentationIntersectionsForViewport(\n      actorsWorldPointsMap,\n      viewport\n    );\n\n    const actorEntries = viewport.getActors();\n    const cacheId = getCacheId(viewport);\n\n    actorEntries.forEach((actorEntry) => {\n      if (!actorEntry?.clippingFilter) {\n        return;\n      }\n      const actorWorldPointMap = actorsWorldPointsMap.get(actorEntry.uid);\n      if (!actorWorldPointMap) {\n        return;\n      }\n      if (!actorWorldPointMap.get(cacheId)) {\n        return;\n      }\n      let polyLineIdx = 1;\n      const { worldPointsSet, color } = actorWorldPointMap.get(cacheId);\n      for (let i = 0; i < worldPointsSet.length; i++) {\n        const worldPoints = worldPointsSet[i];\n        const canvasPoints = worldPoints.map((point) =>\n          viewport.worldToCanvas(point)\n        );\n\n        const options = {\n          color: color,\n          fillColor: color,\n          fillOpacity: this.configuration.opacity,\n          connectLastToFirst: true,\n        };\n\n        const polyLineUID = actorEntry.uid + '#' + polyLineIdx;\n        drawPolyline(\n          svgDrawingHelper,\n          annotationUID,\n          polyLineUID,\n          canvasPoints,\n          options\n        );\n        polyLineIdx++;\n      }\n    });\n\n    renderStatus = true;\n    return renderStatus;\n  };\n}\n\n/**\n * Calculates surface intersections points for all surface actors in a list of viewports\n * @param actorWorldPointsMap\n * @param viewportsInfo\n */\nfunction calculateSurfaceSegmentationIntersections(\n  actorsWorldPointsMap,\n  viewportsInfo\n) {\n  viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n    const viewport =\n      getRenderingEngine(renderingEngineId)?.getViewport(viewportId);\n    calculateSurfaceSegmentationIntersectionsForViewport(\n      actorsWorldPointsMap,\n      viewport\n    );\n  });\n}\n\n/**\n * Calculates surface intersections points for all surface actors in a viewport\n * generating a set of polyline points for each actor\n * @param actorWorldPointsMap\n * @param viewport\n */\nfunction calculateSurfaceSegmentationIntersectionsForViewport(\n  actorsWorldPointsMap,\n  viewport\n) {\n  const actorEntries = viewport.getActors();\n\n  // we should not use the focalPoint here, since the pan and zoom updates it,\n  // imageIndex is reliable enough\n  const cacheId = getCacheId(viewport);\n\n  actorEntries.forEach((actorEntry) => {\n    if (!actorEntry?.clippingFilter) {\n      return;\n    }\n\n    let actorWorldPointsMap = actorsWorldPointsMap.get(actorEntry.uid);\n    if (!actorWorldPointsMap) {\n      actorWorldPointsMap = new Map();\n      actorsWorldPointsMap.set(actorEntry.uid, actorWorldPointsMap);\n    }\n    if (!actorWorldPointsMap.get(cacheId)) {\n      const polyData = actorEntry.clippingFilter.getOutputData();\n      const worldPointsSet = polyDataUtils.getPolyDataPoints(polyData);\n      if (!worldPointsSet) {\n        return;\n      }\n\n      // worldPointsSet = removeExtraPoints(viewport, worldPointsSet);\n      const colorArray = actorEntry.actor.getProperty().getColor();\n      const color = colorToString(colorArray);\n      actorWorldPointsMap.set(cacheId, { worldPointsSet, color });\n    }\n  });\n}\n\nfunction getCacheId(viewport) {\n  const { viewPlaneNormal } = viewport.getCamera();\n  const imageIndex = viewport.getCurrentImageIdIndex();\n  return `${viewport.id}-${pointToString(viewPlaneNormal)}-${imageIndex}`;\n}\n\n/**\n * Transform a color array into a string\n * @param colorArray\n * @returns\n */\nfunction colorToString(colorArray): string {\n  function colorComponentToString(component) {\n    let componentString = Math.floor(component * 255).toString(16);\n    if (componentString.length === 1) {\n      componentString = '0' + componentString;\n    }\n    return componentString;\n  }\n  return (\n    '#' +\n    colorComponentToString(colorArray[0]) +\n    colorComponentToString(colorArray[1]) +\n    colorComponentToString(colorArray[2])\n  );\n}\n\n/**\n * Remove duplicate and unnecessary points\n * @param worldPoints\n * @param canvasPoints\n * @returns\n */\nfunction removeExtraPoints(viewport, worldPointsSet) {\n  return worldPointsSet.map((worldPoints) => {\n    const canvasPoints = worldPoints.map((point) => {\n      const canvasPoint = viewport.worldToCanvas(point);\n      return [Math.floor(canvasPoint[0]), Math.floor(canvasPoint[1])];\n    });\n\n    let lastPoint;\n    const newWorldPoints = [];\n    let newCanvasPoints = [];\n    // removing duplicate points\n    for (let i = 0; i < worldPoints.length; i++) {\n      if (lastPoint) {\n        if (distanceToPoint(lastPoint, canvasPoints[i]) > 0) {\n          newWorldPoints.push(worldPoints[i]);\n          newCanvasPoints.push(canvasPoints[i]);\n        }\n      }\n      lastPoint = canvasPoints[i];\n    }\n\n    // checking if a middle point is near the start\n    const firstPoint = newCanvasPoints[0];\n    for (\n      let j = Math.min(30, newCanvasPoints.length);\n      j < newCanvasPoints.length;\n      j++\n    ) {\n      if (distanceToPoint(firstPoint, newCanvasPoints[j]) < 0.5) {\n        newCanvasPoints = newCanvasPoints.slice(0, j);\n        return newWorldPoints.slice(0, j);\n      }\n    }\n    return newWorldPoints;\n  });\n}\n\nSegmentationIntersectionTool.toolName = 'SegmentationIntersection';\nexport default SegmentationIntersectionTool;\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Given two world positions and an orthogonal view to an `imageVolume` defined by\n * a `viewPlaneNormal` and a `viewUp`, get the width and height in world coordinates of the rectangle\n * defined by the two points. The implementation works both with orthogonal\n * non-orthogonal rectangles.\n *\n * @param viewPlaneNormal - The normal of the view.\n * @param viewUp - The up direction of the view.\n * @param imageVolume - The imageVolume to use to measure.\n * @param worldPos1 - The first world position.\n * @param worldPos2 - The second world position.\n *\n * @returns The `worldWidth` and `worldHeight`.\n */\nexport default function getWorldWidthAndHeightFromTwoPoints(\n  viewPlaneNormal: Types.Point3,\n  viewUp: Types.Point3,\n  worldPos1: Types.Point3,\n  worldPos2: Types.Point3\n): { worldWidth: number; worldHeight: number } {\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n  const pos1 = vec3.fromValues(...worldPos1);\n  const pos2 = vec3.fromValues(...worldPos2);\n\n  const diagonal = vec3.create();\n  vec3.subtract(diagonal, pos1, pos2);\n\n  const diagonalLength = vec3.length(diagonal);\n\n  // When the two points are very close to each other return width as 0\n  // to avoid NaN the cosTheta formula calculation\n  if (diagonalLength < 0.0001) {\n    return { worldWidth: 0, worldHeight: 0 };\n  }\n\n  const cosTheta =\n    vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n\n  const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n\n  const worldWidth = sinTheta * diagonalLength;\n  const worldHeight = cosTheta * diagonalLength;\n\n  return { worldWidth, worldHeight };\n}\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  eventTarget,\n  triggerEvent,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCalibratedAreaUnits,\n  getCalibratedScale,\n} from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  drawCircle as drawCircleSvg,\n  drawEllipseByCoordinates as drawEllipseSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport {\n  pointInEllipse,\n  getCanvasEllipseCorners,\n} from '../../utilities/math/ellipse';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { EllipticalROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { pointInShapeCallback } from '../../utilities/';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport {\n  ModalityUnitOptions,\n  getModalityUnit,\n} from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * EllipticalROITool let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of an elliptical region of interest.\n * You can use EllipticalROITool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Elliptical tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * Changing tool configuration (see below) you can make the tool to draw the center\n * point circle with a given radius.\n *\n * ```js\n * cornerstoneTools.addTool(EllipticalROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(EllipticalROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(EllipticalROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // draw a circle at the center point with 4px radius.\n * toolGroup.setToolConfiguration(EllipticalROITool.toolName, {\n *   centerPointRadius: 4,\n * });\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass EllipticalROITool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    centerWorld?: Array<number>;\n    canvasWidth?: number;\n    canvasHeight?: number;\n    originalHandleCanvas?: Array<number>;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        // Radius of the circle to draw  at the center point of the ellipse.\n        // Set this zero(0) in order not to draw the circle.\n        centerPointRadius: 0,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a EllipticalROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): EllipticalROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          points: [\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n          ] as [Types.Point3, Types.Point3, Types.Point3, Types.Point3],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        initialRotation: viewport.getRotation(),\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      centerWorld: worldPos,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: EllipticalROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p)) as [\n      Types.Point2,\n      Types.Point2,\n      Types.Point2,\n      Types.Point2\n    ];\n    const canvasCorners = getCanvasEllipseCorners(canvasCoordinates);\n\n    const [canvasPoint1, canvasPoint2] = canvasCorners;\n\n    const minorEllipse = {\n      left: Math.min(canvasPoint1[0], canvasPoint2[0]) + proximity / 2,\n      top: Math.min(canvasPoint1[1], canvasPoint2[1]) + proximity / 2,\n      width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) - proximity,\n      height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) - proximity,\n    };\n\n    const majorEllipse = {\n      left: Math.min(canvasPoint1[0], canvasPoint2[0]) - proximity / 2,\n      top: Math.min(canvasPoint1[1], canvasPoint2[1]) - proximity / 2,\n      width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) + proximity,\n      height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) + proximity,\n    };\n\n    const pointInMinorEllipse = this._pointInEllipseCanvas(\n      minorEllipse,\n      canvasCoords\n    );\n    const pointInMajorEllipse = this._pointInEllipseCanvas(\n      majorEllipse,\n      canvasCoords\n    );\n\n    if (pointInMajorEllipse && !pointInMinorEllipse) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: EllipticalROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: EllipticalROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    let centerCanvas;\n    let centerWorld;\n    let canvasWidth;\n    let canvasHeight;\n    let originalHandleCanvas;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      const { points } = data.handles;\n      const { viewport } = getEnabledElement(element);\n      const { worldToCanvas, canvasToWorld } = viewport;\n\n      handleIndex = points.findIndex((p) => p === handle);\n\n      const pointsCanvas = points.map(worldToCanvas);\n\n      originalHandleCanvas = pointsCanvas[handleIndex];\n\n      canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);\n      canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);\n\n      centerCanvas = [\n        (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,\n        (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,\n      ];\n\n      centerWorld = canvasToWorld(centerCanvas);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      canvasWidth,\n      canvasHeight,\n      centerWorld,\n      originalHandleCanvas,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    // Elliptical ROI tool should reset its highlight to false on mouse up (as opposed\n    // to other tools that keep it highlighted until the user moves. The reason\n    // is that we use top-left and bottom-right handles to define the ellipse,\n    // and they are by definition not in the ellipse on mouse up.\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerWorld } = this.editData;\n    const centerCanvas = viewport.worldToCanvas(centerWorld as Types.Point3);\n    const { data } = annotation;\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n\n    // Todo: why bottom is -dY, it should be +dY\n    const bottomCanvas = <Types.Point2>[centerCanvas[0], centerCanvas[1] - dY];\n    const topCanvas = <Types.Point2>[centerCanvas[0], centerCanvas[1] + dY];\n    const leftCanvas = <Types.Point2>[centerCanvas[0] - dX, centerCanvas[1]];\n    const rightCanvas = <Types.Point2>[centerCanvas[0] + dX, centerCanvas[1]];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { viewport } = getEnabledElement(element);\n    const { canvasToWorld, worldToCanvas } = viewport;\n\n    const {\n      annotation,\n      canvasWidth,\n      canvasHeight,\n      handleIndex,\n      centerWorld,\n      originalHandleCanvas,\n    } = this.editData;\n    const centerCanvas = viewport.worldToCanvas(centerWorld as Types.Point3);\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // Move current point in that direction.\n    // Move other points in opposite direction.\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    if (handleIndex === 0 || handleIndex === 1) {\n      // Dragging top or bottom point\n      const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n      const canvasBottom = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] - dYCanvas,\n      ];\n      const canvasTop = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] + dYCanvas,\n      ];\n\n      points[0] = canvasToWorld(canvasBottom);\n      points[1] = canvasToWorld(canvasTop);\n\n      const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];\n      const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;\n      const canvasLeft = <Types.Point2>[\n        centerCanvas[0] - newHalfCanvasWidth,\n        centerCanvas[1],\n      ];\n      const canvasRight = <Types.Point2>[\n        centerCanvas[0] + newHalfCanvasWidth,\n        centerCanvas[1],\n      ];\n\n      points[2] = canvasToWorld(canvasLeft);\n      points[3] = canvasToWorld(canvasRight);\n    } else {\n      // Dragging left or right point\n      const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n      const canvasLeft = <Types.Point2>[\n        centerCanvas[0] - dXCanvas,\n        centerCanvas[1],\n      ];\n      const canvasRight = <Types.Point2>[\n        centerCanvas[0] + dXCanvas,\n        centerCanvas[1],\n      ];\n\n      points[2] = canvasToWorld(canvasLeft);\n      points[3] = canvasToWorld(canvasRight);\n\n      const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];\n      const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;\n      const canvasBottom = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] - newHalfCanvasHeight,\n      ];\n      const canvasTop = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] + newHalfCanvasHeight,\n      ];\n\n      points[0] = canvasToWorld(canvasBottom);\n      points[1] = canvasToWorld(canvasTop);\n    }\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the ellipticalROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as EllipticalROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2, Types.Point2, Types.Point2, Types.Point2];\n\n      const rotation = Math.abs(\n        viewport.getRotation() - (data.initialRotation || 0)\n      );\n      const canvasCorners = <Array<Types.Point2>>(\n        getCanvasEllipseCorners(canvasCoordinates) // bottom, top, left, right, keep as is\n      );\n\n      const { centerPointRadius } = this.configuration;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related viewports data, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-ellipse`;\n      const ellipseUID = '0';\n      drawEllipseSvg(\n        svgDrawingHelper,\n        annotationUID,\n        ellipseUID,\n        canvasCoordinates,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      // draw center point, if \"centerPointRadius\" configuration is valid.\n      if (centerPointRadius > 0) {\n        const minRadius = Math.min(\n          Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, // horizontal radius\n          Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2 // vertical radius\n        );\n        if (minRadius > 3 * centerPointRadius) {\n          const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);\n          drawCircleSvg(\n            svgDrawingHelper,\n            annotationUID,\n            `${ellipseUID}-center`,\n            centerPoint,\n            centerPointRadius,\n            {\n              color,\n              lineDash,\n              lineWidth,\n            }\n          );\n        }\n      }\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      // Poor man's cached?\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats = (\n    annotation,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\n      getCanvasEllipseCorners(canvasCoordinates)\n    );\n\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n    const worldPos1 = topLeftWorld;\n    const worldPos2 = bottomRightWorld;\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata, hasPixelSpacing } = image;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const center = [\n          (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n          (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n          (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n        ] as Types.Point3;\n\n        const ellipseObj = {\n          center,\n          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n        };\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n        const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n        const scale = getCalibratedScale(image);\n        const area =\n          Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2)) /\n          scale /\n          scale;\n\n        const modalityUnitOptions = {\n          isPreScaled: isViewportPreScaled(viewport, targetId),\n\n          isSuvScaled: this.isSuvScaled(\n            viewport,\n            targetId,\n            annotation.metadata.referencedImageId\n          ),\n        };\n\n        const modalityUnit = getModalityUnit(\n          metadata.Modality,\n          annotation.metadata.referencedImageId,\n          modalityUnitOptions\n        );\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        const stats = this.configuration.statsCalculator.getStatistics();\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean: stats[1]?.value,\n          max: stats[0]?.value,\n          stdDev: stats[2]?.value,\n          statsArray: stats,\n          pointsInShape: pointsInShape,\n          isEmptyArea,\n          areaUnit: getCalibratedAreaUnits(null, image),\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n\n  /**\n   * This is a temporary function to use the old ellipse's canvas-based\n   * calculation for isPointNearTool, we should move the the world-based\n   * calculation to the tool's isPointNearTool function.\n   *\n   * @param ellipse - The ellipse object\n   * @param location - The location to check\n   * @returns True if the point is inside the ellipse\n   */\n  _pointInEllipseCanvas(ellipse, location: Types.Point2): boolean {\n    const xRadius = ellipse.width / 2;\n    const yRadius = ellipse.height / 2;\n\n    if (xRadius <= 0.0 || yRadius <= 0.0) {\n      return false;\n    }\n\n    const center = [ellipse.left + xRadius, ellipse.top + yRadius];\n    const normalized = [location[0] - center[0], location[1] - center[1]];\n\n    const inEllipse =\n      (normalized[0] * normalized[0]) / (xRadius * xRadius) +\n        (normalized[1] * normalized[1]) / (yRadius * yRadius) <=\n      1.0;\n\n    return inEllipse;\n  }\n\n  /**\n   * It takes the canvas coordinates of the ellipse corners and returns the center point of it\n   *\n   * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\n   * @returns center point.\n   */\n  _getCanvasEllipseCenter(ellipseCanvasPoints: Types.Point2[]): Types.Point2 {\n    const [bottom, top, left, right] = ellipseCanvasPoints;\n    const topLeft = [left[0], top[1]];\n    const bottomRight = [right[0], bottom[1]];\n    return [\n      (topLeft[0] + bottomRight[0]) / 2,\n      (topLeft[1] + bottomRight[1]) / 2,\n    ] as Types.Point2;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit } =\n    cachedVolumeStats;\n\n  const textLines: string[] = [];\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n    textLines.push(areaLine);\n  }\n\n  if (mean) {\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  }\n\n  if (max) {\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  }\n\n  if (stdDev) {\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nEllipticalROITool.toolName = 'EllipticalROI';\nexport default EllipticalROITool;\n","import { distanceToPoint } from '../point';\nimport { canvasCoordinates } from './_types';\n\n/**\n * It takes the canvas coordinates of the circle corners and returns the top left and bottom right\n * corners of it\n *\n * @param circleCanvasPoints - The coordinates of the circle in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasCircleRadius(\n  circleCanvasPoints: canvasCoordinates\n): number {\n  const [center, end] = circleCanvasPoints;\n  return distanceToPoint(center, end);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { distanceToPoint } from '../point';\nimport { canvasCoordinates } from './_types';\n\n/**\n * It takes the canvas coordinates of the circle corners (wrapping square rectangle)\n * and returns the top left and bottom right\n * corners of it\n *\n * @param circleCanvasPoints - The coordinates of the circle in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasCircleCorners(\n  circleCanvasPoints: canvasCoordinates\n): Array<Types.Point2> {\n  const [center, end] = circleCanvasPoints;\n  const radius = distanceToPoint(center, end);\n\n  const topLeft = <Types.Point2>[center[0] - radius, center[1] - radius];\n  const bottomRight = <Types.Point2>[center[0] + radius, center[1] + radius];\n\n  return [topLeft, bottomRight];\n}\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  eventTarget,\n  triggerEvent,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCalibratedLengthUnits,\n  getCalibratedAreaUnits,\n  getCalibratedScale,\n  getCalibratedAspect,\n} from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { CircleROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { pointInShapeCallback } from '../../utilities';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport {\n  getCanvasCircleCorners,\n  getCanvasCircleRadius,\n} from '../../utilities/math/circle';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * CircleROITool let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of an elliptical region of interest.\n * You can use CircleROITool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Circle tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * Changing tool configuration (see below) you can make the tool to draw the center\n * point circle with a given radius.\n *\n * ```js\n * cornerstoneTools.addTool(CircleROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(CircleROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(CircleROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // draw a circle at the center point with 4px radius.\n * toolGroup.setToolConfiguration(CircleROITool.toolName, {\n *   centerPointRadius: 4,\n * });\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass CircleROITool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        // Radius of the circle to draw  at the center point of the circle.\n        // Set this zero(0) in order not to draw the circle.\n        centerPointRadius: 0,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): CircleROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          points: [[...worldPos], [...worldPos]] as [\n            Types.Point3, // center\n            Types.Point3 // end\n          ],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CircleROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p)) as [\n      Types.Point2,\n      Types.Point2\n    ];\n\n    const radius = getCanvasCircleRadius(canvasCoordinates);\n    const radiusPoint = getCanvasCircleRadius([\n      canvasCoordinates[0],\n      canvasCoords,\n    ]);\n\n    if (Math.abs(radiusPoint - radius) < proximity / 2) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: CircleROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: CircleROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      const { points } = data.handles;\n\n      handleIndex = points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    // Circle ROI tool should reset its highlight to false on mouse up (as opposed\n    // to other tools that keep it highlighted until the user moves. The reason\n    // is that we use top-left and bottom-right handles to define the circle,\n    // and they are by definition not in the circle on mouse up.\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n\n    data.handles.points = [\n      data.handles.points[0], // center stays\n      canvasToWorld(currentCanvasPoints), // end point moves (changing radius)\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n\n    const { annotation, handleIndex } = this.editData;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => worldToCanvas(p));\n\n    // Move current point in that direction.\n    // Move other points in opposite direction.\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    if (handleIndex === 0) {\n      // Dragging center, move the circle ROI\n      const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];\n      const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];\n\n      const canvasCenter = currentCanvasPoints as Types.Point2;\n      const canvasEnd = <Types.Point2>[\n        canvasCoordinates[1][0] + dXCanvas,\n        canvasCoordinates[1][1] + dYCanvas,\n      ];\n\n      points[0] = canvasToWorld(canvasCenter);\n      points[1] = canvasToWorld(canvasEnd);\n    } else {\n      // Dragging end point, center stays\n      points[1] = canvasToWorld(currentCanvasPoints);\n    }\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as CircleROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2, Types.Point2];\n      const center = canvasCoordinates[0];\n      const radius = getCanvasCircleRadius(canvasCoordinates);\n      const canvasCorners = getCanvasCircleCorners(canvasCoordinates);\n\n      const { centerPointRadius } = this.configuration;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n          radius: null,\n          radiusUnit: null,\n          perimeter: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related viewports data, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-circle`;\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        center,\n        radius,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      // draw center point, if \"centerPointRadius\" configuration is valid.\n      if (centerPointRadius > 0) {\n        if (radius > 3 * centerPointRadius) {\n          drawCircleSvg(\n            svgDrawingHelper,\n            annotationUID,\n            `${circleUID}-center`,\n            center,\n            centerPointRadius,\n            {\n              color,\n              lineDash,\n              lineWidth,\n            }\n          );\n        }\n      }\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      // Poor man's cached?\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats = (\n    annotation,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\n      getCanvasCircleCorners(canvasCoordinates)\n    );\n\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n    const worldPos1 = topLeftWorld;\n    const worldPos2 = bottomRightWorld;\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata, hasPixelSpacing } = image;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const center = [\n          (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n          (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n          (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n        ] as Types.Point3;\n\n        const ellipseObj = {\n          center,\n          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n        };\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n        const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n        const scale = getCalibratedScale(image);\n        const aspect = getCalibratedAspect(image);\n        const area = Math.abs(\n          Math.PI *\n            (worldWidth / scale / 2) *\n            (worldHeight / aspect / scale / 2)\n        );\n\n        const modalityUnitOptions = {\n          isPreScaled: isViewportPreScaled(viewport, targetId),\n          isSuvScaled: this.isSuvScaled(\n            viewport,\n            targetId,\n            annotation.metadata.referencedImageId\n          ),\n        };\n\n        const modalityUnit = getModalityUnit(\n          metadata.Modality,\n          annotation.metadata.referencedImageId,\n          modalityUnitOptions\n        );\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          (pointLPS) =>\n            pointInEllipse(ellipseObj, pointLPS, {\n              fast: true,\n            }),\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        const stats = this.configuration.statsCalculator.getStatistics();\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean: stats[1]?.value,\n          max: stats[0]?.value,\n          stdDev: stats[2]?.value,\n          statsArray: stats,\n          pointsInShape: pointsInShape,\n          isEmptyArea,\n          areaUnit: getCalibratedAreaUnits(null, image),\n          radius: worldWidth / 2 / scale,\n          radiusUnit: getCalibratedLengthUnits(null, image),\n          perimeter: (2 * Math.PI * (worldWidth / 2)) / scale,\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const {\n    radius,\n    radiusUnit,\n    area,\n    mean,\n    stdDev,\n    max,\n    isEmptyArea,\n    Modality,\n    areaUnit,\n    modalityUnit,\n  } = cachedVolumeStats;\n\n  const textLines: string[] = [];\n\n  if (radius) {\n    const radiusLine = isEmptyArea\n      ? `Radius: Oblique not supported`\n      : `Radius: ${roundNumber(radius)} ${radiusUnit}`;\n    textLines.push(radiusLine);\n  }\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n    textLines.push(areaLine);\n  }\n\n  if (mean) {\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  }\n\n  if (max) {\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  }\n\n  if (stdDev) {\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nCircleROITool.toolName = 'CircleROI';\nexport default CircleROITool;\n","import { Types } from '@cornerstonejs/core';\nimport * as math from '../../../utilities/math';\nimport type {\n  ISpline,\n  SplineProps,\n  SplineLineSegment,\n  ClosestControlPoint,\n  ClosestSplinePoint,\n  ClosestPoint,\n  ControlPointInfo,\n  SplineCurveSegment,\n} from '../../../types';\n\ntype CurveSegmentDistanceSquared = {\n  curveSegmentIndex: number;\n  curveSegment: SplineCurveSegment;\n  distanceSquared: number;\n};\n\n/**\n * Spline curve representation\n *\n * You can find more about splines in this video\n * https://www.youtube.com/watch?v=jvPPXbo87ds&t=11m20s\n */\nabstract class Spline implements ISpline {\n  private _controlPoints: Types.Point2[] = [];\n  private _resolution: number;\n  private _closed: boolean;\n  private _invalidated = false;\n  private _curveSegments: SplineCurveSegment[];\n  private _aabb: Types.AABB2;\n  private _length = 0;\n\n  constructor(props?: SplineProps) {\n    this._controlPoints = [];\n    this._resolution = props?.resolution ?? 20;\n    this._closed = props?.closed ?? false;\n    this._invalidated = true;\n  }\n\n  /**\n   * Return the control points array\n   *\n   * Any external access should be done through getControlPoints because it\n   * clones the points to make sure the data will not get changed by the caller\n   */\n  protected get controlPoints(): Types.Point2[] {\n    return this._controlPoints;\n  }\n\n  /** Number of control points */\n  public get numControlPoints(): number {\n    return this._controlPoints.length;\n  }\n\n  /** Resolution of the spline curve (greater than or equal to 0) */\n  public get resolution(): number {\n    return this._resolution;\n  }\n\n  /** Set the resolution of the spline curve */\n  public set resolution(resolution: number) {\n    if (this._resolution === resolution) {\n      return;\n    }\n\n    this._resolution = resolution;\n    this.invalidated = true;\n  }\n\n  /** Flag that is set to true when the curve is already closed */\n  public get closed(): boolean {\n    return this._closed;\n  }\n\n  /** Set the curve as closed which connects the last to the first point */\n  public set closed(closed: boolean) {\n    if (this._closed === closed) {\n      return;\n    }\n\n    this._closed = closed;\n    this.invalidated = true;\n  }\n\n  /** Axis-aligned bounding box (minX, minY, maxX, maxY) */\n  public get aabb(): Types.AABB2 {\n    this._update();\n    return this._aabb;\n  }\n\n  /** Length of the spline curve in pixels */\n  public get length(): number {\n    this._update();\n    return this._length;\n  }\n\n  /**\n   * Flag that is set to true when the spline needs to be updated. The update\n   * runs automaticaly when needed (eg: getPolylinePoints).\n   */\n  public get invalidated(): boolean {\n    return this._invalidated;\n  }\n\n  /**\n   * Sets the spline as invalid when curve segments need to be recalculated\n   * or as valid after recomputing the curves\n   */\n  protected set invalidated(invalidated: boolean) {\n    this._invalidated = invalidated;\n  }\n\n  /**\n   * Bzier curves have tangent points connected to control points\n   * @returns True if the spline has tangent point or false otherwise\n   */\n  public hasTangentPoints() {\n    return false;\n  }\n\n  /**\n   * Add a control point to the end of the array\n   * @param point - Control point (2D)\n   */\n  public addControlPoint(point: Types.Point2): void {\n    this._controlPoints.push([point[0], point[1]]);\n    this.invalidated = true;\n  }\n\n  /**\n   * Add a list of control poits to the end of the array\n   * @param points - Control points to be added\n   */\n  public addControlPoints(points: Types.Point2[]): void {\n    points.forEach((point) => this.addControlPoint(point));\n  }\n\n  /**\n   * Add a control point specifying its `u` value in Parameter Space which is a number from 0 to N\n   * where N is the number of curve segments. The integer part is the curve segment index and the\n   * decimal part is the `t` value on that curve segment.\n   * @param u - `u` value in Parameter Space\n   */\n  public addControlPointAtU(u: number): ControlPointInfo {\n    const lineSegment = this._getLineSegmentAt(u);\n    const { start: startPoint, end: endPoint } = lineSegment.points;\n    const curveSegmentIndex = Math.floor(u);\n    const curveSegment = this._curveSegments[curveSegmentIndex];\n    const t = u - Math.floor(curveSegmentIndex);\n    const controlPointPos: Types.Point2 = [\n      startPoint[0] + t * (endPoint[0] - startPoint[0]),\n      startPoint[1] + t * (endPoint[1] - startPoint[1]),\n    ];\n\n    const insertIndex =\n      this._controlPoints.indexOf(curveSegment.controlPoints.p1) + 1;\n\n    this._controlPoints.splice(insertIndex, 0, controlPointPos);\n    this.invalidated = true;\n\n    return {\n      index: insertIndex,\n      point: controlPointPos,\n    };\n  }\n\n  /**\n   * Delete a control point given its index\n   * @param index - Control point index to be removed\n   * @returns True if the control point is removed or false otherwise\n   */\n  public deleteControlPointByIndex(index: number): boolean {\n    const minControlPoints = this._closed ? 3 : 1;\n    const canDelete =\n      index >= 0 &&\n      index < this._controlPoints.length &&\n      this._controlPoints.length > minControlPoints;\n\n    if (!canDelete) {\n      return false;\n    }\n\n    this._controlPoints.splice(index, 1);\n    this.invalidated = true;\n\n    return true;\n  }\n\n  /**\n   * Remove all control points\n   */\n  public clearControlPoints(): void {\n    this._controlPoints = [];\n    this.invalidated = true;\n  }\n\n  /**\n   * Replace all control points by some new ones\n   * @param points - Control points to be added to the array\n   */\n  public setControlPoints(points: Types.Point2[]): void {\n    this.clearControlPoints();\n    this.addControlPoints(points);\n  }\n\n  /**\n   * Update the coordinate of a control point given its index\n   * @param index - Control point index\n   * @param newControlPoint - New control point\n   */\n  public updateControlPoint(\n    index: number,\n    newControlPoint: Types.Point2\n  ): void {\n    if (index < 0 || index >= this._controlPoints.length) {\n      throw new Error('Index out of bounds');\n    }\n\n    this._controlPoints[index] = [...newControlPoint];\n    this.invalidated = true;\n  }\n\n  /**\n   * Get a list with all control points. The control points are cloned to prevent\n   * any caller from changing them resulting in unexpected behaviors\n   * @returns - List of all control points\n   */\n  public getControlPoints(): Types.Point2[] {\n    return this._controlPoints.map((controlPoint) => [\n      controlPoint[0],\n      controlPoint[1],\n    ]);\n  }\n\n  /**\n   * Finds the closest control point given a 2D point\n   * @param point - Reference point\n   * @returns Closest control point\n   */\n  public getClosestControlPoint(point: Types.Point2): ClosestControlPoint {\n    const controlPoints = this._controlPoints;\n    let minSquaredDist = Infinity;\n    let closestPointIndex = -1;\n\n    for (let i = 0, len = controlPoints.length; i < len; i++) {\n      const controlPoint = controlPoints[i];\n      const dx = point[0] - controlPoint[0];\n      const dy = point[1] - controlPoint[1];\n      const squaredDist = dx * dx + dy * dy;\n\n      if (squaredDist < minSquaredDist) {\n        minSquaredDist = squaredDist;\n        closestPointIndex = i;\n      }\n    }\n\n    return {\n      index: closestPointIndex,\n      point:\n        closestPointIndex === -1\n          ? undefined\n          : [...controlPoints[closestPointIndex]],\n      distance: Math.sqrt(minSquaredDist),\n    };\n  }\n\n  /**\n   * Finds the closest control point given a 2D point and a maximum distance\n   * @param point - Reference 2D point\n   * @param maxDist - Maximum distance\n   * @returns Closest control point that is within the given range or undefined otherwise\n   */\n  public getClosestControlPointWithinDistance(\n    point: Types.Point2,\n    maxDist: number\n  ): ClosestControlPoint {\n    const closestControlPoint = this.getClosestControlPoint(point);\n\n    return closestControlPoint.distance <= maxDist\n      ? closestControlPoint\n      : undefined;\n  }\n\n  /**\n   * Finds the closest point on the spline curve given 2D point\n   * @param point - Reference 2D point\n   * @returns Closest point on the spline curve\n   */\n  public getClosestPoint(point: Types.Point2): ClosestSplinePoint {\n    this._update();\n\n    const curveSegmentsDistInfo =\n      this._getCurveSegmmentsDistanceSquaredInfo(point);\n\n    if (!curveSegmentsDistInfo.length) {\n      return;\n    }\n\n    // Sort the curves by distance because in most cases the closest point may be in the first\n    // curve segment and there is no need to check all next line segments if theirs curve segments'\n    // AABB is not closest compared to the minDist found saving a lot of cpu time.\n    curveSegmentsDistInfo.sort(\n      (csA, csB) => csA.distanceSquared - csB.distanceSquared\n    );\n\n    let closestPoint: Types.Point2;\n    let closestPointCurveSegmentIndex = -1;\n    let minDistSquared = Infinity;\n    let minDistCurveSegment: SplineCurveSegment;\n    let minDistLineSegment: SplineLineSegment;\n\n    for (let i = 0; i < curveSegmentsDistInfo.length; i++) {\n      const curveSegmentDistInfo = curveSegmentsDistInfo[i];\n\n      // If the distance to curve segments' AABB is greater than the minDist\n      // it does not need to waste time verifying each line segment\n      if (curveSegmentDistInfo.distanceSquared > minDistSquared) {\n        continue;\n      }\n\n      const { curveSegmentIndex, curveSegment } = curveSegmentDistInfo;\n      const { lineSegments } = curveSegment;\n\n      for (let j = 0; j < lineSegments.length; j++) {\n        const lineSegment = lineSegments[j];\n        const { point: lineSegPoint, distanceSquared: lineSegDistSquared } =\n          math.lineSegment.distanceToPointSquaredInfo(\n            lineSegment.points.start,\n            lineSegment.points.end,\n            point\n          );\n\n        if (lineSegDistSquared < minDistSquared) {\n          minDistLineSegment = lineSegment;\n          closestPointCurveSegmentIndex = curveSegmentIndex;\n          minDistCurveSegment = curveSegmentDistInfo.curveSegment;\n          closestPoint = lineSegPoint;\n          minDistSquared = lineSegDistSquared;\n        }\n      }\n    }\n\n    const curveSegmentLengthToPoint =\n      minDistLineSegment.previousLineSegmentsLength +\n      math.point.distanceToPoint(minDistLineSegment.points.start, closestPoint);\n\n    const t = curveSegmentLengthToPoint / minDistCurveSegment.length;\n    const u = closestPointCurveSegmentIndex + t;\n\n    return {\n      point: closestPoint,\n      uValue: u,\n      distance: Math.sqrt(minDistSquared),\n    };\n  }\n\n  /**\n   * Finds the closest point on the straight line that connects all control points given a 2D point\n   * @param point - Reference point\n   * @returns Closest point on the straight line that connects all control points\n   */\n  public getClosestPointOnControlPointLines(point: Types.Point2): ClosestPoint {\n    const linePoints = [...this._controlPoints];\n\n    if (this._closed) {\n      linePoints.push(this._controlPoints[0]);\n    }\n\n    if (!linePoints.length) {\n      return;\n    }\n\n    let closestPoint: Types.Point2;\n    let minDistSquared = Infinity;\n    let startPoint = linePoints[0];\n\n    for (let i = 1, len = linePoints.length; i < len; i++) {\n      const endPoint = linePoints[i];\n      const { point: lineSegPoint, distanceSquared: lineSegDistSquared } =\n        math.lineSegment.distanceToPointSquaredInfo(\n          startPoint,\n          endPoint,\n          point\n        );\n\n      if (lineSegDistSquared < minDistSquared) {\n        closestPoint = lineSegPoint;\n        minDistSquared = lineSegDistSquared;\n      }\n\n      startPoint = endPoint;\n    }\n\n    return {\n      point: closestPoint,\n      distance: Math.sqrt(minDistSquared),\n    };\n  }\n\n  /**\n   * Get all points necessary to draw a spline curve\n   * @returns Array with all points necessary to draw a spline curve\n   */\n  public getPolylinePoints(): Types.Point2[] {\n    this._update();\n\n    return this._convertCurveSegmentsToPolyline(this._curveSegments);\n  }\n\n  /**\n   * Get all points necessary to draw the preview of the changes that shall be\n   * made to the spline if a new control point is added to it\n   * @param controlPointPreview - New control point preview\n   * @param closeDistance - Distance to the first control point to consider it a closed spline\n   * @returns Array with all points necessary to draw a spline curve preview\n   */\n  public getPreviewPolylinePoints(\n    controlPointPreview: Types.Point2,\n    closeDistance: number\n  ): Types.Point2[] {\n    if (this._closed) {\n      return [];\n    }\n\n    this._update();\n\n    // Check if the new control point would be close to the first one\n    // in order to create a preview of a closed spline\n    const closestControlPoint = this.getClosestControlPointWithinDistance(\n      controlPointPreview,\n      closeDistance\n    );\n\n    const closeSpline = closestControlPoint?.index === 0;\n    const previewCurveSegments = this.getPreviewCurveSegments(\n      controlPointPreview,\n      closeSpline\n    );\n\n    return previewCurveSegments?.length\n      ? this._convertCurveSegmentsToPolyline(previewCurveSegments)\n      : [];\n  }\n\n  /**\n   * Checks if a point is near to the spline curve\n   * @param point - Reference point\n   * @param maxDist - Maximum allowed distance\n   * @returns True if the point is close to the spline curve or false otherwise\n   */\n  public isPointNearCurve(point: Types.Point2, maxDist: number): boolean {\n    this._update();\n\n    const curveSegments = this._getCurveSegmmentsWithinDistance(point, maxDist);\n    const maxDistSquared = maxDist * maxDist;\n\n    // Check if the point is close to the spline and doest waste time checking each curve/line\n    for (let i = 0; i < curveSegments.length; i++) {\n      const { lineSegments } = curveSegments[i];\n\n      for (let j = 0; j < lineSegments.length; j++) {\n        const lineSegment = lineSegments[j];\n        const lineDistSquared = math.lineSegment.distanceToPointSquared(\n          lineSegment.points.start,\n          lineSegment.points.end,\n          point\n        );\n\n        if (lineDistSquared <= maxDistSquared) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Checks if a 2D point is inside the spline curve.\n   *\n   * A point is inside a curve/polygon if the number of intersections between the horizontal\n   * ray emanating from the given point and to the right and the line segments is odd.\n   * https://www.eecs.umich.edu/courses/eecs380/HANDOUTS/PROJ2/InsidePoly.html\n   *\n   * @param point - 2D Point\n   * @returns True is the point is inside the spline curve or false otherwise\n   */\n  public containsPoint(point: Types.Point2): boolean {\n    this._update();\n\n    const controlPoints = this._controlPoints;\n\n    if (controlPoints.length < 3) {\n      return false;\n    }\n\n    const curveSegments = [...this._curveSegments];\n    const closingCurveSegment =\n      this._getClosingCurveSegmentWithStraightLineSegment();\n\n    if (closingCurveSegment) {\n      curveSegments.push(closingCurveSegment);\n    }\n\n    let numIntersections = 0;\n\n    for (let i = 0; i < curveSegments.length; i++) {\n      const curveSegment = curveSegments[i];\n      const { aabb: curveSegAABB } = curveSegment;\n      const mayIntersectCurveSegment =\n        point[0] <= curveSegAABB.maxX &&\n        point[1] >= curveSegAABB.minY &&\n        point[1] < curveSegAABB.maxY;\n\n      // Skip all line segments if it is not possible to intersect the curve segment\n      if (!mayIntersectCurveSegment) {\n        continue;\n      }\n\n      const { lineSegments } = curveSegment;\n\n      for (let i = 0; i < lineSegments.length; i++) {\n        const lineSegment = lineSegments[i];\n        const { aabb: lineSegmentAABB } = lineSegment;\n        const mayIntersectLineSegment =\n          point[0] <= lineSegmentAABB.maxX &&\n          point[1] >= lineSegmentAABB.minY &&\n          point[1] < lineSegmentAABB.maxY;\n\n        if (mayIntersectLineSegment) {\n          const { start: p1, end: p2 } = lineSegment.points;\n          const isVerticalLine = p1[0] === p2[0];\n          const xIntersection =\n            ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];\n\n          numIntersections +=\n            isVerticalLine || point[0] <= xIntersection ? 1 : 0;\n        }\n      }\n    }\n\n    return numIntersections % 2 === 1;\n  }\n\n  protected abstract getTransformMatrix(): number[];\n\n  protected abstract getSplineCurves(): SplineCurveSegment[];\n\n  protected abstract getPreviewCurveSegments(\n    controlPointPreview: Types.Point2,\n    closeSpline: boolean\n  ): SplineCurveSegment[];\n\n  private _update() {\n    if (!this._invalidated) {\n      return;\n    }\n\n    const curveSegments = this.getSplineCurves();\n    let length = 0;\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for (let i = 0, len = curveSegments.length; i < len; i++) {\n      const { aabb: curveSegAABB, length: curveSegLength } = curveSegments[i];\n\n      minX = minX <= curveSegAABB.minX ? minX : curveSegAABB.minX;\n      minY = minY <= curveSegAABB.minY ? minY : curveSegAABB.minY;\n      maxX = maxX >= curveSegAABB.maxX ? maxX : curveSegAABB.maxX;\n      maxY = maxY >= curveSegAABB.maxY ? maxY : curveSegAABB.maxY;\n      length += curveSegLength;\n    }\n\n    this._curveSegments = curveSegments;\n    this._aabb = { minX, minY, maxX, maxY };\n    this._length = length;\n    this._invalidated = false;\n  }\n\n  private _convertCurveSegmentsToPolyline(\n    curveSegments: SplineCurveSegment[]\n  ): Types.Point2[] {\n    this._update();\n\n    const polylinePoints: Types.Point2[] = [];\n\n    curveSegments.forEach(({ lineSegments }, curveSegIndex) => {\n      lineSegments.forEach((lineSegment, lineSegIndex) => {\n        // Add the start point before adding all end points\n        if (curveSegIndex === 0 && lineSegIndex === 0) {\n          polylinePoints.push([...lineSegment.points.start]);\n        }\n\n        // Always add 1 because the first segment stored its start point at the first position\n        polylinePoints.push([...lineSegment.points.end]);\n      });\n    });\n\n    return polylinePoints;\n  }\n\n  /**\n   * Returns all curve segments and theirs respective squared distance to a given point\n   * @param point - Reference point\n   * @returns Curve segments and theirs respective squared distance to a given point\n   */\n  private _getCurveSegmmentsDistanceSquaredInfo(\n    point: Types.Point2\n  ): CurveSegmentDistanceSquared[] {\n    this._update();\n\n    const curveSegmentsDistanceSquared: CurveSegmentDistanceSquared[] = [];\n    const { _curveSegments: curveSegments } = this;\n\n    for (let i = 0; i < curveSegments.length; i++) {\n      const curveSegment = curveSegments[i];\n      const distanceSquared = math.aabb.distanceToPointSquared(\n        curveSegment.aabb,\n        point\n      );\n\n      curveSegmentsDistanceSquared.push({\n        curveSegmentIndex: i,\n        curveSegment,\n        distanceSquared,\n      });\n    }\n\n    return curveSegmentsDistanceSquared;\n  }\n\n  private _getCurveSegmmentsWithinDistance(\n    point: Types.Point2,\n    maxDist: number\n  ): SplineCurveSegment[] {\n    this._update();\n\n    const maxDistSquared = maxDist * maxDist;\n\n    // Does not waste time checking each curve segment if the point is not event\n    // close to the spline's AABB\n    if (math.aabb.distanceToPointSquared(this.aabb, point) > maxDistSquared) {\n      return [];\n    }\n\n    const curveSegmentsDistance =\n      this._getCurveSegmmentsDistanceSquaredInfo(point);\n    const curveSegmentsWithinRange: SplineCurveSegment[] = [];\n\n    for (let i = 0, len = curveSegmentsDistance.length; i < len; i++) {\n      const { curveSegment, distanceSquared: curveSegmentDistSquared } =\n        curveSegmentsDistance[i];\n\n      if (curveSegmentDistSquared <= maxDistSquared) {\n        curveSegmentsWithinRange.push(curveSegment);\n      }\n    }\n\n    return curveSegmentsWithinRange;\n  }\n\n  private _getLineSegmentAt(u: number): SplineLineSegment {\n    this._update();\n\n    const curveSegmentIndex = Math.floor(u);\n    const t = u - curveSegmentIndex;\n    const curveSegment = this._curveSegments[curveSegmentIndex];\n    const { lineSegments } = curveSegment;\n    const pointLength = curveSegment.length * t;\n\n    for (let i = 0; i < lineSegments.length; i++) {\n      const lineSegment = lineSegments[i];\n      const lengthEnd =\n        lineSegment.previousLineSegmentsLength + lineSegment.length;\n\n      if (\n        pointLength >= lineSegment.previousLineSegmentsLength &&\n        pointLength <= lengthEnd\n      ) {\n        return lineSegment;\n      }\n    }\n  }\n\n  /**\n   * Creates a curve segment with a single line segment connecting the start and end control points\n   * @returns A curve segment that closes the spline\n   */\n  private _getClosingCurveSegmentWithStraightLineSegment(): SplineCurveSegment {\n    if (this.closed) {\n      return;\n    }\n\n    const controlPoints = this._controlPoints;\n    const startControlPoint = controlPoints[0];\n    const endControlPoint = controlPoints[controlPoints.length - 1];\n\n    // The only properties needed are `points` and `aabb`. All the other ones may undefined\n    const closingLineSegment: SplineLineSegment = {\n      points: {\n        start: [...startControlPoint],\n        end: [...endControlPoint],\n      },\n      aabb: {\n        minX: Math.min(startControlPoint[0], endControlPoint[0]),\n        minY: Math.min(startControlPoint[1], endControlPoint[1]),\n        maxX: Math.max(startControlPoint[0], endControlPoint[0]),\n        maxY: Math.max(startControlPoint[1], endControlPoint[1]),\n      },\n    } as SplineLineSegment;\n\n    // The only properties needed are `lineSegments` and `aabb`. All the other ones may undefined\n    return {\n      aabb: {\n        minX: closingLineSegment.aabb.minX,\n        minY: closingLineSegment.aabb.minY,\n        maxX: closingLineSegment.aabb.maxX,\n        maxY: closingLineSegment.aabb.maxY,\n      },\n      lineSegments: [closingLineSegment],\n    } as SplineCurveSegment;\n  }\n}\n\nexport { Spline as default, Spline };\n","import { vec4, mat4 } from 'gl-matrix';\nimport { Types } from '@cornerstonejs/core';\nimport { Spline } from './Spline';\nimport * as math from '../../../utilities/math';\nimport type { SplineCurveSegment, SplineLineSegment } from '../../../types';\n\n// The `u` in Parameter Space used when spliting a curve segment into line segments must\n// be greater than or equal to `curveSegmentIndex` and smaller than `curveSegmentIndex + 1`.\n// In this case we are using `curveSegmentIndex + 1 - MAX_U_ERROR`\nconst MAX_U_ERROR = 1e-8;\n\n/**\n * Base class for all cubic splines\n */\nabstract class CubicSpline extends Spline {\n  protected getPreviewCurveSegments(\n    controlPointPreview: Types.Point2,\n    closeSpline: boolean\n  ): SplineCurveSegment[] {\n    const previewNumCurveSegments = this._getNumCurveSegments() + 1;\n    const startCurveSegIndex = Math.max(0, previewNumCurveSegments - 2);\n    const endCurveSegIndex = closeSpline\n      ? previewNumCurveSegments\n      : previewNumCurveSegments - 1;\n    const transformMatrix = this.getTransformMatrix();\n    const controlPoints = [...this.controlPoints];\n    const curveSegments: SplineCurveSegment[] = [];\n\n    if (!closeSpline) {\n      controlPoints.push(controlPointPreview);\n    }\n\n    for (let i = startCurveSegIndex; i <= endCurveSegIndex; i++) {\n      const curveSegment = this._getCurveSegment(\n        i,\n        transformMatrix,\n        controlPoints,\n        closeSpline\n      );\n\n      curveSegments.push(curveSegment);\n    }\n\n    return curveSegments;\n  }\n\n  protected getSplineCurves(): SplineCurveSegment[] {\n    const numCurveSegments = this._getNumCurveSegments();\n    const curveSegments: SplineCurveSegment[] = new Array(numCurveSegments);\n\n    if (numCurveSegments <= 0) {\n      return [];\n    }\n\n    const transformMatrix = this.getTransformMatrix();\n    let previousCurveSegmentsLength = 0;\n\n    for (let i = 0; i < numCurveSegments; i++) {\n      const curveSegment = this._getCurveSegment(i, transformMatrix);\n\n      curveSegment.previousCurveSegmentsLength = previousCurveSegmentsLength;\n      curveSegments[i] = curveSegment;\n\n      previousCurveSegmentsLength += curveSegment.length;\n    }\n\n    return curveSegments;\n  }\n\n  private _getNumCurveSegments(\n    controlPoints: Types.Point2[] = this.controlPoints,\n    closed: boolean = this.closed\n  ): number {\n    return closed\n      ? controlPoints.length\n      : Math.max(0, controlPoints.length - 1);\n  }\n\n  /**\n   * Get a point on a spline curve given `u` value\n   *\n   * @param u - `u` value in Parameter Space that must be between 0 and N where N is the number of\n   *   curve segments for opened splines or any negative/positive number for closed splines\n   * @returns - Point (x, y) on the spline. It may return `undefined` when `u` is smaller than 0\n   *   or greater than N for opened splines\n   */\n  private _getPoint(\n    u: number,\n    transformMatrix: number[],\n    controlPoints: Types.Point2[] = this.controlPoints,\n    closed: boolean = this.closed\n  ): Types.Point2 {\n    const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n    const uInt = Math.floor(u);\n    let curveSegmentIndex = uInt % numCurveSegments;\n\n    // `t` must be between 0 and 1\n    const t = u - uInt;\n\n    const curveSegmentIndexOutOfBounds =\n      curveSegmentIndex < 0 || curveSegmentIndex >= numCurveSegments;\n\n    if (curveSegmentIndexOutOfBounds) {\n      if (this.closed) {\n        // Wraps around when the index is negative or greater than or equal to `numSegments`\n        curveSegmentIndex =\n          (numCurveSegments + curveSegmentIndex) % numCurveSegments;\n      } else {\n        // Point is not on the spline curve\n        return;\n      }\n    }\n\n    const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(\n      curveSegmentIndex,\n      controlPoints,\n      closed\n    );\n\n    // Formula to find any point on a cubic spline curve given a `t` value\n    //\n    // P(t) = [1  t  t2  t3] | m00 m01 m02 m03 |  | P0 |\n    //                       | m10 m11 m12 m13 |  | P1 |\n    //                       | m20 m21 m22 m23 |  | P2 |\n    //                       | m30 m31 m32 m33 |  | P3 |\n\n    const tt = t * t;\n    const ttt = tt * t;\n    const tValues = vec4.fromValues(1, t, tt, ttt);\n\n    // Influential field values which tell us how much P0, P1, P2 and P3 influence\n    // each point of the curve\n    const qValues = vec4.transformMat4(\n      vec4.create(),\n      tValues,\n      transformMatrix as mat4\n    );\n\n    return [\n      vec4.dot(qValues, vec4.fromValues(p0[0], p1[0], p2[0], p3[0])),\n      vec4.dot(qValues, vec4.fromValues(p0[1], p1[1], p2[1], p3[1])),\n    ] as Types.Point2;\n  }\n\n  private _getCurveSegmentPoints(\n    curveSegmentIndex: number,\n    controlPoints: Types.Point2[] = this.controlPoints,\n    closed: boolean = this.closed\n  ) {\n    const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n    const p1Index = curveSegmentIndex;\n    const p0Index = p1Index - 1;\n    const p2Index = closed ? (p1Index + 1) % numCurveSegments : p1Index + 1;\n    const p3Index = p2Index + 1;\n    const p1 = controlPoints[p1Index];\n    const p2 = controlPoints[p2Index];\n    let p0;\n    let p3;\n\n    // P0 shall be negative when P1/P2 are the start/end points of the first curve segment\n    if (p0Index >= 0) {\n      p0 = controlPoints[p0Index];\n    } else {\n      p0 = closed\n        ? controlPoints[controlPoints.length - 1]\n        : math.point.mirror(p2, p1);\n    }\n\n    // P3 shall be negative when P1/P2 are the start/end points of the last curve segment\n    if (p3Index < controlPoints.length) {\n      p3 = controlPoints[p3Index];\n    } else {\n      p3 = closed ? controlPoints[0] : math.point.mirror(p1, p2);\n    }\n\n    return { p0, p1, p2, p3 };\n  }\n\n  private _getLineSegments(\n    curveSegmentIndex: number,\n    transformMatrix: number[],\n    controlPoints: Types.Point2[] = this.controlPoints,\n    closed: boolean = this.closed\n  ): SplineLineSegment[] {\n    const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n    const numLineSegments = this.resolution + 1;\n    const inc = 1 / numLineSegments;\n    const minU = curveSegmentIndex;\n    let maxU = minU + 1;\n\n    // 'u' must be greater than or equal to 0 and smaller than N where N is the number of segments\n    // otherwise it does not find the spline segment when it is not a closed curve because it is\n    // 0-based indexed. In this case `u` needs to get very close to the end point but never touch it\n    if (!closed && curveSegmentIndex === numCurveSegments - 1) {\n      maxU -= MAX_U_ERROR;\n    }\n\n    const lineSegments: SplineLineSegment[] = [];\n    let startPoint: Types.Point2;\n    let endPoint: Types.Point2;\n    let previousLineSegmentsLength = 0;\n\n    for (let i = 0, u = minU; i <= numLineSegments; i++, u += inc) {\n      // `u` may be greater than maxU in the last FOR loop due to number precision issue\n      u = u > maxU ? maxU : u;\n\n      const point = this._getPoint(u, transformMatrix, controlPoints, closed);\n\n      if (!i) {\n        startPoint = point;\n        continue;\n      }\n\n      endPoint = point;\n\n      const dx = endPoint[0] - startPoint[0];\n      const dy = endPoint[1] - startPoint[1];\n      const length = Math.sqrt(dx ** 2 + dy ** 2);\n      const aabb: Types.AABB2 = {\n        minX: startPoint[0] <= endPoint[0] ? startPoint[0] : endPoint[0],\n        maxX: startPoint[0] >= endPoint[0] ? startPoint[0] : endPoint[0],\n        minY: startPoint[1] <= endPoint[1] ? startPoint[1] : endPoint[1],\n        maxY: startPoint[1] >= endPoint[1] ? startPoint[1] : endPoint[1],\n      };\n\n      lineSegments.push({\n        points: {\n          start: startPoint,\n          end: endPoint,\n        },\n        aabb,\n        length,\n        previousLineSegmentsLength,\n      });\n\n      startPoint = endPoint;\n      previousLineSegmentsLength += length;\n    }\n\n    return lineSegments;\n  }\n\n  private _getCurveSegment(\n    curveSegmentIndex: number,\n    transformMatrix: number[] = this.getTransformMatrix(),\n    controlPoints: Types.Point2[] = this.controlPoints,\n    closed: boolean = this.closed\n  ): SplineCurveSegment {\n    // Cubic spline curves are mainly controlled by P1 and P2 points but\n    // they are also influenced by previous (P0) and next (P3) poins. For\n    // Cardinal, Linear and Catmull-Rom splines P1 and P2 are also known as\n    // knots because they are the connection between two curve segments.\n    const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(\n      curveSegmentIndex,\n      controlPoints,\n      closed\n    );\n    const lineSegments = this._getLineSegments(\n      curveSegmentIndex,\n      transformMatrix,\n      controlPoints,\n      closed\n    );\n    let curveSegmentLength = 0;\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    lineSegments.forEach(({ aabb: lineSegAABB, length: lineSegLength }) => {\n      minX = Math.min(minX, lineSegAABB.minX);\n      minY = Math.min(minY, lineSegAABB.minY);\n      maxX = Math.max(maxX, lineSegAABB.maxX);\n      maxY = Math.max(maxY, lineSegAABB.maxY);\n      curveSegmentLength += lineSegLength;\n    });\n\n    return {\n      controlPoints: { p0, p1, p2, p3 },\n      aabb: { minX, minY, maxX, maxY },\n      length: curveSegmentLength,\n      previousCurveSegmentsLength: 0,\n      lineSegments,\n    };\n  }\n}\n\nexport { CubicSpline as default, CubicSpline };\n","import { CubicSpline } from './CubicSpline';\nimport { CardinalSplineProps } from '../../../types';\n\nclass CardinalSpline extends CubicSpline {\n  private _scale: number;\n  private _fixedScale: boolean;\n\n  constructor(props?: CardinalSplineProps) {\n    super(props);\n    this._scale = props?.scale ?? 0.5;\n    this._fixedScale = props?.fixedScale ?? false;\n  }\n\n  public get scale() {\n    return this._scale;\n  }\n\n  public set scale(scale: number) {\n    if (this._fixedScale || this._scale === scale) {\n      return;\n    }\n\n    this._scale = scale;\n    this.invalidated = true;\n  }\n\n  public get fixedScale() {\n    return this._fixedScale;\n  }\n\n  protected getTransformMatrix(): number[] {\n    const { scale: s } = this;\n    const s2 = 2 * s;\n\n    // prettier-ignore\n    return [\n       0,      1,       0,   0,\n      -s,      0,       s,   0,\n      s2,  s - 3,  3 - s2,  -s,\n      -s,  2 - s,   s - 2,   s\n    ];\n  }\n}\n\nexport { CardinalSpline as default, CardinalSpline };\n","import { CardinalSpline } from './CardinalSpline';\n\n// TODO: LinearSpline should inherit from Spline\n\n/**\n * Linear spline matrix is the same one from Cardinal spline with scale equal\n * to 0. Then it can inherit from Spline using the matrix below or inherit from\n * CardinalSpline fixing the scale to 0\n *\n * Transformation Matrix:\n *      1,   0,\n *     -1,  -1,\n */\nclass LinearSpline extends CardinalSpline {\n  constructor() {\n    super({ scale: 0, fixedScale: true });\n  }\n}\n\nexport { LinearSpline as default, LinearSpline };\n","import { CardinalSpline } from './CardinalSpline';\n\n// Catmull-Rom spline matrix is a Cardinal spline with scale equal to 1/2. Then\n// it can inherit from CubicSpline using the matrix below or inherit from\n// CardinalSpline using a fixed scale equal to 0.5.\n//\n// Transformation Matrix:\n//      0,  2,  0,  0,\n//     -1,  0,  1,  0,\n//      2, -5,  4, -1,\n//     -1,  3, -3,  1\n\nclass CatmullRomSpline extends CardinalSpline {\n  constructor() {\n    super({ scale: 0.5, fixedScale: true });\n  }\n}\n\nexport { CatmullRomSpline as default, CatmullRomSpline };\n","import { mat4 } from 'gl-matrix';\nimport { CubicSpline } from './CubicSpline';\n\n// prettier-ignore\nconst TRANSFORM_MATRIX = mat4.multiplyScalar(\n  mat4.create(),\n  mat4.fromValues(\n     1,  4,  1,  0,\n    -3,  0,  3,  0,\n     3, -6,  3,  0,\n    -1,  3, -3,  1,\n  ),\n  1 / 6\n) as number[];\n\nclass BSpline extends CubicSpline {\n  protected getTransformMatrix(): number[] {\n    return TRANSFORM_MATRIX;\n  }\n}\n\nexport { BSpline as default, BSpline };\n","import { utilities } from '@cornerstonejs/core';\nimport {\n  getEnabledElement,\n  eventTarget,\n  triggerEvent,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { removeAnnotation } from '../../stateManagement/annotation/annotationState';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawPolyline as drawPolylineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events, MouseBindings, KeyboardBindings } from '../../enums';\nimport { resetElementCursor } from '../../cursors/elementCursor';\nimport {\n  Annotation,\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport {\n  math,\n  throttle,\n  roundNumber,\n  triggerAnnotationRenderForViewportIds,\n  getCalibratedScale,\n  getCalibratedAreaUnits,\n} from '../../utilities';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\n\nimport { SplineROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\nimport { ISpline } from '../../types/ISpline';\nimport { CardinalSpline } from './splines/CardinalSpline';\nimport { LinearSpline } from './splines/LinearSpline';\nimport { CatmullRomSpline } from './splines/CatmullRomSpline';\nimport { BSpline } from './splines/BSpline';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\n\nconst SPLINE_MIN_POINTS = 3;\nconst SPLINE_CLICK_CLOSE_CURVE_DIST = 10;\n\nconst DEFAULT_SPLINE_CONFIG = {\n  resolution: 20,\n  controlPointAdditionDistance: 6,\n  controlPointDeletionDistance: 6,\n  showControlPointsConnectors: false,\n  controlPointAdditionEnabled: true,\n  controlPointDeletionEnabled: true,\n};\n\nenum SplineTypesEnum {\n  Cardinal = 'CARDINAL',\n  Linear = 'LINEAR',\n  CatmullRom = 'CATMULLROM',\n  BSpline = 'BSPLINE',\n}\n\nenum SplineToolActions {\n  AddControlPoint = 'addControlPoint',\n  DeleteControlPoint = 'deleteControlPoint',\n}\n\nclass SplineROITool extends ContourSegmentationBaseTool {\n  static toolName;\n  static SplineTypes = SplineTypesEnum;\n  static Actions = SplineToolActions;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: SplineROIAnnotation;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    lastCanvasPoint?: Types.Point2;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        calculateStats: true,\n        getTextLines: defaultGetTextLines,\n        spline: {\n          configuration: {\n            [SplineTypesEnum.Cardinal]: {\n              Class: CardinalSpline,\n              scale: 0.5,\n            },\n            [SplineTypesEnum.CatmullRom]: {\n              Class: CatmullRomSpline,\n            },\n            [SplineTypesEnum.Linear]: {\n              Class: LinearSpline,\n            },\n            [SplineTypesEnum.BSpline]: {\n              Class: BSpline,\n              controlPointAdditionEnabled: false,\n              controlPointDeletionEnabled: false,\n              showControlPointsConnectors: true,\n            },\n          },\n          type: SplineTypesEnum.CatmullRom,\n          drawPreviewEnabled: true,\n          lastControlPointDeletionKeys: ['Backspace', 'Delete'],\n        },\n        actions: {\n          [SplineToolActions.AddControlPoint]: {\n            method: 'addControlPointCallback',\n            bindings: [\n              {\n                mouseButton: MouseBindings.Primary,\n                modifierKey: KeyboardBindings.Shift,\n              },\n            ],\n          },\n          [SplineToolActions.DeleteControlPoint]: {\n            method: 'deleteControlPointCallback',\n            bindings: [\n              {\n                mouseButton: MouseBindings.Primary,\n                modifierKey: KeyboardBindings.Ctrl,\n              },\n            ],\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation(evt: EventTypes.InteractionEventType): SplineROIAnnotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const { canvas: canvasPos } = currentPoints;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const annotation = this.createAnnotation(evt) as SplineROIAnnotation;\n\n    this.isDrawing = true;\n    this.addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n      lastCanvasPoint: canvasPos,\n    };\n\n    this._activateDraw(element);\n    evt.preventDefault();\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  }\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: SplineROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const { instance: spline } = annotation.data.spline;\n\n    return spline.isPointNearCurve(canvasCoords, proximity);\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this._activateModify(element);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      const { points } = data.handles;\n\n      handleIndex = points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  private _keyDownCallback = (evt: EventTypes.KeyDownEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const key = eventDetail.key ?? '';\n    const { lastControlPointDeletionKeys } = this.configuration.spline;\n    const deleteLastPoint = lastControlPointDeletionKeys.includes(key);\n\n    if (!deleteLastPoint) {\n      return;\n    }\n\n    const { annotation } = this.editData;\n    const { data } = annotation;\n\n    if (data.handles.points.length === SPLINE_MIN_POINTS) {\n      this.cancel(element);\n      return;\n    } else {\n      const controlPointIndex = data.handles.points.length - 1;\n      this._deleteControlPointByIndex(element, annotation, controlPointIndex);\n    }\n\n    evt.preventDefault();\n  };\n\n  private _mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\n    const { drawPreviewEnabled } = this.configuration.spline;\n\n    // Does not force a re-render if preview is not enabled\n    if (!drawPreviewEnabled) {\n      return;\n    }\n\n    const { element } = evt.detail;\n    const { renderingEngine } = getEnabledElement(element);\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData.lastCanvasPoint = evt.detail.currentPoints.canvas;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    evt.preventDefault();\n  };\n\n  private _mouseDownCallback = (evt: EventTypes.InteractionEventType): void => {\n    const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n\n    if (data.contour.closed) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const { canvas: canvasPoint, world: worldPoint } = currentPoints;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    let closeContour = data.handles.points.length >= 2 && doubleClick;\n    let addNewPoint = true;\n\n    // Check if user clicked on the first point to close the curve\n    if (data.handles.points.length >= 3) {\n      const { instance: spline } = data.spline;\n      const closestControlPoint = spline.getClosestControlPointWithinDistance(\n        canvasPoint,\n        SPLINE_CLICK_CLOSE_CURVE_DIST\n      );\n\n      if (closestControlPoint?.index === 0) {\n        addNewPoint = false;\n        closeContour = true;\n      }\n    }\n\n    if (addNewPoint) {\n      data.handles.points.push(worldPoint);\n    }\n\n    data.contour.closed = data.contour.closed || closeContour;\n    annotation.invalidated = true;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (data.contour.closed) {\n      this._endCallback(evt);\n    }\n\n    evt.preventDefault();\n  };\n\n  private _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel(element: HTMLDivElement) {\n    // If it is not in mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n    if (newAnnotation) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    super.cancelAnnotation(annotation);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData = null;\n    return annotation.annotationUID;\n  }\n\n  /**\n   * Triggers an annotation modified event.\n   */\n  triggerAnnotationModified = (\n    annotation: SplineROIAnnotation,\n    enabledElement: Types.IEnabledElement\n  ): void => {\n    const { viewportId, renderingEngineId } = enabledElement;\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n  };\n\n  private _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  private _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  private _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.KEY_DOWN, this._keyDownCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n    element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n    element.addEventListener(\n      Events.MOUSE_DOUBLE_CLICK,\n      this._mouseDownCallback\n    );\n\n    element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n  };\n\n  private _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.KEY_DOWN, this._keyDownCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n    element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n    element.removeEventListener(\n      Events.MOUSE_DOUBLE_CLICK,\n      this._mouseDownCallback\n    );\n\n    element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n  };\n\n  protected isContourSegmentationTool(): boolean {\n    // Disable contour segmenatation behavior because it shall be activated only\n    // for SplineContourSegmentationTool\n    return false;\n  }\n\n  /**\n   * Render an annotation instance\n   * @param renderContext - Render context that contains the annotation, enabledElement, etc.\n   * @returns True if the annotation is rendered or false otherwise\n   */\n  protected renderAnnotationInstance(renderContext: {\n    enabledElement: Types.IEnabledElement;\n    targetId: string;\n    annotation: Annotation;\n    annotationStyle: Record<string, any>;\n    svgDrawingHelper: SVGDrawingHelper;\n  }): boolean {\n    const { enabledElement, targetId, svgDrawingHelper, annotationStyle } =\n      renderContext;\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { element } = viewport;\n    const annotation = renderContext.annotation as SplineROIAnnotation;\n    const { annotationUID, data, highlighted } = annotation;\n    const { handles } = data;\n    const { points: controlPoints, activeHandleIndex } = handles;\n    const newAnnotation = this.editData?.newAnnotation;\n\n    const {\n      lineWidth,\n      lineDash,\n      color,\n      locked: annotationLocked,\n    } = annotationStyle;\n\n    const canvasCoordinates = controlPoints.map((p) =>\n      worldToCanvas(p)\n    ) as Types.Point2[];\n\n    const { drawPreviewEnabled } = this.configuration.spline;\n    const splineType = annotation.data.spline.type;\n    const splineConfig = this._getSplineConfig(splineType);\n    const spline = this._updateSplineInstance(element, annotation);\n    const splinePolylineCanvas = spline.getPolylinePoints();\n    const splinePolylineWorld = [];\n\n    for (let i = 0, len = splinePolylineCanvas.length; i < len; i++) {\n      splinePolylineWorld.push(viewport.canvasToWorld(splinePolylineCanvas[i]));\n    }\n\n    data.contour.polyline = splinePolylineWorld;\n\n    // Let the base class render the contour\n    super.renderAnnotationInstance(renderContext);\n\n    // If cachedStats does not exist, or the areaUnit is missing (as part of\n    // import/hydration etc.), force to recalculate the stats from the points\n    if (\n      !data.cachedStats[targetId] ||\n      data.cachedStats[targetId].areaUnit == null\n    ) {\n      data.cachedStats[targetId] = {\n        Modality: null,\n        area: null,\n        areaUnit: null,\n      };\n\n      this._calculateCachedStats(annotation, element);\n    } else if (annotation.invalidated) {\n      this._throttledCalculateCachedStats(annotation, element);\n    }\n\n    let activeHandleCanvasCoords;\n\n    if (!annotationLocked && !this.editData && activeHandleIndex !== null) {\n      // Not locked or creating and hovering over handle, so render handle.\n      activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n    }\n\n    if (activeHandleCanvasCoords || newAnnotation || highlighted) {\n      const handleGroupUID = '0';\n\n      // Move this call to the base class (contour seg) in the near future\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        canvasCoordinates,\n        {\n          color,\n          lineWidth: Math.max(1, lineWidth),\n          handleRadius: '3',\n        }\n      );\n    }\n\n    if (\n      drawPreviewEnabled &&\n      spline.numControlPoints > 1 &&\n      this.editData?.lastCanvasPoint &&\n      !spline.closed\n    ) {\n      const { lastCanvasPoint } = this.editData;\n      const previewPolylinePoints = spline.getPreviewPolylinePoints(\n        lastCanvasPoint,\n        SPLINE_CLICK_CLOSE_CURVE_DIST\n      );\n\n      drawPolylineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        'previewSplineChange',\n        previewPolylinePoints,\n        {\n          color: '#9EA0CA',\n          lineDash,\n          lineWidth: 1,\n        }\n      );\n    }\n\n    if (splineConfig.showControlPointsConnectors) {\n      const controlPointsConnectors = [...canvasCoordinates];\n\n      // Connect the last point to the first one when the spline is closed\n      if (spline.closed) {\n        controlPointsConnectors.push(canvasCoordinates[0]);\n      }\n\n      drawPolylineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        'controlPointsConnectors',\n        controlPointsConnectors,\n        {\n          color: 'rgba(255, 255, 255, 0.5)',\n          lineWidth: 1,\n        }\n      );\n    }\n\n    this._renderStats(\n      annotation,\n      viewport,\n      svgDrawingHelper,\n      annotationStyle.textbox\n    );\n\n    annotation.invalidated = false;\n    return true;\n  }\n\n  protected createAnnotation(evt: EventTypes.InteractionEventType): Annotation {\n    const contourAnnotation = super.createAnnotation(evt);\n    const { world: worldPos } = evt.detail.currentPoints;\n    const { type: splineType } = this.configuration.spline;\n    const splineConfig = this._getSplineConfig(splineType);\n    const spline = new splineConfig.Class();\n\n    return <SplineROIAnnotation>utilities.deepMerge(contourAnnotation, {\n      data: {\n        handles: {\n          points: [[...worldPos]],\n        },\n        spline: {\n          type: splineConfig.type,\n          instance: spline,\n          resolution: splineConfig.resolution,\n        },\n        cachedStats: {},\n      },\n    });\n  }\n\n  private _renderStats = (\n    annotation,\n    viewport,\n    svgDrawingHelper,\n    textboxStyle\n  ) => {\n    const data = annotation.data;\n    const targetId = this.getTargetId(viewport);\n\n    if (!data.spline.closed || !textboxStyle.visibility) {\n      return;\n    }\n\n    const textLines = this.configuration.getTextLines(data, targetId);\n    if (!textLines || textLines.length === 0) {\n      return;\n    }\n\n    const canvasCoordinates = data.handles.points.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n    if (!data.handles.textBox.hasMoved) {\n      const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n      data.handles.textBox.worldPosition =\n        viewport.canvasToWorld(canvasTextBoxCoords);\n    }\n\n    const textBoxPosition = viewport.worldToCanvas(\n      data.handles.textBox.worldPosition\n    );\n\n    const textBoxUID = 'textBox';\n    const boundingBox = drawLinkedTextBoxSvg(\n      svgDrawingHelper,\n      annotation.annotationUID ?? '',\n      textBoxUID,\n      textLines,\n      textBoxPosition,\n      canvasCoordinates,\n      {},\n      textboxStyle\n    );\n\n    const { x: left, y: top, width, height } = boundingBox;\n\n    data.handles.textBox.worldBoundingBox = {\n      topLeft: viewport.canvasToWorld([left, top]),\n      topRight: viewport.canvasToWorld([left + width, top]),\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\n    };\n  };\n\n  addControlPointCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation\n  ) => {\n    const { data } = annotation;\n    const splineType = data.spline.type;\n    const splineConfig = this._getSplineConfig(splineType);\n    const maxDist = splineConfig.controlPointAdditionDistance;\n\n    if (splineConfig.controlPointAdditionEnabled === false) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    const { instance: spline } = data.spline;\n    const canvasPos = evt.detail.currentPoints.canvas;\n    const closestPointInfo = spline.getClosestPoint(canvasPos);\n\n    if (closestPointInfo.distance > maxDist) {\n      return;\n    }\n\n    // Add a point at the `u` position from Parameter Space\n    const { index, point: canvasPoint } = spline.addControlPointAtU(\n      closestPointInfo.uValue\n    );\n\n    data.handles.points.splice(index, 0, canvasToWorld(canvasPoint));\n    annotation.invalidated = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  private _deleteControlPointByIndex(\n    element: HTMLDivElement,\n    annotation: SplineROIAnnotation,\n    controlPointIndex: number\n  ) {\n    const enabledElement = getEnabledElement(element);\n    const { points: controlPoints } = annotation.data.handles;\n\n    // There is no curve with only 2 points\n    if (controlPoints.length === 3) {\n      removeAnnotation(annotation.annotationUID);\n    } else {\n      controlPoints.splice(controlPointIndex, 1);\n    }\n\n    const { renderingEngine } = enabledElement;\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    annotation.invalidated = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  }\n\n  deleteControlPointCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation\n  ) => {\n    const splineType = annotation.data.spline.type;\n    const splineConfig = this._getSplineConfig(splineType);\n    const maxDist = splineConfig.controlPointDeletionDistance;\n\n    if (splineConfig.controlPointDeletionEnabled === false) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { element, currentPoints } = eventDetail;\n    const { canvas: canvasPos } = currentPoints;\n    const { instance: spline } = annotation.data.spline;\n    const closestControlPoint = spline.getClosestControlPointWithinDistance(\n      canvasPos,\n      maxDist\n    );\n\n    if (!closestControlPoint) {\n      return;\n    }\n\n    this._deleteControlPointByIndex(\n      element,\n      annotation,\n      closestControlPoint.index\n    );\n  };\n\n  /**\n   * Get a spline config merged with the default settings.\n   * @param type - Spline type (CARDINAL, CATMULLROM, LINEAR or BSPLINE)\n   * @returns Spline configuration\n   */\n  private _getSplineConfig(type: string) {\n    const { configuration: config } = this;\n    const splineConfigs = config.spline.configuration;\n\n    return Object.assign({ type }, DEFAULT_SPLINE_CONFIG, splineConfigs[type]);\n  }\n\n  private _updateSplineInstance(\n    element: HTMLDivElement,\n    annotation: SplineROIAnnotation\n  ): ISpline {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { data } = annotation;\n    const { type: splineType, instance: spline } = annotation.data.spline;\n    const splineConfig = this._getSplineConfig(splineType);\n    const worldPoints = data.handles.points;\n    const canvasPoints = worldPoints.map(worldToCanvas);\n\n    spline.setControlPoints(canvasPoints);\n    spline.closed = !!data.contour.closed;\n\n    // Update spline resolution in case it has changed\n    if (spline.resolution !== splineConfig.resolution) {\n      spline.resolution = parseInt(splineConfig.resolution);\n      annotation.invalidated = true;\n    }\n\n    // Update Cardinal spline scale in case it has changed\n    if (\n      spline instanceof CardinalSpline &&\n      !spline.fixedScale &&\n      splineConfig.scale !== undefined &&\n      spline.scale !== splineConfig.scale\n    ) {\n      spline.scale = splineConfig.scale;\n      annotation.invalidated = true;\n    }\n\n    return spline;\n  }\n\n  private _calculateCachedStats = (\n    annotation: SplineROIAnnotation,\n    element: HTMLDivElement\n  ) => {\n    if (!this.configuration.calculateStats) {\n      return;\n    }\n    const data = annotation.data;\n\n    if (!data.contour.closed) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { cachedStats } = data;\n    const { polyline: points } = data.contour;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { metadata } = image;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // Using an arbitrary start point (canvasPoint), calculate the\n      // mm spacing for the canvas in the X and Y directions.\n      const canvasPoint = canvasCoordinates[0];\n      const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n      const deltaXPoint = viewport.canvasToWorld([\n        canvasPoint[0] + 1,\n        canvasPoint[1],\n      ]);\n      const deltaYPoint = viewport.canvasToWorld([\n        canvasPoint[0],\n        canvasPoint[1] + 1,\n      ]);\n\n      const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n      const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n\n      const scale = getCalibratedScale(image);\n      let area =\n        math.polyline.calculateAreaOfPoints(canvasCoordinates) / scale / scale;\n\n      // Convert from canvas_pixels ^2 to mm^2\n      area *= deltaInX * deltaInY;\n\n      cachedStats[targetId] = {\n        Modality: metadata.Modality,\n        area,\n        areaUnit: getCalibratedAreaUnits(null, image),\n      };\n    }\n\n    this.triggerAnnotationModified(annotation, enabledElement);\n\n    return cachedStats;\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, isEmptyArea, areaUnit } = cachedVolumeStats;\n  const textLines: string[] = [];\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n\n    textLines.push(areaLine);\n  }\n\n  return textLines;\n}\n\nSplineROITool.toolName = 'SplineROI';\nexport default SplineROITool;\n","import { utilities } from '@cornerstonejs/core';\nimport { PublicToolProps } from '../../types';\nimport SplineROITool from './SplineROITool';\n\nclass SplineContourSegmentationTool extends SplineROITool {\n  static toolName;\n\n  constructor(toolProps: PublicToolProps) {\n    const initialProps = utilities.deepMerge(\n      {\n        configuration: {\n          calculateStats: false,\n        },\n      },\n      toolProps\n    );\n\n    super(initialProps);\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Re-enable contour segmentation behavior disabled by SplineROITool\n    return true;\n  }\n}\n\nSplineContourSegmentationTool.toolName = 'SplineContourSegmentationTool';\nexport default SplineContourSegmentationTool;\n","import { utilities } from '@cornerstonejs/core';\nimport { PublicToolProps } from '../../types';\nimport PlanarFreehandROITool from './PlanarFreehandROITool';\n\nclass PlanarFreehandContourSegmentationTool extends PlanarFreehandROITool {\n  static toolName;\n\n  constructor(toolProps: PublicToolProps) {\n    const initialProps = utilities.deepMerge(\n      {\n        configuration: {\n          calculateStats: false,\n        },\n      },\n      toolProps\n    );\n\n    super(initialProps);\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Re-enable contour segmentation behavior disabled by PlanarFreehandROITool\n    return true;\n  }\n}\n\nPlanarFreehandContourSegmentationTool.toolName =\n  'PlanarFreehandContourSegmentationTool';\n\nexport default PlanarFreehandContourSegmentationTool;\n","type BucketNode<T> = {\n  value: T;\n  next: BucketNode<T>;\n};\n\n/**\n * Circular Bucket Queue.\n *\n * Returns input'd points in sorted order. All operations run in roughly O(1)\n * time (for input with small cost values), but it has a strict requirement:\n *\n * If the most recent point had a cost of c, any points added should have a cost\n * c' in the range c <= c' <= c + (capacity - 1).\n */\nexport class BucketQueue<T> {\n  private _bucketCount: number;\n  private _mask: number;\n  private _size: number;\n  private _currentBucketIndex: number;\n  private _getPriority: (item: T) => number;\n  private _areEqual: (itemA: T, itemB: T) => boolean;\n  private _buckets: BucketNode<T>[];\n\n  /**\n   * @param bits - Number of bits.\n   * @param getPriority - A function that returns the priority of an item\n   */\n  constructor({\n    numBits,\n    getPriority,\n    areEqual,\n  }: {\n    numBits: number;\n    getPriority?: (item: T) => number;\n    areEqual?: (itemA: T, itemB: T) => boolean;\n  }) {\n    this._bucketCount = 1 << numBits; // # of buckets = 2^numBits\n    this._mask = this._bucketCount - 1; // 2^numBits - 1 = index mask\n    this._size = 0;\n    this._currentBucketIndex = 0;\n    this._buckets = this._buildArray(this._bucketCount);\n\n    this._getPriority =\n      typeof getPriority !== 'undefined'\n        ? getPriority\n        : (item) => item as unknown as number;\n\n    this._areEqual =\n      typeof areEqual === 'function'\n        ? areEqual\n        : (itemA, itemB) => itemA === itemB;\n  }\n\n  /**\n   * Prepend item to the list in the appropriate bucket\n   * @param item - Item to be added to the queue based on its priority\n   */\n  public push(item: T) {\n    const bucketIndex = this._getBucketIndex(item);\n    const oldHead = this._buckets[bucketIndex];\n    const newHead: BucketNode<T> = {\n      value: item,\n      next: oldHead,\n    };\n\n    this._buckets[bucketIndex] = newHead;\n    this._size++;\n  }\n\n  public pop(): T {\n    if (this._size === 0) {\n      throw new Error('Cannot pop because the queue is empty.');\n    }\n\n    // Find first empty bucket\n    while (this._buckets[this._currentBucketIndex] === null) {\n      this._currentBucketIndex =\n        (this._currentBucketIndex + 1) % this._bucketCount;\n    }\n\n    // All items in bucket have same cost, return the first one\n    const ret = this._buckets[this._currentBucketIndex];\n\n    this._buckets[this._currentBucketIndex] = ret.next;\n    this._size--;\n\n    return ret.value;\n  }\n\n  /**\n   * Tries to remove item from queue.\n   * @param item - Item to be removed from the queue\n   * @returns True if the item is found and removed or false otherwise\n   */\n  public remove(item: T): boolean {\n    if (!item) {\n      return false;\n    }\n\n    // To find node, go to bucket and search through unsorted list.\n    const bucketIndex = this._getBucketIndex(item);\n    const firstBucketNode = this._buckets[bucketIndex];\n    let node = firstBucketNode;\n    let prevNode: BucketNode<T>;\n\n    while (node !== null) {\n      if (this._areEqual(item, node.value)) {\n        break;\n      }\n\n      prevNode = node;\n      node = node.next;\n    }\n\n    // Item not found\n    if (node === null) {\n      return false;\n    }\n\n    // Item found and it needs to be removed from the list\n    if (node === firstBucketNode) {\n      this._buckets[bucketIndex] = node.next;\n    } else {\n      prevNode.next = node.next;\n    }\n\n    this._size--;\n    return true;\n  }\n\n  public isEmpty(): boolean {\n    return this._size === 0;\n  }\n\n  /**\n   * Return the bucket index\n   * @param item - Item for which the bucket shall be returned\n   * @returns Bucket index for the item provided\n   */\n  private _getBucketIndex(item): number {\n    return this._getPriority(item) & this._mask;\n  }\n\n  /**\n   * Create array and initialze pointers to null\n   * @param size - Size of the new array\n   * @returns An array with `N` buckets pointing to null\n   */\n  private _buildArray(size) {\n    const buckets = new Array(size);\n    buckets.fill(null);\n    return buckets;\n  }\n}\n","import { Types } from '@cornerstonejs/core';\nimport { BucketQueue } from '../BucketQueue';\n\nconst MAX_UINT32 = 4294967295;\nconst TWO_THIRD_PI = 2 / (3 * Math.PI);\n\n/**\n * Scissors\n *\n * Ref: Eric N. Mortensen, William A. Barrett, Interactive Segmentation with\n *   Intelligent Scissors, Graphical Models and Image Processing, Volume 60,\n *   Issue 5, September 1998, Pages 349-384, ISSN 1077-3169,\n *   DOI: 10.1006/gmip.1998.0480.\n *\n * {@link http://www.sciencedirect.com/science/article/B6WG4-45JB8WN-9/2/6fe59d8089fd1892c2bfb82283065579}\n *\n * Implementation based on\n * {@link http://code.google.com/p/livewire-javascript/}\n */\nexport class LivewireScissors {\n  private searchGranularityBits: number;\n  private searchGranularity: number;\n\n  /** Width of the image */\n  public readonly width: number;\n\n  /** Height of the image */\n  public readonly height: number;\n\n  /** Grayscale image */\n  private grayscalePixelData: Float32Array;\n\n  // Laplace zero-crossings (either 0 or 1).\n  private laplace: Float32Array;\n\n  /** Gradient vector magnitude for each pixel */\n  private gradMagnitude: Float32Array;\n\n  /** Gradient of each pixel in the x-direction */\n  private gradXNew: Float32Array;\n\n  /** Gradient of each pixel in the y-direction */\n  private gradYNew: Float32Array;\n\n  /** Dijkstra - start point */\n  private startPoint: Types.Point2;\n\n  /** Dijkstra - store the state of a pixel (visited/unvisited) */\n  private visited: boolean[];\n\n  /** Dijkstra - map a point to its parent along the shortest path to root (start point) */\n  private parents: Uint32Array;\n\n  /** Dijkstra - store the cost to go from the start point to each node */\n  private costs: Float32Array;\n\n  /** Dijkstra - BucketQueue to sort items by priority */\n  private priorityQueueNew: BucketQueue<number>;\n\n  constructor(grayscalePixelData: Float32Array, width: number, height: number) {\n    const numPixels = grayscalePixelData.length;\n\n    this.searchGranularityBits = 8; // Bits of resolution for BucketQueue.\n    this.searchGranularity = 1 << this.searchGranularityBits; //bits.\n\n    this.width = width;\n    this.height = height;\n\n    this.grayscalePixelData = grayscalePixelData;\n    this.laplace = null;\n    this.gradXNew = null;\n    this.gradYNew = null;\n\n    this.laplace = this._computeLaplace();\n    this.gradMagnitude = this._computeGradient();\n    this.gradXNew = this._computeGradientX();\n    this.gradYNew = this._computeGradientY();\n\n    this.visited = new Array(numPixels);\n    this.parents = new Uint32Array(numPixels);\n    this.costs = new Float32Array(numPixels);\n  }\n\n  public startSearch(startPoint: Types.Point2): void {\n    const startPointIndex = this._getPointIndex(startPoint[1], startPoint[0]);\n\n    this.startPoint = null;\n    this.visited.fill(false);\n    this.parents.fill(MAX_UINT32);\n    this.costs.fill(Infinity);\n    this.priorityQueueNew = new BucketQueue<number>({\n      numBits: this.searchGranularityBits,\n      getPriority: this._getPointCost,\n    });\n\n    this.startPoint = startPoint;\n    this.costs[startPointIndex] = 0;\n    this.priorityQueueNew.push(startPointIndex);\n  }\n\n  /**\n   * Runs Dijsktra until it finds a path from the start point to the target\n   * point. Once it reaches the target point all the state is preserved in order\n   * to save processing time the next time the method is called for a new target\n   * point. The search is restarted whenever `startSearch` is called.\n   * @param targetPoint - Target point\n   * @returns An array with all points for the shortest path found that goes\n   * from startPoint to targetPoint.\n   */\n  public findPathToPoint(targetPoint: Types.Point2): Types.Point2[] {\n    if (!this.startPoint) {\n      throw new Error('There is no search in progress');\n    }\n\n    const {\n      startPoint,\n      _getPointIndex: index,\n      _getPointCoordinate: coord,\n    } = this;\n    const startPointIndex = index(startPoint[1], startPoint[0]);\n    const targetPointIndex = index(targetPoint[1], targetPoint[0]);\n    const {\n      visited: visited,\n      parents: parents,\n      costs: cost,\n      priorityQueueNew: priorityQueue,\n    } = this;\n\n    if (targetPointIndex === startPointIndex) {\n      return [];\n    }\n\n    // Stop searching until there are no more items in the queue or it has\n    // reached the target point. In case it reaches the target all the remaining\n    // items will stay in the queue then once the user moves the mouse to a new\n    // location the search can continue from where it left off.\n    while (\n      !priorityQueue.isEmpty() &&\n      parents[targetPointIndex] === MAX_UINT32\n    ) {\n      const pointIndex = priorityQueue.pop();\n\n      if (visited[pointIndex]) {\n        continue;\n      }\n\n      const point = coord(pointIndex);\n      const neighborsPoints = this._getNeighborPoints(point);\n\n      visited[pointIndex] = true;\n\n      // Update the cost of all neighbors that have higher costs\n      for (let i = 0, len = neighborsPoints.length; i < len; i++) {\n        const neighborPoint = neighborsPoints[i];\n        const neighbordPointIndex = index(neighborPoint[1], neighborPoint[0]);\n        const dist = this._getWeightedDistance(point, neighborPoint);\n        const neighborCost = cost[pointIndex] + dist;\n\n        if (neighborCost < cost[neighbordPointIndex]) {\n          if (cost[neighbordPointIndex] !== Infinity) {\n            // The item needs to be removed from the priority queue and\n            // re-added in order to be moved to the right bucket.\n            priorityQueue.remove(neighbordPointIndex);\n          }\n\n          cost[neighbordPointIndex] = neighborCost;\n          parents[neighbordPointIndex] = pointIndex;\n          priorityQueue.push(neighbordPointIndex);\n        }\n      }\n    }\n\n    const pathPoints = [];\n    let pathPointIndex = targetPointIndex;\n\n    while (pathPointIndex !== MAX_UINT32) {\n      pathPoints.push(coord(pathPointIndex));\n      pathPointIndex = parents[pathPointIndex];\n    }\n\n    return pathPoints.reverse();\n  }\n\n  /**\n   * Convert a point coordinate (x,y) into a point index\n   * @param index - Point index\n   * @returns Point coordinate (x,y)\n   */\n  private _getPointIndex = (row: number, col: number) => {\n    const { width } = this;\n    return row * width + col;\n  };\n\n  /**\n   * Convert a point index into a point coordinate (x,y)\n   * @param index - Point index\n   * @returns Point coordinate (x,y)\n   */\n  private _getPointCoordinate = (index: number): Types.Point2 => {\n    const x = index % this.width;\n    const y = Math.floor(index / this.width);\n\n    return [x, y];\n  };\n\n  /**\n   * Calculate the delta X between a given point and its neighbor at the right\n   * @param x - Point x-coordinate\n   * @param y - Point y-coordinate\n   * @returns Delta Y between the given point and its neighbor at the right\n   */\n  private _getDeltaX(x: number, y: number) {\n    const { grayscalePixelData: data, width } = this;\n    let index = this._getPointIndex(y, x);\n\n    // If it is at the end, back up one\n    if (x + 1 === width) {\n      index--;\n    }\n\n    return data[index + 1] - data[index];\n  }\n\n  /**\n   * Calculate the delta Y between a given point and its neighbor at the bottom\n   * @param x - Point x-coordinate\n   * @param y - Point y-coordinate\n   * @returns Delta Y between the given point and its neighbor at the bottom\n   */\n  private _getDeltaY(x: number, y: number) {\n    const { grayscalePixelData: data, width, height } = this;\n    let index = this._getPointIndex(y, x);\n\n    // If it is at the end, back up one\n    if (y + 1 === height) {\n      index -= height;\n    }\n\n    return data[index] - data[index + width];\n  }\n\n  private _getGradientMagnitude(x: number, y: number): number {\n    const dx = this._getDeltaX(x, y);\n    const dy = this._getDeltaY(x, y);\n\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  /**\n   *  Calculate the Laplacian of Gaussian (LoG) value for a given pixel\n   *\n   *     Kernel Indexes           Laplacian of Gaussian Kernel\n   *   __  __  02  __  __              0   0   1   0   0\n   *   __  11  12  13  __              0   1   2   1   0\n   *   20  21  22  23  24              1   2 -16   2   1\n   *   __  31  32  33  __              0   1   2   1   0\n   *   __  __  42  __  __              0   0   1   0   0\n   */\n  private _getLaplace(x: number, y: number): number {\n    const { grayscalePixelData: data, _getPointIndex: index } = this;\n\n    // Points related to the kernel indexes\n    const p02 = data[index(y - 2, x)];\n    const p11 = data[index(y - 1, x - 1)];\n    const p12 = data[index(y - 1, x)];\n    const p13 = data[index(y - 1, x + 1)];\n    const p20 = data[index(y, x - 2)];\n    const p21 = data[index(y, x - 1)];\n    const p22 = data[index(y, x)];\n    const p23 = data[index(y, x + 1)];\n    const p24 = data[index(y, x + 2)];\n    const p31 = data[index(y + 1, x - 1)];\n    const p32 = data[index(y + 1, x)];\n    const p33 = data[index(y + 1, x + 1)];\n    const p42 = data[index(y + 2, x)];\n\n    // Laplacian of Gaussian\n    let lap = p02;\n    lap += p11 + 2 * p12 + p13;\n    lap += p20 + 2 * p21 - 16 * p22 + 2 * p23 + p24;\n    lap += p31 + 2 * p32 + p33;\n    lap += p42;\n\n    return lap;\n  }\n\n  /**\n   * Returns a 2D array of gradient magnitude values for grayscale. The values\n   * are scaled between 0 and 1, and then flipped, so that it works as a cost\n   * function.\n   * @returns A gradient object\n   */\n  private _computeGradient(): Float32Array {\n    const { width, height } = this;\n    const gradient = new Float32Array(width * height);\n\n    let pixelIndex = 0;\n    let max = 0;\n    let x = 0;\n    let y = 0;\n\n    for (y = 0; y < height - 1; y++) {\n      for (x = 0; x < width - 1; x++) {\n        gradient[pixelIndex] = this._getGradientMagnitude(x, y);\n        max = Math.max(gradient[pixelIndex], max);\n        pixelIndex++;\n      }\n\n      // Make the last column the same as the previous one because there is\n      // no way to calculate `dx` since x+1 gets out of bounds\n      gradient[pixelIndex] = gradient[pixelIndex - 1];\n      pixelIndex++;\n    }\n\n    // Make the last row the same as the previous one because there is\n    // no way to calculate `dy` since y+1 gets out of bounds\n    for (let len = gradient.length; pixelIndex < len; pixelIndex++) {\n      gradient[pixelIndex] = gradient[pixelIndex - width];\n    }\n\n    // Flip and scale\n    for (let i = 0, len = gradient.length; i < len; i++) {\n      gradient[i] = 1 - gradient[i] / max;\n    }\n\n    return gradient;\n  }\n\n  /**\n   * Returns a 2D array of Laplacian of Gaussian values\n   *\n   * @param grayscale - The input grayscale\n   * @returns A laplace object\n   */\n  private _computeLaplace(): Float32Array {\n    const { width, height, _getPointIndex: index } = this;\n    const laplace = new Float32Array(width * height);\n\n    // Make the first two rows low cost\n    laplace.fill(1, 0, index(2, 0));\n\n    for (let y = 2; y < height - 2; y++) {\n      // Make the first two columns low cost\n      laplace[index(y, 0)] = 1;\n      laplace[index(y, 1)] = 1;\n\n      for (let x = 2; x < width - 2; x++) {\n        // Threshold needed to get rid of clutter.\n        laplace[index(y, x)] = this._getLaplace(x, y) > 0.33 ? 0 : 1;\n      }\n\n      // Make the last two columns low cost\n      laplace[index(y, width - 2)] = 1;\n      laplace[index(y, width - 1)] = 1;\n    }\n\n    // Make the last two rows low cost\n    laplace.fill(1, index(height - 2, 0));\n\n    return laplace;\n  }\n\n  /**\n   * Returns 2D array of x-gradient values for grayscale\n   *\n   * @param grayscale - Grayscale pixel data\n   * @returns 2D x-gradient array\n   */\n  private _computeGradientX(): Float32Array {\n    const { width, height } = this;\n    const gradX = new Float32Array(width * height);\n    let pixelIndex = 0;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width - 1; x++) {\n        gradX[pixelIndex++] = this._getDeltaX(x, y);\n      }\n\n      // Make the last column the same as the previous one because there is\n      // no way to calculate `dx` since x+1 gets out of bounds\n      gradX[pixelIndex] = gradX[pixelIndex - 1];\n      pixelIndex++;\n    }\n\n    return gradX;\n  }\n\n  /**\n   * Compute the Y gradient.\n   *\n   * @param grayscale - Grayscale pixel data\n   * @returns 2D array of y-gradient values for grayscale\n   */\n  private _computeGradientY(): Float32Array {\n    const { width, height } = this;\n    const gradY = new Float32Array(width * height);\n    let pixelIndex = 0;\n\n    for (let y = 0; y < height - 1; y++) {\n      for (let x = 0; x < width; x++) {\n        gradY[pixelIndex++] = this._getDeltaY(x, y);\n      }\n    }\n\n    // Make the last row the same as the previous one because there is\n    // no way to calculate `dy` since y+1 gets out of bounds\n    for (let len = gradY.length; pixelIndex < len; pixelIndex++) {\n      gradY[pixelIndex] = gradY[pixelIndex - width];\n    }\n\n    return gradY;\n  }\n\n  /**\n   * Compute the gradient unit vector.\n   * @param px - Point x-coordinate\n   * @param py - Point y-coordinate\n   * @returns Gradient vector at (px, py), scaled to a magnitude of 1\n   */\n  private _getGradientUnitVector(px: number, py: number) {\n    const { gradXNew, gradYNew, _getPointIndex: index } = this;\n\n    const pointGradX = gradXNew[index(py, px)];\n    const pointGradY = gradYNew[index(py, px)];\n    let gradVecLen = Math.sqrt(\n      pointGradX * pointGradX + pointGradY * pointGradY\n    );\n\n    // To avoid possible divide-by-0 errors\n    gradVecLen = Math.max(gradVecLen, 1e-100);\n\n    return [pointGradX / gradVecLen, pointGradY / gradVecLen];\n  }\n\n  /**\n   * Compute the gradiant direction, in radians, between to points\n   *\n   * @param px - Point `p` x-coordinate of point p.\n   * @param py - Point `p` y-coordinate of point p.\n   * @param qx - Point `q` x-coordinate of point q.\n   * @param qy - Point `q` y-coordinate of point q.\n   * @returns Gradient direction\n   */\n  private _getGradientDirection(\n    px: number,\n    py: number,\n    qx: number,\n    qy: number\n  ): number {\n    const dgpUnitVec = this._getGradientUnitVector(px, py);\n    const gdqUnitVec = this._getGradientUnitVector(qx, qy);\n\n    let dp = dgpUnitVec[1] * (qx - px) - dgpUnitVec[0] * (qy - py);\n    let dq = gdqUnitVec[1] * (qx - px) - gdqUnitVec[0] * (qy - py);\n\n    // Make sure dp is positive, to keep things consistent\n    if (dp < 0) {\n      dp = -dp;\n      dq = -dq;\n    }\n\n    if (px !== qx && py !== qy) {\n      // It's going diagonally between pixels\n      dp *= Math.SQRT1_2;\n      dq *= Math.SQRT1_2;\n    }\n\n    return TWO_THIRD_PI * (Math.acos(dp) + Math.acos(dq));\n  }\n\n  /**\n   * Return a weighted distance between two points\n   */\n  private _getWeightedDistance(pointA: Types.Point2, pointB: Types.Point2) {\n    const { _getPointIndex: index } = this;\n    const [aX, aY] = pointA;\n    const [bX, bY] = pointB;\n    const bIndex = index(bY, bX);\n\n    // Weighted distance function\n    let gradient = this.gradMagnitude[bIndex];\n\n    if (aX === bX || aY === bY) {\n      // The distance is Euclidean-ish; non-diagonal edges should be shorter\n      gradient *= Math.SQRT1_2;\n    }\n\n    const laplace = this.laplace[bIndex];\n    const direction = this._getGradientDirection(aX, aY, bX, bY);\n\n    return 0.43 * gradient + 0.43 * laplace + 0.11 * direction;\n  }\n\n  /**\n   * Get up to 8 neighbors points\n   * @param point - Reference point\n   * @returns Up to eight neighbor points\n   */\n  private _getNeighborPoints(point: Types.Point2): Types.Point2[] {\n    const { width, height } = this;\n    const list: Types.Point2[] = [];\n\n    const sx = Math.max(point[0] - 1, 0);\n    const sy = Math.max(point[1] - 1, 0);\n    const ex = Math.min(point[0] + 1, width - 1);\n    const ey = Math.min(point[1] + 1, height - 1);\n\n    for (let y = sy; y <= ey; y++) {\n      for (let x = sx; x <= ex; x++) {\n        if (x !== point[0] || y !== point[1]) {\n          list.push([x, y]);\n        }\n      }\n    }\n\n    return list;\n  }\n\n  private _getPointCost = (pointIndex: number): number => {\n    return Math.round(this.searchGranularity * this.costs[pointIndex]);\n  };\n\n  /**\n   * Create a livewire scissor instance from RAW pixel data\n   * @param pixelData - Raw pixel data\n   * @param width - Width of the image\n   * @param height - Height of the image\n   * @param voiRange - VOI Range\n   * @returns A LivewireScissors instance\n   */\n  public static createInstanceFromRawPixelData(\n    pixelData: Float32Array,\n    width: number,\n    height: number,\n    voiRange: Types.VOIRange\n  ) {\n    const numPixels = pixelData.length;\n    const grayscalePixelData = new Float32Array(numPixels);\n    const { lower: minPixelValue, upper: maxPixelValue } = voiRange;\n    const pixelRange = maxPixelValue - minPixelValue;\n\n    for (let i = 0, len = pixelData.length; i < len; i++) {\n      // Grayscale values must be between 0 and 1\n      grayscalePixelData[i] = Math.max(\n        0,\n        Math.min(1, (pixelData[i] - minPixelValue) / pixelRange)\n      );\n    }\n\n    return new LivewireScissors(grayscalePixelData, width, height);\n  }\n\n  /**\n   * Create a livewire scissor instance from a RGBA image\n   * @param rgbaPixelData - RGBA pixel data\n   * @param width - Width of the image\n   * @param height - Height of the image\n   * @returns A LivewireScissors instance\n   */\n  public static createInstanceFromRGBAPixelData(\n    rgbaPixelData: Uint8ClampedArray,\n    width: number,\n    height: number\n  ): LivewireScissors {\n    const numPixels = rgbaPixelData.length / 4;\n    const grayscalePixelData = new Float32Array(numPixels);\n\n    // Multiplier to average an RGB sum and convert it to 0-1 range.\n    // 1/x because multiplication is faster than division.\n    const avgMultiplier = 1 / (3 * 255);\n\n    for (let i = 0, offset = 0; i < numPixels; i++, offset += 4) {\n      const red = rgbaPixelData[offset];\n      const green = rgbaPixelData[offset];\n      const blue = rgbaPixelData[offset];\n\n      grayscalePixelData[i] = (red + green + blue) * avgMultiplier;\n    }\n\n    return new LivewireScissors(grayscalePixelData, width, height);\n  }\n}\n","import { Types } from '@cornerstonejs/core';\n/**\n * Path that contains points and control points to draw a path\n * used by the livewire tool\n */\nexport class LivewirePath {\n  /**\n   * List of points.\n   */\n  public pointArray: Types.Point2[];\n\n  /**\n   * List of control points indexes\n   */\n  private _controlPointIndexes: number[];\n\n  /**\n   * @param inputPointArray - The list of Point2D that make the path (optional).\n   * @param inputControlPointIndexArray - The list of control point of path, as indexes (optional).\n   *   Note: first and last point do not need to be equal.\n   */\n  constructor(\n    inputPointArray?: Types.Point2[],\n    inputControlPointIndexArray?: number[]\n  ) {\n    this.pointArray = inputPointArray ? inputPointArray.slice() : [];\n    this._controlPointIndexes = inputControlPointIndexArray\n      ? inputControlPointIndexArray.slice()\n      : [];\n  }\n\n  /**\n   * Get a point of the list.\n   *\n   * @param index - The index of the point to get\n   * @returns The Point2D at the given index.\n   */\n  public getPoint(index: number): Types.Point2 {\n    return this.pointArray[index];\n  }\n\n  /**\n   * Get the last point of the list.\n   *\n   * @returns The last point of the list.\n   */\n  public getLastPoint(): Types.Point2 {\n    return this.pointArray[this.pointArray.length - 1];\n  }\n\n  /**\n   * Is the given point a control point.\n   *\n   * @param point - The 2D point to check.\n   * @returns True if a control point, false otherwise.\n   */\n  public isControlPoint(point: Types.Point2): boolean {\n    const index = this.pointArray.indexOf(point);\n    if (index !== -1) {\n      return this._controlPointIndexes.indexOf(index) !== -1;\n    } else {\n      throw new Error('Error: isControlPoint called with not in list point.');\n    }\n  }\n\n  /**\n   * Add a point to the path.\n   *\n   * @param point - The 2D point to add.\n   */\n  public addPoint(point: Types.Point2) {\n    this.pointArray.push(point);\n  }\n\n  /**\n   * Add a control point to the path.\n   *\n   * @param point - The 2D point to make a control point.\n   */\n  public addControlPoint(point: Types.Point2) {\n    const index = this.pointArray.indexOf(point);\n\n    if (index !== -1) {\n      this._controlPointIndexes.push(index);\n    } else {\n      throw new Error('Cannot mark a non registered point as control point.');\n    }\n  }\n\n  public getControlPoints() {\n    return this._controlPointIndexes.map((i) => this.pointArray[i]);\n  }\n\n  public getNumControlPoints(): number {\n    return this._controlPointIndexes.length;\n  }\n\n  public removeLastControlPoint(): void {\n    if (this._controlPointIndexes.length) {\n      this._controlPointIndexes.pop();\n    }\n  }\n\n  /**\n   * Add points to the path.\n   *\n   * @param newPointArray - The list of 2D points to add.\n   */\n  public addPoints(newPointArray: Types.Point2[]) {\n    this.pointArray = this.pointArray.concat(newPointArray);\n  }\n\n  /**\n   * Prepend a path to this one.\n   *\n   * @param other - The path to append.\n   */\n  public prependPath(other: LivewirePath): void {\n    const otherSize = other.pointArray.length;\n    const shiftedIndexArray: number[] = [];\n\n    this.pointArray = other.pointArray.concat(this.pointArray);\n\n    for (let i = 0; i < this._controlPointIndexes.length; ++i) {\n      shiftedIndexArray[i] = this._controlPointIndexes[i] + otherSize;\n    }\n\n    this._controlPointIndexes =\n      other._controlPointIndexes.concat(shiftedIndexArray);\n  }\n}\n","import { vec3 } from 'gl-matrix';\n\nimport {\n  getEnabledElement,\n  eventTarget,\n  triggerEvent,\n  utilities as csUtils,\n  StackViewport,\n  VolumeViewport,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { removeAnnotation } from '../../stateManagement/annotation/annotationState';\nimport { drawHandles as drawHandlesSvg } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { resetElementCursor } from '../../cursors/elementCursor';\nimport {\n  Annotation,\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { math, triggerAnnotationRenderForViewportIds } from '../../utilities';\nimport { LivewireContourAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport { LivewireScissors } from '../../utilities/livewire/LivewireScissors';\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\n\nconst CLICK_CLOSE_CURVE_SQR_DIST = 10 ** 2; // px\n\nclass LivewireContourTool extends ContourSegmentationBaseTool {\n  public static toolName: string;\n  private scissors: LivewireScissors;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: LivewireContourAnnotation;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    lastCanvasPoint?: Types.Point2;\n    confirmedPath?: LivewirePath;\n    currentPath?: LivewirePath;\n    closed?: boolean;\n    worldToSlice?: (point: Types.Point3) => Types.Point2;\n    sliceToWorld?: (point: Types.Point2) => Types.Point3;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation(\n    evt: EventTypes.InteractionEventType\n  ): LivewireContourAnnotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const { world: worldPos, canvas: canvasPos } = currentPoints;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const defaultActor = viewport.getDefaultActor();\n\n    if (!defaultActor || !csUtils.isImageActor(defaultActor)) {\n      throw new Error('Default actor must be an image actor');\n    }\n\n    const viewportImageData = viewport.getImageData();\n    const { imageData: vtkImageData } = viewportImageData;\n    let worldToSlice: (point: Types.Point3) => Types.Point2;\n    let sliceToWorld: (point: Types.Point2) => Types.Point3;\n    let scalarData;\n    let width;\n    let height;\n\n    if (viewport instanceof StackViewport) {\n      scalarData = viewportImageData.scalarData;\n      width = viewportImageData.dimensions[0];\n      height = viewportImageData.dimensions[1];\n\n      // Method only to simplify the code making stack and volume viewports code\n      // similar and avoiding `if(stack)/else` whenever a coordinate needs to be\n      // transformed because `worldToSlice` in this case returns the same IJK\n      // coordinate from index space.\n      worldToSlice = (point: Types.Point3) => {\n        const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n        return [ijkPoint[0], ijkPoint[1]];\n      };\n\n      // Method only to simplify the code making stack and volume viewports code\n      // similar and avoiding `if(stack)/else` whenever a coordinate needs to be\n      // transformed because `sliceToWorld` in this case receives the same IJK\n      // coordinate from index space.\n      sliceToWorld = (point: Types.Point2) =>\n        csUtils.transformIndexToWorld(vtkImageData, [point[0], point[1], 0]);\n    } else if (viewport instanceof VolumeViewport) {\n      const sliceImageData = csUtils.getCurrentVolumeViewportSlice(viewport);\n      const { sliceToIndexMatrix, indexToSliceMatrix } = sliceImageData;\n\n      worldToSlice = (point: Types.Point3) => {\n        const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n        const slicePoint = vec3.transformMat4(\n          [0, 0, 0],\n          ijkPoint,\n          indexToSliceMatrix\n        );\n\n        return [slicePoint[0], slicePoint[1]];\n      };\n\n      sliceToWorld = (point: Types.Point2) => {\n        const ijkPoint = vec3.transformMat4(\n          [0, 0, 0],\n          [point[0], point[1], 0],\n          sliceToIndexMatrix\n        ) as Types.Point3;\n\n        return csUtils.transformIndexToWorld(vtkImageData, ijkPoint);\n      };\n\n      scalarData = sliceImageData.scalarData;\n      width = sliceImageData.width;\n      height = sliceImageData.height;\n    } else {\n      throw new Error('Viewport not supported');\n    }\n\n    const { voiRange } = viewport.getProperties();\n    const startPos = worldToSlice(worldPos);\n\n    this.scissors = LivewireScissors.createInstanceFromRawPixelData(\n      scalarData,\n      width,\n      height,\n      voiRange\n    );\n\n    this.scissors.startSearch(startPos);\n\n    const confirmedPath = new LivewirePath();\n    const currentPath = new LivewirePath();\n\n    confirmedPath.addPoint(startPos);\n    confirmedPath.addControlPoint(startPos);\n\n    const annotation = this.createAnnotation(evt) as LivewireContourAnnotation;\n\n    this.addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation: true,\n      hasMoved: false,\n      lastCanvasPoint: canvasPos,\n      confirmedPath: confirmedPath,\n      currentPath: currentPath,\n      closed: false,\n      worldToSlice,\n      sliceToWorld,\n    };\n\n    this._activateDraw(element);\n    evt.preventDefault();\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  }\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: LivewireContourAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const proximitySquared = proximity * proximity;\n    const canvasPoints = annotation.data.contour.polyline.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n\n    let startPoint = canvasPoints[canvasPoints.length - 1];\n\n    for (let i = 0; i < canvasPoints.length; i++) {\n      const endPoint = canvasPoints[i];\n      const distanceToPointSquared = math.lineSegment.distanceToPointSquared(\n        startPoint,\n        endPoint,\n        canvasCoords\n      );\n\n      if (distanceToPointSquared <= proximitySquared) {\n        return true;\n      }\n\n      startPoint = endPoint;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: LivewireContourAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n    };\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this._activateModify(element);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: LivewireContourAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    const { points } = data.handles;\n    const handleIndex = points.findIndex((p) => p === handle);\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n    };\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.scissors = null;\n    this.isDrawing = false;\n  };\n\n  private _mouseDownCallback = (evt: EventTypes.InteractionEventType): void => {\n    const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n    const { annotation, viewportIdsToRender, worldToSlice, sliceToWorld } =\n      this.editData;\n\n    if (this.editData.closed) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const { canvas: canvasPos, world: worldPos } = currentPoints;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const controlPoints = this.editData.currentPath.getControlPoints();\n    let closePath = controlPoints.length >= 2 && doubleClick;\n\n    // Check if user clicked on the first point to close the curve\n    if (controlPoints.length >= 2) {\n      const closestHandlePoint = {\n        index: -1,\n        distSquared: Infinity,\n      };\n\n      // Check if there is a control point close to the cursor\n      for (let i = 0, len = controlPoints.length; i < len; i++) {\n        const controlPoint = controlPoints[i];\n        const worldControlPoint = sliceToWorld(controlPoint);\n        const canvasControlPoint = viewport.worldToCanvas(worldControlPoint);\n\n        const distSquared = math.point.distanceToPointSquared(\n          canvasPos,\n          canvasControlPoint\n        );\n\n        if (\n          distSquared <= CLICK_CLOSE_CURVE_SQR_DIST &&\n          distSquared < closestHandlePoint.distSquared\n        ) {\n          closestHandlePoint.distSquared = distSquared;\n          closestHandlePoint.index = i;\n        }\n      }\n\n      if (closestHandlePoint.index === 0) {\n        closePath = true;\n      }\n    }\n\n    this.editData.closed = this.editData.closed || closePath;\n    this.editData.confirmedPath = this.editData.currentPath;\n\n    // Add the current cursor position as a new control point after clicking\n    this.editData.confirmedPath.addControlPoint(\n      this.editData.currentPath.getLastPoint()\n    );\n\n    // Start a new search starting at the last control point\n    this.scissors.startSearch(worldToSlice(worldPos));\n\n    annotation.invalidated = true;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (this.editData.closed) {\n      // Update the annotation because `editData` will be set to null\n      this._updateAnnotation(element, this.editData.confirmedPath);\n      this._endCallback(evt);\n    }\n\n    evt.preventDefault();\n  };\n\n  private _mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\n    const { element, currentPoints } = evt.detail;\n    const { world: worldPos, canvas: canvasPos } = currentPoints;\n    const { renderingEngine } = getEnabledElement(element);\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData.lastCanvasPoint = canvasPos;\n\n    const { width: imgWidth, height: imgHeight } = this.scissors;\n    const { worldToSlice } = this.editData;\n    const slicePoint: Types.Point2 = worldToSlice(worldPos);\n\n    // Check if the point is inside the bounding box\n    if (\n      slicePoint[0] < 0 ||\n      slicePoint[1] < 0 ||\n      slicePoint[0] >= imgWidth ||\n      slicePoint[1] >= imgHeight\n    ) {\n      return;\n    }\n\n    const pathPoints = this.scissors.findPathToPoint(slicePoint);\n    const currentPath = new LivewirePath();\n\n    for (let i = 0, len = pathPoints.length; i < len; i++) {\n      currentPath.addPoint(pathPoints[i]);\n    }\n\n    // Merge the \"confirmed\" path that goes from the first control point to the\n    // last one with the current path that goes from the last control point to\n    // the cursor point\n    currentPath.prependPath(this.editData.confirmedPath);\n\n    // Store the new path\n    this.editData.currentPath = currentPath;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    evt.preventDefault();\n  };\n\n  private _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.contour.polyline;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is not in mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n    if (newAnnotation) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData = null;\n    this.scissors = null;\n    return annotation.annotationUID;\n  };\n\n  /**\n   * Triggers an annotation modified event.\n   */\n  triggerAnnotationModified = (\n    annotation: LivewireContourAnnotation,\n    enabledElement: Types.IEnabledElement\n  ): void => {\n    const { viewportId, renderingEngineId } = enabledElement;\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n  };\n\n  private _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  private _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  private _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n    element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n    element.addEventListener(\n      Events.MOUSE_DOUBLE_CLICK,\n      this._mouseDownCallback\n    );\n\n    element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n  };\n\n  private _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n    element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n    element.removeEventListener(\n      Events.MOUSE_DOUBLE_CLICK,\n      this._mouseDownCallback\n    );\n\n    element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n  };\n\n  public renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean {\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    // Update the annotation that is in editData (being edited)\n    this._updateAnnotation(element, this.editData?.currentPath);\n\n    return super.renderAnnotation(enabledElement, svgDrawingHelper);\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Disable contour segmenatation behavior because it shall be activated only\n    // for LivewireContourSegmentationTool\n    return false;\n  }\n\n  protected createAnnotation(evt: EventTypes.InteractionEventType): Annotation {\n    const contourSegmentationAnnotation = super.createAnnotation(evt);\n    const { world: worldPos } = evt.detail.currentPoints;\n\n    return <LivewireContourAnnotation>csUtils.deepMerge(\n      contourSegmentationAnnotation,\n      {\n        data: {\n          handles: {\n            points: [[...worldPos]],\n          },\n        },\n      }\n    );\n  }\n\n  /**\n   * Render an annotation instance\n   * @param renderContext - Render context that contains the annotation, enabledElement, etc.\n   * @returns True if the annotation is rendered or false otherwise\n   */\n  protected renderAnnotationInstance(renderContext: {\n    enabledElement: Types.IEnabledElement;\n    targetId: string;\n    annotation: Annotation;\n    annotationStyle: Record<string, any>;\n    svgDrawingHelper: SVGDrawingHelper;\n  }): boolean {\n    const { enabledElement, svgDrawingHelper, annotationStyle } = renderContext;\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const annotation = renderContext.annotation as LivewireContourAnnotation;\n    const { annotationUID, data } = annotation;\n    const { handles } = data;\n    const newAnnotation = this.editData?.newAnnotation;\n    const { lineWidth, lineDash, color } = annotationStyle;\n\n    // Render the first control point only when the annotaion is drawn for the\n    // first time to make it easier to know where the user needs to click to\n    // to close the ROI.\n    if (\n      newAnnotation &&\n      annotation.annotationUID === this.editData?.annotation?.annotationUID\n    ) {\n      const handleGroupUID = '0';\n      const startPoint = worldToCanvas(handles.points[0]);\n\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        [startPoint],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        }\n      );\n    }\n\n    // Let the base class render the contour\n    super.renderAnnotationInstance(renderContext);\n\n    return true;\n  }\n\n  private _updateAnnotation(\n    element: HTMLDivElement,\n    livewirePath: LivewirePath\n  ) {\n    if (!this.editData || !livewirePath) {\n      return;\n    }\n\n    const { pointArray: imagePoints } = livewirePath;\n    const worldPolylinePoints: Types.Point3[] = [];\n    const { annotation, sliceToWorld } = this.editData;\n\n    for (let i = 0, len = imagePoints.length; i < len; i++) {\n      const imagePoint = imagePoints[i];\n      const worldPoint = sliceToWorld(imagePoint);\n      worldPolylinePoints.push(worldPoint);\n    }\n\n    if (worldPolylinePoints.length > 1) {\n      worldPolylinePoints.push([...worldPolylinePoints[0]]);\n    }\n\n    annotation.data.contour.polyline = worldPolylinePoints;\n  }\n}\n\nLivewireContourTool.toolName = 'LivewireContour';\nexport default LivewireContourTool;\n","import LivewireContourTool from './LivewireContourTool';\n\nclass LivewireContourSegmentationTool extends LivewireContourTool {\n  static toolName;\n\n  protected isContourSegmentationTool(): boolean {\n    // Re-enable contour segmentation behavior disabled by LivewireContourTool\n    return true;\n  }\n}\n\nLivewireContourSegmentationTool.toolName = 'LivewireContourSegmentationTool';\nexport default LivewireContourSegmentationTool;\n","import { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawArrow as drawArrowSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { ArrowAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass ArrowAnnotateTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        getTextCallback,\n        changeTextCallback,\n        preventHandleOutsideImage: false,\n        arrowFirst: true,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): ArrowAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const { arrowFirst } = this.configuration;\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        text: '',\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          arrowFirst,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: ArrowAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: ArrowAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: ArrowAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { viewportId, renderingEngineId, renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    if (newAnnotation) {\n      this.configuration.getTextCallback((text) => {\n        if (!text) {\n          removeAnnotation(annotation.annotationUID);\n          triggerAnnotationRenderForViewportIds(\n            renderingEngine,\n            viewportIdsToRender\n          );\n          this.editData = null;\n          this.isDrawing = false;\n          return;\n        }\n        annotation.data.text = text;\n\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n\n        triggerAnnotationRenderForViewportIds(\n          renderingEngine,\n          viewportIdsToRender\n        );\n      });\n    } else {\n      const eventType = Events.ANNOTATION_MODIFIED;\n\n      const eventDetail: AnnotationModifiedEventDetail = {\n        annotation,\n        viewportId,\n        renderingEngineId,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  touchTapCallback = (evt: EventTypes.TouchTapEventType) => {\n    if (evt.detail.taps == 2) {\n      this.doubleClickCallback(evt);\n    }\n  };\n\n  doubleClickCallback = (evt: EventTypes.TouchTapEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return;\n    }\n\n    const clickedAnnotation = annotations.find((annotation) =>\n      this.isPointNearTool(\n        element,\n        annotation as ArrowAnnotation,\n        eventDetail.currentPoints.canvas,\n        6 // Todo: get from configuration\n      )\n    );\n\n    if (!clickedAnnotation) {\n      return;\n    }\n\n    const annotation = clickedAnnotation as ArrowAnnotation;\n\n    this.configuration.changeTextCallback(\n      clickedAnnotation,\n      evt.detail,\n      this._doneChangingTextCallback.bind(this, element, annotation)\n    );\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    // This double click was handled and the dialogue was displayed.\n    // No need for any other listener to handle it too - stopImmediatePropagation\n    // helps ensure this primarily so that no other listeners on the target element\n    // get called.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  };\n\n  _doneChangingTextCallback(element, annotation, updatedText): void {\n    annotation.data.text = updatedText;\n\n    const { renderingEngine, viewportId, renderingEngineId } =\n      getEnabledElement(element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    triggerEvent(eventTarget, eventType, {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    });\n  }\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ArrowAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles, text } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineWidth,\n          }\n        );\n      }\n\n      const arrowUID = '1';\n      if (this.configuration.arrowFirst) {\n        drawArrowSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arrowUID,\n          canvasCoordinates[1],\n          canvasCoordinates[0],\n          {\n            color,\n            width: lineWidth,\n            lineDash: lineDash,\n          }\n        );\n      } else {\n        drawArrowSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arrowUID,\n          canvasCoordinates[0],\n          canvasCoordinates[1],\n          {\n            color,\n            width: lineWidth,\n            lineDash: lineDash,\n          }\n        );\n      }\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (!text) {\n        continue;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      // Need to update to sync w/ annotation while unlinked/not moved\n      if (!data.handles.textBox.hasMoved) {\n        // linked to the point that doesn't have the arrowhead by default\n        const canvasTextBoxCoords = canvasCoordinates[1];\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        [text],\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nfunction getTextCallback(doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nArrowAnnotateTool.toolName = 'ArrowAnnotate';\nexport default ArrowAnnotateTool;\n","import { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { roundNumber } from '../../utilities';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { AngleAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass AngleTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  angleStartedNotYetCompleted: boolean;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.InteractionEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): AngleAnnotation => {\n    if (this.angleStartedNotYetCompleted) {\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: AngleAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2, point3] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line1 = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line1.start.x, line1.start.y],\n      [line1.end.x, line1.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n    if (!point3) {\n      return false;\n    }\n\n    const canvasPoint3 = viewport.worldToCanvas(point3);\n\n    const line2 = {\n      start: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n      end: {\n        x: canvasPoint3[0],\n        y: canvasPoint3[1],\n      },\n    };\n\n    const distanceToPoint2 = lineSegment.distanceToPoint(\n      [line2.start.x, line2.start.y],\n      [line2.end.x, line2.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint2 <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: AngleAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: AngleAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n\n    const { data } = annotation;\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    // If preventing new measurement means we are in the middle of an existing measurement\n    // we shouldn't deactivate modify or draw\n    if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {\n      // adds the last point to the measurement\n      this.editData.handleIndex = 2;\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      this.angleStartedNotYetCompleted = false;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as AngleAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].angle == null\n      ) {\n        data.cachedStats[targetId] = {\n          angle: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      let lineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      renderStatus = true;\n\n      // Don't add textBox until annotation has 3 anchor points (actually 4 because of the center point)\n      if (canvasCoordinates.length !== 3) {\n        return renderStatus;\n      }\n\n      lineUID = '2';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[1],\n        canvasCoordinates[2],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      if (!data.cachedStats[targetId]?.angle) {\n        continue;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n\n      if (!data.handles.textBox.hasMoved) {\n        // linked to the vertex by default\n        const canvasTextBoxCoords = canvasCoordinates[1];\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    // Until we have all three anchors bail out\n    if (data.handles.points.length !== 3) {\n      return;\n    }\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const worldPos3 = data.handles.points[2];\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const angle = angleBetweenLines(\n        [worldPos1, worldPos2],\n        [worldPos2, worldPos3]\n      );\n\n      cachedStats[targetId] = {\n        angle: isNaN(angle) ? 'Incomplete Angle' : angle,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { angle } = cachedVolumeStats;\n\n  if (angle === undefined) {\n    return;\n  }\n\n  const textLines = [`${roundNumber(angle)} ${String.fromCharCode(176)}`];\n\n  return textLines;\n}\n\nAngleTool.toolName = 'Angle';\nexport default AngleTool;\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Return the midpoint (think average) of all the provided points.\n */\nconst midPoint = (\n  ...args: (Types.Point2 | Types.Point3)[]\n): Types.Point2 | Types.Point3 => {\n  const ret =\n    args[0].length === 2 ? <Types.Point2>[0, 0] : <Types.Point3>[0, 0, 0];\n  const len = args.length;\n  for (const arg of args) {\n    ret[0] += arg[0] / len;\n    ret[1] += arg[1] / len;\n    if (ret.length === 3) {\n      ret[2] += arg[2] / len;\n    }\n  }\n  return ret;\n};\n\nconst midPoint2 = midPoint as (...args: Types.Point2[]) => Types.Point2;\n\nexport default midPoint;\n\nexport { midPoint2 };\n","import { vec3 } from 'gl-matrix';\nimport { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { midPoint2 } from '../../utilities/math/midPoint';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { CobbAngleAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass CobbAngleTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  angleStartedNotYetCompleted: boolean;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    isNearFirstLine?: boolean;\n    isNearSecondLine?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      25,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.MouseDownActivateEventType\n  ): CobbAngleAnnotation => {\n    if (this.angleStartedNotYetCompleted) {\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CobbAngleAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n\n    const { distanceToPoint, distanceToPoint2 } = this.distanceToLines({\n      viewport,\n      points: data.handles.points,\n      canvasCoords,\n      proximity,\n    });\n\n    if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.MouseDownEventType,\n    annotation: CobbAngleAnnotation,\n    interactionType: InteractionTypes,\n    canvasCoords: Types.Point2,\n    proximity = 6\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n\n    const { isNearFirstLine, isNearSecondLine } = this.distanceToLines({\n      viewport,\n      points: annotation.data.handles.points,\n      canvasCoords,\n      proximity,\n    });\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n      isNearFirstLine,\n      isNearSecondLine,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.MouseDownEventType,\n    annotation: CobbAngleAnnotation,\n    handle: ToolHandle,\n    interactionType = 'mouse'\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _mouseUpCallback = (\n    evt: EventTypes.MouseUpEventType | EventTypes.MouseClickEventType\n  ) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n\n    const { data } = annotation;\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    // If preventing new measurement means we are in the middle of an existing measurement\n    // we shouldn't deactivate modify or draw\n    if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {\n      resetElementCursor(element);\n\n      // adds the first point of the second line\n      this.editData.handleIndex = data.handles.points.length;\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  /**\n   * Handles the mouse down for all points that follow the very first mouse down.\n   * The very first mouse down is handled by addAnnotation.\n   * This method ensures that the state of the tool is correct for the drawing of the second line segment.\n   * In particular it ensures that the second segment can be created via a mouse down and drag.\n   */\n  _mouseDownCallback = (\n    evt: EventTypes.MouseUpEventType | EventTypes.MouseClickEventType\n  ) => {\n    const { annotation, handleIndex } = this.editData;\n    const eventDetail = evt.detail;\n    const { element, currentPoints } = eventDetail;\n    const worldPos = currentPoints.world;\n    const { data } = annotation;\n\n    if (handleIndex === 1) {\n      // This is the mouse down for the second point of the first segment.\n      // The mouse up takes care of adding the first point of the second segment.\n      data.handles.points[1] = worldPos;\n      this.editData.hasMoved =\n        data.handles.points[1][0] !== data.handles.points[0][0] ||\n        data.handles.points[1][1] !== data.handles.points[0][0];\n      return;\n    }\n\n    if (handleIndex === 3) {\n      // This is the mouse down for the second point of the second segment (i.e. the last point)\n      data.handles.points[3] = worldPos;\n      this.editData.hasMoved =\n        data.handles.points[3][0] !== data.handles.points[2][0] ||\n        data.handles.points[3][1] !== data.handles.points[2][0];\n\n      this.angleStartedNotYetCompleted = false;\n      return;\n    }\n\n    // This is the first mouse down of the first point of the second line segment.\n    // It is as if we have not moved yet because Cobb Angle has two, disjoint sections, each with its own move.\n    this.editData.hasMoved = false;\n    hideElementCursor(element);\n\n    // Add the last segment points for the subsequent drag/mouse move.\n    data.handles.points[2] = data.handles.points[3] = worldPos;\n    this.editData.handleIndex = data.handles.points.length - 1;\n  };\n\n  _mouseDragCallback = (\n    evt: EventTypes.MouseDragEventType | EventTypes.MouseMoveEventType\n  ) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n      isNearFirstLine,\n      isNearSecondLine,\n    } = this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (\n      handleIndex === undefined &&\n      (isNearFirstLine || isNearSecondLine)\n    ) {\n      // select tool mode - moving annotation\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n      const points = data.handles.points;\n\n      // separate the logic for moving handles to move them separately\n      if (isNearFirstLine) {\n        const firstLinePoints = [points[0], points[1]];\n        firstLinePoints.forEach((point) => {\n          point[0] += worldPosDelta[0];\n          point[1] += worldPosDelta[1];\n          point[2] += worldPosDelta[2];\n        });\n      } else if (isNearSecondLine) {\n        const secondLinePoints = [points[2], points[3]];\n        secondLinePoints.forEach((point) => {\n          point[0] += worldPosDelta[0];\n          point[1] += worldPosDelta[1];\n          point[2] += worldPosDelta[2];\n        });\n      }\n\n      annotation.invalidated = true;\n    } else {\n      // Drag handle mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    if (data.handles.points.length < 4) {\n      // If it is mid-draw\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.angleStartedNotYetCompleted = false;\n    return annotation.annotationUID;\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n\n    // element.addEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n\n    // element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DOWN,\n      this._mouseDownCallback as EventListener\n    );\n\n    // element.addEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DOWN,\n      this._mouseDownCallback as EventListener\n    );\n\n    // element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as CobbAngleAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].angle == null\n      ) {\n        data.cachedStats[targetId] = {\n          angle: null,\n          arc1Angle: null,\n          arc2Angle: null,\n          points: {\n            world: {\n              arc1Start: null,\n              arc1End: null,\n              arc2Start: null,\n              arc2End: null,\n              arc1Angle: null,\n              arc2Angle: null,\n            },\n            canvas: {\n              arc1Start: null,\n              arc1End: null,\n              arc2Start: null,\n              arc2End: null,\n              arc1Angle: null,\n              arc2Angle: null,\n            },\n          },\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      const firstLine = [canvasCoordinates[0], canvasCoordinates[1]] as [\n        Types.Point2,\n        Types.Point2\n      ];\n      const secondLine = [canvasCoordinates[2], canvasCoordinates[3]] as [\n        Types.Point2,\n        Types.Point2\n      ];\n\n      let lineUID = 'line1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        firstLine[0],\n        firstLine[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      renderStatus = true;\n\n      // Don't add the stats until annotation has 4 anchor points\n      if (canvasCoordinates.length < 4) {\n        return renderStatus;\n      }\n\n      lineUID = 'line2';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        secondLine[0],\n        secondLine[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      lineUID = 'linkLine';\n      const mid1 = midPoint2(firstLine[0], firstLine[1]);\n      const mid2 = midPoint2(secondLine[0], secondLine[1]);\n      drawLineSvg(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {\n        color,\n        lineWidth: '1',\n        lineDash: '1,4',\n      });\n\n      // Calculating the arcs\n\n      const { arc1Start, arc1End, arc2End, arc2Start } =\n        data.cachedStats[targetId].points.canvas;\n      const { arc1Angle, arc2Angle } = data.cachedStats[targetId];\n\n      lineUID = 'arc1';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        arc1Start as Types.Point2,\n        arc1End as Types.Point2,\n        {\n          color,\n          lineWidth: '1',\n        }\n      );\n\n      lineUID = 'arc2';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        arc2Start as Types.Point2,\n        arc2End as Types.Point2,\n        {\n          color,\n          lineWidth: '1',\n        }\n      );\n\n      if (!data.cachedStats[targetId]?.angle) {\n        continue;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = 'cobbAngleText';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n\n      const arc1TextBoxUID = 'arcAngle1';\n\n      const arc1TextLine = [\n        `${arc1Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n      ];\n\n      const arch1TextPosCanvas = midPoint2(arc1Start, arc1End);\n\n      drawTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        arc1TextBoxUID,\n        arc1TextLine,\n        arch1TextPosCanvas,\n        {\n          ...options,\n          padding: 3,\n        }\n      );\n\n      const arc2TextBoxUID = 'arcAngle2';\n\n      const arc2TextLine = [\n        `${arc2Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n      ];\n\n      const arch2TextPosCanvas = midPoint2(arc2Start, arc2End);\n\n      drawTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        arc2TextBoxUID,\n        arc2TextLine,\n        arch2TextPosCanvas,\n        {\n          ...options,\n          padding: 3,\n        }\n      );\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    // Until we have all four anchors bail out\n    if (data.handles.points.length !== 4) {\n      return;\n    }\n\n    const seg1: [Types.Point3, Types.Point3] = [null, null];\n    const seg2: [Types.Point3, Types.Point3] = [null, null];\n    let minDist = Number.MAX_VALUE;\n\n    // Order the endpoints of each line segment such that seg1[1] and seg2[0]\n    // are the closest (Euclidean distance-wise) to each other. Thus\n    // the angle formed between the vectors seg1[1]->seg1[0] and seg2[0]->seg[1]\n    // is calculated.\n    // The assumption here is that the Cobb angle line segments are drawn\n    // such that the segments intersect nearest the segment endpoints\n    // that are closest AND those closest endpoints are the tails of the\n    // vectors used to calculate the angle between the vectors/line segments.\n    for (let i = 0; i < 2; i += 1) {\n      for (let j = 2; j < 4; j += 1) {\n        const dist = vec3.distance(\n          data.handles.points[i],\n          data.handles.points[j]\n        );\n        if (dist < minDist) {\n          minDist = dist;\n          seg1[1] = data.handles.points[i];\n          seg1[0] = data.handles.points[(i + 1) % 2];\n          seg2[0] = data.handles.points[j];\n          seg2[1] = data.handles.points[2 + ((j - 1) % 2)];\n        }\n      }\n    }\n    const { viewport } = enabledElement;\n\n    const canvasPoints = data.handles.points.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n\n    const firstLine = [canvasPoints[0], canvasPoints[1]] as [\n      Types.Point2,\n      Types.Point2\n    ];\n    const secondLine = [canvasPoints[2], canvasPoints[3]] as [\n      Types.Point2,\n      Types.Point2\n    ];\n\n    const mid1 = midPoint2(firstLine[0], firstLine[1]);\n    const mid2 = midPoint2(secondLine[0], secondLine[1]);\n\n    const { arc1Start, arc1End, arc2End, arc2Start, arc1Angle, arc2Angle } =\n      this.getArcsStartEndPoints({\n        firstLine,\n        secondLine,\n        mid1,\n        mid2,\n      });\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      cachedStats[targetId] = {\n        angle: angleBetweenLines(seg1, seg2),\n        arc1Angle,\n        arc2Angle,\n        points: {\n          canvas: {\n            arc1Start,\n            arc1End,\n            arc2End,\n            arc2Start,\n          },\n          world: {\n            arc1Start: viewport.canvasToWorld(arc1Start),\n            arc1End: viewport.canvasToWorld(arc1End),\n            arc2End: viewport.canvasToWorld(arc2End),\n            arc2Start: viewport.canvasToWorld(arc2Start),\n          },\n        },\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  }\n\n  distanceToLines = ({ viewport, points, canvasCoords, proximity }) => {\n    const [point1, point2, point3, point4] = points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n    const canvasPoint3 = viewport.worldToCanvas(point3);\n    const canvasPoint4 = viewport.worldToCanvas(point4);\n\n    const line1 = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const line2 = {\n      start: {\n        x: canvasPoint3[0],\n        y: canvasPoint3[1],\n      },\n      end: {\n        x: canvasPoint4[0],\n        y: canvasPoint4[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line1.start.x, line1.start.y],\n      [line1.end.x, line1.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    const distanceToPoint2 = lineSegment.distanceToPoint(\n      [line2.start.x, line2.start.y],\n      [line2.end.x, line2.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    let isNearFirstLine = false;\n    let isNearSecondLine = false;\n\n    if (distanceToPoint <= proximity) {\n      isNearFirstLine = true;\n    } else if (distanceToPoint2 <= proximity) {\n      isNearSecondLine = true;\n    }\n    return {\n      distanceToPoint,\n      distanceToPoint2,\n      isNearFirstLine,\n      isNearSecondLine,\n    };\n  };\n\n  getArcsStartEndPoints = ({\n    firstLine,\n    secondLine,\n    mid1,\n    mid2,\n  }): {\n    arc1Start: Types.Point2;\n    arc1End: Types.Point2;\n    arc2Start: Types.Point2;\n    arc2End: Types.Point2;\n    arc1Angle: number;\n    arc2Angle: number;\n  } => {\n    const linkLine = [mid1, mid2] as [Types.Point2, Types.Point2];\n\n    const arc1Angle = angleBetweenLines(firstLine, linkLine);\n    const arc2Angle = angleBetweenLines(secondLine, linkLine);\n\n    const arc1Side = arc1Angle > 90 ? 1 : 0;\n    const arc2Side = arc2Angle > 90 ? 0 : 1;\n\n    const midLinkLine = midPoint2(linkLine[0], linkLine[1]);\n\n    const linkLineLength = Math.sqrt(\n      (linkLine[1][0] - linkLine[0][0]) ** 2 +\n        (linkLine[1][1] - linkLine[0][1]) ** 2\n    );\n    const ratio = 0.1; // 10% of the line length\n\n    const midFirstLine = midPoint2(firstLine[0], firstLine[1]);\n    const midSecondLine = midPoint2(secondLine[0], secondLine[1]);\n\n    // For arc1Start\n    const directionVectorStartArc1 = [\n      firstLine[arc1Side][0] - midFirstLine[0],\n      firstLine[arc1Side][1] - midFirstLine[1],\n    ];\n    const magnitudeStartArc1 = Math.sqrt(\n      directionVectorStartArc1[0] ** 2 + directionVectorStartArc1[1] ** 2\n    );\n    const normalizedDirectionStartArc1 = [\n      directionVectorStartArc1[0] / magnitudeStartArc1,\n      directionVectorStartArc1[1] / magnitudeStartArc1,\n    ];\n    const arc1Start = [\n      midFirstLine[0] +\n        normalizedDirectionStartArc1[0] * linkLineLength * ratio,\n      midFirstLine[1] +\n        normalizedDirectionStartArc1[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    // Existing logic for arc1End\n    const directionVectorEndArc1 = [\n      midLinkLine[0] - mid1[0],\n      midLinkLine[1] - mid1[1],\n    ];\n    const magnitudeEndArc1 = Math.sqrt(\n      directionVectorEndArc1[0] ** 2 + directionVectorEndArc1[1] ** 2\n    );\n    const normalizedDirectionEndArc1 = [\n      directionVectorEndArc1[0] / magnitudeEndArc1,\n      directionVectorEndArc1[1] / magnitudeEndArc1,\n    ];\n    const arc1End = [\n      mid1[0] + normalizedDirectionEndArc1[0] * linkLineLength * ratio,\n      mid1[1] + normalizedDirectionEndArc1[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    // Similar logic for arc2Start\n    const directionVectorStartArc2 = [\n      secondLine[arc2Side][0] - midSecondLine[0],\n      secondLine[arc2Side][1] - midSecondLine[1],\n    ];\n    const magnitudeStartArc2 = Math.sqrt(\n      directionVectorStartArc2[0] ** 2 + directionVectorStartArc2[1] ** 2\n    );\n    const normalizedDirectionStartArc2 = [\n      directionVectorStartArc2[0] / magnitudeStartArc2,\n      directionVectorStartArc2[1] / magnitudeStartArc2,\n    ];\n    const arc2Start = [\n      midSecondLine[0] +\n        normalizedDirectionStartArc2[0] * linkLineLength * ratio,\n      midSecondLine[1] +\n        normalizedDirectionStartArc2[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    // Similar logic for arc2End\n    const directionVectorEndArc2 = [\n      midLinkLine[0] - mid2[0],\n      midLinkLine[1] - mid2[1],\n    ];\n    const magnitudeEndArc2 = Math.sqrt(\n      directionVectorEndArc2[0] ** 2 + directionVectorEndArc2[1] ** 2\n    );\n    const normalizedDirectionEndArc2 = [\n      directionVectorEndArc2[0] / magnitudeEndArc2,\n      directionVectorEndArc2[1] / magnitudeEndArc2,\n    ];\n    const arc2End = [\n      mid2[0] + normalizedDirectionEndArc2[0] * linkLineLength * ratio,\n      mid2[1] + normalizedDirectionEndArc2[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    return {\n      arc1Start,\n      arc1End,\n      arc2Start,\n      arc2End,\n      arc1Angle: arc1Angle > 90 ? 180 - arc1Angle : arc1Angle,\n      arc2Angle: arc2Angle > 90 ? 180 - arc2Angle : arc2Angle,\n    };\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { angle } = cachedVolumeStats;\n\n  if (angle === undefined) {\n    return;\n  }\n\n  const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];\n\n  return textLines;\n}\n\nCobbAngleTool.toolName = 'CobbAngle';\nexport default CobbAngleTool;\n","import { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n  StackViewport,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { UltrasoundDirectionalAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport {\n  drawHandle as drawHandleSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { roundNumber } from '../../utilities';\nimport { distanceToPoint } from '../../utilities/math/point';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  Annotation,\n  InteractionTypes,\n} from '../../types';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * The `UltrasoundDirectionalTool` class is a tool for creating directional ultrasound annotations.\n * It allows users to draw lines and measure distances between two points in the image.\n * It automatically calculates the distance based on the relevant unit of measurement.\n */\nclass UltrasoundDirectionalTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  startedDrawing: boolean;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n        /**\n         * Determines whether both horizontal and vertical distances should be displayed\n         * in the text lines when generating annotations' measurement information.\n         */\n        displayBothAxesDistances: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Ultrasound Directional Tool and store it in the annotationManager\n   *\n   * @param evt -  EventTypes.InteractionEventType\n   * @returns The annotation object.\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): UltrasoundDirectionalAnnotation => {\n    if (this.startedDrawing) {\n      return;\n    }\n\n    this.startedDrawing = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    if (!(viewport instanceof StackViewport)) {\n      throw new Error(\n        'UltrasoundDirectionalTool can only be used on a StackViewport'\n      );\n    }\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: UltrasoundDirectionalAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    return false;\n  };\n\n  toolSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes,\n    canvasCoords?: Types.Point2\n  ): void {\n    return;\n  }\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: UltrasoundDirectionalAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    let movingTextBox = false;\n    let handleIndex;\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n\n    this.editData = {\n      handleIndex,\n      annotation,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n\n    const { data } = annotation;\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    // If preventing new measurement means we are in the middle of an existing measurement\n    // we shouldn't deactivate modify or draw\n    if (this.startedDrawing && data.handles.points.length === 1) {\n      // adds the last point to the measurement\n      this.editData.handleIndex = 1;\n      return;\n    }\n\n    this.startedDrawing = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      this.startedDrawing = false;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as UltrasoundDirectionalAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].xValues == null\n      ) {\n        data.cachedStats[targetId] = {\n          xValues: [0, 0],\n          yValues: [0, 0],\n          isHorizontal: false,\n          units: [''],\n          isUnitless: false,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      // draw first point\n      let handleGroupUID = '0';\n      drawHandleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        canvasCoordinates[0],\n        {\n          color,\n        },\n        0\n      );\n\n      renderStatus = true;\n\n      if (canvasCoordinates.length !== 2) {\n        return renderStatus;\n      }\n\n      handleGroupUID = '1';\n      drawHandleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        canvasCoordinates[1],\n        {\n          color,\n        },\n        1\n      );\n\n      const isUnitless = data.cachedStats[targetId].isUnitless;\n\n      if (!isUnitless) {\n        const canvasPoint1 = canvasCoordinates[0];\n        const canvasPoint2 = canvasCoordinates[1];\n\n        const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n        const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n\n        const isHorizontal = data.cachedStats[targetId].isHorizontal;\n\n        // then for the third point we need to go from first point towards\n        // the second point (it can be left or right in the horizontal orientation)\n        // or up or down in the vertical orientation, and only add\n        // the delta y to the x or y coordinate of the first point\n        let projectedPointCanvas = [0, 0] as Types.Point2;\n        if (isHorizontal) {\n          projectedPointCanvas = [\n            canvasPoint1[0] + canvasDeltaX,\n            canvasPoint1[1],\n          ];\n        } else {\n          projectedPointCanvas = [\n            canvasPoint1[0],\n            canvasPoint1[1] + canvasDeltaY,\n          ];\n        }\n\n        // create a line from the first point to the third point\n        let dataId = `${annotationUID}-line-1`;\n        let lineUID = '1';\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          canvasCoordinates[0],\n          projectedPointCanvas,\n          {\n            color,\n            width: 1,\n            shadow: this.configuration.shadow,\n          },\n          dataId\n        );\n\n        // draw another line from first point to the projected one\n        dataId = `${annotationUID}-line-2`;\n        lineUID = '2';\n\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          canvasCoordinates[1],\n          projectedPointCanvas,\n          {\n            color,\n            width: 1,\n            lineDash: [1, 1],\n            shadow: this.configuration.shadow,\n          },\n          dataId\n        );\n      } else {\n        // draw straight line between the two points\n        const dataId = `${annotationUID}-line-1`;\n        const lineUID = '1';\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          canvasCoordinates[0],\n          canvasCoordinates[1],\n          {\n            color,\n            width: 1,\n            shadow: this.configuration.shadow,\n          },\n          dataId\n        );\n      }\n\n      // draw another line from first point to the\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(\n        data,\n        targetId,\n        this.configuration\n      );\n\n      if (!data.handles.textBox.hasMoved) {\n        // linked to the vertex by default\n        const canvasTextBoxCoords = canvasCoordinates[1];\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    // Until we have all two anchors bail out\n    if (data.handles.points.length !== 2) {\n      return;\n    }\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData } = image;\n\n      const worldPos1 = data.handles.points[0];\n      const worldPos2 = data.handles.points[1];\n\n      const imageIndex1 = transformWorldToIndex(imageData, worldPos1);\n      const imageIndex2 = transformWorldToIndex(imageData, worldPos2);\n\n      const { values: values1, units: units1 } =\n        getCalibratedProbeUnitsAndValue(image, [imageIndex1]);\n      const { values: values2, units: units2 } =\n        getCalibratedProbeUnitsAndValue(image, [imageIndex2]);\n\n      let xValues, yValues, units, isHorizontal;\n      let isUnitless = false;\n      if (\n        units1[0] !== units2[0] ||\n        units1[1] !== units2[1] ||\n        (units1[0] === 'raw' && units2[0] === 'raw')\n      ) {\n        // if units are not the same, we cannot calculate the diff\n        // so we just report the px distance\n        const value = distanceToPoint(worldPos1, worldPos2);\n\n        xValues = [value, 0];\n        yValues = [value, 0];\n        units = ['px'];\n        isUnitless = true;\n      } else {\n        const canvasPoint1 = enabledElement.viewport.worldToCanvas(worldPos1);\n        const canvasPoint2 = enabledElement.viewport.worldToCanvas(worldPos2);\n\n        const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n        const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n\n        isHorizontal = Math.abs(canvasDeltaX) > Math.abs(canvasDeltaY);\n        xValues = [values1[0], values2[0]];\n        yValues = [values1[1], values2[1]];\n\n        units = [units1[0], units1[1]];\n      }\n\n      cachedStats[targetId] = {\n        xValues,\n        yValues,\n        isHorizontal,\n        units,\n        isUnitless,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId, configuration): string[] {\n  const cachedStats = data.cachedStats[targetId];\n  const { xValues, yValues, units, isUnitless, isHorizontal } = cachedStats;\n\n  if (isUnitless) {\n    return [`${roundNumber(xValues[0])} px`];\n  }\n\n  if (configuration.displayBothAxesDistances) {\n    const dist1 = Math.abs(xValues[1] - xValues[0]);\n    const dist2 = Math.abs(yValues[1] - yValues[0]);\n    return [\n      `${roundNumber(dist1)} ${units[0]}`,\n      `${roundNumber(dist2)} ${units[1]}`,\n    ];\n  }\n\n  if (isHorizontal) {\n    const dist = Math.abs(xValues[1] - xValues[0]);\n    return [`${roundNumber(dist)} ${units[0]}`];\n  } else {\n    const dist = Math.abs(yValues[1] - yValues[0]);\n    return [`${roundNumber(dist)} ${units[1]}`];\n  }\n}\n\nUltrasoundDirectionalTool.toolName = 'UltrasoundDirectionalTool';\nexport default UltrasoundDirectionalTool;\n","import { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\n\nimport { drawArrow as drawArrowSvg } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { AnnotationCompletedEventDetail } from '../../types/EventTypes';\n\nimport { resetElementCursor } from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { Annotation } from '../../types';\n\ntype Point2 = Types.Point2;\n\nclass KeyImageTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        getTextCallback,\n        changeTextCallback,\n        canvasPosition: [10, 10],\n        canvasSize: 10,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      annotationUID: null as string,\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        text: '',\n        handles: {\n          points: new Array<Types.Point3>(),\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.configuration.getTextCallback((text) => {\n      if (!text) {\n        removeAnnotation(annotation.annotationUID);\n        triggerAnnotationRenderForViewportIds(\n          renderingEngine,\n          viewportIdsToRender\n        );\n        this.isDrawing = false;\n        return;\n      }\n      annotation.data.text = text;\n\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n    });\n\n    return annotation;\n  };\n\n  public cancel() {\n    // No op - the annotation can't be in a partial state\n  }\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n\n    const { canvasPosition, canvasSize } = this.configuration;\n    if (!canvasPosition?.length) {\n      return false;\n    }\n    if (\n      Math.abs(canvasCoords[0] - canvasPosition[0] + canvasSize / 2) <=\n        canvasSize / 2 &&\n      Math.abs(canvasCoords[1] - canvasPosition[1] + canvasSize / 2) <=\n        canvasSize / 2\n    ) {\n      return true;\n    }\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation\n  ): void => {\n    annotation.highlighted = true;\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    handle: ToolHandle\n  ): void {\n    // Nothing special to do here.\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    this._deactivateModify(element);\n    resetElementCursor(element);\n  };\n\n  doubleClickCallback = (evt: EventTypes.TouchTapEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return;\n    }\n\n    const clickedAnnotation = annotations.find((annotation) =>\n      this.isPointNearTool(\n        element,\n        annotation as Annotation,\n        eventDetail.currentPoints.canvas,\n        6 // Todo: get from configuration\n      )\n    );\n\n    if (!clickedAnnotation) {\n      return;\n    }\n\n    const annotation = clickedAnnotation as Annotation;\n\n    this.configuration.changeTextCallback(\n      clickedAnnotation,\n      evt.detail,\n      this._doneChangingTextCallback.bind(this, element, annotation)\n    );\n\n    this.isDrawing = false;\n\n    // This double click was handled and the dialogue was displayed.\n    // No need for any other listener to handle it too - stopImmediatePropagation\n    // helps ensure this primarily so that no other listeners on the target element\n    // get called.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  };\n\n  _doneChangingTextCallback(element, annotation, updatedText): void {\n    annotation.data.text = updatedText;\n\n    const { renderingEngine, viewportId, renderingEngineId } =\n      getEnabledElement(element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    triggerEvent(eventTarget, eventType, {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    });\n  }\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i];\n      const { annotationUID } = annotation;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const { canvasPosition, canvasSize } = this.configuration;\n      if (canvasPosition?.length) {\n        const arrowUID = '1';\n        drawArrowSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arrowUID,\n          canvasPosition.map((it) => it + canvasSize) as Point2,\n          canvasPosition as Point2,\n          {\n            color,\n            width: 1,\n          }\n        );\n      }\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n    }\n\n    return renderStatus;\n  };\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nfunction getTextCallback(doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nKeyImageTool.toolName = 'KeyImage';\n\nexport default KeyImageTool;\n","import { BaseTool } from './base';\nimport { Events } from '../enums';\n\nimport { getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { state } from '../store';\nimport { Enums } from '@cornerstonejs/core';\n\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../cursors/elementCursor';\nimport { IPoints } from '../types';\n\nconst MAGNIFY_VIEWPORT_ID = 'magnify-viewport';\n\nclass MagnifyTool extends BaseTool {\n  static toolName;\n  _bounds: any;\n  editData: {\n    referencedImageId: string;\n    viewportIdsToRender: string[];\n    enabledElement: Types.IEnabledElement;\n    renderingEngine: Types.IRenderingEngine;\n    currentPoints: IPoints;\n  } | null;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        magnifySize: 10, // parallel scale , higher more zoom\n        magnifyWidth: 250, //px\n        magnifyHeight: 250, //px\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  _getReferencedImageId(\n    viewport: Types.IStackViewport | Types.IVolumeViewport\n  ): string {\n    const targetId = this.getTargetId(viewport);\n\n    let referencedImageId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    }\n\n    return referencedImageId;\n  }\n\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element, currentPoints } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    if (!(viewport instanceof StackViewport)) {\n      throw new Error('MagnifyTool only works on StackViewports');\n    }\n\n    const referencedImageId = this._getReferencedImageId(viewport);\n\n    if (!referencedImageId) {\n      throw new Error(\n        'MagnifyTool: No referenced image id found, reconstructed planes not supported yet'\n      );\n    }\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      referencedImageId,\n      viewportIdsToRender,\n      enabledElement,\n      renderingEngine,\n      currentPoints,\n    };\n\n    this._createMagnificationViewport();\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType) => {\n    this.preMouseDownCallback(evt);\n  };\n\n  _createMagnificationViewport = () => {\n    const {\n      enabledElement,\n      referencedImageId,\n      viewportIdsToRender,\n      renderingEngine,\n      currentPoints,\n    } = this.editData;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    const viewportProperties = viewport.getProperties();\n\n    const { canvas: canvasPos, world: worldPos } = currentPoints;\n\n    let magnifyToolElement: HTMLDivElement;\n\n    magnifyToolElement = element.querySelector('.magnifyTool');\n    if (magnifyToolElement === null) {\n      const magnifyElement = document.createElement('div');\n\n      magnifyElement.classList.add('magnifyTool');\n\n      magnifyElement.style.display = 'block';\n      magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;\n      magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;\n      magnifyElement.style.position = 'absolute';\n\n      magnifyToolElement = magnifyElement;\n\n      const viewportElement = element.querySelector('.viewport-element');\n      viewportElement.appendChild(magnifyElement);\n\n      const viewportInput = {\n        viewportId: MAGNIFY_VIEWPORT_ID,\n        type: Enums.ViewportType.STACK,\n        element: magnifyToolElement as HTMLDivElement,\n      };\n\n      renderingEngine.enableElement(viewportInput);\n    }\n\n    // Todo: use CSS transform instead of setting top and left for better performance\n    magnifyToolElement.style.top = `${\n      canvasPos[1] - this.configuration.magnifyHeight / 2\n    }px`;\n    magnifyToolElement.style.left = `${\n      canvasPos[0] - this.configuration.magnifyWidth / 2\n    }px`;\n\n    const magnifyViewport = renderingEngine.getViewport(\n      MAGNIFY_VIEWPORT_ID\n    ) as Types.IStackViewport;\n\n    magnifyViewport.setStack([referencedImageId]).then(() => {\n      // match the original viewport voi range\n      magnifyViewport.setProperties(viewportProperties);\n\n      // Use the original viewport for the base for parallelScale\n      const { parallelScale } = viewport.getCamera();\n\n      const { focalPoint, position, viewPlaneNormal } =\n        magnifyViewport.getCamera();\n\n      const distance = Math.sqrt(\n        Math.pow(focalPoint[0] - position[0], 2) +\n          Math.pow(focalPoint[1] - position[1], 2) +\n          Math.pow(focalPoint[2] - position[2], 2)\n      );\n\n      const updatedFocalPoint = <Types.Point3>[\n        worldPos[0],\n        worldPos[1],\n        worldPos[2],\n      ];\n\n      const updatedPosition = <Types.Point3>[\n        updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n        updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n        updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n      ];\n\n      magnifyViewport.setCamera({\n        parallelScale: parallelScale * (1 / this.configuration.magnifySize),\n        focalPoint: updatedFocalPoint,\n        position: updatedPosition,\n      });\n      magnifyViewport.render();\n    });\n\n    magnifyToolElement.style.display = 'block';\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n\n    const { deltaPoints, element, currentPoints } = eventDetail;\n    const deltaPointsWorld = deltaPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n\n    const magnifyElement = element.querySelector(\n      '.magnifyTool'\n    ) as HTMLDivElement;\n\n    if (!magnifyElement) {\n      return;\n    }\n\n    magnifyElement.style.top = `${\n      canvasPos[1] - this.configuration.magnifyHeight / 2\n    }px`;\n    magnifyElement.style.left = `${\n      canvasPos[0] - this.configuration.magnifyWidth / 2\n    }px`;\n\n    const { focalPoint, position } = magnifyViewport.getCamera();\n\n    const updatedPosition = <Types.Point3>[\n      position[0] + deltaPointsWorld[0],\n      position[1] + deltaPointsWorld[1],\n      position[2] + deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] + deltaPointsWorld[0],\n      focalPoint[1] + deltaPointsWorld[1],\n      focalPoint[2] + deltaPointsWorld[2],\n    ];\n\n    magnifyViewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n\n    magnifyViewport.render();\n  };\n\n  _dragEndCallback = (evt: EventTypes.InteractionEventType) => {\n    const { element } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);\n\n    const viewportElement = element.querySelector('.viewport-element');\n\n    const magnifyToolElement = viewportElement.querySelector(\n      '.magnifyTool'\n    ) as HTMLDivElement;\n\n    viewportElement.removeChild(magnifyToolElement);\n\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._dragEndCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._dragEndCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._dragEndCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n}\n\nMagnifyTool.toolName = 'Magnify';\nexport default MagnifyTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport {\n  getEnabledElement,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  SegmentationRepresentations,\n  ToolModes,\n  Events as cstEvents,\n} from '../enums';\nimport { ToolGroupManager, state } from '../store';\nimport { debounce } from '../utilities';\nimport { ToolModeChangedEventType } from '../types/EventTypes';\nimport { segmentation } from '..';\nimport { EventTypes, IToolGroup } from '../types';\nimport {\n  AnnotationTool,\n  AdvancedMagnifyTool,\n  SegmentationDisplayTool,\n} from './';\nimport { distanceToPoint } from '../utilities/math/point';\n\nconst MAGNIFY_CLASSNAME = 'advancedMagnifyTool';\nconst MAGNIFY_VIEWPORT_INITIAL_RADIUS = 125;\n\n// TODO: find a better to identify segmentation actors\nconst isSegmentation = (actor) => actor.uid !== actor.referenceId;\n\nexport type AutoPanCallbackData = {\n  points: {\n    currentPosition: {\n      canvas: Types.Point2;\n      world: Types.Point3;\n    };\n    newPosition: {\n      canvas: Types.Point2;\n      world: Types.Point3;\n    };\n  };\n  delta: {\n    canvas: Types.Point2;\n    world: Types.Point3;\n  };\n};\n\nexport type AutoPanCallback = (data: AutoPanCallbackData) => void;\n\nclass AdvancedMagnifyViewport {\n  private _viewportId: string;\n  private _sourceEnabledElement: Types.IEnabledElement;\n  private _enabledElement: Types.IEnabledElement = null;\n  private _sourceToolGroup: IToolGroup = null;\n  private _magnifyToolGroup: IToolGroup = null;\n  private _isViewportReady = false;\n  private _radius = 0;\n  private _resized = false;\n  private _resizeViewportAsync: () => void;\n  private _canAutoPan = false;\n  private _autoPan: {\n    enabled: boolean;\n    padding: number;\n    callback: AutoPanCallback;\n  };\n  public position: Types.Point2;\n  public zoomFactor: number;\n  public visible: boolean;\n\n  constructor({\n    magnifyViewportId,\n    sourceEnabledElement,\n    radius = MAGNIFY_VIEWPORT_INITIAL_RADIUS,\n    position = [0, 0],\n    zoomFactor,\n    autoPan,\n  }: {\n    magnifyViewportId?: string;\n    sourceEnabledElement: Types.IEnabledElement;\n    radius?: number;\n    position?: Types.Point2;\n    zoomFactor: number;\n    autoPan: {\n      enabled: boolean;\n      padding: number;\n      callback: AutoPanCallback;\n    };\n  }) {\n    // Private properties\n    this._viewportId = magnifyViewportId ?? csUtils.uuidv4();\n    this._sourceEnabledElement = sourceEnabledElement;\n    this._autoPan = autoPan;\n\n    // Pulic properties\n    this.radius = radius;\n    this.position = position;\n    this.zoomFactor = zoomFactor;\n    this.visible = true;\n\n    this._browserMouseDownCallback = this._browserMouseDownCallback.bind(this);\n    this._browserMouseUpCallback = this._browserMouseUpCallback.bind(this);\n    this._handleToolModeChanged = this._handleToolModeChanged.bind(this);\n    this._mouseDragCallback = this._mouseDragCallback.bind(this);\n    this._resizeViewportAsync = <() => void>(\n      debounce(this._resizeViewport.bind(this), 1)\n    );\n\n    this._initialize();\n  }\n\n  public get sourceEnabledElement() {\n    return this._sourceEnabledElement;\n  }\n\n  public get viewportId() {\n    return this._viewportId;\n  }\n\n  public get radius() {\n    return this._radius;\n  }\n\n  public set radius(radius: number) {\n    // Just moving the magnifying glass around may change its radius\n    // by very small amount due to floating number precision\n    if (Math.abs(this._radius - radius) > 0.00001) {\n      this._radius = radius;\n      this._resized = true;\n    }\n  }\n\n  public update() {\n    const { radius, position, visible } = this;\n    const { viewport } = this._enabledElement;\n    const { element } = viewport;\n    const size = 2 * radius;\n    const [x, y] = position;\n\n    if (this._resized) {\n      this._resizeViewportAsync();\n      this._resized = false;\n    }\n\n    Object.assign(element.style, {\n      display: visible ? 'block' : 'hidden',\n      width: `${size}px`,\n      height: `${size}px`,\n      left: `${-radius}px`,\n      top: `${-radius}px`,\n      transform: `translate(${x}px, ${y}px)`,\n    });\n\n    if (this._isViewportReady) {\n      this._syncViewports();\n      viewport.render();\n    }\n  }\n\n  public dispose() {\n    const { viewport } = this._enabledElement;\n    const { element } = viewport;\n    const renderingEngine = viewport.getRenderingEngine();\n\n    this._removeEventListeners(element);\n    renderingEngine.disableElement(viewport.id);\n\n    if (element.parentNode) {\n      element.parentNode.removeChild(element);\n    }\n  }\n\n  private _handleToolModeChanged(evt: ToolModeChangedEventType) {\n    const { _magnifyToolGroup: magnifyToolGroup } = this;\n    const { toolGroupId, toolName, mode, toolBindingsOptions } = evt.detail;\n\n    if (this._sourceToolGroup?.id !== toolGroupId) {\n      return;\n    }\n\n    switch (mode) {\n      case ToolModes.Active:\n        magnifyToolGroup.setToolActive(toolName, toolBindingsOptions);\n        break;\n      case ToolModes.Passive:\n        magnifyToolGroup.setToolPassive(toolName);\n        break;\n      case ToolModes.Enabled:\n        magnifyToolGroup.setToolEnabled(toolName);\n        break;\n      case ToolModes.Disabled:\n        magnifyToolGroup.setToolDisabled(toolName);\n        break;\n      default:\n        throw new Error(`Unknow tool mode (${mode})`);\n    }\n  }\n\n  // Children elements need to inherit border-radius otherwise the canvas will\n  // trigger events when moving/dragging/clicking on the corners outside of the\n  // border (circle) region.\n  private _inheritBorderRadius(magnifyElement) {\n    const viewport = magnifyElement.querySelector('.viewport-element');\n    const canvas = magnifyElement.querySelector('.cornerstone-canvas');\n\n    viewport.style.borderRadius = 'inherit';\n    canvas.style.borderRadius = 'inherit';\n  }\n\n  private _createViewportNode(): HTMLDivElement {\n    const magnifyElement = document.createElement('div');\n    const { radius } = this;\n    const size = radius * 2;\n\n    magnifyElement.classList.add(MAGNIFY_CLASSNAME);\n\n    // Update the style and move the element out of the screen with \"transforms\"\n    // to make it \"invisible\" and preserving its size because when \"display\" is\n    // set to \"none\" both \"offsetWidth\" and \"offsetHeight\" returns zero. Another\n    // way would be setting \"visibility\" to \"hidden\" but \"transforms\" is used\n    // because it is already being updated when update() is called\n    Object.assign(magnifyElement.style, {\n      display: 'block',\n      width: `${size}px`,\n      height: `${size}px`,\n      position: 'absolute',\n      overflow: 'hidden',\n      borderRadius: '50%',\n      boxSizing: 'border-box',\n      left: `${-radius}px`,\n      top: `${-radius}px`,\n      transform: `translate(-1000px, -1000px)`,\n    });\n\n    return magnifyElement;\n  }\n\n  private _convertZoomFactorToParalellScale(\n    viewport,\n    magnifyViewport,\n    zoomFactor\n  ) {\n    const { parallelScale } = viewport.getCamera();\n    const canvasRatio =\n      magnifyViewport.canvas.offsetWidth / viewport.canvas.offsetWidth;\n\n    return parallelScale * (1 / zoomFactor) * canvasRatio;\n  }\n\n  private _isStackViewport(\n    viewport: Types.IViewport\n  ): viewport is Types.IStackViewport {\n    return 'setStack' in viewport;\n  }\n\n  private _isVolumeViewport(\n    viewport: Types.IViewport\n  ): viewport is Types.IVolumeViewport {\n    return 'addVolumes' in viewport;\n  }\n\n  private _cloneToolGroups(\n    sourceViewport: Types.IViewport,\n    magnifyViewport: Types.IViewport\n  ) {\n    const sourceActors = sourceViewport.getActors();\n    const magnifyToolGroupId = `${magnifyViewport.id}-toolGroup`;\n    const sourceToolGroup = ToolGroupManager.getToolGroupForViewport(\n      sourceViewport.id,\n      sourceViewport.renderingEngineId\n    );\n\n    const magnifyToolGroup = sourceToolGroup.clone(\n      magnifyToolGroupId,\n      (toolName) => {\n        const toolInstance = sourceToolGroup.getToolInstance(toolName);\n        const isAnnotationTool =\n          toolInstance instanceof AnnotationTool &&\n          !(toolInstance instanceof AdvancedMagnifyTool);\n\n        return (\n          isAnnotationTool || toolName === SegmentationDisplayTool.toolName\n        );\n      }\n    );\n\n    magnifyToolGroup.addViewport(\n      magnifyViewport.id,\n      magnifyViewport.renderingEngineId\n    );\n\n    sourceActors.filter(isSegmentation).forEach((actor) => {\n      segmentation.addSegmentationRepresentations(magnifyToolGroupId, [\n        {\n          segmentationId: actor.referenceId,\n          type: SegmentationRepresentations.Labelmap,\n        },\n      ]);\n    });\n\n    return { sourceToolGroup, magnifyToolGroup };\n  }\n\n  private _cloneStack(\n    sourceViewport: Types.IStackViewport,\n    magnifyViewport: Types.IStackViewport\n  ): void {\n    const imageIds = sourceViewport.getImageIds();\n\n    magnifyViewport.setStack(imageIds).then(() => {\n      this._isViewportReady = true;\n      this.update();\n    });\n  }\n\n  private _cloneVolumes(\n    sourceViewport: Types.IVolumeViewport,\n    magnifyViewport: Types.IVolumeViewport\n  ): Types.IVolumeViewport {\n    const actors = sourceViewport.getActors();\n    const volumeInputArray: Types.IVolumeInput[] = actors\n      .filter((actor) => !isSegmentation(actor))\n      .map((actor) => ({ volumeId: actor.uid }));\n\n    magnifyViewport.setVolumes(volumeInputArray).then(() => {\n      this._isViewportReady = true;\n      this.update();\n    });\n\n    return magnifyViewport;\n  }\n\n  private _cloneViewport(sourceViewport, magnifyElement) {\n    const { viewportId: magnifyViewportId } = this;\n    const renderingEngine =\n      sourceViewport.getRenderingEngine() as Types.IRenderingEngine;\n\n    const { options: sourceViewportOptions } = sourceViewport;\n    const viewportInput = {\n      element: magnifyElement,\n      viewportId: magnifyViewportId,\n      type: sourceViewport.type,\n      defaultOptions: { ...sourceViewportOptions },\n    };\n\n    renderingEngine.enableElement(viewportInput);\n\n    const magnifyViewport = <Types.IViewport>(\n      renderingEngine.getViewport(magnifyViewportId)\n    );\n\n    if (this._isStackViewport(sourceViewport)) {\n      this._cloneStack(sourceViewport, magnifyViewport as Types.IStackViewport);\n    } else if (this._isVolumeViewport(sourceViewport)) {\n      this._cloneVolumes(\n        sourceViewport,\n        magnifyViewport as Types.IVolumeViewport\n      );\n    }\n\n    // Prevent handling events outside of the magnifying glass because it has rounded border\n    this._inheritBorderRadius(magnifyElement);\n\n    const toolGroups = this._cloneToolGroups(sourceViewport, magnifyViewport);\n\n    this._sourceToolGroup = toolGroups.sourceToolGroup;\n    this._magnifyToolGroup = toolGroups.magnifyToolGroup;\n  }\n\n  private _cancelMouseEventCallback(evt): void {\n    evt.stopPropagation();\n    evt.preventDefault();\n  }\n\n  private _browserMouseUpCallback(evt) {\n    const { element } = this._enabledElement.viewport;\n\n    document.removeEventListener('mouseup', this._browserMouseUpCallback);\n\n    // Restrict the scope of magnifying glass events again\n    element.addEventListener('mouseup', this._cancelMouseEventCallback);\n    element.addEventListener('mousemove', this._cancelMouseEventCallback);\n  }\n\n  private _browserMouseDownCallback(evt) {\n    const { element } = this._enabledElement.viewport;\n\n    // Enable auto pan only when user clicks inside of the magnifying glass\n    // viewport otherwise it can move when interacting with annotations outside\n    // of the magnifying glass or when trying to move/resize it.\n    this._canAutoPan = !!evt.target?.closest('.advancedMagnifyTool');\n\n    // Wait for the mouseup event to restrict the scope of magnifying glass events again\n    document.addEventListener('mouseup', this._browserMouseUpCallback);\n\n    // Allow mouseup and mousemove events to make it possible to manipulate the\n    // tool when passing the mouse over the magnifying glass (dragging a handle).\n    // Just relying on state.isInteractingWithTool does not work because there\n    // is a 400ms delay to handle double click (see mouseDownListener) which\n    // makes the magnifying glass unresponsive for that amount of time.\n    element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n    element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n  }\n\n  private _mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    if (!state.isInteractingWithTool) {\n      return;\n    }\n\n    const { _autoPan: autoPan } = this;\n\n    if (!autoPan.enabled || !this._canAutoPan) {\n      return;\n    }\n\n    const { currentPoints } = evt.detail;\n    const { viewport } = this._enabledElement;\n    const { canvasToWorld } = viewport;\n    const { canvas: canvasCurrent } = currentPoints;\n    const { radius: magnifyRadius } = this;\n    const canvasCenter: Types.Point2 = [magnifyRadius, magnifyRadius];\n    const dist = distanceToPoint(canvasCenter, canvasCurrent);\n    const maxDist = magnifyRadius - autoPan.padding;\n\n    // No need to pan if it is not close to the border\n    if (dist <= maxDist) {\n      return;\n    }\n\n    const panDist = dist - maxDist;\n    const canvasDeltaPos = vec2.sub(\n      vec2.create(),\n      canvasCurrent,\n      canvasCenter\n    ) as Types.Point2;\n\n    vec2.normalize(canvasDeltaPos, canvasDeltaPos);\n    vec2.scale(canvasDeltaPos, canvasDeltaPos, panDist);\n\n    const newCanvasPosition = vec2.add(\n      vec2.create(),\n      this.position,\n      canvasDeltaPos\n    ) as Types.Point2;\n    const currentWorldPos = canvasToWorld(this.position);\n    const newWorldPos = canvasToWorld(newCanvasPosition);\n    const worldDeltaPos = vec3.sub(\n      vec3.create(),\n      newWorldPos,\n      currentWorldPos\n    ) as Types.Point3;\n\n    const autoPanCallbackData: AutoPanCallbackData = {\n      points: {\n        currentPosition: {\n          canvas: this.position,\n          world: currentWorldPos,\n        },\n        newPosition: {\n          canvas: newCanvasPosition,\n          world: newWorldPos,\n        },\n      },\n      delta: {\n        canvas: canvasDeltaPos,\n        world: worldDeltaPos,\n      },\n    };\n\n    autoPan.callback(autoPanCallbackData);\n  }\n\n  private _addBrowserEventListeners(element) {\n    // mousedown on document is handled in the capture phase because the other\n    // mousedown event listener added to the magnifying glass element does not\n    // allow the event to buble up and reach the document.\n    document.addEventListener(\n      'mousedown',\n      this._browserMouseDownCallback,\n      true\n    );\n\n    // All mouse events should not buble up avoiding the source viewport from\n    // handling those events resulting in unexpected behaviors.\n    element.addEventListener('mousedown', this._cancelMouseEventCallback);\n    element.addEventListener('mouseup', this._cancelMouseEventCallback);\n    element.addEventListener('mousemove', this._cancelMouseEventCallback);\n    element.addEventListener('dblclick', this._cancelMouseEventCallback);\n  }\n\n  private _removeBrowserEventListeners(element) {\n    document.removeEventListener(\n      'mousedown',\n      this._browserMouseDownCallback,\n      true\n    );\n    document.removeEventListener('mouseup', this._browserMouseUpCallback);\n\n    element.removeEventListener('mousedown', this._cancelMouseEventCallback);\n    element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n    element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n    element.removeEventListener('dblclick', this._cancelMouseEventCallback);\n  }\n\n  private _addEventListeners(element) {\n    eventTarget.addEventListener(\n      cstEvents.TOOL_MODE_CHANGED,\n      this._handleToolModeChanged\n    );\n\n    element.addEventListener(\n      cstEvents.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n\n    element.addEventListener(\n      cstEvents.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n\n    this._addBrowserEventListeners(element);\n  }\n\n  private _removeEventListeners(element) {\n    eventTarget.removeEventListener(\n      cstEvents.TOOL_MODE_CHANGED,\n      this._handleToolModeChanged\n    );\n\n    element.addEventListener(\n      cstEvents.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n\n    element.addEventListener(\n      cstEvents.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n\n    this._removeBrowserEventListeners(element);\n  }\n\n  private _initialize() {\n    const { _sourceEnabledElement: sourceEnabledElement } = this;\n    const { viewport: sourceViewport } = sourceEnabledElement;\n    const { canvas: sourceCanvas } = sourceViewport;\n    const magnifyElement = this._createViewportNode();\n\n    sourceCanvas.parentNode.appendChild(magnifyElement);\n\n    this._addEventListeners(magnifyElement);\n    this._cloneViewport(sourceViewport, magnifyElement);\n    this._enabledElement = getEnabledElement(magnifyElement);\n  }\n\n  private _syncViewportsCameras(sourceViewport, magnifyViewport) {\n    const worldPos = sourceViewport.canvasToWorld(this.position);\n\n    // Use the original viewport for the base for parallelScale\n    const parallelScale = this._convertZoomFactorToParalellScale(\n      sourceViewport,\n      magnifyViewport,\n      this.zoomFactor\n    );\n\n    const { focalPoint, position, viewPlaneNormal } =\n      magnifyViewport.getCamera();\n\n    const distance = Math.sqrt(\n      Math.pow(focalPoint[0] - position[0], 2) +\n        Math.pow(focalPoint[1] - position[1], 2) +\n        Math.pow(focalPoint[2] - position[2], 2)\n    );\n\n    const updatedFocalPoint = <Types.Point3>[\n      worldPos[0],\n      worldPos[1],\n      worldPos[2],\n    ];\n\n    const updatedPosition = <Types.Point3>[\n      updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n      updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n      updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n    ];\n\n    magnifyViewport.setCamera({\n      parallelScale,\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n  }\n\n  private _syncStackViewports(\n    sourceViewport: Types.IStackViewport,\n    magnifyViewport: Types.IStackViewport\n  ) {\n    magnifyViewport.setImageIdIndex(sourceViewport.getCurrentImageIdIndex());\n  }\n\n  private _syncViewports() {\n    const { viewport: sourceViewport } = this._sourceEnabledElement;\n    const { viewport: magnifyViewport } = this._enabledElement;\n    const sourceProperties = sourceViewport.getProperties();\n\n    magnifyViewport.setProperties(sourceProperties);\n    this._syncViewportsCameras(sourceViewport, magnifyViewport);\n\n    if (this._isStackViewport(sourceViewport)) {\n      this._syncStackViewports(\n        sourceViewport as Types.IStackViewport,\n        magnifyViewport as Types.IStackViewport\n      );\n    }\n  }\n\n  private _resizeViewport() {\n    const { viewport } = this._enabledElement;\n    const renderingEngine = viewport.getRenderingEngine();\n\n    renderingEngine.resize();\n  }\n}\n\nexport { AdvancedMagnifyViewport as default, AdvancedMagnifyViewport };\n","import { vec3 } from 'gl-matrix';\nimport {\n  eventTarget,\n  Enums,\n  getRenderingEngine,\n  CONSTANTS,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { AnnotationRemovedEventType } from '../types/EventTypes';\nimport { Events as cstEvents } from '../enums';\nimport {\n  AdvancedMagnifyViewport,\n  AutoPanCallback,\n} from './AdvancedMagnifyViewport';\nimport { AdvancedMagnifyAnnotation } from '../types/ToolSpecificAnnotationTypes';\n\n// Defined the tool name internally instead of importing\n// AdvangedMagnifyTool due to cyclic dependency\nconst ADVANCED_MAGNIFY_TOOL_NAME = 'AdvancedMagnify';\n\nconst PARALLEL_THRESHOLD = 1 - CONSTANTS.EPSILON;\nconst { Events } = Enums;\n\nexport type MagnifyViewportInfo = {\n  // Viewport id to be used or new v4 compliant GUID is used instead\n  magnifyViewportId?: string;\n  // Enabled element where the magnifying glass shall be added to\n  sourceEnabledElement: Types.IEnabledElement;\n  // Magnifying glass position (center)\n  position: Types.Point2;\n  // Magnifying glass radius (pixels)\n  radius: number;\n  // Amount of magnification applied to the magnifying glass image compared to the source viewport.\n  zoomFactor: number;\n  // Allow panning the viewport when moving an annotation point close to the border of the magnifying glass\n  autoPan: {\n    // Enable or disable auto pan\n    enabled: boolean;\n    // Minimum distance to the border before start auto panning\n    padding: number;\n    // Callback function responsible for updating the annotation (circle)\n    // that contains the magnifying viewport\n    callback: AutoPanCallback;\n  };\n};\n\ntype MagnifyViewportsMapEntry = {\n  annotation: AdvancedMagnifyAnnotation;\n  magnifyViewport: AdvancedMagnifyViewport;\n};\n\n/**\n * Manager responsible for creating, storing and destroying magnifying glass\n * viewports. There are no restrictions to create a new instance of it but it\n * should be accessed through getInstance() method.\n */\nclass AdvancedMagnifyViewportManager {\n  private static _singleton: AdvancedMagnifyViewportManager;\n  private _magnifyViewportsMap: Map<string, MagnifyViewportsMapEntry>;\n\n  constructor() {\n    this._magnifyViewportsMap = new Map();\n    this._initialize();\n  }\n\n  /**\n   * Creates a new magnifying glass viewport manager instance when this method is\n   * called for the first time or return the instance previously created for\n   * any subsequent call (singleton pattern).\n   * @returns A magnifying viewport manager instance\n   */\n  public static getInstance(): AdvancedMagnifyViewportManager {\n    AdvancedMagnifyViewportManager._singleton =\n      AdvancedMagnifyViewportManager._singleton ??\n      new AdvancedMagnifyViewportManager();\n\n    return AdvancedMagnifyViewportManager._singleton;\n  }\n\n  /**\n   * Creates a new magnifying glass viewport instance\n   * @param viewportInfo - Viewport data used when creating a new magnifying glass viewport\n   * @returns A magnifying glass viewport instance\n   */\n  public createViewport = (\n    annotation: AdvancedMagnifyAnnotation,\n    viewportInfo: MagnifyViewportInfo\n  ): AdvancedMagnifyViewport => {\n    const {\n      magnifyViewportId,\n      sourceEnabledElement,\n      position,\n      radius,\n      zoomFactor,\n      autoPan,\n    } = viewportInfo;\n    const { viewport: sourceViewport } = sourceEnabledElement;\n    const { element: sourceElement } = sourceViewport;\n\n    const magnifyViewport = new AdvancedMagnifyViewport({\n      magnifyViewportId,\n      sourceEnabledElement,\n      radius,\n      position,\n      zoomFactor,\n      autoPan,\n    });\n\n    this._addSourceElementEventListener(sourceElement);\n    this._magnifyViewportsMap.set(magnifyViewport.viewportId, {\n      annotation,\n      magnifyViewport,\n    });\n\n    return magnifyViewport;\n  };\n\n  /**\n   * Find and return a magnifying glass viewport based on its id\n   * @param magnifyViewportId - Magnifying glass viewport id\n   * @returns A magnifying glass viewport instance\n   */\n  public getViewport(magnifyViewportId: string): AdvancedMagnifyViewport {\n    return this._magnifyViewportsMap.get(magnifyViewportId)?.magnifyViewport;\n  }\n\n  /**\n   * Release all magnifying glass viewport instances and remove all event\n   * listeners making all objects available to be garbage collected.\n   */\n  public dispose() {\n    this._removeEventListeners();\n    this._destroyViewports();\n  }\n\n  private _destroyViewport(magnifyViewportId: string) {\n    const magnifyViewportMapEntry =\n      this._magnifyViewportsMap.get(magnifyViewportId);\n\n    if (magnifyViewportMapEntry) {\n      const { magnifyViewport } = magnifyViewportMapEntry;\n      const { viewport: sourceViewport } = magnifyViewport.sourceEnabledElement;\n      const { element: sourceElement } = sourceViewport;\n\n      this._removeSourceElementEventListener(sourceElement);\n\n      magnifyViewport.dispose();\n      this._magnifyViewportsMap.delete(magnifyViewportId);\n    }\n  }\n\n  private _destroyViewports() {\n    const magnifyViewportIds = Array.from(this._magnifyViewportsMap.keys());\n\n    magnifyViewportIds.forEach((magnifyViewportId) =>\n      this._destroyViewport(magnifyViewportId)\n    );\n  }\n\n  private _annotationRemovedCallback = (evt: AnnotationRemovedEventType) => {\n    const { annotation } = evt.detail;\n\n    if (annotation.metadata.toolName !== ADVANCED_MAGNIFY_TOOL_NAME) {\n      return;\n    }\n\n    this._destroyViewport(annotation.data.magnifyViewportId);\n  };\n\n  private _getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId) {\n    const magnifyViewportsMapEntries = Array.from(\n      this._magnifyViewportsMap.values()\n    );\n\n    return magnifyViewportsMapEntries.filter(({ magnifyViewport }) => {\n      const { viewport } = magnifyViewport.sourceEnabledElement;\n      return viewport.id === sourceViewportId;\n    });\n  }\n\n  private _newStackImageCallback = (\n    evt: Types.EventTypes.StackNewImageEvent\n  ) => {\n    const { viewportId: sourceViewportId, imageId } = evt.detail;\n    const magnifyViewportsMapEntries =\n      this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n\n    magnifyViewportsMapEntries.forEach(({ annotation }) => {\n      annotation.metadata.referencedImageId = imageId;\n      annotation.invalidated = true;\n    });\n  };\n\n  private _newVolumeImageCallback = (\n    evt: Types.EventTypes.VolumeNewImageEvent\n  ) => {\n    const { renderingEngineId, viewportId: sourceViewportId } = evt.detail;\n    const renderingEngine = getRenderingEngine(renderingEngineId);\n    const sourceViewport = renderingEngine.getViewport(sourceViewportId);\n    const { viewPlaneNormal: currentViewPlaneNormal } =\n      sourceViewport.getCamera();\n\n    const magnifyViewportsMapEntries =\n      this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n\n    magnifyViewportsMapEntries.forEach(({ annotation }) => {\n      const { viewPlaneNormal } = annotation.metadata;\n\n      // Compare the normal to make sure the volume is not rotate in 3D space\n      const isParallel =\n        Math.abs(vec3.dot(viewPlaneNormal, currentViewPlaneNormal)) >\n        PARALLEL_THRESHOLD;\n\n      if (!isParallel) {\n        return;\n      }\n\n      const { handles } = annotation.data;\n      const worldImagePlanePoint = sourceViewport.canvasToWorld([0, 0]);\n      const vecHandleToImagePlane = vec3.sub(\n        vec3.create(),\n        worldImagePlanePoint,\n        handles.points[0]\n      );\n      const worldDist = vec3.dot(vecHandleToImagePlane, currentViewPlaneNormal);\n      const worldDelta = vec3.scale(\n        vec3.create(),\n        currentViewPlaneNormal,\n        worldDist\n      );\n\n      // Move all handle points to the image plane to make the annotation visible\n      for (let i = 0, len = handles.points.length; i < len; i++) {\n        const point = handles.points[i];\n\n        point[0] += worldDelta[0];\n        point[1] += worldDelta[1];\n        point[2] += worldDelta[2];\n      }\n\n      annotation.invalidated = true;\n    });\n  };\n\n  private _addEventListeners() {\n    eventTarget.addEventListener(\n      cstEvents.ANNOTATION_REMOVED,\n      this._annotationRemovedCallback\n    );\n  }\n\n  private _removeEventListeners() {\n    eventTarget.removeEventListener(\n      cstEvents.ANNOTATION_REMOVED,\n      this._annotationRemovedCallback\n    );\n  }\n\n  private _addSourceElementEventListener(element) {\n    element.addEventListener(\n      Events.STACK_NEW_IMAGE,\n      this._newStackImageCallback\n    );\n\n    element.addEventListener(\n      Events.VOLUME_NEW_IMAGE,\n      this._newVolumeImageCallback\n    );\n  }\n\n  private _removeSourceElementEventListener(element) {\n    element.removeEventListener(\n      Events.STACK_NEW_IMAGE,\n      this._newStackImageCallback\n    );\n\n    element.removeEventListener(\n      Events.VOLUME_NEW_IMAGE,\n      this._newVolumeImageCallback\n    );\n  }\n\n  private _initialize() {\n    this._addEventListeners();\n  }\n}\n\nexport {\n  AdvancedMagnifyViewportManager as default,\n  AdvancedMagnifyViewportManager,\n};\n","import { AnnotationTool } from './base';\n\nimport {\n  getEnabledElement,\n  eventTarget,\n  triggerEvent,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n} from '../drawingSvg';\nimport { state } from '../store';\nimport { Events, MouseBindings, KeyboardBindings } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../types';\nimport { AdvancedMagnifyAnnotation } from '../types/ToolSpecificAnnotationTypes';\n\nimport { AnnotationCompletedEventDetail } from '../types/EventTypes';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { getCanvasCircleRadius } from '../utilities/math/circle';\nimport AdvancedMagnifyViewportManager from './AdvancedMagnifyViewportManager';\nimport type { AutoPanCallbackData } from './AdvancedMagnifyViewport';\n\nenum AdvancedMagnifyToolActions {\n  ShowZoomFactorsList = 'showZoomFactorsList',\n}\n\nclass AdvancedMagnifyTool extends AnnotationTool {\n  static toolName;\n  static Actions = AdvancedMagnifyToolActions;\n\n  magnifyViewportManager: AdvancedMagnifyViewportManager;\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        magnifyingGlass: {\n          radius: 125, // px\n          zoomFactor: 2.5,\n          zoomFactorList: [2.5, 3, 3.5, 4, 4.5, 5],\n          autoPan: {\n            enabled: true,\n            padding: 10, // px\n          },\n        },\n        actions: {\n          showZoomFactorsList: {\n            method: 'showZoomFactorsList',\n            bindings: [\n              {\n                mouseButton: MouseBindings.Secondary,\n                modifierKey: KeyboardBindings.Shift,\n              },\n            ],\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.magnifyViewportManager = AdvancedMagnifyViewportManager.getInstance();\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): AdvancedMagnifyAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const { magnifyingGlass: config } = this.configuration;\n    const { radius, zoomFactor, autoPan } = config;\n\n    const worldHandlesPoints = this._getWorldHandlesPoints(\n      viewport,\n      canvasPos,\n      radius\n    );\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotationUID = csUtils.uuidv4();\n    const magnifyViewportId = csUtils.uuidv4();\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: AdvancedMagnifyAnnotation = {\n      annotationUID,\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        sourceViewportId: viewport.id,\n        magnifyViewportId,\n        zoomFactor,\n        handles: {\n          points: worldHandlesPoints,\n          activeHandleIndex: null,\n        },\n      },\n    };\n\n    this.magnifyViewportManager.createViewport(annotation, {\n      magnifyViewportId,\n      sourceEnabledElement: enabledElement,\n      position: canvasPos,\n      radius,\n      zoomFactor,\n      autoPan: {\n        enabled: autoPan.enabled,\n        padding: autoPan.padding,\n        callback: (data: AutoPanCallbackData) => {\n          const annotationPoints = annotation.data.handles.points;\n          const { world: worldDelta } = data.delta;\n\n          for (let i = 0, len = annotationPoints.length; i < len; i++) {\n            annotationPoints[i][0] += worldDelta[0];\n            annotationPoints[i][1] += worldDelta[1];\n            annotationPoints[i][2] += worldDelta[2];\n          }\n        },\n      },\n    });\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    evt.preventDefault();\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  public isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: AdvancedMagnifyAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p)) as [\n      Types.Point2,\n      Types.Point2,\n      Types.Point2,\n      Types.Point2\n    ];\n\n    const canvasTop = canvasCoordinates[0];\n    const canvasBottom = canvasCoordinates[2];\n    const canvasLeft = canvasCoordinates[3];\n    const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n    const center = [\n      canvasLeft[0] + radius,\n      canvasTop[1] + radius,\n    ] as Types.Point2;\n    const radiusPoint = getCanvasCircleRadius([center, canvasCoords]);\n\n    if (Math.abs(radiusPoint - radius) < proximity * 1.5) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: AdvancedMagnifyAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: AdvancedMagnifyAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    const { points } = data.handles;\n    const handleIndex = points.findIndex((p) => p === handle);\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element, deltaPoints } = eventDetail;\n    const worldPosDelta = deltaPoints?.world ?? [0, 0, 0];\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { points } = annotation.data.handles;\n\n    points.forEach((point) => {\n      point[0] += worldPosDelta[0];\n      point[1] += worldPosDelta[1];\n      point[2] += worldPosDelta[2];\n    });\n\n    annotation.invalidated = true;\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n\n    const { annotation } = this.editData;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => worldToCanvas(p));\n    const canvasTop = canvasCoordinates[0];\n    const canvasBottom = canvasCoordinates[2];\n    const canvasLeft = canvasCoordinates[3];\n    const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n    const canvasCenter: Types.Point2 = [\n      canvasLeft[0] + radius,\n      canvasTop[1] + radius,\n    ];\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    const newRadius = getCanvasCircleRadius([\n      canvasCenter,\n      currentCanvasPoints,\n    ]);\n    const newWorldHandlesPoints = this._getWorldHandlesPoints(\n      viewport,\n      canvasCenter,\n      newRadius\n    );\n\n    points[0] = newWorldHandlesPoints[0];\n    points[1] = newWorldHandlesPoints[1];\n    points[2] = newWorldHandlesPoints[2];\n    points[3] = newWorldHandlesPoints[3];\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    return annotation.annotationUID;\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    annotations = annotations?.filter(\n      (annotation) =>\n        (<AdvancedMagnifyAnnotation>annotation).data.sourceViewportId ===\n        viewport.id\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as AdvancedMagnifyAnnotation;\n      const { annotationUID, data } = annotation;\n      const { magnifyViewportId, zoomFactor, handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as Types.Point2[];\n      const canvasTop = canvasCoordinates[0];\n      const canvasBottom = canvasCoordinates[2];\n      const canvasLeft = canvasCoordinates[3];\n      const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n      const center = [\n        canvasLeft[0] + radius,\n        canvasTop[1] + radius,\n      ] as Types.Point2;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-advancedMagnify`;\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        center,\n        radius,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      const magnifyViewport =\n        this.magnifyViewportManager.getViewport(magnifyViewportId);\n\n      magnifyViewport.position = center;\n      magnifyViewport.radius = radius;\n      magnifyViewport.zoomFactor = zoomFactor;\n      magnifyViewport.update();\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  // Basic dropdown component that allows the user to select a different zoom factor.\n  // configurations.actions may be changed to use a customized dropdown.\n  public showZoomFactorsList(\n    evt: EventTypes.InteractionEventType,\n    annotation: AdvancedMagnifyAnnotation\n  ) {\n    const { element, currentPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { canvas: canvasPoint } = currentPoints;\n    const viewportElement = element.querySelector(':scope .viewport-element');\n    const currentZoomFactor = annotation.data.zoomFactor;\n    const remove = () => dropdown.parentElement.removeChild(dropdown);\n\n    const dropdown = this._getZoomFactorsListDropdown(\n      currentZoomFactor,\n      (newZoomFactor) => {\n        if (newZoomFactor !== undefined) {\n          annotation.data.zoomFactor = Number.parseFloat(newZoomFactor);\n          annotation.invalidated = true;\n        }\n\n        remove();\n        viewport.render();\n      }\n    );\n\n    Object.assign(dropdown.style, {\n      left: `${canvasPoint[0]}px`,\n      top: `${canvasPoint[1]}px`,\n    });\n\n    viewportElement.appendChild(dropdown);\n    dropdown.focus();\n  }\n\n  private _getZoomFactorsListDropdown(currentZoomFactor, onChangeCallback) {\n    const { zoomFactorList } = this.configuration.magnifyingGlass;\n    const dropdown = document.createElement('select');\n\n    dropdown.size = 5;\n    Object.assign(dropdown.style, {\n      width: '50px',\n      position: 'absolute',\n    });\n\n    ['mousedown', 'mouseup', 'mousemove', 'click'].forEach((eventName) => {\n      dropdown.addEventListener(eventName, (evt) => evt.stopPropagation());\n    });\n\n    dropdown.addEventListener('change', (evt) => {\n      evt.stopPropagation();\n      onChangeCallback(dropdown.value);\n    });\n\n    dropdown.addEventListener('keydown', (evt) => {\n      const shouldCancel =\n        (evt.keyCode ?? evt.which === 27) ||\n        evt.key?.toLowerCase() === 'escape';\n\n      if (shouldCancel) {\n        evt.stopPropagation();\n        onChangeCallback();\n      }\n    });\n\n    zoomFactorList.forEach((zoomFactor) => {\n      const option = document.createElement('option');\n\n      option.label = zoomFactor;\n      option.title = `Zoom factor ${zoomFactor.toFixed(1)}`;\n      option.value = zoomFactor;\n      option.defaultSelected = zoomFactor === currentZoomFactor;\n\n      dropdown.add(option);\n    });\n\n    return dropdown;\n  }\n\n  private _getWorldHandlesPoints = (\n    viewport,\n    canvasCenterPos,\n    canvasRadius\n  ): Types.Point3[] => {\n    const canvasHandlesPoints = [\n      [canvasCenterPos[0], canvasCenterPos[1] - canvasRadius], // top\n      [canvasCenterPos[0] + canvasRadius, canvasCenterPos[1]], // right\n      [canvasCenterPos[0], canvasCenterPos[1] + canvasRadius], // bottom\n      [canvasCenterPos[0] - canvasRadius, canvasCenterPos[1]], // left\n    ];\n\n    const worldHandlesPoints = canvasHandlesPoints.map((p) =>\n      viewport.canvasToWorld(p)\n    ) as Types.Point3[];\n\n    return worldHandlesPoints;\n  };\n}\n\nAdvancedMagnifyTool.toolName = 'AdvancedMagnify';\n\nexport { AdvancedMagnifyTool as default };\n","import {\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  utilities,\n  getEnabledElementByIds,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { drawLine } from '../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  EventTypes,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  Annotation,\n  Annotations,\n} from '../types';\nimport { ReferenceCursor } from '../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { vec3 } from 'gl-matrix';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../cursors/elementCursor';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\n/**\n * ReferenceCursors is a tool that will show your cursors position in all other elements in the toolGroup if they have a matching FrameOfReference relative to its position in world space.\n * Also when positionSync is enabled, it will try to sync viewports so that the cursor can be displayed in the correct position in all viewports.\n *\n * Configuration:\n * - positionSync: boolean, if true, it will try to sync viewports so that the cursor can be displayed in the correct position in all viewports.\n * - disableCursor: boolean, if true, it will hide the cursor in all viewports. You need to disable and reactivate the tool for this to apply.\n * - displayThreshold: number, if the distance of the cursor in a viewport is bigger than this threshold the cursor will not be displayed.\n *\n * Only uses Active and Disabled state\n */\nclass ReferenceCursors extends AnnotationDisplayTool {\n  static toolName;\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  isDrawing = false;\n  isHandleOutsideImage = false;\n  _elementWithCursor: null | HTMLDivElement = null;\n  _currentCursorWorldPosition: null | Types.Point3 = null;\n  _currentCanvasPosition: null | Types.Point2 = null;\n  //need to keep track if this was enabled when tool was enabled because we need to know if we should reset cursors\n  _disableCursorEnabled = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        displayThreshold: 5,\n        positionSync: true,\n        disableCursor: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this._disableCursorEnabled = this.configuration.disableCursor;\n  }\n\n  /**\n   * Overwritten mouseMoveCallback since we want to keep track of the current mouse position and redraw on mouseMove\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\n   *\n   *\n   * @param evt - The normalized mouse event\n   * @param filteredAnnotations - The annotations to check for hover interactions\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\n   */\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const { detail } = evt;\n    const { element, currentPoints } = detail;\n\n    //save current positions and current element the curser is hovering over\n    this._currentCursorWorldPosition = currentPoints.world;\n    this._currentCanvasPosition = currentPoints.canvas;\n    this._elementWithCursor = element;\n\n    const annotation = this.getActiveAnnotation(element);\n    if (annotation === null) {\n      this.createInitialAnnotation(currentPoints.world, element);\n      return false;\n    }\n    this.updateAnnotationPosition(element, annotation);\n    return false;\n  };\n\n  onSetToolActive(): void {\n    this._disableCursorEnabled = this.configuration.disableCursor;\n    if (!this._disableCursorEnabled) {\n      return;\n    }\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n    if (!viewportIds) {\n      return;\n    }\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n\n    enabledElements.forEach((element) => {\n      if (element) {\n        hideElementCursor(element.viewport.element);\n      }\n    });\n  }\n  onSetToolDisabled(): void {\n    if (!this._disableCursorEnabled) {\n      return;\n    }\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n    if (!viewportIds) {\n      return;\n    }\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n    enabledElements.forEach((element) => {\n      if (element) {\n        resetElementCursor(element.viewport.element);\n      }\n    });\n  }\n\n  createInitialAnnotation = (\n    worldPos: Types.Point3,\n    element: HTMLDivElement\n  ): void => {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n      throw new Error('No enabled element found');\n    }\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    if (!viewPlaneNormal || !viewUp) {\n      throw new Error('Camera not found');\n    }\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          points: [[...worldPos]] as [Types.Point3],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n      },\n    };\n\n    const annotations = getAnnotations(this.getToolName(), element);\n\n    if (annotations.length > 0) {\n      return null;\n    }\n    const annotationId = addAnnotation(annotation, element);\n\n    if (annotationId === null) {\n      return;\n    }\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  getActiveAnnotation(element: HTMLDivElement): null | Annotation {\n    const annotations = getAnnotations(this.getToolName(), element);\n    if (!annotations.length) {\n      return null;\n    }\n    const targetAnnotation = annotations[0];\n    return targetAnnotation;\n  }\n\n  /**\n   * updates the position of the annotation to match the currently set world position\n   */\n  updateAnnotationPosition(\n    element: HTMLDivElement,\n    annotation: Annotation\n  ): void {\n    const worldPos = this._currentCursorWorldPosition;\n    if (!worldPos) {\n      return;\n    }\n    if (!annotation.data?.handles?.points) {\n      return;\n    }\n    annotation.data.handles.points = [[...worldPos]];\n    annotation.invalidated = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n      return;\n    }\n    const { renderingEngine } = enabledElement;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  }\n\n  //checks if we need to update the annotation position due to camera changes\n  onCameraModified = (evt: any): void => {\n    const eventDetail = evt.detail;\n    const { element, previousCamera, camera } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const viewport = enabledElement.viewport as\n      | Types.IVolumeViewport\n      | Types.IStackViewport;\n\n    //only react to changes for element with cursor, otherwise would cause infinite loop\n    if (element !== this._elementWithCursor) {\n      return;\n    }\n    //check if camera moved along its normal\n    const oldFocalPoint = previousCamera.focalPoint;\n    const cameraNormal = camera.viewPlaneNormal;\n    const newFocalPoint = camera.focalPoint;\n\n    const deltaCameraFocalPoint: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);\n    //check if focal point changed\n    if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0) {\n      return;\n    }\n    //if nomrmal is perpendicular to focal point change, then we are not moving along the normal\n    const dotProduct = vtkMath.dot(deltaCameraFocalPoint, cameraNormal);\n    //dot product is 0 -> perpendicular\n    if (Math.abs(dotProduct) < 1e-2) {\n      return;\n    }\n\n    //need to update the position of the annotation since camera changed\n    if (!this._currentCanvasPosition) {\n      return;\n    }\n\n    const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);\n    this._currentCursorWorldPosition = newWorldPos;\n    this.updateAnnotationPosition(element, this.getActiveAnnotation(element));\n  };\n\n  //display annotation if current viewing plane has a max distance of \"displayThreshold\" from the annotation\n  filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations {\n    //calculate distance of current viewport to annotation\n    if (!(annotations instanceof Array) || annotations.length === 0) {\n      return [];\n    }\n    const annotation = annotations[0];\n    const viewport = getEnabledElement(element)?.viewport;\n    if (!viewport) {\n      return [];\n    }\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, focalPoint } = camera;\n    if (!viewPlaneNormal || !focalPoint) {\n      return [];\n    }\n    const points = annotation.data?.handles?.points;\n    if (!(points instanceof Array) || points.length !== 1) {\n      return [];\n    }\n    const worldPos = points[0];\n    const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n    const distance = utilities.planar.planeDistanceToPoint(plane, worldPos);\n    return distance < this.configuration.displayThreshold ? [annotation] : [];\n  }\n\n  /**\n   * Draws the cursor representation on the enabledElement\n   * Checks if a stack change has happened and updates annotation in that case\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, FrameOfReferenceUID } = enabledElement;\n\n    const isElementWithCursor = this._elementWithCursor === viewport.element;\n\n    //update stack position if position sync is enabled\n    if (this.configuration.positionSync && !isElementWithCursor) {\n      this.updateViewportImage(viewport);\n    }\n\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    //the viewport change from updateStackPosition might not be applied yet, so sometimes the annotation might not be immediately visible\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    ) as Annotations;\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ReferenceCursor;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points } = handles;\n\n      if (!annotationUID) {\n        return renderStatus;\n      }\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidthBase = parseFloat(\n        this.getStyle('lineWidth', styleSpecifier, annotation) as string\n      );\n\n      const lineWidth =\n        typeof lineWidthBase === 'number' && isElementWithCursor\n          ? lineWidthBase\n          : lineWidthBase;\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      if (points[0].some((e) => isNaN(e))) {\n        return renderStatus;\n      }\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2];\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      const crosshairUIDs = {\n        upper: 'upper',\n        right: 'right',\n        lower: 'lower',\n        left: 'left',\n      };\n      const [x, y] = canvasCoordinates[0];\n      const centerSpace = isElementWithCursor ? 20 : 7;\n      const lineLength = isElementWithCursor ? 5 : 7;\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.upper,\n        [x, y - (centerSpace / 2 + lineLength)],\n        [x, y - centerSpace / 2],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.lower,\n        [x, y + (centerSpace / 2 + lineLength)],\n        [x, y + centerSpace / 2],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.right,\n        [x + (centerSpace / 2 + lineLength), y],\n        [x + centerSpace / 2, y],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.left,\n        [x - (centerSpace / 2 + lineLength), y],\n        [x - centerSpace / 2, y],\n        { color, lineDash, lineWidth }\n      );\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  updateViewportImage(\n    viewport: Types.IStackViewport | Types.IVolumeViewport\n  ): void {\n    const currentMousePosition = this._currentCursorWorldPosition;\n\n    if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e))) {\n      return;\n    }\n\n    if (viewport instanceof StackViewport) {\n      const closestIndex = utilities.getClosestStackImageIndexForPoint(\n        currentMousePosition,\n        viewport\n      );\n\n      if (closestIndex === null) {\n        return;\n      }\n      if (closestIndex !== viewport.getCurrentImageIdIndex()) {\n        viewport.setImageIdIndex(closestIndex);\n      }\n    } else if (viewport instanceof VolumeViewport) {\n      const { focalPoint, viewPlaneNormal } = viewport.getCamera();\n      if (!focalPoint || !viewPlaneNormal) {\n        return;\n      }\n      const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n      const currentDistance = utilities.planar.planeDistanceToPoint(\n        plane,\n        currentMousePosition,\n        true\n      );\n\n      if (Math.abs(currentDistance) < 0.5) {\n        return;\n      }\n      const normalizedViewPlane = vec3.normalize(\n        vec3.create(),\n        vec3.fromValues(...viewPlaneNormal)\n      );\n      const scaledPlaneNormal = vec3.scale(\n        vec3.create(),\n        normalizedViewPlane,\n        currentDistance\n      );\n      const newFocalPoint = vec3.add(\n        vec3.create(),\n        vec3.fromValues(...focalPoint),\n        scaledPlaneNormal\n      ) as Types.Point3;\n      //TODO: make check if new focal point is within bounds of volume\n      const isInBounds = true;\n      if (isInBounds) {\n        viewport.setCamera({ focalPoint: newFocalPoint });\n        const renderingEngine = viewport.getRenderingEngine();\n        if (renderingEngine) {\n          renderingEngine.renderViewport(viewport.id);\n        }\n      }\n    }\n  }\n}\n\nReferenceCursors.toolName = 'ReferenceCursors';\nexport default ReferenceCursors;\n","import AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { vec3 } from 'gl-matrix';\nimport {\n  getEnabledElementByIds,\n  getRenderingEngines,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { ScaleOverlayAnnotation } from '../types/ToolSpecificAnnotationTypes';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport {\n  drawLine as drawLineSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../drawingSvg';\nimport {\n  EventTypes,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../types';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\nconst SCALEOVERLAYTOOL_ID = 'scaleoverlay-viewport';\nconst viewportsWithAnnotations = [];\n\n/**\n * @public\n * @class ScaleOverlayTool\n * @memberof Tools\n *\n * @classdesc Tool for displaying a scale overlay on the image.\n * @extends Tools.Base.BaseTool\n */\nclass ScaleOverlayTool extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    renderingEngine: any;\n    viewport: any;\n    annotation: ScaleOverlayAnnotation;\n  } | null = {} as any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        viewportId: '',\n        scaleLocation: 'bottom',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  _init = (): void => {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    if (!renderingEngine) {\n      return;\n    }\n\n    // get viewports with tool enabled\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    if (!viewportIds) {\n      return;\n    }\n\n    // get enabled elements\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n\n    let { viewport } = enabledElements[0];\n    const { FrameOfReferenceUID } = enabledElements[0];\n\n    // onCameraModified, configuration.viewportId is set to the active\n    // viewport Id, here we are setting the viewport variable to the\n    // viewport with the matching Id\n    if (this.configuration.viewportId) {\n      enabledElements.forEach((element) => {\n        if (element.viewport.id == this.configuration.viewportId) {\n          viewport = element.viewport;\n        }\n      });\n    }\n\n    if (!viewport) {\n      return;\n    }\n\n    const { viewUp, viewPlaneNormal } = viewport.getCamera();\n\n    const viewportCanvasCornersInWorld =\n      csUtils.getViewportImageCornersInWorld(viewport);\n\n    let annotation = this.editData.annotation;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    // if annotations have been created, get the annotation for the\n    // current viewport Id\n    if (annotations.length) {\n      annotation = annotations.filter(\n        (thisAnnotation) => thisAnnotation.data.viewportId == viewport.id\n      )[0] as ScaleOverlayAnnotation;\n    }\n\n    // viewportsWithAnnotations stores which viewports have an annotation,\n    // if the viewport does not have an annotation, create a new one\n    if (!viewportsWithAnnotations.includes(viewport.id)) {\n      const newAnnotation: ScaleOverlayAnnotation = {\n        metadata: {\n          toolName: this.getToolName(),\n          viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n          viewUp: <Types.Point3>[...viewUp],\n          FrameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          handles: {\n            points: viewportCanvasCornersInWorld,\n          },\n          viewportId: viewport.id,\n        },\n      };\n\n      viewportsWithAnnotations.push(viewport.id);\n\n      addAnnotation(newAnnotation, viewport.element);\n      annotation = newAnnotation;\n    } else if (this.editData.annotation.data.viewportId == viewport.id) {\n      this.editData.annotation.data.handles.points =\n        viewportCanvasCornersInWorld;\n      this.editData.annotation.data.viewportId = viewport.id;\n    }\n\n    this.editData = {\n      viewport,\n      renderingEngine,\n      annotation,\n    };\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    // If the camera is modified, we need to update the viewport\n    // that the camera was modified on\n    this.configuration.viewportId = evt.detail.viewportId;\n    this._init();\n  };\n\n  /**\n   * Used to draw the scale annotation in each request animation\n   * frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   * @returns\n   */\n\n  renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ) {\n    if (!this.editData.viewport) {\n      return;\n    }\n    const location = this.configuration.scaleLocation;\n    const { viewport } = enabledElement;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n    const annotation = annotations.filter(\n      (thisAnnotation) => thisAnnotation.data.viewportId == viewport.id\n    )[0];\n    const canvas = enabledElement.viewport.canvas;\n\n    const renderStatus = false;\n\n    if (!viewport) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const canvasSize = {\n      width: canvas.width,\n      height: canvas.height,\n    };\n\n    const topLeft = annotation.data.handles.points[0];\n    const topRight = annotation.data.handles.points[1];\n    const bottomLeft = annotation.data.handles.points[2];\n    const bottomRight = annotation.data.handles.points[3];\n\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n\n    const worldWidthViewport = vec3.distance(bottomLeft, bottomRight);\n    const worldHeightViewport = vec3.distance(topLeft, bottomLeft);\n\n    // hscaleBounds and vscaleBounds compute the max bound for scales on the image\n    const hscaleBounds = this.computeScaleBounds(\n      canvasSize,\n      0.05,\n      0.05,\n      location\n    );\n\n    const vscaleBounds = this.computeScaleBounds(\n      canvasSize,\n      0.05,\n      0.05,\n      location\n    );\n\n    // Computes which scale size to use, ex: 100mm, 50mm\n    const scaleSize = this.computeScaleSize(\n      worldWidthViewport,\n      worldHeightViewport,\n      location\n    );\n\n    // Applies the scale with the predetermined size to the image in\n    // world coordinates, then converts them to canvas coordinates\n    const canvasCoordinates = this.computeWorldScaleCoordinates(\n      scaleSize,\n      location,\n      pointSet1\n    ).map((world) => viewport.worldToCanvas(world));\n\n    // Uses the bounds and canvas size to center the scale\n    // based on the location\n    const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(\n      canvasSize,\n      canvasCoordinates,\n      vscaleBounds,\n      hscaleBounds,\n      location\n    );\n\n    // Computes the end scale ticks coordinates\n    const scaleTicks = this.computeEndScaleTicks(\n      scaleCanvasCoordinates,\n      location\n    );\n\n    const { annotationUID } = annotation;\n\n    styleSpecifier.annotationUID = annotationUID;\n    const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n    const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n    const color = this.getStyle('color', styleSpecifier, annotation);\n    const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n    const scaleId = `${annotationUID}-scaleline`;\n    const scaleLineUID = '1';\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      scaleLineUID,\n      scaleCanvasCoordinates[0],\n      scaleCanvasCoordinates[1],\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      scaleId\n    );\n    const leftTickId = `${annotationUID}-left`;\n    const leftTickUID = '2';\n\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      leftTickUID,\n      scaleTicks.endTick1[0] as Types.Point2,\n      scaleTicks.endTick1[1] as Types.Point2,\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      leftTickId\n    );\n    const rightTickId = `${annotationUID}-right`;\n    const rightTickUID = '3';\n\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      rightTickUID,\n      scaleTicks.endTick2[0] as Types.Point2,\n      scaleTicks.endTick2[1] as Types.Point2,\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      rightTickId\n    );\n\n    const locationTextOffest = {\n      bottom: [-10, -42],\n      top: [-12, -35],\n      left: [-40, -20],\n      right: [-50, -20],\n    };\n\n    const textCanvasCoordinates = [\n      scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],\n      scaleCanvasCoordinates[0][1] + locationTextOffest[location][1],\n    ];\n    const textBoxLines = this._getTextLines(scaleSize);\n\n    const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(\n      scaleSize,\n      location,\n      annotationUID,\n      scaleTicks.endTick1,\n      scaleTicks.endTick2\n    );\n\n    // draws inner ticks for scale\n    for (let i = 0; i < tickUIDs.length; i++) {\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        tickUIDs[i],\n        tickCoordinates[i][0],\n        tickCoordinates[i][1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        tickIds[i]\n      );\n    }\n\n    const textUID = 'text0';\n    drawTextBoxSvg(\n      svgDrawingHelper,\n      annotationUID,\n      textUID,\n      textBoxLines,\n      [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n      {\n        fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n        fontSize: '14px',\n        lineDash: '2,3',\n        lineWidth: '1',\n        shadow: true,\n        color: color,\n      }\n    );\n\n    return renderStatus;\n  }\n\n  _getTextLines(scaleSize: number): string[] | undefined {\n    let scaleSizeDisplayValue;\n    let scaleSizeUnits;\n    if (scaleSize >= 50) {\n      scaleSizeDisplayValue = scaleSize / 10; //convert to cm\n      scaleSizeUnits = ' cm';\n    } else {\n      scaleSizeDisplayValue = scaleSize; //convert to cm\n      scaleSizeUnits = ' mm';\n    }\n\n    const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];\n\n    return textLines;\n  }\n\n  /**\n   *\n   * @param worldWidthViewport\n   * @returns currentScaleSize\n   */\n  computeScaleSize = (\n    worldWidthViewport: number,\n    worldHeightViewport: number,\n    location: any\n  ) => {\n    const scaleSizes = [\n      16000, 8000, 4000, 2000, 1000, 500, 250, 100, 50, 25, 10, 5, 2,\n    ];\n    let currentScaleSize;\n    if (location == 'top' || location == 'bottom') {\n      currentScaleSize = scaleSizes.filter(\n        (scaleSize) =>\n          scaleSize < worldWidthViewport * 0.6 &&\n          scaleSize > worldWidthViewport * 0.2\n      );\n    } else {\n      currentScaleSize = scaleSizes.filter(\n        (scaleSize) =>\n          scaleSize < worldHeightViewport * 0.6 &&\n          scaleSize > worldHeightViewport * 0.2\n      );\n    }\n\n    return currentScaleSize[0];\n  };\n\n  /**\n   *  calculates scale ticks for ends of the scale\n   * @param canvasCoordinates\n   * @returns leftTick, rightTick\n   */\n  computeEndScaleTicks = (canvasCoordinates, location) => {\n    const locationTickOffset = {\n      bottom: [\n        [0, -10],\n        [0, -10],\n      ],\n      top: [\n        [0, 10],\n        [0, 10],\n      ],\n      left: [\n        [0, 0],\n        [10, 0],\n      ],\n      right: [\n        [0, 0],\n        [-10, 0],\n      ],\n    };\n\n    const endTick1 = [\n      [\n        canvasCoordinates[1][0] + locationTickOffset[location][0][0],\n        canvasCoordinates[1][1] + locationTickOffset[location][0][0],\n      ],\n      [\n        canvasCoordinates[1][0] + locationTickOffset[location][1][0],\n        canvasCoordinates[1][1] + locationTickOffset[location][1][1],\n      ],\n    ];\n    const endTick2 = [\n      [\n        canvasCoordinates[0][0] + locationTickOffset[location][0][0],\n        canvasCoordinates[0][1] + locationTickOffset[location][0][0],\n      ],\n      [\n        canvasCoordinates[0][0] + locationTickOffset[location][1][0],\n        canvasCoordinates[0][1] + locationTickOffset[location][1][1],\n      ],\n    ];\n\n    return {\n      endTick1: endTick1,\n      endTick2: endTick2,\n    };\n  };\n\n  computeInnerScaleTicks = (\n    scaleSize: number,\n    location: string,\n    annotationUID: string,\n    leftTick: any[][],\n    rightTick: any[][]\n  ) => {\n    let canvasScaleSize;\n    if (location == 'bottom' || location == 'top') {\n      canvasScaleSize = rightTick[0][0] - leftTick[0][0];\n    } else if (location == 'left' || location == 'right') {\n      canvasScaleSize = rightTick[0][1] - leftTick[0][1];\n    }\n    const tickIds = [];\n    const tickUIDs = [];\n    const tickCoordinates = [];\n    let numberSmallTicks = scaleSize;\n\n    if (scaleSize >= 50) {\n      numberSmallTicks = scaleSize / 10;\n    }\n\n    const tickSpacing = canvasScaleSize / numberSmallTicks;\n\n    for (let i = 0; i < numberSmallTicks - 1; i++) {\n      const locationOffset = {\n        bottom: [\n          [tickSpacing * (i + 1), 0],\n          [tickSpacing * (i + 1), 5],\n        ],\n        top: [\n          [tickSpacing * (i + 1), 0],\n          [tickSpacing * (i + 1), -5],\n        ],\n        left: [\n          [0, tickSpacing * (i + 1)],\n          [-5, tickSpacing * (i + 1)],\n        ],\n        right: [\n          [0, tickSpacing * (i + 1)],\n          [5, tickSpacing * (i + 1)],\n        ],\n      };\n      tickIds.push(`${annotationUID}-tick${i}`);\n      tickUIDs.push(`tick${i}`);\n      if ((i + 1) % 5 == 0) {\n        tickCoordinates.push([\n          [\n            leftTick[0][0] + locationOffset[location][0][0],\n            leftTick[0][1] + locationOffset[location][0][1],\n          ],\n          [\n            leftTick[1][0] + locationOffset[location][0][0],\n            leftTick[1][1] + locationOffset[location][0][1],\n          ],\n        ]);\n      } else {\n        tickCoordinates.push([\n          [\n            leftTick[0][0] + locationOffset[location][0][0],\n            leftTick[0][1] + locationOffset[location][0][1],\n          ],\n          [\n            leftTick[1][0] + locationOffset[location][1][0],\n            leftTick[1][1] + locationOffset[location][1][1],\n          ],\n        ]);\n      }\n    }\n\n    return { tickIds, tickUIDs, tickCoordinates };\n  };\n\n  computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {\n    let worldCoordinates;\n    let topBottomVec = vec3.subtract(vec3.create(), pointSet[0], pointSet[1]);\n    topBottomVec = vec3.normalize(vec3.create(), topBottomVec) as Types.Point3;\n\n    let topRightVec = vec3.subtract(vec3.create(), pointSet[2], pointSet[0]);\n    topRightVec = vec3.normalize(vec3.create(), topRightVec);\n\n    const midpointLocation = {\n      bottom: [pointSet[1], pointSet[2]],\n      top: [pointSet[0], pointSet[3]],\n      right: [pointSet[2], pointSet[3]],\n      left: [pointSet[0], pointSet[1]],\n    };\n\n    const midpoint = vec3\n      .add(\n        vec3.create(),\n        midpointLocation[location][0],\n        midpointLocation[location][0]\n      )\n      .map((i) => i / 2) as Types.Point3;\n\n    const offset =\n      scaleSize /\n      2 /\n      Math.sqrt(\n        Math.pow(topBottomVec[0], 2) +\n          Math.pow(topBottomVec[1], 2) +\n          Math.pow(topBottomVec[2], 2)\n      );\n\n    if (location == 'top' || location == 'bottom') {\n      worldCoordinates = [\n        vec3.subtract(\n          vec3.create(),\n          midpoint,\n          topRightVec.map((i) => i * offset) as Types.Point3\n        ),\n        vec3.add(\n          vec3.create(),\n          midpoint,\n          topRightVec.map((i) => i * offset) as Types.Point3\n        ),\n      ];\n    } else if (location == 'left' || location == 'right') {\n      worldCoordinates = [\n        vec3.add(\n          vec3.create(),\n          midpoint,\n          topBottomVec.map((i) => i * offset) as Types.Point3\n        ),\n        vec3.subtract(\n          vec3.create(),\n          midpoint,\n          topBottomVec.map((i) => i * offset) as Types.Point3\n        ),\n      ];\n    }\n\n    return worldCoordinates;\n  };\n\n  /**\n   * Computes the centered canvas coordinates for scale\n   * @param canvasSize\n   * @param canvasCoordinates\n   * @param vscaleBounds\n   * @returns scaleCanvasCoordinates\n   */\n  computeCanvasScaleCoordinates = (\n    canvasSize,\n    canvasCoordinates,\n    vscaleBounds,\n    hscaleBounds,\n    location\n  ) => {\n    let scaleCanvasCoordinates;\n    if (location == 'top' || location == 'bottom') {\n      const worldDistanceOnCanvas =\n        canvasCoordinates[0][0] - canvasCoordinates[1][0];\n      scaleCanvasCoordinates = [\n        [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],\n        [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height],\n      ];\n    } else if (location == 'left' || location == 'right') {\n      const worldDistanceOnCanvas =\n        canvasCoordinates[0][1] - canvasCoordinates[1][1];\n      scaleCanvasCoordinates = [\n        [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],\n        [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2],\n      ];\n    }\n\n    return scaleCanvasCoordinates;\n  };\n\n  /**\n   * Computes the max bound for scales on the image\n   * @param  {{width: number, height: number}} canvasSize\n   * @param  {number} horizontalReduction\n   * @param  {number} verticalReduction\n   * @returns {Object.<string, { x:number, y:number }>}\n   */\n  computeScaleBounds = (\n    canvasSize,\n    horizontalReduction,\n    verticalReduction,\n    location\n  ) => {\n    const hReduction = horizontalReduction * Math.min(1000, canvasSize.width);\n    const vReduction = verticalReduction * Math.min(1000, canvasSize.height);\n    const locationBounds = {\n      bottom: [-vReduction, -hReduction],\n      top: [vReduction, hReduction],\n      left: [vReduction, hReduction],\n      right: [-vReduction, -hReduction],\n    };\n    const canvasBounds = {\n      bottom: [canvasSize.height, canvasSize.width],\n      top: [0, canvasSize.width],\n      left: [canvasSize.height, 0],\n      right: [canvasSize.height, canvasSize.width],\n    };\n\n    return {\n      height: canvasBounds[location][0] + locationBounds[location][0],\n      width: canvasBounds[location][1] + locationBounds[location][1],\n    };\n  };\n}\n\nScaleOverlayTool.toolName = 'ScaleOverlay';\nexport default ScaleOverlayTool;\n","import { utilities as csUtils, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getBoundingBoxAroundShapeIJK,\n  getBoundingBoxAroundShapeWorld,\n} from '../../../utilities/boundingBox';\nimport { pointInShapeCallback } from '../../../utilities';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { LabelmapToolOperationData } from '../../../types';\nimport { getStrategyData } from './utils/getStrategyData';\nimport { isAxisAlignedRectangle } from '../../../utilities/rectangleROITool/isAxisAlignedRectangle';\n\nconst { transformWorldToIndex } = csUtils;\n\ntype OperationData = LabelmapToolOperationData & {\n  points: [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n};\n\n/**\n * For each point in the bounding box around the rectangle, if the point is inside\n * the rectangle, set the scalar value to the segmentIndex\n * @param toolGroupId - string\n * @param operationData - OperationData\n * @param inside - boolean\n */\n// Todo: why we have another constraintFn? in addition to the one in the operationData?\nfunction fillRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData,\n  inside = true\n): void {\n  const { points, segmentsLocked, segmentIndex, segmentationId } =\n    operationData;\n\n  const { viewport } = enabledElement;\n  const strategyData = getStrategyData({\n    operationData,\n    viewport: enabledElement.viewport,\n  });\n\n  if (!strategyData) {\n    console.warn('No data found for fillRectangle');\n    return;\n  }\n\n  const { segmentationImageData, segmentationScalarData } = strategyData;\n\n  let rectangleCornersIJK = points.map((world) => {\n    return transformWorldToIndex(segmentationImageData, world);\n  });\n\n  // math round\n  rectangleCornersIJK = rectangleCornersIJK.map((point) => {\n    return point.map((coord) => {\n      return Math.round(coord);\n    });\n  });\n\n  const boundsIJK = getBoundingBoxAroundShapeIJK(\n    rectangleCornersIJK,\n    segmentationImageData.getDimensions()\n  );\n\n  const isStackViewport = viewport instanceof StackViewport;\n\n  // Are we working with 2D rectangle in axis aligned viewport view or not\n  const isAligned =\n    isStackViewport || isAxisAlignedRectangle(rectangleCornersIJK);\n\n  const direction = segmentationImageData.getDirection();\n  const spacing = segmentationImageData.getSpacing();\n  const { viewPlaneNormal } = viewport.getCamera();\n\n  // In case that we are working on oblique, our EPS is really the spacing in the\n  // normal direction, since we can't really test each voxel against a 2D rectangle\n  // we need some tolerance in the normal direction.\n  const EPS = csUtils.getSpacingInNormalDirection(\n    {\n      direction,\n      spacing,\n    },\n    viewPlaneNormal\n  );\n\n  const pointsBoundsLPS = getBoundingBoxAroundShapeWorld(points);\n  let [[xMin, xMax], [yMin, yMax], [zMin, zMax]] = pointsBoundsLPS;\n\n  // Update the bounds with +/- EPS\n  xMin -= EPS;\n  xMax += EPS;\n  yMin -= EPS;\n  yMax += EPS;\n  zMin -= EPS;\n  zMax += EPS;\n\n  const pointInShapeFn = isAligned\n    ? () => true\n    : (pointLPS) => {\n        const [x, y, z] = pointLPS;\n        const xInside = x >= xMin && x <= xMax;\n        const yInside = y >= yMin && y <= yMax;\n        const zInside = z >= zMin && z <= zMax;\n\n        return xInside && yInside && zInside;\n      };\n\n  const callback = ({ value, index }) => {\n    if (segmentsLocked.includes(value)) {\n      return;\n    }\n\n    segmentationScalarData[index] = segmentIndex;\n  };\n\n  pointInShapeCallback(\n    segmentationImageData,\n    pointInShapeFn,\n    callback,\n    boundsIJK\n  );\n\n  triggerSegmentationDataModified(segmentationId);\n}\n\n/**\n * Fill the inside of a rectangle\n * @param toolGroupId - The unique identifier of the tool group.\n * @param operationData - The data that will be used to create the\n * new rectangle.\n */\nexport function fillInsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  fillRectangle(enabledElement, operationData, true);\n}\n\n/**\n * Fill the area outside of a rectangle for the toolGroupId and segmentationRepresentationUID.\n * @param toolGroupId - The unique identifier of the tool group.\n * @param operationData - The data that will be used to create the\n * new rectangle.\n */\nexport function fillOutsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  fillRectangle(enabledElement, operationData, false);\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport { LabelmapToolOperationData } from '../../../types';\nimport { fillInsideRectangle } from './fillRectangle';\n\ntype OperationData = LabelmapToolOperationData & {\n  points: [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n};\n\nfunction eraseRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData,\n  inside = true\n): void {\n  // Take the arguments and set the segmentIndex to 0,\n  // Then use existing fillRectangle functionality.\n  const eraseOperationData = Object.assign({}, operationData, {\n    segmentIndex: 0,\n  });\n\n  fillInsideRectangle(enabledElement, eraseOperationData);\n}\n\n/**\n * Erase the rectangle region segment inside the segmentation defined by the operationData.\n * It erases the segmentation pixels inside the defined rectangle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - OperationData\n */\nexport function eraseInsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  eraseRectangle(enabledElement, operationData, true);\n}\n\n/**\n * Erase the rectangle region segment inside the segmentation defined by the operationData.\n * It erases the segmentation pixels outside the defined rectangle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - OperationData\n */\nexport function eraseOutsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  eraseRectangle(enabledElement, operationData, false);\n}\n","import { cache, getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { fillInsideRectangle } from './strategies/fillRectangle';\nimport { eraseInsideRectangle } from './strategies/eraseRectangle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\n\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawRect as drawRectSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { LabelmapSegmentationData } from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\n/**\n * Tool for manipulating segmentation data by drawing a rectangle. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex.\n */\nclass RectangleScissorsTool extends BaseTool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    //\n    imageIdReferenceMap: Map<string, string>;\n    volumeId: string;\n    referencedVolumeId: string;\n    //\n    annotation: any;\n    segmentationId: string;\n    segmentIndex: number;\n    segmentsLocked: number[];\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideRectangle,\n          ERASE_INSIDE: eraseInsideRectangle,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    // if we are already drawing, means we have started with a click, and now we\n    // are moving the mouse (not dragging) so the final click should not\n    // be handled by this preMouseDownCallback but rather the endCallback\n    if (this.isDrawing === true) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId, type } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const { representationData } = getSegmentation(segmentationId);\n    const labelmapData = representationData[\n      SegmentationRepresentations.Labelmap\n    ] as LabelmapSegmentationData;\n\n    // Todo: Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n      },\n    };\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n    this.editData = {\n      annotation,\n      segmentIndex,\n      segmentationId,\n      segmentsLocked,\n      segmentColor,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n      segmentationRepresentationUID,\n    } as any;\n\n    if (isVolumeSegmentation(labelmapData as LabelmapSegmentationData)) {\n      const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n      const segmentation = cache.getVolume(volumeId);\n\n      this.editData = {\n        ...this.editData,\n        volumeId,\n        referencedVolumeId: segmentation.referencedVolumeId,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      this.editData = {\n        ...this.editData,\n        imageIdReferenceMap,\n      };\n    }\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    // Moving handle.\n    const { currentPoints } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n    const worldPos = currentPoints.world;\n\n    const { points } = data.handles;\n\n    // Move this handle.\n    points[handleIndex] = [...worldPos];\n\n    let bottomLeftCanvas;\n    let bottomRightCanvas;\n    let topLeftCanvas;\n    let topRightCanvas;\n\n    let bottomLeftWorld;\n    let bottomRightWorld;\n    let topLeftWorld;\n    let topRightWorld;\n\n    switch (handleIndex) {\n      case 0:\n      case 3:\n        // Moving bottomLeft or topRight\n\n        bottomLeftCanvas = worldToCanvas(points[0]);\n        topRightCanvas = worldToCanvas(points[3]);\n\n        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n        topLeftWorld = canvasToWorld(topLeftCanvas);\n\n        points[1] = bottomRightWorld;\n        points[2] = topLeftWorld;\n\n        break;\n      case 1:\n      case 2:\n        // Moving bottomRight or topLeft\n        bottomRightCanvas = worldToCanvas(points[1]);\n        topLeftCanvas = worldToCanvas(points[2]);\n\n        bottomLeftCanvas = <Types.Point2>[\n          topLeftCanvas[0],\n          bottomRightCanvas[1],\n        ];\n        topRightCanvas = <Types.Point2>[bottomRightCanvas[0], topLeftCanvas[1]];\n\n        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n        topRightWorld = canvasToWorld(topRightCanvas);\n\n        points[0] = bottomLeftWorld;\n        points[3] = topRightWorld;\n\n        break;\n    }\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, newAnnotation, hasMoved } = this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    const operationData = {\n      ...this.editData,\n      points: data.handles.points,\n    };\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n  };\n\n  /**\n   * it is used to draw the rectangleScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const rectangleUID = '0';\n    drawRectSvg(\n      svgDrawingHelper,\n      annotationUID,\n      rectangleUID,\n      canvasCoordinates[0],\n      canvasCoordinates[3],\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n}\n\nRectangleScissorsTool.toolName = 'RectangleScissor';\nexport default RectangleScissorsTool;\n","import { cache, getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\n\nimport { fillInsideCircle } from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { Events } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  segmentLocking,\n  activeSegmentation,\n  segmentIndex as segmentIndexController,\n  config as segmentationConfig,\n} from '../../stateManagement/segmentation';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\n/**\n * Tool for manipulating segmentation data by drawing a circle. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex.\n */\nclass CircleScissorsTool extends BaseTool {\n  static toolName;\n  editData: {\n    annotation: any;\n    segmentIndex: number;\n    //\n    volumeId: string;\n    referencedVolumeId: string;\n    imageIdReferenceMap: Map<string, string>;\n    //\n    segmentsLocked: number[];\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    centerCanvas?: Array<number>;\n    segmentationRepresentationUID?: string;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideCircle,\n          ERASE_INSIDE: eraseInsideCircle,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    // if we are already drawing, means we have started with a click, and now we\n    // are moving the mouse (not dragging) so the final click should not\n    // be handled by this preMouseDownCallback but rather the endCallback\n    if (this.isDrawing === true) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId, type } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const { representationData } = getSegmentation(segmentationId);\n\n    // Todo: are we going to support contour editing with rectangle scissors?\n    const labelmapData = representationData[type];\n\n    if (!labelmapData) {\n      throw new Error(\n        'No labelmap data found for the active segmentation, create one before using scissors tool'\n      );\n    }\n\n    // Todo: Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        handles: {\n          points: [[...worldPos], [...worldPos], [...worldPos], [...worldPos]],\n          activeHandleIndex: null,\n        },\n        isDrawing: true,\n        cachedStats: {},\n      },\n    };\n\n    const viewportIdsToRender = [viewport.id];\n\n    this.editData = {\n      annotation,\n      centerCanvas: canvasPos,\n      segmentIndex,\n      segmentationId,\n      segmentsLocked,\n      segmentColor,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n      segmentationRepresentationUID,\n    } as any;\n\n    if (isVolumeSegmentation(labelmapData as LabelmapSegmentationData)) {\n      const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n      const segmentation = cache.getVolume(volumeId);\n\n      this.editData = {\n        ...this.editData,\n        volumeId,\n        referencedVolumeId: segmentation.referencedVolumeId,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      this.editData = {\n        ...this.editData,\n        imageIdReferenceMap,\n      };\n    }\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n    const { data } = annotation;\n\n    // Center of circle in canvas Coordinates\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n    const radius = Math.sqrt(dX * dX + dY * dY);\n\n    const bottomCanvas: Types.Point2 = [\n      centerCanvas[0],\n      centerCanvas[1] + radius,\n    ];\n    const topCanvas: Types.Point2 = [centerCanvas[0], centerCanvas[1] - radius];\n    const leftCanvas: Types.Point2 = [\n      centerCanvas[0] - radius,\n      centerCanvas[1],\n    ];\n    const rightCanvas: Types.Point2 = [\n      centerCanvas[0] + radius,\n      centerCanvas[1],\n    ];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, newAnnotation, hasMoved } = this.editData;\n    const { data } = annotation;\n    const { viewPlaneNormal, viewUp } = annotation.metadata;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    const operationData = {\n      ...this.editData,\n      points: data.handles.points,\n      viewPlaneNormal,\n      viewUp,\n      strategySpecificConfiguration: {},\n    };\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender } = this.editData;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return renderStatus;\n    }\n\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n    return renderStatus;\n  };\n}\n\nCircleScissorsTool.toolName = 'CircleScissor';\nexport default CircleScissorsTool;\n","import { cache, getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\n\nimport { fillInsideSphere } from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataVolume,\n  LabelmapSegmentationDataStack,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n/**\n * Tool for manipulating segmentation data by drawing a sphere in 3d space. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex. Todo: sphere scissor has some memory problem which\n * lead to ui blocking behavior that needs to be fixed.\n */\nclass SphereScissorsTool extends BaseTool {\n  static toolName;\n  editData: {\n    annotation: any;\n    segmentIndex: number;\n    segmentsLocked: number[];\n    segmentationRepresentationUID: string;\n    //\n    volumeId: string;\n    referencedVolumeId: string;\n    imageIdReferenceMap: Map<string, string>;\n    //\n    toolGroupId: string;\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    centerCanvas?: Array<number>;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideSphere,\n          ERASE_INSIDE: eraseInsideSphere,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): true => {\n    // if we are already drawing, means we have started with a click, and now we\n    // are moving the mouse (not dragging) so the final click should not\n    // be handled by this preMouseDownCallback but rather the endCallback\n    if (this.isDrawing === true) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    this.isDrawing = true;\n\n    // Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        invalidated: true,\n        handles: {\n          points: [[...worldPos], [...worldPos], [...worldPos], [...worldPos]],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        highlighted: true,\n      },\n    };\n\n    const viewportIdsToRender = [viewport.id];\n\n    this.editData = {\n      annotation,\n      centerCanvas: canvasPos,\n      segmentationRepresentationUID,\n      segmentIndex,\n      segmentationId,\n      segmentsLocked,\n      segmentColor,\n      toolGroupId,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    } as any;\n\n    const { representationData } = getSegmentation(segmentationId);\n    const labelmapData =\n      representationData[SegmentationRepresentations.Labelmap];\n\n    if (isVolumeSegmentation(labelmapData as LabelmapSegmentationData)) {\n      const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n      const segmentation = cache.getVolume(volumeId);\n\n      this.editData = {\n        ...this.editData,\n        volumeId,\n        referencedVolumeId: segmentation.referencedVolumeId,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      this.editData = {\n        ...this.editData,\n        imageIdReferenceMap,\n      };\n    }\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n    const { data } = annotation;\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n    const radius = Math.sqrt(dX * dX + dY * dY);\n\n    const bottomCanvas: Types.Point2 = [\n      centerCanvas[0],\n      centerCanvas[1] + radius,\n    ];\n    const topCanvas: Types.Point2 = [centerCanvas[0], centerCanvas[1] - radius];\n    const leftCanvas: Types.Point2 = [\n      centerCanvas[0] - radius,\n      centerCanvas[1],\n    ];\n    const rightCanvas: Types.Point2 = [\n      centerCanvas[0] + radius,\n      centerCanvas[1],\n    ];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      newAnnotation,\n      hasMoved,\n      segmentIndex,\n      segmentationRepresentationUID,\n      segmentsLocked,\n    } = this.editData;\n    const { data } = annotation;\n    const { viewPlaneNormal, viewUp } = annotation.metadata;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    const operationData = {\n      ...this.editData,\n      points: data.handles.points,\n      segmentIndex,\n      segmentationRepresentationUID,\n      segmentsLocked,\n      viewPlaneNormal,\n      viewUp,\n    };\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the sphereScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender } = this.editData;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return renderStatus;\n    }\n\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n}\n\nSphereScissorsTool.toolName = 'SphereScissor';\nexport default SphereScissorsTool;\n","import vtkOrientationMarkerWidget from '@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget';\nimport vtkAnnotatedCubeActor from '@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor';\nimport vtkAxesActor from '@kitware/vtk.js/Rendering/Core/AxesActor';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkXMLPolyDataReader from '@kitware/vtk.js/IO/XML/XMLPolyDataReader';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\n\nimport { BaseTool } from './base';\nimport { getRenderingEngines } from '@cornerstonejs/core';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\n\nconst OverlayMarkerType = {\n  ANNOTATED_CUBE: 1,\n  AXES: 2,\n  CUSTOM: 3,\n};\n\n/**\n * The OrientationMarker is a tool that includes an orientation marker in viewports\n * when activated\n */\nclass OrientationMarkerTool extends BaseTool {\n  static toolName;\n  static CUBE = 1;\n  static AXIS = 2;\n  static VTPFILE = 3;\n  orientationMarkers;\n  polyDataURL;\n\n  static OVERLAY_MARKER_TYPES = OverlayMarkerType;\n\n  configuration_invalidated = true;\n\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      configuration: {\n        orientationWidget: {\n          enabled: true,\n          viewportCorner: vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT,\n          viewportSize: 0.15,\n          minPixelSize: 100,\n          maxPixelSize: 300,\n        },\n        overlayMarkerType:\n          OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE,\n        overlayConfiguration: {\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE]: {\n            faceProperties: {\n              xPlus: { text: 'R', faceColor: '#ffff00', faceRotation: 90 },\n              xMinus: { text: 'L', faceColor: '#ffff00', faceRotation: 270 },\n              yPlus: {\n                text: 'P',\n                faceColor: '#00ffff',\n                fontColor: 'white',\n                faceRotation: 180,\n              },\n              yMinus: { text: 'A', faceColor: '#00ffff', fontColor: 'white' },\n              zPlus: { text: 'S' },\n              zMinus: { text: 'I' },\n            },\n            defaultStyle: {\n              fontStyle: 'bold',\n              fontFamily: 'Arial',\n              fontColor: 'black',\n              fontSizeScale: (res) => res / 2,\n              faceColor: '#0000ff',\n              edgeThickness: 0.1,\n              edgeColor: 'black',\n              resolution: 400,\n            },\n          },\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.AXES]: {},\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.CUSTOM]: {\n            polyDataURL:\n              'https://raw.githubusercontent.com/Slicer/Slicer/80ad0a04dacf134754459557bf2638c63f3d1d1b/Base/Logic/Resources/OrientationMarkers/Human.vtp',\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.orientationMarkers = {};\n    this.configuration_invalidated = true;\n  }\n\n  onSetToolEnabled = (): void => {\n    this.initViewports();\n    this.configuration_invalidated = true;\n  };\n\n  onSetToolActive = (): void => {\n    this.initViewports();\n  };\n\n  onSetToolDisabled = (): void => {\n    this.cleanUpData();\n  };\n\n  private cleanUpData() {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n    const viewports = renderingEngine.getViewports();\n\n    viewports.forEach((viewport) => {\n      const orientationMarker = this.orientationMarkers[viewport.id];\n      if (!orientationMarker) {\n        return;\n      }\n\n      const { actor, orientationWidget } = orientationMarker;\n      orientationWidget?.setEnabled(false);\n      orientationWidget?.delete();\n      actor?.delete();\n\n      const renderWindow = viewport\n        .getRenderingEngine()\n        .offscreenMultiRenderWindow.getRenderWindow();\n      renderWindow.render();\n      viewport.getRenderingEngine().render();\n\n      delete this.orientationMarkers[viewport.id];\n    });\n  }\n\n  private initViewports() {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    if (!renderingEngine) {\n      return;\n    }\n\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n    viewports.forEach((viewport) => this.addAxisActorInViewport(viewport));\n  }\n\n  async addAxisActorInViewport(viewport) {\n    const viewportId = viewport.id;\n    const type = this.configuration.overlayMarkerType;\n\n    const overlayConfiguration = this.configuration.overlayConfiguration[type];\n\n    if (this.orientationMarkers[viewportId]) {\n      const { actor, orientationWidget } = this.orientationMarkers[viewportId];\n      // remove the previous one\n      viewport.getRenderer().removeActor(actor);\n      orientationWidget.setEnabled(false);\n    }\n\n    let actor;\n    if (type === 1) {\n      actor = this.createAnnotationCube(overlayConfiguration);\n    } else if (type === 2) {\n      actor = vtkAxesActor.newInstance();\n    } else if (type === 3) {\n      actor = await this.createCustomActor();\n    }\n\n    const renderer = viewport.getRenderer();\n    const renderWindow = viewport\n      .getRenderingEngine()\n      .offscreenMultiRenderWindow.getRenderWindow();\n\n    const {\n      enabled,\n      viewportCorner,\n      viewportSize,\n      minPixelSize,\n      maxPixelSize,\n    } = this.configuration.orientationWidget;\n\n    const orientationWidget = vtkOrientationMarkerWidget.newInstance({\n      actor,\n      interactor: renderWindow.getInteractor(),\n      parentRenderer: renderer,\n    });\n\n    orientationWidget.setEnabled(enabled);\n    orientationWidget.setViewportCorner(viewportCorner);\n    orientationWidget.setViewportSize(viewportSize);\n    orientationWidget.setMinPixelSize(minPixelSize);\n    orientationWidget.setMaxPixelSize(maxPixelSize);\n\n    orientationWidget.updateMarkerOrientation();\n    this.orientationMarkers[viewportId] = {\n      orientationWidget,\n      actor,\n    };\n    renderWindow.render();\n    viewport.getRenderingEngine().render();\n\n    this.configuration_invalidated = false;\n  }\n\n  private async createCustomActor() {\n    const url =\n      this.configuration.overlayConfiguration[OverlayMarkerType.CUSTOM]\n        .polyDataURL;\n\n    const response = await fetch(url);\n    const arrayBuffer = await response.arrayBuffer();\n    const vtpReader = vtkXMLPolyDataReader.newInstance();\n    vtpReader.parseAsArrayBuffer(arrayBuffer);\n    vtpReader.update();\n\n    const polyData = vtkPolyData.newInstance();\n    polyData.shallowCopy(vtpReader.getOutputData());\n    polyData.getPointData().setActiveScalars('Color');\n    const mapper = vtkMapper.newInstance();\n    mapper.setInputData(polyData);\n    mapper.setColorModeToDirectScalars();\n\n    const actor = vtkActor.newInstance();\n    actor.setMapper(mapper);\n    actor.rotateZ(180);\n    return actor;\n  }\n\n  private createAnnotationCube(overlayConfiguration: any) {\n    const actor = vtkAnnotatedCubeActor.newInstance();\n    actor.setDefaultStyle({ ...overlayConfiguration.defaultStyle });\n    actor.setXPlusFaceProperty({\n      ...overlayConfiguration.faceProperties.xPlus,\n    });\n    actor.setXMinusFaceProperty({\n      ...overlayConfiguration.faceProperties.xMinus,\n    });\n    actor.setYPlusFaceProperty({\n      ...overlayConfiguration.faceProperties.yPlus,\n    });\n    actor.setYMinusFaceProperty({\n      ...overlayConfiguration.faceProperties.yMinus,\n    });\n    actor.setZPlusFaceProperty({\n      ...overlayConfiguration.faceProperties.zPlus,\n    });\n    actor.setZMinusFaceProperty({\n      ...overlayConfiguration.faceProperties.zMinus,\n    });\n    return actor;\n  }\n\n  async createAnnotatedCubeActor() {\n    const axes = vtkAnnotatedCubeActor.newInstance();\n    const { faceProperties, defaultStyle } = this.configuration.annotatedCube;\n\n    axes.setDefaultStyle(defaultStyle);\n\n    Object.keys(faceProperties).forEach((key) => {\n      const methodName = `set${\n        key.charAt(0).toUpperCase() + key.slice(1)\n      }FaceProperty`;\n      axes[methodName](faceProperties[key]);\n    });\n\n    return axes;\n  }\n}\n\nOrientationMarkerTool.toolName = 'OrientationMarker';\nexport default OrientationMarkerTool;\n","import {\n  cache,\n  getEnabledElement,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  Segmentation,\n} from '../../types';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\nimport {\n  getActiveSegmentation,\n  getActiveSegmentationRepresentation,\n} from '../../stateManagement/segmentation/activeSegmentation';\nimport RepresentationTypes from '../../enums/SegmentationRepresentations';\nimport { setActiveSegmentIndex } from '../../stateManagement/segmentation/segmentIndex';\n\n/**\n * Represents a tool used for segment selection. It is used to select a segment\n * by hovering over it.\n *\n */\nclass SegmentSelectTool extends BaseTool {\n  static toolName;\n  private hoverTimer: ReturnType<typeof setTimeout> | null;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        hoverTimeout: 750,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.hoverTimer = null;\n  }\n\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    if (this.hoverTimer) {\n      clearTimeout(this.hoverTimer);\n    }\n\n    this.hoverTimer = setTimeout(() => {\n      this._setActiveSegment(evt);\n      this.hoverTimer = null;\n    }, this.configuration.hoverTimeout);\n\n    return true;\n  };\n\n  onSetToolEnabled = (): void => {\n    this.onSetToolActive();\n  };\n\n  onSetToolActive = (): void => {\n    this.hoverTimer = null;\n  };\n\n  onSetToolDisabled = (): void => {\n    this.hoverTimer = null;\n  };\n\n  _setActiveSegment(evt = {} as EventTypes.InteractionEventType): void {\n    const { element, currentPoints } = evt.detail;\n\n    const worldPoint = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n\n    if (!enabledElement) {\n      return;\n    }\n\n    const { viewport } = enabledElement;\n\n    const activeSegmentation = getActiveSegmentation(this.toolGroupId);\n\n    if (activeSegmentation.type === RepresentationTypes.Labelmap) {\n      this._setActiveSegmentLabelmap(activeSegmentation, worldPoint, viewport);\n    } else {\n      throw Error('non-labelmap segmentation not supported yet');\n    }\n  }\n\n  _setActiveSegmentLabelmap(\n    activeSegmentation: Segmentation,\n    worldPoint: Types.Point3,\n    viewport: Types.IStackViewport | Types.IVolumeViewport\n  ): void {\n    const imageDataInfo = viewport.getImageData();\n\n    if (!imageDataInfo) {\n      return;\n    }\n\n    const labelmapData = activeSegmentation.representationData.LABELMAP;\n\n    let hoveredSegmentIndex;\n\n    if (isVolumeSegmentation(activeSegmentation.representationData.LABELMAP)) {\n      const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n\n      const segmentationVolume = cache.getVolume(volumeId);\n\n      if (!segmentationVolume) {\n        return;\n      }\n\n      hoveredSegmentIndex =\n        segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      const currentImageId = viewport.getCurrentImageId();\n      const segmentationImageId = imageIdReferenceMap.get(currentImageId);\n\n      const image = cache.getImage(segmentationImageId);\n\n      if (!image) {\n        return;\n      }\n\n      const activeSegmentationRepresentation =\n        getActiveSegmentationRepresentation(this.toolGroupId);\n\n      if (!activeSegmentationRepresentation) {\n        return;\n      }\n\n      const segmentationActor = viewport.getActor(\n        activeSegmentationRepresentation.segmentationRepresentationUID\n      );\n\n      const imageData = segmentationActor?.actor.getMapper().getInputData();\n\n      const indexIJK = csUtils.transformWorldToIndex(imageData, worldPoint);\n\n      // since it is a stack we don't need to check the z\n      const flattenedIndex = indexIJK[0] + indexIJK[1] * image.columns;\n\n      const scalars = imageData.getPointData().getScalars().getData();\n\n      hoveredSegmentIndex = scalars[flattenedIndex];\n    }\n\n    // No need to select background\n    if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {\n      return;\n    }\n\n    setActiveSegmentIndex(\n      activeSegmentation.segmentationId,\n      hoveredSegmentIndex\n    );\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    // update states\n    triggerSegmentationModified(activeSegmentation.segmentationId);\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      renderingEngine.getViewports().map((v) => v.id)\n    );\n  }\n}\n\nSegmentSelectTool.toolName = 'SegmentSelectTool';\nexport default SegmentSelectTool;\n","import {\n  cache,\n  getEnabledElement,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport { PublicToolProps, ToolProps, EventTypes } from '../../types';\nimport { SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport {\n  segmentLocking,\n  activeSegmentation,\n  segmentIndex as segmentIndexController,\n} from '../../stateManagement/segmentation';\nimport floodFill from '../../utilities/segmentation/floodFill';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { FloodFillResult, FloodFillGetter } from '../../types';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\nconst { transformWorldToIndex, isEqual } = csUtils;\n\ntype PaintFillToolHelpers = {\n  getScalarDataPositionFromPlane: (x: number, y: number) => number;\n  getLabelValue: (x: number, y: number, z: number) => number;\n  floodFillGetter: FloodFillGetter;\n  inPlaneSeedPoint: Types.Point2;\n  fixedDimensionValue: number;\n};\n\n/**\n * Tool for manipulating segmentation data by filling in regions. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will fill a given labelled\n * or empty region with the the activeSegmentIndex label. You can use the\n * SegmentationModule to set the active segmentation and segmentIndex.\n */\nclass PaintFillTool extends BaseTool {\n  static toolName;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationId, type } = activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked: number[] =\n      segmentLocking.getLockedSegments(segmentationId);\n    const { representationData } = getSegmentation(segmentationId);\n\n    const labelmapData =\n      representationData[SegmentationRepresentations.Labelmap];\n\n    let dimensions: Types.Point3;\n    let direction: Types.Mat3;\n    let scalarData: Types.PixelDataTypedArray;\n    let index: Types.Point3;\n\n    if (isVolumeSegmentation(labelmapData)) {\n      const { volumeId } = representationData[\n        type\n      ] as LabelmapSegmentationDataVolume;\n\n      const segmentation = cache.getVolume(volumeId);\n      ({ dimensions, direction } = segmentation);\n      scalarData = segmentation.getScalarData();\n\n      index = transformWorldToIndex(segmentation.imageData, worldPos);\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      const currentImageId = enabledElement.viewport.getCurrentImageId();\n      const currentSegmentationImageId =\n        imageIdReferenceMap.get(currentImageId);\n\n      if (!currentSegmentationImageId) {\n        throw new Error(\n          'No active segmentation imageId detected, create one before using scissors tool'\n        );\n      }\n\n      const segmentationImage = cache.getImage(currentSegmentationImageId);\n      scalarData = segmentationImage.getPixelData();\n      const { imageData } = viewport.getImageData();\n      dimensions = imageData.getDimensions();\n      direction = imageData.getDirection();\n      index = transformWorldToIndex(imageData, worldPos);\n    }\n\n    const fixedDimension = this.getFixedDimension(\n      viewPlaneNormal,\n      direction as number[]\n    );\n\n    if (fixedDimension === undefined) {\n      console.warn('Oblique paint fill not yet supported');\n      return;\n    }\n\n    const {\n      floodFillGetter,\n      getLabelValue,\n      getScalarDataPositionFromPlane,\n      inPlaneSeedPoint,\n      fixedDimensionValue,\n    } = this.generateHelpers(scalarData, dimensions, index, fixedDimension);\n\n    // Check if within volume\n    if (\n      index[0] < 0 ||\n      index[0] >= dimensions[0] ||\n      index[1] < 0 ||\n      index[1] >= dimensions[1] ||\n      index[2] < 0 ||\n      index[2] >= dimensions[2]\n    ) {\n      // Clicked outside segmentation volume, no good way to fill.\n      return;\n    }\n    //@ts-ignore // todo type\n    const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);\n\n    if (segmentsLocked.includes(clickedLabelValue)) {\n      // Label is locked, cannot fill.\n      return;\n    }\n\n    const floodFillResult = floodFill(floodFillGetter, inPlaneSeedPoint);\n\n    const { flooded } = floodFillResult;\n\n    flooded.forEach((index) => {\n      const scalarDataPosition = getScalarDataPositionFromPlane(\n        index[0],\n        index[1]\n      );\n\n      scalarData[scalarDataPosition] = segmentIndex;\n    });\n\n    const framesModified = this.getFramesModified(\n      fixedDimension,\n      fixedDimensionValue,\n      floodFillResult\n    );\n\n    triggerSegmentationDataModified(segmentationId, framesModified);\n\n    return true;\n  };\n\n  private getFramesModified = (\n    fixedDimension: number,\n    fixedDimensionValue: number,\n    floodFillResult: FloodFillResult\n  ): number[] => {\n    const { boundaries } = floodFillResult;\n\n    if (fixedDimension === 2) {\n      return [fixedDimensionValue];\n    }\n\n    // For both the fixedDimensions being 0 and 1, the Z (stack) direction is j,\n    // so we don't need to find min/max i.\n\n    let minJ = Infinity;\n    let maxJ = -Infinity;\n\n    for (let b = 0; b < boundaries.length; b++) {\n      const j = boundaries[b][1];\n\n      if (j < minJ) {\n        minJ = j;\n      }\n      if (j > maxJ) {\n        maxJ = j;\n      }\n    }\n\n    const framesModified = [];\n\n    for (let frame = minJ; frame <= maxJ; frame++) {\n      framesModified.push(frame);\n    }\n\n    return framesModified;\n  };\n\n  private generateHelpers = (\n    scalarData: Types.PixelDataTypedArray,\n    dimensions: Types.Point3,\n    seedIndex3D: Types.Point3,\n    fixedDimension = 2\n  ): PaintFillToolHelpers => {\n    let fixedDimensionValue: number;\n    let inPlaneSeedPoint: Types.Point2;\n\n    switch (fixedDimension) {\n      case 0:\n        fixedDimensionValue = seedIndex3D[0]; // X\n        inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]]; // Y,Z\n        break;\n      case 1:\n        fixedDimensionValue = seedIndex3D[1]; // Y\n        inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]]; // X,Z\n        break;\n      case 2:\n        fixedDimensionValue = seedIndex3D[2]; // Z\n        inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]]; // X, Y\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    const getScalarDataPosition = (x: number, y: number, z: number): number => {\n      return z * dimensions[1] * dimensions[0] + y * dimensions[0] + x;\n    };\n\n    const getLabelValue = (x: number, y: number, z: number): number => {\n      return scalarData[getScalarDataPosition(x, y, z)];\n    };\n\n    const floodFillGetter = this.generateFloodFillGetter(\n      dimensions,\n      fixedDimension,\n      fixedDimensionValue,\n      getLabelValue\n    );\n\n    const getScalarDataPositionFromPlane =\n      this.generateGetScalarDataPositionFromPlane(\n        getScalarDataPosition,\n        fixedDimension,\n        fixedDimensionValue\n      );\n\n    return {\n      getScalarDataPositionFromPlane,\n      getLabelValue,\n      floodFillGetter,\n      inPlaneSeedPoint,\n      fixedDimensionValue,\n    };\n  };\n\n  private getFixedDimension(\n    viewPlaneNormal: Types.Point3,\n    direction: number[]\n  ): number | undefined {\n    const xDirection = direction.slice(0, 3);\n    const yDirection = direction.slice(3, 6);\n    const zDirection = direction.slice(6, 9);\n\n    const absoluteOfViewPlaneNormal = [\n      Math.abs(viewPlaneNormal[0]),\n      Math.abs(viewPlaneNormal[1]),\n      Math.abs(viewPlaneNormal[2]),\n    ];\n\n    const absoluteOfXDirection = [\n      Math.abs(xDirection[0]),\n      Math.abs(xDirection[1]),\n      Math.abs(xDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {\n      return 0;\n    }\n\n    const absoluteOfYDirection = [\n      Math.abs(yDirection[0]),\n      Math.abs(yDirection[1]),\n      Math.abs(yDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {\n      return 1;\n    }\n\n    const absoluteOfZDirection = [\n      Math.abs(zDirection[0]),\n      Math.abs(zDirection[1]),\n      Math.abs(zDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {\n      return 2;\n    }\n  }\n\n  // Define a getter for the fill routine to access the working label map.\n  private generateFloodFillGetter = (\n    dimensions: Types.Point3,\n    fixedDimension: number,\n    fixedDimensionValue: number,\n    getLabelValue: PaintFillToolHelpers['getLabelValue']\n  ): FloodFillGetter => {\n    let floodFillGetter;\n\n    // In each helper we first check if out of bounds, as the flood filler\n    // doesn't know about the dimensions of the data structure that sits on top\n    // of the scalarData. E.g. if cols is 10, (0,1) and (10, 0) would point to\n    // the same position in these getters.\n\n    switch (fixedDimension) {\n      case 0:\n        floodFillGetter = (y, z) => {\n          if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {\n            return;\n          }\n\n          return getLabelValue(fixedDimensionValue, y, z);\n        };\n        break;\n\n      case 1:\n        floodFillGetter = (x, z) => {\n          if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {\n            return;\n          }\n\n          return getLabelValue(x, fixedDimensionValue, z);\n        };\n        break;\n\n      case 2:\n        floodFillGetter = (x, y) => {\n          if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {\n            return;\n          }\n\n          return getLabelValue(x, y, fixedDimensionValue);\n        };\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    return floodFillGetter;\n  };\n\n  private generateGetScalarDataPositionFromPlane = (\n    getScalarDataPosition: (x: number, y: number, z: number) => number,\n    fixedDimension: number,\n    fixedDimensionValue: number\n  ): PaintFillToolHelpers['getScalarDataPositionFromPlane'] => {\n    let getScalarDataPositionFromPlane;\n\n    switch (fixedDimension) {\n      case 0:\n        getScalarDataPositionFromPlane = (y, z) => {\n          return getScalarDataPosition(fixedDimensionValue, y, z);\n        };\n        break;\n      case 1:\n        getScalarDataPositionFromPlane = (x, z) => {\n          return getScalarDataPosition(x, fixedDimensionValue, z);\n        };\n        break;\n      case 2:\n        getScalarDataPositionFromPlane = (x, y) => {\n          return getScalarDataPosition(x, y, fixedDimensionValue);\n        };\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    return getScalarDataPositionFromPlane;\n  };\n}\n\nPaintFillTool.toolName = 'PaintFill';\nexport default PaintFillTool;\n","import { vec3, vec2 } from 'gl-matrix';\n\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n  cache,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\n\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRedactionRect as drawRedactionRectSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport { EventTypes, SVGDrawingHelper } from '../../types';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { VideoRedactionAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nclass VideoRedactionTool extends AnnotationTool {\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportUIDsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  _configuration: any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(toolConfiguration = {}) {\n    super(toolConfiguration, {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: { shadow: true, preventHandleOutsideImage: false },\n    });\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): VideoRedactionAnnotation => {\n    const eventData = evt.detail;\n    const { currentPoints, element } = eventData;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotation = {\n      metadata: {\n        // We probably just want a different type of data here, hacking this\n        // together for now.\n        viewPlaneNormal: <Types.Point3>[0, 0, 1],\n        viewUp: <Types.Point3>[0, 1, 0],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId,\n        toolName: this.getToolName(),\n      },\n      data: {\n        invalidated: true,\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        active: true,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    this.editData = {\n      annotation,\n      viewportUIDsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    return annotation;\n  };\n\n  getHandleNearImagePoint = (element, annotation, canvasCoords, proximity) => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      const toolDataCanvasCoordinate = viewport.worldToCanvas(point);\n\n      const near =\n        vec2.distance(canvasCoords, <vec2>toolDataCanvasCoordinate) < proximity;\n\n      if (near === true) {\n        data.handles.activeHandleIndex = i;\n        return point;\n      }\n    }\n\n    data.handles.activeHandleIndex = null;\n  };\n\n  isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasPoint1 = viewport.worldToCanvas(points[0]);\n    const canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    const rect = this._getRectangleImageCoordinates([\n      canvasPoint1,\n      canvasPoint2,\n    ]);\n\n    const point = [canvasCoords[0], canvasCoords[1]] as Types.Point2;\n    const { left, top, width, height } = rect;\n\n    const distanceToPoint = rectangle.distanceToPoint(\n      [left, top, width, height],\n      point\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n  };\n\n  toolSelectedCallback = (evt, annotation, interactionType = 'mouse') => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { data } = annotation;\n\n    data.active = true;\n\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    this.editData = {\n      annotation,\n      viewportUIDsToRender,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt,\n    annotation,\n    handle,\n    interactionType = 'mouse'\n  ) => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const { data } = annotation;\n\n    data.active = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if (handle.worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    this.editData = {\n      annotation,\n      viewportUIDsToRender,\n      handleIndex,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    evt.preventDefault();\n  };\n\n  _mouseUpCallback = (evt) => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { annotation, viewportUIDsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.active = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n  };\n\n  _mouseDragCallback = (evt) => {\n    this.isDrawing = true;\n\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { annotation, viewportUIDsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    if (handleIndex === undefined) {\n      // Moving tool, so move all points by the world points delta\n      const { deltaPoints } = eventData;\n      const worldPosDelta = deltaPoints.world;\n\n      const { points } = data.handles;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      data.invalidated = true;\n    } else {\n      // Moving handle.\n      const { currentPoints } = eventData;\n      const enabledElement = getEnabledElement(element);\n      const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n      const worldPos = currentPoints.world;\n\n      const { points } = data.handles;\n\n      // Move this handle.\n      points[handleIndex] = [...worldPos];\n\n      let bottomLeftCanvas;\n      let bottomRightCanvas;\n      let topLeftCanvas;\n      let topRightCanvas;\n\n      let bottomLeftWorld;\n      let bottomRightWorld;\n      let topLeftWorld;\n      let topRightWorld;\n\n      switch (handleIndex) {\n        case 0:\n        case 3:\n          // Moving bottomLeft or topRight\n\n          bottomLeftCanvas = worldToCanvas(points[0]);\n          topRightCanvas = worldToCanvas(points[3]);\n\n          bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n          topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n          bottomRightWorld = canvasToWorld(bottomRightCanvas);\n          topLeftWorld = canvasToWorld(topLeftCanvas);\n\n          points[1] = bottomRightWorld;\n          points[2] = topLeftWorld;\n\n          break;\n        case 1:\n        case 2:\n          // Moving bottomRight or topLeft\n          bottomRightCanvas = worldToCanvas(points[1]);\n          topLeftCanvas = worldToCanvas(points[2]);\n\n          bottomLeftCanvas = <Types.Point2>[\n            topLeftCanvas[0],\n            bottomRightCanvas[1],\n          ];\n          topRightCanvas = <Types.Point2>[\n            bottomRightCanvas[0],\n            topLeftCanvas[1],\n          ];\n\n          bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n          topRightWorld = canvasToWorld(topRightCanvas);\n\n          points[0] = bottomLeftWorld;\n          points[3] = topRightWorld;\n\n          break;\n      }\n      data.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n  };\n\n  cancel(element) {\n    // If it is mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportUIDsToRender } = this.editData;\n\n    const { data } = annotation;\n\n    data.active = false;\n    data.handles.activeHandleIndex = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    this.editData = null;\n    return annotation.metadata.annotationUID;\n  }\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  /**\n   * Remove event handlers for the modify event loop, and enable default event propagation.\n   */\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i];\n      const { annotationUID } = annotation;\n      const toolMetadata = annotation.metadata;\n\n      const data = annotation.data;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        // !isToolDataLocked(toolData) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const rectangleUID = '0';\n      drawRedactionRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color: 'black',\n          lineDash,\n          lineWidth,\n        }\n      );\n    }\n  };\n\n  _getRectangleImageCoordinates = (\n    points: Array<Types.Point2>\n  ): {\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n  } => {\n    const [point0, point1] = points;\n\n    return {\n      left: Math.min(point0[0], point1[0]),\n      top: Math.min(point0[1], point1[1]),\n      width: Math.abs(point0[0] - point1[0]),\n      height: Math.abs(point0[1] - point1[1]),\n    };\n  };\n\n  _getImageVolumeFromTargetUID(targetUID, renderingEngine) {\n    let imageVolume, viewport;\n    if (targetUID.startsWith('stackTarget')) {\n      const coloneIndex = targetUID.indexOf(':');\n      const viewportUID = targetUID.substring(coloneIndex + 1);\n      const viewport = renderingEngine.getViewport(viewportUID);\n      imageVolume = viewport.getImageData();\n    } else {\n      imageVolume = cache.getVolume(targetUID);\n    }\n\n    return { imageVolume, viewport };\n  }\n\n  /**\n   * _calculateCachedStats - For each volume in the frame of reference that a\n   * tool instance in particular viewport defines as its target volume, find the\n   * volume coordinates (i,j,k) being probed by the two corners. One of i,j or k\n   * will be constant across the two points. In the other two directions iterate\n   * over the voxels and calculate the first and second-order statistics.\n   *\n   * @param {object} data - The toolData tool-specific data.\n   * @param {Array<number>} viewPlaneNormal The normal vector of the camera.\n   * @param {Array<number>} viewUp The viewUp vector of the camera.\n   */\n  _calculateCachedStats = (\n    annotation,\n    viewPlaneNormal,\n    viewUp,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const { data } = annotation;\n    const { viewportUID, renderingEngineUID, sceneUID } = enabledElement;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[3];\n    const { cachedStats } = data;\n\n    const targetUIDs = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetUIDs.length; i++) {\n      const targetUID = targetUIDs[i];\n\n      const { imageVolume } = this._getImageVolumeFromTargetUID(\n        targetUID,\n        renderingEngine\n      );\n\n      const {\n        dimensions,\n        scalarData,\n        vtkImageData: imageData,\n        metadata,\n      } = imageVolume;\n      const worldPos1Index = vec3.fromValues(0, 0, 0);\n      const worldPos2Index = vec3.fromValues(0, 0, 0);\n\n      imageData.worldToIndexVec3(worldPos1, worldPos1Index);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      imageData.worldToIndexVec3(worldPos2, worldPos2Index);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n\n        // Calculate index bounds to iterate over\n\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n\n        const area = worldWidth * worldHeight;\n\n        let count = 0;\n        let mean = 0;\n        let stdDev = 0;\n\n        const yMultiple = dimensions[0];\n        const zMultiple = dimensions[0] * dimensions[1];\n\n        // This is a triple loop, but one of these 3 values will be constant\n        // In the planar view.\n        for (let k = kMin; k <= kMax; k++) {\n          for (let j = jMin; j <= jMax; j++) {\n            for (let i = iMin; i <= iMax; i++) {\n              const value = scalarData[k * zMultiple + j * yMultiple + i];\n\n              count++;\n              mean += value;\n            }\n          }\n        }\n\n        mean /= count;\n\n        for (let k = kMin; k <= kMax; k++) {\n          for (let j = jMin; j <= jMax; j++) {\n            for (let i = iMin; i <= iMax; i++) {\n              const value = scalarData[k * zMultiple + j * yMultiple + i];\n\n              const valueMinusMean = value - mean;\n\n              stdDev += valueMinusMean * valueMinusMean;\n            }\n          }\n        }\n\n        stdDev /= count;\n        stdDev = Math.sqrt(stdDev);\n\n        cachedStats[targetUID] = {\n          Modality: metadata.Modality,\n          area,\n          mean,\n          stdDev,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetUID] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    data.invalidated = false;\n\n    // Dispatching measurement modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail = {\n      annotation,\n      viewportUID,\n      renderingEngineUID,\n      sceneUID: sceneUID,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n\n  _getTargetStackUID(viewport) {\n    return `stackTarget:${viewport.uid}`;\n  }\n\n  _getTargetVolumeUID = (scene) => {\n    if (this.configuration.volumeUID) {\n      return this.configuration.volumeUID;\n    }\n\n    const volumeActors = scene.getVolumeActors();\n\n    if (!volumeActors && !volumeActors.length) {\n      // No stack to scroll through\n      return;\n    }\n\n    return volumeActors[0].uid;\n  };\n}\n\nVideoRedactionTool.toolName = 'VideoRedaction';\nexport default VideoRedactionTool;\n"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__976__","__WEBPACK_EXTERNAL_MODULE__953__","__WEBPACK_EXTERNAL_MODULE__441__","__WEBPACK_EXTERNAL_MODULE__795__","__WEBPACK_EXTERNAL_MODULE__396__","__WEBPACK_EXTERNAL_MODULE__348__","__WEBPACK_EXTERNAL_MODULE__70__","__WEBPACK_EXTERNAL_MODULE__785__","__WEBPACK_EXTERNAL_MODULE__127__","__WEBPACK_EXTERNAL_MODULE__474__","__WEBPACK_EXTERNAL_MODULE__610__","__WEBPACK_EXTERNAL_MODULE__448__","__WEBPACK_EXTERNAL_MODULE__283__","__WEBPACK_EXTERNAL_MODULE__807__","__WEBPACK_EXTERNAL_MODULE__543__","__WEBPACK_EXTERNAL_MODULE__847__","__WEBPACK_EXTERNAL_MODULE__518__","__WEBPACK_EXTERNAL_MODULE__744__","__WEBPACK_EXTERNAL_MODULE__424__","__WEBPACK_EXTERNAL_MODULE__614__","HASH_UNDEFINED","MAX_SAFE_INTEGER","argsTag","boolTag","dateTag","funcTag","genTag","mapTag","numberTag","objectTag","promiseTag","regexpTag","setTag","stringTag","symbolTag","weakMapTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","reFlags","reIsHostCtor","reIsUint","cloneableTags","freeGlobal","g","Object","freeSelf","Function","freeExports","nodeType","freeModule","moduleExports","addMapEntry","map","pair","set","addSetEntry","value","add","arrayReduce","array","iteratee","accumulator","initAccum","index","length","isHostObject","result","toString","e","mapToArray","Array","size","forEach","key","overArg","func","transform","arg","setToArray","uid","arrayProto","prototype","funcProto","objectProto","coreJsData","maskSrcKey","exec","keys","IE_PROTO","funcToString","hasOwnProperty","objectToString","reIsNative","RegExp","call","replace","Buffer","undefined","Symbol","Uint8Array","getPrototype","getPrototypeOf","objectCreate","create","propertyIsEnumerable","splice","nativeGetSymbols","getOwnPropertySymbols","nativeIsBuffer","isBuffer","nativeKeys","DataView","getNative","Map","Promise","Set","WeakMap","nativeCreate","dataViewCtorString","toSource","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","symbolValueOf","valueOf","Hash","entries","this","clear","entry","ListCache","MapCache","Stack","__data__","assignValue","object","objValue","eq","assocIndexOf","baseClone","isDeep","isFull","customizer","stack","isObject","isArr","isArray","constructor","input","initCloneArray","source","copyArray","tag","getTag","isFunc","buffer","slice","copy","cloneBuffer","isPrototype","proto","initCloneObject","copyObject","getSymbols","copySymbols","baseAssign","cloneFunc","symbol","Ctor","cloneArrayBuffer","dataView","byteOffset","byteLength","cloneDataView","typedArray","cloneTypedArray","cloneMap","regexp","lastIndex","cloneRegExp","cloneSet","initCloneByTag","stacked","get","props","keysFunc","symbolsFunc","values","offset","arrayPush","baseGetAllKeys","getAllKeys","arrayEach","subValue","arrayBuffer","newValue","getMapData","type","data","getValue","isFunction","test","baseIsNative","has","pop","push","cache","pairs","LARGE_ARRAY_SIZE","isIndex","other","ArrayBuffer","resolve","ctorString","isArrayLike","isLength","inherited","isObjectLike","isArrayLikeObject","isArguments","n","baseTimes","String","skipIndexes","arrayLikeKeys","baseKeys","INFINITY","reIsDeepProp","reIsPlainProp","reLeadingDot","rePropName","reEscapeChar","symbolToString","pattern","stringToPath","memoize","string","isSymbol","baseToString","match","number","quote","toKey","resolver","TypeError","memoized","args","arguments","apply","Cache","path","defaultValue","isKey","baseGet","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","id","loaded","__webpack_modules__","getter","__esModule","d","a","definition","o","defineProperty","enumerable","globalThis","window","obj","prop","r","toStringTag","nmd","paths","children","Events","_typeof","iterator","_defineProperty","hint","prim","toPrimitive","res","configurable","writable","globalLockedAnnotationsSet","setAnnotationLocked","annotation","locked","detail","makeEventDetail","lockedAnnotationsSet","added","lock","unlock","publish","unlockAllAnnotations","clearLockedAnnotationsSet","getAnnotationsLocked","from","isAnnotationLocked","getAnnotationsLockedCount","checkAndDefineIsLockedProperty","isLocked","descriptor","getOwnPropertyDescriptor","setIsLocked","getIsLocked","isExtensible","shouldDefineIsLockedProperty","freeze","removed","delete","item","triggerEvent","eventTarget","selectedAnnotationUIDs","setAnnotationSelected","annotationUID","deselectAnnotation","preserveSelected","clearSelectionSet","selectAnnotation","getAnnotationsSelected","getAnnotationsSelectedByToolName","toolName","filter","getAnnotation","metadata","isAnnotationSelected","getAnnotationsSelectedCount","selection","selectionSet","globalHiddenAnnotationUIDsSet","setAnnotationVisibility","visible","show","annotationUIDsSet","lastHidden","hide","showAllAnnotations","isAnnotationVisible","checkAndDefineIsVisibleProperty","_annotation$isVisible","isVisible","setIsVisible","getIsVisible","shouldDefineIsVisibleProperty","lastVisible","hidden","FrameOfReferenceSpecificAnnotationManager","annotationGroupSelector","element","enabledElement","getEnabledElement","Error","FrameOfReferenceUID","evt","eventDetail","frameOfReferenceSpecificAnnotations","annotations","invalidated","groupKey","frameOfReferenceUID","frameOfReferenceAnnotations","toolSpecificAnnotations","getAnnotations","total","groupAnnotations","toolAnnotations","findIndex","cloneDeep","state","count","utilities","Enums","_imageVolumeModifiedHandler","defaultFrameOfReferenceSpecificAnnotationManager","svgNodeCache","defaultState","isInteractingWithTool","isMultiPartToolActive","tools","toolGroups","synchronizers","enabledElements","handleRadius","ToolModes","MODES","_ref","toolOptions","toolGroupToolNames","i","includes","mode","defaultManager","getAnnotationManager","setAnnotationManager","annotationManager","resetAnnotationManager","manager","getGroupKey","addAnnotation","csUtils","HTMLDivElement","renderingEngine","viewportId","eventType","renderingEngineId","triggerAnnotationAddedForElement","getToolGroupsWithToolName","viewportsToRender","toolGroup","viewportsInfo","viewportInfo","getEnabledElementByIds","triggerAnnotationAddedForFOR","getNumberOfAnnotations","removeAnnotation","annotationManagerUID","removeAllAnnotations","SegmentationRepresentations","defaultContourConfig","renderOutline","outlineWidthActive","outlineWidthInactive","outlineOpacity","outlineOpacityInactive","renderFill","fillAlpha","fillAlphaInactive","defaultLabelmapConfig","activeSegmentOutlineWidthDelta","renderFillInactive","getDefaultLabelmapConfig","initialDefaultState","colorLUT","segmentations","globalConfig","renderInactiveSegmentations","representations","defaultSegmentationStateManager","getState","getToolGroups","getColorLUT","lutIndex","getNextColorLUTIndex","resetState","getSegmentation","segmentationId","find","segmentation","addSegmentation","concat","getSegmentationRepresentations","toolGroupId","toolGroupSegRepresentationsWithConfig","segmentationRepresentations","getAllSegmentationRepresentations","toolGroupSegReps","addSegmentationRepresentation","segmentationRepresentation","config","_handleActiveSegmentation","getGlobalConfig","setGlobalConfig","getSegmentationRepresentationByUID","segmentationRepresentationUID","representation","removeSegmentation","removeSegmentationRepresentation","toolGroupSegmentationRepresentations","segData","console","warn","removedSegmentationRepresentation","setActiveSegmentationRepresentation","toolGroupSegmentations","segmentationData","active","getToolGroupSpecificConfig","toolGroupStateWithConfig","getSegmentationRepresentationSpecificConfig","segmentationRepresentationSpecificConfig","setSegmentationRepresentationSpecificConfig","getSegmentSpecificConfig","segmentIndex","segmentSpecificConfig","setSegmentSpecificConfig","options","setSegmentationRepresentationConfig","addColorLUT","structuredClone","removeColorLUT","colorLUTIndex","recentlyAddedOrRemovedSegmentationRepresentation","triggerSegmentationRemoved","triggerSegmentationRepresentationRemoved","triggerSegmentationRepresentationModified","triggerSegmentationModified","segmentationIds","getSegmentations","triggerSegmentationDataModified","modifiedSlicesToUse","segmentationInput","isContourRepresentation","_contourData$geometry","_contourData$annotati","contourData","geometryIds","annotationUIDsMap","cachedStats","segmentLabels","label","segmentsLocked","activeSegmentIndex","representationData","getDefaultSegmentationStateManager","suppressEvents","segmentationStateManager","normalizeSegmentationInput","getToolGroupIdsWithSegmentation","toolGroupIds","foundToolGroupIds","setToolGroupSpecificConfig","getSegmentSpecificRepresentationConfig","setSegmentSpecificRepresentationConfig","removeSegmentationRepresentations","getMouseEventPoints","elementToUse","currentTarget","viewport","clientPoint","clientX","clientY","_clientToPoint","pagePoint","pageX","pageY","_pageToPoint","canvasPoint","rect","getBoundingClientRect","left","pageXOffset","top","pageYOffset","_pagePointsToCanvasPoints","page","client","canvas","world","canvasToWorld","startPoints","event","eventName","camera","lastPoints","currentPoints","deltaPoints","stopImmediatePropagation","preventDefault","MOUSE_DOWN","MOUSE_DOWN_ACTIVATE","MOUSE_CLICK","MOUSE_UP","MOUSE_DRAG","DOUBLE_CLICK_DRAG_TOLERANCE","mouseButton","isClickEvent","clickDelay","preventClickTimeout","doubleClickState","doubleClickTimeout","mouseDownEvent","mouseUpEvent","ignoreDoubleClick","_onMouseDrag","_updateMouseEventsLastPoints","_getDeltaPoints","_isDragPastDoubleClickTolerance","_doStateMouseDownAndUp","_copyPoints","_onMouseUp","clearTimeout","_cleanUp","addEventListener","_onMouseMove","document","removeEventListener","mouseMoveListener","delta","Math","abs","_preventClickHandler","_clearDoubleClickTimeoutAndEvents","_doMouseDown","_state$element","_state$element2","JSON","parse","stringify","points","_subtractPoints2D","point0","point1","mouseDoubleClickIgnoreListener","buttons","setTimeout","disable","mouseDoubleClickListener","mouseDownListener","capture","enable","deltaY","spinX","spinY","pixelX","pixelY","wheelDelta","wheelDeltaY","wheelDeltaX","deltaX","deltaMode","normalizeWheel","direction","wheel","wheelListener","passive","pointerType","lastInteractionType","lastInteractionTime","handleTap","now","Date","stopPropagation","handleTapMouse","bind","handleTapTouch","attachEvents","eventList","interactionType","tapHandler","removeEvents","mouseEvents","touchEvents","Swipe","getTouchEventPoints","touches","changedTouches","touch","identifier","radiusX","radiusY","force","rotationAngle","getDeltaPoints","curr","getMeanPoints","last","getDeltaDistance","_getDistance2D","_getDistance3D","getDeltaRotation","getDeltaDistanceBetweenIPoints","currentDistance","_getMeanDistanceBetweenAllIPoints","lastDistance","copyPointsList","copyPoints","reduce","prev","getMeanTouchPoints","pairedDistance","j","sqrt","pow","Settings","TOUCH_START","TOUCH_START_ACTIVATE","TOUCH_PRESS","TOUCH_DRAG","TOUCH_END","TOUCH_TAP","TOUCH_SWIPE","zeroIPoint","zeroIDistance","startPointsList","lastPointsList","isTouchStart","startTime","pressTimeout","pressDelay","pressMaxDistance","accumulatedDistance","swipeDistanceThreshold","swiped","swipeToleranceMs","defaultTapState","taps","tapTimeout","tapMaxDistance","tapToleranceMs","tapState","triggerEventCallback","ele","name","_onTouchDrag","currentPointsList","_updateTouchEventsLastPoints","deltaDistance","totalDistance","currentTime","getTime","x","y","swipe","RIGHT","LEFT","DOWN","UP","_checkTouchSwipe","_onTouchEnd","_checkTouchTap","lp","_onTouchPress","_onTouchStart","preventGhostClick","touchStartListener","keyCode","keyListener","_onKeyUp","_onVisibilityChange","visibilityState","resetModifierKey","_cloneDeep","keyDownListener","getModifierKey","toolGroupFilteredByIds","tg","some","vp","isVolumeSegmentation","operationData","volumeId","s","SegmentationState","segmentationConfig","getGlobalRepresentationConfig","representationType","setGlobalRepresentationConfig","segmentationRepresentationConfig","getUniqueSegmentIndices","scalarData","getScalarData","keySet","it","parseInt","_segmentation$represe","_segmentation$represe2","CONTOUR","indices","geometryId","geometry","getSegmentIndex","sort","setSegmentationVisibility","visibility","segmentsHidden","getSegmentationVisibility","indicesSet","setSegmentsVisibility","segmentIndices","segRepresentation","setSegmentVisibility","getSegmentVisibility","BaseTool","toolProps","defaultToolProps","initialProps","configuration","supportedInteractionTypes","strategies","defaultStrategy","activeStrategy","strategyOptions","assign","getToolName","applyActiveStrategy","_strategies$activeStr","applyActiveStrategyCallback","callbackType","_strategies$activeStr2","setConfiguration","newConfiguration","setActiveStrategy","strategyName","getTargetVolumeId","_actorEntries$find","actorEntries","getActors","actorEntry","actor","getClassName","getTargetIdImage","targetId","startsWith","imageId","split","imageURI","viewports","getCurrentImageId","getImageData","getTargetId","StackViewport","BaseVolumeViewport","VideoViewport","actorUIDsToRemove","Boolean","removeActors","pointToString","point","decimals","parseFloat","toFixed","polyDataCache","updateSurfacePlanes","vtkPlanes","clippingFilter","mapper","getMapper","viewPlaneNormal","getCamera","imageIndex","getCurrentImageIdIndex","cacheId","actorCache","polyData","setClippingPlanes","update","getOutputData","error","setInputData","render","async","toolGroupConfig","SurfaceData","Representations","surface","surfaceUID","actorUID","getActor","getPoints","polys","getPolys","color","getColor","vtkPolyData","setData","triangles","vtkCellArray","Float32Array","setPolys","vtkMapper","VolumeViewport3D","vtkClipClosedSurface","clippingPlanes","activePlaneId","passPointData","setGenerateOutline","setGenerateFaces","filteredData","vtkActor","setMapper","getProperty","setColor","addActor","addSurfaceToElement","_renderSurface","resetCamera","renderImmediate","getToolGroup","removeSurfaceFromElement","_removeSurfaceFromToolGroupViewports","getViewportsInfo","contourRepresentation","segmentId","_contourRepresentatio","_contourRepresentatio2","configCachePerSegmentationRepresentationUID","getConfigCache","setConfigCache","addContourSetsToElement","contourRepresentationConfig","contourActorUID","appendPolyData","vtkAppendPolyData","scalarToColorMap","segmentSpecificMap","validateGeometry","contourSet","pointArray","vtkPoints","lines","pointIndex","getContours","contour","pointList","flatPoints","getFlatPointsArray","getType","pointIndexes","_","pointListIndex","linePoints","insertNextCell","polygon","setPoints","setLines","getPolyData","getNumberOfPoints","scalars","vtkDataArray","numberOfComponents","dataType","setTuple","getPointData","setScalars","addInputData","polyDataOutput","setLineWidth","setForceOpaque","updateContourSets","newContourConfig","cachedConfig","contourSetsActor","newOutlineWithActive","lut","getLookupTable","segmentsToSetToInvisible","segmentsToSetToVisible","mergedInvisibleSegments","contourSets","segmentSpecificConfigs","acc","affectedSegments","hasCustomSegmentSpecificConfig","polyDataModified","getInputData","appendScalarsData","getScalars","getData","_segmentSpecificConfi","getTotalNumberOfPoints","segmentConfig","modified","setLookupTable","representationConfig","addOrUpdateContourSets","removeContourFromElement","_removeContourFromToolGroupViewports","deleteConfigCache","removeVolumeActors","labelMapConfigCache","getRepresentationRenderingConfig","cfun","vtkColorTransferFunction","ofun","vtkPiecewiseFunction","addPoint","_getLabelmapConfig","toolGroupLabelmapConfig","segmentationRepresentationLabelmapConfig","isActiveLabelmap","segmentsLabelmapConfig","configToUse","outlineWidth","_needsTransferFunctionUpdate","_ref2","segmentColor","cacheUID","oldConfig","forceOpacityUpdate","forceColorUpdate","oldFillAlpha","oldRenderFill","oldRenderOutline","oldOutlineWidth","oldSegmentColor","oldSegmentsHidden","_addLabelmapToViewport","labelmapData","labelMapData","volumeInputs","blendMode","addVolumesToViewports","stackInputs","imageIdReferenceMap","addImageSlicesToViewports","addLabelmapToElement","renderingConfig","labelmapUID","referencedVolumeId","defaultActor","getDefaultActor","defaultActorUID","volume","referencedVolume","isSameFrameOfReference","VolumeViewport","numColors","min","segmentSpecificLabelmapConfig","addRGBPoint","segmentOpacity","removePoint","addPointLong","setRGBTransferFunction","setClamping","setScalarOpacity","setInterpolationTypeToNearest","setUseLabelOutline","setLabelOutlineOpacity","outlineWidths","setLabelOutlineThickness","setVisibility","_setLabelmapColorAndOpacity","removeLabelmapFromElement","_removeLabelmapFromToolGroupViewports","SegmentationDisplayTool","super","toolGroupViewports","segmentationRenderList","_getMergedRepresentationsConfig","viewportsRenderList","display","labelmapDisplay","contourDisplay","surfaceDisplay","renderedViewport","allSettled","then","onSetToolEnabled","onSetToolDisabled","segmentationRenderingEngine","_throwIfDestroyed","_needsRender","_triggerRender","_animationFrameSet","_animationFrameHandle","removeToolGroup","_reset","renderToolGroupSegmentations","_setToolGroupSegmentationToBeRenderedNextFrame","hasBeenDestroyed","_render","requestAnimationFrame","_renderFlaggedToolGroups","getRenderingEngine","getViewport","segmentationDisplayToolInstance","getToolInstance","onSegmentationRender","getToolGroupForViewport","csToolsEvents","renderSegmentation","cancelAnimationFrame","triggerSegmentationRender","_imageChangeEventListener","_toolGroupSegmentatio","eventData","representationList","currentImageId","actors","segmentationActor","derivedImageId","segmentationImageData","scalarArray","imageData","vtkImageData","derivedImage","dimensions","spacing","getImageDataMetadata","currentImage","origin","currentOrigin","originToUse","setOrigin","getDimensions","addImages","callback","imageActor","getPixelData","setDimensions","setSpacing","setDirection","getSvgNode","canvasHash","cacheKey","domRef","appendNode","svgLayerElement","svgNode","touched","appendChild","setNodeTouched","clearUntouched","cacheEntry","removeChild","fn","svgDrawingHelper","viewportElement","querySelector","_getSvgLayer","svgNodeCacheForCanvas","getSvgDrawingHelper","getToolsWithModesForElement","modesFilter","ToolGroupManager","enabledTools","toolInstance","Active","Passive","Enabled","annotationRenderingEngine","elements","_viewportElements","addViewportElement","removeViewportElement","renderViewport","_setViewportsToBeRenderedNextFrame","_setAllViewportsToBeRenderedNextFrame","_renderFlaggedViewports","elementsEnabled","indexOf","drawSvg","anyRendered","tool","renderAnnotation","rendered","onImageRendered","triggerAnnotationRender","getToolsWithModesForMouseEvent","evtButton","correctBinding","bindings","binding","onCameraModified","onImageSpacingCalibrated","customCallbackHandler","handlerType","customFunction","activeTool","filterToolsWithMoveableHandles","ToolAndAnnotations","canvasCoords","proximity","toolsWithMoveableHandles","handle","getHandleNearImagePoint","filterToolsWithAnnotationsForElement","_annotations","filterInteractableAnnotationsForElement","filterMoveableAnnotationTools","moveableAnnotationTools","isPointNearTool","MouseBindings","KeyboardBindings","shiftKey","ctrlKey","kb","altKey","metaKey","getActiveToolForMouseEvent","mouseEvent","modifierKey","getMouseModifier","keyEventListener","defaultMousePrimary","getDefaultMousePrimary","mouseDown","preMouseDownCallback","isPrimaryClick","applicableTools","toolsWithActions","toolModes","_mouseEvent$buttons","_tool$configuration$a","_tool$configuration","actionsConfig","actions","action","getToolsWithActionsForMouseEvent","method","mouseDownAnnotationAction","annotationToolsWithAnnotations","annotationToolsWithMoveableHandles","isMultiSelect","getAnnotationForSelection","toggleAnnotationSelection","handleSelectedCallback","toolSelectedCallback","postMouseDownCallback","toolsWithMovableHandles","mouseDownActivate","addNewAnnotation","mouseDrag","mouseDragCallback","mouseMove","activeAndPassiveTools","toolsWithAnnotations","toolsWithoutAnnotations","toolAndAnnotation","annotationsNeedToBeRedrawn","mouseMoveCallback","mouseClick","mouseDoubleClick","mouseUp","mouseWheel","getActiveToolForKeyboardEvent","keyDown","setViewportsCursorByToolName","activeToolsWithEventBinding","getToolsWithActionsForKeyboardEvent","keyUp","getActiveToolForTouchEvent","touchEvent","numTouchPoints","getToolsWithModesForTouchEvent","touchStart","preTouchStartCallback","postTouchStartCallback","touchStartActivate","touchDrag","touchDragCallback","touchEnd","touchTap","touchPress","addEnabledElement","svgLayer","svgns","createElementNS","svgLayerId","classList","setAttribute","style","width","height","pointerEvents","position","defs","feOffset","feColorMatrix","feBlend","_createSvgAnnotationLayer","newNode","viewportUid","renderingEngineUid","dataset","elementHash","_setSvgNodeCache","mouseEventListeners","wheelEventListener","touchEventListeners","imageChangeEventListener","imageRenderedEventDispatcher","cameraModifiedEventDispatcher","imageSpacingCalibratedEventDispatcher","mouseToolEventDispatcher","keyboardToolEventDispatcher","touchToolEventDispatcher","synchronizersFilteredByIds","synchronizer","notDisabled","isDisabled","hasSourceViewport","hasTargetViewport","elementDisabledEvt","_resetSvgNodeCache","internalViewportNode","_removeSvgNode","getSynchronizersForViewport","sync","remove","_removeViewportFromSynchronizers","removeViewports","_removeViewportFromToolGroup","foundElementIndex","el","_removeEnabledElement","viewportIdsToRender","triggerAnnotationRenderForViewportIds","getRenderingEngines","viewportIds","getViewports","segmentationVolume","vtkOpenGLTexture","slicesToUpdate","numSlices","setUpdatedFrame","segImageData","currentSegmentationImageId","segmentationImage","segmentationRepresentationUIDs","immediate","toolGroupSegRepresentations","toolGroupSegRepresentationUIDs","segRepresentationUIDsToRemove","invalidSegRepresentationUIDs","segRepresentationUID","segmentationDataUID","_removeSegmentation","toolGroupIndex","removeSegmentationsFromToolGroup","csToolsState","destroyToolGroup","csToolsInitialized","init","_removeCornerstoneEventListeners","elementEnabledEvent","elementDisabledEvent","removeEnabledElement","_addCornerstoneEventListeners","_removeCornerstoneToolsEventListeners","TOOLS_EVENTS","annotationModifiedListener","annotationSelectionListener","segmentationModifiedListener","segmentationDataModifiedEventListener","segmentationRepresentationModifiedEventListener","segmentationRepresentationRemovedEventListener","destroy","restoreAnnotations","addTool","ToolClass","toolAlreadyAdded","toolClass","removeTool","cancelActiveManipulations","toolsWithData","cancel","_getViewportIndex","arr","ar","_containsViewport","synchronizerId","eventHandler","_ignoreFiredEvents","_targetViewports","_sourceViewports","fireEvent","_enabled","_eventName","_eventHandler","_options","_auxiliaryEventNames","auxiliaryEventNames","_hasSourceElements","setOptions","_viewportOptions","getOptions","addTarget","addSource","_onEvent","_updateDisableHandlers","getSourceViewports","getTargetViewports","removeSource","t","removeTarget","_getViewportElement","sourceViewport","sourceEvent","promises","targetViewport","ex","vp1","vp2","unique","vps","u","_getUniqueViewports","_remove","disableHandler","vUid","Synchronizer","synchronizerIndex","DEFINED_CURSORS","STANDARD_CURSORS","MouseCursor","fallback","getName","addFallbackStyleProperty","getStyleProperty","getDefinedCursor","definedCursors","getDefinedCursors","mouseCursor","setDefinedCursor","cursor","context","standardCursorNames","AnnotationStyleStates","ImageMouseCursor","url","getUniqueInstanceName","Number","prefix","BASE","iconContent","iconSize","viewBox","mousePoint","mousePointerGroupString","SEGMENTATION_CURSOR_BOUNDARIES","MINUS_RECT","PLUS_RECT","SCISSOR_ICON","RECTANGLE_ICON","CIRCLE_ICON","CursorSVG","Angle","extend","ArrowAnnotate","Bidirectional","CobbAngle","CircleROI","EllipticalROI","FreehandROI","FreehandROISculptor","Length","Probe","RectangleROI","TextMarker","Crosshairs","Eraser","Magnify","Pan","Rotate","StackScroll","WindowLevelRegion","WindowLevel","Zoom","SegmentationFreeHandEraseInside","SegmentationFreeHandFillInside","SegmentationFreeHandEraseOutside","SegmentationFreeHandFillOutside","SegmentationRectangleEraseInside","RectangleScissor","CircleScissor","base","registerCursor","svgCursorNames","_initializeConfig","colorHighlighted","colorSelected","colorLocked","lineWidth","lineDash","shadow","textBoxVisibility","textBoxFontFamily","textBoxFontSize","textBoxColor","textBoxColorHighlighted","textBoxColorSelected","textBoxColorLocked","textBoxBackground","textBoxLinkLineWidth","textBoxLinkLineDash","textBoxShadow","getAnnotationToolStyles","getViewportToolStyles","getToolGroupToolStyles","getDefaultToolStyles","default","setAnnotationStyles","styles","annotationSpecificStyles","setViewportToolStyles","viewportSpecificStyles","setToolGroupToolStyles","toolGroupSpecificStyles","setDefaultToolStyles","toolStyle","specifications","_getToolStyle","property","annotationToolStyles","viewportToolStyles","global","toolGroupToolStyles","globalStyles","toolStyles","styleSpecifier","alternatives","list","getHierarchalPropertyStyles","STATE","MODE","SVGMouseCursor","pointer","urn","getCursorURN","getDefinedSVGCursorDescriptor","URL","createObjectURL","svgString","createSVGIconWithPointer","createSVGIcon","Blob","createSVGIconBlob","createSVGIconUrl","createSVGMouseCursor","format","template","dictionary","dict","defined","scale","max","svgSize","ELEMENT_CURSORS_MAP","initElementCursor","_getElementCursors","_setElementCursor","cursors","resetElementCursor","hideElementCursor","Disabled","ToolGroup","getViewportIds","toolInstanceName","_toolInstances","toolDefinition","hasToolName","localToolInstance","instantiatedTool","addToolInstance","parentClassName","_state$tools$toolName","ToolClassToUse","ParentClass","ToolInstance","addViewport","renderingEngines","renderingEngineUIDToUse","vpId","getActivePrimaryMouseButtonTool","vpInfo","setToolMode","setToolDisabled","setToolEnabled","setToolPassive","setToolActive","restoreToolOptions","toolBindingsOptions","TouchBinding","MouseBinding","hasSameBinding","binding2","binding1","useCursor","_hasMousePrimaryButtonBinding","_setCursorForViewports","onSetToolActive","_renderViewports","_triggerToolModeChangedEvent","prevToolOptions","getToolOptions","onSetToolPassive","toolOptionsForTool","_getCursor","cursorName","_ref3","setToolConfiguration","overwrite","_configuration","Primary","getToolConfiguration","configurationPath","clone","newToolGroupId","_fnToolFilter","fnToolFilter","_sourceToolOptions$bi","sourceToolInstance","sourceToolOptions","sourceToolMode","_toolOptions$bindings","_ref4","cameraSyncCallback","synchronizerInstance","cameraModifiedEvent","tViewport","setCamera","CAMERA_MODIFIED","createCameraPositionSynchronizer","synchronizerName","createSynchronizer","voiSyncCallback","voiModifiedEvent","range","invertStateChanged","invert","tProperties","voiRange","syncInvertState","setProperties","createVOISynchronizer","zoomPanSyncCallback","sViewport","syncZoom","srcZoom","getZoom","setZoom","syncPan","srcPan","getPan","setPan","createZoomPanSynchronizer","val","low","high","scroll","getImageIds","viewportType","scrollSlabs","debounceLoading","loop","useSlabThickness","numScrollSteps","currentStepIndex","sliceRangeInfo","sliceRange","spacingInNormalDirection","focalPoint","newFocalPoint","newPosition","desiredStepIndex","VolumeScrollEventDetail","EVENTS","scrollVolume","currentImageIndex","numberOfSlices","getTargetImageIdIndex","_getImageSliceData","imageIndexToJump","clip","_getImageIndexToJump","getSpatialRegistration","sourceId","imageSliceSyncCallback","disabled","imageId1","sourceImagePositionPatient","metaData","imagePositionPatient","targetImageIds","viewport1","viewport2","viewPlaneNormal1","viewPlaneNormal2","dotProducts","vec3","areViewportsCoplanar","registrationMatrixMat4","getFrameOfReferenceUID","useInitialPosition","mat4","targetImagePositionPatientWithRegistrationMatrix","closestImageIdIndex2","targetPoint","closestImageIdIndex","distance","Infinity","imageIndexToSet","jumpToSlice","STACK_NEW_IMAGE","VOLUME_NEW_IMAGE","createImageSliceSynchronizer","createStackImageSynchronizer","drawingElementType","nodeUID","attributes","currentValue","getAttribute","removeAttribute","circleUID","center","radius","dataId","fill","fillOpacity","strokeOpacity","strokeWidth","svgNodeHash","_getHash","existingCircleElement","cx","cy","stroke","setAttributesIfNecessary","newCircleElement","setNewAttributesIfValid","ellipseUID","canvasCoordinates","existingEllipse","bottom","right","w","hypot","h","angle","atan2","PI","rx","ry","svgEllipseElement","corner1","corner2","drawEllipseByCoordinates","handleGroupUID","uniqueIndex","opacity","side","existingHandleElement","newHandleElement","handlePoints","drawHandle","drawLine","lineUID","start","end","isNaN","existingLine","dropShadowStyle","x1","y1","x2","y2","newLine","drawPolyline","polylineUID","fillColor","connectLastToFirst","existingPolyLine","pointsAttribute","firstPoint","newPolyLine","_createTextSpan","text","textSpanElement","textContent","_drawTextBackground","group","getBBox","insertBefore","firstChild","bBox","textUID","textLines","padding","fontFamily","fontSize","background","textGroupBoundingBox","existingTextGroup","textElement","textSpans","textSpan","textAttributes","textGroupAttributes","textGroup","combinedStyle","_createTextElement","_drawTextGroup","centerX","centerY","findClosestPoint","sourcePoints","minPoint","minDistance","sourcePoint","p1","p2","_distanceBetween","textBoxUID","textBoxPosition","annotationAnchorPoints","textBox","mergedOptions","centering","canvasBoundingBox","drawTextBox","linkUID","refPoint","boundingBox","halfWidth","halfHeight","_boundingBoxPoints","drawLink","drawRect","rectangleUID","_width","existingRect","tlhc","svgRectElement","drawArrow","arrowUID","firstLine","cos","sin","secondLine","drawRedactionRect","_setAttributesIfNecessary","_setNewAttributesIfValid","getAnnotationNearPoint","getAnnotationNearPointOnEnabledElement","found","findAnnotationNearPointByTool","_viewport$getCurrentI","currentId","_annotation$metadata","referencedImageId","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","useRAF","invokeFunc","time","thisArg","startTimer","pendingFunc","shouldInvoke","timeSinceLastCall","timerExpired","trailingEdge","timeSinceLastInvoke","timeWaiting","remainingWait","debounced","isInvoking","_len","_key","leadingEdge","cancelTimer","flush","pending","debounce","calibratedPixelSpacingMetadataProvider","calibrateImageSpacing","calibrationOrScale","getStackViewports","calibrateSpacing","CalibrationTypes","PIXEL_UNITS","SUPPORTED_REGION_DATA_TYPES","SUPPORTED_LENGTH_VARIANT","SUPPORTED_PROBE_VARIANT","UNIT_MAPPING","getCalibratedLengthUnits","handles","image","calibration","hasPixelSpacing","units","sequenceOfUltrasoundRegions","UNCALIBRATED","SQUARE","getCalibratedAreaUnits","getCalibratedScale","_image$calibration","_image$calibration2","getCalibratedLengthUnitsAndScale","imageIndex1","imageIndex2","areaUnits","calibrationType","_regions","regions","region","regionLocationMinX0","regionLocationMaxX1","regionLocationMinY0","regionLocationMaxY1","regionDataType","physicalUnitXDirection","physicalUnitYDirection","physicalDeltaX","physicalDeltaY","getCalibratedProbeUnitsAndValue","supportedRegionsMetadata","referencePixelX0","referencePixelY0","yValue","getCalibratedAspect","_image$calibration3","aspect","pointInShapeCallback","pointInShapeFn","boundsIJK","iMin","iMax","jMin","jMax","kMin","kMax","getDirection","rowCosines","columnCosines","scanAxisNormal","getSpacing","rowSpacing","columnSpacing","scanAxisSpacing","worldPosStart","indexToWorld","rowStep","columnStep","scanAxisStep","xMultiple","yMultiple","zMultiple","pointsInShape","currentPos","k","startPosJ","startPosI","pointIJK","pointLPS","EPSILON","CONSTANTS","calculateBoundingBox","_points$","isWorld","xMin","xMax","yMin","yMax","zMin","zMax","is3D","p","_p$","_p$2","getBoundingBoxAroundShapeIJK","getBoundingBoxAroundShapeWorld","clipBounds","transformWorldToIndex","getSphereBoundsInfo","circlePoints","centerWorld","radiusWorld","topLeftWorld","bottomRightWorld","viewUp","viewRight","_computeBoundsIJKWithCamera","AnnotationFrameRange","imageIdToFrames","frameRangeExtractor","framesToString","framesToImageId","newRangeString","setFrameRange","eventBase","getFrameRange","findNextLink","line","contourPoints","cell","b","nextLine","remainingLines","findContours","firstCell","shift","extraContours","findContoursFromReducedSet","ptInArray","pt","ptA","ptB","replacePointIndexReferences","linesArray","oldIndex","newIndex","removeDuplicatePoints","bypass","getLines","pointsArray","getPoint","getNumberOfCells","getCell","newPoints","newLines","processContourHoles","contours","useXOR","retContours","closedContours","contourWithHoles","contourWithoutHoles","holes","hContour","hIndex","outerContour","innerContour","vertices","pointsNotEnclosed","getIsPointInsidePolygon","inside","xi","yi","xj","yj","checkEnclosed","contourHoleSet","holeIndex","contourIndex","Labelmap","generateContourSetsFromLabelmap","segments","segVolumeId","vol","cornerstoneCache","imageVol","pixelsPerSlice","z","ContourSets","numSegments","segIndex","segment","sliceContours","containedSegmentIndices","sliceIndex","isSliceEmptyForSegment","frameStart","_reducedSet$points","setValue","mSquares","vtkImageMarchingSquares","imageDataCopy","shallowCopy","cValues","setContourValues","setMergePoints","reducedSet","imageIds","FrameNumber","ContourSet","startIdx","endIdx","RectangleROIStartEndThreshold","getContourSequence","toolData","metadataProvider","projectionPoints","projectionPointsImageIds","ContourData","pointsArrayWithPrecision","flat","ContourImageSequence","sopCommon","ReferencedSOPClassUID","sopClassUID","ReferencedSOPInstanceUID","sopInstanceUID","getContourImageSequence","NumberOfContourPoints","ContourGeometricType","AnnotationToPointData","convert","referenceImageId","validateAnnotation","TOOL_NAMES","ContourSequence","ReferencedROINumber","ROIDisplayColor","floor","random","register","StrategyCallbacks","strategySpecificConfiguration","centerSegmentIndex","previewSegmentIndex","segmentationVoxelManager","centerIJK","imageVoxelManager","preview","useCenterSegmentIndex","hasSegmentIndex","hasPreviewIndex","isInObject","existingValue","getAtIJKPoint","THRESHOLD","isDynamic","threshold","oldThreshold","dynamicRadius","useDelta","nestedBounds","ijk","idx","_strategySpecificConf","defaultEquals","lpad","character","join","seed","onFlood","onBoundary","equals","diagonals","startNode","permutations","perms","permutation","c","permute","perm","countNonZeroes","flooded","visits","bounds","currentArgs","flood","boundaries","unshift","job","getArgs","prevArgs","previousArgs","node","safely","member","markAsFlooded","nextArgs","pushAdjacent","markAsBoundary","f","setColorLUT","getColorForSegmentIndex","colorValue","setColorForSegmentIndex","colorReference","determineSegmentIndex","dynamicThreshold","erase","islandRemoval","previewVoxelManager","clickedPoints","getBoundsIJK","bound","floodedSet","toIndex","oldVal","getAtIndex","isIn","floodedCount","setAtIJK","clickedPoint","floodFill","clearedCount","previewCount","trackValue","setAtIJKPoint","islandMap","isInternal","internalSet","onFloodInternal","floodIndex","toIJK","setAtIndex","getArrayOfSlices","_this$onInteractionSt","previewColors","onInteractionStart","_this$onInteractionEn","isPreviewFromHover","onInteractionEnd","sourceVoxelManager","configColor","_preview$segmentIndex","tracking","modifiedSlices","regionFill","_brushStrategy$create","brushStrategy","isWithinThreshold","createIsInThreshold","oldValue","useSegmentIndex","THRESHOLD_INSIDE_CIRCLE","voxelValue","VoxelManager","getStrategyData","segmentationScalarData","imageScalarData","imageVolume","columns","rows","createVolumeVoxelManager","BrushStrategy","initializedData","initialize","_fill","_onInteractionStart","configurationName","initializers","compositions","initializer","childFunctions","strategyFunction","_operationData$previe","createHistoryVoxelManager","_initialize","addListMethod","createInitialized","listName","addSingletonMethod","isInitialized","getCanvasEllipseCorners","ellipseCanvasPoints","pointInEllipse","ellipse","inverts","precalculated","precalculatePointInEllipse","xRadius","yRadius","zRadius","invXRadiusSq","invYRadiusSq","invZRadiusSq","centerL","centerP","centerS","dx","dy","dz","isEqual","initializeCircle","worldToCanvas","topLeftCanvas","bottomRightCanvas","createPointInEllipse","worldInfo","sphereObj","radius2","sphere","pointInSphere","ellipseObj","CIRCLE_STRATEGY","CIRCLE_THRESHOLD_STRATEGY","fillInsideCircle","thresholdInsideCircle","sphereComposition","newBoundsIJK","createEllipseInPoint","SPHERE_STRATEGY","fillInsideSphere","thresholdInsideSphere","eraseInsideSphere","eraseInsideCircle","getActiveSegmentationRepresentation","getActiveSegmentation","activeRepresentation","isSegmentIndexLocked","setSegmentIndexLocked","getLockedSegments","invalidateBrushCursor","getBrushToolInstances","viewportsInfoArray","setActiveSegmentIndex","getActiveSegmentIndex","BrushTool","FILL_INSIDE_CIRCLE","ERASE_INSIDE_CIRCLE","FILL_INSIDE_SPHERE","ERASE_INSIDE_SPHERE","THRESHOLD_INSIDE_SPHERE","brushSize","enabled","previewTimeMs","previewMoveDistance","dragMoveDistance","dragTimeMs","centerRadius","timerStart","timer","startPoint","NaN","isDrag","disableCursor","_editData","createEditData","_activateDraw","_previewData","hoverData","_hoverData","createHoverData","triggerAnnotationRenderForViewportUIDs","getOperationData","updateCursor","vec2","rejectPreview","previewCallback","_deactivateDraw","acceptPreview","_endCallback","_dragCallback","activeSegmentationRepresentation","activeSegmentation","segmentLocking","segmentationState","centerCanvas","getActiveSegmentationData","brushCursor","segmentIndexController","_calculateCursor","_data$handles","_this$_previewData","editData","centerCursorInWorld","bottomCursorInWorld","topCursorInWorld","leftCursorInWorld","rightCursorInWorld","_toolMetadata$segment","toolMetadata","brushCursorUID","drawCircleSvg","toolInstances","getVoxelOverlap","voxelSpacing","voxelCenter","voxelCornersWorld","processVolumes","thresholdVolumeInformation","segmentationSpacing","volumeInfoList","baseVolumeIdx","volumeSize","referenceValues","lower","upper","equalsCheck","overlapType","overlaps","testOverlapRange","volumeInfo","overlapBounds","overlapTest","testRange","computeOffsetIndex","insert","filterViewportsWithFrameOfReferenceUID","numViewports","viewportsWithFrameOfReferenceUID","filterViewportsWithToolEnabled","viewportsWithToolEnabled","_toolGroupHasActiveEnabledOrPassiveTool","toolMode","EPS","vpCamera","getViewportIdsWithToolToRender","requireParallelNormals","filterViewportsWithParallelNormals","PARALLEL_THRESHOLD","filterAnnotationsWithinSlice","annotationsWithParallelNormals","td","annotationViewPlaneNormal","imageOrientationPatient","rowCosineVec","colCosineVec","isParallel","halfSpacingInNormalDirection","annotationsWithinSlice","dir","dot","baseUrlExtractor","filterAnnotationsForDisplay","colonIndex","substring","testURI","hasImageURI","annotationFrameRange","frameNumber","getFrameNumber","highlighted","AnnotationDisplayTool","getFramesOfReference","frameOfReference","getReferencedImageId","worldPos","getStyle","AnnotationTool","_toolProps$configurat","_toolProps$configurat2","filteredAnnotations","activateHandleIndex","activeHandleIndex","near","_imagePointNearToolOrHandle","nearToolAndNotMarkedActive","notNearToolAndMarkedActive","getTextLines","statsCalculator","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","annotationCanvasCoordinate","getLinkedTextBoxStyle","isSuvScaled","_volume$scaling","scaling","PT","scalingModule","suvbw","getAnnotationStyle","lineOpacity","textbox","distanceToPointSquared","z1","z2","distanceToPointSquaredInfo","lineStart","lineEnd","closestPoint","distanceSquared","math","dotProduct","distanceToPoint","lineSegments","rectToLineSegments","lineSegment","getTextBoxCoordsCanvas","annotationCanvasPoints","corners","canvasPoints","handlesLeftToRight","handlesTopToBottom","_determineCorners","getWorldWidthAndHeightFromCorners","pos1","pos2","diagonal","diagonalLength","worldWidth","worldHeight","cosTheta","getModalityUnit","modality","isPreScaled","generalSeriesModule","petSeriesModule","_handlePTModality","isViewportPreScaled","targetIdTokens","preScale","scaled","Calculator","BasicStatsCalculator","singleArrayAsNumber","_class","sum","sumSquares","squaredDiffSum","newArray","mean","stdDev","stdDevWithSumSquare","currentMax","unit","RectangleROITool","preventHandleOutsideImage","defaultGetTextLines","isDrawing","hasMoved","worldPosition","handleIndex","movingTextBox","newAnnotation","canvasPoint1","canvasPoint2","_getRectangleImageCoordinates","rectangle","_activateModify","_deactivateModify","isHandleOutsideImage","worldPosDelta","bottomLeftCanvas","topRightCanvas","bottomLeftWorld","topRightWorld","_annotations2","renderStatus","areaUnit","_throttledCalculateCachedStats","referencedImageURI","currentImageURI","Modality","area","_calculateCachedStats","activeHandleCanvasCoords","drawHandlesSvg","drawRectSvg","canvasTextBoxCoords","drawLinkedTextBoxSvg","worldPos1","worldPos2","targetIds","worldPos1Index","worldPos2Index","_isInsideVolume","_stats$","_stats$2","_stats$3","modalityUnitOptions","modalityUnit","statsCallback","stats","getStatistics","statsArray","index1","index2","throttle","cachedVolumeStats","roundNumber","RectangleROIThresholdTool","RectangleROIStartEndThresholdTool","numSlicesToPropagate","startIndex","spacingInNormal","endIndex","_getEndSliceIndex","startSlice","endSlice","_computeProjectionPoints","firstOrLastSlice","lineDashToUse","_calculateCachedStatsTool","startIJK","endIJK","startWorld","indexToWorldVec3","endWorld","newProjectionPoints","dist","newPoint","RectanglePoints","endPos","imageIdIndex","numSlicesToProject","sliceNormalIndex","referenceVolume","AllBoundsIJK","_data$cachedStats","_data$cachedStats2","pointsToUse","extend2DBoundingBoxInViewAxis","annotationUIDs","validToolNames","_validateAnnotations","getBoundsIJKFromRectangleAnnotations","thresholdVolumeByRange","labelmaps","labelmap","outputData","arrayType","volumeLoader","isValidRepresentationConfig","SegmentationRepresentation","isValidLabelmapConfig","getDefaultRepresentationConfig","createLabelmapVolumeForViewport","_options$volumeId","properties","setBrushSizeForToolGroup","getBrushSizeForToolGroup","brushToolInstance","setBrushThresholdForToolGroup","otherArgs","brushBasedToolInstances","getBrushThresholdForToolGroup","segmentationIndex","_handleSameSizeVolume","callbackOverlap","_handleDifferentSizeVolume","createImageIdReferenceMap","imageIdsArray","segmentationImageIds","isLineInSegment","point2","isInSegment","ijk1","ijk2","testPoint","testIJK","testSize","round","unitDelta","createBidirectionalForSlice","sliceContour","maxMajor","maxMinor","currentMaxMinor","currentMaxMajor","maxMajorPoints","distance2","testCenter","handle0","handle1","unitMajor","maxMinorPoints","majorAxis","minorAxis","contourAndFindLargestBidirectional","maxBidirectional","worldToIndex","createIsInSegment","bidirectional","findLargestBidirectional","createBidirectionalToolData","bidirectionalData","major0","major1","minor0","minor1","sign","intersectLine","line1Start","line1End","line2Start","line2End","x3","y3","x4","y4","a1","b1","c1","r3","r4","a2","b2","c2","r1","r2","denom","num","BidirectionalTool","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","currentShortAxisVector","shortAxis","canvasCoordPoints","shortAxisDistFromCenter","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","_dragDrawCallback","_dragModifyCallback","dataId1","dataId2","drawLineSvg","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos3","worldPos4","dist1","_calculateLength","dist2","index3","index4","vector1","vector2","segmentContourAction","configurationData","getSegment","defaultGetSegment","segmentationsList","bidirectionals","annotationState","hasExistingActiveSegment","existingLargestBidirectionals","existingBidirectionalItem","newBidirectional","existingLargestBidirectional","updateSegment","bidirectionalToolData","annotationConfig","_configuration$segmen","_configuration$segmen2","segmentData","aabb","aabbWidth","maxX","minX","aabbHeight","maxY","minY","aabbSize","aabbCenter","translatedPoint","mirror","mirrorPoint","staticPoint","getIntersectionCoordinatesWithPolyline","q1","polylineIndexes","initialI","intersections","doesIntersect","getAllIntersectionsWithPolyline","intersection","getIntersection","getFirstIntersectionWithPolyline","getClosestIntersectionWithPolyline","q2","distances","intersectionPoints","midpoint","orient","orientation","onSegment","q","orientationValue","denominator","numerator1","numerator2","getSubPixelSpacingAndXYDirections","subPixelResolution","xDir","yDir","volumeSpacing","iVector","jVector","kVector","absViewRightDotI","absViewRightDotJ","absViewRightDotK","xSpacing","absViewUpDotI","absViewUpDotJ","absViewUpDotK","ySpacing","pointsAreWithinCloseContourProximity","closeContourProximity","addCanvasPointsToArray","newCanvasPoint","commonData","lastWorldPos","newWorldPos","worldPosDiff","xDist","yDist","numPointsToAdd","lastCanvasPoint","canvasDist","canvasDir","distPerPoint","pointCanProjectOnLine","p1p","p1p2","p1p2Mag","projectionVectorMag","p1p2UnitVector","projectionVector","projectionPoint","calculateAreaOfPoints","INSIDE","OUTSIDE","clipT","tE","tL","box","da","db","getPointInLineOfSightWithCriteria","targetVolumeId","criteriaFunction","stepSize","cameraPosition","step","getBounds","vector","pickedPoint","vtkMath","pointT","_inBounds","pointToPick","getIntensityFromWorld","getOrientationStringLPS","orientationX","orientationY","orientationZ","MIN","invertOrientationStringLPS","orientationString","inverted","toUpperCase","addToolState","getToolState","ViewportStatus","dynamicVolumesPlayingMap","playClip","playClipOptions","_playClipOptions$dyna","playClipTimeouts","playClipIsTimeVarying","dynamicCineEnabled","_getVolumeFromViewport","playClipContext","_playClipOptions$wait","waitForRendered","frameTimeVectorEnabled","waitForRenderedCount","viewportStatus","RENDERED","_createStackViewportCinePlayContext","isDynamicVolume","numTimePoints","timePointIndex","_createDynamicVolumeViewportCinePlayContext","cachedScrollInfo","scrollInfo","getScrollInfo","volumeViewPlaneNormal","glMatrix","_createVolumeViewportCinePlayContext","_createCinePlayContext","playClipData","isDynamicCinePlaying","_playClipOptions$fram","_playClipOptions$fram2","_playClipOptions$reve","_playClipOptions$loop","_stopDynamicVolumeCine","_stopClip","intervalId","framesPerSecond","lastFrameTimeStamp","ignoreFrameTimeVector","usingFrameTimeVector","frameTimeVector","speed","frameTimeVectorSpeedMultiplier","reverse","timeouts","isTimeVarying","sample","delay","limit","_getPlayClipTimeouts","playClipAction","newStepIndex","CINE_EVENTS","playClipTimeoutHandler","setInterval","stopClip","stopDynamicCine","cineToolData","clearInterval","_stopClipWithData","dynamicCineElement","volumes","_getVolumesFromViewport","dynamicVolume","v1","v2","v0","v3","t1","t2","t3","basis","interpolator","samples","zip","matrix","m","valueof","transpose","row","interpolateSegmentPoints","iniIndex","knotsRatioPercentage","_Math$floor","_Math$floor2","segmentSize","amountOfKnots","minKnotDistance","interpolationIniIndex","interpolationEndIndex","segmentPointsUnchangedBeg","segmentPointsUnchangedEnd","originalPoints","knotsIndexes","xInterpolator","d3InterpolateBasis","yInterpolator","zInterpolator","d3Zip","d3Quantize","interpolatePoints","minDistributionDistance","closedInterval","intervalIni","intervalEnd","intervalSize","intensity","continuosDistributionValue","getContinuousUniformDistributionValues","shouldInterpolate","_configuration$interp","_configuration$interp2","interpolation","interpolateOnAdd","interpolateOnEdit","followingIndex","circularFindNextIndexBy","listParams","otherListParams","criteria","indexDelimiter","otherIndexDelimiter","otherPoints","pointsLength","otherPointsLength","otherStartIndex","getInterpolatedPoints","pointsOfReference","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","changedIniIndex","changedEndIndex","previousPoints","firstMatchIndex","previousFirstMatchIndex","findMatchIndexes","toBeNotEqualCriteria","pointA","pointB","isEqualByProximity","lowDiffIndex","lowOtherDiffIndex","highIndex","findChangedSegment","findOpenUShapedContourVectorToPeak","first","firstToLastUnitVector","normalVector1","normalVector2","centerOfFirstToLast","furthest","polyline","activateDraw","canvasPos","drawData","polylineIndex","mouseUpDrawCallback","mouseDragDrawCallback","deactivateDraw","lastWorldPoint","crossingIndex","findCrossingIndexDuringCreate","applyCreateOnCross","numPointsAdded","allowOpenContours","lastPoint","completeDrawOpenContour","completeDrawClosedContour","removeCrossedLinesOnCompleteDraw","haltDrawing","worldPoints","closed","triggerAnnotationCompleted","numPoints","endToStart","canvasPointsMinusEnds","indexToRemoveUpTo","isOpenUShapeContour","openUShapeContourVectorToPeak","pointsLessLastOne","activateClosedContourEdit","cancelDrawing","minPoints","shouldHaltDrawing","checkForFirstCrossing","isClosedContour","editCanvasPoints","prevCanvasPoints","crossedLineSegment","startCrossingIndex","removePointsUpUntilFirstCrossing","checkCanvasEditFallbackProximity","firstEditCanvasPoint","distanceIndexPairs","prevCanvasPoint","twoClosestDistanceIndexPairs","lowestIndex","extendedPoint","crossedLineSegmentFromExtendedPoint","pointsToPrepend","editIndex","numPointsToRemove","checkForSecondCrossing","removePointsAfterSecondCrossing","lastLine","didCrossLine","findSnapIndex","lastEditCanvasPoint","editCanvasPointsLessLastOne","snapCanvasPosition","checkAndRemoveCrossesOnEditLine","editIndexCrossed","isEditingClosed","mouseUpClosedContourEditCallback","mouseDragClosedContourEditCallback","deactivateClosedContourEdit","currentEditIndex","snapIndex","fusedCanvasPoints","fuseEditPointsWithClosedContour","finishEditAndStartNewEdit","triggerAnnotationModified","augmentedEditCanvasPoints","lowIndex","distanceBetweenLowAndFirstPoint","distanceBetweenLowAndLastPoint","distanceBetweenHighAndFirstPoint","distanceBetweenHighAndLastPoint","pointSet1","inPlaceDistance","reverseDistance","pointSet2","completeClosedContourEdit","cancelClosedContourEdit","activateOpenContourEdit","isEditingOpen","mouseUpOpenContourEditCallback","mouseDragOpenContourEditCallback","deactivateOpenContourEdit","fuseEditPointsWithOpenContour","finishEditOpenOnSecondCrossing","checkIfShouldOverwriteAnEnd","openContourEditOverwriteEnd","fuseEditPointsForOpenContourEndEdit","activateOpenContourEndEdit","lastCanvasPos","p3","aDotb","magA","magB","acos","newCanvasPoints","pointsToRender","completeOpenContourEdit","cancelOpenContourEdit","_getRenderingOptions","renderContour","_enabledElement$viewp","renderClosedContour","findOpenUShapedContourVectorToPeakOnRender","calculateUShapeContourVectorToPeakIfNotPresent","renderOpenUShapedContour","renderOpenContour","drawPolylineSvg","_this$configuration$a","alwaysRenderOpenContourHandles","handlePoint","firstCanvasPoint","openUShapeContourVectorToPeakCanvas","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","ContourBaseTool","annotationStyle","annotationRendered","renderAnnotationInstance","createAnnotation","cancelAnnotation","getPolylinePoints","_annotation$data$cont","_annotation$data$cont2","renderContext","polylineCanvasPoints","ContourSegmentationBaseTool","isContourSegmentationTool","contourAnnotation","segmentationType","_registerContourSegmentationAnnotation","_unregisterContourSegmentationAnnotation","contourSegmentationStyle","_getContourSegmentationStyle","_globalConfig$represe","_globalConfig$represe2","_toolGroupConfig$repr","_toolGroupConfig$repr2","_segmentationRepresen","_segmentConfig$CONTOU","annotationLocked","segmentationVisible","segmentVisible","mergedConfig","_mergedConfig$outline","_mergedConfig$outline2","_mergedConfig$outline3","_mergedConfig$fillAlp","_mergedConfig$outline4","_mergedConfig$outline5","_mergedConfig$outline6","_mergedConfig$fillAlp2","outlineDashActive","outlineDashInactive","annotationsUIDsSet","PlanarFreehandROITool","calculateStats","previousPoint","pStart","pEnd","originalWorldPoint","deltaXPoint","deltaYPoint","deltaInX","deltaInY","worldPosIndex","iDelta","jDelta","kDelta","ceil","worldPosEnd","canvasPosEnd","curRow","intersectionCounter","_annotation$annotatio","drawLinkedTextBox","registerDrawLoop","registerEditLoopCommon","registerClosedContourEditLoop","registerOpenContourEditLoop","registerOpenContourEndEditLoop","registerRenderMethods","annotationsToDisplay","activeAnnotationUID","_calculateStatsIfActive","_renderStats","_this$commonData","_this$commonData2","_this$commonData3","isEmptyArea","areaLine","interpolateAnnotation","_annotation$data","shouldPreventInterpolation","interpolatedCanvasPoints","axisList","isAxisAlignedRectangle","rectangleCornersIJK","rectangleVec1","rectangleVec2","calculateAnglesWithAxes","every","vec","axes","axis","requestType","priority","lowEnd","highEnd","getStackData","currentImageIdIndex","getPromiseRemovedHandler","stackData","stackPrefetchData","indicesToRequest","clearFromImageIds","imageIdSet","requestDetails","additionalDetails","resetPrefetchTimeout","maxImagesToPrefetch","preserveExistingPool","prefetch","_stack$imageIds","_stackPrefetch$indice","stackPrefetch","removeFromList","imageLoadPoolManager","nearest","v","nearestIndex","nextImageIdIndex","lowerIndex","higherIndex","imageIdsToPrefetch","currentIndex","shouldLoadLower","shouldLoadHigher","requestFn","imageLoader","useNorm16Texture","getCoreConfiguration","rendering","targetBuffer","onImageUpdated","target","indexOfCurrentImage","promiseRemovedHandler","getConfiguration","minBefore","maxAfter","directionExtraImages","indicesToRequestCopy","_image$image","decodeTimeInMS","_image$image2","loadTimeInMS","sizeInBytes","usage","cacheFill","fillTime","fillSize","log","initialTime","initialSize","updateToolState","doneCallback","stackCount","totalBytes","positionFraction","minIndex","maxIndex","jumpToWorld","jumpWorld","normal","dotProd","projectedDelta","_applyShift","frames","frameNumbers","maskVolumeId","imageCoordinate","dataInTime","ijkCoords","maskImageData","segScalarData","len","nonZeroVoxelIndices","actualLen","dynamicVolumeScalarDataArray","getScalarDataArrays","indexValues","frame","activeScalarData","segPointLPS","segValue","segPointIJK","overlapIJKMinMax","perFrameSum","averageValues","_getTimePointDataMask","coordinate","allScalarData","scalarIndex","_getTimePointDataCoordinate","operation","numFrames","typedArrays","arrayLength","finalArray","currentArray","getPolyDataPointIndexes","linesData","findStartingPoint","nextPoint","getPolyDataPoints","contoursIndexes","rawPointsData","contourIndexes","ColorbarRangeTextPosition","isRangeValid","areColorbarRangesEqual","isColorbarSizeValid","areColorbarSizesEqual","clamp","ColorbarCanvas","validateProps","colormap","imageRange","container","showFullPixelValueRange","_colormap","_imageRange","_voiRange","_showFullImageRange","_canvas","_createRootElement","appendTo","_setCanvasSize","showFullImageRange","dispose","parentElement","createElement","boxSizing","isConnected","RGBPoints","rgbPoints","colorsCount","getColorPoint","canvasContext","getContext","isHorizontal","maxValue","windowWidth","previousColorPoint","currentColorPoint","incRawPixelValue","rawPixelValue","tVoiRange","normColor","tColorRange","fillStyle","fillRect","interpolateVec3","DEFAULTS","FONT","COLOR","TICK_SIZE","TICK_WIDTH","TICK_LABEL_MARGIN","MAX_NUM_TICKS","TICKS_STEPS","ColorbarTicks","_ticksStyle$font","_ticksStyle$color","_ticksStyle$tickSize","_ticksStyle$tickWidth","_ticksStyle$labelMarg","_ticksStyle$maxNumTic","ticks","ticksProps","ticksStyle","rangeTextPosition","_font","font","_color","_tickSize","tickSize","_tickWidth","tickWidth","_labelMargin","labelMargin","_maxNumTicks","maxNumTicks","_rangeTextPosition","Right","_showFullPixelValueRange","_createCanvasElement","showFullRange","_getTicks","roughStep","stepPower","log10","roughtStepNormalized","scaleMax","scaleMin","ticksCount","_getLeftTickInfo","labelMeasure","labelPoint","tickPoints","_getRightTickInfo","_getTopTickInfo","_getBottomTickInfo","maxCanvasPixelValue","rangeWidth","clearRect","textBaseline","strokeStyle","tick","measureText","tickInfo","Top","Left","tickStart","tickEnd","beginPath","moveTo","lineTo","fillText","Widget","contentRect","contentBoxSize","inlineSize","blockSize","_containerSize","onContainerResize","_id","_rootElement","createRootElement","_containerResizeObserver","ResizeObserver","_containerResizeCallback","rootElement","resizeObserver","currentContainer","unobserve","observe","disconnect","containerSize","MULTIPLIER","RANGE_TEXT_POSITION","TICKS_BAR_SIZE","Colorbar","_props$ticks$position","_props$ticks","_isMouseOver","showTicks","hideTicks","_isInteracting","_addVOIEventListeners","initialState","multipliers","getVOIMultipliers","_getPointsFromMouseEvent","startVOIRange","canvasDelta","local","wwDelta","wcDelta","voiLower","voiUpper","windowCenter","newVoiRange","_removeVOIEventListeners","_eventListenersManager","_colormaps","getColormapsMap","_activeColormapName","getInitialColormapName","_createCanvas","_ticksBar","_createTicksBar","_addRootElementEventListeners","activeColormapName","colormapName","currentVoiRange","onVoiChange","reset","updateTicksBar","colormaps","items","Name","cm","containerWidth","containerHeight","ticksBar","colorbarWidth","colorbarHeight","Bottom","isRangeTextPositionValid","ticksBarTop","ticksBarLeft","_mouseOverCallback","_mouseOutCallback","_mouseDownCallback","initialDragState","_mouseUpCallback","_mouseDragCallback","defaultImageRange","ViewportColorbar","_getImageRange","_getVOIRange","_hideTicksTimeoutId","timeLeft","_hideTicksTime","autoHideTicks","_element","_volumeId","showAndAutoHideTicks","_addCornerstoneEventListener","clientWidth","clientHeight","ptMultiplier","fixedPTWindowWidth","xMultiplier","viewportsContainingVolumeUID","getRange","volumeActor","getRGBTransferFunction","interval","IMAGE_VOLUME_MODIFIED","_imageVolumeModifiedCallback","_stackNewImageCallback","VOI_MODIFIED","_viewportVOIModifiedCallback","setElementCursor","CursorNames","AnnotationGroup","visibleFilter","unboundVisibleFilter","_isVisible","setVisible","baseEvent","findNearby","uids","_len2","_key2","segmentationInputArray","validateLabelmap","validateSegmentationInput","segInput","addSegmentationToState","getRepresentationSpecificConfig","representationInput","getLabelmapRenderingConfig","representationInputArray","toolGroupSpecificRepresentationConfig","toolGroupSpecificConfig","colorLUTOrIndexInput","colorLUTOrIndex","colorLUTIndexToUse","nextIndex","CORNERSTONE_COLOR_LUT","toolGroupSpecificRepresentation","currentToolGroupConfig","SegmentationConfig","addSegmentationRepresentationToState","all","convertStackToVolumeSegmentation","_options$newSegmentat","_options$removeOrigin","LABELMAP","newSegmentationId","removeOriginal","addSegmentations","addSegmentationRepresentations","convertVolumeToStackSegmentation","_segmentationVolume$a","_segmentationVolume$r","referencedImageIds","_referencedVolume$ima","_referencedVolume$ima2","_segmentationImageIds","segmentationImageIdsToUse","convertToImageSlicesAndCache","_getImageIdReferenceMapForStackSegmentation","PanTool","deltaPointsWorld","updatedPosition","updatedFocalPoint","TrackballRotateTool","rotateIncrementDegrees","vtkCamera","getVtkActiveCamera","getViewUp","getFocalPoint","getPosition","newViewUp","currentPointsCanvas","lastPointsCanvas","normalizedPosition","normalizedPreviousPosition","radsq","op","oe","opsq","oesq","lop","loe","nop","noe","angleX","upVec","atV","rightV","forwardV","rotateCamera","angleY","ProbeTool","eventDispatchDetail","textCanvasCoordinates","drawTextBoxSvg","samplesPerPixel","baseIndex","calibratedResults","hasEnhancedRegionValues","DragProbeTool","WindowLevelTool","middleSliceIndex","frameLength","bytesPerVoxel","TypedArrayConstructor","Uint16Array","Int16Array","_getMinMax","newRange","getProperties","_viewport$getImageDat","_preScale$scalingPara","scalingParameters","getPTScaledNewRange","deltaPointsCanvas","getNewRange","multiplier","_getMultiplierFromDynamicRange","imageDynamicRange","_imageVolume$metadata","calculatedDynamicRange","_getImageDynamicRangeFromMiddleSlice","BitsStored","metadataDynamicRange","_getImageDynamicRangeFromViewport","ratio","voxel","ZoomTool","_this","zoomToCenter","minZoomScale","maxZoomScale","pinchToZoom","pan","initialMousePosWorld","dirVec","pinch","parallelScale","parallelScaleToSet","focalPointToSet","positionToSet","distanceToCanvasCenter","cappedParallelScale","thresholdExceeded","zoomScale","directionOfProjection","tmp","_pinchCallback","parallelProjection","_dragParallelProjection","_dragPerspectiveProjection","_panCallback","StackScrollTool","debounceIfNotLoaded","deltaPointY","pixelsPerImage","_getPixelPerImage","imageIdIndexOffset","getNumberOfSlices","offsetHeight","angleBetweenLines","line1","line2","p4","angleBetween3DLines","angleBetween2DLines","PlanarRotateTool","currentPointWorld","startPointWorld","cross","rotAngle","rotMat","rotatedViewUp","rotation","StackScrollMouseWheelTool","mouseWheelCallback","DIRECTIONS","X","Y","Z","CUSTOM","VolumeRotateMouseWheelTool","cz","ax","ay","az","MIPJumpToClickTool","targetViewportIds","mouseClickCallback","maxIntensity","brightestPoint","maxFn","foundToolGroup","LengthTool","RENDERING_DEFAULTS","defaultReferenceLineColor","defaultReferenceLineControllable","defaultReferenceLineDraggableRotatable","defaultReferenceLineSlabThicknessControlsOn","CrosshairsTool","_toolProps$configurat3","_toolProps$configurat4","viewportIndicators","autoPan","panSize","referenceLinesCenterGapRadius","filterActorUIDsToSetSlabThickness","slabThicknessBlendMode","mobile","_getAnnotations","cameraFocalPoint","rotationPoints","slabThicknessPoints","toolCenter","activeOperation","activeViewportIds","firstViewport","secondViewport","thirdViewport","normal1","initializeViewport","normal2","normal3","point3","firstPlane","secondPlane","thirdPlane","_jump","viewportIdArray","otherViewport","viewportControllable","_getReferenceLineControllable","viewportDraggableRotatable","_getReferenceLineDraggableRotatable","_pointNearTool","viewportAnnotation","currentCamera","oldCameraPosition","deltaCameraPosition","oldCameraFocalPoint","deltaCameraFocalPoint","isRotation","cameraModifiedInPlane","_autoPanViewportIfNecessary","filteredToolAnnotations","imageNeedsUpdate","previousActiveOperation","previousActiveViewportIds","_areViewportIdArraysEqual","canvasDiagonalLength","canvasMinDimensionLength","crosshairCenterCanvas","otherViewportAnnotations","_filterAnnotationsByUniqueViewportOrientations","referenceLines","canvasBox","otherCamera","otherViewportControllable","otherViewportDraggableRotatable","otherViewportSlabThicknessControlsOn","_getReferenceLineSlabThicknessControlsOn","otherCanvasDiagonalLength","otherCanvasCenter","otherViewportCenterWorld","pointWorld0","pointWorld1","pointCanvas0","otherViewportCenterCanvas","canvasUnitVectorFromCenter","canvasVectorFromCenterLong","canvasVectorFromCenterMid","canvasVectorFromCenterShort","canvasVectorFromCenterStart","centerGap","refLinePointOne","refLinePointTwo","refLinePointThree","refLinePointFour","refLinesCenter","liangBarksyClip","rotHandleOne","rotHandleTwo","stHandlesCenterCanvas","stHandlesCenterWorld","worldUnitVectorFromCenter","vtkMatrixBuilder","rotate","worldUnitOrthoVectorFromCenter","slabThicknessValue","getSlabThickness","worldOrthoVectorFromCenter","worldVerticalRefPoint","canvasVerticalRefPoint","canvasOrthoVectorFromCenter","stLinePointOne","stLinePointTwo","stLinePointThree","stLinePointFour","stHandleOne","stHandleTwo","stHandleThree","stHandleFour","newRtpoints","newStpoints","viewportColor","_getReferenceLineColor","lineIndex","_this$configuration$m","_this$configuration$m2","viewportSlabThicknessControlsOn","selectedViewportId","lineActive","_this$configuration$m3","rotHandlesActive","rotationHandles","rotHandleWorldOne","rotHandleWorldTwo","slabThicknessHandlesActive","slabThicknessHandles","slabThicknessHandleWorldOne","slabThicknessHandleWorldTwo","slabThicknessHandleWorldThree","slabThicknessHandleWorldFour","_this$configuration$m4","_this$configuration$m5","_this$configuration$m6","_this$configuration$m7","_this$configuration$m8","_this$configuration$m9","_this$configuration$m10","_this$configuration$m11","handleUID","_this$configuration$m12","_this$configuration$m13","_this$configuration$m14","_this$configuration$m15","_this$configuration$m16","_this$configuration$m17","_this$configuration$m18","_this$configuration$m19","_getViewportsInfo","computeToolCenter","viewportIdArrayOne","viewportIdArrayTwo","itemFound","viewportsWithDifferentCameras","cameraOfTarget","referenceAnnotation","linkedViewportAnnotations","otherViewPlaneNormal","otherLinkedViewportAnnotationsFromSameScene","otherViewportsAnnotationsWithUniqueCameras","cameraFound","jj","cameraOfStocked","otherNonLinkedViewportAnnotationsFromSameScene","_getAnnotationsForViewportsWithDifferentCameras","otherViewportActors","sameScene","viewportsAnnotationsToUpdate","_checkIfViewportsRenderingSameScene","_applyDeltaShiftToSelectedViewportCameras","_this$configuration$m20","dir1","dir2","finalPointCanvas","originalPointCanvas","_isClockWise","rotationAxis","translate","otherViewportsIds","renderViewports","referenceAnnotations","_filterViewportWithSameOrientation","viewportsIds","mod","currentPoint","currentCenter","otherViewportRotationPoints","dotProdDirection","projectedDirection","normalizedProjectedDirection","normalizedProjectedDelta","MINIMUM_SLAB_THICKNESS","_pointNearReferenceLine","setSlabThickness","lineViewport","lineSegment1","distanceToPoint1","lineSegment2","distanceToPoint2","getReferenceLineColor","getReferenceLineControllable","getReferenceLineDraggableRotatable","getReferenceLineSlabThicknessControlsOn","_unsubscribeToViewportNewVolumeSet","_subscribeToViewportNewVolumeSet","_ref5","_getRotationHandleNearImagePoint","_getSlabThicknessHandleNearImagePoint","_ref6","_onNewVolume","_ref7","toolCenterCanvas","visiblePointCanvas","visiblePointWorld","slabThickness","actorUIDs","blendModeToUse","setBlendMode","_applyDeltaShiftToViewportCamera","stPointLineCanvas1","stPointLineCanvas2","stPointLineCanvas1Start","stPointLineCanvas2Start","ReferenceLines","sourceViewportId","showFullDimension","sourceViewportCanvasCornersInWorld","_init","sourceViewPlaneNormal","targetViewportPlane","pointSetToUse","topBottomVec","topRightVec","newNormal","isPerpendicular","lineStartWorld","lineEndWorld","handleFullDimension","vec1","targetImage","topLeftImageCoord","topRightImageCoord","bottomRightImageCoord","bottomLeftImageCoord","lineStartImageCoord","lineEndImageCoord","intersectInfiniteLines","isInBound","err","OverlayGridTool","sourceImageIds","imagePlaneModule","pointSets","calculateImageIdPointSets","viewportData","rowPixelSpacing","columnPixelSpacing","imageIdNormal","getImageIdNormal","targetData","initializeViewportData","pointSetsToUse","lineStartsWorld","lineEndsWorld","SegmentationIntersectionTool","_getRenderingEngine","actorsWorldPointsMap","_getRenderingEngine2","calculateSurfaceSegmentationIntersectionsForViewport","calculateSurfaceSegmentationIntersections","getCacheId","actorWorldPointMap","polyLineIdx","worldPointsSet","polyLineUID","actorWorldPointsMap","polyDataUtils","colorArray","colorComponentToString","component","componentString","colorToString","getWorldWidthAndHeightFromTwoPoints","EllipticalROITool","centerPointRadius","initialRotation","getRotation","canvasCorners","minorEllipse","majorEllipse","pointInMinorEllipse","_pointInEllipseCanvas","canvasWidth","canvasHeight","originalHandleCanvas","pointsCanvas","currentCanvasPoints","dX","dY","bottomCanvas","topCanvas","leftCanvas","rightCanvas","_dragHandle","dYCanvas","canvasBottom","canvasTop","newHalfCanvasWidth","canvasLeft","canvasRight","dXCanvas","newHalfCanvasHeight","drawEllipseSvg","centerPoint","_getCanvasEllipseCenter","fast","location","normalized","getCanvasCircleRadius","circleCanvasPoints","getCanvasCircleCorners","CircleROITool","radiusPoint","canvasCenter","canvasEnd","radiusUnit","perimeter","radiusLine","Spline","_props$resolution","_props$closed","_controlPoints","_resolution","resolution","_closed","_invalidated","controlPoints","numControlPoints","_update","_aabb","_length","hasTangentPoints","addControlPoint","addControlPoints","addControlPointAtU","_getLineSegmentAt","endPoint","curveSegmentIndex","curveSegment","_curveSegments","controlPointPos","insertIndex","deleteControlPointByIndex","minControlPoints","clearControlPoints","setControlPoints","updateControlPoint","newControlPoint","getControlPoints","controlPoint","getClosestControlPoint","minSquaredDist","closestPointIndex","squaredDist","getClosestControlPointWithinDistance","maxDist","closestControlPoint","getClosestPoint","curveSegmentsDistInfo","_getCurveSegmmentsDistanceSquaredInfo","csA","csB","minDistCurveSegment","minDistLineSegment","closestPointCurveSegmentIndex","minDistSquared","curveSegmentDistInfo","lineSegPoint","lineSegDistSquared","uValue","previousLineSegmentsLength","getClosestPointOnControlPointLines","_convertCurveSegmentsToPolyline","getPreviewPolylinePoints","controlPointPreview","closeDistance","closeSpline","previewCurveSegments","getPreviewCurveSegments","isPointNearCurve","curveSegments","_getCurveSegmmentsWithinDistance","maxDistSquared","containsPoint","closingCurveSegment","_getClosingCurveSegmentWithStraightLineSegment","numIntersections","curveSegAABB","lineSegmentAABB","isVerticalLine","xIntersection","getSplineCurves","curveSegLength","polylinePoints","curveSegIndex","lineSegIndex","curveSegmentsDistanceSquared","curveSegmentsDistance","curveSegmentsWithinRange","curveSegmentDistSquared","pointLength","lengthEnd","startControlPoint","endControlPoint","closingLineSegment","CubicSpline","previewNumCurveSegments","_getNumCurveSegments","startCurveSegIndex","endCurveSegIndex","transformMatrix","getTransformMatrix","_getCurveSegment","numCurveSegments","previousCurveSegmentsLength","_getPoint","uInt","p0","_getCurveSegmentPoints","tt","ttt","tValues","vec4","qValues","p0Index","p2Index","p3Index","_getLineSegments","numLineSegments","inc","maxU","curveSegmentLength","lineSegAABB","lineSegLength","CardinalSpline","_props$scale","_props$fixedScale","_scale","_fixedScale","fixedScale","s2","LinearSpline","CatmullRomSpline","TRANSFORM_MATRIX","BSpline","DEFAULT_SPLINE_CONFIG","controlPointAdditionDistance","controlPointDeletionDistance","showControlPointsConnectors","controlPointAdditionEnabled","controlPointDeletionEnabled","SplineTypesEnum","SplineToolActions","SplineROITool","spline","Cardinal","Class","CatmullRom","Linear","drawPreviewEnabled","lastControlPointDeletionKeys","AddControlPoint","Shift","DeleteControlPoint","Ctrl","instance","_eventDetail$key","controlPointIndex","_deleteControlPointByIndex","doubleClick","worldPoint","closeContour","addNewPoint","_keyDownCallback","_mouseMoveCallback","textboxStyle","splineType","splineConfig","_getSplineConfig","closestPointInfo","_this$editData","_this$editData2","_updateSplineInstance","splinePolylineCanvas","splinePolylineWorld","controlPointsConnectors","splineConfigs","SplineContourSegmentationTool","PlanarFreehandContourSegmentationTool","BucketQueue","numBits","getPriority","areEqual","_bucketCount","_mask","_size","_currentBucketIndex","_buckets","_buildArray","_getPriority","_areEqual","itemA","itemB","bucketIndex","_getBucketIndex","newHead","next","ret","firstBucketNode","prevNode","isEmpty","buckets","MAX_UINT32","TWO_THIRD_PI","LivewireScissors","grayscalePixelData","col","searchGranularity","costs","numPixels","searchGranularityBits","laplace","gradXNew","gradYNew","_computeLaplace","gradMagnitude","_computeGradient","_computeGradientX","_computeGradientY","visited","parents","Uint32Array","startSearch","startPointIndex","_getPointIndex","priorityQueueNew","_getPointCost","findPathToPoint","_getPointCoordinate","coord","targetPointIndex","cost","priorityQueue","neighborsPoints","_getNeighborPoints","neighborPoint","neighbordPointIndex","_getWeightedDistance","neighborCost","pathPoints","pathPointIndex","_getDeltaX","_getDeltaY","_getGradientMagnitude","_getLaplace","lap","gradient","pixelIndex","gradX","gradY","_getGradientUnitVector","px","py","pointGradX","pointGradY","gradVecLen","_getGradientDirection","qx","qy","dgpUnitVec","gdqUnitVec","dp","dq","SQRT1_2","aX","aY","bX","bY","bIndex","sx","sy","ey","createInstanceFromRawPixelData","pixelData","minPixelValue","maxPixelValue","pixelRange","createInstanceFromRGBAPixelData","rgbaPixelData","red","green","blue","LivewirePath","inputPointArray","inputControlPointIndexArray","_controlPointIndexes","getLastPoint","isControlPoint","getNumControlPoints","removeLastControlPoint","addPoints","newPointArray","prependPath","otherSize","shiftedIndexArray","LivewireContourTool","proximitySquared","scissors","worldToSlice","sliceToWorld","currentPath","closePath","closestHandlePoint","distSquared","worldControlPoint","confirmedPath","_updateAnnotation","imgWidth","imgHeight","slicePoint","viewportImageData","ijkPoint","sliceImageData","sliceToIndexMatrix","indexToSliceMatrix","startPos","contourSegmentationAnnotation","_this$editData3","livewirePath","imagePoints","worldPolylinePoints","LivewireContourSegmentationTool","ArrowAnnotateTool","getTextCallback","changeTextCallback","arrowFirst","doubleClickCallback","clickedAnnotation","_doneChangingTextCallback","_annotations3","drawArrowSvg","updatedText","doneChangingTextCallback","prompt","AngleTool","angleStartedNotYetCompleted","canvasPoint3","_data$cachedStats$tar","fromCharCode","midPoint2","CobbAngleTool","distanceToLines","isNearFirstLine","isNearSecondLine","arc1Angle","arc2Angle","arc1Start","arc1End","arc2Start","arc2End","arc1TextBoxUID","arc1TextLine","arch1TextPosCanvas","arc2TextBoxUID","arc2TextLine","arch2TextPosCanvas","point4","canvasPoint4","mid1","mid2","linkLine","arc1Side","arc2Side","midLinkLine","linkLineLength","midFirstLine","midSecondLine","directionVectorStartArc1","magnitudeStartArc1","normalizedDirectionStartArc1","directionVectorEndArc1","magnitudeEndArc1","normalizedDirectionEndArc1","directionVectorStartArc2","magnitudeStartArc2","normalizedDirectionStartArc2","directionVectorEndArc2","magnitudeEndArc2","normalizedDirectionEndArc2","seg1","seg2","minDist","MAX_VALUE","getArcsStartEndPoints","UltrasoundDirectionalTool","displayBothAxesDistances","startedDrawing","xValues","yValues","isUnitless","drawHandleSvg","canvasDeltaY","canvasDeltaX","projectedPointCanvas","values1","units1","values2","units2","KeyImageTool","canvasPosition","canvasSize","MAGNIFY_VIEWPORT_ID","MagnifyTool","magnifySize","magnifyWidth","magnifyHeight","_getReferencedImageId","_createMagnificationViewport","viewportProperties","magnifyToolElement","magnifyElement","viewportInput","enableElement","magnifyViewport","setStack","disableElement","_dragEndCallback","MAGNIFY_VIEWPORT_INITIAL_RADIUS","isSegmentation","referenceId","AdvancedMagnifyViewport","magnifyViewportId","sourceEnabledElement","zoomFactor","_viewportId","_sourceEnabledElement","_autoPan","_browserMouseDownCallback","_browserMouseUpCallback","_handleToolModeChanged","_resizeViewportAsync","_resizeViewport","_radius","_resized","_enabledElement","_isViewportReady","_syncViewports","_removeEventListeners","parentNode","_this$_sourceToolGrou","_magnifyToolGroup","magnifyToolGroup","_sourceToolGroup","_inheritBorderRadius","borderRadius","_createViewportNode","overflow","_convertZoomFactorToParalellScale","offsetWidth","_isStackViewport","_isVolumeViewport","_cloneToolGroups","sourceActors","magnifyToolGroupId","sourceToolGroup","AdvancedMagnifyTool","_cloneStack","_cloneVolumes","volumeInputArray","setVolumes","_cloneViewport","sourceViewportOptions","defaultOptions","_cancelMouseEventCallback","_evt$target","_canAutoPan","closest","canvasCurrent","magnifyRadius","panDist","canvasDeltaPos","newCanvasPosition","currentWorldPos","worldDeltaPos","autoPanCallbackData","currentPosition","_addBrowserEventListeners","_removeBrowserEventListeners","_addEventListeners","cstEvents","sourceCanvas","_syncViewportsCameras","_syncStackViewports","setImageIdIndex","sourceProperties","resize","AdvancedMagnifyViewportManager","sourceElement","_addSourceElementEventListener","_magnifyViewportsMap","_destroyViewport","_getMagnifyViewportsMapEntriesBySourceViewportId","currentViewPlaneNormal","worldImagePlanePoint","vecHandleToImagePlane","worldDist","worldDelta","getInstance","_AdvancedMagnifyViewp","_singleton","_this$_magnifyViewpor","_destroyViewports","magnifyViewportMapEntry","_removeSourceElementEventListener","_annotationRemovedCallback","_newStackImageCallback","_newVolumeImageCallback","AdvancedMagnifyToolActions","magnifyingGlass","zoomFactorList","showZoomFactorsList","Secondary","worldHandlesPoints","_getWorldHandlesPoints","magnifyViewportManager","createViewport","annotationPoints","_deltaPoints$world","newRadius","newWorldHandlesPoints","canvasCenterPos","canvasRadius","currentZoomFactor","dropdown","_getZoomFactorsListDropdown","newZoomFactor","focus","onChangeCallback","_evt$keyCode","_evt$key","which","toLowerCase","option","title","defaultSelected","ReferenceCursors","displayThreshold","positionSync","_currentCursorWorldPosition","_currentCanvasPosition","_elementWithCursor","getActiveAnnotation","createInitialAnnotation","updateAnnotationPosition","previousCamera","oldFocalPoint","cameraNormal","isElementWithCursor","updateViewportImage","crosshairUIDs","centerSpace","lineLength","_disableCursorEnabled","_getEnabledElement","_annotation$data2","plane","currentMousePosition","closestIndex","normalizedViewPlane","scaledPlaneNormal","viewportsWithAnnotations","ScaleOverlayTool","scaleLocation","viewportCanvasCornersInWorld","thisAnnotation","worldWidthViewport","worldHeightViewport","scaleSizes","currentScaleSize","scaleSize","locationTickOffset","endTick1","endTick2","leftTick","rightTick","canvasScaleSize","tickIds","tickUIDs","tickCoordinates","numberSmallTicks","tickSpacing","locationOffset","pointSet","worldCoordinates","midpointLocation","vscaleBounds","hscaleBounds","scaleCanvasCoordinates","worldDistanceOnCanvas","horizontalReduction","verticalReduction","hReduction","vReduction","locationBounds","canvasBounds","computeScaleBounds","computeScaleSize","computeWorldScaleCoordinates","computeCanvasScaleCoordinates","scaleTicks","computeEndScaleTicks","scaleId","leftTickId","rightTickId","locationTextOffest","textBoxLines","_getTextLines","computeInnerScaleTicks","scaleSizeDisplayValue","scaleSizeUnits","fillInsideRectangle","strategyData","isAligned","pointsBoundsLPS","fillRectangle","eraseInsideRectangle","eraseRectangle","RectangleScissorsTool","FILL_INSIDE","ERASE_INSIDE","CircleScissorsTool","SphereScissorsTool","OverlayMarkerType","ANNOTATED_CUBE","AXES","OrientationMarkerTool","orientationWidget","viewportCorner","vtkOrientationMarkerWidget","viewportSize","minPixelSize","maxPixelSize","overlayMarkerType","OVERLAY_MARKER_TYPES","overlayConfiguration","faceProperties","xPlus","faceColor","faceRotation","xMinus","yPlus","fontColor","yMinus","zPlus","zMinus","defaultStyle","fontStyle","fontSizeScale","edgeThickness","edgeColor","polyDataURL","initViewports","configuration_invalidated","cleanUpData","orientationMarkers","orientationMarker","setEnabled","offscreenMultiRenderWindow","getRenderWindow","addAxisActorInViewport","getRenderer","removeActor","createAnnotationCube","vtkAxesActor","createCustomActor","renderer","renderWindow","interactor","getInteractor","parentRenderer","setViewportCorner","setViewportSize","setMinPixelSize","setMaxPixelSize","updateMarkerOrientation","response","fetch","vtpReader","vtkXMLPolyDataReader","parseAsArrayBuffer","setActiveScalars","setColorModeToDirectScalars","rotateZ","vtkAnnotatedCubeActor","setDefaultStyle","setXPlusFaceProperty","setXMinusFaceProperty","setYPlusFaceProperty","setYMinusFaceProperty","setZPlusFaceProperty","setZMinusFaceProperty","createAnnotatedCubeActor","annotatedCube","methodName","charAt","SegmentSelectTool","hoverTimeout","hoverTimer","_setActiveSegment","RepresentationTypes","_setActiveSegmentLabelmap","hoveredSegmentIndex","getScalarValueFromWorld","segmentationImageId","indexIJK","flattenedIndex","PaintFillTool","fixedDimension","getFixedDimension","floodFillGetter","getLabelValue","getScalarDataPositionFromPlane","inPlaneSeedPoint","fixedDimensionValue","generateHelpers","clickedLabelValue","floodFillResult","scalarDataPosition","getFramesModified","minJ","maxJ","framesModified","seedIndex3D","getScalarDataPosition","generateFloodFillGetter","generateGetScalarDataPositionFromPlane","xDirection","yDirection","zDirection","absoluteOfViewPlaneNormal","absoluteOfXDirection","absoluteOfYDirection","absoluteOfZDirection","VideoRedactionTool","viewportUIDsToRender","toolDataCanvasCoordinate","drawRedactionRectSvg","viewportUID","renderingEngineUID","sceneUID","targetUIDs","targetUID","_getImageVolumeFromTargetUID","worldToIndexVec3","valueMinusMean","scene","volumeUID","volumeActors","getVolumeActors","coloneIndex","_getTargetStackUID"],"sourceRoot":""}