{"ast":null,"code":"import { vec3 } from 'gl-matrix';\nimport vtkPlane from '../../../Common/DataModel/Plane.js';\n\n/**\n * Perform plane-line intersection, where the line is defined by two points (p1, p2),\n * and the plane is defined by the imageData and slice number.\n *\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {vtkImageMapper|vtkImageArrayMapper} mapper\n */\nfunction doPicking(p1, p2, mapper) {\n  const imageData = mapper.getCurrentImage();\n  const extent = imageData.getExtent();\n\n  // Slice origin\n  const ijk = [extent[0], extent[2], extent[4]];\n  const {\n    ijkMode\n  } = mapper.getClosestIJKAxis();\n  let nSlice = mapper.isA('vtkImageArrayMapper') ? mapper.getSubSlice() : mapper.getSlice();\n  if (ijkMode !== mapper.getSlicingMode()) {\n    // If not IJK slicing, get the IJK slice from the XYZ position/slice\n    nSlice = mapper.getSliceAtPosition(nSlice);\n  }\n  ijk[ijkMode] += nSlice;\n  const worldOrigin = [0, 0, 0];\n  imageData.indexToWorld(ijk, worldOrigin);\n\n  // Normal computation\n  ijk[ijkMode] += 1;\n  const worldNormal = [0, 0, 0];\n  imageData.indexToWorld(ijk, worldNormal);\n  worldNormal[0] -= worldOrigin[0];\n  worldNormal[1] -= worldOrigin[1];\n  worldNormal[2] -= worldOrigin[2];\n  vec3.normalize(worldNormal, worldNormal);\n  const intersect = vtkPlane.intersectWithLine(p1, p2, worldOrigin, worldNormal);\n  if (intersect.intersection) {\n    const point = intersect.x;\n    const absoluteIJK = [0, 0, 0];\n    imageData.worldToIndex(point, absoluteIJK);\n    // `t` is the parametric position along the line\n    // defined in Plane.intersectWithLine\n    return {\n      t: intersect.t,\n      absoluteIJK\n    };\n  }\n  return null;\n}\n\n/**\n * Implement point picking for image plane.\n * The plane is defined by the imageData and current slice number,\n * set in the input mapper.\n *\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {vtkImageMapper|vtkImageArrayMapper} mapper\n */\nfunction intersectWithLineForPointPicking(p1, p2, mapper) {\n  const pickingData = doPicking(p1, p2, mapper);\n  if (pickingData) {\n    const imageData = mapper.getCurrentImage();\n    const extent = imageData.getExtent();\n\n    // Get closer integer ijk\n    // NB: point picking means closest slice, means rounding\n    const ijk = [Math.round(pickingData.absoluteIJK[0]), Math.round(pickingData.absoluteIJK[1]), Math.round(pickingData.absoluteIJK[2])];\n\n    // Are we outside our actual extent\n    if (ijk[0] < extent[0] || ijk[0] > extent[1] || ijk[1] < extent[2] || ijk[1] > extent[3] || ijk[2] < extent[4] || ijk[2] > extent[5]) {\n      return null;\n    }\n    return {\n      t: pickingData.t,\n      ijk\n    };\n  }\n  return null;\n}\n\n/**\n * Implement cell picking for image plane.\n * The plane is defined by the imageData and current slice number,\n * set in the input mapper.\n *\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {vtkImageMapper|vtkImageArrayMapper} mapper\n */\nfunction intersectWithLineForCellPicking(p1, p2, mapper) {\n  const pickingData = doPicking(p1, p2, mapper);\n  if (pickingData) {\n    const imageData = mapper.getCurrentImage();\n    const extent = imageData.getExtent();\n    const absIJK = pickingData.absoluteIJK;\n\n    // Get closer integer ijk\n    // NB: cell picking means closest voxel, means flooring\n    const ijk = [Math.floor(absIJK[0]), Math.floor(absIJK[1]), Math.floor(absIJK[2])];\n\n    // Are we outside our actual extent\n    if (ijk[0] < extent[0] || ijk[0] > extent[1] - 1 || ijk[1] < extent[2] || ijk[1] > extent[3] - 1 || ijk[2] < extent[4] ||\n    // handle single-slice images\n    ijk[2] > (extent[5] ? extent[5] - 1 : extent[5])) {\n      return null;\n    }\n\n    // Parametric coordinates within cell\n    const pCoords = [absIJK[0] - ijk[0], absIJK[1] - ijk[1], absIJK[2] - ijk[2]];\n    return {\n      t: pickingData.t,\n      ijk,\n      pCoords\n    };\n  }\n  return null;\n}\nexport { intersectWithLineForCellPicking, intersectWithLineForPointPicking };","map":{"version":3,"names":["vec3","vtkPlane","doPicking","p1","p2","mapper","imageData","getCurrentImage","extent","getExtent","ijk","ijkMode","getClosestIJKAxis","nSlice","isA","getSubSlice","getSlice","getSlicingMode","getSliceAtPosition","worldOrigin","indexToWorld","worldNormal","normalize","intersect","intersectWithLine","intersection","point","x","absoluteIJK","worldToIndex","t","intersectWithLineForPointPicking","pickingData","Math","round","intersectWithLineForCellPicking","absIJK","floor","pCoords"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/Core/AbstractImageMapper/helper.js"],"sourcesContent":["import { vec3 } from 'gl-matrix';\nimport vtkPlane from '../../../Common/DataModel/Plane.js';\n\n/**\n * Perform plane-line intersection, where the line is defined by two points (p1, p2),\n * and the plane is defined by the imageData and slice number.\n *\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {vtkImageMapper|vtkImageArrayMapper} mapper\n */\nfunction doPicking(p1, p2, mapper) {\n  const imageData = mapper.getCurrentImage();\n  const extent = imageData.getExtent();\n\n  // Slice origin\n  const ijk = [extent[0], extent[2], extent[4]];\n  const {\n    ijkMode\n  } = mapper.getClosestIJKAxis();\n  let nSlice = mapper.isA('vtkImageArrayMapper') ? mapper.getSubSlice() : mapper.getSlice();\n  if (ijkMode !== mapper.getSlicingMode()) {\n    // If not IJK slicing, get the IJK slice from the XYZ position/slice\n    nSlice = mapper.getSliceAtPosition(nSlice);\n  }\n  ijk[ijkMode] += nSlice;\n  const worldOrigin = [0, 0, 0];\n  imageData.indexToWorld(ijk, worldOrigin);\n\n  // Normal computation\n  ijk[ijkMode] += 1;\n  const worldNormal = [0, 0, 0];\n  imageData.indexToWorld(ijk, worldNormal);\n  worldNormal[0] -= worldOrigin[0];\n  worldNormal[1] -= worldOrigin[1];\n  worldNormal[2] -= worldOrigin[2];\n  vec3.normalize(worldNormal, worldNormal);\n  const intersect = vtkPlane.intersectWithLine(p1, p2, worldOrigin, worldNormal);\n  if (intersect.intersection) {\n    const point = intersect.x;\n    const absoluteIJK = [0, 0, 0];\n    imageData.worldToIndex(point, absoluteIJK);\n    // `t` is the parametric position along the line\n    // defined in Plane.intersectWithLine\n    return {\n      t: intersect.t,\n      absoluteIJK\n    };\n  }\n  return null;\n}\n\n/**\n * Implement point picking for image plane.\n * The plane is defined by the imageData and current slice number,\n * set in the input mapper.\n *\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {vtkImageMapper|vtkImageArrayMapper} mapper\n */\nfunction intersectWithLineForPointPicking(p1, p2, mapper) {\n  const pickingData = doPicking(p1, p2, mapper);\n  if (pickingData) {\n    const imageData = mapper.getCurrentImage();\n    const extent = imageData.getExtent();\n\n    // Get closer integer ijk\n    // NB: point picking means closest slice, means rounding\n    const ijk = [Math.round(pickingData.absoluteIJK[0]), Math.round(pickingData.absoluteIJK[1]), Math.round(pickingData.absoluteIJK[2])];\n\n    // Are we outside our actual extent\n    if (ijk[0] < extent[0] || ijk[0] > extent[1] || ijk[1] < extent[2] || ijk[1] > extent[3] || ijk[2] < extent[4] || ijk[2] > extent[5]) {\n      return null;\n    }\n    return {\n      t: pickingData.t,\n      ijk\n    };\n  }\n  return null;\n}\n\n/**\n * Implement cell picking for image plane.\n * The plane is defined by the imageData and current slice number,\n * set in the input mapper.\n *\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {vtkImageMapper|vtkImageArrayMapper} mapper\n */\nfunction intersectWithLineForCellPicking(p1, p2, mapper) {\n  const pickingData = doPicking(p1, p2, mapper);\n  if (pickingData) {\n    const imageData = mapper.getCurrentImage();\n    const extent = imageData.getExtent();\n    const absIJK = pickingData.absoluteIJK;\n\n    // Get closer integer ijk\n    // NB: cell picking means closest voxel, means flooring\n    const ijk = [Math.floor(absIJK[0]), Math.floor(absIJK[1]), Math.floor(absIJK[2])];\n\n    // Are we outside our actual extent\n    if (ijk[0] < extent[0] || ijk[0] > extent[1] - 1 || ijk[1] < extent[2] || ijk[1] > extent[3] - 1 || ijk[2] < extent[4] ||\n    // handle single-slice images\n    ijk[2] > (extent[5] ? extent[5] - 1 : extent[5])) {\n      return null;\n    }\n\n    // Parametric coordinates within cell\n    const pCoords = [absIJK[0] - ijk[0], absIJK[1] - ijk[1], absIJK[2] - ijk[2]];\n    return {\n      t: pickingData.t,\n      ijk,\n      pCoords\n    };\n  }\n  return null;\n}\n\nexport { intersectWithLineForCellPicking, intersectWithLineForPointPicking };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}