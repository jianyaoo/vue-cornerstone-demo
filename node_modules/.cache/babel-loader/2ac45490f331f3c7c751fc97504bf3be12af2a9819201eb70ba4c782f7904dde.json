{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { vec3, mat4, quat } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport vtkBufferObject from './BufferObject.js';\nimport { ObjectType } from './BufferObject/Constants.js';\nimport { Representation } from '../Core/Property/Constants.js';\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// Static functions\n// ----------------------------------------------------------------------------\n\nfunction computeInverseShiftAndScaleMatrix(coordShift, coordScale) {\n  const inverseScale = new Float64Array(3);\n  vec3.inverse(inverseScale, coordScale);\n  const matrix = new Float64Array(16);\n  mat4.fromRotationTranslationScale(matrix, quat.create(), coordShift, inverseScale);\n  return matrix;\n}\nfunction shouldApplyCoordShiftAndScale(coordShift, coordScale) {\n  if (coordShift === null || coordScale === null) {\n    return false;\n  }\n  return !(vec3.exactEquals(coordShift, [0, 0, 0]) && vec3.exactEquals(coordScale, [1, 1, 1]));\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLCellArrayBufferObject methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLCellArrayBufferObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLCellArrayBufferObject');\n  publicAPI.setType(ObjectType.ARRAY_BUFFER);\n  publicAPI.createVBO = function (cellArray, inRep, outRep, options) {\n    let selectionMaps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    if (!cellArray.getData() || !cellArray.getData().length) {\n      model.elementCount = 0;\n      return 0;\n    }\n\n    // Figure out how big each block will be, currently 6 or 7 floats.\n    model.blockSize = 3;\n    model.vertexOffset = 0;\n    model.normalOffset = 0;\n    model.tCoordOffset = 0;\n    model.tCoordComponents = 0;\n    model.colorComponents = 0;\n    model.colorOffset = 0;\n    model.customData = [];\n    const pointData = options.points.getData();\n    let normalData = null;\n    let tcoordData = null;\n    let colorData = null;\n    const colorComponents = options.colors ? options.colors.getNumberOfComponents() : 0;\n    const textureComponents = options.tcoords ? options.tcoords.getNumberOfComponents() : 0;\n\n    // the values of 4 below are because floats are 4 bytes\n\n    if (options.normals) {\n      model.normalOffset = 4 * model.blockSize;\n      model.blockSize += 3;\n      normalData = options.normals.getData();\n    }\n    if (options.customAttributes) {\n      options.customAttributes.forEach(a => {\n        if (a) {\n          model.customData.push({\n            data: a.getData(),\n            offset: 4 * model.blockSize,\n            components: a.getNumberOfComponents(),\n            name: a.getName()\n          });\n          model.blockSize += a.getNumberOfComponents();\n        }\n      });\n    }\n    if (options.tcoords) {\n      model.tCoordOffset = 4 * model.blockSize;\n      model.tCoordComponents = textureComponents;\n      model.blockSize += textureComponents;\n      tcoordData = options.tcoords.getData();\n    }\n    if (options.colors) {\n      model.colorComponents = options.colors.getNumberOfComponents();\n      model.colorOffset = 0;\n      colorData = options.colors.getData();\n      if (!model.colorBO) {\n        model.colorBO = vtkBufferObject.newInstance();\n      }\n      model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);\n    } else {\n      model.colorBO = null;\n    }\n    model.stride = 4 * model.blockSize;\n    let pointIdx = 0;\n    let normalIdx = 0;\n    let tcoordIdx = 0;\n    let colorIdx = 0;\n    let custIdx = 0;\n    let cellCount = 0;\n    let addAPoint;\n    const cellBuilders = {\n      // easy, every input point becomes an output point\n      anythingToPoints(numPoints, cellPts, offset) {\n        for (let i = 0; i < numPoints; ++i) {\n          addAPoint(cellPts[offset + i]);\n        }\n      },\n      linesToWireframe(numPoints, cellPts, offset) {\n        // for lines we add a bunch of segments\n        for (let i = 0; i < numPoints - 1; ++i) {\n          addAPoint(cellPts[offset + i]);\n          addAPoint(cellPts[offset + i + 1]);\n        }\n      },\n      polysToWireframe(numPoints, cellPts, offset) {\n        // for polys we add a bunch of segments and close it\n        if (numPoints > 2) {\n          for (let i = 0; i < numPoints; ++i) {\n            addAPoint(cellPts[offset + i]);\n            addAPoint(cellPts[offset + (i + 1) % numPoints]);\n          }\n        }\n      },\n      stripsToWireframe(numPoints, cellPts, offset) {\n        if (numPoints > 2) {\n          // for strips we add a bunch of segments and close it\n          for (let i = 0; i < numPoints - 1; ++i) {\n            addAPoint(cellPts[offset + i]);\n            addAPoint(cellPts[offset + i + 1]);\n          }\n          for (let i = 0; i < numPoints - 2; i++) {\n            addAPoint(cellPts[offset + i]);\n            addAPoint(cellPts[offset + i + 2]);\n          }\n        }\n      },\n      polysToSurface(npts, cellPts, offset) {\n        for (let i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + 0]);\n          addAPoint(cellPts[offset + i + 1]);\n          addAPoint(cellPts[offset + i + 2]);\n        }\n      },\n      stripsToSurface(npts, cellPts, offset) {\n        for (let i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + i]);\n          addAPoint(cellPts[offset + i + 1 + i % 2]);\n          addAPoint(cellPts[offset + i + 1 + (i + 1) % 2]);\n        }\n      }\n    };\n    const cellCounters = {\n      // easy, every input point becomes an output point\n      anythingToPoints(numPoints, cellPts) {\n        return numPoints;\n      },\n      linesToWireframe(numPoints, cellPts) {\n        if (numPoints > 1) {\n          return (numPoints - 1) * 2;\n        }\n        return 0;\n      },\n      polysToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 2;\n        }\n        return 0;\n      },\n      stripsToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 4 - 6;\n        }\n        return 0;\n      },\n      polysToSurface(npts, cellPts) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n        return 0;\n      },\n      stripsToSurface(npts, cellPts, offset) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n        return 0;\n      }\n    };\n    let func = null;\n    let countFunc = null;\n    if (outRep === Representation.POINTS || inRep === 'verts') {\n      func = cellBuilders.anythingToPoints;\n      countFunc = cellCounters.anythingToPoints;\n    } else if (outRep === Representation.WIREFRAME || inRep === 'lines') {\n      func = cellBuilders[`${inRep}ToWireframe`];\n      countFunc = cellCounters[`${inRep}ToWireframe`];\n    } else {\n      func = cellBuilders[`${inRep}ToSurface`];\n      countFunc = cellCounters[`${inRep}ToSurface`];\n    }\n    const array = cellArray.getData();\n    const size = array.length;\n    let caboCount = 0;\n    for (let index = 0; index < size;) {\n      caboCount += countFunc(array[index], array);\n      index += array[index] + 1;\n    }\n    let packedUCVBO = null;\n    const packedVBO = new Float32Array(caboCount * model.blockSize);\n    if (colorData) {\n      packedUCVBO = new Uint8Array(caboCount * 4);\n    }\n    let vboidx = 0;\n    let ucidx = 0;\n\n    // Find out if shift scale should be used\n    // Compute squares of diagonal size and distance from the origin\n    let diagSq = 0.0;\n    let distSq = 0.0;\n    for (let i = 0; i < 3; ++i) {\n      const range = options.points.getRange(i);\n      const delta = range[1] - range[0];\n      diagSq += delta * delta;\n      const distShift = 0.5 * (range[1] + range[0]);\n      distSq += distShift * distShift;\n    }\n    const useShiftAndScale = diagSq > 0 && (Math.abs(distSq) / diagSq > 1.0e6 ||\n    // If data is far from the origin relative to its size\n    Math.abs(Math.log10(diagSq)) > 3.0 ||\n    // If the size is huge when not far from the origin\n    diagSq === 0 && distSq > 1.0e6); // If data is a point, but far from the origin\n\n    if (useShiftAndScale) {\n      // Compute shift and scale vectors\n      const coordShift = new Float64Array(3);\n      const coordScale = new Float64Array(3);\n      for (let i = 0; i < 3; ++i) {\n        const range = options.points.getRange(i);\n        const delta = range[1] - range[0];\n        coordShift[i] = 0.5 * (range[1] + range[0]);\n        coordScale[i] = delta > 0 ? 1.0 / delta : 1.0;\n      }\n      publicAPI.setCoordShiftAndScale(coordShift, coordScale);\n    } else if (model.coordShiftAndScaleEnabled === true) {\n      // Make sure to reset\n      publicAPI.setCoordShiftAndScale(null, null);\n    }\n\n    // Initialize the structures used to keep track of point ids and cell ids for selectors\n    if (selectionMaps) {\n      if (!selectionMaps.points && !selectionMaps.cells) {\n        selectionMaps.points = new Int32Array(caboCount);\n        selectionMaps.cells = new Int32Array(caboCount);\n      } else {\n        const newPoints = new Int32Array(caboCount + selectionMaps.points.length);\n        newPoints.set(selectionMaps.points);\n        selectionMaps.points = newPoints;\n        const newCells = new Int32Array(caboCount + selectionMaps.cells.length);\n        newCells.set(selectionMaps.cells);\n        selectionMaps.cells = newCells;\n      }\n    }\n    let pointCount = options.vertexOffset;\n    addAPoint = function addAPointFunc(i) {\n      // Keep track of original point and cell ids, for selection\n      if (selectionMaps) {\n        selectionMaps.points[pointCount] = i;\n        selectionMaps.cells[pointCount] = cellCount + options.cellOffset;\n      }\n      ++pointCount;\n\n      // Vertices\n      pointIdx = i * 3;\n      if (!model.coordShiftAndScaleEnabled) {\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n      } else {\n        // Apply shift and scale\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];\n      }\n      if (normalData !== null) {\n        if (options.haveCellNormals) {\n          normalIdx = (cellCount + options.cellOffset) * 3;\n        } else {\n          normalIdx = i * 3;\n        }\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n      }\n      model.customData.forEach(attr => {\n        custIdx = i * attr.components;\n        for (let j = 0; j < attr.components; ++j) {\n          packedVBO[vboidx++] = attr.data[custIdx++];\n        }\n      });\n      if (tcoordData !== null) {\n        tcoordIdx = i * textureComponents;\n        for (let j = 0; j < textureComponents; ++j) {\n          packedVBO[vboidx++] = tcoordData[tcoordIdx++];\n        }\n      }\n      if (colorData !== null) {\n        if (options.haveCellScalars) {\n          colorIdx = (cellCount + options.cellOffset) * colorComponents;\n        } else {\n          colorIdx = i * colorComponents;\n        }\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorComponents === 4 ? colorData[colorIdx++] : 255;\n      }\n    };\n    for (let index = 0; index < size;) {\n      func(array[index], array, index + 1);\n      index += array[index] + 1;\n      cellCount++;\n    }\n    model.elementCount = caboCount;\n    publicAPI.upload(packedVBO, ObjectType.ARRAY_BUFFER);\n    if (model.colorBO) {\n      model.colorBOStride = 4;\n      model.colorBO.upload(packedUCVBO, ObjectType.ARRAY_BUFFER);\n    }\n    return cellCount;\n  };\n  publicAPI.setCoordShiftAndScale = (coordShift, coordScale) => {\n    if (coordShift !== null && (coordShift.constructor !== Float64Array || coordShift.length !== 3)) {\n      vtkErrorMacro('Wrong type for coordShift, expected vec3 or null');\n      return;\n    }\n    if (coordScale !== null && (coordScale.constructor !== Float64Array || coordScale.length !== 3)) {\n      vtkErrorMacro('Wrong type for coordScale, expected vec3 or null');\n      return;\n    }\n    if (model.coordShift === null || coordShift === null || !vec3.equals(coordShift, model.coordShift)) {\n      model.coordShift = coordShift;\n    }\n    if (model.coordScale === null || coordScale === null || !vec3.equals(coordScale, model.coordScale)) {\n      model.coordScale = coordScale;\n    }\n    model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(model.coordShift, model.coordScale);\n    if (model.coordShiftAndScaleEnabled) {\n      model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(model.coordShift, model.coordScale);\n    } else {\n      model.inverseShiftAndScaleMatrix = null;\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  elementCount: 0,\n  stride: 0,\n  colorBOStride: 0,\n  vertexOffset: 0,\n  normalOffset: 0,\n  tCoordOffset: 0,\n  tCoordComponents: 0,\n  colorOffset: 0,\n  colorComponents: 0,\n  tcoordBO: null,\n  customData: [],\n  coordShift: null,\n  coordScale: null,\n  coordShiftAndScaleEnabled: false,\n  inverseShiftAndScaleMatrix: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkBufferObject.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['colorBO', 'elementCount', 'stride', 'colorBOStride', 'vertexOffset', 'normalOffset', 'tCoordOffset', 'tCoordComponents', 'colorOffset', 'colorComponents', 'customData']);\n  macro.get(publicAPI, model, ['coordShift', 'coordScale', 'coordShiftAndScaleEnabled', 'inverseShiftAndScaleMatrix']);\n\n  // Object specific methods\n  vtkOpenGLCellArrayBufferObject(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellArrayBufferObject = {\n  newInstance,\n  extend\n};\nexport { vtkCellArrayBufferObject as default, extend, newInstance };","map":{"version":3,"names":["vec3","mat4","quat","m","macro","vtkBufferObject","ObjectType","Representation","vtkErrorMacro","computeInverseShiftAndScaleMatrix","coordShift","coordScale","inverseScale","Float64Array","inverse","matrix","fromRotationTranslationScale","create","shouldApplyCoordShiftAndScale","exactEquals","vtkOpenGLCellArrayBufferObject","publicAPI","model","classHierarchy","push","setType","ARRAY_BUFFER","createVBO","cellArray","inRep","outRep","options","selectionMaps","arguments","length","undefined","getData","elementCount","blockSize","vertexOffset","normalOffset","tCoordOffset","tCoordComponents","colorComponents","colorOffset","customData","pointData","points","normalData","tcoordData","colorData","colors","getNumberOfComponents","textureComponents","tcoords","normals","customAttributes","forEach","a","data","offset","components","name","getName","colorBO","newInstance","setOpenGLRenderWindow","_openGLRenderWindow","stride","pointIdx","normalIdx","tcoordIdx","colorIdx","custIdx","cellCount","addAPoint","cellBuilders","anythingToPoints","numPoints","cellPts","i","linesToWireframe","polysToWireframe","stripsToWireframe","polysToSurface","npts","stripsToSurface","cellCounters","func","countFunc","POINTS","WIREFRAME","array","size","caboCount","index","packedUCVBO","packedVBO","Float32Array","Uint8Array","vboidx","ucidx","diagSq","distSq","range","getRange","delta","distShift","useShiftAndScale","Math","abs","log10","setCoordShiftAndScale","coordShiftAndScaleEnabled","cells","Int32Array","newPoints","set","newCells","pointCount","addAPointFunc","cellOffset","haveCellNormals","attr","j","haveCellScalars","upload","colorBOStride","constructor","equals","inverseShiftAndScaleMatrix","DEFAULT_VALUES","tcoordBO","extend","initialValues","Object","assign","setGet","get","vtkCellArrayBufferObject","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/OpenGL/CellArrayBufferObject.js"],"sourcesContent":["import { vec3, mat4, quat } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport vtkBufferObject from './BufferObject.js';\nimport { ObjectType } from './BufferObject/Constants.js';\nimport { Representation } from '../Core/Property/Constants.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// Static functions\n// ----------------------------------------------------------------------------\n\nfunction computeInverseShiftAndScaleMatrix(coordShift, coordScale) {\n  const inverseScale = new Float64Array(3);\n  vec3.inverse(inverseScale, coordScale);\n  const matrix = new Float64Array(16);\n  mat4.fromRotationTranslationScale(matrix, quat.create(), coordShift, inverseScale);\n  return matrix;\n}\nfunction shouldApplyCoordShiftAndScale(coordShift, coordScale) {\n  if (coordShift === null || coordScale === null) {\n    return false;\n  }\n  return !(vec3.exactEquals(coordShift, [0, 0, 0]) && vec3.exactEquals(coordScale, [1, 1, 1]));\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLCellArrayBufferObject methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLCellArrayBufferObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLCellArrayBufferObject');\n  publicAPI.setType(ObjectType.ARRAY_BUFFER);\n  publicAPI.createVBO = function (cellArray, inRep, outRep, options) {\n    let selectionMaps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    if (!cellArray.getData() || !cellArray.getData().length) {\n      model.elementCount = 0;\n      return 0;\n    }\n\n    // Figure out how big each block will be, currently 6 or 7 floats.\n    model.blockSize = 3;\n    model.vertexOffset = 0;\n    model.normalOffset = 0;\n    model.tCoordOffset = 0;\n    model.tCoordComponents = 0;\n    model.colorComponents = 0;\n    model.colorOffset = 0;\n    model.customData = [];\n    const pointData = options.points.getData();\n    let normalData = null;\n    let tcoordData = null;\n    let colorData = null;\n    const colorComponents = options.colors ? options.colors.getNumberOfComponents() : 0;\n    const textureComponents = options.tcoords ? options.tcoords.getNumberOfComponents() : 0;\n\n    // the values of 4 below are because floats are 4 bytes\n\n    if (options.normals) {\n      model.normalOffset = 4 * model.blockSize;\n      model.blockSize += 3;\n      normalData = options.normals.getData();\n    }\n    if (options.customAttributes) {\n      options.customAttributes.forEach(a => {\n        if (a) {\n          model.customData.push({\n            data: a.getData(),\n            offset: 4 * model.blockSize,\n            components: a.getNumberOfComponents(),\n            name: a.getName()\n          });\n          model.blockSize += a.getNumberOfComponents();\n        }\n      });\n    }\n    if (options.tcoords) {\n      model.tCoordOffset = 4 * model.blockSize;\n      model.tCoordComponents = textureComponents;\n      model.blockSize += textureComponents;\n      tcoordData = options.tcoords.getData();\n    }\n    if (options.colors) {\n      model.colorComponents = options.colors.getNumberOfComponents();\n      model.colorOffset = 0;\n      colorData = options.colors.getData();\n      if (!model.colorBO) {\n        model.colorBO = vtkBufferObject.newInstance();\n      }\n      model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);\n    } else {\n      model.colorBO = null;\n    }\n    model.stride = 4 * model.blockSize;\n    let pointIdx = 0;\n    let normalIdx = 0;\n    let tcoordIdx = 0;\n    let colorIdx = 0;\n    let custIdx = 0;\n    let cellCount = 0;\n    let addAPoint;\n    const cellBuilders = {\n      // easy, every input point becomes an output point\n      anythingToPoints(numPoints, cellPts, offset) {\n        for (let i = 0; i < numPoints; ++i) {\n          addAPoint(cellPts[offset + i]);\n        }\n      },\n      linesToWireframe(numPoints, cellPts, offset) {\n        // for lines we add a bunch of segments\n        for (let i = 0; i < numPoints - 1; ++i) {\n          addAPoint(cellPts[offset + i]);\n          addAPoint(cellPts[offset + i + 1]);\n        }\n      },\n      polysToWireframe(numPoints, cellPts, offset) {\n        // for polys we add a bunch of segments and close it\n        if (numPoints > 2) {\n          for (let i = 0; i < numPoints; ++i) {\n            addAPoint(cellPts[offset + i]);\n            addAPoint(cellPts[offset + (i + 1) % numPoints]);\n          }\n        }\n      },\n      stripsToWireframe(numPoints, cellPts, offset) {\n        if (numPoints > 2) {\n          // for strips we add a bunch of segments and close it\n          for (let i = 0; i < numPoints - 1; ++i) {\n            addAPoint(cellPts[offset + i]);\n            addAPoint(cellPts[offset + i + 1]);\n          }\n          for (let i = 0; i < numPoints - 2; i++) {\n            addAPoint(cellPts[offset + i]);\n            addAPoint(cellPts[offset + i + 2]);\n          }\n        }\n      },\n      polysToSurface(npts, cellPts, offset) {\n        for (let i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + 0]);\n          addAPoint(cellPts[offset + i + 1]);\n          addAPoint(cellPts[offset + i + 2]);\n        }\n      },\n      stripsToSurface(npts, cellPts, offset) {\n        for (let i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + i]);\n          addAPoint(cellPts[offset + i + 1 + i % 2]);\n          addAPoint(cellPts[offset + i + 1 + (i + 1) % 2]);\n        }\n      }\n    };\n    const cellCounters = {\n      // easy, every input point becomes an output point\n      anythingToPoints(numPoints, cellPts) {\n        return numPoints;\n      },\n      linesToWireframe(numPoints, cellPts) {\n        if (numPoints > 1) {\n          return (numPoints - 1) * 2;\n        }\n        return 0;\n      },\n      polysToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 2;\n        }\n        return 0;\n      },\n      stripsToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 4 - 6;\n        }\n        return 0;\n      },\n      polysToSurface(npts, cellPts) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n        return 0;\n      },\n      stripsToSurface(npts, cellPts, offset) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n        return 0;\n      }\n    };\n    let func = null;\n    let countFunc = null;\n    if (outRep === Representation.POINTS || inRep === 'verts') {\n      func = cellBuilders.anythingToPoints;\n      countFunc = cellCounters.anythingToPoints;\n    } else if (outRep === Representation.WIREFRAME || inRep === 'lines') {\n      func = cellBuilders[`${inRep}ToWireframe`];\n      countFunc = cellCounters[`${inRep}ToWireframe`];\n    } else {\n      func = cellBuilders[`${inRep}ToSurface`];\n      countFunc = cellCounters[`${inRep}ToSurface`];\n    }\n    const array = cellArray.getData();\n    const size = array.length;\n    let caboCount = 0;\n    for (let index = 0; index < size;) {\n      caboCount += countFunc(array[index], array);\n      index += array[index] + 1;\n    }\n    let packedUCVBO = null;\n    const packedVBO = new Float32Array(caboCount * model.blockSize);\n    if (colorData) {\n      packedUCVBO = new Uint8Array(caboCount * 4);\n    }\n    let vboidx = 0;\n    let ucidx = 0;\n\n    // Find out if shift scale should be used\n    // Compute squares of diagonal size and distance from the origin\n    let diagSq = 0.0;\n    let distSq = 0.0;\n    for (let i = 0; i < 3; ++i) {\n      const range = options.points.getRange(i);\n      const delta = range[1] - range[0];\n      diagSq += delta * delta;\n      const distShift = 0.5 * (range[1] + range[0]);\n      distSq += distShift * distShift;\n    }\n    const useShiftAndScale = diagSq > 0 && (Math.abs(distSq) / diagSq > 1.0e6 ||\n    // If data is far from the origin relative to its size\n    Math.abs(Math.log10(diagSq)) > 3.0 ||\n    // If the size is huge when not far from the origin\n    diagSq === 0 && distSq > 1.0e6); // If data is a point, but far from the origin\n\n    if (useShiftAndScale) {\n      // Compute shift and scale vectors\n      const coordShift = new Float64Array(3);\n      const coordScale = new Float64Array(3);\n      for (let i = 0; i < 3; ++i) {\n        const range = options.points.getRange(i);\n        const delta = range[1] - range[0];\n        coordShift[i] = 0.5 * (range[1] + range[0]);\n        coordScale[i] = delta > 0 ? 1.0 / delta : 1.0;\n      }\n      publicAPI.setCoordShiftAndScale(coordShift, coordScale);\n    } else if (model.coordShiftAndScaleEnabled === true) {\n      // Make sure to reset\n      publicAPI.setCoordShiftAndScale(null, null);\n    }\n\n    // Initialize the structures used to keep track of point ids and cell ids for selectors\n    if (selectionMaps) {\n      if (!selectionMaps.points && !selectionMaps.cells) {\n        selectionMaps.points = new Int32Array(caboCount);\n        selectionMaps.cells = new Int32Array(caboCount);\n      } else {\n        const newPoints = new Int32Array(caboCount + selectionMaps.points.length);\n        newPoints.set(selectionMaps.points);\n        selectionMaps.points = newPoints;\n        const newCells = new Int32Array(caboCount + selectionMaps.cells.length);\n        newCells.set(selectionMaps.cells);\n        selectionMaps.cells = newCells;\n      }\n    }\n    let pointCount = options.vertexOffset;\n    addAPoint = function addAPointFunc(i) {\n      // Keep track of original point and cell ids, for selection\n      if (selectionMaps) {\n        selectionMaps.points[pointCount] = i;\n        selectionMaps.cells[pointCount] = cellCount + options.cellOffset;\n      }\n      ++pointCount;\n\n      // Vertices\n      pointIdx = i * 3;\n      if (!model.coordShiftAndScaleEnabled) {\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n      } else {\n        // Apply shift and scale\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];\n      }\n      if (normalData !== null) {\n        if (options.haveCellNormals) {\n          normalIdx = (cellCount + options.cellOffset) * 3;\n        } else {\n          normalIdx = i * 3;\n        }\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n      }\n      model.customData.forEach(attr => {\n        custIdx = i * attr.components;\n        for (let j = 0; j < attr.components; ++j) {\n          packedVBO[vboidx++] = attr.data[custIdx++];\n        }\n      });\n      if (tcoordData !== null) {\n        tcoordIdx = i * textureComponents;\n        for (let j = 0; j < textureComponents; ++j) {\n          packedVBO[vboidx++] = tcoordData[tcoordIdx++];\n        }\n      }\n      if (colorData !== null) {\n        if (options.haveCellScalars) {\n          colorIdx = (cellCount + options.cellOffset) * colorComponents;\n        } else {\n          colorIdx = i * colorComponents;\n        }\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorComponents === 4 ? colorData[colorIdx++] : 255;\n      }\n    };\n    for (let index = 0; index < size;) {\n      func(array[index], array, index + 1);\n      index += array[index] + 1;\n      cellCount++;\n    }\n    model.elementCount = caboCount;\n    publicAPI.upload(packedVBO, ObjectType.ARRAY_BUFFER);\n    if (model.colorBO) {\n      model.colorBOStride = 4;\n      model.colorBO.upload(packedUCVBO, ObjectType.ARRAY_BUFFER);\n    }\n    return cellCount;\n  };\n  publicAPI.setCoordShiftAndScale = (coordShift, coordScale) => {\n    if (coordShift !== null && (coordShift.constructor !== Float64Array || coordShift.length !== 3)) {\n      vtkErrorMacro('Wrong type for coordShift, expected vec3 or null');\n      return;\n    }\n    if (coordScale !== null && (coordScale.constructor !== Float64Array || coordScale.length !== 3)) {\n      vtkErrorMacro('Wrong type for coordScale, expected vec3 or null');\n      return;\n    }\n    if (model.coordShift === null || coordShift === null || !vec3.equals(coordShift, model.coordShift)) {\n      model.coordShift = coordShift;\n    }\n    if (model.coordScale === null || coordScale === null || !vec3.equals(coordScale, model.coordScale)) {\n      model.coordScale = coordScale;\n    }\n    model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(model.coordShift, model.coordScale);\n    if (model.coordShiftAndScaleEnabled) {\n      model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(model.coordShift, model.coordScale);\n    } else {\n      model.inverseShiftAndScaleMatrix = null;\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  elementCount: 0,\n  stride: 0,\n  colorBOStride: 0,\n  vertexOffset: 0,\n  normalOffset: 0,\n  tCoordOffset: 0,\n  tCoordComponents: 0,\n  colorOffset: 0,\n  colorComponents: 0,\n  tcoordBO: null,\n  customData: [],\n  coordShift: null,\n  coordScale: null,\n  coordShiftAndScaleEnabled: false,\n  inverseShiftAndScaleMatrix: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkBufferObject.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['colorBO', 'elementCount', 'stride', 'colorBOStride', 'vertexOffset', 'normalOffset', 'tCoordOffset', 'tCoordComponents', 'colorOffset', 'colorComponents', 'customData']);\n  macro.get(publicAPI, model, ['coordShift', 'coordScale', 'coordShiftAndScaleEnabled', 'inverseShiftAndScaleMatrix']);\n\n  // Object specific methods\n  vtkOpenGLCellArrayBufferObject(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellArrayBufferObject = {\n  newInstance,\n  extend\n};\n\nexport { vtkCellArrayBufferObject as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}