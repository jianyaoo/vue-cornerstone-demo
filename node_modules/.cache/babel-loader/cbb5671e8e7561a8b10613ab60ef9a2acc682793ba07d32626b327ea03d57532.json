{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nconst getIsPointInsidePolygon = (point, vertices) => {\n  const x = point[0];\n  const y = point[1];\n  let inside = false;\n  for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {\n    const xi = vertices[i][0],\n      yi = vertices[i][1];\n    const xj = vertices[j][0],\n      yj = vertices[j][1];\n    const intersect = yi > y != yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) {\n      inside = !inside;\n    }\n  }\n  return inside;\n};\nfunction checkEnclosed(outerContour, innerContour, points) {\n  const vertices = [];\n  outerContour.contourPoints.forEach(point => {\n    vertices.push([points[point][0], points[point][1]]);\n  });\n  let pointsNotEnclosed = 0;\n  innerContour.contourPoints.forEach(point => {\n    const result = getIsPointInsidePolygon([points[point][0], points[point][1]], vertices);\n    if (!result) {\n      pointsNotEnclosed++;\n    }\n  });\n  return pointsNotEnclosed === 0;\n}\nexport function processContourHoles(contours, points, useXOR = true) {\n  const retContours = contours.filter(contour => contour.type !== 'CLOSED_PLANAR');\n  const closedContours = contours.filter(contour => contour.type === 'CLOSED_PLANAR');\n  const contourWithHoles = [];\n  let contourWithoutHoles = [];\n  closedContours.forEach((contour, index) => {\n    const holes = [];\n    closedContours.forEach((hContour, hIndex) => {\n      if (index != hIndex) {\n        if (checkEnclosed(contour, hContour, points)) {\n          holes.push(hIndex);\n        }\n      }\n    });\n    if (holes.length > 0) {\n      contourWithHoles.push({\n        contour,\n        holes\n      });\n    } else {\n      contourWithoutHoles.push(index);\n    }\n  });\n  if (useXOR) {\n    contourWithHoles.forEach(contourHoleSet => {\n      contourHoleSet.contour.type = 'CLOSEDPLANAR_XOR';\n      retContours.push(contourHoleSet.contour);\n      contourHoleSet.holes.forEach(holeIndex => {\n        closedContours[holeIndex].type = 'CLOSEDPLANAR_XOR';\n        retContours.push(closedContours[holeIndex]);\n        contourWithoutHoles = contourWithoutHoles.filter(contourIndex => {\n          return contourIndex !== holeIndex;\n        });\n      });\n    });\n    contourWithoutHoles.forEach(contourIndex => {\n      retContours.push(closedContours[contourIndex]);\n    });\n  } else {}\n  return retContours;\n}\nexport default {\n  processContourHoles\n};","map":{"version":3,"names":["getIsPointInsidePolygon","point","vertices","x","y","inside","i","j","length","xi","yi","xj","yj","intersect","checkEnclosed","outerContour","innerContour","points","contourPoints","forEach","push","pointsNotEnclosed","result","processContourHoles","contours","useXOR","retContours","filter","contour","type","closedContours","contourWithHoles","contourWithoutHoles","index","holes","hContour","hIndex","contourHoleSet","holeIndex","contourIndex"],"sources":["../../../../src/utilities/contours/detectContourHoles.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}