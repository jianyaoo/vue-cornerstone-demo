"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContourBaseTool = exports.default = void 0;
const core_1 = require("@cornerstonejs/core");
const annotationState_1 = require("../../stateManagement/annotation/annotationState");
const drawingSvg_1 = require("../../drawingSvg");
const AnnotationTool_1 = __importDefault(require("./AnnotationTool"));
const contours_1 = require("../../utilities/contours/");
const contours_2 = require("../../utilities/contours");
class ContourBaseTool extends AnnotationTool_1.default {
    constructor(toolProps, defaultToolProps) {
        super(toolProps, defaultToolProps);
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        let renderStatus = false;
        const { viewport } = enabledElement;
        const { element } = viewport;
        if (!viewport.getRenderingEngine()) {
            console.warn('Rendering Engine has been destroyed');
            return renderStatus;
        }
        let annotations = (0, annotationState_1.getAnnotations)(this.getToolName(), element);
        if (!(annotations === null || annotations === void 0 ? void 0 : annotations.length)) {
            return renderStatus;
        }
        annotations = this.filterInteractableAnnotationsForElement(element, annotations);
        if (!(annotations === null || annotations === void 0 ? void 0 : annotations.length)) {
            return renderStatus;
        }
        const targetId = this.getTargetId(viewport);
        const styleSpecifier = {
            toolGroupId: this.toolGroupId,
            toolName: this.getToolName(),
            viewportId: enabledElement.viewport.id,
        };
        for (let i = 0; i < annotations.length; i++) {
            const annotation = annotations[i];
            styleSpecifier.annotationUID = annotation.annotationUID;
            const annotationStyle = this.getAnnotationStyle({
                annotation,
                styleSpecifier,
            });
            if (!annotationStyle.visibility) {
                continue;
            }
            const annotationRendered = this.renderAnnotationInstance({
                enabledElement,
                targetId,
                annotation,
                annotationStyle,
                svgDrawingHelper,
            });
            renderStatus || (renderStatus = annotationRendered);
            annotation.invalidated = false;
        }
        return renderStatus;
    }
    createAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const { world: worldPos } = currentPoints;
        const enabledElement = (0, core_1.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const { viewPlaneNormal, viewUp, position: cameraPosition } = camera;
        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
        const viewReference = viewport.getViewReference({ points: [worldPos] });
        return {
            highlighted: true,
            invalidated: true,
            metadata: Object.assign(Object.assign({ toolName: this.getToolName() }, viewReference), { referencedImageId,
                viewUp,
                cameraPosition }),
            data: {
                handles: {
                    points: [],
                    activeHandleIndex: null,
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                },
                contour: {
                    polyline: [],
                    closed: false,
                },
            },
            interpolationUID: '',
            autoGenerated: false,
        };
    }
    addAnnotation(annotation, element) {
        return (0, annotationState_1.addAnnotation)(annotation, element);
    }
    cancelAnnotation(annotation) {
    }
    moveAnnotation(annotation, worldPosDelta) {
        const { points } = annotation.data.handles;
        for (let i = 0, numPoints = points.length; i < numPoints; i++) {
            const point = points[i];
            point[0] += worldPosDelta[0];
            point[1] += worldPosDelta[1];
            point[2] += worldPosDelta[2];
        }
        annotation.invalidated = true;
        (0, annotationState_1.getChildAnnotations)(annotation).forEach((childAnnotation) => this.moveAnnotation(childAnnotation, worldPosDelta));
    }
    updateContourPolyline(annotation, polylineData, transforms) {
        var _a;
        const decimateConfig = ((_a = this.configuration) === null || _a === void 0 ? void 0 : _a.decimate) || {};
        (0, contours_1.updateContourPolyline)(annotation, polylineData, transforms, {
            decimate: {
                enabled: !!decimateConfig.enabled,
                epsilon: decimateConfig.epsilon,
            },
        });
    }
    getPolylinePoints(annotation) {
        var _a, _b;
        return (_b = (_a = annotation.data.contour) === null || _a === void 0 ? void 0 : _a.polyline) !== null && _b !== void 0 ? _b : annotation.data.polyline;
    }
    renderAnnotationInstance(renderContext) {
        const { enabledElement, annotationStyle, svgDrawingHelper } = renderContext;
        const annotation = renderContext.annotation;
        if (annotation.parentAnnotationUID) {
            return;
        }
        const { annotationUID } = annotation;
        const { viewport } = enabledElement;
        const { worldToCanvas } = viewport;
        const polylineCanvasPoints = this.getPolylinePoints(annotation).map((point) => worldToCanvas(point));
        const { lineWidth, lineDash, color, fillColor, fillOpacity } = annotationStyle;
        const childContours = (0, contours_2.getContourHolesDataCanvas)(annotation, viewport);
        const allContours = [polylineCanvasPoints, ...childContours];
        (0, drawingSvg_1.drawPath)(svgDrawingHelper, annotationUID, 'contourPolyline', allContours, {
            color,
            lineDash,
            lineWidth: Math.max(0.1, lineWidth),
            fillColor: fillColor,
            fillOpacity,
        });
        return true;
    }
}
exports.default = ContourBaseTool;
exports.ContourBaseTool = ContourBaseTool;
//# sourceMappingURL=ContourBaseTool.js.map