{"ast":null,"code":"import { m as macro } from '../../macros2.js';\n\n// ----------------------------------------------------------------------------\n// vtkTexture methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTexture(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkTexture');\n  publicAPI.imageLoaded = () => {\n    model.image.removeEventListener('load', publicAPI.imageLoaded);\n    model.imageLoaded = true;\n    publicAPI.modified();\n  };\n  publicAPI.setJsImageData = imageData => {\n    if (model.jsImageData === imageData) {\n      return;\n    }\n\n    // clear other entries\n    if (imageData !== null) {\n      publicAPI.setInputData(null);\n      publicAPI.setInputConnection(null);\n      model.image = null;\n      model.canvas = null;\n    }\n    model.jsImageData = imageData;\n    model.imageLoaded = true;\n    publicAPI.modified();\n  };\n  publicAPI.setCanvas = canvas => {\n    if (model.canvas === canvas) {\n      return;\n    }\n\n    // clear other entries\n    if (canvas !== null) {\n      publicAPI.setInputData(null);\n      publicAPI.setInputConnection(null);\n      model.image = null;\n      model.jsImageData = null;\n    }\n    model.canvas = canvas;\n    publicAPI.modified();\n  };\n  publicAPI.setImage = image => {\n    if (model.image === image) {\n      return;\n    }\n\n    // clear other entries\n    if (image !== null) {\n      publicAPI.setInputData(null);\n      publicAPI.setInputConnection(null);\n      model.canvas = null;\n      model.jsImageData = null;\n    }\n    model.image = image;\n    model.imageLoaded = false;\n    if (image.complete) {\n      publicAPI.imageLoaded();\n    } else {\n      image.addEventListener('load', publicAPI.imageLoaded);\n    }\n    publicAPI.modified();\n  };\n  publicAPI.getDimensionality = () => {\n    let width = 0;\n    let height = 0;\n    let depth = 1;\n    if (publicAPI.getInputData()) {\n      const data = publicAPI.getInputData();\n      width = data.getDimensions()[0];\n      height = data.getDimensions()[1];\n      depth = data.getDimensions()[2];\n    }\n    if (model.jsImageData) {\n      width = model.jsImageData.width;\n      height = model.jsImageData.height;\n    }\n    if (model.canvas) {\n      width = model.canvas.width;\n      height = model.canvas.height;\n    }\n    if (model.image) {\n      width = model.image.width;\n      height = model.image.height;\n    }\n    const dimensionality = (width > 1) + (height > 1) + (depth > 1);\n    return dimensionality;\n  };\n  publicAPI.getInputAsJsImageData = () => {\n    if (!model.imageLoaded || publicAPI.getInputData()) return null;\n    if (model.jsImageData) {\n      return model.jsImageData();\n    }\n    if (model.canvas) {\n      const context = model.canvas.getContext('2d');\n      const imageData = context.getImageData(0, 0, model.canvas.width, model.canvas.height);\n      return imageData;\n    }\n    if (model.image) {\n      const canvas = document.createElement('canvas');\n      canvas.width = model.image.width;\n      canvas.height = model.image.height;\n      const context = canvas.getContext('2d');\n      context.translate(0, canvas.height);\n      context.scale(1, -1);\n      context.drawImage(model.image, 0, 0, model.image.width, model.image.height);\n      const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n      return imageData;\n    }\n    return null;\n  };\n}\n\n// Use nativeArray instead of self\nconst generateMipmaps = (nativeArray, width, height, level) => {\n  // TODO: FIX UNEVEN TEXTURE MIP GENERATION:\n  // When textures don't have standard ratios, higher mip levels\n  // result in their color chanels getting messed up and shifting\n  // 3x3 gaussian kernel\n  const g3m = [1, 2, 1]; // eslint-disable-line\n  const g3w = 4; // eslint-disable-line\n\n  const kernel = g3m;\n  const kernelWeight = g3w;\n  const hs = nativeArray.length / (width * height); // TODO: support for textures with depth more than 1\n  let currentWidth = width;\n  let currentHeight = height;\n  let imageData = nativeArray;\n  const maps = [imageData];\n  for (let i = 0; i < level; i++) {\n    const oldData = [...imageData];\n    currentWidth /= 2;\n    currentHeight /= 2;\n    imageData = new Uint8ClampedArray(currentWidth * currentHeight * hs);\n    const vs = hs * currentWidth;\n\n    // Scale down\n    let shift = 0;\n    for (let p = 0; p < imageData.length; p += hs) {\n      if (p % vs === 0) {\n        shift += 2 * hs * currentWidth;\n      }\n      for (let c = 0; c < hs; c++) {\n        let sample = oldData[shift + c];\n        sample += oldData[shift + hs + c];\n        sample += oldData[shift - 2 * vs + c];\n        sample += oldData[shift - 2 * vs + hs + c];\n        sample /= 4;\n        imageData[p + c] = sample;\n      }\n      shift += 2 * hs;\n    }\n\n    // Horizontal Pass\n    let dataCopy = [...imageData];\n    for (let p = 0; p < imageData.length; p += hs) {\n      for (let c = 0; c < hs; c++) {\n        let x = -(kernel.length - 1) / 2;\n        let kw = kernelWeight;\n        let value = 0.0;\n        for (let k = 0; k < kernel.length; k++) {\n          let index = p + c + x * hs;\n          const lineShift = index % vs - (p + c) % vs;\n          if (lineShift > hs) index += vs;\n          if (lineShift < -hs) index -= vs;\n          if (dataCopy[index]) {\n            value += dataCopy[index] * kernel[k];\n          } else {\n            kw -= kernel[k];\n          }\n          x += 1;\n        }\n        imageData[p + c] = value / kw;\n      }\n    }\n    // Vertical Pass\n    dataCopy = [...imageData];\n    for (let p = 0; p < imageData.length; p += hs) {\n      for (let c = 0; c < hs; c++) {\n        let x = -(kernel.length - 1) / 2;\n        let kw = kernelWeight;\n        let value = 0.0;\n        for (let k = 0; k < kernel.length; k++) {\n          const index = p + c + x * vs;\n          if (dataCopy[index]) {\n            value += dataCopy[index] * kernel[k];\n          } else {\n            kw -= kernel[k];\n          }\n          x += 1;\n        }\n        imageData[p + c] = value / kw;\n      }\n    }\n    maps.push(imageData);\n  }\n  return maps;\n};\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  image: null,\n  canvas: null,\n  jsImageData: null,\n  imageLoaded: false,\n  repeat: false,\n  interpolate: false,\n  edgeClamp: false,\n  mipLevel: 0,\n  resizable: false // must be set at construction time if the texture can be resizable\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.algo(publicAPI, model, 6, 0);\n  macro.get(publicAPI, model, ['canvas', 'image', 'jsImageData', 'imageLoaded', 'resizable']);\n  macro.setGet(publicAPI, model, ['repeat', 'edgeClamp', 'interpolate', 'mipLevel']);\n  vtkTexture(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkTexture');\nconst STATIC = {\n  generateMipmaps\n};\n\n// ----------------------------------------------------------------------------\n\nvar vtkTexture$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\nexport { STATIC, vtkTexture$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkTexture","publicAPI","model","classHierarchy","push","imageLoaded","image","removeEventListener","modified","setJsImageData","imageData","jsImageData","setInputData","setInputConnection","canvas","setCanvas","setImage","complete","addEventListener","getDimensionality","width","height","depth","getInputData","data","getDimensions","dimensionality","getInputAsJsImageData","context","getContext","getImageData","document","createElement","translate","scale","drawImage","generateMipmaps","nativeArray","level","g3m","g3w","kernel","kernelWeight","hs","length","currentWidth","currentHeight","maps","i","oldData","Uint8ClampedArray","vs","shift","p","c","sample","dataCopy","x","kw","value","k","index","lineShift","DEFAULT_VALUES","repeat","interpolate","edgeClamp","mipLevel","resizable","extend","initialValues","arguments","undefined","Object","assign","obj","algo","get","setGet","newInstance","STATIC","vtkTexture$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/Core/Texture.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\n\n// ----------------------------------------------------------------------------\n// vtkTexture methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTexture(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkTexture');\n  publicAPI.imageLoaded = () => {\n    model.image.removeEventListener('load', publicAPI.imageLoaded);\n    model.imageLoaded = true;\n    publicAPI.modified();\n  };\n  publicAPI.setJsImageData = imageData => {\n    if (model.jsImageData === imageData) {\n      return;\n    }\n\n    // clear other entries\n    if (imageData !== null) {\n      publicAPI.setInputData(null);\n      publicAPI.setInputConnection(null);\n      model.image = null;\n      model.canvas = null;\n    }\n    model.jsImageData = imageData;\n    model.imageLoaded = true;\n    publicAPI.modified();\n  };\n  publicAPI.setCanvas = canvas => {\n    if (model.canvas === canvas) {\n      return;\n    }\n\n    // clear other entries\n    if (canvas !== null) {\n      publicAPI.setInputData(null);\n      publicAPI.setInputConnection(null);\n      model.image = null;\n      model.jsImageData = null;\n    }\n    model.canvas = canvas;\n    publicAPI.modified();\n  };\n  publicAPI.setImage = image => {\n    if (model.image === image) {\n      return;\n    }\n\n    // clear other entries\n    if (image !== null) {\n      publicAPI.setInputData(null);\n      publicAPI.setInputConnection(null);\n      model.canvas = null;\n      model.jsImageData = null;\n    }\n    model.image = image;\n    model.imageLoaded = false;\n    if (image.complete) {\n      publicAPI.imageLoaded();\n    } else {\n      image.addEventListener('load', publicAPI.imageLoaded);\n    }\n    publicAPI.modified();\n  };\n  publicAPI.getDimensionality = () => {\n    let width = 0;\n    let height = 0;\n    let depth = 1;\n    if (publicAPI.getInputData()) {\n      const data = publicAPI.getInputData();\n      width = data.getDimensions()[0];\n      height = data.getDimensions()[1];\n      depth = data.getDimensions()[2];\n    }\n    if (model.jsImageData) {\n      width = model.jsImageData.width;\n      height = model.jsImageData.height;\n    }\n    if (model.canvas) {\n      width = model.canvas.width;\n      height = model.canvas.height;\n    }\n    if (model.image) {\n      width = model.image.width;\n      height = model.image.height;\n    }\n    const dimensionality = (width > 1) + (height > 1) + (depth > 1);\n    return dimensionality;\n  };\n  publicAPI.getInputAsJsImageData = () => {\n    if (!model.imageLoaded || publicAPI.getInputData()) return null;\n    if (model.jsImageData) {\n      return model.jsImageData();\n    }\n    if (model.canvas) {\n      const context = model.canvas.getContext('2d');\n      const imageData = context.getImageData(0, 0, model.canvas.width, model.canvas.height);\n      return imageData;\n    }\n    if (model.image) {\n      const canvas = document.createElement('canvas');\n      canvas.width = model.image.width;\n      canvas.height = model.image.height;\n      const context = canvas.getContext('2d');\n      context.translate(0, canvas.height);\n      context.scale(1, -1);\n      context.drawImage(model.image, 0, 0, model.image.width, model.image.height);\n      const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n      return imageData;\n    }\n    return null;\n  };\n}\n\n// Use nativeArray instead of self\nconst generateMipmaps = (nativeArray, width, height, level) => {\n  // TODO: FIX UNEVEN TEXTURE MIP GENERATION:\n  // When textures don't have standard ratios, higher mip levels\n  // result in their color chanels getting messed up and shifting\n  // 3x3 gaussian kernel\n  const g3m = [1, 2, 1]; // eslint-disable-line\n  const g3w = 4; // eslint-disable-line\n\n  const kernel = g3m;\n  const kernelWeight = g3w;\n  const hs = nativeArray.length / (width * height); // TODO: support for textures with depth more than 1\n  let currentWidth = width;\n  let currentHeight = height;\n  let imageData = nativeArray;\n  const maps = [imageData];\n  for (let i = 0; i < level; i++) {\n    const oldData = [...imageData];\n    currentWidth /= 2;\n    currentHeight /= 2;\n    imageData = new Uint8ClampedArray(currentWidth * currentHeight * hs);\n    const vs = hs * currentWidth;\n\n    // Scale down\n    let shift = 0;\n    for (let p = 0; p < imageData.length; p += hs) {\n      if (p % vs === 0) {\n        shift += 2 * hs * currentWidth;\n      }\n      for (let c = 0; c < hs; c++) {\n        let sample = oldData[shift + c];\n        sample += oldData[shift + hs + c];\n        sample += oldData[shift - 2 * vs + c];\n        sample += oldData[shift - 2 * vs + hs + c];\n        sample /= 4;\n        imageData[p + c] = sample;\n      }\n      shift += 2 * hs;\n    }\n\n    // Horizontal Pass\n    let dataCopy = [...imageData];\n    for (let p = 0; p < imageData.length; p += hs) {\n      for (let c = 0; c < hs; c++) {\n        let x = -(kernel.length - 1) / 2;\n        let kw = kernelWeight;\n        let value = 0.0;\n        for (let k = 0; k < kernel.length; k++) {\n          let index = p + c + x * hs;\n          const lineShift = index % vs - (p + c) % vs;\n          if (lineShift > hs) index += vs;\n          if (lineShift < -hs) index -= vs;\n          if (dataCopy[index]) {\n            value += dataCopy[index] * kernel[k];\n          } else {\n            kw -= kernel[k];\n          }\n          x += 1;\n        }\n        imageData[p + c] = value / kw;\n      }\n    }\n    // Vertical Pass\n    dataCopy = [...imageData];\n    for (let p = 0; p < imageData.length; p += hs) {\n      for (let c = 0; c < hs; c++) {\n        let x = -(kernel.length - 1) / 2;\n        let kw = kernelWeight;\n        let value = 0.0;\n        for (let k = 0; k < kernel.length; k++) {\n          const index = p + c + x * vs;\n          if (dataCopy[index]) {\n            value += dataCopy[index] * kernel[k];\n          } else {\n            kw -= kernel[k];\n          }\n          x += 1;\n        }\n        imageData[p + c] = value / kw;\n      }\n    }\n    maps.push(imageData);\n  }\n  return maps;\n};\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  image: null,\n  canvas: null,\n  jsImageData: null,\n  imageLoaded: false,\n  repeat: false,\n  interpolate: false,\n  edgeClamp: false,\n  mipLevel: 0,\n  resizable: false // must be set at construction time if the texture can be resizable\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.algo(publicAPI, model, 6, 0);\n  macro.get(publicAPI, model, ['canvas', 'image', 'jsImageData', 'imageLoaded', 'resizable']);\n  macro.setGet(publicAPI, model, ['repeat', 'edgeClamp', 'interpolate', 'mipLevel']);\n  vtkTexture(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkTexture');\nconst STATIC = {\n  generateMipmaps\n};\n\n// ----------------------------------------------------------------------------\n\nvar vtkTexture$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkTexture$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}