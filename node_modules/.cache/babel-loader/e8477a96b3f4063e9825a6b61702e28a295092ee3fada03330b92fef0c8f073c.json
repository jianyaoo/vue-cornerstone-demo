{"ast":null,"code":"import { mat4, vec3 } from 'gl-matrix';\nimport { n as newInstance$1, o as obj, g as get, k as getArray, e as setGet, c as macro } from '../../macros2.js';\nimport { r as radiansFromDegrees } from '../../Common/Core/Math/index.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport vtkWebGPUBindGroup from './BindGroup.js';\nimport vtkWebGPUFullScreenQuad from './FullScreenQuad.js';\nimport vtkWebGPUStorageBuffer from './StorageBuffer.js';\nimport vtkWebGPUUniformBuffer from './UniformBuffer.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nconst {\n  vtkDebugMacro\n} = macro;\nconst clearFragColorTemplate = `\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = mapperUBO.BackgroundColor;\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n`;\nconst clearFragTextureTemplate = `\nfn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {\n  var tau: f32 = 6.28318530718;\n  var pi: f32 = 3.14159265359;\n  var out: vec2<f32> = vec2<f32>(0.0);\n\n  out.x = atan2(dir.z, dir.x) / tau;\n  out.x += 0.5;\n\n  var phix: f32 = length(vec2(dir.x, dir.z));\n  out.y = atan2(dir.y, phix) / pi + 0.5;\n\n  return out;\n}\n\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var tcoord: vec4<f32> = vec4<f32>(input.vertexVC.xy, -1, 1);\n  var V: vec4<f32> = normalize(mapperUBO.FSQMatrix * tcoord); // vec2<f32>((input.tcoordVS.x - 0.5) * 2, -(input.tcoordVS.y - 0.5) * 2);\n  // textureSampleLevel gets rid of some ugly artifacts\n  var background = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, vecToRectCoord(V.xyz), 0);\n  var computedColor: vec4<f32> = vec4<f32>(background.rgb, 1);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n`;\nconst _fsqClearMat4 = new Float64Array(16);\nconst _tNormalMat4 = new Float64Array(16);\n\n// Light type index gives either 0, 1, or 2 which indicates what type of light there is.\n// While technically, there are only spot and directional lights, within the CellArrayMapper\n// there is a third, positional light. It is technically just a variant of a spot light with\n// a cone angle of 90 or above, however certain calculations can be skipped if it is treated\n// separately.\n// The mappings are shown below:\n// 0 -> positional light\n// 1 -> directional light\n// 2 -> spot light\nfunction getLightTypeIndex(light) {\n  if (light.getPositional()) {\n    if (light.getConeAngle() >= 90) {\n      return 0;\n    }\n    return 2;\n  }\n  return 1;\n}\n\n// ----------------------------------------------------------------------------\n// vtkWebGPURenderer methods\n// ----------------------------------------------------------------------------\n/* eslint-disable no-bitwise */\n\nfunction vtkWebGPURenderer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPURenderer');\n\n  // Builds myself.\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      if (!model.renderable) {\n        return;\n      }\n      model.camera = model.renderable.getActiveCamera();\n      publicAPI.updateLights();\n      publicAPI.prepareNodes();\n      publicAPI.addMissingNode(model.camera);\n      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());\n      publicAPI.removeUnusedNodes();\n      model.webgpuCamera = publicAPI.getViewNodeFor(model.camera);\n      publicAPI.updateStabilizedMatrix();\n    }\n  };\n  publicAPI.updateStabilizedMatrix = () => {\n    // This method is designed to help with floating point\n    // issues when rendering datasets that push the limits of\n    // resolutions on float.\n    //\n    // One of the most common cases is when the dataset is located far\n    // away from the origin relative to the clipping range we are looking\n    // at. For that case we want to perform the floating point sensitive\n    // multiplications on the CPU in double. To this end we want the\n    // vertex rendering ops to look something like\n    //\n    // Compute shifted points and load those into the VBO\n    // pointCoordsSC = WorldToStabilizedMatrix * pointCoords;\n    //\n    // In the vertex shader do the following\n    // positionVC = StabilizedToDeviceMatrix * ModelToStabilizedMatrix*vertexIn;\n    //\n    // We use two matrices because it is expensive to change the\n    // WorldToStabilized matrix as we have to reupload all pointCoords\n    // So that matrix (MCSCMatrix) is fairly static, the Stabilized to\n    // Device matrix is the one that gets updated every time the camera\n    // changes.\n    //\n    // The basic idea is that we should translate the data so that\n    // when the center of the view frustum moves a lot\n    // we recenter it. The center of the view frustum is roughly\n    // camPos + dirOfProj*(far + near)*0.5\n    const clipRange = model.camera.getClippingRange();\n    const pos = model.camera.getPositionByReference();\n    const dop = model.camera.getDirectionOfProjectionByReference();\n    const center = [];\n    const offset = [];\n    vec3.scale(offset, dop, 0.5 * (clipRange[0] + clipRange[1]));\n    vec3.add(center, pos, offset);\n    vec3.sub(offset, center, model.stabilizedCenter);\n    const length = vec3.len(offset);\n    if (length / (clipRange[1] - clipRange[0]) > model.recenterThreshold) {\n      model.stabilizedCenter = center;\n      model.stabilizedTime.modified();\n    }\n  };\n  publicAPI.updateLights = () => {\n    let count = 0;\n    const lights = model.renderable.getLightsByReference();\n    for (let index = 0; index < lights.length; ++index) {\n      if (lights[index].getSwitch() > 0.0) {\n        count++;\n      }\n    }\n    if (!count) {\n      vtkDebugMacro('No lights are on, creating one.');\n      model.renderable.createLight();\n    }\n    return count;\n  };\n  publicAPI.updateUBO = () => {\n    // make sure the data is up to date\n    // has the camera changed?\n    const utime = model.UBO.getSendTime();\n    if (model._parent.getMTime() > utime || publicAPI.getMTime() > utime || model.camera.getMTime() > utime || model.renderable.getMTime() > utime) {\n      const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);\n      model.UBO.setArray('WCVCMatrix', keyMats.wcvc);\n      model.UBO.setArray('SCPCMatrix', keyMats.scpc);\n      model.UBO.setArray('PCSCMatrix', keyMats.pcsc);\n      model.UBO.setArray('SCVCMatrix', keyMats.scvc);\n      model.UBO.setArray('VCPCMatrix', keyMats.vcpc);\n      model.UBO.setArray('WCVCNormals', keyMats.normalMatrix);\n      model.UBO.setValue('LightCount', model.renderable.getLights().length);\n      model.UBO.setValue('MaxEnvironmentMipLevel', model.renderable.getEnvironmentTexture()?.getMipLevel());\n      model.UBO.setValue('BackgroundDiffuseStrength', model.renderable.getEnvironmentTextureDiffuseStrength());\n      model.UBO.setValue('BackgroundSpecularStrength', model.renderable.getEnvironmentTextureSpecularStrength());\n      const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();\n      model.UBO.setArray('viewportSize', [tsize.usize, tsize.vsize]);\n      model.UBO.setValue('cameraParallel', model.camera.getParallelProjection());\n      const device = model._parent.getDevice();\n      model.UBO.sendIfNeeded(device);\n    }\n  };\n  publicAPI.updateSSBO = () => {\n    const lights = model.renderable.getLights();\n    const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);\n    let lightTimeString = `${model.renderable.getMTime()}`;\n    for (let i = 0; i < lights.length; i++) {\n      lightTimeString += lights[i].getMTime();\n    }\n    if (lightTimeString !== model.lightTimeString) {\n      const lightPosArray = new Float32Array(lights.length * 4);\n      const lightDirArray = new Float32Array(lights.length * 4);\n      const lightColorArray = new Float32Array(lights.length * 4);\n      const lightTypeArray = new Float32Array(lights.length * 4);\n      for (let i = 0; i < lights.length; i++) {\n        const offset = i * 4;\n\n        // Position\n        const viewCoordinatePosition = lights[i].getPosition();\n        vec3.transformMat4(viewCoordinatePosition, viewCoordinatePosition, keyMats.wcvc);\n        // viewCoordinatePosition\n        lightPosArray[offset] = viewCoordinatePosition[0];\n        lightPosArray[offset + 1] = viewCoordinatePosition[1];\n        lightPosArray[offset + 2] = viewCoordinatePosition[2];\n        lightPosArray[offset + 3] = 0;\n\n        // Rotation (All are negative to correct for -Z being forward)\n        lightDirArray[offset] = -lights[i].getDirection()[0];\n        lightDirArray[offset + 1] = -lights[i].getDirection()[1];\n        lightDirArray[offset + 2] = -lights[i].getDirection()[2];\n        lightDirArray[offset + 3] = 0;\n\n        // Color\n        lightColorArray[offset] = lights[i].getColor()[0];\n        lightColorArray[offset + 1] = lights[i].getColor()[1];\n        lightColorArray[offset + 2] = lights[i].getColor()[2];\n        lightColorArray[offset + 3] = lights[i].getIntensity() * 5; // arbitrary multiplication to fix the dullness of low value PBR lights\n\n        // Type\n        lightTypeArray[offset] = getLightTypeIndex(lights[i]); // Type\n        lightTypeArray[offset + 1] = Math.cos(radiansFromDegrees(lights[i].getConeAngle())); // Inner Phi, should probably do some check on these to make sure they dont excede limits\n        lightTypeArray[offset + 2] = Math.cos(radiansFromDegrees(lights[i].getConeAngle() + lights[i].getConeFalloff())); // Outer Phi\n        lightTypeArray[offset + 3] = 0;\n      }\n\n      // Im not sure how correct this is, but this is what the example does\n      // https://kitware.github.io/vtk-js/api/Rendering_WebGPU_VolumePassFSQ.html\n      model.SSBO.clearData();\n      model.SSBO.setNumberOfInstances(lights.length);\n      model.SSBO.addEntry('LightPos', 'vec4<f32>'); // Position\n      model.SSBO.addEntry('LightDir', 'vec4<f32>'); // Direction\n      model.SSBO.addEntry('LightColor', 'vec4<f32>'); // Color (r, g, b, intensity)\n      model.SSBO.addEntry('LightData', 'vec4<f32>'); // Other data (type, etc, etc, etc)\n\n      model.SSBO.setAllInstancesFromArray('LightPos', lightPosArray);\n      model.SSBO.setAllInstancesFromArray('LightDir', lightDirArray);\n      model.SSBO.setAllInstancesFromArray('LightColor', lightColorArray);\n      model.SSBO.setAllInstancesFromArray('LightData', lightTypeArray);\n      const device = model._parent.getDevice();\n      model.SSBO.send(device);\n    }\n    model.lightTimeString = lightTimeString;\n  };\n  publicAPI.scissorAndViewport = encoder => {\n    const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();\n    encoder.getHandle().setViewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize, 0.0, 1.0);\n    // set scissor\n    encoder.getHandle().setScissorRect(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);\n  };\n  publicAPI.bindUBO = renderEncoder => {\n    renderEncoder.activateBindGroup(model.bindGroup);\n  };\n\n  // Renders myself\n  publicAPI.opaquePass = prepass => {\n    if (prepass) {\n      model.renderEncoder.begin(model._parent.getCommandEncoder());\n      publicAPI.updateUBO();\n      publicAPI.updateSSBO();\n    } else {\n      publicAPI.scissorAndViewport(model.renderEncoder);\n      publicAPI.clear();\n      model.renderEncoder.end();\n    }\n  };\n  publicAPI.clear = () => {\n    if (model.renderable.getTransparent() || model.suppressClear) {\n      return;\n    }\n    const device = model._parent.getDevice();\n    // Normal Solid Color\n    if (!model.clearFSQ) {\n      model.clearFSQ = vtkWebGPUFullScreenQuad.newInstance();\n      model.clearFSQ.setDevice(device);\n      model.clearFSQ.setPipelineHash('clearfsq');\n      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);\n      const ubo = vtkWebGPUUniformBuffer.newInstance({\n        label: 'mapperUBO'\n      });\n      ubo.addEntry('FSQMatrix', 'mat4x4<f32>');\n      ubo.addEntry('BackgroundColor', 'vec4<f32>');\n      model.clearFSQ.setUBO(ubo);\n      model.backgroundTex = model.renderable.getEnvironmentTexture();\n    }\n    // Textured Background\n    if (model.clearFSQ.getPipelineHash() !== 'clearfsqwithtexture' && model.renderable.getUseEnvironmentTextureAsBackground() && model.backgroundTex?.getImageLoaded()) {\n      model.clearFSQ.setFragmentShaderTemplate(clearFragTextureTemplate);\n      const ubo = vtkWebGPUUniformBuffer.newInstance({\n        label: 'mapperUBO'\n      });\n      ubo.addEntry('FSQMatrix', 'mat4x4<f32>');\n      ubo.addEntry('BackgroundColor', 'vec4<f32>');\n      model.clearFSQ.setUBO(ubo);\n      const environmentTextureHash = device.getTextureManager().getTextureForVTKTexture(model.backgroundTex);\n      if (environmentTextureHash.getReady()) {\n        const tview = environmentTextureHash.createView(`EnvironmentTexture`);\n        model.clearFSQ.setTextureViews([tview]);\n        model.backgroundTexLoaded = true;\n        const interpolate = model.backgroundTex.getInterpolate() ? 'linear' : 'nearest';\n        tview.addSampler(device, {\n          addressModeU: 'repeat',\n          addressModeV: 'clamp-to-edge',\n          addressModeW: 'repeat',\n          minFilter: interpolate,\n          magFilter: interpolate,\n          mipmapFilter: 'linear'\n        });\n      }\n      model.clearFSQ.setPipelineHash('clearfsqwithtexture');\n    } else if (model.clearFSQ.getPipelineHash() === 'clearfsqwithtexture' && !model.renderable.getUseEnvironmentTextureAsBackground()) {\n      // In case the mode is changed at runtime\n      model.clearFSQ = vtkWebGPUFullScreenQuad.newInstance();\n      model.clearFSQ.setDevice(device);\n      model.clearFSQ.setPipelineHash('clearfsq');\n      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);\n      const ubo = vtkWebGPUUniformBuffer.newInstance({\n        label: 'mapperUBO'\n      });\n      ubo.addEntry('FSQMatrix', 'mat4x4<f32>');\n      ubo.addEntry('BackgroundColor', 'vec4<f32>');\n      model.clearFSQ.setUBO(ubo);\n    }\n    const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);\n    const background = model.renderable.getBackgroundByReference();\n    model.clearFSQ.getUBO().setArray('BackgroundColor', background);\n    mat4.transpose(_tNormalMat4, keyMats.normalMatrix);\n    mat4.mul(_fsqClearMat4, keyMats.scvc, keyMats.pcsc);\n    mat4.mul(_fsqClearMat4, _tNormalMat4, _fsqClearMat4);\n    model.clearFSQ.getUBO().setArray('FSQMatrix', _fsqClearMat4);\n    model.clearFSQ.getUBO().sendIfNeeded(device);\n    model.clearFSQ.prepareAndDraw(model.renderEncoder);\n  };\n  publicAPI.translucentPass = prepass => {\n    if (prepass) {\n      model.renderEncoder.begin(model._parent.getCommandEncoder());\n    } else {\n      publicAPI.scissorAndViewport(model.renderEncoder);\n      model.renderEncoder.end();\n    }\n  };\n  publicAPI.volumeDepthRangePass = prepass => {\n    if (prepass) {\n      model.renderEncoder.begin(model._parent.getCommandEncoder());\n    } else {\n      publicAPI.scissorAndViewport(model.renderEncoder);\n      model.renderEncoder.end();\n    }\n  };\n  publicAPI.getAspectRatio = () => {\n    const size = model._parent.getSizeByReference();\n    const viewport = model.renderable.getViewportByReference();\n    return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);\n  };\n  publicAPI.convertToOpenGLDepth = val => model.webgpuCamera.convertToOpenGLDepth(val);\n  publicAPI.getYInvertedTiledSizeAndOrigin = () => {\n    const res = publicAPI.getTiledSizeAndOrigin();\n    const size = model._parent.getSizeByReference();\n    res.lowerLeftV = size[1] - res.vsize - res.lowerLeftV;\n    return res;\n  };\n  publicAPI.getTiledSizeAndOrigin = () => {\n    const vport = model.renderable.getViewportByReference();\n\n    // if there is no window assume 0 1\n    const tileViewPort = [0.0, 0.0, 1.0, 1.0];\n\n    // find the lower left corner of the viewport, taking into account the\n    // lower left boundary of this tile\n    const vpu = vport[0] - tileViewPort[0];\n    const vpv = vport[1] - tileViewPort[1];\n\n    // store the result as a pixel value\n    const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);\n    const lowerLeftU = Math.round(ndvp[0]);\n    const lowerLeftV = Math.round(ndvp[1]);\n\n    // find the upper right corner of the viewport, taking into account the\n    // lower left boundary of this tile\n    const vpu2 = vport[2] - tileViewPort[0];\n    const vpv2 = vport[3] - tileViewPort[1];\n    const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);\n\n    // now compute the size of the intersection of the viewport with the\n    // current tile\n    let usize = Math.round(ndvp2[0]) - lowerLeftU;\n    let vsize = Math.round(ndvp2[1]) - lowerLeftV;\n    if (usize < 0) {\n      usize = 0;\n    }\n    if (vsize < 0) {\n      vsize = 0;\n    }\n    return {\n      usize,\n      vsize,\n      lowerLeftU,\n      lowerLeftV\n    };\n  };\n  publicAPI.getPropFromID = id => {\n    for (let i = 0; i < model.children.length; i++) {\n      const res = model.children[i].getPropID ? model.children[i].getPropID() : -1;\n      if (res === id) {\n        return model.children[i];\n      }\n    }\n    return null;\n  };\n  publicAPI.getStabilizedTime = () => model.stabilizedTime.getMTime();\n  publicAPI.releaseGraphicsResources = () => {\n    if (model.selector !== null) {\n      model.selector.releaseGraphicsResources();\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  bindGroup: null,\n  selector: null,\n  renderEncoder: null,\n  recenterThreshold: 20.0,\n  suppressClear: false,\n  stabilizedCenter: [0.0, 0.0, 0.0]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n\n  // UBO\n  model.UBO = vtkWebGPUUniformBuffer.newInstance({\n    label: 'rendererUBO'\n  });\n  model.UBO.addEntry('WCVCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('SCPCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('PCSCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('SCVCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('VCPCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('WCVCNormals', 'mat4x4<f32>');\n  model.UBO.addEntry('viewportSize', 'vec2<f32>');\n  model.UBO.addEntry('LightCount', 'i32');\n  model.UBO.addEntry('MaxEnvironmentMipLevel', 'f32');\n  model.UBO.addEntry('BackgroundDiffuseStrength', 'f32');\n  model.UBO.addEntry('BackgroundSpecularStrength', 'f32');\n  model.UBO.addEntry('cameraParallel', 'u32');\n\n  // SSBO (Light data)\n  model.SSBO = vtkWebGPUStorageBuffer.newInstance({\n    label: 'rendererLightSSBO'\n  });\n  model.lightTimeString = '';\n  model.bindGroup = vtkWebGPUBindGroup.newInstance({\n    label: 'rendererBG'\n  });\n  model.bindGroup.setBindables([model.UBO, model.SSBO]);\n  model.tmpMat4 = mat4.identity(new Float64Array(16));\n  model.stabilizedTime = {};\n  obj(model.stabilizedTime, {\n    mtime: 0\n  });\n\n  // Build VTK API\n  get(publicAPI, model, ['bindGroup', 'stabilizedTime']);\n  getArray(publicAPI, model, ['stabilizedCenter']);\n  setGet(publicAPI, model, ['renderEncoder', 'selector', 'suppressClear', 'UBO']);\n\n  // Object methods\n  vtkWebGPURenderer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkWebGPURenderer');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\n// Register ourself to WebGPU backend if imported\nregisterOverride('vtkRenderer', newInstance);\nexport { index as default, extend, newInstance };","map":{"version":3,"names":["mat4","vec3","n","newInstance$1","o","obj","g","get","k","getArray","e","setGet","c","macro","r","radiansFromDegrees","vtkViewNode","vtkWebGPUBindGroup","vtkWebGPUFullScreenQuad","vtkWebGPUStorageBuffer","vtkWebGPUUniformBuffer","registerOverride","vtkDebugMacro","clearFragColorTemplate","clearFragTextureTemplate","_fsqClearMat4","Float64Array","_tNormalMat4","getLightTypeIndex","light","getPositional","getConeAngle","vtkWebGPURenderer","publicAPI","model","classHierarchy","push","buildPass","prepass","renderable","camera","getActiveCamera","updateLights","prepareNodes","addMissingNode","addMissingNodes","getViewPropsWithNestedProps","removeUnusedNodes","webgpuCamera","getViewNodeFor","updateStabilizedMatrix","clipRange","getClippingRange","pos","getPositionByReference","dop","getDirectionOfProjectionByReference","center","offset","scale","add","sub","stabilizedCenter","length","len","recenterThreshold","stabilizedTime","modified","count","lights","getLightsByReference","index","getSwitch","createLight","updateUBO","utime","UBO","getSendTime","_parent","getMTime","keyMats","getKeyMatrices","setArray","wcvc","scpc","pcsc","scvc","vcpc","normalMatrix","setValue","getLights","getEnvironmentTexture","getMipLevel","getEnvironmentTextureDiffuseStrength","getEnvironmentTextureSpecularStrength","tsize","getYInvertedTiledSizeAndOrigin","usize","vsize","getParallelProjection","device","getDevice","sendIfNeeded","updateSSBO","lightTimeString","i","lightPosArray","Float32Array","lightDirArray","lightColorArray","lightTypeArray","viewCoordinatePosition","getPosition","transformMat4","getDirection","getColor","getIntensity","Math","cos","getConeFalloff","SSBO","clearData","setNumberOfInstances","addEntry","setAllInstancesFromArray","send","scissorAndViewport","encoder","getHandle","setViewport","lowerLeftU","lowerLeftV","setScissorRect","bindUBO","renderEncoder","activateBindGroup","bindGroup","opaquePass","begin","getCommandEncoder","clear","end","getTransparent","suppressClear","clearFSQ","newInstance","setDevice","setPipelineHash","setFragmentShaderTemplate","ubo","label","setUBO","backgroundTex","getPipelineHash","getUseEnvironmentTextureAsBackground","getImageLoaded","environmentTextureHash","getTextureManager","getTextureForVTKTexture","getReady","tview","createView","setTextureViews","backgroundTexLoaded","interpolate","getInterpolate","addSampler","addressModeU","addressModeV","addressModeW","minFilter","magFilter","mipmapFilter","background","getBackgroundByReference","getUBO","transpose","mul","prepareAndDraw","translucentPass","volumeDepthRangePass","getAspectRatio","size","getSizeByReference","viewport","getViewportByReference","convertToOpenGLDepth","val","res","getTiledSizeAndOrigin","vport","tileViewPort","vpu","vpv","ndvp","normalizedDisplayToDisplay","round","vpu2","vpv2","ndvp2","getPropFromID","id","children","getPropID","getStabilizedTime","releaseGraphicsResources","selector","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","setBindables","tmpMat4","identity","mtime","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/WebGPU/Renderer.js"],"sourcesContent":["import { mat4, vec3 } from 'gl-matrix';\nimport { n as newInstance$1, o as obj, g as get, k as getArray, e as setGet, c as macro } from '../../macros2.js';\nimport { r as radiansFromDegrees } from '../../Common/Core/Math/index.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport vtkWebGPUBindGroup from './BindGroup.js';\nimport vtkWebGPUFullScreenQuad from './FullScreenQuad.js';\nimport vtkWebGPUStorageBuffer from './StorageBuffer.js';\nimport vtkWebGPUUniformBuffer from './UniformBuffer.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  vtkDebugMacro\n} = macro;\nconst clearFragColorTemplate = `\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = mapperUBO.BackgroundColor;\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n`;\nconst clearFragTextureTemplate = `\nfn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {\n  var tau: f32 = 6.28318530718;\n  var pi: f32 = 3.14159265359;\n  var out: vec2<f32> = vec2<f32>(0.0);\n\n  out.x = atan2(dir.z, dir.x) / tau;\n  out.x += 0.5;\n\n  var phix: f32 = length(vec2(dir.x, dir.z));\n  out.y = atan2(dir.y, phix) / pi + 0.5;\n\n  return out;\n}\n\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var tcoord: vec4<f32> = vec4<f32>(input.vertexVC.xy, -1, 1);\n  var V: vec4<f32> = normalize(mapperUBO.FSQMatrix * tcoord); // vec2<f32>((input.tcoordVS.x - 0.5) * 2, -(input.tcoordVS.y - 0.5) * 2);\n  // textureSampleLevel gets rid of some ugly artifacts\n  var background = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, vecToRectCoord(V.xyz), 0);\n  var computedColor: vec4<f32> = vec4<f32>(background.rgb, 1);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n`;\nconst _fsqClearMat4 = new Float64Array(16);\nconst _tNormalMat4 = new Float64Array(16);\n\n// Light type index gives either 0, 1, or 2 which indicates what type of light there is.\n// While technically, there are only spot and directional lights, within the CellArrayMapper\n// there is a third, positional light. It is technically just a variant of a spot light with\n// a cone angle of 90 or above, however certain calculations can be skipped if it is treated\n// separately.\n// The mappings are shown below:\n// 0 -> positional light\n// 1 -> directional light\n// 2 -> spot light\nfunction getLightTypeIndex(light) {\n  if (light.getPositional()) {\n    if (light.getConeAngle() >= 90) {\n      return 0;\n    }\n    return 2;\n  }\n  return 1;\n}\n\n// ----------------------------------------------------------------------------\n// vtkWebGPURenderer methods\n// ----------------------------------------------------------------------------\n/* eslint-disable no-bitwise */\n\nfunction vtkWebGPURenderer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPURenderer');\n\n  // Builds myself.\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      if (!model.renderable) {\n        return;\n      }\n      model.camera = model.renderable.getActiveCamera();\n      publicAPI.updateLights();\n      publicAPI.prepareNodes();\n      publicAPI.addMissingNode(model.camera);\n      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());\n      publicAPI.removeUnusedNodes();\n      model.webgpuCamera = publicAPI.getViewNodeFor(model.camera);\n      publicAPI.updateStabilizedMatrix();\n    }\n  };\n  publicAPI.updateStabilizedMatrix = () => {\n    // This method is designed to help with floating point\n    // issues when rendering datasets that push the limits of\n    // resolutions on float.\n    //\n    // One of the most common cases is when the dataset is located far\n    // away from the origin relative to the clipping range we are looking\n    // at. For that case we want to perform the floating point sensitive\n    // multiplications on the CPU in double. To this end we want the\n    // vertex rendering ops to look something like\n    //\n    // Compute shifted points and load those into the VBO\n    // pointCoordsSC = WorldToStabilizedMatrix * pointCoords;\n    //\n    // In the vertex shader do the following\n    // positionVC = StabilizedToDeviceMatrix * ModelToStabilizedMatrix*vertexIn;\n    //\n    // We use two matrices because it is expensive to change the\n    // WorldToStabilized matrix as we have to reupload all pointCoords\n    // So that matrix (MCSCMatrix) is fairly static, the Stabilized to\n    // Device matrix is the one that gets updated every time the camera\n    // changes.\n    //\n    // The basic idea is that we should translate the data so that\n    // when the center of the view frustum moves a lot\n    // we recenter it. The center of the view frustum is roughly\n    // camPos + dirOfProj*(far + near)*0.5\n    const clipRange = model.camera.getClippingRange();\n    const pos = model.camera.getPositionByReference();\n    const dop = model.camera.getDirectionOfProjectionByReference();\n    const center = [];\n    const offset = [];\n    vec3.scale(offset, dop, 0.5 * (clipRange[0] + clipRange[1]));\n    vec3.add(center, pos, offset);\n    vec3.sub(offset, center, model.stabilizedCenter);\n    const length = vec3.len(offset);\n    if (length / (clipRange[1] - clipRange[0]) > model.recenterThreshold) {\n      model.stabilizedCenter = center;\n      model.stabilizedTime.modified();\n    }\n  };\n  publicAPI.updateLights = () => {\n    let count = 0;\n    const lights = model.renderable.getLightsByReference();\n    for (let index = 0; index < lights.length; ++index) {\n      if (lights[index].getSwitch() > 0.0) {\n        count++;\n      }\n    }\n    if (!count) {\n      vtkDebugMacro('No lights are on, creating one.');\n      model.renderable.createLight();\n    }\n    return count;\n  };\n  publicAPI.updateUBO = () => {\n    // make sure the data is up to date\n    // has the camera changed?\n    const utime = model.UBO.getSendTime();\n    if (model._parent.getMTime() > utime || publicAPI.getMTime() > utime || model.camera.getMTime() > utime || model.renderable.getMTime() > utime) {\n      const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);\n      model.UBO.setArray('WCVCMatrix', keyMats.wcvc);\n      model.UBO.setArray('SCPCMatrix', keyMats.scpc);\n      model.UBO.setArray('PCSCMatrix', keyMats.pcsc);\n      model.UBO.setArray('SCVCMatrix', keyMats.scvc);\n      model.UBO.setArray('VCPCMatrix', keyMats.vcpc);\n      model.UBO.setArray('WCVCNormals', keyMats.normalMatrix);\n      model.UBO.setValue('LightCount', model.renderable.getLights().length);\n      model.UBO.setValue('MaxEnvironmentMipLevel', model.renderable.getEnvironmentTexture()?.getMipLevel());\n      model.UBO.setValue('BackgroundDiffuseStrength', model.renderable.getEnvironmentTextureDiffuseStrength());\n      model.UBO.setValue('BackgroundSpecularStrength', model.renderable.getEnvironmentTextureSpecularStrength());\n      const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();\n      model.UBO.setArray('viewportSize', [tsize.usize, tsize.vsize]);\n      model.UBO.setValue('cameraParallel', model.camera.getParallelProjection());\n      const device = model._parent.getDevice();\n      model.UBO.sendIfNeeded(device);\n    }\n  };\n  publicAPI.updateSSBO = () => {\n    const lights = model.renderable.getLights();\n    const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);\n    let lightTimeString = `${model.renderable.getMTime()}`;\n    for (let i = 0; i < lights.length; i++) {\n      lightTimeString += lights[i].getMTime();\n    }\n    if (lightTimeString !== model.lightTimeString) {\n      const lightPosArray = new Float32Array(lights.length * 4);\n      const lightDirArray = new Float32Array(lights.length * 4);\n      const lightColorArray = new Float32Array(lights.length * 4);\n      const lightTypeArray = new Float32Array(lights.length * 4);\n      for (let i = 0; i < lights.length; i++) {\n        const offset = i * 4;\n\n        // Position\n        const viewCoordinatePosition = lights[i].getPosition();\n        vec3.transformMat4(viewCoordinatePosition, viewCoordinatePosition, keyMats.wcvc);\n        // viewCoordinatePosition\n        lightPosArray[offset] = viewCoordinatePosition[0];\n        lightPosArray[offset + 1] = viewCoordinatePosition[1];\n        lightPosArray[offset + 2] = viewCoordinatePosition[2];\n        lightPosArray[offset + 3] = 0;\n\n        // Rotation (All are negative to correct for -Z being forward)\n        lightDirArray[offset] = -lights[i].getDirection()[0];\n        lightDirArray[offset + 1] = -lights[i].getDirection()[1];\n        lightDirArray[offset + 2] = -lights[i].getDirection()[2];\n        lightDirArray[offset + 3] = 0;\n\n        // Color\n        lightColorArray[offset] = lights[i].getColor()[0];\n        lightColorArray[offset + 1] = lights[i].getColor()[1];\n        lightColorArray[offset + 2] = lights[i].getColor()[2];\n        lightColorArray[offset + 3] = lights[i].getIntensity() * 5; // arbitrary multiplication to fix the dullness of low value PBR lights\n\n        // Type\n        lightTypeArray[offset] = getLightTypeIndex(lights[i]); // Type\n        lightTypeArray[offset + 1] = Math.cos(radiansFromDegrees(lights[i].getConeAngle())); // Inner Phi, should probably do some check on these to make sure they dont excede limits\n        lightTypeArray[offset + 2] = Math.cos(radiansFromDegrees(lights[i].getConeAngle() + lights[i].getConeFalloff())); // Outer Phi\n        lightTypeArray[offset + 3] = 0;\n      }\n\n      // Im not sure how correct this is, but this is what the example does\n      // https://kitware.github.io/vtk-js/api/Rendering_WebGPU_VolumePassFSQ.html\n      model.SSBO.clearData();\n      model.SSBO.setNumberOfInstances(lights.length);\n      model.SSBO.addEntry('LightPos', 'vec4<f32>'); // Position\n      model.SSBO.addEntry('LightDir', 'vec4<f32>'); // Direction\n      model.SSBO.addEntry('LightColor', 'vec4<f32>'); // Color (r, g, b, intensity)\n      model.SSBO.addEntry('LightData', 'vec4<f32>'); // Other data (type, etc, etc, etc)\n\n      model.SSBO.setAllInstancesFromArray('LightPos', lightPosArray);\n      model.SSBO.setAllInstancesFromArray('LightDir', lightDirArray);\n      model.SSBO.setAllInstancesFromArray('LightColor', lightColorArray);\n      model.SSBO.setAllInstancesFromArray('LightData', lightTypeArray);\n      const device = model._parent.getDevice();\n      model.SSBO.send(device);\n    }\n    model.lightTimeString = lightTimeString;\n  };\n  publicAPI.scissorAndViewport = encoder => {\n    const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();\n    encoder.getHandle().setViewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize, 0.0, 1.0);\n    // set scissor\n    encoder.getHandle().setScissorRect(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);\n  };\n  publicAPI.bindUBO = renderEncoder => {\n    renderEncoder.activateBindGroup(model.bindGroup);\n  };\n\n  // Renders myself\n  publicAPI.opaquePass = prepass => {\n    if (prepass) {\n      model.renderEncoder.begin(model._parent.getCommandEncoder());\n      publicAPI.updateUBO();\n      publicAPI.updateSSBO();\n    } else {\n      publicAPI.scissorAndViewport(model.renderEncoder);\n      publicAPI.clear();\n      model.renderEncoder.end();\n    }\n  };\n  publicAPI.clear = () => {\n    if (model.renderable.getTransparent() || model.suppressClear) {\n      return;\n    }\n    const device = model._parent.getDevice();\n    // Normal Solid Color\n    if (!model.clearFSQ) {\n      model.clearFSQ = vtkWebGPUFullScreenQuad.newInstance();\n      model.clearFSQ.setDevice(device);\n      model.clearFSQ.setPipelineHash('clearfsq');\n      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);\n      const ubo = vtkWebGPUUniformBuffer.newInstance({\n        label: 'mapperUBO'\n      });\n      ubo.addEntry('FSQMatrix', 'mat4x4<f32>');\n      ubo.addEntry('BackgroundColor', 'vec4<f32>');\n      model.clearFSQ.setUBO(ubo);\n      model.backgroundTex = model.renderable.getEnvironmentTexture();\n    }\n    // Textured Background\n    if (model.clearFSQ.getPipelineHash() !== 'clearfsqwithtexture' && model.renderable.getUseEnvironmentTextureAsBackground() && model.backgroundTex?.getImageLoaded()) {\n      model.clearFSQ.setFragmentShaderTemplate(clearFragTextureTemplate);\n      const ubo = vtkWebGPUUniformBuffer.newInstance({\n        label: 'mapperUBO'\n      });\n      ubo.addEntry('FSQMatrix', 'mat4x4<f32>');\n      ubo.addEntry('BackgroundColor', 'vec4<f32>');\n      model.clearFSQ.setUBO(ubo);\n      const environmentTextureHash = device.getTextureManager().getTextureForVTKTexture(model.backgroundTex);\n      if (environmentTextureHash.getReady()) {\n        const tview = environmentTextureHash.createView(`EnvironmentTexture`);\n        model.clearFSQ.setTextureViews([tview]);\n        model.backgroundTexLoaded = true;\n        const interpolate = model.backgroundTex.getInterpolate() ? 'linear' : 'nearest';\n        tview.addSampler(device, {\n          addressModeU: 'repeat',\n          addressModeV: 'clamp-to-edge',\n          addressModeW: 'repeat',\n          minFilter: interpolate,\n          magFilter: interpolate,\n          mipmapFilter: 'linear'\n        });\n      }\n      model.clearFSQ.setPipelineHash('clearfsqwithtexture');\n    } else if (model.clearFSQ.getPipelineHash() === 'clearfsqwithtexture' && !model.renderable.getUseEnvironmentTextureAsBackground()) {\n      // In case the mode is changed at runtime\n      model.clearFSQ = vtkWebGPUFullScreenQuad.newInstance();\n      model.clearFSQ.setDevice(device);\n      model.clearFSQ.setPipelineHash('clearfsq');\n      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);\n      const ubo = vtkWebGPUUniformBuffer.newInstance({\n        label: 'mapperUBO'\n      });\n      ubo.addEntry('FSQMatrix', 'mat4x4<f32>');\n      ubo.addEntry('BackgroundColor', 'vec4<f32>');\n      model.clearFSQ.setUBO(ubo);\n    }\n    const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);\n    const background = model.renderable.getBackgroundByReference();\n    model.clearFSQ.getUBO().setArray('BackgroundColor', background);\n    mat4.transpose(_tNormalMat4, keyMats.normalMatrix);\n    mat4.mul(_fsqClearMat4, keyMats.scvc, keyMats.pcsc);\n    mat4.mul(_fsqClearMat4, _tNormalMat4, _fsqClearMat4);\n    model.clearFSQ.getUBO().setArray('FSQMatrix', _fsqClearMat4);\n    model.clearFSQ.getUBO().sendIfNeeded(device);\n    model.clearFSQ.prepareAndDraw(model.renderEncoder);\n  };\n  publicAPI.translucentPass = prepass => {\n    if (prepass) {\n      model.renderEncoder.begin(model._parent.getCommandEncoder());\n    } else {\n      publicAPI.scissorAndViewport(model.renderEncoder);\n      model.renderEncoder.end();\n    }\n  };\n  publicAPI.volumeDepthRangePass = prepass => {\n    if (prepass) {\n      model.renderEncoder.begin(model._parent.getCommandEncoder());\n    } else {\n      publicAPI.scissorAndViewport(model.renderEncoder);\n      model.renderEncoder.end();\n    }\n  };\n  publicAPI.getAspectRatio = () => {\n    const size = model._parent.getSizeByReference();\n    const viewport = model.renderable.getViewportByReference();\n    return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);\n  };\n  publicAPI.convertToOpenGLDepth = val => model.webgpuCamera.convertToOpenGLDepth(val);\n  publicAPI.getYInvertedTiledSizeAndOrigin = () => {\n    const res = publicAPI.getTiledSizeAndOrigin();\n    const size = model._parent.getSizeByReference();\n    res.lowerLeftV = size[1] - res.vsize - res.lowerLeftV;\n    return res;\n  };\n  publicAPI.getTiledSizeAndOrigin = () => {\n    const vport = model.renderable.getViewportByReference();\n\n    // if there is no window assume 0 1\n    const tileViewPort = [0.0, 0.0, 1.0, 1.0];\n\n    // find the lower left corner of the viewport, taking into account the\n    // lower left boundary of this tile\n    const vpu = vport[0] - tileViewPort[0];\n    const vpv = vport[1] - tileViewPort[1];\n\n    // store the result as a pixel value\n    const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);\n    const lowerLeftU = Math.round(ndvp[0]);\n    const lowerLeftV = Math.round(ndvp[1]);\n\n    // find the upper right corner of the viewport, taking into account the\n    // lower left boundary of this tile\n    const vpu2 = vport[2] - tileViewPort[0];\n    const vpv2 = vport[3] - tileViewPort[1];\n    const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);\n\n    // now compute the size of the intersection of the viewport with the\n    // current tile\n    let usize = Math.round(ndvp2[0]) - lowerLeftU;\n    let vsize = Math.round(ndvp2[1]) - lowerLeftV;\n    if (usize < 0) {\n      usize = 0;\n    }\n    if (vsize < 0) {\n      vsize = 0;\n    }\n    return {\n      usize,\n      vsize,\n      lowerLeftU,\n      lowerLeftV\n    };\n  };\n  publicAPI.getPropFromID = id => {\n    for (let i = 0; i < model.children.length; i++) {\n      const res = model.children[i].getPropID ? model.children[i].getPropID() : -1;\n      if (res === id) {\n        return model.children[i];\n      }\n    }\n    return null;\n  };\n  publicAPI.getStabilizedTime = () => model.stabilizedTime.getMTime();\n  publicAPI.releaseGraphicsResources = () => {\n    if (model.selector !== null) {\n      model.selector.releaseGraphicsResources();\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  bindGroup: null,\n  selector: null,\n  renderEncoder: null,\n  recenterThreshold: 20.0,\n  suppressClear: false,\n  stabilizedCenter: [0.0, 0.0, 0.0]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n\n  // UBO\n  model.UBO = vtkWebGPUUniformBuffer.newInstance({\n    label: 'rendererUBO'\n  });\n  model.UBO.addEntry('WCVCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('SCPCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('PCSCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('SCVCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('VCPCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('WCVCNormals', 'mat4x4<f32>');\n  model.UBO.addEntry('viewportSize', 'vec2<f32>');\n  model.UBO.addEntry('LightCount', 'i32');\n  model.UBO.addEntry('MaxEnvironmentMipLevel', 'f32');\n  model.UBO.addEntry('BackgroundDiffuseStrength', 'f32');\n  model.UBO.addEntry('BackgroundSpecularStrength', 'f32');\n  model.UBO.addEntry('cameraParallel', 'u32');\n\n  // SSBO (Light data)\n  model.SSBO = vtkWebGPUStorageBuffer.newInstance({\n    label: 'rendererLightSSBO'\n  });\n  model.lightTimeString = '';\n  model.bindGroup = vtkWebGPUBindGroup.newInstance({\n    label: 'rendererBG'\n  });\n  model.bindGroup.setBindables([model.UBO, model.SSBO]);\n  model.tmpMat4 = mat4.identity(new Float64Array(16));\n  model.stabilizedTime = {};\n  obj(model.stabilizedTime, {\n    mtime: 0\n  });\n\n  // Build VTK API\n  get(publicAPI, model, ['bindGroup', 'stabilizedTime']);\n  getArray(publicAPI, model, ['stabilizedCenter']);\n  setGet(publicAPI, model, ['renderEncoder', 'selector', 'suppressClear', 'UBO']);\n\n  // Object methods\n  vtkWebGPURenderer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkWebGPURenderer');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\n// Register ourself to WebGPU backend if imported\nregisterOverride('vtkRenderer', newInstance);\n\nexport { index as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}