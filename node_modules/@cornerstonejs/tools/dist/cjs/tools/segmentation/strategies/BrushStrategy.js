"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@cornerstonejs/core");
const triggerSegmentationEvents_1 = require("../../../stateManagement/segmentation/triggerSegmentationEvents");
const compositions_1 = __importDefault(require("./compositions"));
const getStrategyData_1 = require("./utils/getStrategyData");
const enums_1 = require("../../../enums");
const { VoxelManager } = core_1.utilities;
class BrushStrategy {
    constructor(name, ...initializers) {
        this._initialize = [];
        this._fill = [];
        this._onInteractionStart = [];
        this.fill = (enabledElement, operationData) => {
            const initializedData = this.initialize(enabledElement, operationData, enums_1.StrategyCallbacks.Fill);
            if (!initializedData) {
                return;
            }
            const { strategySpecificConfiguration = {}, centerIJK } = initializedData;
            if (core_1.utilities.isEqual(centerIJK, strategySpecificConfiguration.centerIJK)) {
                return operationData.preview;
            }
            else {
                strategySpecificConfiguration.centerIJK = centerIJK;
            }
            this._fill.forEach((func) => func(initializedData));
            const { segmentationVoxelManager, previewVoxelManager, previewSegmentIndex, } = initializedData;
            (0, triggerSegmentationEvents_1.triggerSegmentationDataModified)(initializedData.segmentationId, segmentationVoxelManager.getArrayOfSlices());
            if (!previewSegmentIndex || !previewVoxelManager.modifiedSlices.size) {
                return null;
            }
            return initializedData.preview || initializedData;
        };
        this.onInteractionStart = (enabledElement, operationData) => {
            const { preview } = operationData;
            if (preview === null || preview === void 0 ? void 0 : preview.isPreviewFromHover) {
                preview.isPreviewFromHover = false;
                return;
            }
            const initializedData = this.initialize(enabledElement, operationData);
            if (!initializedData) {
                return;
            }
            this._onInteractionStart.forEach((func) => func.call(this, initializedData));
        };
        this.configurationName = name;
        this.compositions = initializers;
        initializers.forEach((initializer) => {
            const result = typeof initializer === 'function' ? initializer() : initializer;
            if (!result) {
                return;
            }
            for (const key in result) {
                if (!BrushStrategy.childFunctions[key]) {
                    throw new Error(`Didn't find ${key} as a brush strategy`);
                }
                BrushStrategy.childFunctions[key](this, result[key]);
            }
        });
        this.strategyFunction = (enabledElement, operationData) => this.fill(enabledElement, operationData);
        for (const key of Object.keys(BrushStrategy.childFunctions)) {
            this.strategyFunction[key] = this[key];
        }
    }
    initialize(enabledElement, operationData, operationName) {
        var _a;
        const { viewport } = enabledElement;
        const data = (0, getStrategyData_1.getStrategyData)({ operationData, viewport });
        if (!data) {
            console.warn('No data found for BrushStrategy');
            return operationData.preview;
        }
        const { imageVoxelManager, segmentationVoxelManager, segmentationImageData, } = data;
        const previewVoxelManager = ((_a = operationData.preview) === null || _a === void 0 ? void 0 : _a.previewVoxelManager) ||
            VoxelManager.createHistoryVoxelManager(segmentationVoxelManager);
        const previewEnabled = !!operationData.previewColors;
        const previewSegmentIndex = previewEnabled ? 255 : undefined;
        const initializedData = Object.assign(Object.assign({ operationName,
            previewSegmentIndex }, operationData), { enabledElement,
            imageVoxelManager,
            segmentationVoxelManager,
            segmentationImageData,
            previewVoxelManager,
            viewport, centerWorld: null, brushStrategy: this });
        this._initialize.forEach((func) => func(initializedData));
        return initializedData;
    }
}
exports.default = BrushStrategy;
BrushStrategy.COMPOSITIONS = compositions_1.default;
BrushStrategy.childFunctions = {
    [enums_1.StrategyCallbacks.OnInteractionStart]: addListMethod(enums_1.StrategyCallbacks.OnInteractionStart, enums_1.StrategyCallbacks.Initialize),
    [enums_1.StrategyCallbacks.OnInteractionEnd]: addListMethod(enums_1.StrategyCallbacks.OnInteractionEnd, enums_1.StrategyCallbacks.Initialize),
    [enums_1.StrategyCallbacks.Fill]: addListMethod(enums_1.StrategyCallbacks.Fill),
    [enums_1.StrategyCallbacks.Initialize]: addListMethod(enums_1.StrategyCallbacks.Initialize),
    [enums_1.StrategyCallbacks.CreateIsInThreshold]: addSingletonMethod(enums_1.StrategyCallbacks.CreateIsInThreshold),
    [enums_1.StrategyCallbacks.AcceptPreview]: addListMethod(enums_1.StrategyCallbacks.AcceptPreview, enums_1.StrategyCallbacks.Initialize),
    [enums_1.StrategyCallbacks.RejectPreview]: addListMethod(enums_1.StrategyCallbacks.RejectPreview, enums_1.StrategyCallbacks.Initialize),
    [enums_1.StrategyCallbacks.INTERNAL_setValue]: addSingletonMethod(enums_1.StrategyCallbacks.INTERNAL_setValue),
    [enums_1.StrategyCallbacks.Preview]: addSingletonMethod(enums_1.StrategyCallbacks.Preview, false),
    [enums_1.StrategyCallbacks.ComputeInnerCircleRadius]: addListMethod(enums_1.StrategyCallbacks.ComputeInnerCircleRadius),
    compositions: null,
};
function addListMethod(name, createInitialized) {
    const listName = `_${name}`;
    return (brushStrategy, func) => {
        brushStrategy[listName] || (brushStrategy[listName] = []);
        brushStrategy[listName].push(func);
        brushStrategy[name] || (brushStrategy[name] = createInitialized
            ? (enabledElement, operationData) => {
                const initializedData = brushStrategy[createInitialized](enabledElement, operationData, name);
                brushStrategy[listName].forEach((func) => func.call(brushStrategy, initializedData));
            }
            : (operationData) => {
                brushStrategy[listName].forEach((func) => func.call(brushStrategy, operationData));
            });
    };
}
function addSingletonMethod(name, isInitialized = true) {
    return (brushStrategy, func) => {
        if (brushStrategy[name]) {
            throw new Error(`The singleton method ${name} already exists`);
        }
        brushStrategy[name] = isInitialized
            ? func
            : (enabledElement, operationData) => {
                operationData.enabledElement = enabledElement;
                return func.call(brushStrategy, operationData);
            };
    };
}
//# sourceMappingURL=BrushStrategy.js.map