{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkShader from './Shader.js';\nconst {\n  vtkErrorMacro\n} = macro;\n\n// perform in place string substitutions, indicate if a substitution was done\n// this is useful for building up shader strings which typically involve\n// lots of string substitutions. Return true if a substitution was done.\nfunction substitute(source, search, replace, all) {\n  // We only accept strings or array of strings, typeof is faster than Array.isArray\n  const replaceStr = typeof replace === 'string' ? replace : replace.join('\\n');\n\n  // We don't need to instantiate a RegExp if we don't want a global substitution.\n  // In all other cases, we need to take the provided string or RegExp and\n  // instantiate a new one to add the `g` flag.\n  // Argument defaults are transpiled to slow `arguments`-based operations\n  // better assume undefined as flag to know if the value is set or not\n  const replaceSearch = all === false ? search : new RegExp(search, 'g');\n  const resultstr = source.replace(replaceSearch, replaceStr);\n  return {\n    // If the result is different than the input, we did perform a replacement\n    replace: resultstr !== replaceStr,\n    result: resultstr\n  };\n}\n\n// ----------------------------------------------------------------------------\n// vtkShaderProgram methods\n// ----------------------------------------------------------------------------\n\nfunction vtkShaderProgram(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkShaderProgram');\n  publicAPI.compileShader = () => {\n    if (!model.vertexShader.compile()) {\n      vtkErrorMacro(model.vertexShader.getSource().split('\\n').map((line, index) => `${index}: ${line}`).join('\\n'));\n      vtkErrorMacro(model.vertexShader.getError());\n      return 0;\n    }\n    if (!model.fragmentShader.compile()) {\n      vtkErrorMacro(model.fragmentShader.getSource().split('\\n').map((line, index) => `${index}: ${line}`).join('\\n'));\n      vtkErrorMacro(model.fragmentShader.getError());\n      return 0;\n    }\n    // skip geometry for now\n    if (!publicAPI.attachShader(model.vertexShader)) {\n      vtkErrorMacro(model.error);\n      return 0;\n    }\n    if (!publicAPI.attachShader(model.fragmentShader)) {\n      vtkErrorMacro(model.error);\n      return 0;\n    }\n    if (!publicAPI.link()) {\n      vtkErrorMacro(`Links failed: ${model.error}`);\n      return 0;\n    }\n    publicAPI.setCompiled(true);\n    return 1;\n  };\n  publicAPI.cleanup = () => {\n    if (model.shaderType === 'Unknown' || model.handle === 0) {\n      return;\n    }\n    publicAPI.release();\n    if (model.vertexShaderHandle !== 0) {\n      model.context.detachShader(model.handle, model.vertexShaderHandle);\n      model.vertexShaderHandle = 0;\n    }\n    if (model.fragmentShaderHandle !== 0) {\n      model.context.detachShader(model.handle, model.fragmentShaderHandle);\n      model.fragmentShaderHandle = 0;\n    }\n    model.context.deleteProgram(model.handle);\n    model.handle = 0;\n    publicAPI.setCompiled(false);\n  };\n  publicAPI.bind = () => {\n    if (!model.linked && !publicAPI.link()) {\n      return false;\n    }\n    model.context.useProgram(model.handle);\n    publicAPI.setBound(true);\n    return true;\n  };\n  publicAPI.isBound = () => !!model.bound;\n  publicAPI.release = () => {\n    model.context.useProgram(null);\n    publicAPI.setBound(false);\n  };\n  publicAPI.setContext = ctx => {\n    model.vertexShader.setContext(ctx);\n    model.fragmentShader.setContext(ctx);\n    model.geometryShader.setContext(ctx);\n  };\n  publicAPI.link = () => {\n    if (model.linked) {\n      return true;\n    }\n    if (model.handle === 0) {\n      model.error = 'Program has not been initialized, and/or does not have shaders.';\n      return false;\n    }\n\n    // clear out the list of uniforms used\n    model.uniformLocs = {};\n    model.context.linkProgram(model.handle);\n    const isCompiled = model.context.getProgramParameter(model.handle, model.context.LINK_STATUS);\n    if (!isCompiled) {\n      const lastError = model.context.getProgramInfoLog(model.handle);\n      vtkErrorMacro(`Error linking shader ${lastError}`);\n      model.handle = 0;\n      return false;\n    }\n    publicAPI.setLinked(true);\n    model.attributeLocs = {};\n    return true;\n  };\n  publicAPI.setUniformMatrix = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    const f32 = new Float32Array(v);\n    model.context.uniformMatrix4fv(location, false, f32);\n    return true;\n  };\n  publicAPI.setUniformMatrix3x3 = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    const f32 = new Float32Array(v);\n    model.context.uniformMatrix3fv(location, false, f32);\n    return true;\n  };\n  publicAPI.setUniformf = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform1f(location, v);\n    return true;\n  };\n  publicAPI.setUniformfv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform1fv(location, v);\n    return true;\n  };\n  publicAPI.setUniformi = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform1i(location, v);\n    return true;\n  };\n  publicAPI.setUniformiv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform1iv(location, v);\n    return true;\n  };\n  publicAPI.setUniform2f = (name, v1, v2) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    if (v2 === undefined) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform2f(location, v1, v2);\n    return true;\n  };\n  publicAPI.setUniform2fv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform2fv(location, v);\n    return true;\n  };\n  publicAPI.setUniform2i = (name, v1, v2) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    if (v2 === undefined) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform2i(location, v1, v2);\n    return true;\n  };\n  publicAPI.setUniform2iv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform2iv(location, v);\n    return true;\n  };\n  publicAPI.setUniform3f = (name, a1, a2, a3) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    if (a3 === undefined) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform3f(location, a1, a2, a3);\n    return true;\n  };\n  publicAPI.setUniform3fArray = (name, a) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    if (!Array.isArray(a) || a.length !== 3) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform3f(location, a[0], a[1], a[2]);\n    return true;\n  };\n  publicAPI.setUniform3fv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform3fv(location, v);\n    return true;\n  };\n  publicAPI.setUniform3i = function (name) {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    let array = args;\n    // allow an array passed as a single argument\n    if (array.length === 1 && Array.isArray(array[0])) {\n      array = array[0];\n    }\n    if (array.length !== 3) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform3i(location, array[0], array[1], array[2]);\n    return true;\n  };\n  publicAPI.setUniform3iv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform3iv(location, v);\n    return true;\n  };\n  publicAPI.setUniform4f = function (name) {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    let array = args;\n    // allow an array passed as a single argument\n    if (array.length === 1 && Array.isArray(array[0])) {\n      array = array[0];\n    }\n    if (array.length !== 4) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform4f(location, array[0], array[1], array[2], array[3]);\n    return true;\n  };\n  publicAPI.setUniform4fv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform4fv(location, v);\n    return true;\n  };\n  publicAPI.setUniform4i = function (name) {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    let array = args;\n    // allow an array passed as a single argument\n    if (array.length === 1 && Array.isArray(array[0])) {\n      array = array[0];\n    }\n    if (array.length !== 4) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform4i(location, array[0], array[1], array[2], array[3]);\n    return true;\n  };\n  publicAPI.setUniform4iv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform4iv(location, v);\n    return true;\n  };\n  publicAPI.findUniform = name => {\n    if (!name || !model.linked) {\n      return -1;\n    }\n\n    // see if we have cached the result\n    let loc = model.uniformLocs[name];\n    if (loc !== undefined) {\n      return loc;\n    }\n    loc = model.context.getUniformLocation(model.handle, name);\n    if (loc === null) {\n      model.error = `Uniform ${name} not found in current shader program.`;\n      model.uniformLocs[name] = -1;\n      return -1;\n    }\n    model.uniformLocs[name] = loc;\n    return loc;\n  };\n  publicAPI.isUniformUsed = name => {\n    if (!name) {\n      return false;\n    }\n\n    // see if we have cached the result\n    let loc = model.uniformLocs[name];\n    if (loc !== undefined) {\n      return loc !== null;\n    }\n    if (!model.linked) {\n      vtkErrorMacro('attempt to find uniform when the shader program is not linked');\n      return false;\n    }\n    loc = model.context.getUniformLocation(model.handle, name);\n    model.uniformLocs[name] = loc;\n    if (loc === null) {\n      return false;\n    }\n    return true;\n  };\n  publicAPI.isAttributeUsed = name => {\n    if (!name) {\n      return false;\n    }\n\n    // see if we have cached the result\n    if (name in model.attributeLocs) {\n      return true;\n    }\n    if (!model.linked) {\n      vtkErrorMacro('attempt to find uniform when the shader program is not linked');\n      return false;\n    }\n    const loc = model.context.getAttribLocation(model.handle, name);\n    if (loc === -1) {\n      return false;\n    }\n    model.attributeLocs[name] = loc;\n    return true;\n  };\n  publicAPI.attachShader = shader => {\n    if (shader.getHandle() === 0) {\n      model.error = 'Shader object was not initialized, cannot attach it.';\n      return false;\n    }\n    if (shader.getShaderType() === 'Unknown') {\n      model.error = 'Shader object is of type Unknown and cannot be used.';\n      return false;\n    }\n    if (model.handle === 0) {\n      const thandle = model.context.createProgram();\n      if (thandle === 0) {\n        model.error = 'Could not create shader program.';\n        return false;\n      }\n      model.handle = thandle;\n      model.linked = false;\n    }\n    if (shader.getShaderType() === 'Vertex') {\n      if (model.vertexShaderHandle !== 0) {\n        model.context.detachShader(model.handle, model.vertexShaderHandle);\n      }\n      model.vertexShaderHandle = shader.getHandle();\n    }\n    if (shader.getShaderType() === 'Fragment') {\n      if (model.fragmentShaderHandle !== 0) {\n        model.context.detachShader(model.handle, model.fragmentShaderHandle);\n      }\n      model.fragmentShaderHandle = shader.getHandle();\n    }\n    model.context.attachShader(model.handle, shader.getHandle());\n    publicAPI.setLinked(false);\n    return true;\n  };\n  publicAPI.detachShader = shader => {\n    if (shader.getHandle() === 0) {\n      model.error = 'shader object was not initialized, cannot attach it.';\n      return false;\n    }\n    if (shader.getShaderType() === 'Unknown') {\n      model.error = 'Shader object is of type Unknown and cannot be used.';\n      return false;\n    }\n    if (model.handle === 0) {\n      model.error = 'This shader program has not been initialized yet.';\n    }\n    switch (shader.getShaderType()) {\n      case 'Vertex':\n        if (model.vertexShaderHandle !== shader.getHandle()) {\n          model.error = 'The supplied shader was not attached to this program.';\n          return false;\n        }\n        model.context.detachShader(model.handle, shader.getHandle());\n        model.vertexShaderHandle = 0;\n        model.linked = false;\n        return true;\n      case 'Fragment':\n        if (model.fragmentShaderHandle !== shader.getHandle()) {\n          model.error = 'The supplied shader was not attached to this program.';\n          return false;\n        }\n        model.context.detachShader(model.handle, shader.getHandle());\n        model.fragmentShaderHandle = 0;\n        model.linked = false;\n        return true;\n      default:\n        return false;\n    }\n  };\n  publicAPI.setContext = ctx => {\n    model.context = ctx;\n    model.vertexShader.setContext(ctx);\n    model.fragmentShader.setContext(ctx);\n    model.geometryShader.setContext(ctx);\n  };\n  publicAPI.setLastCameraMTime = mtime => {\n    model.lastCameraMTime = mtime;\n  };\n\n  // publicAPI.enableAttributeArray = (name) => {\n  //   const location = publicAPI.findAttributeArray(name);\n  //   if (location === -1) {\n  //     model.error = `Could not enable attribute ${name} No such attribute.`;\n  //     return false;\n  //   }\n  //   model.context.enableVertexAttribArray(location);\n  //   return true;\n  // };\n\n  // publicAPI.disableAttributeArray = (name) => {\n  //   const location = publicAPI.findAttributeArray(name);\n  //   if (location === -1) {\n  //     model.error = `Could not enable attribute ${name} No such attribute.`;\n  //     return false;\n  //   }\n  //   model.context.disableVertexAttribArray(location);\n  //   return true;\n  // };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  vertexShaderHandle: 0,\n  fragmentShaderHandle: 0,\n  geometryShaderHandle: 0,\n  vertexShader: null,\n  fragmentShader: null,\n  geometryShader: null,\n  linked: false,\n  bound: false,\n  compiled: false,\n  error: '',\n  handle: 0,\n  numberOfOutputs: 0,\n  attributesLocs: null,\n  uniformLocs: null,\n  md5Hash: 0,\n  context: null,\n  lastCameraMTime: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Instantiate internal objects\n  model.attributesLocs = {};\n  model.uniformLocs = {};\n  model.vertexShader = vtkShader.newInstance();\n  model.vertexShader.setShaderType('Vertex');\n  model.fragmentShader = vtkShader.newInstance();\n  model.fragmentShader.setShaderType('Fragment');\n  model.geometryShader = vtkShader.newInstance();\n  model.geometryShader.setShaderType('Geometry');\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['lastCameraMTime']);\n  macro.setGet(publicAPI, model, ['error', 'handle', 'compiled', 'bound', 'md5Hash', 'vertexShader', 'fragmentShader', 'geometryShader', 'linked']);\n\n  // Object methods\n  vtkShaderProgram(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkShaderProgram');\n\n// ----------------------------------------------------------------------------\n\nvar vtkShaderProgram$1 = {\n  newInstance,\n  extend,\n  substitute\n};\nexport { vtkShaderProgram$1 as default, substitute };","map":{"version":3,"names":["m","macro","vtkShader","vtkErrorMacro","substitute","source","search","replace","all","replaceStr","join","replaceSearch","RegExp","resultstr","result","vtkShaderProgram","publicAPI","model","classHierarchy","push","compileShader","vertexShader","compile","getSource","split","map","line","index","getError","fragmentShader","attachShader","error","link","setCompiled","cleanup","shaderType","handle","release","vertexShaderHandle","context","detachShader","fragmentShaderHandle","deleteProgram","bind","linked","useProgram","setBound","isBound","bound","setContext","ctx","geometryShader","uniformLocs","linkProgram","isCompiled","getProgramParameter","LINK_STATUS","lastError","getProgramInfoLog","setLinked","attributeLocs","setUniformMatrix","name","v","location","findUniform","f32","Float32Array","uniformMatrix4fv","setUniformMatrix3x3","uniformMatrix3fv","setUniformf","uniform1f","setUniformfv","uniform1fv","setUniformi","uniform1i","setUniformiv","uniform1iv","setUniform2f","v1","v2","undefined","RangeError","uniform2f","setUniform2fv","uniform2fv","setUniform2i","uniform2i","setUniform2iv","uniform2iv","setUniform3f","a1","a2","a3","uniform3f","setUniform3fArray","a","Array","isArray","length","setUniform3fv","uniform3fv","setUniform3i","_len","arguments","args","_key","array","uniform3i","setUniform3iv","uniform3iv","setUniform4f","_len2","_key2","uniform4f","setUniform4fv","uniform4fv","setUniform4i","_len3","_key3","uniform4i","setUniform4iv","uniform4iv","loc","getUniformLocation","isUniformUsed","isAttributeUsed","getAttribLocation","shader","getHandle","getShaderType","thandle","createProgram","setLastCameraMTime","mtime","lastCameraMTime","DEFAULT_VALUES","geometryShaderHandle","compiled","numberOfOutputs","attributesLocs","md5Hash","extend","initialValues","Object","assign","newInstance","setShaderType","obj","get","setGet","vtkShaderProgram$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkShader from './Shader.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// perform in place string substitutions, indicate if a substitution was done\n// this is useful for building up shader strings which typically involve\n// lots of string substitutions. Return true if a substitution was done.\nfunction substitute(source, search, replace, all) {\n  // We only accept strings or array of strings, typeof is faster than Array.isArray\n  const replaceStr = typeof replace === 'string' ? replace : replace.join('\\n');\n\n  // We don't need to instantiate a RegExp if we don't want a global substitution.\n  // In all other cases, we need to take the provided string or RegExp and\n  // instantiate a new one to add the `g` flag.\n  // Argument defaults are transpiled to slow `arguments`-based operations\n  // better assume undefined as flag to know if the value is set or not\n  const replaceSearch = all === false ? search : new RegExp(search, 'g');\n  const resultstr = source.replace(replaceSearch, replaceStr);\n  return {\n    // If the result is different than the input, we did perform a replacement\n    replace: resultstr !== replaceStr,\n    result: resultstr\n  };\n}\n\n// ----------------------------------------------------------------------------\n// vtkShaderProgram methods\n// ----------------------------------------------------------------------------\n\nfunction vtkShaderProgram(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkShaderProgram');\n  publicAPI.compileShader = () => {\n    if (!model.vertexShader.compile()) {\n      vtkErrorMacro(model.vertexShader.getSource().split('\\n').map((line, index) => `${index}: ${line}`).join('\\n'));\n      vtkErrorMacro(model.vertexShader.getError());\n      return 0;\n    }\n    if (!model.fragmentShader.compile()) {\n      vtkErrorMacro(model.fragmentShader.getSource().split('\\n').map((line, index) => `${index}: ${line}`).join('\\n'));\n      vtkErrorMacro(model.fragmentShader.getError());\n      return 0;\n    }\n    // skip geometry for now\n    if (!publicAPI.attachShader(model.vertexShader)) {\n      vtkErrorMacro(model.error);\n      return 0;\n    }\n    if (!publicAPI.attachShader(model.fragmentShader)) {\n      vtkErrorMacro(model.error);\n      return 0;\n    }\n    if (!publicAPI.link()) {\n      vtkErrorMacro(`Links failed: ${model.error}`);\n      return 0;\n    }\n    publicAPI.setCompiled(true);\n    return 1;\n  };\n  publicAPI.cleanup = () => {\n    if (model.shaderType === 'Unknown' || model.handle === 0) {\n      return;\n    }\n    publicAPI.release();\n    if (model.vertexShaderHandle !== 0) {\n      model.context.detachShader(model.handle, model.vertexShaderHandle);\n      model.vertexShaderHandle = 0;\n    }\n    if (model.fragmentShaderHandle !== 0) {\n      model.context.detachShader(model.handle, model.fragmentShaderHandle);\n      model.fragmentShaderHandle = 0;\n    }\n    model.context.deleteProgram(model.handle);\n    model.handle = 0;\n    publicAPI.setCompiled(false);\n  };\n  publicAPI.bind = () => {\n    if (!model.linked && !publicAPI.link()) {\n      return false;\n    }\n    model.context.useProgram(model.handle);\n    publicAPI.setBound(true);\n    return true;\n  };\n  publicAPI.isBound = () => !!model.bound;\n  publicAPI.release = () => {\n    model.context.useProgram(null);\n    publicAPI.setBound(false);\n  };\n  publicAPI.setContext = ctx => {\n    model.vertexShader.setContext(ctx);\n    model.fragmentShader.setContext(ctx);\n    model.geometryShader.setContext(ctx);\n  };\n  publicAPI.link = () => {\n    if (model.linked) {\n      return true;\n    }\n    if (model.handle === 0) {\n      model.error = 'Program has not been initialized, and/or does not have shaders.';\n      return false;\n    }\n\n    // clear out the list of uniforms used\n    model.uniformLocs = {};\n    model.context.linkProgram(model.handle);\n    const isCompiled = model.context.getProgramParameter(model.handle, model.context.LINK_STATUS);\n    if (!isCompiled) {\n      const lastError = model.context.getProgramInfoLog(model.handle);\n      vtkErrorMacro(`Error linking shader ${lastError}`);\n      model.handle = 0;\n      return false;\n    }\n    publicAPI.setLinked(true);\n    model.attributeLocs = {};\n    return true;\n  };\n  publicAPI.setUniformMatrix = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    const f32 = new Float32Array(v);\n    model.context.uniformMatrix4fv(location, false, f32);\n    return true;\n  };\n  publicAPI.setUniformMatrix3x3 = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    const f32 = new Float32Array(v);\n    model.context.uniformMatrix3fv(location, false, f32);\n    return true;\n  };\n  publicAPI.setUniformf = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform1f(location, v);\n    return true;\n  };\n  publicAPI.setUniformfv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform1fv(location, v);\n    return true;\n  };\n  publicAPI.setUniformi = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform1i(location, v);\n    return true;\n  };\n  publicAPI.setUniformiv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform1iv(location, v);\n    return true;\n  };\n  publicAPI.setUniform2f = (name, v1, v2) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    if (v2 === undefined) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform2f(location, v1, v2);\n    return true;\n  };\n  publicAPI.setUniform2fv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform2fv(location, v);\n    return true;\n  };\n  publicAPI.setUniform2i = (name, v1, v2) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    if (v2 === undefined) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform2i(location, v1, v2);\n    return true;\n  };\n  publicAPI.setUniform2iv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform2iv(location, v);\n    return true;\n  };\n  publicAPI.setUniform3f = (name, a1, a2, a3) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    if (a3 === undefined) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform3f(location, a1, a2, a3);\n    return true;\n  };\n  publicAPI.setUniform3fArray = (name, a) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    if (!Array.isArray(a) || a.length !== 3) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform3f(location, a[0], a[1], a[2]);\n    return true;\n  };\n  publicAPI.setUniform3fv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform3fv(location, v);\n    return true;\n  };\n  publicAPI.setUniform3i = function (name) {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    let array = args;\n    // allow an array passed as a single argument\n    if (array.length === 1 && Array.isArray(array[0])) {\n      array = array[0];\n    }\n    if (array.length !== 3) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform3i(location, array[0], array[1], array[2]);\n    return true;\n  };\n  publicAPI.setUniform3iv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform3iv(location, v);\n    return true;\n  };\n  publicAPI.setUniform4f = function (name) {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    let array = args;\n    // allow an array passed as a single argument\n    if (array.length === 1 && Array.isArray(array[0])) {\n      array = array[0];\n    }\n    if (array.length !== 4) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform4f(location, array[0], array[1], array[2], array[3]);\n    return true;\n  };\n  publicAPI.setUniform4fv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform4fv(location, v);\n    return true;\n  };\n  publicAPI.setUniform4i = function (name) {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    let array = args;\n    // allow an array passed as a single argument\n    if (array.length === 1 && Array.isArray(array[0])) {\n      array = array[0];\n    }\n    if (array.length !== 4) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform4i(location, array[0], array[1], array[2], array[3]);\n    return true;\n  };\n  publicAPI.setUniform4iv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform4iv(location, v);\n    return true;\n  };\n  publicAPI.findUniform = name => {\n    if (!name || !model.linked) {\n      return -1;\n    }\n\n    // see if we have cached the result\n    let loc = model.uniformLocs[name];\n    if (loc !== undefined) {\n      return loc;\n    }\n    loc = model.context.getUniformLocation(model.handle, name);\n    if (loc === null) {\n      model.error = `Uniform ${name} not found in current shader program.`;\n      model.uniformLocs[name] = -1;\n      return -1;\n    }\n    model.uniformLocs[name] = loc;\n    return loc;\n  };\n  publicAPI.isUniformUsed = name => {\n    if (!name) {\n      return false;\n    }\n\n    // see if we have cached the result\n    let loc = model.uniformLocs[name];\n    if (loc !== undefined) {\n      return loc !== null;\n    }\n    if (!model.linked) {\n      vtkErrorMacro('attempt to find uniform when the shader program is not linked');\n      return false;\n    }\n    loc = model.context.getUniformLocation(model.handle, name);\n    model.uniformLocs[name] = loc;\n    if (loc === null) {\n      return false;\n    }\n    return true;\n  };\n  publicAPI.isAttributeUsed = name => {\n    if (!name) {\n      return false;\n    }\n\n    // see if we have cached the result\n    if (name in model.attributeLocs) {\n      return true;\n    }\n    if (!model.linked) {\n      vtkErrorMacro('attempt to find uniform when the shader program is not linked');\n      return false;\n    }\n    const loc = model.context.getAttribLocation(model.handle, name);\n    if (loc === -1) {\n      return false;\n    }\n    model.attributeLocs[name] = loc;\n    return true;\n  };\n  publicAPI.attachShader = shader => {\n    if (shader.getHandle() === 0) {\n      model.error = 'Shader object was not initialized, cannot attach it.';\n      return false;\n    }\n    if (shader.getShaderType() === 'Unknown') {\n      model.error = 'Shader object is of type Unknown and cannot be used.';\n      return false;\n    }\n    if (model.handle === 0) {\n      const thandle = model.context.createProgram();\n      if (thandle === 0) {\n        model.error = 'Could not create shader program.';\n        return false;\n      }\n      model.handle = thandle;\n      model.linked = false;\n    }\n    if (shader.getShaderType() === 'Vertex') {\n      if (model.vertexShaderHandle !== 0) {\n        model.context.detachShader(model.handle, model.vertexShaderHandle);\n      }\n      model.vertexShaderHandle = shader.getHandle();\n    }\n    if (shader.getShaderType() === 'Fragment') {\n      if (model.fragmentShaderHandle !== 0) {\n        model.context.detachShader(model.handle, model.fragmentShaderHandle);\n      }\n      model.fragmentShaderHandle = shader.getHandle();\n    }\n    model.context.attachShader(model.handle, shader.getHandle());\n    publicAPI.setLinked(false);\n    return true;\n  };\n  publicAPI.detachShader = shader => {\n    if (shader.getHandle() === 0) {\n      model.error = 'shader object was not initialized, cannot attach it.';\n      return false;\n    }\n    if (shader.getShaderType() === 'Unknown') {\n      model.error = 'Shader object is of type Unknown and cannot be used.';\n      return false;\n    }\n    if (model.handle === 0) {\n      model.error = 'This shader program has not been initialized yet.';\n    }\n    switch (shader.getShaderType()) {\n      case 'Vertex':\n        if (model.vertexShaderHandle !== shader.getHandle()) {\n          model.error = 'The supplied shader was not attached to this program.';\n          return false;\n        }\n        model.context.detachShader(model.handle, shader.getHandle());\n        model.vertexShaderHandle = 0;\n        model.linked = false;\n        return true;\n      case 'Fragment':\n        if (model.fragmentShaderHandle !== shader.getHandle()) {\n          model.error = 'The supplied shader was not attached to this program.';\n          return false;\n        }\n        model.context.detachShader(model.handle, shader.getHandle());\n        model.fragmentShaderHandle = 0;\n        model.linked = false;\n        return true;\n      default:\n        return false;\n    }\n  };\n  publicAPI.setContext = ctx => {\n    model.context = ctx;\n    model.vertexShader.setContext(ctx);\n    model.fragmentShader.setContext(ctx);\n    model.geometryShader.setContext(ctx);\n  };\n  publicAPI.setLastCameraMTime = mtime => {\n    model.lastCameraMTime = mtime;\n  };\n\n  // publicAPI.enableAttributeArray = (name) => {\n  //   const location = publicAPI.findAttributeArray(name);\n  //   if (location === -1) {\n  //     model.error = `Could not enable attribute ${name} No such attribute.`;\n  //     return false;\n  //   }\n  //   model.context.enableVertexAttribArray(location);\n  //   return true;\n  // };\n\n  // publicAPI.disableAttributeArray = (name) => {\n  //   const location = publicAPI.findAttributeArray(name);\n  //   if (location === -1) {\n  //     model.error = `Could not enable attribute ${name} No such attribute.`;\n  //     return false;\n  //   }\n  //   model.context.disableVertexAttribArray(location);\n  //   return true;\n  // };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  vertexShaderHandle: 0,\n  fragmentShaderHandle: 0,\n  geometryShaderHandle: 0,\n  vertexShader: null,\n  fragmentShader: null,\n  geometryShader: null,\n  linked: false,\n  bound: false,\n  compiled: false,\n  error: '',\n  handle: 0,\n  numberOfOutputs: 0,\n  attributesLocs: null,\n  uniformLocs: null,\n  md5Hash: 0,\n  context: null,\n  lastCameraMTime: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Instantiate internal objects\n  model.attributesLocs = {};\n  model.uniformLocs = {};\n  model.vertexShader = vtkShader.newInstance();\n  model.vertexShader.setShaderType('Vertex');\n  model.fragmentShader = vtkShader.newInstance();\n  model.fragmentShader.setShaderType('Fragment');\n  model.geometryShader = vtkShader.newInstance();\n  model.geometryShader.setShaderType('Geometry');\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['lastCameraMTime']);\n  macro.setGet(publicAPI, model, ['error', 'handle', 'compiled', 'bound', 'md5Hash', 'vertexShader', 'fragmentShader', 'geometryShader', 'linked']);\n\n  // Object methods\n  vtkShaderProgram(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkShaderProgram');\n\n// ----------------------------------------------------------------------------\n\nvar vtkShaderProgram$1 = {\n  newInstance,\n  extend,\n  substitute\n};\n\nexport { vtkShaderProgram$1 as default, substitute };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}