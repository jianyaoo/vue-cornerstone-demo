"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const gl_matrix_1 = require("gl-matrix");
const StrategyCallbacks_1 = __importDefault(require("../../../../enums/StrategyCallbacks"));
exports.default = {
    [StrategyCallbacks_1.default.Initialize]: (operationData) => {
        const { operationName, centerIJK, strategySpecificConfiguration, segmentationVoxelManager: segmentationVoxelManager, imageVoxelManager: imageVoxelManager, segmentIndex, } = operationData;
        const { THRESHOLD } = strategySpecificConfiguration;
        if (!(THRESHOLD === null || THRESHOLD === void 0 ? void 0 : THRESHOLD.isDynamic) || !centerIJK || !segmentIndex) {
            return;
        }
        if (operationName === StrategyCallbacks_1.default.RejectPreview ||
            operationName === StrategyCallbacks_1.default.OnInteractionEnd) {
            return;
        }
        const { boundsIJK } = segmentationVoxelManager;
        const { threshold: oldThreshold, dynamicRadius = 0 } = THRESHOLD;
        const useDelta = oldThreshold ? 0 : dynamicRadius;
        const nestedBounds = boundsIJK.map((ijk, idx) => {
            const [min, max] = ijk;
            return [
                Math.max(min, centerIJK[idx] - useDelta),
                Math.min(max, centerIJK[idx] + useDelta),
            ];
        });
        const threshold = oldThreshold || [Infinity, -Infinity];
        const callback = ({ value }) => {
            const gray = Array.isArray(value) ? gl_matrix_1.vec3.len(value) : value;
            threshold[0] = Math.min(gray, threshold[0]);
            threshold[1] = Math.max(gray, threshold[1]);
        };
        imageVoxelManager.forEach(callback, { boundsIJK: nestedBounds });
        operationData.strategySpecificConfiguration.THRESHOLD.threshold = threshold;
    },
    [StrategyCallbacks_1.default.OnInteractionStart]: (operationData) => {
        var _a;
        const { strategySpecificConfiguration, preview } = operationData;
        if (!((_a = strategySpecificConfiguration === null || strategySpecificConfiguration === void 0 ? void 0 : strategySpecificConfiguration.THRESHOLD) === null || _a === void 0 ? void 0 : _a.isDynamic) && !preview) {
            return;
        }
        strategySpecificConfiguration.THRESHOLD.threshold = null;
    },
    [StrategyCallbacks_1.default.ComputeInnerCircleRadius]: (operationData) => {
        const { configuration, viewport } = operationData;
        const { THRESHOLD: { dynamicRadius = 0 } = {} } = configuration.strategySpecificConfiguration || {};
        if (dynamicRadius === 0) {
            return;
        }
        const { spacing } = viewport.getImageData();
        const centerCanvas = [
            viewport.element.clientWidth / 2,
            viewport.element.clientHeight / 2,
        ];
        const radiusInWorld = dynamicRadius * spacing[0];
        const centerCursorInWorld = viewport.canvasToWorld(centerCanvas);
        const offSetCenterInWorld = centerCursorInWorld.map((coord) => coord + radiusInWorld);
        const offSetCenterCanvas = viewport.worldToCanvas(offSetCenterInWorld);
        const dynamicRadiusInCanvas = Math.abs(centerCanvas[0] - offSetCenterCanvas[0]);
        const { strategySpecificConfiguration, activeStrategy } = configuration;
        if (!strategySpecificConfiguration[activeStrategy]) {
            strategySpecificConfiguration[activeStrategy] = {};
        }
        strategySpecificConfiguration[activeStrategy].dynamicRadiusInCanvas =
            dynamicRadiusInCanvas;
    },
};
//# sourceMappingURL=dynamicThreshold.js.map