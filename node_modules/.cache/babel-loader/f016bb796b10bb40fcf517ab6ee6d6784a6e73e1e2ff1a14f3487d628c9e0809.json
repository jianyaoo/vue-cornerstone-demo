{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { n as newInstance$1, o as obj, e as setGet } from '../../macros2.js';\nimport vtkWebGPUTypes from './Types.js';\nfunction arraysEqual(a, b) {\n  if (a === b) return true;\n  if (a == null || b == null) return false;\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; ++i) {\n    if (!b.includes(a[i])) return false;\n  }\n  return true;\n}\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUVertexInput methods\n// ----------------------------------------------------------------------------\nfunction vtkWebGPUVertexInput(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUVertexInput');\n  publicAPI.addBuffer = function (buffer, inames) {\n    let stepMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'vertex';\n    let names = inames;\n    if (!Array.isArray(names)) {\n      names = [names];\n    }\n    // only add if it is a new setting\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (arraysEqual(model.inputs[i].names, names)) {\n        if (model.inputs[i].buffer === buffer) {\n          return;\n        }\n        model.inputs[i].buffer = buffer;\n        return;\n      }\n    }\n\n    // when adding a new entry, make sure we sort the array\n    // as the order is important to the shader and must always\n    // be the same, so alphabetical is an easy option\n    model.inputs.push({\n      buffer,\n      stepMode,\n      names\n    });\n    model.inputs = model.inputs.sort((v1, v2) => {\n      if (v1.names[0] < v2.names[0]) {\n        return -1;\n      }\n      if (v1.names[0] > v2.names[0]) {\n        return 1;\n      }\n      return 0;\n    });\n  };\n  publicAPI.removeBufferIfPresent = name => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        model.inputs.splice(i, 1);\n      }\n    }\n  };\n  publicAPI.getBuffer = name => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return model.inputs[i].buffer;\n      }\n    }\n    return null;\n  };\n  publicAPI.hasAttribute = name => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  publicAPI.getAttributeTime = name => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return model.inputs[i].buffer.getSourceTime();\n      }\n    }\n    return 0;\n  };\n  publicAPI.getShaderCode = () => {\n    let result = '';\n    let nameCount = 0;\n    for (let i = 0; i < model.inputs.length; i++) {\n      for (let nm = 0; nm < model.inputs[i].names.length; nm++) {\n        const arrayInfo = model.inputs[i].buffer.getArrayInformation()[nm];\n        const type = vtkWebGPUTypes.getShaderTypeFromBufferFormat(arrayInfo.format);\n        if (nameCount > 0) {\n          result += ',\\n';\n        }\n        result = `${result}  @location(${nameCount}) ${model.inputs[i].names[nm]} : ${type}`;\n        nameCount++;\n      }\n    }\n    return result;\n  };\n  publicAPI.getVertexInputInformation = () => {\n    const info = {};\n    if (model.inputs.length) {\n      const vertexBuffers = [];\n      let nameCount = 0;\n      for (let i = 0; i < model.inputs.length; i++) {\n        const buf = model.inputs[i].buffer;\n        const buffer = {\n          arrayStride: buf.getStrideInBytes(),\n          stepMode: model.inputs[i].stepMode,\n          attributes: []\n        };\n        const arrayInfo = buf.getArrayInformation();\n        for (let nm = 0; nm < model.inputs[i].names.length; nm++) {\n          buffer.attributes.push({\n            shaderLocation: nameCount,\n            offset: arrayInfo[nm].offset,\n            format: arrayInfo[nm].format\n          });\n          nameCount++;\n        }\n        vertexBuffers.push(buffer);\n      }\n      info.buffers = vertexBuffers;\n    }\n    return info;\n  };\n  publicAPI.bindBuffers = renderEncoder => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      renderEncoder.setVertexBuffer(i, model.inputs[i].buffer.getHandle());\n    }\n    if (model.indexBuffer) {\n      renderEncoder.setIndexBuffer(model.indexBuffer.getHandle(), model.indexBuffer.getArrayInformation()[0].format);\n    }\n  };\n  publicAPI.getReady = () => {};\n  publicAPI.releaseGraphicsResources = () => {\n    if (model.created) {\n      model.inputs = [];\n      model.bindingDescriptions = [];\n      model.attributeDescriptions = [];\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\nconst DEFAULT_VALUES = {\n  inputs: null,\n  bindingDescriptions: false,\n  attributeDescriptions: null,\n  indexBuffer: null\n};\n\n// ----------------------------------------------------------------------------\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  obj(publicAPI, model);\n  model.bindingDescriptions = [];\n  model.attributeDescriptions = [];\n  model.inputs = [];\n  setGet(publicAPI, model, ['created', 'device', 'handle', 'indexBuffer']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n  vtkWebGPUVertexInput(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\nconst newInstance = newInstance$1(extend, 'vtkWebGPUVertexInput');\n\n// ----------------------------------------------------------------------------\nvar vtkWebGPUVertexInput$1 = {\n  newInstance,\n  extend\n};\nexport { vtkWebGPUVertexInput$1 as default, extend, newInstance };","map":{"version":3,"names":["n","newInstance$1","o","obj","e","setGet","vtkWebGPUTypes","arraysEqual","a","b","length","i","includes","vtkWebGPUVertexInput","publicAPI","model","classHierarchy","push","addBuffer","buffer","inames","stepMode","arguments","undefined","names","Array","isArray","inputs","sort","v1","v2","removeBufferIfPresent","name","splice","getBuffer","hasAttribute","getAttributeTime","getSourceTime","getShaderCode","result","nameCount","nm","arrayInfo","getArrayInformation","type","getShaderTypeFromBufferFormat","format","getVertexInputInformation","info","vertexBuffers","buf","arrayStride","getStrideInBytes","attributes","shaderLocation","offset","buffers","bindBuffers","renderEncoder","setVertexBuffer","getHandle","indexBuffer","setIndexBuffer","getReady","releaseGraphicsResources","created","bindingDescriptions","attributeDescriptions","DEFAULT_VALUES","extend","initialValues","Object","assign","newInstance","vtkWebGPUVertexInput$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/WebGPU/VertexInput.js"],"sourcesContent":["import { n as newInstance$1, o as obj, e as setGet } from '../../macros2.js';\nimport vtkWebGPUTypes from './Types.js';\n\nfunction arraysEqual(a, b) {\n  if (a === b) return true;\n  if (a == null || b == null) return false;\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; ++i) {\n    if (!b.includes(a[i])) return false;\n  }\n  return true;\n}\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUVertexInput methods\n// ----------------------------------------------------------------------------\nfunction vtkWebGPUVertexInput(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUVertexInput');\n  publicAPI.addBuffer = function (buffer, inames) {\n    let stepMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'vertex';\n    let names = inames;\n    if (!Array.isArray(names)) {\n      names = [names];\n    }\n    // only add if it is a new setting\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (arraysEqual(model.inputs[i].names, names)) {\n        if (model.inputs[i].buffer === buffer) {\n          return;\n        }\n        model.inputs[i].buffer = buffer;\n        return;\n      }\n    }\n\n    // when adding a new entry, make sure we sort the array\n    // as the order is important to the shader and must always\n    // be the same, so alphabetical is an easy option\n    model.inputs.push({\n      buffer,\n      stepMode,\n      names\n    });\n    model.inputs = model.inputs.sort((v1, v2) => {\n      if (v1.names[0] < v2.names[0]) {\n        return -1;\n      }\n      if (v1.names[0] > v2.names[0]) {\n        return 1;\n      }\n      return 0;\n    });\n  };\n  publicAPI.removeBufferIfPresent = name => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        model.inputs.splice(i, 1);\n      }\n    }\n  };\n  publicAPI.getBuffer = name => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return model.inputs[i].buffer;\n      }\n    }\n    return null;\n  };\n  publicAPI.hasAttribute = name => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  publicAPI.getAttributeTime = name => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return model.inputs[i].buffer.getSourceTime();\n      }\n    }\n    return 0;\n  };\n  publicAPI.getShaderCode = () => {\n    let result = '';\n    let nameCount = 0;\n    for (let i = 0; i < model.inputs.length; i++) {\n      for (let nm = 0; nm < model.inputs[i].names.length; nm++) {\n        const arrayInfo = model.inputs[i].buffer.getArrayInformation()[nm];\n        const type = vtkWebGPUTypes.getShaderTypeFromBufferFormat(arrayInfo.format);\n        if (nameCount > 0) {\n          result += ',\\n';\n        }\n        result = `${result}  @location(${nameCount}) ${model.inputs[i].names[nm]} : ${type}`;\n        nameCount++;\n      }\n    }\n    return result;\n  };\n  publicAPI.getVertexInputInformation = () => {\n    const info = {};\n    if (model.inputs.length) {\n      const vertexBuffers = [];\n      let nameCount = 0;\n      for (let i = 0; i < model.inputs.length; i++) {\n        const buf = model.inputs[i].buffer;\n        const buffer = {\n          arrayStride: buf.getStrideInBytes(),\n          stepMode: model.inputs[i].stepMode,\n          attributes: []\n        };\n        const arrayInfo = buf.getArrayInformation();\n        for (let nm = 0; nm < model.inputs[i].names.length; nm++) {\n          buffer.attributes.push({\n            shaderLocation: nameCount,\n            offset: arrayInfo[nm].offset,\n            format: arrayInfo[nm].format\n          });\n          nameCount++;\n        }\n        vertexBuffers.push(buffer);\n      }\n      info.buffers = vertexBuffers;\n    }\n    return info;\n  };\n  publicAPI.bindBuffers = renderEncoder => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      renderEncoder.setVertexBuffer(i, model.inputs[i].buffer.getHandle());\n    }\n    if (model.indexBuffer) {\n      renderEncoder.setIndexBuffer(model.indexBuffer.getHandle(), model.indexBuffer.getArrayInformation()[0].format);\n    }\n  };\n  publicAPI.getReady = () => {};\n  publicAPI.releaseGraphicsResources = () => {\n    if (model.created) {\n      model.inputs = [];\n      model.bindingDescriptions = [];\n      model.attributeDescriptions = [];\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\nconst DEFAULT_VALUES = {\n  inputs: null,\n  bindingDescriptions: false,\n  attributeDescriptions: null,\n  indexBuffer: null\n};\n\n// ----------------------------------------------------------------------------\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  obj(publicAPI, model);\n  model.bindingDescriptions = [];\n  model.attributeDescriptions = [];\n  model.inputs = [];\n  setGet(publicAPI, model, ['created', 'device', 'handle', 'indexBuffer']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n  vtkWebGPUVertexInput(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\nconst newInstance = newInstance$1(extend, 'vtkWebGPUVertexInput');\n\n// ----------------------------------------------------------------------------\nvar vtkWebGPUVertexInput$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUVertexInput$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}