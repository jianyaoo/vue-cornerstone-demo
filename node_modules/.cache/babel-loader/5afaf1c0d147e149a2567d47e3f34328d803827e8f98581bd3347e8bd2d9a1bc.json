{"ast":null,"code":"import { mat4, vec3 } from 'gl-matrix';\nimport { n as newInstance$1, g as get, e as setGet, k as getArray, l as setGetArray, i as moveToProtected, c as macro } from '../../macros2.js';\nimport vtkCamera from './Camera.js';\nimport vtkLight from './Light.js';\nimport { R as areBoundsInitialized, u as uninitializeBounds, r as radiansFromDegrees, d as dot, F as createUninitializedBounds } from '../../Common/Core/Math/index.js';\nimport vtkViewport from './Viewport.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\nfunction notImplemented(method) {\n  return () => vtkErrorMacro(`vtkRenderer::${method} - NOT IMPLEMENTED`);\n}\n\n// ----------------------------------------------------------------------------\n// vtkRenderer methods\n// ----------------------------------------------------------------------------\n\nfunction vtkRenderer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkRenderer');\n\n  // Events\n  const COMPUTE_VISIBLE_PROP_BOUNDS_EVENT = {\n    type: 'ComputeVisiblePropBoundsEvent',\n    renderer: publicAPI\n  };\n  const RESET_CAMERA_CLIPPING_RANGE_EVENT = {\n    type: 'ResetCameraClippingRangeEvent',\n    renderer: publicAPI\n  };\n  const RESET_CAMERA_EVENT = {\n    type: 'ResetCameraEvent',\n    renderer: publicAPI\n  };\n  publicAPI.updateCamera = () => {\n    if (!model.activeCamera) {\n      vtkDebugMacro('No cameras are on, creating one.');\n      // the get method will automagically create a camera\n      // and reset it since one hasn't been specified yet.\n      publicAPI.getActiveCameraAndResetIfCreated();\n    }\n\n    // update the viewing transformation\n    model.activeCamera.render(publicAPI);\n    return true;\n  };\n  publicAPI.updateLightsGeometryToFollowCamera = () => {\n    // only update the light's geometry if this Renderer is tracking\n    // this lights.  That allows one renderer to view the lights that\n    // another renderer is setting up.\n    const camera = publicAPI.getActiveCameraAndResetIfCreated();\n    model.lights.forEach(light => {\n      if (light.lightTypeIsSceneLight()) ;else if (light.lightTypeIsHeadLight()) {\n        // update position and orientation of light to match camera.\n        light.setPositionFrom(camera.getPositionByReference());\n        light.setFocalPointFrom(camera.getFocalPointByReference());\n        light.modified(camera.getMTime());\n      } else if (light.lightTypeIsCameraLight()) {\n        light.setTransformMatrix(camera.getCameraLightTransformMatrix(mat4.create()));\n      } else {\n        vtkErrorMacro('light has unknown light type', light.get());\n      }\n    });\n  };\n  publicAPI.updateLightGeometry = () => {\n    if (model.lightFollowCamera) {\n      // only update the light's geometry if this Renderer is tracking\n      // this lights.  That allows one renderer to view the lights that\n      // another renderer is setting up.\n      return publicAPI.updateLightsGeometryToFollowCamera();\n    }\n    return true;\n  };\n  publicAPI.allocateTime = notImplemented('allocateTime');\n  publicAPI.updateGeometry = notImplemented('updateGeometry');\n  publicAPI.getVTKWindow = () => model._renderWindow;\n  publicAPI.setLayer = layer => {\n    vtkDebugMacro(publicAPI.getClassName(), publicAPI, 'setting Layer to ', layer);\n    if (model.layer !== layer) {\n      model.layer = layer;\n      publicAPI.modified();\n    }\n    publicAPI.setPreserveColorBuffer(!!layer);\n  };\n  publicAPI.setActiveCamera = camera => {\n    if (model.activeCamera === camera) {\n      return false;\n    }\n    model.activeCamera = camera;\n    publicAPI.modified();\n    publicAPI.invokeEvent({\n      type: 'ActiveCameraEvent',\n      camera\n    });\n    return true;\n  };\n  publicAPI.makeCamera = () => {\n    const camera = vtkCamera.newInstance();\n    publicAPI.invokeEvent({\n      type: 'CreateCameraEvent',\n      camera\n    });\n    return camera;\n  };\n\n  // Replace the set/get macro method\n  publicAPI.getActiveCamera = () => {\n    if (!model.activeCamera) {\n      model.activeCamera = publicAPI.makeCamera();\n    }\n    return model.activeCamera;\n  };\n  publicAPI.getActiveCameraAndResetIfCreated = () => {\n    if (!model.activeCamera) {\n      publicAPI.getActiveCamera();\n      publicAPI.resetCamera();\n    }\n    return model.activeCamera;\n  };\n  publicAPI.getActors = () => {\n    model.actors = [];\n    model.props.forEach(prop => {\n      model.actors = model.actors.concat(prop.getActors());\n    });\n    return model.actors;\n  };\n  publicAPI.addActor = publicAPI.addViewProp;\n  publicAPI.removeActor = actor => {\n    model.actors = model.actors.filter(a => a !== actor);\n    publicAPI.removeViewProp(actor);\n    publicAPI.modified();\n  };\n  publicAPI.removeAllActors = () => {\n    const actors = publicAPI.getActors();\n    actors.forEach(actor => {\n      publicAPI.removeViewProp(actor);\n    });\n    model.actors = [];\n    publicAPI.modified();\n  };\n  publicAPI.getVolumes = () => {\n    model.volumes = [];\n    model.props.forEach(prop => {\n      model.volumes = model.volumes.concat(prop.getVolumes());\n    });\n    return model.volumes;\n  };\n  publicAPI.addVolume = publicAPI.addViewProp;\n  publicAPI.removeVolume = volume => {\n    model.volumes = model.volumes.filter(v => v !== volume);\n    publicAPI.removeViewProp(volume);\n    publicAPI.modified();\n  };\n  publicAPI.removeAllVolumes = () => {\n    const volumes = publicAPI.getVolumes();\n    volumes.forEach(volume => {\n      publicAPI.removeViewProp(volume);\n    });\n    model.volumes = [];\n    publicAPI.modified();\n  };\n  publicAPI.hasLight = light => model.lights.includes(light);\n  publicAPI.addLight = light => {\n    if (light && !publicAPI.hasLight(light)) {\n      model.lights.push(light);\n      publicAPI.modified();\n    }\n  };\n  publicAPI.removeLight = light => {\n    model.lights = model.lights.filter(l => l !== light);\n    publicAPI.modified();\n  };\n  publicAPI.removeAllLights = () => {\n    model.lights = [];\n    publicAPI.modified();\n  };\n  publicAPI.setLightCollection = lights => {\n    model.lights = lights;\n    publicAPI.modified();\n  };\n  publicAPI.makeLight = vtkLight.newInstance;\n  publicAPI.createLight = () => {\n    if (!model.automaticLightCreation) {\n      return;\n    }\n    if (model._createdLight) {\n      publicAPI.removeLight(model._createdLight);\n      model._createdLight.delete();\n      model._createdLight = null;\n    }\n    model._createdLight = publicAPI.makeLight();\n    publicAPI.addLight(model._createdLight);\n    model._createdLight.setLightTypeToHeadLight();\n\n    // set these values just to have a good default should LightFollowCamera\n    // be turned off.\n    model._createdLight.setPosition(publicAPI.getActiveCamera().getPosition());\n    model._createdLight.setFocalPoint(publicAPI.getActiveCamera().getFocalPoint());\n  };\n\n  // requires the aspect ratio of the viewport as X/Y\n  publicAPI.normalizedDisplayToWorld = (x, y, z, aspect) => {\n    let vpd = publicAPI.normalizedDisplayToProjection(x, y, z);\n    vpd = publicAPI.projectionToView(vpd[0], vpd[1], vpd[2], aspect);\n    return publicAPI.viewToWorld(vpd[0], vpd[1], vpd[2]);\n  };\n\n  // requires the aspect ratio of the viewport as X/Y\n  publicAPI.worldToNormalizedDisplay = (x, y, z, aspect) => {\n    let vpd = publicAPI.worldToView(x, y, z);\n    vpd = publicAPI.viewToProjection(vpd[0], vpd[1], vpd[2], aspect);\n    return publicAPI.projectionToNormalizedDisplay(vpd[0], vpd[1], vpd[2]);\n  };\n\n  // requires the aspect ratio of the viewport as X/Y\n  publicAPI.viewToWorld = (x, y, z) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0');\n      return [0, 0, 0];\n    }\n\n    // get the view matrix from the active camera\n    const matrix = model.activeCamera.getViewMatrix();\n    mat4.invert(matrix, matrix);\n    mat4.transpose(matrix, matrix);\n\n    // Transform point to world coordinates\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n  publicAPI.projectionToView = (x, y, z, aspect) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0');\n      return [0, 0, 0];\n    }\n\n    // get the projection transformation from the active camera\n    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);\n    mat4.invert(matrix, matrix);\n    mat4.transpose(matrix, matrix);\n\n    // Transform point to world coordinates\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n\n  // Convert world point coordinates to view coordinates.\n  publicAPI.worldToView = (x, y, z) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('WorldToView: no active camera, cannot compute view to world, returning 0,0,0');\n      return [0, 0, 0];\n    }\n\n    // get the view transformation from the active camera\n    const matrix = model.activeCamera.getViewMatrix();\n    mat4.transpose(matrix, matrix);\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n\n  // Convert world point coordinates to view coordinates.\n  // requires the aspect ratio of the viewport as X/Y\n  publicAPI.viewToProjection = (x, y, z, aspect) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0');\n      return [0, 0, 0];\n    }\n\n    // get the projeciton transformation from the active camera\n    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);\n    mat4.transpose(matrix, matrix);\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n  publicAPI.computeVisiblePropBounds = () => {\n    model.allBounds[0] = vtkBoundingBox.INIT_BOUNDS[0];\n    model.allBounds[1] = vtkBoundingBox.INIT_BOUNDS[1];\n    model.allBounds[2] = vtkBoundingBox.INIT_BOUNDS[2];\n    model.allBounds[3] = vtkBoundingBox.INIT_BOUNDS[3];\n    model.allBounds[4] = vtkBoundingBox.INIT_BOUNDS[4];\n    model.allBounds[5] = vtkBoundingBox.INIT_BOUNDS[5];\n    let nothingVisible = true;\n    publicAPI.invokeEvent(COMPUTE_VISIBLE_PROP_BOUNDS_EVENT);\n\n    // loop through all props\n    for (let index = 0; index < model.props.length; ++index) {\n      const prop = model.props[index];\n      if (prop.getVisibility() && prop.getUseBounds()) {\n        const bounds = prop.getBounds();\n        if (bounds && areBoundsInitialized(bounds)) {\n          nothingVisible = false;\n          if (bounds[0] < model.allBounds[0]) {\n            model.allBounds[0] = bounds[0];\n          }\n          if (bounds[1] > model.allBounds[1]) {\n            model.allBounds[1] = bounds[1];\n          }\n          if (bounds[2] < model.allBounds[2]) {\n            model.allBounds[2] = bounds[2];\n          }\n          if (bounds[3] > model.allBounds[3]) {\n            model.allBounds[3] = bounds[3];\n          }\n          if (bounds[4] < model.allBounds[4]) {\n            model.allBounds[4] = bounds[4];\n          }\n          if (bounds[5] > model.allBounds[5]) {\n            model.allBounds[5] = bounds[5];\n          }\n        }\n      }\n    }\n    if (nothingVisible) {\n      uninitializeBounds(model.allBounds);\n      vtkDebugMacro(\"Can't compute bounds, no 3D props are visible\");\n    }\n    return model.allBounds;\n  };\n  publicAPI.resetCamera = function () {\n    let bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();\n    const center = [0, 0, 0];\n    if (!areBoundsInitialized(boundsToUse)) {\n      vtkDebugMacro('Cannot reset camera!');\n      return false;\n    }\n    let vn = null;\n    if (publicAPI.getActiveCamera()) {\n      vn = model.activeCamera.getViewPlaneNormal();\n    } else {\n      vtkErrorMacro('Trying to reset non-existent camera');\n      return false;\n    }\n\n    // Reset the perspective zoom factors, otherwise subsequent zooms will cause\n    // the view angle to become very small and cause bad depth sorting.\n    model.activeCamera.setViewAngle(30.0);\n    center[0] = (boundsToUse[0] + boundsToUse[1]) / 2.0;\n    center[1] = (boundsToUse[2] + boundsToUse[3]) / 2.0;\n    center[2] = (boundsToUse[4] + boundsToUse[5]) / 2.0;\n    let w1 = boundsToUse[1] - boundsToUse[0];\n    let w2 = boundsToUse[3] - boundsToUse[2];\n    let w3 = boundsToUse[5] - boundsToUse[4];\n    w1 *= w1;\n    w2 *= w2;\n    w3 *= w3;\n    let radius = w1 + w2 + w3;\n\n    // If we have just a single point, pick a radius of 1.0\n    radius = radius === 0 ? 1.0 : radius;\n\n    // compute the radius of the enclosing sphere\n    radius = Math.sqrt(radius) * 0.5;\n\n    // default so that the bounding sphere fits within the view fustrum\n\n    // compute the distance from the intersection of the view frustum with the\n    // bounding sphere. Basically in 2D draw a circle representing the bounding\n    // sphere in 2D then draw a horizontal line going out from the center of\n    // the circle. That is the camera view. Then draw a line from the camera\n    // position to the point where it intersects the circle. (it will be tangent\n    // to the circle at this point, this is important, only go to the tangent\n    // point, do not draw all the way to the view plane). Then draw the radius\n    // from the tangent point to the center of the circle. You will note that\n    // this forms a right triangle with one side being the radius, another being\n    // the target distance for the camera, then just find the target dist using\n    // a sin.\n    const angle = radiansFromDegrees(model.activeCamera.getViewAngle());\n    const parallelScale = radius;\n    const distance = radius / Math.sin(angle * 0.5);\n\n    // check view-up vector against view plane normal\n    const vup = model.activeCamera.getViewUp();\n    if (Math.abs(dot(vup, vn)) > 0.999) {\n      vtkWarningMacro('Resetting view-up since view plane normal is parallel');\n      model.activeCamera.setViewUp(-vup[2], vup[0], vup[1]);\n    }\n\n    // update the camera\n    model.activeCamera.setFocalPoint(center[0], center[1], center[2]);\n    model.activeCamera.setPosition(center[0] + distance * vn[0], center[1] + distance * vn[1], center[2] + distance * vn[2]);\n    publicAPI.resetCameraClippingRange(boundsToUse);\n\n    // setup default parallel scale\n    model.activeCamera.setParallelScale(parallelScale);\n\n    // update reasonable world to physical values\n    model.activeCamera.setPhysicalScale(radius);\n    model.activeCamera.setPhysicalTranslation(-center[0], -center[1], -center[2]);\n\n    // Here to let parallel/distributed compositing intercept\n    // and do the right thing.\n    publicAPI.invokeEvent(RESET_CAMERA_EVENT);\n    return true;\n  };\n  publicAPI.resetCameraClippingRange = function () {\n    let bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();\n    if (!areBoundsInitialized(boundsToUse)) {\n      vtkDebugMacro('Cannot reset camera clipping range!');\n      return false;\n    }\n\n    // Make sure we have an active camera\n    publicAPI.getActiveCameraAndResetIfCreated();\n    if (!model.activeCamera) {\n      vtkErrorMacro('Trying to reset clipping range of non-existent camera');\n      return false;\n    }\n\n    // Get the exact range for the bounds\n    const range = model.activeCamera.computeClippingRange(boundsToUse);\n\n    // do not let far - near be less than 0.1 of the window height\n    // this is for cases such as 2D images which may have zero range\n    let minGap = 0.0;\n    if (model.activeCamera.getParallelProjection()) {\n      minGap = 0.2 * model.activeCamera.getParallelScale();\n    } else {\n      const angle = radiansFromDegrees(model.activeCamera.getViewAngle());\n      minGap = 0.2 * Math.tan(angle / 2.0) * range[1];\n    }\n    if (range[1] - range[0] < minGap) {\n      minGap = minGap - range[1] + range[0];\n      range[1] += minGap / 2.0;\n      range[0] -= minGap / 2.0;\n    }\n\n    // Do not let the range behind the camera throw off the calculation.\n    if (range[0] < 0.0) {\n      range[0] = 0.0;\n    }\n\n    // Give ourselves a little breathing room\n    range[0] = 0.99 * range[0] - (range[1] - range[0]) * model.clippingRangeExpansion;\n    range[1] = 1.01 * range[1] + (range[1] - range[0]) * model.clippingRangeExpansion;\n\n    // Make sure near is not bigger than far\n    range[0] = range[0] >= range[1] ? 0.01 * range[1] : range[0];\n\n    // Make sure near is at least some fraction of far - this prevents near\n    // from being behind the camera or too close in front. How close is too\n    // close depends on the resolution of the depth buffer\n    if (!model.nearClippingPlaneTolerance) {\n      model.nearClippingPlaneTolerance = 0.01;\n    }\n\n    // make sure the front clipping range is not too far from the far clippnig\n    // range, this is to make sure that the zbuffer resolution is effectively\n    // used\n    if (range[0] < model.nearClippingPlaneTolerance * range[1]) {\n      range[0] = model.nearClippingPlaneTolerance * range[1];\n    }\n    model.activeCamera.setClippingRange(range[0], range[1]);\n\n    // Here to let parallel/distributed compositing intercept\n    // and do the right thing.\n    publicAPI.invokeEvent(RESET_CAMERA_CLIPPING_RANGE_EVENT);\n    return false;\n  };\n  publicAPI.setRenderWindow = renderWindow => {\n    if (renderWindow !== model._renderWindow) {\n      model._vtkWindow = renderWindow;\n      model._renderWindow = renderWindow;\n    }\n  };\n  publicAPI.visibleActorCount = () => model.props.filter(prop => prop.getVisibility()).length;\n  publicAPI.visibleVolumeCount = publicAPI.visibleActorCount;\n  publicAPI.getMTime = () => {\n    let m1 = model.mtime;\n    const m2 = model.activeCamera ? model.activeCamera.getMTime() : 0;\n    if (m2 > m1) {\n      m1 = m2;\n    }\n    const m3 = model._createdLight ? model._createdLight.getMTime() : 0;\n    if (m3 > m1) {\n      m1 = m3;\n    }\n    return m1;\n  };\n  publicAPI.getTransparent = () => !!model.preserveColorBuffer;\n  publicAPI.isActiveCameraCreated = () => !!model.activeCamera;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  pickedProp: null,\n  activeCamera: null,\n  allBounds: [],\n  ambient: [1, 1, 1],\n  allocatedRenderTime: 100,\n  timeFactor: 1,\n  automaticLightCreation: true,\n  twoSidedLighting: true,\n  lastRenderTimeInSeconds: -1,\n  renderWindow: null,\n  lights: [],\n  actors: [],\n  volumes: [],\n  lightFollowCamera: true,\n  numberOfPropsRendered: 0,\n  propArray: null,\n  pathArray: null,\n  layer: 0,\n  preserveColorBuffer: false,\n  preserveDepthBuffer: false,\n  computeVisiblePropBounds: createUninitializedBounds(),\n  interactive: true,\n  nearClippingPlaneTolerance: 0,\n  clippingRangeExpansion: 0.05,\n  erase: true,\n  draw: true,\n  useShadows: false,\n  useDepthPeeling: false,\n  occlusionRatio: 0,\n  maximumNumberOfPeels: 4,\n  selector: null,\n  delegate: null,\n  texturedBackground: false,\n  backgroundTexture: null,\n  environmentTexture: null,\n  environmentTextureDiffuseStrength: 1,\n  environmentTextureSpecularStrength: 1,\n  useEnvironmentTextureAsBackground: false,\n  pass: 0\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewport.extend(publicAPI, model, initialValues);\n\n  // make sure background has 4 entries. Default to opaque black\n  if (!model.background) model.background = [0, 0, 0, 1];\n  while (model.background.length < 3) model.background.push(0);\n  if (model.background.length === 3) model.background.push(1);\n\n  // Build VTK API\n  get(publicAPI, model, ['_renderWindow', 'allocatedRenderTime', 'timeFactor', 'lastRenderTimeInSeconds', 'numberOfPropsRendered', 'lastRenderingUsedDepthPeeling', 'selector']);\n  setGet(publicAPI, model, ['twoSidedLighting', 'lightFollowCamera', 'automaticLightCreation', 'erase', 'draw', 'nearClippingPlaneTolerance', 'clippingRangeExpansion', 'backingStore', 'interactive', 'layer', 'preserveColorBuffer', 'preserveDepthBuffer', 'useDepthPeeling', 'occlusionRatio', 'maximumNumberOfPeels', 'delegate', 'backgroundTexture', 'texturedBackground', 'environmentTexture', 'environmentTextureDiffuseStrength', 'environmentTextureSpecularStrength', 'useEnvironmentTextureAsBackground', 'useShadows', 'pass']);\n  getArray(publicAPI, model, ['actors', 'volumes', 'lights']);\n  setGetArray(publicAPI, model, ['background'], 4, 1.0);\n  moveToProtected(publicAPI, model, ['renderWindow']);\n\n  // Object methods\n  vtkRenderer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkRenderer');\n\n// ----------------------------------------------------------------------------\n\nvar vtkRenderer$1 = {\n  newInstance,\n  extend\n};\nexport { vtkRenderer$1 as default, extend, newInstance };","map":{"version":3,"names":["mat4","vec3","n","newInstance$1","g","get","e","setGet","k","getArray","l","setGetArray","i","moveToProtected","c","macro","vtkCamera","vtkLight","R","areBoundsInitialized","u","uninitializeBounds","r","radiansFromDegrees","d","dot","F","createUninitializedBounds","vtkViewport","vtkBoundingBox","vtkDebugMacro","vtkErrorMacro","vtkWarningMacro","notImplemented","method","vtkRenderer","publicAPI","model","classHierarchy","push","COMPUTE_VISIBLE_PROP_BOUNDS_EVENT","type","renderer","RESET_CAMERA_CLIPPING_RANGE_EVENT","RESET_CAMERA_EVENT","updateCamera","activeCamera","getActiveCameraAndResetIfCreated","render","updateLightsGeometryToFollowCamera","camera","lights","forEach","light","lightTypeIsSceneLight","lightTypeIsHeadLight","setPositionFrom","getPositionByReference","setFocalPointFrom","getFocalPointByReference","modified","getMTime","lightTypeIsCameraLight","setTransformMatrix","getCameraLightTransformMatrix","create","updateLightGeometry","lightFollowCamera","allocateTime","updateGeometry","getVTKWindow","_renderWindow","setLayer","layer","getClassName","setPreserveColorBuffer","setActiveCamera","invokeEvent","makeCamera","newInstance","getActiveCamera","resetCamera","getActors","actors","props","prop","concat","addActor","addViewProp","removeActor","actor","filter","a","removeViewProp","removeAllActors","getVolumes","volumes","addVolume","removeVolume","volume","v","removeAllVolumes","hasLight","includes","addLight","removeLight","removeAllLights","setLightCollection","makeLight","createLight","automaticLightCreation","_createdLight","delete","setLightTypeToHeadLight","setPosition","getPosition","setFocalPoint","getFocalPoint","normalizedDisplayToWorld","x","y","z","aspect","vpd","normalizedDisplayToProjection","projectionToView","viewToWorld","worldToNormalizedDisplay","worldToView","viewToProjection","projectionToNormalizedDisplay","matrix","getViewMatrix","invert","transpose","result","Float64Array","transformMat4","getProjectionMatrix","computeVisiblePropBounds","allBounds","INIT_BOUNDS","nothingVisible","index","length","getVisibility","getUseBounds","bounds","getBounds","arguments","undefined","boundsToUse","center","vn","getViewPlaneNormal","setViewAngle","w1","w2","w3","radius","Math","sqrt","angle","getViewAngle","parallelScale","distance","sin","vup","getViewUp","abs","setViewUp","resetCameraClippingRange","setParallelScale","setPhysicalScale","setPhysicalTranslation","range","computeClippingRange","minGap","getParallelProjection","getParallelScale","tan","clippingRangeExpansion","nearClippingPlaneTolerance","setClippingRange","setRenderWindow","renderWindow","_vtkWindow","visibleActorCount","visibleVolumeCount","m1","mtime","m2","m3","getTransparent","preserveColorBuffer","isActiveCameraCreated","DEFAULT_VALUES","pickedProp","ambient","allocatedRenderTime","timeFactor","twoSidedLighting","lastRenderTimeInSeconds","numberOfPropsRendered","propArray","pathArray","preserveDepthBuffer","interactive","erase","draw","useShadows","useDepthPeeling","occlusionRatio","maximumNumberOfPeels","selector","delegate","texturedBackground","backgroundTexture","environmentTexture","environmentTextureDiffuseStrength","environmentTextureSpecularStrength","useEnvironmentTextureAsBackground","pass","extend","initialValues","Object","assign","background","vtkRenderer$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/Core/Renderer.js"],"sourcesContent":["import { mat4, vec3 } from 'gl-matrix';\nimport { n as newInstance$1, g as get, e as setGet, k as getArray, l as setGetArray, i as moveToProtected, c as macro } from '../../macros2.js';\nimport vtkCamera from './Camera.js';\nimport vtkLight from './Light.js';\nimport { R as areBoundsInitialized, u as uninitializeBounds, r as radiansFromDegrees, d as dot, F as createUninitializedBounds } from '../../Common/Core/Math/index.js';\nimport vtkViewport from './Viewport.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\n\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\nfunction notImplemented(method) {\n  return () => vtkErrorMacro(`vtkRenderer::${method} - NOT IMPLEMENTED`);\n}\n\n// ----------------------------------------------------------------------------\n// vtkRenderer methods\n// ----------------------------------------------------------------------------\n\nfunction vtkRenderer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkRenderer');\n\n  // Events\n  const COMPUTE_VISIBLE_PROP_BOUNDS_EVENT = {\n    type: 'ComputeVisiblePropBoundsEvent',\n    renderer: publicAPI\n  };\n  const RESET_CAMERA_CLIPPING_RANGE_EVENT = {\n    type: 'ResetCameraClippingRangeEvent',\n    renderer: publicAPI\n  };\n  const RESET_CAMERA_EVENT = {\n    type: 'ResetCameraEvent',\n    renderer: publicAPI\n  };\n  publicAPI.updateCamera = () => {\n    if (!model.activeCamera) {\n      vtkDebugMacro('No cameras are on, creating one.');\n      // the get method will automagically create a camera\n      // and reset it since one hasn't been specified yet.\n      publicAPI.getActiveCameraAndResetIfCreated();\n    }\n\n    // update the viewing transformation\n    model.activeCamera.render(publicAPI);\n    return true;\n  };\n  publicAPI.updateLightsGeometryToFollowCamera = () => {\n    // only update the light's geometry if this Renderer is tracking\n    // this lights.  That allows one renderer to view the lights that\n    // another renderer is setting up.\n    const camera = publicAPI.getActiveCameraAndResetIfCreated();\n    model.lights.forEach(light => {\n      if (light.lightTypeIsSceneLight()) ; else if (light.lightTypeIsHeadLight()) {\n        // update position and orientation of light to match camera.\n        light.setPositionFrom(camera.getPositionByReference());\n        light.setFocalPointFrom(camera.getFocalPointByReference());\n        light.modified(camera.getMTime());\n      } else if (light.lightTypeIsCameraLight()) {\n        light.setTransformMatrix(camera.getCameraLightTransformMatrix(mat4.create()));\n      } else {\n        vtkErrorMacro('light has unknown light type', light.get());\n      }\n    });\n  };\n  publicAPI.updateLightGeometry = () => {\n    if (model.lightFollowCamera) {\n      // only update the light's geometry if this Renderer is tracking\n      // this lights.  That allows one renderer to view the lights that\n      // another renderer is setting up.\n      return publicAPI.updateLightsGeometryToFollowCamera();\n    }\n    return true;\n  };\n  publicAPI.allocateTime = notImplemented('allocateTime');\n  publicAPI.updateGeometry = notImplemented('updateGeometry');\n  publicAPI.getVTKWindow = () => model._renderWindow;\n  publicAPI.setLayer = layer => {\n    vtkDebugMacro(publicAPI.getClassName(), publicAPI, 'setting Layer to ', layer);\n    if (model.layer !== layer) {\n      model.layer = layer;\n      publicAPI.modified();\n    }\n    publicAPI.setPreserveColorBuffer(!!layer);\n  };\n  publicAPI.setActiveCamera = camera => {\n    if (model.activeCamera === camera) {\n      return false;\n    }\n    model.activeCamera = camera;\n    publicAPI.modified();\n    publicAPI.invokeEvent({\n      type: 'ActiveCameraEvent',\n      camera\n    });\n    return true;\n  };\n  publicAPI.makeCamera = () => {\n    const camera = vtkCamera.newInstance();\n    publicAPI.invokeEvent({\n      type: 'CreateCameraEvent',\n      camera\n    });\n    return camera;\n  };\n\n  // Replace the set/get macro method\n  publicAPI.getActiveCamera = () => {\n    if (!model.activeCamera) {\n      model.activeCamera = publicAPI.makeCamera();\n    }\n    return model.activeCamera;\n  };\n  publicAPI.getActiveCameraAndResetIfCreated = () => {\n    if (!model.activeCamera) {\n      publicAPI.getActiveCamera();\n      publicAPI.resetCamera();\n    }\n    return model.activeCamera;\n  };\n  publicAPI.getActors = () => {\n    model.actors = [];\n    model.props.forEach(prop => {\n      model.actors = model.actors.concat(prop.getActors());\n    });\n    return model.actors;\n  };\n  publicAPI.addActor = publicAPI.addViewProp;\n  publicAPI.removeActor = actor => {\n    model.actors = model.actors.filter(a => a !== actor);\n    publicAPI.removeViewProp(actor);\n    publicAPI.modified();\n  };\n  publicAPI.removeAllActors = () => {\n    const actors = publicAPI.getActors();\n    actors.forEach(actor => {\n      publicAPI.removeViewProp(actor);\n    });\n    model.actors = [];\n    publicAPI.modified();\n  };\n  publicAPI.getVolumes = () => {\n    model.volumes = [];\n    model.props.forEach(prop => {\n      model.volumes = model.volumes.concat(prop.getVolumes());\n    });\n    return model.volumes;\n  };\n  publicAPI.addVolume = publicAPI.addViewProp;\n  publicAPI.removeVolume = volume => {\n    model.volumes = model.volumes.filter(v => v !== volume);\n    publicAPI.removeViewProp(volume);\n    publicAPI.modified();\n  };\n  publicAPI.removeAllVolumes = () => {\n    const volumes = publicAPI.getVolumes();\n    volumes.forEach(volume => {\n      publicAPI.removeViewProp(volume);\n    });\n    model.volumes = [];\n    publicAPI.modified();\n  };\n  publicAPI.hasLight = light => model.lights.includes(light);\n  publicAPI.addLight = light => {\n    if (light && !publicAPI.hasLight(light)) {\n      model.lights.push(light);\n      publicAPI.modified();\n    }\n  };\n  publicAPI.removeLight = light => {\n    model.lights = model.lights.filter(l => l !== light);\n    publicAPI.modified();\n  };\n  publicAPI.removeAllLights = () => {\n    model.lights = [];\n    publicAPI.modified();\n  };\n  publicAPI.setLightCollection = lights => {\n    model.lights = lights;\n    publicAPI.modified();\n  };\n  publicAPI.makeLight = vtkLight.newInstance;\n  publicAPI.createLight = () => {\n    if (!model.automaticLightCreation) {\n      return;\n    }\n    if (model._createdLight) {\n      publicAPI.removeLight(model._createdLight);\n      model._createdLight.delete();\n      model._createdLight = null;\n    }\n    model._createdLight = publicAPI.makeLight();\n    publicAPI.addLight(model._createdLight);\n    model._createdLight.setLightTypeToHeadLight();\n\n    // set these values just to have a good default should LightFollowCamera\n    // be turned off.\n    model._createdLight.setPosition(publicAPI.getActiveCamera().getPosition());\n    model._createdLight.setFocalPoint(publicAPI.getActiveCamera().getFocalPoint());\n  };\n\n  // requires the aspect ratio of the viewport as X/Y\n  publicAPI.normalizedDisplayToWorld = (x, y, z, aspect) => {\n    let vpd = publicAPI.normalizedDisplayToProjection(x, y, z);\n    vpd = publicAPI.projectionToView(vpd[0], vpd[1], vpd[2], aspect);\n    return publicAPI.viewToWorld(vpd[0], vpd[1], vpd[2]);\n  };\n\n  // requires the aspect ratio of the viewport as X/Y\n  publicAPI.worldToNormalizedDisplay = (x, y, z, aspect) => {\n    let vpd = publicAPI.worldToView(x, y, z);\n    vpd = publicAPI.viewToProjection(vpd[0], vpd[1], vpd[2], aspect);\n    return publicAPI.projectionToNormalizedDisplay(vpd[0], vpd[1], vpd[2]);\n  };\n\n  // requires the aspect ratio of the viewport as X/Y\n  publicAPI.viewToWorld = (x, y, z) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0');\n      return [0, 0, 0];\n    }\n\n    // get the view matrix from the active camera\n    const matrix = model.activeCamera.getViewMatrix();\n    mat4.invert(matrix, matrix);\n    mat4.transpose(matrix, matrix);\n\n    // Transform point to world coordinates\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n  publicAPI.projectionToView = (x, y, z, aspect) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0');\n      return [0, 0, 0];\n    }\n\n    // get the projection transformation from the active camera\n    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);\n    mat4.invert(matrix, matrix);\n    mat4.transpose(matrix, matrix);\n\n    // Transform point to world coordinates\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n\n  // Convert world point coordinates to view coordinates.\n  publicAPI.worldToView = (x, y, z) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('WorldToView: no active camera, cannot compute view to world, returning 0,0,0');\n      return [0, 0, 0];\n    }\n\n    // get the view transformation from the active camera\n    const matrix = model.activeCamera.getViewMatrix();\n    mat4.transpose(matrix, matrix);\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n\n  // Convert world point coordinates to view coordinates.\n  // requires the aspect ratio of the viewport as X/Y\n  publicAPI.viewToProjection = (x, y, z, aspect) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0');\n      return [0, 0, 0];\n    }\n\n    // get the projeciton transformation from the active camera\n    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);\n    mat4.transpose(matrix, matrix);\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n  publicAPI.computeVisiblePropBounds = () => {\n    model.allBounds[0] = vtkBoundingBox.INIT_BOUNDS[0];\n    model.allBounds[1] = vtkBoundingBox.INIT_BOUNDS[1];\n    model.allBounds[2] = vtkBoundingBox.INIT_BOUNDS[2];\n    model.allBounds[3] = vtkBoundingBox.INIT_BOUNDS[3];\n    model.allBounds[4] = vtkBoundingBox.INIT_BOUNDS[4];\n    model.allBounds[5] = vtkBoundingBox.INIT_BOUNDS[5];\n    let nothingVisible = true;\n    publicAPI.invokeEvent(COMPUTE_VISIBLE_PROP_BOUNDS_EVENT);\n\n    // loop through all props\n    for (let index = 0; index < model.props.length; ++index) {\n      const prop = model.props[index];\n      if (prop.getVisibility() && prop.getUseBounds()) {\n        const bounds = prop.getBounds();\n        if (bounds && areBoundsInitialized(bounds)) {\n          nothingVisible = false;\n          if (bounds[0] < model.allBounds[0]) {\n            model.allBounds[0] = bounds[0];\n          }\n          if (bounds[1] > model.allBounds[1]) {\n            model.allBounds[1] = bounds[1];\n          }\n          if (bounds[2] < model.allBounds[2]) {\n            model.allBounds[2] = bounds[2];\n          }\n          if (bounds[3] > model.allBounds[3]) {\n            model.allBounds[3] = bounds[3];\n          }\n          if (bounds[4] < model.allBounds[4]) {\n            model.allBounds[4] = bounds[4];\n          }\n          if (bounds[5] > model.allBounds[5]) {\n            model.allBounds[5] = bounds[5];\n          }\n        }\n      }\n    }\n    if (nothingVisible) {\n      uninitializeBounds(model.allBounds);\n      vtkDebugMacro(\"Can't compute bounds, no 3D props are visible\");\n    }\n    return model.allBounds;\n  };\n  publicAPI.resetCamera = function () {\n    let bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();\n    const center = [0, 0, 0];\n    if (!areBoundsInitialized(boundsToUse)) {\n      vtkDebugMacro('Cannot reset camera!');\n      return false;\n    }\n    let vn = null;\n    if (publicAPI.getActiveCamera()) {\n      vn = model.activeCamera.getViewPlaneNormal();\n    } else {\n      vtkErrorMacro('Trying to reset non-existent camera');\n      return false;\n    }\n\n    // Reset the perspective zoom factors, otherwise subsequent zooms will cause\n    // the view angle to become very small and cause bad depth sorting.\n    model.activeCamera.setViewAngle(30.0);\n    center[0] = (boundsToUse[0] + boundsToUse[1]) / 2.0;\n    center[1] = (boundsToUse[2] + boundsToUse[3]) / 2.0;\n    center[2] = (boundsToUse[4] + boundsToUse[5]) / 2.0;\n    let w1 = boundsToUse[1] - boundsToUse[0];\n    let w2 = boundsToUse[3] - boundsToUse[2];\n    let w3 = boundsToUse[5] - boundsToUse[4];\n    w1 *= w1;\n    w2 *= w2;\n    w3 *= w3;\n    let radius = w1 + w2 + w3;\n\n    // If we have just a single point, pick a radius of 1.0\n    radius = radius === 0 ? 1.0 : radius;\n\n    // compute the radius of the enclosing sphere\n    radius = Math.sqrt(radius) * 0.5;\n\n    // default so that the bounding sphere fits within the view fustrum\n\n    // compute the distance from the intersection of the view frustum with the\n    // bounding sphere. Basically in 2D draw a circle representing the bounding\n    // sphere in 2D then draw a horizontal line going out from the center of\n    // the circle. That is the camera view. Then draw a line from the camera\n    // position to the point where it intersects the circle. (it will be tangent\n    // to the circle at this point, this is important, only go to the tangent\n    // point, do not draw all the way to the view plane). Then draw the radius\n    // from the tangent point to the center of the circle. You will note that\n    // this forms a right triangle with one side being the radius, another being\n    // the target distance for the camera, then just find the target dist using\n    // a sin.\n    const angle = radiansFromDegrees(model.activeCamera.getViewAngle());\n    const parallelScale = radius;\n    const distance = radius / Math.sin(angle * 0.5);\n\n    // check view-up vector against view plane normal\n    const vup = model.activeCamera.getViewUp();\n    if (Math.abs(dot(vup, vn)) > 0.999) {\n      vtkWarningMacro('Resetting view-up since view plane normal is parallel');\n      model.activeCamera.setViewUp(-vup[2], vup[0], vup[1]);\n    }\n\n    // update the camera\n    model.activeCamera.setFocalPoint(center[0], center[1], center[2]);\n    model.activeCamera.setPosition(center[0] + distance * vn[0], center[1] + distance * vn[1], center[2] + distance * vn[2]);\n    publicAPI.resetCameraClippingRange(boundsToUse);\n\n    // setup default parallel scale\n    model.activeCamera.setParallelScale(parallelScale);\n\n    // update reasonable world to physical values\n    model.activeCamera.setPhysicalScale(radius);\n    model.activeCamera.setPhysicalTranslation(-center[0], -center[1], -center[2]);\n\n    // Here to let parallel/distributed compositing intercept\n    // and do the right thing.\n    publicAPI.invokeEvent(RESET_CAMERA_EVENT);\n    return true;\n  };\n  publicAPI.resetCameraClippingRange = function () {\n    let bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();\n    if (!areBoundsInitialized(boundsToUse)) {\n      vtkDebugMacro('Cannot reset camera clipping range!');\n      return false;\n    }\n\n    // Make sure we have an active camera\n    publicAPI.getActiveCameraAndResetIfCreated();\n    if (!model.activeCamera) {\n      vtkErrorMacro('Trying to reset clipping range of non-existent camera');\n      return false;\n    }\n\n    // Get the exact range for the bounds\n    const range = model.activeCamera.computeClippingRange(boundsToUse);\n\n    // do not let far - near be less than 0.1 of the window height\n    // this is for cases such as 2D images which may have zero range\n    let minGap = 0.0;\n    if (model.activeCamera.getParallelProjection()) {\n      minGap = 0.2 * model.activeCamera.getParallelScale();\n    } else {\n      const angle = radiansFromDegrees(model.activeCamera.getViewAngle());\n      minGap = 0.2 * Math.tan(angle / 2.0) * range[1];\n    }\n    if (range[1] - range[0] < minGap) {\n      minGap = minGap - range[1] + range[0];\n      range[1] += minGap / 2.0;\n      range[0] -= minGap / 2.0;\n    }\n\n    // Do not let the range behind the camera throw off the calculation.\n    if (range[0] < 0.0) {\n      range[0] = 0.0;\n    }\n\n    // Give ourselves a little breathing room\n    range[0] = 0.99 * range[0] - (range[1] - range[0]) * model.clippingRangeExpansion;\n    range[1] = 1.01 * range[1] + (range[1] - range[0]) * model.clippingRangeExpansion;\n\n    // Make sure near is not bigger than far\n    range[0] = range[0] >= range[1] ? 0.01 * range[1] : range[0];\n\n    // Make sure near is at least some fraction of far - this prevents near\n    // from being behind the camera or too close in front. How close is too\n    // close depends on the resolution of the depth buffer\n    if (!model.nearClippingPlaneTolerance) {\n      model.nearClippingPlaneTolerance = 0.01;\n    }\n\n    // make sure the front clipping range is not too far from the far clippnig\n    // range, this is to make sure that the zbuffer resolution is effectively\n    // used\n    if (range[0] < model.nearClippingPlaneTolerance * range[1]) {\n      range[0] = model.nearClippingPlaneTolerance * range[1];\n    }\n    model.activeCamera.setClippingRange(range[0], range[1]);\n\n    // Here to let parallel/distributed compositing intercept\n    // and do the right thing.\n    publicAPI.invokeEvent(RESET_CAMERA_CLIPPING_RANGE_EVENT);\n    return false;\n  };\n  publicAPI.setRenderWindow = renderWindow => {\n    if (renderWindow !== model._renderWindow) {\n      model._vtkWindow = renderWindow;\n      model._renderWindow = renderWindow;\n    }\n  };\n  publicAPI.visibleActorCount = () => model.props.filter(prop => prop.getVisibility()).length;\n  publicAPI.visibleVolumeCount = publicAPI.visibleActorCount;\n  publicAPI.getMTime = () => {\n    let m1 = model.mtime;\n    const m2 = model.activeCamera ? model.activeCamera.getMTime() : 0;\n    if (m2 > m1) {\n      m1 = m2;\n    }\n    const m3 = model._createdLight ? model._createdLight.getMTime() : 0;\n    if (m3 > m1) {\n      m1 = m3;\n    }\n    return m1;\n  };\n  publicAPI.getTransparent = () => !!model.preserveColorBuffer;\n  publicAPI.isActiveCameraCreated = () => !!model.activeCamera;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  pickedProp: null,\n  activeCamera: null,\n  allBounds: [],\n  ambient: [1, 1, 1],\n  allocatedRenderTime: 100,\n  timeFactor: 1,\n  automaticLightCreation: true,\n  twoSidedLighting: true,\n  lastRenderTimeInSeconds: -1,\n  renderWindow: null,\n  lights: [],\n  actors: [],\n  volumes: [],\n  lightFollowCamera: true,\n  numberOfPropsRendered: 0,\n  propArray: null,\n  pathArray: null,\n  layer: 0,\n  preserveColorBuffer: false,\n  preserveDepthBuffer: false,\n  computeVisiblePropBounds: createUninitializedBounds(),\n  interactive: true,\n  nearClippingPlaneTolerance: 0,\n  clippingRangeExpansion: 0.05,\n  erase: true,\n  draw: true,\n  useShadows: false,\n  useDepthPeeling: false,\n  occlusionRatio: 0,\n  maximumNumberOfPeels: 4,\n  selector: null,\n  delegate: null,\n  texturedBackground: false,\n  backgroundTexture: null,\n  environmentTexture: null,\n  environmentTextureDiffuseStrength: 1,\n  environmentTextureSpecularStrength: 1,\n  useEnvironmentTextureAsBackground: false,\n  pass: 0\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewport.extend(publicAPI, model, initialValues);\n\n  // make sure background has 4 entries. Default to opaque black\n  if (!model.background) model.background = [0, 0, 0, 1];\n  while (model.background.length < 3) model.background.push(0);\n  if (model.background.length === 3) model.background.push(1);\n\n  // Build VTK API\n  get(publicAPI, model, ['_renderWindow', 'allocatedRenderTime', 'timeFactor', 'lastRenderTimeInSeconds', 'numberOfPropsRendered', 'lastRenderingUsedDepthPeeling', 'selector']);\n  setGet(publicAPI, model, ['twoSidedLighting', 'lightFollowCamera', 'automaticLightCreation', 'erase', 'draw', 'nearClippingPlaneTolerance', 'clippingRangeExpansion', 'backingStore', 'interactive', 'layer', 'preserveColorBuffer', 'preserveDepthBuffer', 'useDepthPeeling', 'occlusionRatio', 'maximumNumberOfPeels', 'delegate', 'backgroundTexture', 'texturedBackground', 'environmentTexture', 'environmentTextureDiffuseStrength', 'environmentTextureSpecularStrength', 'useEnvironmentTextureAsBackground', 'useShadows', 'pass']);\n  getArray(publicAPI, model, ['actors', 'volumes', 'lights']);\n  setGetArray(publicAPI, model, ['background'], 4, 1.0);\n  moveToProtected(publicAPI, model, ['renderWindow']);\n\n  // Object methods\n  vtkRenderer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkRenderer');\n\n// ----------------------------------------------------------------------------\n\nvar vtkRenderer$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkRenderer$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}