{"ast":null,"code":"import { m as macro } from '../../macros2.js';\nimport { b as roundVector, c as clampVector } from '../Core/Math/index.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkDataSet from './DataSet.js';\nimport vtkStructuredData from './StructuredData.js';\nimport { StructuredType } from './StructuredData/Constants.js';\nimport { mat3, mat4, vec3 } from 'gl-matrix';\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageData');\n  publicAPI.setExtent = function () {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return false;\n    }\n    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {\n      inExtent[_key] = arguments[_key];\n    }\n    const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;\n    if (extentArray.length !== 6) {\n      return false;\n    }\n    const changeDetected = model.extent.some((item, index) => item !== extentArray[index]);\n    if (changeDetected) {\n      model.extent = extentArray.slice();\n      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);\n      publicAPI.modified();\n    }\n    return changeDetected;\n  };\n  publicAPI.setDimensions = function () {\n    let i;\n    let j;\n    let k;\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n    if (arguments.length === 1) {\n      const array = arguments.length <= 0 ? undefined : arguments[0];\n      i = array[0];\n      j = array[1];\n      k = array[2];\n    } else if (arguments.length === 3) {\n      i = arguments.length <= 0 ? undefined : arguments[0];\n      j = arguments.length <= 1 ? undefined : arguments[1];\n      k = arguments.length <= 2 ? undefined : arguments[2];\n    } else {\n      vtkErrorMacro('Bad dimension specification');\n      return;\n    }\n    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);\n  };\n  publicAPI.getDimensions = () => [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];\n  publicAPI.getNumberOfCells = () => {\n    const dims = publicAPI.getDimensions();\n    let nCells = 1;\n    for (let i = 0; i < 3; i++) {\n      if (dims[i] === 0) {\n        return 0;\n      }\n      if (dims[i] > 1) {\n        nCells *= dims[i] - 1;\n      }\n    }\n    return nCells;\n  };\n  publicAPI.getNumberOfPoints = () => {\n    const dims = publicAPI.getDimensions();\n    return dims[0] * dims[1] * dims[2];\n  };\n  publicAPI.getPoint = index => {\n    const dims = publicAPI.getDimensions();\n    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {\n      vtkErrorMacro('Requesting a point from an empty image.');\n      return null;\n    }\n    const ijk = new Float64Array(3);\n    switch (model.dataDescription) {\n      case StructuredType.EMPTY:\n        return null;\n      case StructuredType.SINGLE_POINT:\n        break;\n      case StructuredType.X_LINE:\n        ijk[0] = index;\n        break;\n      case StructuredType.Y_LINE:\n        ijk[1] = index;\n        break;\n      case StructuredType.Z_LINE:\n        ijk[2] = index;\n        break;\n      case StructuredType.XY_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0];\n        break;\n      case StructuredType.YZ_PLANE:\n        ijk[1] = index % dims[1];\n        ijk[2] = index / dims[1];\n        break;\n      case StructuredType.XZ_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[2] = index / dims[0];\n        break;\n      case StructuredType.XYZ_GRID:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0] % dims[1];\n        ijk[2] = index / (dims[0] * dims[1]);\n        break;\n      default:\n        vtkErrorMacro('Invalid dataDescription');\n        break;\n    }\n    const coords = [0, 0, 0];\n    publicAPI.indexToWorld(ijk, coords);\n    return coords;\n  };\n\n  // vtkCell *GetCell(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCell(vtkIdType cellId, vtkGenericCell *cell) VTK_OVERRIDE;\n  // void GetCellBounds(vtkIdType cellId, double bounds[6]) VTK_OVERRIDE;\n  // virtual vtkIdType FindPoint(double x, double y, double z)\n  // {\n  //   return this->vtkDataSet::FindPoint(x, y, z);\n  // }\n  // vtkIdType FindPoint(double x[3]) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkIdType cellId, double tol2,\n  //   int& subId, double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkGenericCell *gencell,\n  //   vtkIdType cellId, double tol2, int& subId,\n  //   double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkCell *FindAndGetCell(double x[3], vtkCell *cell, vtkIdType cellId,\n  //                                 double tol2, int& subId, double pcoords[3],\n  //                                 double *weights) VTK_OVERRIDE;\n  // int GetCellType(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetCellPoints(cellId,ptIds,this->DataDescription,\n  //                                     this->GetDimensions());}\n  // void GetPointCells(vtkIdType ptId, vtkIdList *cellIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetPointCells(ptId,cellIds,this->GetDimensions());}\n  // void ComputeBounds() VTK_OVERRIDE;\n  // int GetMaxCellSize() VTK_OVERRIDE {return 8;}; //voxel is the largest\n\n  publicAPI.getBounds = () => publicAPI.extentToBounds(publicAPI.getSpatialExtent());\n  publicAPI.extentToBounds = ex => vtkBoundingBox.transformBounds(ex, model.indexToWorld);\n  publicAPI.getSpatialExtent = () => vtkBoundingBox.inflate([...model.extent], 0.5);\n\n  // Internal, shouldn't need to call this manually.\n  publicAPI.computeTransforms = () => {\n    mat4.fromTranslation(model.indexToWorld, model.origin);\n    model.indexToWorld[0] = model.direction[0];\n    model.indexToWorld[1] = model.direction[1];\n    model.indexToWorld[2] = model.direction[2];\n    model.indexToWorld[4] = model.direction[3];\n    model.indexToWorld[5] = model.direction[4];\n    model.indexToWorld[6] = model.direction[5];\n    model.indexToWorld[8] = model.direction[6];\n    model.indexToWorld[9] = model.direction[7];\n    model.indexToWorld[10] = model.direction[8];\n    mat4.scale(model.indexToWorld, model.indexToWorld, model.spacing);\n    mat4.invert(model.worldToIndex, model.indexToWorld);\n  };\n  publicAPI.indexToWorld = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.indexToWorld);\n    return aout;\n  };\n  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;\n  publicAPI.worldToIndex = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.worldToIndex);\n    return aout;\n  };\n  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;\n  publicAPI.indexToWorldBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.indexToWorld, bout);\n  };\n  publicAPI.worldToIndexBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.worldToIndex, bout);\n  };\n\n  // Make sure the transform is correct\n  publicAPI.onModified(publicAPI.computeTransforms);\n  publicAPI.computeTransforms();\n  publicAPI.getCenter = () => vtkBoundingBox.getCenter(publicAPI.getBounds());\n  publicAPI.computeHistogram = function (worldBounds) {\n    let voxelFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const bounds = [0, 0, 0, 0, 0, 0];\n    publicAPI.worldToIndexBounds(worldBounds, bounds);\n    const point1 = [0, 0, 0];\n    const point2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);\n    roundVector(point1, point1);\n    roundVector(point2, point2);\n    const dimensions = publicAPI.getDimensions();\n    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);\n    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);\n    const yStride = dimensions[0];\n    const zStride = dimensions[0] * dimensions[1];\n    const pixels = publicAPI.getPointData().getScalars().getData();\n    let maximum = -Infinity;\n    let minimum = Infinity;\n    let sumOfSquares = 0;\n    let isum = 0;\n    let inum = 0;\n    for (let z = point1[2]; z <= point2[2]; z++) {\n      for (let y = point1[1]; y <= point2[1]; y++) {\n        let index = point1[0] + y * yStride + z * zStride;\n        for (let x = point1[0]; x <= point2[0]; x++) {\n          if (!voxelFunc || voxelFunc([x, y, z], bounds)) {\n            const pixel = pixels[index];\n            if (pixel > maximum) maximum = pixel;\n            if (pixel < minimum) minimum = pixel;\n            sumOfSquares += pixel * pixel;\n            isum += pixel;\n            inum += 1;\n          }\n          ++index;\n        }\n      }\n    }\n    const average = inum > 0 ? isum / inum : 0;\n    const variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;\n    const sigma = Math.sqrt(variance);\n    return {\n      minimum,\n      maximum,\n      average,\n      variance,\n      sigma,\n      count: inum\n    };\n  };\n\n  // TODO: use the unimplemented `vtkDataSetAttributes` for scalar length, that is currently also a TODO (GetNumberOfComponents).\n  // Scalar data could be tuples for color information?\n  publicAPI.computeIncrements = function (extent) {\n    let numberOfComponents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const increments = [];\n    let incr = numberOfComponents;\n\n    // Calculate array increment offsets\n    // similar to c++ vtkImageData::ComputeIncrements\n    for (let idx = 0; idx < 3; ++idx) {\n      increments[idx] = incr;\n      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;\n    }\n    return increments;\n  };\n\n  /**\n   * @param {Number[]} index the localized `[i,j,k]` pixel array position. Float values will be rounded.\n   * @return {Number} the corresponding flattened index in the scalar array\n   */\n  publicAPI.computeOffsetIndex = _ref => {\n    let [i, j, k] = _ref;\n    const extent = publicAPI.getExtent();\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    const increments = publicAPI.computeIncrements(extent, numberOfComponents);\n    // Use the array increments to find the pixel index\n    // similar to c++ vtkImageData::GetArrayPointer\n    // Math.floor to catch \"practically 0\" e^-15 scenarios.\n    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);\n  };\n\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @return {Number|NaN} the corresponding pixel's index in the scalar array\n   */\n  publicAPI.getOffsetIndexFromWorld = xyz => {\n    const extent = publicAPI.getExtent();\n    const index = publicAPI.worldToIndex(xyz);\n\n    // Confirm indexed i,j,k coords are within the bounds of the volume\n    for (let idx = 0; idx < 3; ++idx) {\n      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {\n        vtkErrorMacro(`GetScalarPointer: Pixel ${index} is not in memory. Current extent = ${extent}`);\n        return NaN;\n      }\n    }\n\n    // Assumed the index here is within 0 <-> scalarData.length, but doesn't hurt to check upstream\n    return publicAPI.computeOffsetIndex(index);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @param {Number?} comp the scalar component index for multi-component scalars\n   * @return {Number|NaN} the corresponding pixel's scalar value\n   */\n  publicAPI.getScalarValueFromWorld = function (xyz) {\n    let comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    if (comp < 0 || comp >= numberOfComponents) {\n      vtkErrorMacro(`GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`);\n      return NaN;\n    }\n    const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);\n    if (Number.isNaN(offsetIndex)) {\n      // VTK Error Macro will have been tripped already, no need to do it again,\n      return offsetIndex;\n    }\n    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  direction: null,\n  // a mat3\n  indexToWorld: null,\n  // a mat4\n  worldToIndex: null,\n  // a mat4\n  spacing: [1.0, 1.0, 1.0],\n  origin: [0.0, 0.0, 0.0],\n  extent: [0, -1, 0, -1, 0, -1],\n  dataDescription: StructuredType.EMPTY\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkDataSet.extend(publicAPI, model, initialValues);\n  if (!model.direction) {\n    model.direction = mat3.identity(new Float64Array(9));\n  } else if (Array.isArray(model.direction)) {\n    model.direction = new Float64Array(model.direction.slice(0, 9));\n  }\n  model.indexToWorld = new Float64Array(16);\n  model.worldToIndex = new Float64Array(16);\n\n  // Set/Get methods\n  macro.get(publicAPI, model, ['indexToWorld', 'worldToIndex']);\n  macro.setGetArray(publicAPI, model, ['origin', 'spacing'], 3);\n  macro.setGetArray(publicAPI, model, ['direction'], 9);\n  macro.getArray(publicAPI, model, ['extent'], 6);\n\n  // Object specific methods\n  vtkImageData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageData$1 = {\n  newInstance,\n  extend\n};\nexport { vtkImageData$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","b","roundVector","c","clampVector","vtkBoundingBox","vtkDataSet","vtkStructuredData","StructuredType","mat3","mat4","vec3","vtkErrorMacro","vtkImageData","publicAPI","model","classHierarchy","push","setExtent","deleted","_len","arguments","length","inExtent","Array","_key","extentArray","changeDetected","extent","some","item","index","slice","dataDescription","getDataDescriptionFromExtent","modified","setDimensions","i","j","k","array","undefined","getDimensions","getNumberOfCells","dims","nCells","getNumberOfPoints","getPoint","ijk","Float64Array","EMPTY","SINGLE_POINT","X_LINE","Y_LINE","Z_LINE","XY_PLANE","YZ_PLANE","XZ_PLANE","XYZ_GRID","coords","indexToWorld","getBounds","extentToBounds","getSpatialExtent","ex","transformBounds","inflate","computeTransforms","fromTranslation","origin","direction","scale","spacing","invert","worldToIndex","ain","aout","transformMat4","indexToWorldVec3","worldToIndexVec3","indexToWorldBounds","bin","bout","worldToIndexBounds","onModified","getCenter","computeHistogram","worldBounds","voxelFunc","bounds","point1","point2","computeCornerPoints","dimensions","yStride","zStride","pixels","getPointData","getScalars","getData","maximum","Infinity","minimum","sumOfSquares","isum","inum","z","y","x","pixel","average","variance","Math","abs","sigma","sqrt","count","computeIncrements","numberOfComponents","increments","incr","idx","computeOffsetIndex","_ref","getExtent","getNumberOfComponents","floor","round","getOffsetIndexFromWorld","xyz","NaN","getScalarValueFromWorld","comp","offsetIndex","Number","isNaN","getComponent","DEFAULT_VALUES","extend","initialValues","Object","assign","identity","isArray","get","setGetArray","getArray","newInstance","vtkImageData$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport { b as roundVector, c as clampVector } from '../Core/Math/index.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkDataSet from './DataSet.js';\nimport vtkStructuredData from './StructuredData.js';\nimport { StructuredType } from './StructuredData/Constants.js';\nimport { mat3, mat4, vec3 } from 'gl-matrix';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageData');\n  publicAPI.setExtent = function () {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return false;\n    }\n    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {\n      inExtent[_key] = arguments[_key];\n    }\n    const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;\n    if (extentArray.length !== 6) {\n      return false;\n    }\n    const changeDetected = model.extent.some((item, index) => item !== extentArray[index]);\n    if (changeDetected) {\n      model.extent = extentArray.slice();\n      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);\n      publicAPI.modified();\n    }\n    return changeDetected;\n  };\n  publicAPI.setDimensions = function () {\n    let i;\n    let j;\n    let k;\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n    if (arguments.length === 1) {\n      const array = arguments.length <= 0 ? undefined : arguments[0];\n      i = array[0];\n      j = array[1];\n      k = array[2];\n    } else if (arguments.length === 3) {\n      i = arguments.length <= 0 ? undefined : arguments[0];\n      j = arguments.length <= 1 ? undefined : arguments[1];\n      k = arguments.length <= 2 ? undefined : arguments[2];\n    } else {\n      vtkErrorMacro('Bad dimension specification');\n      return;\n    }\n    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);\n  };\n  publicAPI.getDimensions = () => [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];\n  publicAPI.getNumberOfCells = () => {\n    const dims = publicAPI.getDimensions();\n    let nCells = 1;\n    for (let i = 0; i < 3; i++) {\n      if (dims[i] === 0) {\n        return 0;\n      }\n      if (dims[i] > 1) {\n        nCells *= dims[i] - 1;\n      }\n    }\n    return nCells;\n  };\n  publicAPI.getNumberOfPoints = () => {\n    const dims = publicAPI.getDimensions();\n    return dims[0] * dims[1] * dims[2];\n  };\n  publicAPI.getPoint = index => {\n    const dims = publicAPI.getDimensions();\n    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {\n      vtkErrorMacro('Requesting a point from an empty image.');\n      return null;\n    }\n    const ijk = new Float64Array(3);\n    switch (model.dataDescription) {\n      case StructuredType.EMPTY:\n        return null;\n      case StructuredType.SINGLE_POINT:\n        break;\n      case StructuredType.X_LINE:\n        ijk[0] = index;\n        break;\n      case StructuredType.Y_LINE:\n        ijk[1] = index;\n        break;\n      case StructuredType.Z_LINE:\n        ijk[2] = index;\n        break;\n      case StructuredType.XY_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0];\n        break;\n      case StructuredType.YZ_PLANE:\n        ijk[1] = index % dims[1];\n        ijk[2] = index / dims[1];\n        break;\n      case StructuredType.XZ_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[2] = index / dims[0];\n        break;\n      case StructuredType.XYZ_GRID:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0] % dims[1];\n        ijk[2] = index / (dims[0] * dims[1]);\n        break;\n      default:\n        vtkErrorMacro('Invalid dataDescription');\n        break;\n    }\n    const coords = [0, 0, 0];\n    publicAPI.indexToWorld(ijk, coords);\n    return coords;\n  };\n\n  // vtkCell *GetCell(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCell(vtkIdType cellId, vtkGenericCell *cell) VTK_OVERRIDE;\n  // void GetCellBounds(vtkIdType cellId, double bounds[6]) VTK_OVERRIDE;\n  // virtual vtkIdType FindPoint(double x, double y, double z)\n  // {\n  //   return this->vtkDataSet::FindPoint(x, y, z);\n  // }\n  // vtkIdType FindPoint(double x[3]) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkIdType cellId, double tol2,\n  //   int& subId, double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkGenericCell *gencell,\n  //   vtkIdType cellId, double tol2, int& subId,\n  //   double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkCell *FindAndGetCell(double x[3], vtkCell *cell, vtkIdType cellId,\n  //                                 double tol2, int& subId, double pcoords[3],\n  //                                 double *weights) VTK_OVERRIDE;\n  // int GetCellType(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetCellPoints(cellId,ptIds,this->DataDescription,\n  //                                     this->GetDimensions());}\n  // void GetPointCells(vtkIdType ptId, vtkIdList *cellIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetPointCells(ptId,cellIds,this->GetDimensions());}\n  // void ComputeBounds() VTK_OVERRIDE;\n  // int GetMaxCellSize() VTK_OVERRIDE {return 8;}; //voxel is the largest\n\n  publicAPI.getBounds = () => publicAPI.extentToBounds(publicAPI.getSpatialExtent());\n  publicAPI.extentToBounds = ex => vtkBoundingBox.transformBounds(ex, model.indexToWorld);\n  publicAPI.getSpatialExtent = () => vtkBoundingBox.inflate([...model.extent], 0.5);\n\n  // Internal, shouldn't need to call this manually.\n  publicAPI.computeTransforms = () => {\n    mat4.fromTranslation(model.indexToWorld, model.origin);\n    model.indexToWorld[0] = model.direction[0];\n    model.indexToWorld[1] = model.direction[1];\n    model.indexToWorld[2] = model.direction[2];\n    model.indexToWorld[4] = model.direction[3];\n    model.indexToWorld[5] = model.direction[4];\n    model.indexToWorld[6] = model.direction[5];\n    model.indexToWorld[8] = model.direction[6];\n    model.indexToWorld[9] = model.direction[7];\n    model.indexToWorld[10] = model.direction[8];\n    mat4.scale(model.indexToWorld, model.indexToWorld, model.spacing);\n    mat4.invert(model.worldToIndex, model.indexToWorld);\n  };\n  publicAPI.indexToWorld = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.indexToWorld);\n    return aout;\n  };\n  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;\n  publicAPI.worldToIndex = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.worldToIndex);\n    return aout;\n  };\n  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;\n  publicAPI.indexToWorldBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.indexToWorld, bout);\n  };\n  publicAPI.worldToIndexBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.worldToIndex, bout);\n  };\n\n  // Make sure the transform is correct\n  publicAPI.onModified(publicAPI.computeTransforms);\n  publicAPI.computeTransforms();\n  publicAPI.getCenter = () => vtkBoundingBox.getCenter(publicAPI.getBounds());\n  publicAPI.computeHistogram = function (worldBounds) {\n    let voxelFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const bounds = [0, 0, 0, 0, 0, 0];\n    publicAPI.worldToIndexBounds(worldBounds, bounds);\n    const point1 = [0, 0, 0];\n    const point2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);\n    roundVector(point1, point1);\n    roundVector(point2, point2);\n    const dimensions = publicAPI.getDimensions();\n    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);\n    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);\n    const yStride = dimensions[0];\n    const zStride = dimensions[0] * dimensions[1];\n    const pixels = publicAPI.getPointData().getScalars().getData();\n    let maximum = -Infinity;\n    let minimum = Infinity;\n    let sumOfSquares = 0;\n    let isum = 0;\n    let inum = 0;\n    for (let z = point1[2]; z <= point2[2]; z++) {\n      for (let y = point1[1]; y <= point2[1]; y++) {\n        let index = point1[0] + y * yStride + z * zStride;\n        for (let x = point1[0]; x <= point2[0]; x++) {\n          if (!voxelFunc || voxelFunc([x, y, z], bounds)) {\n            const pixel = pixels[index];\n            if (pixel > maximum) maximum = pixel;\n            if (pixel < minimum) minimum = pixel;\n            sumOfSquares += pixel * pixel;\n            isum += pixel;\n            inum += 1;\n          }\n          ++index;\n        }\n      }\n    }\n    const average = inum > 0 ? isum / inum : 0;\n    const variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;\n    const sigma = Math.sqrt(variance);\n    return {\n      minimum,\n      maximum,\n      average,\n      variance,\n      sigma,\n      count: inum\n    };\n  };\n\n  // TODO: use the unimplemented `vtkDataSetAttributes` for scalar length, that is currently also a TODO (GetNumberOfComponents).\n  // Scalar data could be tuples for color information?\n  publicAPI.computeIncrements = function (extent) {\n    let numberOfComponents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const increments = [];\n    let incr = numberOfComponents;\n\n    // Calculate array increment offsets\n    // similar to c++ vtkImageData::ComputeIncrements\n    for (let idx = 0; idx < 3; ++idx) {\n      increments[idx] = incr;\n      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;\n    }\n    return increments;\n  };\n\n  /**\n   * @param {Number[]} index the localized `[i,j,k]` pixel array position. Float values will be rounded.\n   * @return {Number} the corresponding flattened index in the scalar array\n   */\n  publicAPI.computeOffsetIndex = _ref => {\n    let [i, j, k] = _ref;\n    const extent = publicAPI.getExtent();\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    const increments = publicAPI.computeIncrements(extent, numberOfComponents);\n    // Use the array increments to find the pixel index\n    // similar to c++ vtkImageData::GetArrayPointer\n    // Math.floor to catch \"practically 0\" e^-15 scenarios.\n    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);\n  };\n\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @return {Number|NaN} the corresponding pixel's index in the scalar array\n   */\n  publicAPI.getOffsetIndexFromWorld = xyz => {\n    const extent = publicAPI.getExtent();\n    const index = publicAPI.worldToIndex(xyz);\n\n    // Confirm indexed i,j,k coords are within the bounds of the volume\n    for (let idx = 0; idx < 3; ++idx) {\n      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {\n        vtkErrorMacro(`GetScalarPointer: Pixel ${index} is not in memory. Current extent = ${extent}`);\n        return NaN;\n      }\n    }\n\n    // Assumed the index here is within 0 <-> scalarData.length, but doesn't hurt to check upstream\n    return publicAPI.computeOffsetIndex(index);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @param {Number?} comp the scalar component index for multi-component scalars\n   * @return {Number|NaN} the corresponding pixel's scalar value\n   */\n  publicAPI.getScalarValueFromWorld = function (xyz) {\n    let comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    if (comp < 0 || comp >= numberOfComponents) {\n      vtkErrorMacro(`GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`);\n      return NaN;\n    }\n    const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);\n    if (Number.isNaN(offsetIndex)) {\n      // VTK Error Macro will have been tripped already, no need to do it again,\n      return offsetIndex;\n    }\n    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  direction: null,\n  // a mat3\n  indexToWorld: null,\n  // a mat4\n  worldToIndex: null,\n  // a mat4\n  spacing: [1.0, 1.0, 1.0],\n  origin: [0.0, 0.0, 0.0],\n  extent: [0, -1, 0, -1, 0, -1],\n  dataDescription: StructuredType.EMPTY\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkDataSet.extend(publicAPI, model, initialValues);\n  if (!model.direction) {\n    model.direction = mat3.identity(new Float64Array(9));\n  } else if (Array.isArray(model.direction)) {\n    model.direction = new Float64Array(model.direction.slice(0, 9));\n  }\n  model.indexToWorld = new Float64Array(16);\n  model.worldToIndex = new Float64Array(16);\n\n  // Set/Get methods\n  macro.get(publicAPI, model, ['indexToWorld', 'worldToIndex']);\n  macro.setGetArray(publicAPI, model, ['origin', 'spacing'], 3);\n  macro.setGetArray(publicAPI, model, ['direction'], 9);\n  macro.getArray(publicAPI, model, ['extent'], 6);\n\n  // Object specific methods\n  vtkImageData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageData$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageData$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}