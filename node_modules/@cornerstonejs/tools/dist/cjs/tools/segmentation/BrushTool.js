"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@cornerstonejs/core");
const gl_matrix_1 = require("gl-matrix");
const base_1 = require("../base");
const fillSphere_1 = require("./strategies/fillSphere");
const eraseSphere_1 = require("./strategies/eraseSphere");
const fillCircle_1 = require("./strategies/fillCircle");
const eraseCircle_1 = require("./strategies/eraseCircle");
const enums_1 = require("../../enums");
const drawingSvg_1 = require("../../drawingSvg");
const elementCursor_1 = require("../../cursors/elementCursor");
const triggerAnnotationRenderForViewportIds_1 = __importDefault(require("../../utilities/triggerAnnotationRenderForViewportIds"));
const segmentation_1 = require("../../stateManagement/segmentation");
const stackVolumeCheck_1 = require("./strategies/utils/stackVolumeCheck");
class BrushTool extends base_1.BaseTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            strategies: {
                FILL_INSIDE_CIRCLE: fillCircle_1.fillInsideCircle,
                ERASE_INSIDE_CIRCLE: eraseCircle_1.eraseInsideCircle,
                FILL_INSIDE_SPHERE: fillSphere_1.fillInsideSphere,
                ERASE_INSIDE_SPHERE: eraseSphere_1.eraseInsideSphere,
                THRESHOLD_INSIDE_CIRCLE: fillCircle_1.thresholdInsideCircle,
                THRESHOLD_INSIDE_SPHERE: fillSphere_1.thresholdInsideSphere,
            },
            strategySpecificConfiguration: {
                THRESHOLD: {
                    threshold: [-150, -70],
                },
            },
            defaultStrategy: 'FILL_INSIDE_CIRCLE',
            activeStrategy: 'FILL_INSIDE_CIRCLE',
            thresholdVolumeId: null,
            brushSize: 25,
            preview: {
                enabled: false,
                previewColors: {},
                previewTimeMs: 250,
                previewMoveDistance: 8,
                dragMoveDistance: 4,
                dragTimeMs: 500,
            },
            actions: {
                [enums_1.StrategyCallbacks.AcceptPreview]: {
                    method: enums_1.StrategyCallbacks.AcceptPreview,
                    bindings: [
                        {
                            key: 'Enter',
                        },
                    ],
                },
                [enums_1.StrategyCallbacks.RejectPreview]: {
                    method: enums_1.StrategyCallbacks.RejectPreview,
                    bindings: [
                        {
                            key: 'Escape',
                        },
                    ],
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this._previewData = {
            preview: null,
            element: null,
            timerStart: 0,
            timer: null,
            startPoint: [NaN, NaN],
            isDrag: false,
        };
        this.onSetToolPassive = (evt) => {
            this.disableCursor();
        };
        this.onSetToolEnabled = () => {
            this.disableCursor();
        };
        this.onSetToolDisabled = (evt) => {
            this.disableCursor();
        };
        this.preMouseDownCallback = (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const enabledElement = (0, core_1.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            this._editData = this.createEditData(element);
            this._activateDraw(element);
            (0, elementCursor_1.hideElementCursor)(element);
            evt.preventDefault();
            this._previewData.isDrag = false;
            this._previewData.timerStart = Date.now();
            const hoverData = this._hoverData || this.createHoverData(element);
            (0, triggerAnnotationRenderForViewportIds_1.default)(renderingEngine, hoverData.viewportIdsToRender);
            this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), enums_1.StrategyCallbacks.OnInteractionStart);
            return true;
        };
        this.mouseMoveCallback = (evt) => {
            if (this.mode === enums_1.ToolModes.Active) {
                this.updateCursor(evt);
                if (!this.configuration.preview.enabled) {
                    return;
                }
                const { previewTimeMs, previewMoveDistance, dragMoveDistance } = this.configuration.preview;
                const { currentPoints, element } = evt.detail;
                const { canvas } = currentPoints;
                const { preview, startPoint, timer, timerStart, isDrag } = this._previewData;
                const delta = gl_matrix_1.vec2.distance(canvas, startPoint);
                const time = Date.now() - timerStart;
                if (delta > previewMoveDistance ||
                    (time > previewTimeMs && delta > dragMoveDistance)) {
                    if (timer) {
                        window.clearTimeout(timer);
                        this._previewData.timer = null;
                    }
                    if (preview && !isDrag) {
                        this.rejectPreview(element);
                    }
                }
                if (!this._previewData.timer) {
                    const timer = window.setTimeout(this.previewCallback, 250);
                    Object.assign(this._previewData, {
                        timerStart: Date.now(),
                        timer,
                        startPoint: canvas,
                        element,
                    });
                }
            }
        };
        this.previewCallback = () => {
            if (this._previewData.preview) {
                return;
            }
            this._previewData.timer = null;
            this._previewData.preview = this.applyActiveStrategyCallback((0, core_1.getEnabledElement)(this._previewData.element), this.getOperationData(this._previewData.element), enums_1.StrategyCallbacks.Preview);
        };
        this._dragCallback = (evt) => {
            const eventData = evt.detail;
            const { element, currentPoints } = eventData;
            const enabledElement = (0, core_1.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            this.updateCursor(evt);
            const { viewportIdsToRender } = this._hoverData;
            (0, triggerAnnotationRenderForViewportIds_1.default)(renderingEngine, viewportIdsToRender);
            const delta = gl_matrix_1.vec2.distance(currentPoints.canvas, this._previewData.startPoint);
            const { dragTimeMs, dragMoveDistance } = this.configuration.preview;
            if (!this._previewData.isDrag &&
                this._previewData.preview &&
                Date.now() - this._previewData.timerStart < dragTimeMs &&
                delta < dragMoveDistance) {
                return;
            }
            this._previewData.preview = this.applyActiveStrategy(enabledElement, this.getOperationData(element));
            this._previewData.element = element;
            this._previewData.timerStart = Date.now() + dragTimeMs;
            this._previewData.isDrag = true;
            this._previewData.startPoint = currentPoints.canvas;
        };
        this._endCallback = (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const enabledElement = (0, core_1.getEnabledElement)(element);
            const operationData = this.getOperationData(element);
            if (!this._previewData.preview && !this._previewData.isDrag) {
                this.applyActiveStrategy(enabledElement, operationData);
            }
            this._deactivateDraw(element);
            (0, elementCursor_1.resetElementCursor)(element);
            this.updateCursor(evt);
            this._editData = null;
            this.applyActiveStrategyCallback(enabledElement, operationData, enums_1.StrategyCallbacks.OnInteractionEnd);
            if (!this._previewData.isDrag) {
                this.acceptPreview(element);
            }
        };
        this._activateDraw = (element) => {
            element.addEventListener(enums_1.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums_1.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums_1.Events.MOUSE_CLICK, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(enums_1.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums_1.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums_1.Events.MOUSE_CLICK, this._endCallback);
        };
    }
    disableCursor() {
        this._hoverData = undefined;
        this.rejectPreview();
    }
    createEditData(element) {
        var _a, _b, _c;
        const enabledElement = (0, core_1.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const toolGroupId = this.toolGroupId;
        const activeSegmentationRepresentation = segmentation_1.activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);
        if (!activeSegmentationRepresentation) {
            throw new Error('No active segmentation detected, create a segmentation representation before using the brush tool');
        }
        const { segmentationId, type, segmentationRepresentationUID } = activeSegmentationRepresentation;
        if (type === enums_1.SegmentationRepresentations.Contour) {
            throw new Error('Not implemented yet');
        }
        const segmentsLocked = segmentation_1.segmentLocking.getLockedSegments(segmentationId);
        const { representationData } = segmentation_1.state.getSegmentation(segmentationId);
        const labelmapData = representationData[enums_1.SegmentationRepresentations.Labelmap];
        if ((0, stackVolumeCheck_1.isVolumeSegmentation)(labelmapData, viewport)) {
            const { volumeId } = representationData[type];
            const actors = viewport.getActors();
            const isStackViewport = viewport instanceof core_1.StackViewport;
            if (isStackViewport) {
                const event = new CustomEvent(core_1.Enums.Events.ERROR_EVENT, {
                    detail: {
                        type: 'Segmentation',
                        message: 'Cannot perform brush operation on the selected viewport',
                    },
                    cancelable: true,
                });
                core_1.eventTarget.dispatchEvent(event);
                return null;
            }
            const volumes = actors.map((actorEntry) => core_1.cache.getVolume(actorEntry.referenceId));
            const segmentationVolume = core_1.cache.getVolume(volumeId);
            const referencedVolumeIdToThreshold = ((_a = volumes.find((volume) => core_1.utilities.isEqual(volume.dimensions, segmentationVolume.dimensions))) === null || _a === void 0 ? void 0 : _a.volumeId) || ((_b = volumes[0]) === null || _b === void 0 ? void 0 : _b.volumeId);
            return {
                volumeId,
                referencedVolumeId: (_c = this.configuration.thresholdVolumeId) !== null && _c !== void 0 ? _c : referencedVolumeIdToThreshold,
                segmentsLocked,
                segmentationRepresentationUID,
            };
        }
        else {
            const { imageIdReferenceMap } = labelmapData;
            const currentImageId = viewport.getCurrentImageId();
            if (!imageIdReferenceMap.get(currentImageId)) {
                return;
            }
            if (this.configuration.activeStrategy.includes('SPHERE')) {
                throw new Error('Sphere manipulation is not supported for stacks of image segmentations yet');
            }
            return {
                imageIdReferenceMap,
                segmentsLocked,
                segmentationRepresentationUID,
            };
        }
    }
    createHoverData(element, centerCanvas) {
        const enabledElement = (0, core_1.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const { viewPlaneNormal, viewUp } = camera;
        const viewportIdsToRender = [viewport.id];
        const { segmentIndex, segmentationId, segmentationRepresentationUID, segmentColor, } = this.getActiveSegmentationData() || {};
        const brushCursor = {
            metadata: {
                viewPlaneNormal: [...viewPlaneNormal],
                viewUp: [...viewUp],
                FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                referencedImageId: '',
                toolName: this.getToolName(),
                segmentColor,
            },
            data: {},
        };
        return {
            brushCursor,
            centerCanvas,
            segmentIndex,
            segmentationId,
            segmentationRepresentationUID,
            segmentColor,
            viewportIdsToRender,
        };
    }
    getActiveSegmentationData() {
        const toolGroupId = this.toolGroupId;
        const activeSegmentationRepresentation = segmentation_1.activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);
        if (!activeSegmentationRepresentation) {
            console.warn('No active segmentation detected, create one before using the brush tool');
            return;
        }
        const { segmentationRepresentationUID, segmentationId } = activeSegmentationRepresentation;
        const segmentIndex = segmentation_1.segmentIndex.getActiveSegmentIndex(segmentationId);
        const segmentColor = segmentation_1.config.color.getColorForSegmentIndex(toolGroupId, segmentationRepresentationUID, segmentIndex);
        return {
            segmentIndex,
            segmentationId,
            segmentationRepresentationUID,
            segmentColor,
        };
    }
    updateCursor(evt) {
        const eventData = evt.detail;
        const { element } = eventData;
        const { currentPoints } = eventData;
        const centerCanvas = currentPoints.canvas;
        this._hoverData = this.createHoverData(element, centerCanvas);
        this._calculateCursor(element, centerCanvas);
        if (!this._hoverData) {
            return;
        }
        (0, triggerAnnotationRenderForViewportIds_1.default)((0, core_1.getEnabledElement)(element).renderingEngine, this._hoverData.viewportIdsToRender);
    }
    getOperationData(element) {
        var _a, _b;
        const editData = this._editData || this.createEditData(element);
        const { segmentIndex, segmentationId, segmentationRepresentationUID, brushCursor, } = this._hoverData || this.createHoverData(element);
        const { data, metadata = {} } = brushCursor || {};
        const { viewPlaneNormal, viewUp } = metadata;
        const operationData = Object.assign(Object.assign({}, editData), { points: (_a = data === null || data === void 0 ? void 0 : data.handles) === null || _a === void 0 ? void 0 : _a.points, segmentIndex, previewColors: this.configuration.preview.enabled
                ? this.configuration.preview.previewColors
                : null, viewPlaneNormal, toolGroupId: this.toolGroupId, segmentationId,
            segmentationRepresentationUID,
            viewUp, strategySpecificConfiguration: this.configuration.strategySpecificConfiguration, preview: (_b = this._previewData) === null || _b === void 0 ? void 0 : _b.preview });
        return operationData;
    }
    _calculateCursor(element, centerCanvas) {
        const enabledElement = (0, core_1.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { canvasToWorld } = viewport;
        const camera = viewport.getCamera();
        const { brushSize } = this.configuration;
        const viewUp = gl_matrix_1.vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);
        const viewPlaneNormal = gl_matrix_1.vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);
        const viewRight = gl_matrix_1.vec3.create();
        gl_matrix_1.vec3.cross(viewRight, viewUp, viewPlaneNormal);
        const centerCursorInWorld = canvasToWorld([
            centerCanvas[0],
            centerCanvas[1],
        ]);
        const bottomCursorInWorld = gl_matrix_1.vec3.create();
        const topCursorInWorld = gl_matrix_1.vec3.create();
        const leftCursorInWorld = gl_matrix_1.vec3.create();
        const rightCursorInWorld = gl_matrix_1.vec3.create();
        for (let i = 0; i <= 2; i++) {
            bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;
            topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;
            leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;
            rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;
        }
        if (!this._hoverData) {
            return;
        }
        const { brushCursor } = this._hoverData;
        const { data } = brushCursor;
        if (data.handles === undefined) {
            data.handles = {};
        }
        data.handles.points = [
            bottomCursorInWorld,
            topCursorInWorld,
            leftCursorInWorld,
            rightCursorInWorld,
        ];
        const activeStrategy = this.configuration.activeStrategy;
        const strategy = this.configuration.strategies[activeStrategy];
        if (typeof strategy.computeInnerCircleRadius === 'function') {
            strategy.computeInnerCircleRadius({
                configuration: this.configuration,
                viewport,
            });
        }
        data.invalidated = false;
    }
    rejectPreview(element = this._previewData.element) {
        if (!element || !this._previewData.preview) {
            return;
        }
        const enabledElement = (0, core_1.getEnabledElement)(element);
        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), enums_1.StrategyCallbacks.RejectPreview);
        this._previewData.preview = null;
        this._previewData.isDrag = false;
    }
    acceptPreview(element = this._previewData.element) {
        if (!element) {
            return;
        }
        const enabledElement = (0, core_1.getEnabledElement)(element);
        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), enums_1.StrategyCallbacks.AcceptPreview);
        this._previewData.isDrag = false;
        this._previewData.preview = null;
    }
    invalidateBrushCursor() {
        if (this._hoverData === undefined) {
            return;
        }
        const { data } = this._hoverData.brushCursor;
        data.invalidated = true;
        const { segmentColor } = this.getActiveSegmentationData() || {};
        this._hoverData.brushCursor.metadata.segmentColor = segmentColor;
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        var _a;
        if (!this._hoverData) {
            return;
        }
        const { viewport } = enabledElement;
        const viewportIdsToRender = this._hoverData.viewportIdsToRender;
        if (!viewportIdsToRender.includes(viewport.id)) {
            return;
        }
        const brushCursor = this._hoverData.brushCursor;
        if (brushCursor.data.invalidated === true) {
            const { centerCanvas } = this._hoverData;
            const { element } = viewport;
            this._calculateCursor(element, centerCanvas);
        }
        const toolMetadata = brushCursor.metadata;
        if (!toolMetadata) {
            return;
        }
        const annotationUID = toolMetadata.brushCursorUID;
        const data = brushCursor.data;
        const { points } = data.handles;
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        const bottom = canvasCoordinates[0];
        const top = canvasCoordinates[1];
        const center = [
            Math.floor((bottom[0] + top[0]) / 2),
            Math.floor((bottom[1] + top[1]) / 2),
        ];
        const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));
        const color = `rgb(${((_a = toolMetadata.segmentColor) === null || _a === void 0 ? void 0 : _a.slice(0, 3)) || [0, 0, 0]})`;
        if (!viewport.getRenderingEngine()) {
            console.warn('Rendering Engine has been destroyed');
            return;
        }
        const circleUID = '0';
        (0, drawingSvg_1.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
            color,
        });
        const activeStrategy = this.configuration.activeStrategy;
        const { dynamicRadiusInCanvas } = this.configuration
            .strategySpecificConfiguration[activeStrategy] || {
            dynamicRadiusInCanvas: 0,
        };
        if (dynamicRadiusInCanvas) {
            const circleUID1 = '1';
            (0, drawingSvg_1.drawCircle)(svgDrawingHelper, annotationUID, circleUID1, center, dynamicRadiusInCanvas, {
                color,
            });
        }
    }
}
BrushTool.toolName = 'Brush';
exports.default = BrushTool;
//# sourceMappingURL=BrushTool.js.map