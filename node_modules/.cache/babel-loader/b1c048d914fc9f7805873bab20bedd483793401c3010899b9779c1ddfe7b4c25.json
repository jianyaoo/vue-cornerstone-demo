{"ast":null,"code":"import { m as macro } from '../../macros2.js';\nimport vtkFieldData from './DataSetAttributes/FieldData.js';\nimport Constants from './DataSetAttributes/Constants.js';\nimport vtkDataArray from '../Core/DataArray.js';\nconst {\n  AttributeTypes,\n  AttributeCopyOperations\n} = Constants;\nconst {\n  vtkWarningMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkDataSetAttributes methods\n// ----------------------------------------------------------------------------\n\nfunction vtkDataSetAttributes(publicAPI, model) {\n  const attrTypes = ['Scalars', 'Vectors', 'Normals', 'TCoords', 'Tensors', 'GlobalIds', 'PedigreeIds'];\n  function cleanAttributeType(attType) {\n    // Given an integer or string, convert the result to one of the\n    // strings in the \"attrTypes\" array above or null (if\n    // no match is found)\n    let cleanAttType = attrTypes.find(ee => AttributeTypes[ee.toUpperCase()] === attType || typeof attType !== 'number' && ee.toLowerCase() === attType.toLowerCase());\n    if (typeof cleanAttType === 'undefined') {\n      cleanAttType = null;\n    }\n    return cleanAttType;\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkDataSetAttributes');\n  const superClass = {\n    ...publicAPI\n  };\n  publicAPI.checkNumberOfComponents = x => true; // TODO\n\n  publicAPI.setAttribute = (arr, uncleanAttType) => {\n    const attType = cleanAttributeType(uncleanAttType);\n    if (arr && attType.toUpperCase() === 'PEDIGREEIDS' && !arr.isA('vtkDataArray')) {\n      vtkWarningMacro(`Cannot set attribute ${attType}. The attribute must be a vtkDataArray.`);\n      return -1;\n    }\n    if (arr && !publicAPI.checkNumberOfComponents(arr, attType)) {\n      vtkWarningMacro(`Cannot set attribute ${attType}. Incorrect number of components.`);\n      return -1;\n    }\n    let currentAttribute = model[`active${attType}`];\n    if (currentAttribute >= 0 && currentAttribute < model.arrays.length) {\n      if (model.arrays[currentAttribute] === arr) {\n        return currentAttribute;\n      }\n      // FIXME setting an array actually changes its index\n      publicAPI.removeArrayByIndex(currentAttribute);\n    }\n    if (arr) {\n      currentAttribute = publicAPI.addArray(arr);\n      model[`active${attType}`] = currentAttribute;\n    } else {\n      model[`active${attType}`] = -1;\n    }\n    publicAPI.modified();\n    return model[`active${attType}`];\n  };\n  publicAPI.getAttributes = arr => attrTypes.filter(attrType => publicAPI[`get${attrType}`]() === arr);\n  publicAPI.setActiveAttributeByName = (arrayName, attType) => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, attType);\n  publicAPI.setActiveAttributeByIndex = (arrayIdx, uncleanAttType) => {\n    const attType = cleanAttributeType(uncleanAttType);\n    if (arrayIdx >= 0 && arrayIdx < model.arrays.length) {\n      if (attType.toUpperCase() !== 'PEDIGREEIDS') {\n        const arr = publicAPI.getArrayByIndex(arrayIdx);\n        if (!arr.isA('vtkDataArray')) {\n          vtkWarningMacro(`Cannot set attribute ${attType}. Only vtkDataArray subclasses can be set as active attributes.`);\n          return -1;\n        }\n        if (!publicAPI.checkNumberOfComponents(arr, attType)) {\n          vtkWarningMacro(`Cannot set attribute ${attType}. Incorrect number of components.`);\n          return -1;\n        }\n      }\n      model[`active${attType}`] = arrayIdx;\n      publicAPI.modified();\n      return arrayIdx;\n    }\n    if (arrayIdx === -1) {\n      model[`active${attType}`] = arrayIdx;\n      publicAPI.modified();\n    }\n    return -1;\n  };\n  publicAPI.getActiveAttribute = attType => {\n    // Given an integer enum value or a string (with random capitalization),\n    // find the matching string in attrTypes.\n    const cleanAttType = cleanAttributeType(attType);\n    return publicAPI[`get${cleanAttType}`]();\n  };\n\n  // Override to allow proper handling of active attributes\n  publicAPI.removeAllArrays = () => {\n    attrTypes.forEach(attType => {\n      model[`active${attType}`] = -1;\n    });\n    superClass.removeAllArrays();\n  };\n\n  // Override to allow proper handling of active attributes\n  publicAPI.removeArrayByIndex = arrayIdx => {\n    if (arrayIdx !== -1) {\n      attrTypes.forEach(attType => {\n        if (arrayIdx === model[`active${attType}`]) {\n          model[`active${attType}`] = -1;\n        } else if (arrayIdx < model[`active${attType}`]) {\n          model[`active${attType}`] -= 1;\n        }\n      });\n    }\n    return superClass.removeArrayByIndex(arrayIdx);\n  };\n  attrTypes.forEach(value => {\n    const activeVal = `active${value}`;\n    publicAPI[`get${value}`] = () => publicAPI.getArrayByIndex(model[activeVal]);\n    publicAPI[`set${value}`] = da => publicAPI.setAttribute(da, value);\n    publicAPI[`setActive${value}`] = arrayName => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, value);\n    publicAPI[`copy${value}Off`] = () => {\n      const attType = value.toUpperCase();\n      model.copyAttributeFlags[AttributeCopyOperations.PASSDATA][AttributeTypes[attType]] = false;\n    };\n    publicAPI[`copy${value}On`] = () => {\n      const attType = value.toUpperCase();\n      model.copyAttributeFlags[AttributeCopyOperations.PASSDATA][AttributeTypes[attType]] = true;\n    };\n  });\n  publicAPI.initializeAttributeCopyFlags = () => {\n    // Default to copying all attributes in every circumstance:\n    model.copyAttributeFlags = [];\n    Object.keys(AttributeCopyOperations).filter(op => op !== 'ALLCOPY').forEach(attCopyOp => {\n      model.copyAttributeFlags[AttributeCopyOperations[attCopyOp]] = Object.keys(AttributeTypes).filter(ty => ty !== 'NUM_ATTRIBUTES').reduce((a, b) => {\n        a[AttributeTypes[b]] = true;\n        return a;\n      }, []);\n    });\n    // Override some operations where we don't want to copy:\n    model.copyAttributeFlags[AttributeCopyOperations.COPYTUPLE][AttributeTypes.GLOBALIDS] = false;\n    model.copyAttributeFlags[AttributeCopyOperations.INTERPOLATE][AttributeTypes.GLOBALIDS] = false;\n    model.copyAttributeFlags[AttributeCopyOperations.COPYTUPLE][AttributeTypes.PEDIGREEIDS] = false;\n  };\n  publicAPI.initialize = macro.chain(publicAPI.initialize, publicAPI.initializeAttributeCopyFlags);\n\n  // Process dataArrays if any\n  if (model.dataArrays && Object.keys(model.dataArrays).length) {\n    Object.keys(model.dataArrays).forEach(name => {\n      if (!model.dataArrays[name].ref && model.dataArrays[name].type === 'vtkDataArray') {\n        publicAPI.addArray(vtkDataArray.newInstance(model.dataArrays[name]));\n      }\n    });\n  }\n  const superShallowCopy = publicAPI.shallowCopy;\n  publicAPI.shallowCopy = (other, debug) => {\n    superShallowCopy(other, debug);\n    model.arrays = other.getArrays().map(arr => {\n      const arrNew = arr.newClone();\n      arrNew.shallowCopy(arr, debug);\n      return {\n        data: arrNew\n      };\n    });\n  };\n  publicAPI.initializeAttributeCopyFlags();\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  activeScalars: -1,\n  activeVectors: -1,\n  activeTensors: -1,\n  activeNormals: -1,\n  activeTCoords: -1,\n  activeGlobalIds: -1,\n  activePedigreeIds: -1\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  vtkFieldData.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['activeScalars', 'activeNormals', 'activeTCoords', 'activeVectors', 'activeTensors', 'activeGlobalIds', 'activePedigreeIds']);\n  if (!model.arrays) {\n    model.arrays = {};\n  }\n\n  // Object specific methods\n  vtkDataSetAttributes(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkDataSetAttributes');\n\n// ----------------------------------------------------------------------------\n\nvar vtkDataSetAttributes$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\nexport { vtkDataSetAttributes$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkFieldData","Constants","vtkDataArray","AttributeTypes","AttributeCopyOperations","vtkWarningMacro","vtkDataSetAttributes","publicAPI","model","attrTypes","cleanAttributeType","attType","cleanAttType","find","ee","toUpperCase","toLowerCase","classHierarchy","push","superClass","checkNumberOfComponents","x","setAttribute","arr","uncleanAttType","isA","currentAttribute","arrays","length","removeArrayByIndex","addArray","modified","getAttributes","filter","attrType","setActiveAttributeByName","arrayName","setActiveAttributeByIndex","getArrayWithIndex","index","arrayIdx","getArrayByIndex","getActiveAttribute","removeAllArrays","forEach","value","activeVal","da","copyAttributeFlags","PASSDATA","initializeAttributeCopyFlags","Object","keys","op","attCopyOp","ty","reduce","a","b","COPYTUPLE","GLOBALIDS","INTERPOLATE","PEDIGREEIDS","initialize","chain","dataArrays","name","ref","type","newInstance","superShallowCopy","shallowCopy","other","debug","getArrays","map","arrNew","newClone","data","DEFAULT_VALUES","activeScalars","activeVectors","activeTensors","activeNormals","activeTCoords","activeGlobalIds","activePedigreeIds","extend","initialValues","arguments","undefined","assign","setGet","vtkDataSetAttributes$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkFieldData from './DataSetAttributes/FieldData.js';\nimport Constants from './DataSetAttributes/Constants.js';\nimport vtkDataArray from '../Core/DataArray.js';\n\nconst {\n  AttributeTypes,\n  AttributeCopyOperations\n} = Constants;\nconst {\n  vtkWarningMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkDataSetAttributes methods\n// ----------------------------------------------------------------------------\n\nfunction vtkDataSetAttributes(publicAPI, model) {\n  const attrTypes = ['Scalars', 'Vectors', 'Normals', 'TCoords', 'Tensors', 'GlobalIds', 'PedigreeIds'];\n  function cleanAttributeType(attType) {\n    // Given an integer or string, convert the result to one of the\n    // strings in the \"attrTypes\" array above or null (if\n    // no match is found)\n    let cleanAttType = attrTypes.find(ee => AttributeTypes[ee.toUpperCase()] === attType || typeof attType !== 'number' && ee.toLowerCase() === attType.toLowerCase());\n    if (typeof cleanAttType === 'undefined') {\n      cleanAttType = null;\n    }\n    return cleanAttType;\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkDataSetAttributes');\n  const superClass = {\n    ...publicAPI\n  };\n  publicAPI.checkNumberOfComponents = x => true; // TODO\n\n  publicAPI.setAttribute = (arr, uncleanAttType) => {\n    const attType = cleanAttributeType(uncleanAttType);\n    if (arr && attType.toUpperCase() === 'PEDIGREEIDS' && !arr.isA('vtkDataArray')) {\n      vtkWarningMacro(`Cannot set attribute ${attType}. The attribute must be a vtkDataArray.`);\n      return -1;\n    }\n    if (arr && !publicAPI.checkNumberOfComponents(arr, attType)) {\n      vtkWarningMacro(`Cannot set attribute ${attType}. Incorrect number of components.`);\n      return -1;\n    }\n    let currentAttribute = model[`active${attType}`];\n    if (currentAttribute >= 0 && currentAttribute < model.arrays.length) {\n      if (model.arrays[currentAttribute] === arr) {\n        return currentAttribute;\n      }\n      // FIXME setting an array actually changes its index\n      publicAPI.removeArrayByIndex(currentAttribute);\n    }\n    if (arr) {\n      currentAttribute = publicAPI.addArray(arr);\n      model[`active${attType}`] = currentAttribute;\n    } else {\n      model[`active${attType}`] = -1;\n    }\n    publicAPI.modified();\n    return model[`active${attType}`];\n  };\n  publicAPI.getAttributes = arr => attrTypes.filter(attrType => publicAPI[`get${attrType}`]() === arr);\n  publicAPI.setActiveAttributeByName = (arrayName, attType) => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, attType);\n  publicAPI.setActiveAttributeByIndex = (arrayIdx, uncleanAttType) => {\n    const attType = cleanAttributeType(uncleanAttType);\n    if (arrayIdx >= 0 && arrayIdx < model.arrays.length) {\n      if (attType.toUpperCase() !== 'PEDIGREEIDS') {\n        const arr = publicAPI.getArrayByIndex(arrayIdx);\n        if (!arr.isA('vtkDataArray')) {\n          vtkWarningMacro(`Cannot set attribute ${attType}. Only vtkDataArray subclasses can be set as active attributes.`);\n          return -1;\n        }\n        if (!publicAPI.checkNumberOfComponents(arr, attType)) {\n          vtkWarningMacro(`Cannot set attribute ${attType}. Incorrect number of components.`);\n          return -1;\n        }\n      }\n      model[`active${attType}`] = arrayIdx;\n      publicAPI.modified();\n      return arrayIdx;\n    }\n    if (arrayIdx === -1) {\n      model[`active${attType}`] = arrayIdx;\n      publicAPI.modified();\n    }\n    return -1;\n  };\n  publicAPI.getActiveAttribute = attType => {\n    // Given an integer enum value or a string (with random capitalization),\n    // find the matching string in attrTypes.\n    const cleanAttType = cleanAttributeType(attType);\n    return publicAPI[`get${cleanAttType}`]();\n  };\n\n  // Override to allow proper handling of active attributes\n  publicAPI.removeAllArrays = () => {\n    attrTypes.forEach(attType => {\n      model[`active${attType}`] = -1;\n    });\n    superClass.removeAllArrays();\n  };\n\n  // Override to allow proper handling of active attributes\n  publicAPI.removeArrayByIndex = arrayIdx => {\n    if (arrayIdx !== -1) {\n      attrTypes.forEach(attType => {\n        if (arrayIdx === model[`active${attType}`]) {\n          model[`active${attType}`] = -1;\n        } else if (arrayIdx < model[`active${attType}`]) {\n          model[`active${attType}`] -= 1;\n        }\n      });\n    }\n    return superClass.removeArrayByIndex(arrayIdx);\n  };\n  attrTypes.forEach(value => {\n    const activeVal = `active${value}`;\n    publicAPI[`get${value}`] = () => publicAPI.getArrayByIndex(model[activeVal]);\n    publicAPI[`set${value}`] = da => publicAPI.setAttribute(da, value);\n    publicAPI[`setActive${value}`] = arrayName => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, value);\n    publicAPI[`copy${value}Off`] = () => {\n      const attType = value.toUpperCase();\n      model.copyAttributeFlags[AttributeCopyOperations.PASSDATA][AttributeTypes[attType]] = false;\n    };\n    publicAPI[`copy${value}On`] = () => {\n      const attType = value.toUpperCase();\n      model.copyAttributeFlags[AttributeCopyOperations.PASSDATA][AttributeTypes[attType]] = true;\n    };\n  });\n  publicAPI.initializeAttributeCopyFlags = () => {\n    // Default to copying all attributes in every circumstance:\n    model.copyAttributeFlags = [];\n    Object.keys(AttributeCopyOperations).filter(op => op !== 'ALLCOPY').forEach(attCopyOp => {\n      model.copyAttributeFlags[AttributeCopyOperations[attCopyOp]] = Object.keys(AttributeTypes).filter(ty => ty !== 'NUM_ATTRIBUTES').reduce((a, b) => {\n        a[AttributeTypes[b]] = true;\n        return a;\n      }, []);\n    });\n    // Override some operations where we don't want to copy:\n    model.copyAttributeFlags[AttributeCopyOperations.COPYTUPLE][AttributeTypes.GLOBALIDS] = false;\n    model.copyAttributeFlags[AttributeCopyOperations.INTERPOLATE][AttributeTypes.GLOBALIDS] = false;\n    model.copyAttributeFlags[AttributeCopyOperations.COPYTUPLE][AttributeTypes.PEDIGREEIDS] = false;\n  };\n  publicAPI.initialize = macro.chain(publicAPI.initialize, publicAPI.initializeAttributeCopyFlags);\n\n  // Process dataArrays if any\n  if (model.dataArrays && Object.keys(model.dataArrays).length) {\n    Object.keys(model.dataArrays).forEach(name => {\n      if (!model.dataArrays[name].ref && model.dataArrays[name].type === 'vtkDataArray') {\n        publicAPI.addArray(vtkDataArray.newInstance(model.dataArrays[name]));\n      }\n    });\n  }\n  const superShallowCopy = publicAPI.shallowCopy;\n  publicAPI.shallowCopy = (other, debug) => {\n    superShallowCopy(other, debug);\n    model.arrays = other.getArrays().map(arr => {\n      const arrNew = arr.newClone();\n      arrNew.shallowCopy(arr, debug);\n      return {\n        data: arrNew\n      };\n    });\n  };\n  publicAPI.initializeAttributeCopyFlags();\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  activeScalars: -1,\n  activeVectors: -1,\n  activeTensors: -1,\n  activeNormals: -1,\n  activeTCoords: -1,\n  activeGlobalIds: -1,\n  activePedigreeIds: -1\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  vtkFieldData.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['activeScalars', 'activeNormals', 'activeTCoords', 'activeVectors', 'activeTensors', 'activeGlobalIds', 'activePedigreeIds']);\n  if (!model.arrays) {\n    model.arrays = {};\n  }\n\n  // Object specific methods\n  vtkDataSetAttributes(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkDataSetAttributes');\n\n// ----------------------------------------------------------------------------\n\nvar vtkDataSetAttributes$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\nexport { vtkDataSetAttributes$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}