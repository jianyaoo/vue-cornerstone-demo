{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction getEndianness() {\n  const a = new ArrayBuffer(4);\n  const b = new Uint8Array(a);\n  const c = new Uint32Array(a);\n  b[0] = 0xa1;\n  b[1] = 0xb2;\n  b[2] = 0xc3;\n  b[3] = 0xd4;\n  if (c[0] === 0xd4c3b2a1) return 'LittleEndian';\n  if (c[0] === 0xa1b2c3d4) return 'BigEndian';\n  return null;\n}\nconst ENDIANNESS = getEndianness();\nfunction swapBytes(buffer, wordSize) {\n  if (wordSize < 2) {\n    return;\n  }\n  const bytes = new Int8Array(buffer);\n  const size = bytes.length;\n  const tempBuffer = [];\n  for (let i = 0; i < size; i += wordSize) {\n    for (let j = 0; j < wordSize; j++) {\n      tempBuffer.push(bytes[i + j]);\n    }\n    for (let j = 0; j < wordSize; j++) {\n      bytes[i + j] = tempBuffer.pop();\n    }\n  }\n}\nvar Endian = {\n  ENDIANNESS,\n  getEndianness,\n  swapBytes\n};\nexport { ENDIANNESS, Endian as default, getEndianness, swapBytes };","map":{"version":3,"names":["getEndianness","a","ArrayBuffer","b","Uint8Array","c","Uint32Array","ENDIANNESS","swapBytes","buffer","wordSize","bytes","Int8Array","size","length","tempBuffer","i","j","push","pop","Endian","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Common/Core/Endian.js"],"sourcesContent":["function getEndianness() {\n  const a = new ArrayBuffer(4);\n  const b = new Uint8Array(a);\n  const c = new Uint32Array(a);\n  b[0] = 0xa1;\n  b[1] = 0xb2;\n  b[2] = 0xc3;\n  b[3] = 0xd4;\n  if (c[0] === 0xd4c3b2a1) return 'LittleEndian';\n  if (c[0] === 0xa1b2c3d4) return 'BigEndian';\n  return null;\n}\nconst ENDIANNESS = getEndianness();\nfunction swapBytes(buffer, wordSize) {\n  if (wordSize < 2) {\n    return;\n  }\n  const bytes = new Int8Array(buffer);\n  const size = bytes.length;\n  const tempBuffer = [];\n  for (let i = 0; i < size; i += wordSize) {\n    for (let j = 0; j < wordSize; j++) {\n      tempBuffer.push(bytes[i + j]);\n    }\n    for (let j = 0; j < wordSize; j++) {\n      bytes[i + j] = tempBuffer.pop();\n    }\n  }\n}\nvar Endian = {\n  ENDIANNESS,\n  getEndianness,\n  swapBytes\n};\n\nexport { ENDIANNESS, Endian as default, getEndianness, swapBytes };\n"],"mappings":";;;;AAAA,SAASA,aAAaA,CAAA,EAAG;EACvB,MAAMC,CAAC,GAAG,IAAIC,WAAW,CAAC,CAAC,CAAC;EAC5B,MAAMC,CAAC,GAAG,IAAIC,UAAU,CAACH,CAAC,CAAC;EAC3B,MAAMI,CAAC,GAAG,IAAIC,WAAW,CAACL,CAAC,CAAC;EAC5BE,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI;EACXA,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI;EACXA,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI;EACXA,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI;EACX,IAAIE,CAAC,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE,OAAO,cAAc;EAC9C,IAAIA,CAAC,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE,OAAO,WAAW;EAC3C,OAAO,IAAI;AACb;AACA,MAAME,UAAU,GAAGP,aAAa,CAAC,CAAC;AAClC,SAASQ,SAASA,CAACC,MAAM,EAAEC,QAAQ,EAAE;EACnC,IAAIA,QAAQ,GAAG,CAAC,EAAE;IAChB;EACF;EACA,MAAMC,KAAK,GAAG,IAAIC,SAAS,CAACH,MAAM,CAAC;EACnC,MAAMI,IAAI,GAAGF,KAAK,CAACG,MAAM;EACzB,MAAMC,UAAU,GAAG,EAAE;EACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,IAAI,EAAEG,CAAC,IAAIN,QAAQ,EAAE;IACvC,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,QAAQ,EAAEO,CAAC,EAAE,EAAE;MACjCF,UAAU,CAACG,IAAI,CAACP,KAAK,CAACK,CAAC,GAAGC,CAAC,CAAC,CAAC;IAC/B;IACA,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,QAAQ,EAAEO,CAAC,EAAE,EAAE;MACjCN,KAAK,CAACK,CAAC,GAAGC,CAAC,CAAC,GAAGF,UAAU,CAACI,GAAG,CAAC,CAAC;IACjC;EACF;AACF;AACA,IAAIC,MAAM,GAAG;EACXb,UAAU;EACVP,aAAa;EACbQ;AACF,CAAC;AAED,SAASD,UAAU,EAAEa,MAAM,IAAIC,OAAO,EAAErB,aAAa,EAAEQ,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}