"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultGetSegment = void 0;
const core_1 = require("@cornerstonejs/core");
const segmentation = __importStar(require("../../stateManagement/segmentation"));
const annotation_1 = require("../../stateManagement/annotation");
const viewport_1 = require("../viewport");
const contourAndFindLargestBidirectional_1 = __importDefault(require("./contourAndFindLargestBidirectional"));
const createBidirectionalToolData_1 = __importDefault(require("./createBidirectionalToolData"));
const BidirectionalTool_1 = __importDefault(require("../../tools/annotation/BidirectionalTool"));
function segmentContourAction(element, configuration) {
    const { data: configurationData } = configuration;
    const enabledElement = (0, core_1.getEnabledElement)(element);
    const segment = (configurationData.getSegment || defaultGetSegment)(enabledElement, configurationData);
    if (!segment) {
        return;
    }
    const FrameOfReferenceUID = enabledElement.viewport.getFrameOfReferenceUID();
    const segmentationsList = segmentation.state.getSegmentations();
    const { segmentIndex, segmentationId } = segment;
    const bidirectionals = annotation_1.state.getAnnotations(this.toolName || BidirectionalTool_1.default.toolName, FrameOfReferenceUID);
    let hasExistingActiveSegment = false;
    const existingLargestBidirectionals = bidirectionals.filter((existingBidirectionalItem) => {
        const { segment } = existingBidirectionalItem.data;
        if (!segment) {
            return;
        }
        if (segment.segmentationId === segmentationId &&
            segment.segmentIndex === segmentIndex) {
            hasExistingActiveSegment = true;
            existingBidirectionalItem.data.segment = segment;
        }
        return !!segment;
    });
    if (!hasExistingActiveSegment) {
        existingLargestBidirectionals.push({
            data: { segment },
        });
    }
    let newBidirectional;
    existingLargestBidirectionals.forEach((existingLargestBidirectional) => {
        const segments = [];
        const { segment: updateSegment } = existingLargestBidirectional.data;
        const { segmentIndex, segmentationId } = updateSegment;
        segments[segmentIndex] = updateSegment;
        annotation_1.state.removeAnnotation(existingLargestBidirectional.annotationUID);
        const bidirectionalData = (0, contourAndFindLargestBidirectional_1.default)(Object.assign(Object.assign({}, segmentationsList.find((segmentation) => segmentation.segmentationId === segmentationId)), { segments }));
        if (!bidirectionalData) {
            return;
        }
        const bidirectionalToolData = (0, createBidirectionalToolData_1.default)(bidirectionalData, enabledElement.viewport);
        bidirectionalToolData.annotationUID =
            existingLargestBidirectional.annotationUID;
        bidirectionalToolData.data.segment = updateSegment;
        const annotationUID = annotation_1.state.addAnnotation(bidirectionalToolData, FrameOfReferenceUID);
        if (updateSegment.segmentIndex === segment.segmentIndex &&
            updateSegment.segmentationId === segment.segmentationId) {
            newBidirectional = bidirectionalData;
            const { style } = segment;
            if (style) {
                annotation_1.config.style.setAnnotationStyles(annotationUID, style);
            }
        }
    });
    if (newBidirectional) {
        const { sliceIndex } = newBidirectional;
        const imageIds = enabledElement.viewport.getImageIds();
        (0, viewport_1.jumpToSlice)(element, {
            imageIndex: imageIds.length - 1 - sliceIndex,
        });
        enabledElement.viewport.render();
    }
    else {
        console.warn('No bidirectional found');
    }
    return newBidirectional;
}
exports.default = segmentContourAction;
function defaultGetSegment(enabledElement, configuration) {
    var _a, _b;
    const segmentationsList = segmentation.state.getSegmentations();
    if (!segmentationsList.length) {
        return;
    }
    const segmentationId = configuration.segmentationId || segmentationsList[0].segmentationId;
    const segmentIndex = (_a = configuration.segmentIndex) !== null && _a !== void 0 ? _a : segmentation.segmentIndex.getActiveSegmentIndex(segmentationId);
    if (!segmentIndex) {
        return;
    }
    const segmentData = (_b = configuration.segmentData) === null || _b === void 0 ? void 0 : _b.get(segmentIndex);
    return Object.assign({ label: `Segment ${segmentIndex}`, segmentIndex,
        segmentationId }, segmentData);
}
exports.defaultGetSegment = defaultGetSegment;
//# sourceMappingURL=segmentContourAction.js.map