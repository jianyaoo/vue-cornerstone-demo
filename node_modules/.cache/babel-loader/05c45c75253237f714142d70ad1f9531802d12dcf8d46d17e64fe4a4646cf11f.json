{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Md5 from 'spark-md5';\nimport { m as macro } from '../../macros2.js';\nimport vtkShaderProgram from './ShaderProgram.js';\n\n// ----------------------------------------------------------------------------\n\nconst SET_GET_FIELDS = ['lastShaderProgramBound', 'context', '_openGLRenderWindow'];\n\n// ----------------------------------------------------------------------------\n// vtkShaderCache methods\n// ----------------------------------------------------------------------------\n\nfunction vtkShaderCache(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkShaderCache');\n  publicAPI.replaceShaderValues = (VSSource, FSSource, GSSource) => {\n    // first handle renaming any Fragment shader inputs\n    // if we have a geometry shader. By default fragment shaders\n    // assume their inputs come from a Vertex Shader. When we\n    // have a Geometry shader we rename the frament shader inputs\n    // to come from the geometry shader\n\n    let nFSSource = FSSource;\n    if (GSSource.length > 0) {\n      nFSSource = vtkShaderProgram.substitute(nFSSource, 'VSOut', 'GSOut').result;\n    }\n    const gl2 = model._openGLRenderWindow.getWebgl2();\n    let fragDepthString = '\\n';\n    let version = '#version 100\\n';\n    if (gl2) {\n      version = '#version 300 es\\n' + '#define attribute in\\n' + '#define textureCube texture\\n' + '#define texture2D texture\\n' + '#define textureCubeLod textureLod\\n' + '#define texture2DLod textureLod\\n';\n    } else {\n      model.context.getExtension('OES_standard_derivatives');\n      if (model.context.getExtension('EXT_frag_depth')) {\n        fragDepthString = '#extension GL_EXT_frag_depth : enable\\n';\n      }\n      if (model.context.getExtension('EXT_shader_texture_lod')) {\n        fragDepthString += '#extension GL_EXT_shader_texture_lod : enable\\n' + '#define textureCubeLod textureCubeLodEXT\\n' + '#define texture2DLod texture2DLodEXT';\n      }\n    }\n    nFSSource = vtkShaderProgram.substitute(nFSSource, '//VTK::System::Dec', [`${version}\\n`, gl2 ? '' : '#extension GL_OES_standard_derivatives : enable\\n', fragDepthString, '#ifdef GL_FRAGMENT_PRECISION_HIGH', 'precision highp float;', 'precision highp int;', '#else', 'precision mediump float;', 'precision mediump int;', '#endif']).result;\n    let nVSSource = vtkShaderProgram.substitute(VSSource, '//VTK::System::Dec', [`${version}\\n`, '#ifdef GL_FRAGMENT_PRECISION_HIGH', 'precision highp float;', 'precision highp int;', '#else', 'precision mediump float;', 'precision mediump int;', '#endif']).result;\n    if (gl2) {\n      nVSSource = vtkShaderProgram.substitute(nVSSource, 'varying', 'out').result;\n      nFSSource = vtkShaderProgram.substitute(nFSSource, 'varying', 'in').result;\n      let shaderOutputs = '';\n      let outputCount = 0;\n      while (nFSSource.includes(`gl_FragData[${outputCount}]`)) {\n        nFSSource = vtkShaderProgram.substitute(nFSSource, `gl_FragData\\\\[${outputCount}\\\\]`, `fragOutput${outputCount}`).result;\n        shaderOutputs += `layout(location = ${outputCount}) out vec4 fragOutput${outputCount};\\n`;\n        outputCount++;\n      }\n      nFSSource = vtkShaderProgram.substitute(nFSSource, '//VTK::Output::Dec', shaderOutputs).result;\n    }\n\n    // nFSSource = ShaderProgram.substitute(nFSSource, 'gl_FragData\\\\[0\\\\]',\n    //   'gl_FragColor').result;\n\n    const nGSSource = vtkShaderProgram.substitute(GSSource, '//VTK::System::Dec', version).result;\n    return {\n      VSSource: nVSSource,\n      FSSource: nFSSource,\n      GSSource: nGSSource\n    };\n  };\n\n  // return NULL if there is an issue\n  publicAPI.readyShaderProgramArray = (vertexCode, fragmentCode, geometryCode) => {\n    const data = publicAPI.replaceShaderValues(vertexCode, fragmentCode, geometryCode);\n    const shaderProgram = publicAPI.getShaderProgram(data.VSSource, data.FSSource, data.GSSource);\n    return publicAPI.readyShaderProgram(shaderProgram);\n  };\n  publicAPI.readyShaderProgram = program => {\n    if (!program) {\n      return null;\n    }\n\n    // compile if needed\n    if (!program.getCompiled() && !program.compileShader()) {\n      return null;\n    }\n\n    // bind if needed\n    if (!publicAPI.bindShaderProgram(program)) {\n      return null;\n    }\n    return program;\n  };\n  publicAPI.getShaderProgram = (vertexCode, fragmentCode, geometryCode) => {\n    // compute the MD5 and the check the map\n    const hashInput = `${vertexCode}${fragmentCode}${geometryCode}`;\n    const result = Md5.hash(hashInput);\n\n    // does it already exist?\n    if (!(result in model.shaderPrograms)) {\n      // create one\n      const sps = vtkShaderProgram.newInstance();\n      sps.setContext(model.context);\n      sps.getVertexShader().setSource(vertexCode);\n      sps.getFragmentShader().setSource(fragmentCode);\n      if (geometryCode) {\n        sps.getGeometryShader().setSource(geometryCode);\n      }\n      sps.setMd5Hash(result);\n      model.shaderPrograms[result] = sps;\n      return sps;\n    }\n    return model.shaderPrograms[result];\n  };\n  publicAPI.releaseGraphicsResources = win => {\n    // NOTE:\n    // In the current implementation as of October 26th, if a shader\n    // program is created by ShaderCache then it should make sure\n    // that it releases the graphics resources used by these programs.\n    // It is not wisely for callers to do that since then they would\n    // have to loop over all the programs were in use and invoke\n    // release graphics resources individually.\n\n    publicAPI.releaseCurrentShaderProgram();\n    Object.keys(model.shaderPrograms).map(key => model.shaderPrograms[key]).forEach(sp => sp.cleanup());\n    model.shaderPrograms = {};\n  };\n  publicAPI.releaseCurrentShaderProgram = () => {\n    // release prior shader\n    if (model.lastShaderProgramBound) {\n      model.lastShaderProgramBound.cleanup();\n      model.lastShaderProgramBound = null;\n    }\n  };\n  publicAPI.bindShaderProgram = program => {\n    if (model.lastShaderProgramBound === program) {\n      return 1;\n    }\n\n    // release prior program\n    if (model.lastShaderProgramBound) {\n      model.lastShaderProgramBound.release();\n    }\n    program.bind();\n    model.lastShaderProgramBound = program;\n    return 1;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  lastShaderProgramBound: null,\n  shaderPrograms: null,\n  context: null\n  // _openGLRenderWindow: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Internal objects\n  model.shaderPrograms = {};\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, SET_GET_FIELDS);\n  macro.moveToProtected(publicAPI, model, ['openGLRenderWindow']);\n\n  // Object methods\n  vtkShaderCache(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkShaderCache');\n\n// ----------------------------------------------------------------------------\n\nvar vtkShaderCache$1 = {\n  newInstance,\n  extend\n};\nexport { vtkShaderCache$1 as default, extend, newInstance };","map":{"version":3,"names":["Md5","m","macro","vtkShaderProgram","SET_GET_FIELDS","vtkShaderCache","publicAPI","model","classHierarchy","push","replaceShaderValues","VSSource","FSSource","GSSource","nFSSource","length","substitute","result","gl2","_openGLRenderWindow","getWebgl2","fragDepthString","version","context","getExtension","nVSSource","shaderOutputs","outputCount","includes","nGSSource","readyShaderProgramArray","vertexCode","fragmentCode","geometryCode","data","shaderProgram","getShaderProgram","readyShaderProgram","program","getCompiled","compileShader","bindShaderProgram","hashInput","hash","shaderPrograms","sps","newInstance","setContext","getVertexShader","setSource","getFragmentShader","getGeometryShader","setMd5Hash","releaseGraphicsResources","win","releaseCurrentShaderProgram","Object","keys","map","key","forEach","sp","cleanup","lastShaderProgramBound","release","bind","DEFAULT_VALUES","extend","initialValues","arguments","undefined","assign","obj","setGet","moveToProtected","vtkShaderCache$1","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderCache.js"],"sourcesContent":["import Md5 from 'spark-md5';\nimport { m as macro } from '../../macros2.js';\nimport vtkShaderProgram from './ShaderProgram.js';\n\n// ----------------------------------------------------------------------------\n\nconst SET_GET_FIELDS = ['lastShaderProgramBound', 'context', '_openGLRenderWindow'];\n\n// ----------------------------------------------------------------------------\n// vtkShaderCache methods\n// ----------------------------------------------------------------------------\n\nfunction vtkShaderCache(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkShaderCache');\n  publicAPI.replaceShaderValues = (VSSource, FSSource, GSSource) => {\n    // first handle renaming any Fragment shader inputs\n    // if we have a geometry shader. By default fragment shaders\n    // assume their inputs come from a Vertex Shader. When we\n    // have a Geometry shader we rename the frament shader inputs\n    // to come from the geometry shader\n\n    let nFSSource = FSSource;\n    if (GSSource.length > 0) {\n      nFSSource = vtkShaderProgram.substitute(nFSSource, 'VSOut', 'GSOut').result;\n    }\n    const gl2 = model._openGLRenderWindow.getWebgl2();\n    let fragDepthString = '\\n';\n    let version = '#version 100\\n';\n    if (gl2) {\n      version = '#version 300 es\\n' + '#define attribute in\\n' + '#define textureCube texture\\n' + '#define texture2D texture\\n' + '#define textureCubeLod textureLod\\n' + '#define texture2DLod textureLod\\n';\n    } else {\n      model.context.getExtension('OES_standard_derivatives');\n      if (model.context.getExtension('EXT_frag_depth')) {\n        fragDepthString = '#extension GL_EXT_frag_depth : enable\\n';\n      }\n      if (model.context.getExtension('EXT_shader_texture_lod')) {\n        fragDepthString += '#extension GL_EXT_shader_texture_lod : enable\\n' + '#define textureCubeLod textureCubeLodEXT\\n' + '#define texture2DLod texture2DLodEXT';\n      }\n    }\n    nFSSource = vtkShaderProgram.substitute(nFSSource, '//VTK::System::Dec', [`${version}\\n`, gl2 ? '' : '#extension GL_OES_standard_derivatives : enable\\n', fragDepthString, '#ifdef GL_FRAGMENT_PRECISION_HIGH', 'precision highp float;', 'precision highp int;', '#else', 'precision mediump float;', 'precision mediump int;', '#endif']).result;\n    let nVSSource = vtkShaderProgram.substitute(VSSource, '//VTK::System::Dec', [`${version}\\n`, '#ifdef GL_FRAGMENT_PRECISION_HIGH', 'precision highp float;', 'precision highp int;', '#else', 'precision mediump float;', 'precision mediump int;', '#endif']).result;\n    if (gl2) {\n      nVSSource = vtkShaderProgram.substitute(nVSSource, 'varying', 'out').result;\n      nFSSource = vtkShaderProgram.substitute(nFSSource, 'varying', 'in').result;\n      let shaderOutputs = '';\n      let outputCount = 0;\n      while (nFSSource.includes(`gl_FragData[${outputCount}]`)) {\n        nFSSource = vtkShaderProgram.substitute(nFSSource, `gl_FragData\\\\[${outputCount}\\\\]`, `fragOutput${outputCount}`).result;\n        shaderOutputs += `layout(location = ${outputCount}) out vec4 fragOutput${outputCount};\\n`;\n        outputCount++;\n      }\n      nFSSource = vtkShaderProgram.substitute(nFSSource, '//VTK::Output::Dec', shaderOutputs).result;\n    }\n\n    // nFSSource = ShaderProgram.substitute(nFSSource, 'gl_FragData\\\\[0\\\\]',\n    //   'gl_FragColor').result;\n\n    const nGSSource = vtkShaderProgram.substitute(GSSource, '//VTK::System::Dec', version).result;\n    return {\n      VSSource: nVSSource,\n      FSSource: nFSSource,\n      GSSource: nGSSource\n    };\n  };\n\n  // return NULL if there is an issue\n  publicAPI.readyShaderProgramArray = (vertexCode, fragmentCode, geometryCode) => {\n    const data = publicAPI.replaceShaderValues(vertexCode, fragmentCode, geometryCode);\n    const shaderProgram = publicAPI.getShaderProgram(data.VSSource, data.FSSource, data.GSSource);\n    return publicAPI.readyShaderProgram(shaderProgram);\n  };\n  publicAPI.readyShaderProgram = program => {\n    if (!program) {\n      return null;\n    }\n\n    // compile if needed\n    if (!program.getCompiled() && !program.compileShader()) {\n      return null;\n    }\n\n    // bind if needed\n    if (!publicAPI.bindShaderProgram(program)) {\n      return null;\n    }\n    return program;\n  };\n  publicAPI.getShaderProgram = (vertexCode, fragmentCode, geometryCode) => {\n    // compute the MD5 and the check the map\n    const hashInput = `${vertexCode}${fragmentCode}${geometryCode}`;\n    const result = Md5.hash(hashInput);\n\n    // does it already exist?\n    if (!(result in model.shaderPrograms)) {\n      // create one\n      const sps = vtkShaderProgram.newInstance();\n      sps.setContext(model.context);\n      sps.getVertexShader().setSource(vertexCode);\n      sps.getFragmentShader().setSource(fragmentCode);\n      if (geometryCode) {\n        sps.getGeometryShader().setSource(geometryCode);\n      }\n      sps.setMd5Hash(result);\n      model.shaderPrograms[result] = sps;\n      return sps;\n    }\n    return model.shaderPrograms[result];\n  };\n  publicAPI.releaseGraphicsResources = win => {\n    // NOTE:\n    // In the current implementation as of October 26th, if a shader\n    // program is created by ShaderCache then it should make sure\n    // that it releases the graphics resources used by these programs.\n    // It is not wisely for callers to do that since then they would\n    // have to loop over all the programs were in use and invoke\n    // release graphics resources individually.\n\n    publicAPI.releaseCurrentShaderProgram();\n    Object.keys(model.shaderPrograms).map(key => model.shaderPrograms[key]).forEach(sp => sp.cleanup());\n    model.shaderPrograms = {};\n  };\n  publicAPI.releaseCurrentShaderProgram = () => {\n    // release prior shader\n    if (model.lastShaderProgramBound) {\n      model.lastShaderProgramBound.cleanup();\n      model.lastShaderProgramBound = null;\n    }\n  };\n  publicAPI.bindShaderProgram = program => {\n    if (model.lastShaderProgramBound === program) {\n      return 1;\n    }\n\n    // release prior program\n    if (model.lastShaderProgramBound) {\n      model.lastShaderProgramBound.release();\n    }\n    program.bind();\n    model.lastShaderProgramBound = program;\n    return 1;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  lastShaderProgramBound: null,\n  shaderPrograms: null,\n  context: null\n  // _openGLRenderWindow: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Internal objects\n  model.shaderPrograms = {};\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, SET_GET_FIELDS);\n  macro.moveToProtected(publicAPI, model, ['openGLRenderWindow']);\n\n  // Object methods\n  vtkShaderCache(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkShaderCache');\n\n// ----------------------------------------------------------------------------\n\nvar vtkShaderCache$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkShaderCache$1 as default, extend, newInstance };\n"],"mappings":";AAAA,OAAOA,GAAG,MAAM,WAAW;AAC3B,SAASC,CAAC,IAAIC,KAAK,QAAQ,kBAAkB;AAC7C,OAAOC,gBAAgB,MAAM,oBAAoB;;AAEjD;;AAEA,MAAMC,cAAc,GAAG,CAAC,wBAAwB,EAAE,SAAS,EAAE,qBAAqB,CAAC;;AAEnF;AACA;AACA;;AAEA,SAASC,cAAcA,CAACC,SAAS,EAAEC,KAAK,EAAE;EACxC;EACAA,KAAK,CAACC,cAAc,CAACC,IAAI,CAAC,gBAAgB,CAAC;EAC3CH,SAAS,CAACI,mBAAmB,GAAG,CAACC,QAAQ,EAAEC,QAAQ,EAAEC,QAAQ,KAAK;IAChE;IACA;IACA;IACA;IACA;;IAEA,IAAIC,SAAS,GAAGF,QAAQ;IACxB,IAAIC,QAAQ,CAACE,MAAM,GAAG,CAAC,EAAE;MACvBD,SAAS,GAAGX,gBAAgB,CAACa,UAAU,CAACF,SAAS,EAAE,OAAO,EAAE,OAAO,CAAC,CAACG,MAAM;IAC7E;IACA,MAAMC,GAAG,GAAGX,KAAK,CAACY,mBAAmB,CAACC,SAAS,CAAC,CAAC;IACjD,IAAIC,eAAe,GAAG,IAAI;IAC1B,IAAIC,OAAO,GAAG,gBAAgB;IAC9B,IAAIJ,GAAG,EAAE;MACPI,OAAO,GAAG,mBAAmB,GAAG,wBAAwB,GAAG,+BAA+B,GAAG,6BAA6B,GAAG,qCAAqC,GAAG,mCAAmC;IAC1M,CAAC,MAAM;MACLf,KAAK,CAACgB,OAAO,CAACC,YAAY,CAAC,0BAA0B,CAAC;MACtD,IAAIjB,KAAK,CAACgB,OAAO,CAACC,YAAY,CAAC,gBAAgB,CAAC,EAAE;QAChDH,eAAe,GAAG,yCAAyC;MAC7D;MACA,IAAId,KAAK,CAACgB,OAAO,CAACC,YAAY,CAAC,wBAAwB,CAAC,EAAE;QACxDH,eAAe,IAAI,iDAAiD,GAAG,4CAA4C,GAAG,sCAAsC;MAC9J;IACF;IACAP,SAAS,GAAGX,gBAAgB,CAACa,UAAU,CAACF,SAAS,EAAE,oBAAoB,EAAE,CAAE,GAAEQ,OAAQ,IAAG,EAAEJ,GAAG,GAAG,EAAE,GAAG,mDAAmD,EAAEG,eAAe,EAAE,mCAAmC,EAAE,wBAAwB,EAAE,sBAAsB,EAAE,OAAO,EAAE,0BAA0B,EAAE,wBAAwB,EAAE,QAAQ,CAAC,CAAC,CAACJ,MAAM;IAClV,IAAIQ,SAAS,GAAGtB,gBAAgB,CAACa,UAAU,CAACL,QAAQ,EAAE,oBAAoB,EAAE,CAAE,GAAEW,OAAQ,IAAG,EAAE,mCAAmC,EAAE,wBAAwB,EAAE,sBAAsB,EAAE,OAAO,EAAE,0BAA0B,EAAE,wBAAwB,EAAE,QAAQ,CAAC,CAAC,CAACL,MAAM;IACpQ,IAAIC,GAAG,EAAE;MACPO,SAAS,GAAGtB,gBAAgB,CAACa,UAAU,CAACS,SAAS,EAAE,SAAS,EAAE,KAAK,CAAC,CAACR,MAAM;MAC3EH,SAAS,GAAGX,gBAAgB,CAACa,UAAU,CAACF,SAAS,EAAE,SAAS,EAAE,IAAI,CAAC,CAACG,MAAM;MAC1E,IAAIS,aAAa,GAAG,EAAE;MACtB,IAAIC,WAAW,GAAG,CAAC;MACnB,OAAOb,SAAS,CAACc,QAAQ,CAAE,eAAcD,WAAY,GAAE,CAAC,EAAE;QACxDb,SAAS,GAAGX,gBAAgB,CAACa,UAAU,CAACF,SAAS,EAAG,iBAAgBa,WAAY,KAAI,EAAG,aAAYA,WAAY,EAAC,CAAC,CAACV,MAAM;QACxHS,aAAa,IAAK,qBAAoBC,WAAY,wBAAuBA,WAAY,KAAI;QACzFA,WAAW,EAAE;MACf;MACAb,SAAS,GAAGX,gBAAgB,CAACa,UAAU,CAACF,SAAS,EAAE,oBAAoB,EAAEY,aAAa,CAAC,CAACT,MAAM;IAChG;;IAEA;IACA;;IAEA,MAAMY,SAAS,GAAG1B,gBAAgB,CAACa,UAAU,CAACH,QAAQ,EAAE,oBAAoB,EAAES,OAAO,CAAC,CAACL,MAAM;IAC7F,OAAO;MACLN,QAAQ,EAAEc,SAAS;MACnBb,QAAQ,EAAEE,SAAS;MACnBD,QAAQ,EAAEgB;IACZ,CAAC;EACH,CAAC;;EAED;EACAvB,SAAS,CAACwB,uBAAuB,GAAG,CAACC,UAAU,EAAEC,YAAY,EAAEC,YAAY,KAAK;IAC9E,MAAMC,IAAI,GAAG5B,SAAS,CAACI,mBAAmB,CAACqB,UAAU,EAAEC,YAAY,EAAEC,YAAY,CAAC;IAClF,MAAME,aAAa,GAAG7B,SAAS,CAAC8B,gBAAgB,CAACF,IAAI,CAACvB,QAAQ,EAAEuB,IAAI,CAACtB,QAAQ,EAAEsB,IAAI,CAACrB,QAAQ,CAAC;IAC7F,OAAOP,SAAS,CAAC+B,kBAAkB,CAACF,aAAa,CAAC;EACpD,CAAC;EACD7B,SAAS,CAAC+B,kBAAkB,GAAGC,OAAO,IAAI;IACxC,IAAI,CAACA,OAAO,EAAE;MACZ,OAAO,IAAI;IACb;;IAEA;IACA,IAAI,CAACA,OAAO,CAACC,WAAW,CAAC,CAAC,IAAI,CAACD,OAAO,CAACE,aAAa,CAAC,CAAC,EAAE;MACtD,OAAO,IAAI;IACb;;IAEA;IACA,IAAI,CAAClC,SAAS,CAACmC,iBAAiB,CAACH,OAAO,CAAC,EAAE;MACzC,OAAO,IAAI;IACb;IACA,OAAOA,OAAO;EAChB,CAAC;EACDhC,SAAS,CAAC8B,gBAAgB,GAAG,CAACL,UAAU,EAAEC,YAAY,EAAEC,YAAY,KAAK;IACvE;IACA,MAAMS,SAAS,GAAI,GAAEX,UAAW,GAAEC,YAAa,GAAEC,YAAa,EAAC;IAC/D,MAAMhB,MAAM,GAAGjB,GAAG,CAAC2C,IAAI,CAACD,SAAS,CAAC;;IAElC;IACA,IAAI,EAAEzB,MAAM,IAAIV,KAAK,CAACqC,cAAc,CAAC,EAAE;MACrC;MACA,MAAMC,GAAG,GAAG1C,gBAAgB,CAAC2C,WAAW,CAAC,CAAC;MAC1CD,GAAG,CAACE,UAAU,CAACxC,KAAK,CAACgB,OAAO,CAAC;MAC7BsB,GAAG,CAACG,eAAe,CAAC,CAAC,CAACC,SAAS,CAAClB,UAAU,CAAC;MAC3Cc,GAAG,CAACK,iBAAiB,CAAC,CAAC,CAACD,SAAS,CAACjB,YAAY,CAAC;MAC/C,IAAIC,YAAY,EAAE;QAChBY,GAAG,CAACM,iBAAiB,CAAC,CAAC,CAACF,SAAS,CAAChB,YAAY,CAAC;MACjD;MACAY,GAAG,CAACO,UAAU,CAACnC,MAAM,CAAC;MACtBV,KAAK,CAACqC,cAAc,CAAC3B,MAAM,CAAC,GAAG4B,GAAG;MAClC,OAAOA,GAAG;IACZ;IACA,OAAOtC,KAAK,CAACqC,cAAc,CAAC3B,MAAM,CAAC;EACrC,CAAC;EACDX,SAAS,CAAC+C,wBAAwB,GAAGC,GAAG,IAAI;IAC1C;IACA;IACA;IACA;IACA;IACA;IACA;;IAEAhD,SAAS,CAACiD,2BAA2B,CAAC,CAAC;IACvCC,MAAM,CAACC,IAAI,CAAClD,KAAK,CAACqC,cAAc,CAAC,CAACc,GAAG,CAACC,GAAG,IAAIpD,KAAK,CAACqC,cAAc,CAACe,GAAG,CAAC,CAAC,CAACC,OAAO,CAACC,EAAE,IAAIA,EAAE,CAACC,OAAO,CAAC,CAAC,CAAC;IACnGvD,KAAK,CAACqC,cAAc,GAAG,CAAC,CAAC;EAC3B,CAAC;EACDtC,SAAS,CAACiD,2BAA2B,GAAG,MAAM;IAC5C;IACA,IAAIhD,KAAK,CAACwD,sBAAsB,EAAE;MAChCxD,KAAK,CAACwD,sBAAsB,CAACD,OAAO,CAAC,CAAC;MACtCvD,KAAK,CAACwD,sBAAsB,GAAG,IAAI;IACrC;EACF,CAAC;EACDzD,SAAS,CAACmC,iBAAiB,GAAGH,OAAO,IAAI;IACvC,IAAI/B,KAAK,CAACwD,sBAAsB,KAAKzB,OAAO,EAAE;MAC5C,OAAO,CAAC;IACV;;IAEA;IACA,IAAI/B,KAAK,CAACwD,sBAAsB,EAAE;MAChCxD,KAAK,CAACwD,sBAAsB,CAACC,OAAO,CAAC,CAAC;IACxC;IACA1B,OAAO,CAAC2B,IAAI,CAAC,CAAC;IACd1D,KAAK,CAACwD,sBAAsB,GAAGzB,OAAO;IACtC,OAAO,CAAC;EACV,CAAC;AACH;;AAEA;AACA;AACA;;AAEA,MAAM4B,cAAc,GAAG;EACrBH,sBAAsB,EAAE,IAAI;EAC5BnB,cAAc,EAAE,IAAI;EACpBrB,OAAO,EAAE;EACT;AACF,CAAC;;AAED;;AAEA,SAAS4C,MAAMA,CAAC7D,SAAS,EAAEC,KAAK,EAAE;EAChC,IAAI6D,aAAa,GAAGC,SAAS,CAACtD,MAAM,GAAG,CAAC,IAAIsD,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;EAC1Fb,MAAM,CAACe,MAAM,CAAChE,KAAK,EAAE2D,cAAc,EAAEE,aAAa,CAAC;;EAEnD;EACA7D,KAAK,CAACqC,cAAc,GAAG,CAAC,CAAC;;EAEzB;EACA1C,KAAK,CAACsE,GAAG,CAAClE,SAAS,EAAEC,KAAK,CAAC;EAC3BL,KAAK,CAACuE,MAAM,CAACnE,SAAS,EAAEC,KAAK,EAAEH,cAAc,CAAC;EAC9CF,KAAK,CAACwE,eAAe,CAACpE,SAAS,EAAEC,KAAK,EAAE,CAAC,oBAAoB,CAAC,CAAC;;EAE/D;EACAF,cAAc,CAACC,SAAS,EAAEC,KAAK,CAAC;AAClC;;AAEA;;AAEA,MAAMuC,WAAW,GAAG5C,KAAK,CAAC4C,WAAW,CAACqB,MAAM,EAAE,gBAAgB,CAAC;;AAE/D;;AAEA,IAAIQ,gBAAgB,GAAG;EACrB7B,WAAW;EACXqB;AACF,CAAC;AAED,SAASQ,gBAAgB,IAAIC,OAAO,EAAET,MAAM,EAAErB,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}