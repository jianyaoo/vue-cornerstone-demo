{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { d as dot } from '../Core/Math/index.js';\nimport { vec3 } from 'gl-matrix';\nimport vtkPlane from './Plane.js';\nconst INIT_BOUNDS = [Number.MAX_VALUE, -Number.MAX_VALUE,\n// X\nNumber.MAX_VALUE, -Number.MAX_VALUE,\n// Y\nNumber.MAX_VALUE, -Number.MAX_VALUE // Z\n];\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction equals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];\n}\nfunction isValid(bounds) {\n  return bounds?.length >= 6 && bounds[0] <= bounds[1] && bounds[2] <= bounds[3] && bounds[4] <= bounds[5];\n}\nfunction setBounds(bounds, otherBounds) {\n  bounds[0] = otherBounds[0];\n  bounds[1] = otherBounds[1];\n  bounds[2] = otherBounds[2];\n  bounds[3] = otherBounds[3];\n  bounds[4] = otherBounds[4];\n  bounds[5] = otherBounds[5];\n  return bounds;\n}\nfunction reset(bounds) {\n  return setBounds(bounds, INIT_BOUNDS);\n}\nfunction addPoint(bounds, x, y, z) {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  bounds[0] = xMin < x ? xMin : x;\n  bounds[1] = xMax > x ? xMax : x;\n  bounds[2] = yMin < y ? yMin : y;\n  bounds[3] = yMax > y ? yMax : y;\n  bounds[4] = zMin < z ? zMin : z;\n  bounds[5] = zMax > z ? zMax : z;\n  return bounds;\n}\nfunction addPoints(bounds, points) {\n  if (points.length === 0) {\n    return bounds;\n  }\n  if (Array.isArray(points[0])) {\n    for (let i = 0; i < points.length; ++i) {\n      addPoint(bounds, ...points[i]);\n    }\n  } else {\n    for (let i = 0; i < points.length; i += 3) {\n      addPoint(bounds, ...points.slice(i, i + 3));\n    }\n  }\n  return bounds;\n}\nfunction addBounds(bounds, xMin, xMax, yMin, yMax, zMin, zMax) {\n  const [_xMin, _xMax, _yMin, _yMax, _zMin, _zMax] = bounds;\n  if (zMax === undefined) {\n    bounds[0] = Math.min(xMin[0], _xMin);\n    bounds[1] = Math.max(xMin[1], _xMax);\n    bounds[2] = Math.min(xMin[2], _yMin);\n    bounds[3] = Math.max(xMin[3], _yMax);\n    bounds[4] = Math.min(xMin[4], _zMin);\n    bounds[5] = Math.max(xMin[5], _zMax);\n  } else {\n    bounds[0] = Math.min(xMin, _xMin);\n    bounds[1] = Math.max(xMax, _xMax);\n    bounds[2] = Math.min(yMin, _yMin);\n    bounds[3] = Math.max(yMax, _yMax);\n    bounds[4] = Math.min(zMin, _zMin);\n    bounds[5] = Math.max(zMax, _zMax);\n  }\n  return bounds;\n}\nfunction setMinPoint(bounds, x, y, z) {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  bounds[0] = x;\n  bounds[1] = x > xMax ? x : xMax;\n  bounds[2] = y;\n  bounds[3] = y > yMax ? y : yMax;\n  bounds[4] = z;\n  bounds[5] = z > zMax ? z : zMax;\n  return xMin !== x || yMin !== y || zMin !== z;\n}\nfunction setMaxPoint(bounds, x, y, z) {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  bounds[0] = x < xMin ? x : xMin;\n  bounds[1] = x;\n  bounds[2] = y < yMin ? y : yMin;\n  bounds[3] = y;\n  bounds[4] = z < zMin ? z : zMin;\n  bounds[5] = z;\n  return xMax !== x || yMax !== y || zMax !== z;\n}\nfunction inflate(bounds, delta) {\n  bounds[0] -= delta;\n  bounds[1] += delta;\n  bounds[2] -= delta;\n  bounds[3] += delta;\n  bounds[4] -= delta;\n  bounds[5] += delta;\n  return bounds;\n}\nfunction scale(bounds, sx, sy, sz) {\n  if (!isValid(bounds)) {\n    return false;\n  }\n  if (sx >= 0.0) {\n    bounds[0] *= sx;\n    bounds[1] *= sx;\n  } else {\n    bounds[0] = sx * bounds[1];\n    bounds[1] = sx * bounds[0];\n  }\n  if (sy >= 0.0) {\n    bounds[2] *= sy;\n    bounds[3] *= sy;\n  } else {\n    bounds[2] = sy * bounds[3];\n    bounds[3] = sy * bounds[2];\n  }\n  if (sz >= 0.0) {\n    bounds[4] *= sz;\n    bounds[5] *= sz;\n  } else {\n    bounds[4] = sz * bounds[5];\n    bounds[5] = sz * bounds[4];\n  }\n  return true;\n}\nfunction getCenter(bounds) {\n  return [0.5 * (bounds[0] + bounds[1]), 0.5 * (bounds[2] + bounds[3]), 0.5 * (bounds[4] + bounds[5])];\n}\nfunction scaleAboutCenter(bounds, sx, sy, sz) {\n  if (!isValid(bounds)) {\n    return false;\n  }\n  const center = getCenter(bounds);\n  bounds[0] -= center[0];\n  bounds[1] -= center[0];\n  bounds[2] -= center[1];\n  bounds[3] -= center[1];\n  bounds[4] -= center[2];\n  bounds[5] -= center[2];\n  scale(bounds, sx, sy, sz);\n  bounds[0] += center[0];\n  bounds[1] += center[0];\n  bounds[2] += center[1];\n  bounds[3] += center[1];\n  bounds[4] += center[2];\n  bounds[5] += center[2];\n  return true;\n}\nfunction getLength(bounds, index) {\n  return bounds[index * 2 + 1] - bounds[index * 2];\n}\nfunction getLengths(bounds) {\n  return [getLength(bounds, 0), getLength(bounds, 1), getLength(bounds, 2)];\n}\nfunction getXRange(bounds) {\n  return bounds.slice(0, 2);\n}\nfunction getYRange(bounds) {\n  return bounds.slice(2, 4);\n}\nfunction getZRange(bounds) {\n  return bounds.slice(4, 6);\n}\nfunction getMaxLength(bounds) {\n  const l = getLengths(bounds);\n  if (l[0] > l[1]) {\n    if (l[0] > l[2]) {\n      return l[0];\n    }\n    return l[2];\n  }\n  if (l[1] > l[2]) {\n    return l[1];\n  }\n  return l[2];\n}\nfunction getDiagonalLength(bounds) {\n  if (isValid(bounds)) {\n    const l = getLengths(bounds);\n    return Math.sqrt(l[0] * l[0] + l[1] * l[1] + l[2] * l[2]);\n  }\n  return null;\n}\nfunction getMinPoint(bounds) {\n  return [bounds[0], bounds[2], bounds[4]];\n}\nfunction getMaxPoint(bounds) {\n  return [bounds[1], bounds[3], bounds[5]];\n}\nfunction oppositeSign(a, b) {\n  return a <= 0 && b >= 0 || a >= 0 && b <= 0;\n}\nfunction getCorners(bounds, corners) {\n  let count = 0;\n  for (let ix = 0; ix < 2; ix++) {\n    for (let iy = 2; iy < 4; iy++) {\n      for (let iz = 4; iz < 6; iz++) {\n        corners[count++] = [bounds[ix], bounds[iy], bounds[iz]];\n      }\n    }\n  }\n  return corners;\n}\n\n// Computes the two corners with minimal and maximal coordinates\nfunction computeCornerPoints(bounds, point1, point2) {\n  point1[0] = bounds[0];\n  point1[1] = bounds[2];\n  point1[2] = bounds[4];\n  point2[0] = bounds[1];\n  point2[1] = bounds[3];\n  point2[2] = bounds[5];\n  return point1;\n}\nfunction transformBounds(bounds, transform) {\n  let out = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const corners = getCorners(bounds, []);\n  for (let i = 0; i < corners.length; ++i) {\n    vec3.transformMat4(corners[i], corners[i], transform);\n  }\n  reset(out);\n  return addPoints(out, corners);\n}\nfunction computeScale3(bounds) {\n  let scale3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  scale3[0] = 0.5 * (bounds[1] - bounds[0]);\n  scale3[1] = 0.5 * (bounds[3] - bounds[2]);\n  scale3[2] = 0.5 * (bounds[5] - bounds[4]);\n  return scale3;\n}\n\n/**\n * Compute local bounds.\n * Not as fast as vtkPoints.getBounds() if u, v, w form a natural basis.\n * @param {vtkPoints} points\n * @param {array} u first vector\n * @param {array} v second vector\n * @param {array} w third vector\n */\nfunction computeLocalBounds(points, u, v, w) {\n  const bounds = [].concat(INIT_BOUNDS);\n  const pointsData = points.getData();\n  for (let i = 0; i < pointsData.length; i += 3) {\n    const point = [pointsData[i], pointsData[i + 1], pointsData[i + 2]];\n    const du = dot(point, u);\n    bounds[0] = Math.min(du, bounds[0]);\n    bounds[1] = Math.max(du, bounds[1]);\n    const dv = dot(point, v);\n    bounds[2] = Math.min(dv, bounds[2]);\n    bounds[3] = Math.max(dv, bounds[3]);\n    const dw = dot(point, w);\n    bounds[4] = Math.min(dw, bounds[4]);\n    bounds[5] = Math.max(dw, bounds[5]);\n  }\n  return bounds;\n}\n\n// The method returns a non-zero value if the bounding box is hit.\n// Origin[3] starts the ray, dir[3] is the vector components of the ray in the x-y-z\n// directions, coord[3] is the location of hit, and t is the parametric\n// coordinate along line. (Notes: the intersection ray dir[3] is NOT\n// normalized.  Valid intersections will only occur between 0<=t<=1.)\nfunction intersectBox(bounds, origin, dir, coord, tolerance) {\n  let inside = true;\n  const quadrant = [];\n  let whichPlane = 0;\n  const maxT = [];\n  const candidatePlane = [0.0, 0.0, 0.0];\n  const RIGHT = 0;\n  const LEFT = 1;\n  const MIDDLE = 2;\n\n  // First find closest planes\n  for (let i = 0; i < 3; i++) {\n    if (origin[i] < bounds[2 * i]) {\n      quadrant[i] = LEFT;\n      candidatePlane[i] = bounds[2 * i];\n      inside = false;\n    } else if (origin[i] > bounds[2 * i + 1]) {\n      quadrant[i] = RIGHT;\n      candidatePlane[i] = bounds[2 * i + 1];\n      inside = false;\n    } else {\n      quadrant[i] = MIDDLE;\n    }\n  }\n\n  // Check whether origin of ray is inside bbox\n  if (inside) {\n    coord[0] = origin[0];\n    coord[1] = origin[1];\n    coord[2] = origin[2];\n    tolerance[0] = 0;\n    return 1;\n  }\n\n  // Calculate parametric distance to plane\n  for (let i = 0; i < 3; i++) {\n    if (quadrant[i] !== MIDDLE && dir[i] !== 0.0) {\n      maxT[i] = (candidatePlane[i] - origin[i]) / dir[i];\n    } else {\n      maxT[i] = -1.0;\n    }\n  }\n\n  // Find the largest parametric value of intersection\n  for (let i = 0; i < 3; i++) {\n    if (maxT[whichPlane] < maxT[i]) {\n      whichPlane = i;\n    }\n  }\n\n  // Check for value intersection along line\n  if (maxT[whichPlane] > 1.0 || maxT[whichPlane] < 0.0) {\n    return 0;\n  }\n  tolerance[0] = maxT[whichPlane];\n\n  // Intersection point along line is okay. Check bbox.\n  for (let i = 0; i < 3; i++) {\n    if (whichPlane !== i) {\n      coord[i] = origin[i] + maxT[whichPlane] * dir[i];\n      if (coord[i] < bounds[2 * i] || coord[i] > bounds[2 * i + 1]) {\n        return 0;\n      }\n    } else {\n      coord[i] = candidatePlane[i];\n    }\n  }\n  return 1;\n}\n\n// Plane intersection with box\n// The plane is infinite in extent and defined by an origin and normal.The function indicates\n// whether the plane intersects, not the particulars of intersection points and such\n// The function returns non-zero if the plane and box intersect; zero otherwise.\nfunction intersectPlane(bounds, origin, normal) {\n  const p = [];\n  let d = 0;\n  let sign = 1;\n  let firstOne = 1;\n\n  // Evaluate the eight points. If there is a sign change, there is an intersection\n  for (let z = 4; z <= 5; ++z) {\n    p[2] = bounds[z];\n    for (let y = 2; y <= 3; ++y) {\n      p[1] = bounds[y];\n      for (let x = 0; x <= 1; ++x) {\n        p[0] = bounds[x];\n        d = vtkPlane.evaluate(normal, origin, p);\n        if (firstOne) {\n          sign = d >= 0 ? 1 : -1;\n          firstOne = 0;\n        }\n        if (d === 0.0 || sign > 0 && d < 0.0 || sign < 0 && d > 0.0) {\n          return 1;\n        }\n      }\n    }\n  }\n  return 0; // no intersection\n}\nfunction intersect(bounds, bBounds) {\n  if (!(isValid(bounds) && isValid(bBounds))) {\n    return false;\n  }\n  const newBounds = [0, 0, 0, 0, 0, 0];\n  let intersection;\n  for (let i = 0; i < 3; i++) {\n    intersection = false;\n    if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {\n      intersection = true;\n      newBounds[i * 2] = bBounds[i * 2];\n    } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {\n      intersection = true;\n      newBounds[i * 2] = bounds[i * 2];\n    }\n    if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {\n      intersection = true;\n      newBounds[i * 2 + 1] = bBounds[2 * i + 1];\n    } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {\n      intersection = true;\n      newBounds[i * 2 + 1] = bounds[i * 2 + 1];\n    }\n    if (!intersection) {\n      return false;\n    }\n  }\n\n  // OK they did intersect - set the box to be the result\n  bounds[0] = newBounds[0];\n  bounds[1] = newBounds[1];\n  bounds[2] = newBounds[2];\n  bounds[3] = newBounds[3];\n  bounds[4] = newBounds[4];\n  bounds[5] = newBounds[5];\n  return true;\n}\nfunction intersects(bounds, bBounds) {\n  if (!(isValid(bounds) && isValid(bBounds))) {\n    return false;\n  }\n  /* eslint-disable no-continue */\n  for (let i = 0; i < 3; i++) {\n    if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {\n      continue;\n    } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {\n      continue;\n    }\n    if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {\n      continue;\n    } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {\n      continue;\n    }\n    return false;\n  }\n  /* eslint-enable no-continue */\n\n  return true;\n}\nfunction containsPoint(bounds, x, y, z) {\n  if (x < bounds[0] || x > bounds[1]) {\n    return false;\n  }\n  if (y < bounds[2] || y > bounds[3]) {\n    return false;\n  }\n  if (z < bounds[4] || z > bounds[5]) {\n    return false;\n  }\n  return true;\n}\nfunction contains(bounds, otherBounds) {\n  // if either box is not valid or they don't intersect\n  if (!intersects(bounds, otherBounds)) {\n    return false;\n  }\n  if (!containsPoint(bounds, ...getMinPoint(otherBounds))) {\n    return false;\n  }\n  if (!containsPoint(bounds, ...getMaxPoint(otherBounds))) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Returns true if plane intersects bounding box.\n * If so, the box is cut by the plane\n * @param {array} origin\n * @param {array} normal\n */\nfunction cutWithPlane(bounds, origin, normal) {\n  // Index[0..2] represents the order of traversing the corners of a cube\n  // in (x,y,z), (y,x,z) and (z,x,y) ordering, respectively\n  const index = [[0, 1, 2, 3, 4, 5, 6, 7], [0, 1, 4, 5, 2, 3, 6, 7], [0, 2, 4, 6, 1, 3, 5, 7]];\n\n  // stores the signed distance to a plane\n  const d = [0, 0, 0, 0, 0, 0, 0, 0];\n  let idx = 0;\n  for (let ix = 0; ix < 2; ix++) {\n    for (let iy = 2; iy < 4; iy++) {\n      for (let iz = 4; iz < 6; iz++) {\n        const x = [bounds[ix], bounds[iy], bounds[iz]];\n        d[idx++] = vtkPlane.evaluate(normal, origin, x);\n      }\n    }\n  }\n  let dir = 2;\n  while (dir--) {\n    // in each direction, we test if the vertices of two orthogonal faces\n    // are on either side of the plane\n    if (oppositeSign(d[index[dir][0]], d[index[dir][4]]) && oppositeSign(d[index[dir][1]], d[index[dir][5]]) && oppositeSign(d[index[dir][2]], d[index[dir][6]]) && oppositeSign(d[index[dir][3]], d[index[dir][7]])) {\n      break;\n    }\n  }\n  if (dir < 0) {\n    return false;\n  }\n  const sign = Math.sign(normal[dir]);\n  const size = Math.abs((bounds[dir * 2 + 1] - bounds[dir * 2]) * normal[dir]);\n  let t = sign > 0 ? 1 : 0;\n  /* eslint-disable no-continue */\n  for (let i = 0; i < 4; i++) {\n    if (size === 0) {\n      continue; // shouldn't happen\n    }\n    const ti = Math.abs(d[index[dir][i]]) / size;\n    if (sign > 0 && ti < t) {\n      t = ti;\n    }\n    if (sign < 0 && ti > t) {\n      t = ti;\n    }\n  }\n  /* eslint-enable no-continue */\n  const bound = (1.0 - t) * bounds[dir * 2] + t * bounds[dir * 2 + 1];\n  if (sign > 0) {\n    bounds[dir * 2] = bound;\n  } else {\n    bounds[dir * 2 + 1] = bound;\n  }\n  return true;\n}\n\n// ----------------------------------------------------------------------------\n// Light Weight class\n// ----------------------------------------------------------------------------\n\nclass BoundingBox {\n  constructor(refBounds) {\n    this.bounds = refBounds;\n    if (!this.bounds) {\n      this.bounds = new Float64Array(INIT_BOUNDS);\n    }\n  }\n  getBounds() {\n    return this.bounds;\n  }\n  equals(otherBounds) {\n    return equals(this.bounds, otherBounds);\n  }\n  isValid() {\n    return isValid(this.bounds);\n  }\n  setBounds(otherBounds) {\n    return setBounds(this.bounds, otherBounds);\n  }\n  reset() {\n    return reset(this.bounds);\n  }\n  addPoint() {\n    for (var _len = arguments.length, xyz = new Array(_len), _key = 0; _key < _len; _key++) {\n      xyz[_key] = arguments[_key];\n    }\n    return addPoint(this.bounds, ...xyz);\n  }\n  addPoints(points) {\n    return addPoints(this.bounds, points);\n  }\n  addBounds(xMin, xMax, yMin, yMax, zMin, zMax) {\n    return addBounds(this.bounds, xMin, xMax, yMin, yMax, zMin, zMax);\n  }\n  setMinPoint(x, y, z) {\n    return setMinPoint(this.bounds, x, y, z);\n  }\n  setMaxPoint(x, y, z) {\n    return setMaxPoint(this.bounds, x, y, z);\n  }\n  inflate(delta) {\n    return inflate(this.bounds, delta);\n  }\n  scale(sx, sy, sz) {\n    return scale(this.bounds, sx, sy, sz);\n  }\n  getCenter() {\n    return getCenter(this.bounds);\n  }\n  getLength(index) {\n    return getLength(this.bounds, index);\n  }\n  getLengths() {\n    return getLengths(this.bounds);\n  }\n  getMaxLength() {\n    return getMaxLength(this.bounds);\n  }\n  getDiagonalLength() {\n    return getDiagonalLength(this.bounds);\n  }\n  getMinPoint() {\n    return getMinPoint(this.bounds);\n  }\n  getMaxPoint() {\n    return getMaxPoint(this.bounds);\n  }\n  getXRange() {\n    return getXRange(this.bounds);\n  }\n  getYRange() {\n    return getYRange(this.bounds);\n  }\n  getZRange() {\n    return getZRange(this.bounds);\n  }\n  getCorners(corners) {\n    return getCorners(this.bounds, corners);\n  }\n  computeCornerPoints(point1, point2) {\n    return computeCornerPoints(this.bounds, point1, point2);\n  }\n  computeLocalBounds(u, v, w) {\n    return computeLocalBounds(this.bounds, u, v, w);\n  }\n  transformBounds(transform) {\n    let out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return transformBounds(this.bounds, transform, out);\n  }\n  computeScale3(scale3) {\n    return computeScale3(this.bounds, scale3);\n  }\n  cutWithPlane(origin, normal) {\n    return cutWithPlane(this.bounds, origin, normal);\n  }\n  intersectBox(origin, dir, coord, tolerance) {\n    return intersectBox(this.bounds, origin, dir, coord, tolerance);\n  }\n  intersectPlane(origin, normal) {\n    return intersectPlane(this.bounds, origin, normal);\n  }\n  intersect(otherBounds) {\n    return intersect(this.bounds, otherBounds);\n  }\n  intersects(otherBounds) {\n    return intersects(this.bounds, otherBounds);\n  }\n  containsPoint(x, y, z) {\n    return containsPoint(this.bounds, x, y, z);\n  }\n  contains(otherBounds) {\n    return intersects(this.bounds, otherBounds);\n  }\n}\nfunction newInstance(initialValues) {\n  const bounds = initialValues && initialValues.bounds;\n  return new BoundingBox(bounds);\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  equals,\n  isValid,\n  setBounds,\n  reset,\n  addPoint,\n  addPoints,\n  addBounds,\n  setMinPoint,\n  setMaxPoint,\n  inflate,\n  scale,\n  scaleAboutCenter,\n  getCenter,\n  getLength,\n  getLengths,\n  getMaxLength,\n  getDiagonalLength,\n  getMinPoint,\n  getMaxPoint,\n  getXRange,\n  getYRange,\n  getZRange,\n  getCorners,\n  computeCornerPoints,\n  computeLocalBounds,\n  transformBounds,\n  computeScale3,\n  cutWithPlane,\n  intersectBox,\n  intersectPlane,\n  intersect,\n  intersects,\n  containsPoint,\n  contains,\n  INIT_BOUNDS\n};\nvar vtkBoundingBox = {\n  newInstance,\n  ...STATIC\n};\nexport { STATIC, addBounds, addPoint, addPoints, computeCornerPoints, computeLocalBounds, computeScale3, contains, containsPoint, cutWithPlane, vtkBoundingBox as default, equals, getCenter, getCorners, getDiagonalLength, getLength, getLengths, getMaxLength, getMaxPoint, getMinPoint, getXRange, getYRange, getZRange, inflate, intersect, intersectBox, intersectPlane, intersects, isValid, reset, scale, scaleAboutCenter, setBounds, setMaxPoint, setMinPoint, transformBounds };","map":{"version":3,"names":["d","dot","vec3","vtkPlane","INIT_BOUNDS","Number","MAX_VALUE","equals","a","b","isValid","bounds","length","setBounds","otherBounds","reset","addPoint","x","y","z","xMin","xMax","yMin","yMax","zMin","zMax","addPoints","points","Array","isArray","i","slice","addBounds","_xMin","_xMax","_yMin","_yMax","_zMin","_zMax","undefined","Math","min","max","setMinPoint","setMaxPoint","inflate","delta","scale","sx","sy","sz","getCenter","scaleAboutCenter","center","getLength","index","getLengths","getXRange","getYRange","getZRange","getMaxLength","l","getDiagonalLength","sqrt","getMinPoint","getMaxPoint","oppositeSign","getCorners","corners","count","ix","iy","iz","computeCornerPoints","point1","point2","transformBounds","transform","out","arguments","transformMat4","computeScale3","scale3","computeLocalBounds","u","v","w","concat","pointsData","getData","point","du","dv","dw","intersectBox","origin","dir","coord","tolerance","inside","quadrant","whichPlane","maxT","candidatePlane","RIGHT","LEFT","MIDDLE","intersectPlane","normal","p","sign","firstOne","evaluate","intersect","bBounds","newBounds","intersection","intersects","containsPoint","contains","cutWithPlane","idx","size","abs","t","ti","bound","BoundingBox","constructor","refBounds","Float64Array","getBounds","_len","xyz","_key","newInstance","initialValues","STATIC","vtkBoundingBox","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Common/DataModel/BoundingBox.js"],"sourcesContent":["import { d as dot } from '../Core/Math/index.js';\nimport { vec3 } from 'gl-matrix';\nimport vtkPlane from './Plane.js';\n\nconst INIT_BOUNDS = [Number.MAX_VALUE, -Number.MAX_VALUE,\n// X\nNumber.MAX_VALUE, -Number.MAX_VALUE,\n// Y\nNumber.MAX_VALUE, -Number.MAX_VALUE // Z\n];\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction equals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];\n}\nfunction isValid(bounds) {\n  return bounds?.length >= 6 && bounds[0] <= bounds[1] && bounds[2] <= bounds[3] && bounds[4] <= bounds[5];\n}\nfunction setBounds(bounds, otherBounds) {\n  bounds[0] = otherBounds[0];\n  bounds[1] = otherBounds[1];\n  bounds[2] = otherBounds[2];\n  bounds[3] = otherBounds[3];\n  bounds[4] = otherBounds[4];\n  bounds[5] = otherBounds[5];\n  return bounds;\n}\nfunction reset(bounds) {\n  return setBounds(bounds, INIT_BOUNDS);\n}\nfunction addPoint(bounds, x, y, z) {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  bounds[0] = xMin < x ? xMin : x;\n  bounds[1] = xMax > x ? xMax : x;\n  bounds[2] = yMin < y ? yMin : y;\n  bounds[3] = yMax > y ? yMax : y;\n  bounds[4] = zMin < z ? zMin : z;\n  bounds[5] = zMax > z ? zMax : z;\n  return bounds;\n}\nfunction addPoints(bounds, points) {\n  if (points.length === 0) {\n    return bounds;\n  }\n  if (Array.isArray(points[0])) {\n    for (let i = 0; i < points.length; ++i) {\n      addPoint(bounds, ...points[i]);\n    }\n  } else {\n    for (let i = 0; i < points.length; i += 3) {\n      addPoint(bounds, ...points.slice(i, i + 3));\n    }\n  }\n  return bounds;\n}\nfunction addBounds(bounds, xMin, xMax, yMin, yMax, zMin, zMax) {\n  const [_xMin, _xMax, _yMin, _yMax, _zMin, _zMax] = bounds;\n  if (zMax === undefined) {\n    bounds[0] = Math.min(xMin[0], _xMin);\n    bounds[1] = Math.max(xMin[1], _xMax);\n    bounds[2] = Math.min(xMin[2], _yMin);\n    bounds[3] = Math.max(xMin[3], _yMax);\n    bounds[4] = Math.min(xMin[4], _zMin);\n    bounds[5] = Math.max(xMin[5], _zMax);\n  } else {\n    bounds[0] = Math.min(xMin, _xMin);\n    bounds[1] = Math.max(xMax, _xMax);\n    bounds[2] = Math.min(yMin, _yMin);\n    bounds[3] = Math.max(yMax, _yMax);\n    bounds[4] = Math.min(zMin, _zMin);\n    bounds[5] = Math.max(zMax, _zMax);\n  }\n  return bounds;\n}\nfunction setMinPoint(bounds, x, y, z) {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  bounds[0] = x;\n  bounds[1] = x > xMax ? x : xMax;\n  bounds[2] = y;\n  bounds[3] = y > yMax ? y : yMax;\n  bounds[4] = z;\n  bounds[5] = z > zMax ? z : zMax;\n  return xMin !== x || yMin !== y || zMin !== z;\n}\nfunction setMaxPoint(bounds, x, y, z) {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  bounds[0] = x < xMin ? x : xMin;\n  bounds[1] = x;\n  bounds[2] = y < yMin ? y : yMin;\n  bounds[3] = y;\n  bounds[4] = z < zMin ? z : zMin;\n  bounds[5] = z;\n  return xMax !== x || yMax !== y || zMax !== z;\n}\nfunction inflate(bounds, delta) {\n  bounds[0] -= delta;\n  bounds[1] += delta;\n  bounds[2] -= delta;\n  bounds[3] += delta;\n  bounds[4] -= delta;\n  bounds[5] += delta;\n  return bounds;\n}\nfunction scale(bounds, sx, sy, sz) {\n  if (!isValid(bounds)) {\n    return false;\n  }\n  if (sx >= 0.0) {\n    bounds[0] *= sx;\n    bounds[1] *= sx;\n  } else {\n    bounds[0] = sx * bounds[1];\n    bounds[1] = sx * bounds[0];\n  }\n  if (sy >= 0.0) {\n    bounds[2] *= sy;\n    bounds[3] *= sy;\n  } else {\n    bounds[2] = sy * bounds[3];\n    bounds[3] = sy * bounds[2];\n  }\n  if (sz >= 0.0) {\n    bounds[4] *= sz;\n    bounds[5] *= sz;\n  } else {\n    bounds[4] = sz * bounds[5];\n    bounds[5] = sz * bounds[4];\n  }\n  return true;\n}\nfunction getCenter(bounds) {\n  return [0.5 * (bounds[0] + bounds[1]), 0.5 * (bounds[2] + bounds[3]), 0.5 * (bounds[4] + bounds[5])];\n}\nfunction scaleAboutCenter(bounds, sx, sy, sz) {\n  if (!isValid(bounds)) {\n    return false;\n  }\n  const center = getCenter(bounds);\n  bounds[0] -= center[0];\n  bounds[1] -= center[0];\n  bounds[2] -= center[1];\n  bounds[3] -= center[1];\n  bounds[4] -= center[2];\n  bounds[5] -= center[2];\n  scale(bounds, sx, sy, sz);\n  bounds[0] += center[0];\n  bounds[1] += center[0];\n  bounds[2] += center[1];\n  bounds[3] += center[1];\n  bounds[4] += center[2];\n  bounds[5] += center[2];\n  return true;\n}\nfunction getLength(bounds, index) {\n  return bounds[index * 2 + 1] - bounds[index * 2];\n}\nfunction getLengths(bounds) {\n  return [getLength(bounds, 0), getLength(bounds, 1), getLength(bounds, 2)];\n}\nfunction getXRange(bounds) {\n  return bounds.slice(0, 2);\n}\nfunction getYRange(bounds) {\n  return bounds.slice(2, 4);\n}\nfunction getZRange(bounds) {\n  return bounds.slice(4, 6);\n}\nfunction getMaxLength(bounds) {\n  const l = getLengths(bounds);\n  if (l[0] > l[1]) {\n    if (l[0] > l[2]) {\n      return l[0];\n    }\n    return l[2];\n  }\n  if (l[1] > l[2]) {\n    return l[1];\n  }\n  return l[2];\n}\nfunction getDiagonalLength(bounds) {\n  if (isValid(bounds)) {\n    const l = getLengths(bounds);\n    return Math.sqrt(l[0] * l[0] + l[1] * l[1] + l[2] * l[2]);\n  }\n  return null;\n}\nfunction getMinPoint(bounds) {\n  return [bounds[0], bounds[2], bounds[4]];\n}\nfunction getMaxPoint(bounds) {\n  return [bounds[1], bounds[3], bounds[5]];\n}\nfunction oppositeSign(a, b) {\n  return a <= 0 && b >= 0 || a >= 0 && b <= 0;\n}\nfunction getCorners(bounds, corners) {\n  let count = 0;\n  for (let ix = 0; ix < 2; ix++) {\n    for (let iy = 2; iy < 4; iy++) {\n      for (let iz = 4; iz < 6; iz++) {\n        corners[count++] = [bounds[ix], bounds[iy], bounds[iz]];\n      }\n    }\n  }\n  return corners;\n}\n\n// Computes the two corners with minimal and maximal coordinates\nfunction computeCornerPoints(bounds, point1, point2) {\n  point1[0] = bounds[0];\n  point1[1] = bounds[2];\n  point1[2] = bounds[4];\n  point2[0] = bounds[1];\n  point2[1] = bounds[3];\n  point2[2] = bounds[5];\n  return point1;\n}\nfunction transformBounds(bounds, transform) {\n  let out = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const corners = getCorners(bounds, []);\n  for (let i = 0; i < corners.length; ++i) {\n    vec3.transformMat4(corners[i], corners[i], transform);\n  }\n  reset(out);\n  return addPoints(out, corners);\n}\nfunction computeScale3(bounds) {\n  let scale3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  scale3[0] = 0.5 * (bounds[1] - bounds[0]);\n  scale3[1] = 0.5 * (bounds[3] - bounds[2]);\n  scale3[2] = 0.5 * (bounds[5] - bounds[4]);\n  return scale3;\n}\n\n/**\n * Compute local bounds.\n * Not as fast as vtkPoints.getBounds() if u, v, w form a natural basis.\n * @param {vtkPoints} points\n * @param {array} u first vector\n * @param {array} v second vector\n * @param {array} w third vector\n */\nfunction computeLocalBounds(points, u, v, w) {\n  const bounds = [].concat(INIT_BOUNDS);\n  const pointsData = points.getData();\n  for (let i = 0; i < pointsData.length; i += 3) {\n    const point = [pointsData[i], pointsData[i + 1], pointsData[i + 2]];\n    const du = dot(point, u);\n    bounds[0] = Math.min(du, bounds[0]);\n    bounds[1] = Math.max(du, bounds[1]);\n    const dv = dot(point, v);\n    bounds[2] = Math.min(dv, bounds[2]);\n    bounds[3] = Math.max(dv, bounds[3]);\n    const dw = dot(point, w);\n    bounds[4] = Math.min(dw, bounds[4]);\n    bounds[5] = Math.max(dw, bounds[5]);\n  }\n  return bounds;\n}\n\n// The method returns a non-zero value if the bounding box is hit.\n// Origin[3] starts the ray, dir[3] is the vector components of the ray in the x-y-z\n// directions, coord[3] is the location of hit, and t is the parametric\n// coordinate along line. (Notes: the intersection ray dir[3] is NOT\n// normalized.  Valid intersections will only occur between 0<=t<=1.)\nfunction intersectBox(bounds, origin, dir, coord, tolerance) {\n  let inside = true;\n  const quadrant = [];\n  let whichPlane = 0;\n  const maxT = [];\n  const candidatePlane = [0.0, 0.0, 0.0];\n  const RIGHT = 0;\n  const LEFT = 1;\n  const MIDDLE = 2;\n\n  // First find closest planes\n  for (let i = 0; i < 3; i++) {\n    if (origin[i] < bounds[2 * i]) {\n      quadrant[i] = LEFT;\n      candidatePlane[i] = bounds[2 * i];\n      inside = false;\n    } else if (origin[i] > bounds[2 * i + 1]) {\n      quadrant[i] = RIGHT;\n      candidatePlane[i] = bounds[2 * i + 1];\n      inside = false;\n    } else {\n      quadrant[i] = MIDDLE;\n    }\n  }\n\n  // Check whether origin of ray is inside bbox\n  if (inside) {\n    coord[0] = origin[0];\n    coord[1] = origin[1];\n    coord[2] = origin[2];\n    tolerance[0] = 0;\n    return 1;\n  }\n\n  // Calculate parametric distance to plane\n  for (let i = 0; i < 3; i++) {\n    if (quadrant[i] !== MIDDLE && dir[i] !== 0.0) {\n      maxT[i] = (candidatePlane[i] - origin[i]) / dir[i];\n    } else {\n      maxT[i] = -1.0;\n    }\n  }\n\n  // Find the largest parametric value of intersection\n  for (let i = 0; i < 3; i++) {\n    if (maxT[whichPlane] < maxT[i]) {\n      whichPlane = i;\n    }\n  }\n\n  // Check for value intersection along line\n  if (maxT[whichPlane] > 1.0 || maxT[whichPlane] < 0.0) {\n    return 0;\n  }\n  tolerance[0] = maxT[whichPlane];\n\n  // Intersection point along line is okay. Check bbox.\n  for (let i = 0; i < 3; i++) {\n    if (whichPlane !== i) {\n      coord[i] = origin[i] + maxT[whichPlane] * dir[i];\n      if (coord[i] < bounds[2 * i] || coord[i] > bounds[2 * i + 1]) {\n        return 0;\n      }\n    } else {\n      coord[i] = candidatePlane[i];\n    }\n  }\n  return 1;\n}\n\n// Plane intersection with box\n// The plane is infinite in extent and defined by an origin and normal.The function indicates\n// whether the plane intersects, not the particulars of intersection points and such\n// The function returns non-zero if the plane and box intersect; zero otherwise.\nfunction intersectPlane(bounds, origin, normal) {\n  const p = [];\n  let d = 0;\n  let sign = 1;\n  let firstOne = 1;\n\n  // Evaluate the eight points. If there is a sign change, there is an intersection\n  for (let z = 4; z <= 5; ++z) {\n    p[2] = bounds[z];\n    for (let y = 2; y <= 3; ++y) {\n      p[1] = bounds[y];\n      for (let x = 0; x <= 1; ++x) {\n        p[0] = bounds[x];\n        d = vtkPlane.evaluate(normal, origin, p);\n        if (firstOne) {\n          sign = d >= 0 ? 1 : -1;\n          firstOne = 0;\n        }\n        if (d === 0.0 || sign > 0 && d < 0.0 || sign < 0 && d > 0.0) {\n          return 1;\n        }\n      }\n    }\n  }\n  return 0; // no intersection\n}\n\nfunction intersect(bounds, bBounds) {\n  if (!(isValid(bounds) && isValid(bBounds))) {\n    return false;\n  }\n  const newBounds = [0, 0, 0, 0, 0, 0];\n  let intersection;\n  for (let i = 0; i < 3; i++) {\n    intersection = false;\n    if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {\n      intersection = true;\n      newBounds[i * 2] = bBounds[i * 2];\n    } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {\n      intersection = true;\n      newBounds[i * 2] = bounds[i * 2];\n    }\n    if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {\n      intersection = true;\n      newBounds[i * 2 + 1] = bBounds[2 * i + 1];\n    } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {\n      intersection = true;\n      newBounds[i * 2 + 1] = bounds[i * 2 + 1];\n    }\n    if (!intersection) {\n      return false;\n    }\n  }\n\n  // OK they did intersect - set the box to be the result\n  bounds[0] = newBounds[0];\n  bounds[1] = newBounds[1];\n  bounds[2] = newBounds[2];\n  bounds[3] = newBounds[3];\n  bounds[4] = newBounds[4];\n  bounds[5] = newBounds[5];\n  return true;\n}\nfunction intersects(bounds, bBounds) {\n  if (!(isValid(bounds) && isValid(bBounds))) {\n    return false;\n  }\n  /* eslint-disable no-continue */\n  for (let i = 0; i < 3; i++) {\n    if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {\n      continue;\n    } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {\n      continue;\n    }\n    if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {\n      continue;\n    } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {\n      continue;\n    }\n    return false;\n  }\n  /* eslint-enable no-continue */\n\n  return true;\n}\nfunction containsPoint(bounds, x, y, z) {\n  if (x < bounds[0] || x > bounds[1]) {\n    return false;\n  }\n  if (y < bounds[2] || y > bounds[3]) {\n    return false;\n  }\n  if (z < bounds[4] || z > bounds[5]) {\n    return false;\n  }\n  return true;\n}\nfunction contains(bounds, otherBounds) {\n  // if either box is not valid or they don't intersect\n  if (!intersects(bounds, otherBounds)) {\n    return false;\n  }\n  if (!containsPoint(bounds, ...getMinPoint(otherBounds))) {\n    return false;\n  }\n  if (!containsPoint(bounds, ...getMaxPoint(otherBounds))) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Returns true if plane intersects bounding box.\n * If so, the box is cut by the plane\n * @param {array} origin\n * @param {array} normal\n */\nfunction cutWithPlane(bounds, origin, normal) {\n  // Index[0..2] represents the order of traversing the corners of a cube\n  // in (x,y,z), (y,x,z) and (z,x,y) ordering, respectively\n  const index = [[0, 1, 2, 3, 4, 5, 6, 7], [0, 1, 4, 5, 2, 3, 6, 7], [0, 2, 4, 6, 1, 3, 5, 7]];\n\n  // stores the signed distance to a plane\n  const d = [0, 0, 0, 0, 0, 0, 0, 0];\n  let idx = 0;\n  for (let ix = 0; ix < 2; ix++) {\n    for (let iy = 2; iy < 4; iy++) {\n      for (let iz = 4; iz < 6; iz++) {\n        const x = [bounds[ix], bounds[iy], bounds[iz]];\n        d[idx++] = vtkPlane.evaluate(normal, origin, x);\n      }\n    }\n  }\n  let dir = 2;\n  while (dir--) {\n    // in each direction, we test if the vertices of two orthogonal faces\n    // are on either side of the plane\n    if (oppositeSign(d[index[dir][0]], d[index[dir][4]]) && oppositeSign(d[index[dir][1]], d[index[dir][5]]) && oppositeSign(d[index[dir][2]], d[index[dir][6]]) && oppositeSign(d[index[dir][3]], d[index[dir][7]])) {\n      break;\n    }\n  }\n  if (dir < 0) {\n    return false;\n  }\n  const sign = Math.sign(normal[dir]);\n  const size = Math.abs((bounds[dir * 2 + 1] - bounds[dir * 2]) * normal[dir]);\n  let t = sign > 0 ? 1 : 0;\n  /* eslint-disable no-continue */\n  for (let i = 0; i < 4; i++) {\n    if (size === 0) {\n      continue; // shouldn't happen\n    }\n\n    const ti = Math.abs(d[index[dir][i]]) / size;\n    if (sign > 0 && ti < t) {\n      t = ti;\n    }\n    if (sign < 0 && ti > t) {\n      t = ti;\n    }\n  }\n  /* eslint-enable no-continue */\n  const bound = (1.0 - t) * bounds[dir * 2] + t * bounds[dir * 2 + 1];\n  if (sign > 0) {\n    bounds[dir * 2] = bound;\n  } else {\n    bounds[dir * 2 + 1] = bound;\n  }\n  return true;\n}\n\n// ----------------------------------------------------------------------------\n// Light Weight class\n// ----------------------------------------------------------------------------\n\nclass BoundingBox {\n  constructor(refBounds) {\n    this.bounds = refBounds;\n    if (!this.bounds) {\n      this.bounds = new Float64Array(INIT_BOUNDS);\n    }\n  }\n  getBounds() {\n    return this.bounds;\n  }\n  equals(otherBounds) {\n    return equals(this.bounds, otherBounds);\n  }\n  isValid() {\n    return isValid(this.bounds);\n  }\n  setBounds(otherBounds) {\n    return setBounds(this.bounds, otherBounds);\n  }\n  reset() {\n    return reset(this.bounds);\n  }\n  addPoint() {\n    for (var _len = arguments.length, xyz = new Array(_len), _key = 0; _key < _len; _key++) {\n      xyz[_key] = arguments[_key];\n    }\n    return addPoint(this.bounds, ...xyz);\n  }\n  addPoints(points) {\n    return addPoints(this.bounds, points);\n  }\n  addBounds(xMin, xMax, yMin, yMax, zMin, zMax) {\n    return addBounds(this.bounds, xMin, xMax, yMin, yMax, zMin, zMax);\n  }\n  setMinPoint(x, y, z) {\n    return setMinPoint(this.bounds, x, y, z);\n  }\n  setMaxPoint(x, y, z) {\n    return setMaxPoint(this.bounds, x, y, z);\n  }\n  inflate(delta) {\n    return inflate(this.bounds, delta);\n  }\n  scale(sx, sy, sz) {\n    return scale(this.bounds, sx, sy, sz);\n  }\n  getCenter() {\n    return getCenter(this.bounds);\n  }\n  getLength(index) {\n    return getLength(this.bounds, index);\n  }\n  getLengths() {\n    return getLengths(this.bounds);\n  }\n  getMaxLength() {\n    return getMaxLength(this.bounds);\n  }\n  getDiagonalLength() {\n    return getDiagonalLength(this.bounds);\n  }\n  getMinPoint() {\n    return getMinPoint(this.bounds);\n  }\n  getMaxPoint() {\n    return getMaxPoint(this.bounds);\n  }\n  getXRange() {\n    return getXRange(this.bounds);\n  }\n  getYRange() {\n    return getYRange(this.bounds);\n  }\n  getZRange() {\n    return getZRange(this.bounds);\n  }\n  getCorners(corners) {\n    return getCorners(this.bounds, corners);\n  }\n  computeCornerPoints(point1, point2) {\n    return computeCornerPoints(this.bounds, point1, point2);\n  }\n  computeLocalBounds(u, v, w) {\n    return computeLocalBounds(this.bounds, u, v, w);\n  }\n  transformBounds(transform) {\n    let out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return transformBounds(this.bounds, transform, out);\n  }\n  computeScale3(scale3) {\n    return computeScale3(this.bounds, scale3);\n  }\n  cutWithPlane(origin, normal) {\n    return cutWithPlane(this.bounds, origin, normal);\n  }\n  intersectBox(origin, dir, coord, tolerance) {\n    return intersectBox(this.bounds, origin, dir, coord, tolerance);\n  }\n  intersectPlane(origin, normal) {\n    return intersectPlane(this.bounds, origin, normal);\n  }\n  intersect(otherBounds) {\n    return intersect(this.bounds, otherBounds);\n  }\n  intersects(otherBounds) {\n    return intersects(this.bounds, otherBounds);\n  }\n  containsPoint(x, y, z) {\n    return containsPoint(this.bounds, x, y, z);\n  }\n  contains(otherBounds) {\n    return intersects(this.bounds, otherBounds);\n  }\n}\nfunction newInstance(initialValues) {\n  const bounds = initialValues && initialValues.bounds;\n  return new BoundingBox(bounds);\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  equals,\n  isValid,\n  setBounds,\n  reset,\n  addPoint,\n  addPoints,\n  addBounds,\n  setMinPoint,\n  setMaxPoint,\n  inflate,\n  scale,\n  scaleAboutCenter,\n  getCenter,\n  getLength,\n  getLengths,\n  getMaxLength,\n  getDiagonalLength,\n  getMinPoint,\n  getMaxPoint,\n  getXRange,\n  getYRange,\n  getZRange,\n  getCorners,\n  computeCornerPoints,\n  computeLocalBounds,\n  transformBounds,\n  computeScale3,\n  cutWithPlane,\n  intersectBox,\n  intersectPlane,\n  intersect,\n  intersects,\n  containsPoint,\n  contains,\n  INIT_BOUNDS\n};\nvar vtkBoundingBox = {\n  newInstance,\n  ...STATIC\n};\n\nexport { STATIC, addBounds, addPoint, addPoints, computeCornerPoints, computeLocalBounds, computeScale3, contains, containsPoint, cutWithPlane, vtkBoundingBox as default, equals, getCenter, getCorners, getDiagonalLength, getLength, getLengths, getMaxLength, getMaxPoint, getMinPoint, getXRange, getYRange, getZRange, inflate, intersect, intersectBox, intersectPlane, intersects, isValid, reset, scale, scaleAboutCenter, setBounds, setMaxPoint, setMinPoint, transformBounds };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}