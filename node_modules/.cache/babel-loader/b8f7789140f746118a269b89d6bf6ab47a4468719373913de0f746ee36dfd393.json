{"ast":null,"code":"import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { getCanvasEllipseCorners, precalculatePointInEllipse } from '../../../utilities/math/ellipse';\nimport { getBoundingBoxAroundShapeIJK } from '../../../utilities/boundingBox';\nimport BrushStrategy from './BrushStrategy';\nimport { StrategyCallbacks } from '../../../enums';\nimport compositions from './compositions';\nimport { pointInSphere } from '../../../utilities/math/sphere';\nconst {\n  transformWorldToIndex,\n  isEqual\n} = csUtils;\nconst initializeCircle = {\n  [StrategyCallbacks.Initialize]: operationData => {\n    const {\n      points,\n      imageVoxelManager: imageVoxelManager,\n      viewport,\n      segmentationImageData,\n      segmentationVoxelManager: segmentationVoxelManager\n    } = operationData;\n    if (!points) {\n      return;\n    }\n    const center = vec3.fromValues(0, 0, 0);\n    points.forEach(point => {\n      vec3.add(center, center, point);\n    });\n    vec3.scale(center, center, 1 / points.length);\n    operationData.centerWorld = center;\n    operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);\n    const canvasCoordinates = points.map(p => viewport.worldToCanvas(p));\n    const [topLeftCanvas, bottomRightCanvas] = getCanvasEllipseCorners(canvasCoordinates);\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const circleCornersIJK = points.map(world => {\n      return transformWorldToIndex(segmentationImageData, world);\n    });\n    const boundsIJK = getBoundingBoxAroundShapeIJK(circleCornersIJK, segmentationImageData.getDimensions());\n    segmentationVoxelManager.boundsIJK = boundsIJK;\n    imageVoxelManager.isInObject = createPointInEllipse({\n      topLeftWorld,\n      bottomRightWorld,\n      center\n    });\n  }\n};\nfunction createPointInEllipse(worldInfo) {\n  const {\n    topLeftWorld,\n    bottomRightWorld,\n    center\n  } = worldInfo;\n  const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;\n  const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;\n  const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;\n  const radius = Math.max(xRadius, yRadius, zRadius);\n  if (isEqual(xRadius, radius) && isEqual(yRadius, radius) && isEqual(zRadius, radius)) {\n    const sphereObj = {\n      center,\n      radius,\n      radius2: radius * radius\n    };\n    return pointLPS => pointInSphere(sphereObj, pointLPS);\n  }\n  const ellipseObj = {\n    center: center,\n    xRadius,\n    yRadius,\n    zRadius\n  };\n  const {\n    precalculated\n  } = precalculatePointInEllipse(ellipseObj, {});\n  return precalculated;\n}\nconst CIRCLE_STRATEGY = new BrushStrategy('Circle', compositions.regionFill, compositions.setValue, initializeCircle, compositions.determineSegmentIndex, compositions.preview);\nconst CIRCLE_THRESHOLD_STRATEGY = new BrushStrategy('CircleThreshold', compositions.regionFill, compositions.setValue, initializeCircle, compositions.determineSegmentIndex, compositions.dynamicThreshold, compositions.threshold, compositions.preview, compositions.islandRemoval);\nconst fillInsideCircle = CIRCLE_STRATEGY.strategyFunction;\nconst thresholdInsideCircle = CIRCLE_THRESHOLD_STRATEGY.strategyFunction;\nexport function fillOutsideCircle() {\n  throw new Error('Not yet implemented');\n}\nexport { CIRCLE_STRATEGY, CIRCLE_THRESHOLD_STRATEGY, fillInsideCircle, thresholdInsideCircle, createPointInEllipse as createEllipseInPoint };","map":{"version":3,"names":["vec3","utilities","csUtils","getCanvasEllipseCorners","precalculatePointInEllipse","getBoundingBoxAroundShapeIJK","BrushStrategy","StrategyCallbacks","compositions","pointInSphere","transformWorldToIndex","isEqual","initializeCircle","Initialize","operationData","points","imageVoxelManager","viewport","segmentationImageData","segmentationVoxelManager","center","fromValues","forEach","point","add","scale","length","centerWorld","centerIJK","canvasCoordinates","map","p","worldToCanvas","topLeftCanvas","bottomRightCanvas","topLeftWorld","canvasToWorld","bottomRightWorld","circleCornersIJK","world","boundsIJK","getDimensions","isInObject","createPointInEllipse","worldInfo","xRadius","Math","abs","yRadius","zRadius","radius","max","sphereObj","radius2","pointLPS","ellipseObj","precalculated","CIRCLE_STRATEGY","regionFill","setValue","determineSegmentIndex","preview","CIRCLE_THRESHOLD_STRATEGY","dynamicThreshold","threshold","islandRemoval","fillInsideCircle","strategyFunction","thresholdInsideCircle","fillOutsideCircle","Error","createEllipseInPoint"],"sources":["../../../../../src/tools/segmentation/strategies/fillCircle.ts"],"sourcesContent":[null],"mappings":"AAAA,SAASA,IAAI,QAAQ,WAAW;AAChC,SAASC,SAAS,IAAIC,OAAO,QAAQ,qBAAqB;AAG1D,SACEC,uBAAuB,EACvBC,0BAA0B,QACrB,iCAAiC;AACxC,SAASC,4BAA4B,QAAQ,gCAAgC;AAC7E,OAAOC,aAAa,MAAM,iBAAiB;AAG3C,SAASC,iBAAiB,QAAQ,gBAAgB;AAClD,OAAOC,YAAY,MAAM,gBAAgB;AACzC,SAASC,aAAa,QAAQ,gCAAgC;AAE9D,MAAM;EAAEC,qBAAqB;EAAEC;AAAO,CAAE,GAAGT,OAAO;AAElD,MAAMU,gBAAgB,GAAG;EACvB,CAACL,iBAAiB,CAACM,UAAU,GAAIC,aAAuC,IAAI;IAC1E,MAAM;MACJC,MAAM;MACNC,iBAAiB,EAAEA,iBAAiB;MACpCC,QAAQ;MACRC,qBAAqB;MACrBC,wBAAwB,EAAEA;IAAwB,CACnD,GAAGL,aAAa;IAGjB,IAAI,CAACC,MAAM,EAAE;MACX;;IAGF,MAAMK,MAAM,GAAGpB,IAAI,CAACqB,UAAU,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACvCN,MAAM,CAACO,OAAO,CAAEC,KAAK,IAAI;MACvBvB,IAAI,CAACwB,GAAG,CAACJ,MAAM,EAAEA,MAAM,EAAEG,KAAK,CAAC;IACjC,CAAC,CAAC;IACFvB,IAAI,CAACyB,KAAK,CAACL,MAAM,EAAEA,MAAM,EAAE,CAAC,GAAGL,MAAM,CAACW,MAAM,CAAC;IAE7CZ,aAAa,CAACa,WAAW,GAAGP,MAAsB;IAClDN,aAAa,CAACc,SAAS,GAAGlB,qBAAqB,CAC7CQ,qBAAqB,EACrBE,MAAsB,CACvB;IAED,MAAMS,iBAAiB,GAAGd,MAAM,CAACe,GAAG,CAAEC,CAAC,IACrCd,QAAQ,CAACe,aAAa,CAACD,CAAC,CAAC,CACL;IAItB,MAAM,CAACE,aAAa,EAAEC,iBAAiB,CAAC,GACtC/B,uBAAuB,CAAC0B,iBAAiB,CAAC;IAG5C,MAAMM,YAAY,GAAGlB,QAAQ,CAACmB,aAAa,CAACH,aAAa,CAAC;IAC1D,MAAMI,gBAAgB,GAAGpB,QAAQ,CAACmB,aAAa,CAACF,iBAAiB,CAAC;IAElE,MAAMI,gBAAgB,GAAGvB,MAAM,CAACe,GAAG,CAAES,KAAK,IAAI;MAC5C,OAAO7B,qBAAqB,CAACQ,qBAAqB,EAAEqB,KAAK,CAAC;IAC5D,CAAC,CAAC;IAIF,MAAMC,SAAS,GAAGnC,4BAA4B,CAC5CiC,gBAAgB,EAChBpB,qBAAqB,CAACuB,aAAa,EAAE,CACtC;IAEDtB,wBAAwB,CAACqB,SAAS,GAAGA,SAAS;IAC9CxB,iBAAiB,CAAC0B,UAAU,GAAGC,oBAAoB,CAAC;MAClDR,YAAY;MACZE,gBAAgB;MAChBjB;KACD,CAAC;EACJ;CACc;AAUhB,SAASuB,oBAAoBA,CAACC,SAI7B;EACC,MAAM;IAAET,YAAY;IAAEE,gBAAgB;IAAEjB;EAAM,CAAE,GAAGwB,SAAS;EAE5D,MAAMC,OAAO,GAAGC,IAAI,CAACC,GAAG,CAACZ,YAAY,CAAC,CAAC,CAAC,GAAGE,gBAAgB,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;EACnE,MAAMW,OAAO,GAAGF,IAAI,CAACC,GAAG,CAACZ,YAAY,CAAC,CAAC,CAAC,GAAGE,gBAAgB,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;EACnE,MAAMY,OAAO,GAAGH,IAAI,CAACC,GAAG,CAACZ,YAAY,CAAC,CAAC,CAAC,GAAGE,gBAAgB,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;EAEnE,MAAMa,MAAM,GAAGJ,IAAI,CAACK,GAAG,CAACN,OAAO,EAAEG,OAAO,EAAEC,OAAO,CAAC;EAClD,IACEtC,OAAO,CAACkC,OAAO,EAAEK,MAAM,CAAC,IACxBvC,OAAO,CAACqC,OAAO,EAAEE,MAAM,CAAC,IACxBvC,OAAO,CAACsC,OAAO,EAAEC,MAAM,CAAC,EACxB;IACA,MAAME,SAAS,GAAG;MAChBhC,MAAM;MACN8B,MAAM;MACNG,OAAO,EAAEH,MAAM,GAAGA;KACnB;IACD,OAAQI,QAAQ,IAAK7C,aAAa,CAAC2C,SAAS,EAAEE,QAAQ,CAAC;;EAGzD,MAAMC,UAAU,GAAG;IACjBnC,MAAM,EAAEA,MAAsB;IAC9ByB,OAAO;IACPG,OAAO;IACPC;GACD;EAED,MAAM;IAAEO;EAAa,CAAE,GAAGpD,0BAA0B,CAACmD,UAAU,EAAE,EAAE,CAAC;EACpE,OAAOC,aAAa;AACtB;AAEA,MAAMC,eAAe,GAAG,IAAInD,aAAa,CACvC,QAAQ,EACRE,YAAY,CAACkD,UAAU,EACvBlD,YAAY,CAACmD,QAAQ,EACrB/C,gBAAgB,EAChBJ,YAAY,CAACoD,qBAAqB,EAClCpD,YAAY,CAACqD,OAAO,CACrB;AAED,MAAMC,yBAAyB,GAAG,IAAIxD,aAAa,CACjD,iBAAiB,EACjBE,YAAY,CAACkD,UAAU,EACvBlD,YAAY,CAACmD,QAAQ,EACrB/C,gBAAgB,EAChBJ,YAAY,CAACoD,qBAAqB,EAClCpD,YAAY,CAACuD,gBAAgB,EAC7BvD,YAAY,CAACwD,SAAS,EACtBxD,YAAY,CAACqD,OAAO,EACpBrD,YAAY,CAACyD,aAAa,CAC3B;AAQD,MAAMC,gBAAgB,GAAGT,eAAe,CAACU,gBAAgB;AAQzD,MAAMC,qBAAqB,GAAGN,yBAAyB,CAACK,gBAAgB;AAQxE,OAAM,SAAUE,iBAAiBA,CAAA;EAC/B,MAAM,IAAIC,KAAK,CAAC,qBAAqB,CAAC;AACxC;AAEA,SACEb,eAAe,EACfK,yBAAyB,EACzBI,gBAAgB,EAChBE,qBAAqB,EACrBzB,oBAAoB,IAAI4B,oBAAoB"},"metadata":{},"sourceType":"module","externalDependencies":[]}