{"ast":null,"code":"import { utilities, cache } from '@cornerstonejs/core';\nimport { getVoxelOverlap } from '../segmentation/utilities';\nimport pointInShapeCallback from '../pointInShapeCallback';\nfunction getDataInTime(dynamicVolume, options) {\n  let dataInTime;\n  const frames = options.frameNumbers || [...Array(dynamicVolume.numTimePoints).keys()];\n  if (!options.maskVolumeId && !options.imageCoordinate) {\n    throw new Error('You should provide either maskVolumeId or imageCoordinate');\n  }\n  if (options.maskVolumeId && options.imageCoordinate) {\n    throw new Error('You can only use one of maskVolumeId or imageCoordinate');\n  }\n  if (options.maskVolumeId) {\n    const segmentationVolume = cache.getVolume(options.maskVolumeId);\n    const [dataInTime, ijkCoords] = _getTimePointDataMask(frames, dynamicVolume, segmentationVolume);\n    return [dataInTime, ijkCoords];\n  }\n  if (options.imageCoordinate) {\n    const dataInTime = _getTimePointDataCoordinate(frames, options.imageCoordinate, dynamicVolume);\n    return dataInTime;\n  }\n  return dataInTime;\n}\nfunction _getTimePointDataCoordinate(frames, coordinate, volume) {\n  const {\n    dimensions,\n    imageData\n  } = volume;\n  const index = imageData.worldToIndex(coordinate);\n  index[0] = Math.floor(index[0]);\n  index[1] = Math.floor(index[1]);\n  index[2] = Math.floor(index[2]);\n  if (!utilities.indexWithinDimensions(index, dimensions)) {\n    throw new Error('outside bounds');\n  }\n  const yMultiple = dimensions[0];\n  const zMultiple = dimensions[0] * dimensions[1];\n  const allScalarData = volume.getScalarDataArrays();\n  const value = [];\n  frames.forEach(frame => {\n    const activeScalarData = allScalarData[frame];\n    const scalarIndex = index[2] * zMultiple + index[1] * yMultiple + index[0];\n    value.push(activeScalarData[scalarIndex]);\n  });\n  return value;\n}\nfunction _getTimePointDataMask(frames, dynamicVolume, segmentationVolume) {\n  const {\n    imageData: maskImageData\n  } = segmentationVolume;\n  const segScalarData = segmentationVolume.getScalarData();\n  const len = segScalarData.length;\n  const nonZeroVoxelIndices = [];\n  nonZeroVoxelIndices.length = len;\n  const ijkCoords = [];\n  const dimensions = segmentationVolume.dimensions;\n  let actualLen = 0;\n  for (let i = 0, len = segScalarData.length; i < len; i++) {\n    if (segScalarData[i] !== 0) {\n      ijkCoords.push([i % dimensions[0], Math.floor(i / dimensions[0] % dimensions[1]), Math.floor(i / (dimensions[0] * dimensions[1]))]);\n      nonZeroVoxelIndices[actualLen++] = i;\n    }\n  }\n  nonZeroVoxelIndices.length = actualLen;\n  const dynamicVolumeScalarDataArray = dynamicVolume.getScalarDataArrays();\n  const values = [];\n  const isSameVolume = dynamicVolumeScalarDataArray[0].length === len && JSON.stringify(dynamicVolume.spacing) === JSON.stringify(segmentationVolume.spacing);\n  if (isSameVolume) {\n    for (let i = 0; i < nonZeroVoxelIndices.length; i++) {\n      const indexValues = [];\n      frames.forEach(frame => {\n        const activeScalarData = dynamicVolumeScalarDataArray[frame];\n        indexValues.push(activeScalarData[nonZeroVoxelIndices[i]]);\n      });\n      values.push(indexValues);\n    }\n    return [values, ijkCoords];\n  }\n  const callback = ({\n    pointLPS: segPointLPS,\n    value: segValue,\n    pointIJK: segPointIJK\n  }) => {\n    if (segValue === 0) {\n      return;\n    }\n    const overlapIJKMinMax = getVoxelOverlap(dynamicVolume.imageData, dynamicVolume.dimensions, dynamicVolume.spacing, segPointLPS);\n    let count = 0;\n    const perFrameSum = new Map();\n    frames.forEach(frame => perFrameSum.set(frame, 0));\n    const averageCallback = ({\n      index\n    }) => {\n      for (let i = 0; i < frames.length; i++) {\n        const value = dynamicVolumeScalarDataArray[i][index];\n        const frame = frames[i];\n        perFrameSum.set(frame, perFrameSum.get(frame) + value);\n      }\n      count++;\n    };\n    pointInShapeCallback(dynamicVolume.imageData, () => true, averageCallback, overlapIJKMinMax);\n    const averageValues = [];\n    perFrameSum.forEach(sum => {\n      averageValues.push(sum / count);\n    });\n    ijkCoords.push(segPointIJK);\n    values.push(averageValues);\n  };\n  pointInShapeCallback(maskImageData, () => true, callback);\n  return [values, ijkCoords];\n}\nexport default getDataInTime;","map":{"version":3,"names":["utilities","cache","getVoxelOverlap","pointInShapeCallback","getDataInTime","dynamicVolume","options","dataInTime","frames","frameNumbers","Array","numTimePoints","keys","maskVolumeId","imageCoordinate","Error","segmentationVolume","getVolume","ijkCoords","_getTimePointDataMask","_getTimePointDataCoordinate","coordinate","volume","dimensions","imageData","index","worldToIndex","Math","floor","indexWithinDimensions","yMultiple","zMultiple","allScalarData","getScalarDataArrays","value","forEach","frame","activeScalarData","scalarIndex","push","maskImageData","segScalarData","getScalarData","len","length","nonZeroVoxelIndices","actualLen","i","dynamicVolumeScalarDataArray","values","isSameVolume","JSON","stringify","spacing","indexValues","callback","pointLPS","segPointLPS","segValue","pointIJK","segPointIJK","overlapIJKMinMax","count","perFrameSum","Map","set","averageCallback","get","averageValues","sum"],"sources":["../../../../src/utilities/dynamicVolume/getDataInTime.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}