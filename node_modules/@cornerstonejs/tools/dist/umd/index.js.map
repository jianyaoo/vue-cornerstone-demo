{"version":3,"file":"index.js","mappings":"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AK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAA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","sources":["webpack://cornerstoneTools3D/webpack/universalModuleDefinition","webpack://cornerstoneTools3D/../../node_modules/lodash.clonedeep/index.js","webpack://cornerstoneTools3D/../../node_modules/lodash.get/index.js","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/CellArray\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/DataArray\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/Math\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/MatrixBuilder\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/Points\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/DataModel/ImageData\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/DataModel/PolyData\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Filters/General/AppendPolyData\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Filters/General/ImageMarchingSquares\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/IO/XML/XMLPolyDataReader\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Rendering/Core/Actor\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Rendering/Core/AxesActor\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Rendering/Core/Mapper\"","webpack://cornerstoneTools3D/external umd {\"root\":\"cornerstone3D\",\"commonjs\":\"@cornerstonejs/core\",\"commonjs2\":\"@cornerstonejs/core\",\"amd\":\"@cornerstonejs/core\"}","webpack://cornerstoneTools3D/external umd {\"root\":\"window\",\"commonjs\":\"gl-matrix\",\"commonjs2\":\"gl-matrix\",\"amd\":\"gl-matrix\"}","webpack://cornerstoneTools3D/webpack/bootstrap","webpack://cornerstoneTools3D/webpack/runtime/compat get default export","webpack://cornerstoneTools3D/webpack/runtime/define property getters","webpack://cornerstoneTools3D/webpack/runtime/get javascript chunk filename","webpack://cornerstoneTools3D/webpack/runtime/global","webpack://cornerstoneTools3D/webpack/runtime/hasOwnProperty shorthand","webpack://cornerstoneTools3D/webpack/runtime/make namespace object","webpack://cornerstoneTools3D/webpack/runtime/node module decorator","webpack://cornerstoneTools3D/webpack/runtime/publicPath","webpack://cornerstoneTools3D/webpack/runtime/jsonp chunk loading","webpack://cornerstoneTools3D/./src/enums/Events.ts","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","webpack://cornerstoneTools3D/./src/stateManagement/annotation/annotationLocking.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/annotationSelection.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/annotationVisibility.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.ts","webpack://cornerstoneTools3D/./src/enums/ChangeTypes.ts","webpack://cornerstoneTools3D/./src/store/svgNodeCache.ts","webpack://cornerstoneTools3D/./src/store/state.ts","webpack://cornerstoneTools3D/./src/enums/ToolModes.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/getToolGroupsWithToolName.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/helpers/state.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/annotationState.ts","webpack://cornerstoneTools3D/./src/enums/SegmentationRepresentations.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/contourConfig.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/labelmapConfig.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Surface/surfaceConfig.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/SegmentationStateManager.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/utils/stackVolumeCheck.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/getUniqueSegmentIndices.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/triggerSegmentationEvents.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/helpers/normalizeSegmentationInput.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/segmentationState.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/getMouseEventPoints.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/mouseDoubleClickListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/mouseMoveListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/mouseDownListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/index.ts","webpack://cornerstoneTools3D/./src/eventListeners/wheel/wheelListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/wheel/normalizeWheel.ts","webpack://cornerstoneTools3D/./src/eventListeners/wheel/index.ts","webpack://cornerstoneTools3D/./src/eventListeners/touch/preventGhostClick.js","webpack://cornerstoneTools3D/./src/enums/Touch.ts","webpack://cornerstoneTools3D/./src/eventListeners/touch/getTouchEventPoints.ts","webpack://cornerstoneTools3D/./src/utilities/touch/index.ts","webpack://cornerstoneTools3D/./src/eventListeners/touch/touchStartListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/touch/index.ts","webpack://cornerstoneTools3D/./src/eventListeners/keyboard/keyDownListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/keyboard/index.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/getToolGroupForViewport.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/getToolGroup.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/config/segmentationConfig.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/config/segmentationVisibility.ts","webpack://cornerstoneTools3D/./src/tools/base/BaseTool.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Surface/removeSurfaceFromElement.ts","webpack://cornerstoneTools3D/./src/enums/WorkerTypes.ts","webpack://cornerstoneTools3D/./src/utilities/pointToString.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/polySeg/registerPolySegWorker.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/helpers/clipAndCacheSurfacesForViewport.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/validateLabelmap.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/polySeg/canComputeRequestedRepresentation.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/addRepresentationData.ts","webpack://cornerstoneTools3D/./src/utilities/isObject.js","webpack://cornerstoneTools3D/./src/utilities/debounce.js","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/polySeg/computeAndAddRepresentation.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/polySeg/Surface/convertContourToSurface.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/config/segmentationColor.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/polySeg/Surface/createAndCacheSurfacesFromRaw.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/addLabelmapToElement.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/removeLabelmapFromElement.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/polySeg/Labelmap/convertContourToLabelmap.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/polySeg/Labelmap/convertSurfaceToLabelmap.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/createImageIdReferenceMap.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/convertVolumeToStackSegmentation.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/polySeg/Labelmap/computeAndAddLabelmapRepresentation.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/polySeg/Labelmap/labelmapComputationStrategies.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/labelmapDisplay.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/helpers/getRepresentationSpecificConfig.ts","webpack://cornerstoneTools3D/./src/constants/COLOR_LUT.ts","webpack://cornerstoneTools3D/./src/drawingSvg/getSvgDrawingHelper.ts","webpack://cornerstoneTools3D/./src/drawingSvg/draw.ts","webpack://cornerstoneTools3D/./src/utilities/getToolsWithModesForElement.ts","webpack://cornerstoneTools3D/./src/utilities/triggerAnnotationRender.ts","webpack://cornerstoneTools3D/./src/utilities/triggerAnnotationRenderForViewportIds.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/addSegmentationRepresentations.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/addSegmentationRepresentation.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/convertStackToVolumeSegmentation.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/polySeg/Surface/convertLabelmapToSurface.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/polySeg/Surface/surfaceComputationStrategies.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/polySeg/Surface/computeAndAddSurfaceRepresentation.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/polySeg/Surface/updateSurfaceData.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Surface/surfaceDisplay.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Surface/addOrUpdateSurfaceToElement.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/vtkContour/utils.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/vtkContour/contourConfigCache.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/vtkContour/addContourSetsToElement.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/vtkContour/updateVTKContourSets.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/removeContourFromElement.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/polySeg/Contour/utils/extractContourData.ts","webpack://cornerstoneTools3D/./src/utilities/getCalibratedUnits.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/getAABB.ts","webpack://cornerstoneTools3D/./src/utilities/getAnnotationNearPoint.ts","webpack://cornerstoneTools3D/./src/utilities/throttle.js","webpack://cornerstoneTools3D/./src/utilities/clip.js","webpack://cornerstoneTools3D/./src/utilities/calibrateImageSpacing.ts","webpack://cornerstoneTools3D/./src/utilities/triggerAnnotationRenderForToolGroupIds.ts","webpack://cornerstoneTools3D/./src/utilities/scroll.ts","webpack://cornerstoneTools3D/./src/utilities/viewport/jumpToSlice.ts","webpack://cornerstoneTools3D/./src/utilities/pointInShapeCallback.ts","webpack://cornerstoneTools3D/./src/utilities/boundingBox/getBoundingBoxAroundShape.ts","webpack://cornerstoneTools3D/./src/utilities/getSphereBoundsInfo.ts","webpack://cornerstoneTools3D/./src/utilities/annotationFrameRange.ts","webpack://cornerstoneTools3D/./src/utilities/math/sphere/pointInSphere.ts","webpack://cornerstoneTools3D/./src/utilities/pointInSurroundingSphereCallback.ts","webpack://cornerstoneTools3D/./src/utilities/getViewportsForAnnotation.ts","webpack://cornerstoneTools3D/./src/utilities/getViewportForAnnotation.ts","webpack://cornerstoneTools3D/./src/utilities/contours/areCoplanarContours.ts","webpack://cornerstoneTools3D/./src/utilities/contours/contourFinder.ts","webpack://cornerstoneTools3D/./src/utilities/contours/getDeduplicatedVTKPolyDataPoints.ts","webpack://cornerstoneTools3D/./src/utilities/contours/detectContourHoles.ts","webpack://cornerstoneTools3D/./src/utilities/contours/generateContourSetsFromLabelmap.ts","webpack://cornerstoneTools3D/./src/utilities/contours/RectangleROIStartEndThreshold.ts","webpack://cornerstoneTools3D/./src/utilities/contours/AnnotationToPointData.ts","webpack://cornerstoneTools3D/./src/utilities/contours/getContourHolesDataWorld.ts","webpack://cornerstoneTools3D/./src/utilities/contours/getContourHolesDataCanvas.ts","webpack://cornerstoneTools3D/./src/utilities/math/point/distanceToPointSquared.ts","webpack://cornerstoneTools3D/./src/utilities/math/line/distanceToPointSquaredInfo.ts","webpack://cornerstoneTools3D/./src/utilities/math/line/distanceToPointSquared.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/decimate.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/getSignedArea.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/getWindingDirection.ts","webpack://cornerstoneTools3D/./src/utilities/contours/updateContourPolyline.ts","webpack://cornerstoneTools3D/./src/utilities/contours/interpolation/getInterpolationData.ts","webpack://cornerstoneTools3D/./src/utilities/contours/interpolation/createPolylineToolData.ts","webpack://cornerstoneTools3D/./src/utilities/contours/interpolation/findAnnotationForInterpolation.ts","webpack://cornerstoneTools3D/./src/utilities/contours/interpolation/selectHandles.ts","webpack://cornerstoneTools3D/./src/utilities/math/aabb/intersectAABB.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/areLineSegmentsIntersecting.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/getFirstLineSegmentIntersectionIndexes.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/intersectPolyline.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/isClosed.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/containsPoint.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/containsPoints.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/getLineSegmentIntersectionsIndexes.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/getNormal2.ts","webpack://cornerstoneTools3D/./src/utilities/math/line/isPointOnLineSegment.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/getLinesIntersection.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/combinePolyline.ts","webpack://cornerstoneTools3D/./src/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.ts","webpack://cornerstoneTools3D/./src/utilities/viewportFilters/filterViewportsWithToolEnabled.ts","webpack://cornerstoneTools3D/./src/utilities/viewportFilters/filterViewportsWithParallelNormals.ts","webpack://cornerstoneTools3D/./src/utilities/viewportFilters/getViewportIdsWithToolToRender.ts","webpack://cornerstoneTools3D/./src/utilities/contourSegmentation/isContourSegmentationAnnotation.ts","webpack://cornerstoneTools3D/./src/utilities/contourSegmentation/areSameSegment.ts","webpack://cornerstoneTools3D/./src/utilities/contourSegmentation/removeContourSegmentationAnnotation.ts","webpack://cornerstoneTools3D/./src/utilities/contourSegmentation/addContourSegmentationAnnotation.ts","webpack://cornerstoneTools3D/./src/store/addTool.ts","webpack://cornerstoneTools3D/./src/types/ContourAnnotation.ts","webpack://cornerstoneTools3D/./src/eventListeners/annotations/contourSegmentation/contourSegmentationCompleted.ts","webpack://cornerstoneTools3D/./src/utilities/contours/interpolation/interpolate.ts","webpack://cornerstoneTools3D/./src/utilities/contours/interpolation/updateChildInterpolationUID.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/InterpolationManager/deleteRelatedAnnotations.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/InterpolationManager/InterpolationManager.ts","webpack://cornerstoneTools3D/./src/utilities/contours/interpolation/acceptAutogeneratedInterpolations.ts","webpack://cornerstoneTools3D/./src/utilities/contours/interpolation/getInterpolationDataCollection.ts","webpack://cornerstoneTools3D/./src/utilities/contours/findHandlePolylineIndex.ts","webpack://cornerstoneTools3D/./src/utilities/contours/calculatePerimeter.ts","webpack://cornerstoneTools3D/./src/enums/StrategyCallbacks.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/compositions/determineSegmentIndex.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/compositions/dynamicThreshold.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/compositions/erase.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/floodFill.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/compositions/index.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/compositions/islandRemoval.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/compositions/preview.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/compositions/regionFill.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/compositions/setValue.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/compositions/threshold.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/utils/getStrategyData.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/BrushStrategy.ts","webpack://cornerstoneTools3D/./src/utilities/math/ellipse/getCanvasEllipseCorners.ts","webpack://cornerstoneTools3D/./src/utilities/math/ellipse/pointInEllipse.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/fillCircle.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/fillSphere.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/eraseSphere.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/eraseCircle.ts","webpack://cornerstoneTools3D/./src/drawingSvg/_getHash.ts","webpack://cornerstoneTools3D/./src/drawingSvg/setAttributesIfNecessary.ts","webpack://cornerstoneTools3D/./src/drawingSvg/setNewAttributesIfValid.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawCircle.ts","webpack://cornerstoneTools3D/./src/cursors/MouseCursor.ts","webpack://cornerstoneTools3D/./src/cursors/elementCursor.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/activeSegmentation.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/segmentLocking.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/invalidateBrushCursor.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/segmentIndex.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/BrushTool.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/utilities.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/thresholdVolumeByRange.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawHandle.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawHandles.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawRect.ts","webpack://cornerstoneTools3D/./src/utilities/planar/filterAnnotationsWithinSlice.ts","webpack://cornerstoneTools3D/./src/utilities/planar/filterAnnotationsForDisplay.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/config/ToolStyle.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/config/helpers.ts","webpack://cornerstoneTools3D/./src/enums/AnnotationStyleStates.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/config/getState.ts","webpack://cornerstoneTools3D/./src/tools/base/AnnotationDisplayTool.ts","webpack://cornerstoneTools3D/./src/tools/base/AnnotationTool.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawTextBox.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawLine.ts","webpack://cornerstoneTools3D/./src/utilities/math/vec2/findClosestPoint.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawLink.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawLinkedTextBox.ts","webpack://cornerstoneTools3D/./src/utilities/math/line/distanceToPoint.ts","webpack://cornerstoneTools3D/./src/utilities/math/rectangle/distanceToPoint.ts","webpack://cornerstoneTools3D/./src/utilities/drawing/getTextBoxCoordsCanvas.ts","webpack://cornerstoneTools3D/./src/utilities/planar/getWorldWidthAndHeightFromCorners.ts","webpack://cornerstoneTools3D/./src/utilities/getModalityUnit.ts","webpack://cornerstoneTools3D/./src/utilities/viewport/isViewportPreScaled.ts","webpack://cornerstoneTools3D/./src/utilities/math/basic/Calculator.ts","webpack://cornerstoneTools3D/./src/utilities/math/basic/BasicStatsCalculator.ts","webpack://cornerstoneTools3D/./src/tools/annotation/RectangleROITool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/RectangleROIThresholdTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/RectangleROIStartEndThresholdTool.ts","webpack://cornerstoneTools3D/./src/utilities/boundingBox/extend2DBoundingBoxInViewAxis.ts","webpack://cornerstoneTools3D/./src/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/rectangleROIThresholdVolumeByRange.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/createMergedLabelmapForIndex.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/isValidRepresentationConfig.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/getDefaultRepresentationConfig.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/createLabelmapVolumeForViewport.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/brushSizeForToolGroup.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/brushThresholdForToolGroup.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/thresholdSegmentationByRange.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/isLineInSegment.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/findLargestBidirectional.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/contourAndFindLargestBidirectional.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/createBidirectionalToolData.ts","webpack://cornerstoneTools3D/./src/utilities/math/line/intersectLine.ts","webpack://cornerstoneTools3D/./src/tools/annotation/BidirectionalTool.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/segmentContourAction.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/projectTo2D.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/isPointInsidePolyline3D.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/getSegmentAtWorldPoint.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/getSegmentAtLabelmapBorder.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/getHoveredContourSegmentationAnnotation.ts","webpack://cornerstoneTools3D/./src/utilities/math/aabb/distanceToPointSquared.ts","webpack://cornerstoneTools3D/./src/utilities/math/aabb/distanceToPoint.ts","webpack://cornerstoneTools3D/./src/utilities/math/point/distanceToPoint.ts","webpack://cornerstoneTools3D/./src/utilities/math/point/mirror.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/getArea.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/getNormal3.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/getLineSegmentIntersectionsCoordinates.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/getClosestLineSegmentIntersection.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/getSubPixelSpacingAndXYDirections.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/pointsAreWithinCloseContourProximity.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/addCanvasPointsToArray.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/pointCanProjectOnLine.ts","webpack://cornerstoneTools3D/./src/utilities/math/vec2/liangBarksyClip.ts","webpack://cornerstoneTools3D/./src/utilities/planar/getPointInLineOfSightWithCriteria.ts","webpack://cornerstoneTools3D/./src/utilities/planar/isPlaneIntersectingAABB.ts","webpack://cornerstoneTools3D/./src/utilities/planar/index.ts","webpack://cornerstoneTools3D/./src/utilities/orientation/getOrientationStringLPS.ts","webpack://cornerstoneTools3D/./src/utilities/orientation/invertOrientationStringLPS.ts","webpack://cornerstoneTools3D/./src/utilities/cine/events.ts","webpack://cornerstoneTools3D/./src/utilities/cine/state.ts","webpack://cornerstoneTools3D/./src/utilities/cine/playClip.ts","webpack://cornerstoneTools3D/../../node_modules/d3-interpolate/src/basis.js","webpack://cornerstoneTools3D/../../node_modules/d3-interpolate/src/quantize.js","webpack://cornerstoneTools3D/../../node_modules/d3-array/src/transpose.js","webpack://cornerstoneTools3D/../../node_modules/d3-array/src/zip.js","webpack://cornerstoneTools3D/../../node_modules/d3-array/src/min.js","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints.ts","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/interpolation/algorithms/bspline.ts","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/smoothAnnotation.ts","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/index.ts","webpack://cornerstoneTools3D/./src/utilities/rectangleROITool/isAxisAlignedRectangle.ts","webpack://cornerstoneTools3D/./src/utilities/stackPrefetch/state.ts","webpack://cornerstoneTools3D/./src/utilities/stackPrefetch/stackPrefetchUtils.ts","webpack://cornerstoneTools3D/./src/utilities/stackPrefetch/stackPrefetch.ts","webpack://cornerstoneTools3D/./src/utilities/stackPrefetch/stackContextPrefetch.ts","webpack://cornerstoneTools3D/./src/utilities/viewport/jumpToWorld.ts","webpack://cornerstoneTools3D/./src/utilities/dynamicVolume/getDataInTime.ts","webpack://cornerstoneTools3D/./src/utilities/dynamicVolume/generateImageFromTimeData.ts","webpack://cornerstoneTools3D/./src/utilities/polyData/utils.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/common/isRangeValid.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/common/areColorbarRangesEqual.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/common/isColorbarSizeValid.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/common/areColorbarSizesEqual.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/ColorbarCanvas.ts","webpack://cornerstoneTools3D/./src/utilities/math/vec3/interpolateVec3.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/ColorbarTicks.ts","webpack://cornerstoneTools3D/./src/widgets/Widget.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/Colorbar.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/common/isRangeTextPositionValid.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/ViewportColorbar.ts","webpack://cornerstoneTools3D/./src/utilities/getVOIMultipliers.ts","webpack://cornerstoneTools3D/./src/utilities/index.ts","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/smoothPoints.ts","webpack://cornerstoneTools3D/./src/enums/ToolBindings.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getMouseModifier.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/findOpenUShapedContourVectorToPeak.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/drawLoop.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/editLoopCommon.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/closedContourEditLoop.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/openContourEditLoop.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/openContourEndEditLoop.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawPath.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawPolyline.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/renderMethods.ts","webpack://cornerstoneTools3D/./src/tools/base/ContourBaseTool.ts","webpack://cornerstoneTools3D/./src/tools/base/ContourSegmentationBaseTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/PlanarFreehandROITool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/PlanarFreehandContourSegmentationTool.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/polySeg/Contour/utils/createAndAddContourSegmentationsFromClippedSurfaces.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/polySeg/Contour/computeAndAddContourRepresentation.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/polySeg/Contour/contourComputationStrategies.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/contourDisplay.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/vtkContour/addOrUpdateVTKContourSets.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/SegmentationDisplayTool.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/triggerSegmentationRender.ts","webpack://cornerstoneTools3D/./src/eventListeners/segmentation/imageChangeEventListener.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/imageRenderedEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getToolsWithModesForMouseEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/cameraModifiedEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/imageSpacingCalibratedEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/customCallbackHandler.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseClick.ts","webpack://cornerstoneTools3D/./src/store/filterToolsWithMoveableHandles.ts","webpack://cornerstoneTools3D/./src/store/filterToolsWithAnnotationsForElement.ts","webpack://cornerstoneTools3D/./src/store/filterMoveableAnnotationTools.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getActiveToolForMouseEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseDownAnnotationAction.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseDown.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getToolsWithActionsForMouseEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseDownActivate.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseDoubleClick.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseDrag.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseMove.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseUp.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseWheel.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseToolEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getActiveToolForKeyboardEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/keyboardEventHandlers/keyDown.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getToolsWithActionsForKeyboardEvents.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/keyboardEventHandlers/keyUp.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/keyboardToolEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getActiveToolForTouchEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getToolsWithModesForTouchEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchStart.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchStartActivate.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchDrag.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchEnd.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchTap.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchPress.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchToolEventDispatcher.ts","webpack://cornerstoneTools3D/./src/store/addEnabledElement.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/getSynchronizersForViewport.ts","webpack://cornerstoneTools3D/./src/store/removeEnabledElement.ts","webpack://cornerstoneTools3D/./src/eventListeners/annotations/annotationCompletedListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/annotations/annotationModifiedListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/annotations/annotationSelectionListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/annotations/annotationRemovedListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/annotations/contourSegmentation/contourSegmentationRemoved.ts","webpack://cornerstoneTools3D/./src/eventListeners/segmentation/segmentationModifiedEventListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/segmentation/segmentationDataModifiedEventListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/segmentation/labelmap/onLabelmapSegmentationDataModified.ts","webpack://cornerstoneTools3D/./src/eventListeners/segmentation/segmentationRepresentationModifiedEventListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/segmentation/segmentationRepresentationRemovedEventListener.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/annotationInterpolationEventDispatcher.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/removeSegmentationsFromToolGroup.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/destroyToolGroup.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/destroy.ts","webpack://cornerstoneTools3D/./src/init.ts","webpack://cornerstoneTools3D/./src/store/cancelActiveManipulations.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/Synchronizer.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/createSynchronizer.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/destroy.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/getSynchronizer.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/getAllSynchronizers.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/destroySynchronizer.ts","webpack://cornerstoneTools3D/./src/cursors/ImageMouseCursor.ts","webpack://cornerstoneTools3D/./src/cursors/SVGCursorDescriptor.ts","webpack://cornerstoneTools3D/./src/cursors/SVGMouseCursor.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/ToolGroup.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/createToolGroup.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/getAllToolGroups.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/cameraSyncCallback.ts","webpack://cornerstoneTools3D/./src/synchronizers/synchronizers/createCameraPositionSynchronizer.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/presentationViewSyncCallback.ts","webpack://cornerstoneTools3D/./src/synchronizers/synchronizers/createPresentationViewSynchronizer.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/voiSyncCallback.ts","webpack://cornerstoneTools3D/./src/synchronizers/synchronizers/createVOISynchronizer.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/zoomPanSyncCallback.ts","webpack://cornerstoneTools3D/./src/synchronizers/synchronizers/createZoomPanSynchronizer.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/imageSliceSyncCallback.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/areViewportsCoplanar .ts","webpack://cornerstoneTools3D/./src/synchronizers/synchronizers/createImageSliceSynchronizer.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/slabThicknessSyncCallback.ts","webpack://cornerstoneTools3D/./src/synchronizers/synchronizers/createSlabThicknessSynchronizer.ts","webpack://cornerstoneTools3D/./src/synchronizers/index.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawEllipseByCoordinates.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawEllipse.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawArrow.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawRedactionRect.ts","webpack://cornerstoneTools3D/./src/cursors/setCursorForElement.ts","webpack://cornerstoneTools3D/./src/cursors/index.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/config/getFont.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/AnnotationGroup.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/helpers/validateSegmentationInput.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/addSegmentations.ts","webpack://cornerstoneTools3D/./src/tools/PanTool.ts","webpack://cornerstoneTools3D/./src/tools/TrackballRotateTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/ProbeTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/DragProbeTool.ts","webpack://cornerstoneTools3D/./src/tools/WindowLevelTool.ts","webpack://cornerstoneTools3D/./src/tools/ZoomTool.ts","webpack://cornerstoneTools3D/./src/tools/StackScrollTool.ts","webpack://cornerstoneTools3D/./src/utilities/math/angle/angleBetweenLines.ts","webpack://cornerstoneTools3D/./src/tools/PlanarRotateTool.ts","webpack://cornerstoneTools3D/./src/tools/StackScrollToolMouseWheelTool.ts","webpack://cornerstoneTools3D/./src/tools/VolumeRotateMouseWheelTool.ts","webpack://cornerstoneTools3D/./src/tools/MIPJumpToClickTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/LengthTool.ts","webpack://cornerstoneTools3D/./src/tools/CrosshairsTool.ts","webpack://cornerstoneTools3D/./src/tools/ReferenceLinesTool.ts","webpack://cornerstoneTools3D/./src/tools/OverlayGridTool.ts","webpack://cornerstoneTools3D/./src/tools/SegmentationIntersectionTool.ts","webpack://cornerstoneTools3D/./src/utilities/planar/getWorldWidthAndHeightFromTwoPoints.ts","webpack://cornerstoneTools3D/./src/tools/annotation/EllipticalROITool.ts","webpack://cornerstoneTools3D/./src/utilities/math/circle/getCanvasCircleRadius.ts","webpack://cornerstoneTools3D/./src/utilities/math/circle/getCanvasCircleCorners.ts","webpack://cornerstoneTools3D/./src/tools/annotation/CircleROITool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/splines/Spline.ts","webpack://cornerstoneTools3D/./src/tools/annotation/splines/CubicSpline.ts","webpack://cornerstoneTools3D/./src/tools/annotation/splines/CardinalSpline.ts","webpack://cornerstoneTools3D/./src/tools/annotation/splines/LinearSpline.ts","webpack://cornerstoneTools3D/./src/tools/annotation/splines/CatmullRomSpline.ts","webpack://cornerstoneTools3D/./src/tools/annotation/splines/BSpline.ts","webpack://cornerstoneTools3D/./src/tools/annotation/SplineROITool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/SplineContourSegmentationTool.ts","webpack://cornerstoneTools3D/./src/utilities/BucketQueue.ts","webpack://cornerstoneTools3D/./src/utilities/livewire/LivewireScissors.ts","webpack://cornerstoneTools3D/./src/utilities/livewire/LiveWirePath.ts","webpack://cornerstoneTools3D/./src/tools/annotation/LivewireContourTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/LivewireContourSegmentationTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/ArrowAnnotateTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/AngleTool.ts","webpack://cornerstoneTools3D/./src/utilities/math/midPoint.ts","webpack://cornerstoneTools3D/./src/tools/annotation/CobbAngleTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/UltrasoundDirectionalTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/KeyImageTool.ts","webpack://cornerstoneTools3D/./src/tools/MagnifyTool.ts","webpack://cornerstoneTools3D/./src/tools/AdvancedMagnifyViewport.ts","webpack://cornerstoneTools3D/./src/tools/AdvancedMagnifyViewportManager.ts","webpack://cornerstoneTools3D/./src/tools/AdvancedMagnifyTool.ts","webpack://cornerstoneTools3D/./src/tools/ReferenceCursors.ts","webpack://cornerstoneTools3D/./src/tools/ScaleOverlayTool.ts","webpack://cornerstoneTools3D/./src/tools/AnnotationEraserTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/fillRectangle.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/eraseRectangle.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/RectangleScissorsTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/CircleScissorsTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/SphereScissorsTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/CircleROIStartEndThresholdTool.ts","webpack://cornerstoneTools3D/./src/tools/OrientationMarkerTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/SegmentSelectTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/PaintFillTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/VideoRedactionTool.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"gl-matrix\"), require(\"@cornerstonejs/core\"), require(\"@kitware/vtk.js/Common/Core/Math\"), require(\"@kitware/vtk.js/Filters/General/ImageMarchingSquares\"), require(\"@kitware/vtk.js/Common/Core/DataArray\"), require(\"@kitware/vtk.js/Common/DataModel/ImageData\"), require(\"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\"), require(\"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\"), require(\"@kitware/vtk.js/Common/Core/CellArray\"), require(\"@kitware/vtk.js/Common/Core/Points\"), require(\"@kitware/vtk.js/Common/DataModel/PolyData\"), require(\"@kitware/vtk.js/Filters/General/AppendPolyData\"), require(\"@kitware/vtk.js/Rendering/Core/Actor\"), require(\"@kitware/vtk.js/Rendering/Core/Mapper\"), require(\"@kitware/vtk.js/Common/Core/MatrixBuilder\"), require(\"@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget\"), require(\"@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor\"), require(\"@kitware/vtk.js/Rendering/Core/AxesActor\"), require(\"@kitware/vtk.js/IO/XML/XMLPolyDataReader\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"gl-matrix\", \"@cornerstonejs/core\", \"@kitware/vtk.js/Common/Core/Math\", \"@kitware/vtk.js/Filters/General/ImageMarchingSquares\", \"@kitware/vtk.js/Common/Core/DataArray\", \"@kitware/vtk.js/Common/DataModel/ImageData\", \"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\", \"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\", \"@kitware/vtk.js/Common/Core/CellArray\", \"@kitware/vtk.js/Common/Core/Points\", \"@kitware/vtk.js/Common/DataModel/PolyData\", \"@kitware/vtk.js/Filters/General/AppendPolyData\", \"@kitware/vtk.js/Rendering/Core/Actor\", \"@kitware/vtk.js/Rendering/Core/Mapper\", \"@kitware/vtk.js/Common/Core/MatrixBuilder\", \"@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget\", \"@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor\", \"@kitware/vtk.js/Rendering/Core/AxesActor\", \"@kitware/vtk.js/IO/XML/XMLPolyDataReader\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cornerstoneTools3D\"] = factory(require(\"gl-matrix\"), require(\"@cornerstonejs/core\"), require(\"@kitware/vtk.js/Common/Core/Math\"), require(\"@kitware/vtk.js/Filters/General/ImageMarchingSquares\"), require(\"@kitware/vtk.js/Common/Core/DataArray\"), require(\"@kitware/vtk.js/Common/DataModel/ImageData\"), require(\"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\"), require(\"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\"), require(\"@kitware/vtk.js/Common/Core/CellArray\"), require(\"@kitware/vtk.js/Common/Core/Points\"), require(\"@kitware/vtk.js/Common/DataModel/PolyData\"), require(\"@kitware/vtk.js/Filters/General/AppendPolyData\"), require(\"@kitware/vtk.js/Rendering/Core/Actor\"), require(\"@kitware/vtk.js/Rendering/Core/Mapper\"), require(\"@kitware/vtk.js/Common/Core/MatrixBuilder\"), require(\"@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget\"), require(\"@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor\"), require(\"@kitware/vtk.js/Rendering/Core/AxesActor\"), require(\"@kitware/vtk.js/IO/XML/XMLPolyDataReader\"));\n\telse\n\t\troot[\"cornerstoneTools3D\"] = factory(root[\"window\"], root[\"cornerstone3D\"], root[\"@kitware/vtk.js/Common/Core/Math\"], root[\"@kitware/vtk.js/Filters/General/ImageMarchingSquares\"], root[\"@kitware/vtk.js/Common/Core/DataArray\"], root[\"@kitware/vtk.js/Common/DataModel/ImageData\"], root[\"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\"], root[\"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\"], root[\"@kitware/vtk.js/Common/Core/CellArray\"], root[\"@kitware/vtk.js/Common/Core/Points\"], root[\"@kitware/vtk.js/Common/DataModel/PolyData\"], root[\"@kitware/vtk.js/Filters/General/AppendPolyData\"], root[\"@kitware/vtk.js/Rendering/Core/Actor\"], root[\"@kitware/vtk.js/Rendering/Core/Mapper\"], root[\"@kitware/vtk.js/Common/Core/MatrixBuilder\"], root[\"@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget\"], root[\"@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor\"], root[\"@kitware/vtk.js/Rendering/Core/AxesActor\"], root[\"@kitware/vtk.js/IO/XML/XMLPolyDataReader\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__976__, __WEBPACK_EXTERNAL_MODULE__953__, __WEBPACK_EXTERNAL_MODULE__807__, __WEBPACK_EXTERNAL_MODULE__543__, __WEBPACK_EXTERNAL_MODULE__785__, __WEBPACK_EXTERNAL_MODULE__283__, __WEBPACK_EXTERNAL_MODULE__441__, __WEBPACK_EXTERNAL_MODULE__795__, __WEBPACK_EXTERNAL_MODULE__396__, __WEBPACK_EXTERNAL_MODULE__348__, __WEBPACK_EXTERNAL_MODULE__70__, __WEBPACK_EXTERNAL_MODULE__127__, __WEBPACK_EXTERNAL_MODULE__474__, __WEBPACK_EXTERNAL_MODULE__610__, __WEBPACK_EXTERNAL_MODULE__847__, __WEBPACK_EXTERNAL_MODULE__518__, __WEBPACK_EXTERNAL_MODULE__744__, __WEBPACK_EXTERNAL_MODULE__424__, __WEBPACK_EXTERNAL_MODULE__614__) => {\nreturn ","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\n/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {boolean} [isFull] Specify a clone including symbols.\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      if (isHostObject(value)) {\n        return object ? value : {};\n      }\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (!isArr) {\n    var props = isFull ? getAllKeys(value) : keys(value);\n  }\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var result = new buffer.constructor(buffer.length);\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n  return object;\n}\n\n/**\n * Copies own symbol properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Creates an array of the own enumerable symbol properties of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, true, true);\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = cloneDeep;\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__396__;","module.exports = __WEBPACK_EXTERNAL_MODULE__785__;","module.exports = __WEBPACK_EXTERNAL_MODULE__807__;","module.exports = __WEBPACK_EXTERNAL_MODULE__847__;","module.exports = __WEBPACK_EXTERNAL_MODULE__348__;","module.exports = __WEBPACK_EXTERNAL_MODULE__283__;","module.exports = __WEBPACK_EXTERNAL_MODULE__441__;","module.exports = __WEBPACK_EXTERNAL_MODULE__70__;","module.exports = __WEBPACK_EXTERNAL_MODULE__127__;","module.exports = __WEBPACK_EXTERNAL_MODULE__543__;","module.exports = __WEBPACK_EXTERNAL_MODULE__614__;","module.exports = __WEBPACK_EXTERNAL_MODULE__518__;","module.exports = __WEBPACK_EXTERNAL_MODULE__474__;","module.exports = __WEBPACK_EXTERNAL_MODULE__744__;","module.exports = __WEBPACK_EXTERNAL_MODULE__424__;","module.exports = __WEBPACK_EXTERNAL_MODULE__795__;","module.exports = __WEBPACK_EXTERNAL_MODULE__610__;","module.exports = __WEBPACK_EXTERNAL_MODULE__953__;","module.exports = __WEBPACK_EXTERNAL_MODULE__976__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".index.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t647: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// no jsonp function","/**\n *  The events for cornerstoneTools3D Tools. Native Mouse and Keyboard events are\n *  captured, normalized, and re-triggered with a `CORNERSTONE_TOOLS` prefix. This\n *  allows us to handle events consistently across different browsers.\n *\n */\nenum Events {\n  ///////////////////////////////////////\n  //            Tools\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a new tools is activated.\n   *\n   * Make use of {@link EventTypes.ToolActivatedEventType | Tool Activated Event Type  }\n   * for typing your event listeners for this tool activated event, and see what event\n   * detail is included in {@link EventTypes.ToolActivatedEventDetail | Tool Activated Event Detail}.\n   */\n  TOOL_ACTIVATED = 'CORNERSTONE_TOOLS_TOOL_ACTIVATED',\n\n  // fired when a viewport is added to the toolGroup\n  TOOLGROUP_VIEWPORT_ADDED = 'CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_ADDED',\n\n  // fired when a viewport is removed from the toolGroup\n  TOOLGROUP_VIEWPORT_REMOVED = 'CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when a mode of a tool is changed (active, passive, enabled and disabled).\n   *\n   * Make use of {@link EventTypes.ToolModeChangedEventType | Tool Mode Changed Event Type  }\n   * for typing your event listeners for this tool activated event, and see what event\n   * detail is included in {@link EventTypes.ToolModeChangedEventDetail | Tool Mode Changed Event Detail}.\n   */\n  TOOL_MODE_CHANGED = 'CORNERSTONE_TOOLS_TOOL_MODE_CHANGED',\n\n  ///////////////////////////////////////\n  //            Annotations\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a new annotation is added to the state.\n   *\n   * Make use of {@link EventTypes.AnnotationAddedEventType | Annotation Added Event Type  }\n   * for typing your event listeners for this annotation added event, and see what event\n   * detail is included in {@link EventTypes.AnnotationAddedEventDetail | Annotation Added Event Detail}.\n   */\n  ANNOTATION_ADDED = 'CORNERSTONE_TOOLS_ANNOTATION_ADDED',\n\n  /**\n   * Triggers on the eventTarget when a new annotation is completed its drawing\n   * Make use of {@link EventTypes.AnnotationCompletedEventType | Annotation Completed Event Type }\n   * for typing your event listeners for this annotation completed event, and see what event\n   * detail is included in {@link EventTypes.AnnotationCompletedEventDetail | Annotation Completed Event Detail}.\n   */\n  ANNOTATION_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_COMPLETED',\n\n  /**\n   * Triggers on the eventTarget when an annotation is modified (e.g. a handle is modified).\n   * Make use of {@link EventTypes.AnnotationModifiedEventType | Annotation Modified Event Type}\n   * for typing your event listeners for this annotation modified event, and see what\n   * event detail is included in {@link EventTypes.AnnotationModifiedEventDetail | Annotation Modified Event Detail}.\n   */\n  ANNOTATION_MODIFIED = 'CORNERSTONE_TOOLS_ANNOTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when an annotation is removed from the annotations manager.\n   * Make use of {@link EventTypes.AnnotationRemovedEventType | Annotation Removed Event Type}\n   * for typing your event listeners for this annotation removed event, and see what\n   * event detail is included in {@link EventTypes.AnnotationRemovedEventDetail | Annotation Removed Event Detail}.\n   */\n  ANNOTATION_REMOVED = 'CORNERSTONE_TOOLS_ANNOTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when an annotation selection status is changed.\n   * Make use of {@link EventTypes.AnnotationSelectionChangeEventType | Annotation Selection Change Event Type}\n   * for typing your event listeners for this annotation selection change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationSelectionChangeEventDetail | Annotation Selection Change Event Detail}.\n   */\n  ANNOTATION_SELECTION_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation locked status is changed.\n   * Make use of {@link EventTypes.AnnotationLockChangeEventType | Annotation Lock Change Event Type}\n   * for typing your event listeners for this annotation lock change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationLockChangeEventDetail | Annotation Lock Change Event Detail}.\n   */\n  ANNOTATION_LOCK_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation visible status is changed.\n   * Make use of {@link EventTypes.AnnotationVisibilityChangeEventType | Annotation Visible Change Event Type}\n   * for typing your event listeners for this annotation Hide change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationVisibilityChangeEventDetail | Annotation Visible Change Event Detail}.\n   */\n  ANNOTATION_VISIBILITY_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation is rendered.\n   * Make use of {@link EventTypes.AnnotationRenderedEventType | Annotation Rendered Event Type}\n   * for typing your event listeners for this annotation rendered event, and see what\n   * event detail is included in {@link EventTypes.AnnotationRenderedEventDetail | Annotation Rendered Event Detail}.\n   */\n  ANNOTATION_RENDERED = 'CORNERSTONE_TOOLS_ANNOTATION_RENDERED',\n\n  /**\n   * Triggers on the eventTarget when an annotation interpolation process completed.\n   * Make use of {@link EventTypes.AnnotationInterpolationCompletedEventType | Annotation Interpolation process Completed Event Type}\n   * for typing your event listeners for this annotation interpolation complete event, and see what\n   * event detail is included in {@link EventTypes.AnnotationInterpolationCompletedEventDetail | Annotation interpolation process Event Detail}.\n   */\n  ANNOTATION_INTERPOLATION_PROCESS_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED',\n\n  /**\n   * Triggers on the eventTarget when interpolated annotations are removed.\n   * Make use of {@link EventTypes.AnnotationInterpolationRemovedEventType | Annotation Interpolation Removed Event Type}\n   * for typing your event listeners for this interpolated annotation removed event, and see what\n   * event detail is included in {@link EventTypes.AnnotationInterpolationRemovedEventDetail | Annotation interpolation removed Event Detail}.\n   */\n  INTERPOLATED_ANNOTATIONS_REMOVED = 'CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED',\n\n  ///////////////////////////////////////\n  //        Segmentations Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is updated in the state manager.\n   * Make use of {@link EventTypes.SegmentationModifiedEventType | Segmentation Modified Event Type}\n   * for typing your event listeners for this segmentation modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationModifiedEventDetail | Segmentation Modified Event Detail}.\n   */\n  SEGMENTATION_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is rendered by the Segmentation Rendering Engine.\n   * Make use of {@link EventTypes.SegmentationRenderedEventType | Segmentation Rendered Event Type}\n   * for typing your event listeners for this segmentation rendered event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRenderedEventDetail | Segmentation Rendered Event Detail}.\n   */\n  SEGMENTATION_RENDERED = 'CORNERSTONE_TOOLS_SEGMENTATION_RENDERED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation representation of a toolGroup is modified in the state manager.\n   * Make use of {@link EventTypes.SegmentationRepresentationModifiedEventType | Segmentation Representation Modified Event Type}\n   * for typing your event listeners for this segmentation representation modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRepresentationModifiedEventDetail | Segmentation Representation Modified Event Detail}.\n   */\n  SEGMENTATION_REPRESENTATION_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is removed from the state manager.\n   * Make use of {@link EventTypes.SegmentationRemovedEventType | Segmentation Removed Event Type}\n   * for typing your event listeners for this segmentation removed event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRemovedEventDetail | Segmentation Removed Event Detail}.\n   */\n  SEGMENTATION_REMOVED = 'CORNERSTONE_TOOLS_SEGMENTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation representation of a toolGroup is removed in the state manager.\n   * Make use of {@link EventTypes.SegmentationRepresentationRemovedEventType | Segmentation Representation Removed Event Type}\n   * for typing your event listeners for this segmentation representation removed event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRepresentationRemovedEventDetail | Segmentation Representation Removed Event Detail}.\n   */\n  SEGMENTATION_REPRESENTATION_REMOVED = 'CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation data is modified (e.g., by brush tool).\n   * Make use of {@link EventTypes.SegmentationDataModifiedEventType | Segmentation Data Modified Event Type}\n   * for typing your event listeners for this segmentation data modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationDataModifiedEventDetail | Segmentation Data Modified Event Detail}.\n   */\n  SEGMENTATION_DATA_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED',\n\n  ///////////////////////////////////////\n  //         Keyboard Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a key on the keyboard is pressed.\n   * Make use of {@link EventTypes.KeyDownEventType | Key Down Event Type}\n   * for typing your event listeners for this key down event, and see what\n   * event detail is included in {@link EventTypes.KeyDownEventDetail | Key Down Event Detail}.\n   */\n  KEY_DOWN = 'CORNERSTONE_TOOLS_KEY_DOWN',\n\n  /**\n   * Triggers on the eventTarget when a key on the keyboard is released.\n   * Make use of {@link EventTypes.KeyUpEventType | Key Up Event Type}\n   * for typing your event listeners for this key up event, and see what\n   * event detail is included in {@link EventTypes.KeyUpEventDetail | Key Up Event Detail}.\n   */\n  KEY_UP = 'CORNERSTONE_TOOLS_KEY_UP',\n\n  ///////////////////////////////////////\n  //      Mouse Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when the mouse is pressed down, it is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseDownEventType | Mouse Down Event Type}\n   * for typing your event listeners for this mouse down event, and see what\n   * event detail is included in {@link EventTypes.MouseDownEventDetail | Mouse Down Event Detail}.\n   */\n  MOUSE_DOWN = 'CORNERSTONE_TOOLS_MOUSE_DOWN',\n\n  /**\n   * Triggers on the eventTarget when the mouse is released, it is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseUpEventType | Mouse Up Event Type}\n   * for typing your event listeners for this mouse up event, and see what\n   * event detail is included in {@link EventTypes.MouseUpEventDetail | Mouse Up Event Detail}.\n   */\n  MOUSE_UP = 'CORNERSTONE_TOOLS_MOUSE_UP',\n\n  /**\n   * Triggers on the eventTarget when a handled `MOUSE_DOWN` event does not `stopPropagation`. The hook\n   * we use to create new annotation for mouse events.\n   * Make use of {@link EventTypes.MouseDownActivateEventType | Mouse Down Activate Event Type}\n   * for typing your event listeners for this mouse down activate event, and see what\n   * event detail is included in {@link EventTypes.MouseDownActivateEventDetail | Mouse Down Activate Event Detail}.\n   */\n  MOUSE_DOWN_ACTIVATE = 'CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE',\n\n  /**\n   * Triggers on the event target when mouse is dragging an annotation or textBox.\n   * Make use of {@link EventTypes.MouseDragEventType | Mouse Drag Event Type}\n   * for typing your event listeners for this mouse drag event, and see what\n   * event detail is included in {@link EventTypes.MouseDragEventDetail | Mouse Drag Event Detail}.\n   */\n  MOUSE_DRAG = 'CORNERSTONE_TOOLS_MOUSE_DRAG',\n\n  /**\n   * Triggers on the eventTarget, when the mouse is moved, it is CornerstoneTools normalized event.\n   * It can be just a mouse move or when double click is performed and annotation\n   * drawing can be performed with just mouse move.\n   * Make use of {@link EventTypes.MouseMoveEventType | Mouse Move Event Type}\n   * for typing your event listeners for this mouse move event, and see what\n   * event detail is included in {@link EventTypes.MouseMoveEventDetail | Mouse Move Event Detail}.\n   */\n  MOUSE_MOVE = 'CORNERSTONE_TOOLS_MOUSE_MOVE',\n\n  /**\n   * Triggers on the eventTarget when a mouse click is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseClickEventType | Mouse Click Event Type}\n   * for typing your event listeners for this mouse click event, and see what\n   * event detail is included in {@link EventTypes.MouseClickEventDetail | Mouse Click Event Detail}.\n   */\n  MOUSE_CLICK = 'CORNERSTONE_TOOLS_MOUSE_CLICK',\n\n  /**\n   * Triggers on the eventTarget when a mouse double click is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseDoubleClickEventType | Mouse Double Click Event Type}\n   * for typing your event listeners for this mouse double click event, and see what\n   * event detail is included in {@link EventTypes.MouseDoubleClickEventDetail | Mouse Double Click Event Detail}.\n   */\n  MOUSE_DOUBLE_CLICK = 'CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK',\n\n  /**\n   * Triggers on the eventTarget when a mouse wheel event is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseWheelEventType | Mouse Wheel Event Type}\n   * for typing your event listeners for this mouse wheel event, and see what\n   * event detail is included in {@link EventTypes.MouseWheelEventDetail | Mouse Wheel Event Detail}.\n   */\n  MOUSE_WHEEL = 'CORNERSTONE_TOOLS_MOUSE_WHEEL',\n\n  // Todo: not being fired as of now\n  // ANNOTATION_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_COMPLETED',\n  // Todo: not implemented yet\n  // KEY_PRESS = 'CORNERSTONE_TOOLS_KEY_PRESS',\n\n  //////////////////////\n  //   Touch Events   //\n  //////////////////////\n  // The event flow looks like the following\n  // Touch Start -> (optional) Touch Press -> Touch Drag -> (optional) Touch Swipe -> Touch End\n  // Touch Tap\n  // mousedown\n  // mousedown, Touch Start, and Tap are mutually exclusive events\n  TOUCH_START = 'CORNERSTONE_TOOLS_TOUCH_START',\n  TOUCH_START_ACTIVATE = 'CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE',\n  TOUCH_PRESS = 'CORNERSTONE_TOOLS_TOUCH_PRESS',\n  TOUCH_DRAG = 'CORNERSTONE_TOOLS_TOUCH_DRAG',\n  TOUCH_END = 'CORNERSTONE_TOOLS_TOUCH_END',\n  TOUCH_TAP = 'CORNERSTONE_TOOLS_TAP',\n  TOUCH_SWIPE = 'CORNERSTONE_TOOLS_SWIPE',\n}\n\nexport default Events;\n","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { Annotation } from '../../types';\nimport { AnnotationLockChangeEventDetail } from '../../types/EventTypes';\n\n/*\n * Constants\n */\nconst globalLockedAnnotationsSet: Set<Annotation> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set the \"Locked\" state of a given annotation instance.\n *\n * @triggers ANNOTATION_LOCK_CHANGE\n *\n * @param annotation - The annotation instance which will have\n * its locked state changed. An event will only be triggered if the locked state\n * of the given annotation instance changed.\n * @param locked - A boolean value indicating if the instance should\n * be locked (true) or not (false)\n */\nfunction setAnnotationLocked(annotation: Annotation, locked = true): void {\n  const detail = makeEventDetail();\n  if (annotation) {\n    if (locked) {\n      lock(annotation, globalLockedAnnotationsSet, detail);\n    } else {\n      unlock(annotation, globalLockedAnnotationsSet, detail);\n    }\n  }\n  publish(detail, globalLockedAnnotationsSet);\n}\n\n/**\n * Clears all the locked annotation\n *\n */\nfunction unlockAllAnnotations(): void {\n  const detail = makeEventDetail();\n  clearLockedAnnotationsSet(globalLockedAnnotationsSet, detail);\n  publish(detail, globalLockedAnnotationsSet);\n}\n\n/**\n * Returns an array of all the annotation that is currently locked\n * @returns An array of tool specific annotation objects.\n *\n */\nfunction getAnnotationsLocked(): Array<Annotation> {\n  return Array.from(globalLockedAnnotationsSet);\n}\n\n/**\n * Given a Annotation object, return true if it is locked.\n * @param annotation - Annotation\n * @returns A boolean value.\n */\nfunction isAnnotationLocked(annotation: Annotation): boolean {\n  return globalLockedAnnotationsSet.has(annotation);\n}\n\n/**\n * Get the number of locked annotation objects in the global set of locked annotation\n * objects.\n * @returns The number of locked annotation objects.\n *\n */\nfunction getAnnotationsLockedCount(): number {\n  return globalLockedAnnotationsSet.size;\n}\n\n/**\n * Properly initialize the isLocked on annotation, and set it as locked if\n * isLocked is true.\n * @param annotation - The annotation object to be checked.\n */\nfunction checkAndDefineIsLockedProperty(annotation: Annotation): void {\n  if (annotation) {\n    const isLocked = !!annotation.isLocked;\n    if (shouldDefineIsLockedProperty(annotation)) {\n      Object.defineProperty(annotation, 'isLocked', {\n        configurable: false,\n        enumerable: true,\n        set: setIsLocked,\n        get: getIsLocked,\n      });\n    }\n    setAnnotationLocked(annotation, isLocked);\n  }\n}\n\n/*\n * Private Helpers\n */\n\nfunction makeEventDetail(): AnnotationLockChangeEventDetail {\n  return Object.freeze({\n    added: [],\n    removed: [],\n    locked: [],\n  });\n}\n\nfunction lock(\n  annotation: Annotation,\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  if (!lockedAnnotationsSet.has(annotation)) {\n    lockedAnnotationsSet.add(annotation);\n    detail.added.push(annotation);\n  }\n}\n\nfunction unlock(\n  annotation: Annotation,\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  if (lockedAnnotationsSet.delete(annotation)) {\n    detail.removed.push(annotation);\n  }\n}\n\nfunction clearLockedAnnotationsSet(\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  lockedAnnotationsSet.forEach((annotation) => {\n    unlock(annotation, lockedAnnotationsSet, detail);\n  });\n}\n\nfunction publish(\n  detail: AnnotationLockChangeEventDetail,\n  lockedAnnotationsSet: Set<Annotation>\n) {\n  if (detail.added.length > 0 || detail.removed.length > 0) {\n    lockedAnnotationsSet.forEach((item) => void detail.locked.push(item));\n    triggerEvent(eventTarget, Events.ANNOTATION_LOCK_CHANGE, detail);\n  }\n}\n\nfunction shouldDefineIsLockedProperty(annotation: Annotation): boolean {\n  const descriptor = Object.getOwnPropertyDescriptor(annotation, 'isLocked');\n  if (descriptor) {\n    return (\n      descriptor.configurable &&\n      (descriptor.set !== setIsLocked || descriptor.get !== getIsLocked)\n    );\n  }\n  return Object.isExtensible(annotation);\n}\n\nfunction setIsLocked(locked: boolean) {\n  setAnnotationLocked(this as Annotation, locked);\n}\n\nfunction getIsLocked() {\n  return isAnnotationLocked(this as Annotation);\n}\n\n/*\n * Exports\n */\n\nexport {\n  setAnnotationLocked,\n  getAnnotationsLocked,\n  getAnnotationsLockedCount,\n  unlockAllAnnotations,\n  isAnnotationLocked,\n  checkAndDefineIsLockedProperty,\n};\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { AnnotationSelectionChangeEventDetail } from '../../types/EventTypes';\nimport { getAnnotation } from './annotationState';\n\n/*\n * Constants\n */\n\nconst selectedAnnotationUIDs: Set<string> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set a given annotationUID as selected or deselected based on the provided\n * selected value.\n *\n * @param annotationUID - The annotation UID to be selected\n * @param selected - When true, the annotation is selected. When false, the annotation is deselected.\n * @param preserveSelected - When true, preserves existing\n *  selections (i.e., the given annotation is appended to the selection set).\n *  When false (the default behavior) the currently selected items are discarded\n *  (i.e., the given annotation instance replaces the currently selected ones).\n */\nfunction setAnnotationSelected(\n  annotationUID: string,\n  selected = true,\n  preserveSelected = false\n): void {\n  if (selected) {\n    selectAnnotation(annotationUID, preserveSelected);\n  } else {\n    deselectAnnotation(annotationUID);\n  }\n}\n\n/**\n * Set a given annotation as selected.\n *\n * @param annotationUID - The annotation UID to be selected\n * @param preserveSelected - When true, preserves existing\n *  selections (i.e., the given annotation is appended to the selection set).\n *  When false (the default behavior) the currently selected items are discarded\n *  (i.e., the given annotation instance replaces the currently selected ones).\n */\nfunction selectAnnotation(\n  annotationUID: string,\n  preserveSelected = false\n): void {\n  const detail = makeEventDetail();\n  if (!preserveSelected) {\n    clearSelectionSet(selectedAnnotationUIDs, detail);\n  }\n  if (annotationUID && !selectedAnnotationUIDs.has(annotationUID)) {\n    selectedAnnotationUIDs.add(annotationUID);\n    detail.added.push(annotationUID);\n  }\n  publish(detail, selectedAnnotationUIDs);\n}\n\n/**\n * Deselect one or all annotations.\n *\n * @param annotationUID - If an annotation is provided that instance will be removed from\n * the internal selection set. If none is given, ALL selections will be cleared.\n */\nfunction deselectAnnotation(annotationUID?: string): void {\n  const detail = makeEventDetail();\n  if (annotationUID) {\n    if (selectedAnnotationUIDs.delete(annotationUID)) {\n      detail.removed.push(annotationUID);\n    }\n  } else {\n    clearSelectionSet(selectedAnnotationUIDs, detail);\n  }\n  publish(detail, selectedAnnotationUIDs);\n}\n\n/**\n * Return an array of ALL the selected annotationUIDs\n * @returns An array of Annotation UIDs\n */\nfunction getAnnotationsSelected(): Array<string> {\n  return Array.from(selectedAnnotationUIDs);\n}\n\n/**\n * Given a tool name, return ALL the annotationUIDs for that tool that are selected\n * @param toolName - The name of the tool you want to get the selected annotation for\n * @returns An array of annotationUIDs\n */\nfunction getAnnotationsSelectedByToolName(toolName: string): Array<string> {\n  return getAnnotationsSelected().filter((annotationUID) => {\n    const annotation = getAnnotation(annotationUID);\n    return annotation?.metadata?.toolName === toolName;\n  });\n}\n\n/**\n * Given an annotationUID, return true if it is selected, false\n * otherwise.\n * @param annotationUID - Annotation UID\n * @returns A boolean value.\n */\nfunction isAnnotationSelected(annotationUID: string): boolean {\n  return selectedAnnotationUIDs.has(annotationUID);\n}\n\n/**\n * Return the number of the selected annotation\n * @returns The size of the selected annotation set\n */\nfunction getAnnotationsSelectedCount(): number {\n  return selectedAnnotationUIDs.size;\n}\n\n/*\n * Private Helpers\n */\n\nfunction makeEventDetail(): AnnotationSelectionChangeEventDetail {\n  return Object.freeze({\n    added: [],\n    removed: [],\n    selection: [],\n  });\n}\n\nfunction clearSelectionSet(\n  selectionSet: Set<string>,\n  detail: AnnotationSelectionChangeEventDetail\n): void {\n  selectionSet.forEach((value) => {\n    if (selectionSet.delete(value)) {\n      detail.removed.push(value);\n    }\n  });\n}\n\nfunction publish(\n  detail: AnnotationSelectionChangeEventDetail,\n  selectionSet: Set<string>\n) {\n  if (detail.added.length > 0 || detail.removed.length > 0) {\n    selectionSet.forEach((item) => void detail.selection.push(item));\n    triggerEvent(eventTarget, Events.ANNOTATION_SELECTION_CHANGE, detail);\n  }\n}\n\n/*\n * Exports\n */\n\nexport {\n  setAnnotationSelected,\n  getAnnotationsSelected,\n  getAnnotationsSelectedByToolName,\n  getAnnotationsSelectedCount,\n  deselectAnnotation,\n  isAnnotationSelected,\n};\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { getAnnotation } from './annotationState';\nimport { Events } from '../../enums';\nimport { Annotation } from '../../types';\nimport { AnnotationVisibilityChangeEventDetail } from '../../types/EventTypes';\nimport {\n  isAnnotationSelected,\n  deselectAnnotation,\n} from './annotationSelection';\n\n/*\n * It stores all hidden annotation uids.\n */\nconst globalHiddenAnnotationUIDsSet: Set<string> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set the \"visible\" state of a given annotation instance.\n *\n * @event ANNOTATION_VISIBILITY_CHANGE\n *\n * @param annotationUID - The annotation uid which will have\n * its visible state changed. An event will only be triggered if the visible state\n * of the given annotation instance changed.\n * @param visible - A boolean value indicating if the instance should\n * be visible (true) or not (false)\n */\nfunction setAnnotationVisibility(annotationUID: string, visible = true): void {\n  const detail = makeEventDetail();\n  if (annotationUID) {\n    if (visible) {\n      show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n    } else {\n      hide(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n    }\n  }\n  publish(detail);\n}\n\n/**\n * Clears all the hidden annotations.\n *\n */\nfunction showAllAnnotations(): void {\n  const detail = makeEventDetail();\n  globalHiddenAnnotationUIDsSet.forEach((annotationUID) => {\n    show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n  });\n  publish(detail);\n}\n\n/**\n * Given an annotation UID, return true if it is visible, false if hidden and undefined if does not exist.\n * @param annotationUID - The annotation uid to tell if is visible or not.\n * @returns A boolean value or value if does not exist.\n */\nfunction isAnnotationVisible(annotationUID: string): boolean | undefined {\n  const annotation = getAnnotation(annotationUID);\n\n  if (annotation) {\n    return !globalHiddenAnnotationUIDsSet.has(annotationUID);\n  }\n}\n/**\n * It decorates given annotation with isVisible property.\n * It properly initializes the isVisible on annotation(the property will be create if does not exist yet)\n *\n * @param annotation - The annotation object to be checked.\n */\nfunction checkAndDefineIsVisibleProperty(annotation: Annotation): void {\n  if (annotation) {\n    const isVisible = annotation.isVisible ?? true;\n    if (shouldDefineIsVisibleProperty(annotation)) {\n      Object.defineProperty(annotation, 'isVisible', {\n        configurable: false,\n        enumerable: true,\n        set: setIsVisible,\n        get: getIsVisible,\n      });\n    }\n    setAnnotationVisibility(annotation.annotationUID, isVisible);\n  }\n}\n\n/*\n * Private Helpers\n */\nfunction makeEventDetail(): AnnotationVisibilityChangeEventDetail {\n  return Object.freeze({\n    lastVisible: [],\n    lastHidden: [],\n    hidden: [],\n  });\n}\n\nfunction show(\n  annotationUID: string,\n  annotationUIDsSet: Set<string>,\n  detail: AnnotationVisibilityChangeEventDetail\n): void {\n  if (annotationUIDsSet.delete(annotationUID)) {\n    detail.lastVisible.push(annotationUID);\n  }\n}\n\nfunction hide(\n  annotationUID: string,\n  annotationUIDsSet: Set<string>,\n  detail: AnnotationVisibilityChangeEventDetail\n): void {\n  if (!annotationUIDsSet.has(annotationUID)) {\n    annotationUIDsSet.add(annotationUID);\n    if (isAnnotationSelected(annotationUID)) {\n      deselectAnnotation(annotationUID);\n    }\n    detail.lastHidden.push(annotationUID);\n  }\n}\n\nfunction publish(detail: AnnotationVisibilityChangeEventDetail) {\n  if (detail.lastHidden.length > 0 || detail.lastVisible.length > 0) {\n    globalHiddenAnnotationUIDsSet.forEach(\n      (item) => void detail.hidden.push(item)\n    );\n    triggerEvent(eventTarget, Events.ANNOTATION_VISIBILITY_CHANGE, detail);\n  }\n}\n\nfunction shouldDefineIsVisibleProperty(annotation: Annotation): boolean {\n  const descriptor = Object.getOwnPropertyDescriptor(annotation, 'isVisible');\n  if (descriptor) {\n    return (\n      descriptor.configurable &&\n      (descriptor.set !== setIsVisible || descriptor.get !== getIsVisible)\n    );\n  }\n  return Object.isExtensible(annotation);\n}\n\nfunction setIsVisible(hidden: boolean) {\n  setAnnotationVisibility((this as Annotation).annotationUID, hidden);\n}\n\nfunction getIsVisible() {\n  return isAnnotationVisible((this as Annotation).annotationUID);\n}\n\nexport {\n  setAnnotationVisibility,\n  showAllAnnotations,\n  isAnnotationVisible,\n  checkAndDefineIsVisibleProperty,\n};\n","import cloneDeep from 'lodash.clonedeep';\nimport {\n  Annotation,\n  Annotations,\n  AnnotationState,\n  GroupSpecificAnnotations,\n} from '../../types/AnnotationTypes';\n\nimport { AnnotationGroupSelector, IAnnotationManager } from '../../types';\n\nimport {\n  Enums,\n  eventTarget,\n  getEnabledElement,\n  Types,\n  utilities,\n} from '@cornerstonejs/core';\n\nimport { checkAndDefineIsLockedProperty } from './annotationLocking';\nimport { checkAndDefineIsVisibleProperty } from './annotationVisibility';\n\n/**\n * This is the default annotation manager. It stores annotations by default\n * based on the FrameOfReferenceUID. However, it is possible to override the\n * getAnnotationStateKey function to store annotations based on any other\n * property of the element. When you write your custom annotation manager, you\n * can use the setAnnotationManager function to set your custom annotation.\n *\n * Note that this class is a singleton and should not be instantiated directly.\n * To get the stored annotations information you can use ToolState helpers.\n */\nclass FrameOfReferenceSpecificAnnotationManager implements IAnnotationManager {\n  private annotations: AnnotationState;\n  public readonly uid: string;\n\n  /**\n   * @param uid - The uid of the state manager. If omitted it is autogenerated.\n   */\n  constructor(uid?: string) {\n    if (!uid) {\n      uid = utilities.uuidv4();\n    }\n    this.annotations = {};\n    this.uid = uid;\n\n    // Listen to the IMAGE_VOLUME_MODIFIED event to invalidate data.\n    eventTarget.addEventListener(\n      Enums.Events.IMAGE_VOLUME_MODIFIED,\n      this._imageVolumeModifiedHandler\n    );\n  }\n\n  /**\n   * Default annotation manager works with FrameOfReferenceUID as the key. The\n   * manager adds them under the FrameOfReferenceUID for the element being\n   * annotated.\n   *\n   * @param annotationGroupSelector - element or a string that is provided\n   * to the annotation manager to get the key.\n   * @returns - The annotation state key for the element.\n   */\n  getGroupKey = (annotationGroupSelector: AnnotationGroupSelector): string => {\n    if (typeof annotationGroupSelector === 'string') {\n      return annotationGroupSelector;\n    }\n\n    const element = annotationGroupSelector;\n    const enabledElement = getEnabledElement(element);\n\n    if (!enabledElement) {\n      throw new Error(\n        'Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID'\n      );\n    }\n\n    return enabledElement.FrameOfReferenceUID;\n  };\n\n  /**\n   * When a volume is modified we invalidate all of the `annotations` on the\n   * volume's `FrameOfReferenceUID`. This is mainly to update statistics calculations\n   * when an annotation is drawn whilst data is still loading.\n   *\n   * @param evt - The IMAGE_VOLUME_MODIFIED rendering event.\n   */\n  _imageVolumeModifiedHandler = (\n    evt: Types.EventTypes.ImageVolumeModifiedEvent\n  ) => {\n    const eventDetail = evt.detail;\n    const { FrameOfReferenceUID } = eventDetail;\n\n    const annotations = this.annotations;\n    const frameOfReferenceSpecificAnnotations =\n      annotations[FrameOfReferenceUID];\n\n    if (!frameOfReferenceSpecificAnnotations) {\n      return;\n    }\n\n    Object.keys(frameOfReferenceSpecificAnnotations).forEach((toolName) => {\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[toolName];\n\n      toolSpecificAnnotations.forEach((annotation) => {\n        const invalidated = annotation.invalidated;\n\n        if (invalidated !== undefined) {\n          annotation.invalidated = true;\n        }\n      });\n    });\n  };\n\n  /**\n   * Returns all the available frameOfReferences inside the state manager\n   * @returns - All the added frames of references inside the manager\n   */\n  getFramesOfReference = (): Array<string> => {\n    return Object.keys(this.annotations);\n  };\n\n  /**\n   * Returns the annotations associated with the specified frameOfReference and tool, or\n   * all annotations for the group if the tool name is not provided.\n   *\n   * @param groupKey - The annotation group key to retrieve annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - Optional. The name of the tool to retrieve annotations for.\n   * @returns The annotations associated with the specified group (default FrameOfReferenceUID) and tool,\n   * or all annotations for the group (FrameOfReferenceUID) if the tool name is not provided.\n   * WARNING: The list returned here is internal tool data, not a copy, so do NOT modify it.\n   */\n  getAnnotations = (\n    groupKey: string,\n    toolName?: string\n  ): GroupSpecificAnnotations | Annotations => {\n    const annotations = this.annotations;\n\n    if (!annotations[groupKey]) {\n      return [];\n    }\n\n    if (toolName) {\n      return annotations[groupKey][toolName]\n        ? annotations[groupKey][toolName]\n        : [];\n    }\n\n    return annotations[groupKey];\n  };\n\n  /**\n   * Given the unique identified for the some `annotation`, returns the `annotation`\n   * from the `annotations`. Each `annotation` has a unique identifier.\n   *\n   * @param annotationUID - The unique identifier of the `annotation`.\n   * @returns The retrieved `annotation`.\n   */\n  getAnnotation = (annotationUID: string): Annotation | undefined => {\n    const annotations = this.annotations;\n\n    for (const frameOfReferenceUID in annotations) {\n      const frameOfReferenceAnnotations = annotations[frameOfReferenceUID];\n\n      for (const toolName in frameOfReferenceAnnotations) {\n        const toolSpecificAnnotations = frameOfReferenceAnnotations[toolName];\n\n        for (const annotation of toolSpecificAnnotations) {\n          if (annotationUID === annotation.annotationUID) {\n            return annotation;\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * A function that returns the number of annotations for a given tool in the\n   * specific group (default FrameOfReferenceUID) IF no groupKey (FrameOfReferenceUID) is provided,\n   * it will return the number of annotations for the tool in all groups (FrameOfReferenceUIDs)\n   *\n   * @param groupKey - The annotation group key to retrieve annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - The name of the tool to retrieve data for.\n   *\n   * @returns The number of annotations for a given tool in the state\n   */\n  getNumberOfAnnotations = (groupKey: string, toolName?: string): number => {\n    const annotations = this.getAnnotations(groupKey, toolName);\n\n    if (!annotations.length) {\n      return 0;\n    }\n\n    if (toolName) {\n      return (annotations as Annotations).length;\n    }\n\n    let total = 0;\n\n    for (const toolName in annotations) {\n      total += annotations[toolName].length;\n    }\n\n    return total;\n  };\n\n  /**\n   * Adds an instance of `Annotation` to the `annotations`.\n   *\n   * @param annotation - The annotation to add.\n   * @param groupKey - The annotation group key to add the annotation to (in default manager it is FrameOfReferenceUID).\n   */\n  addAnnotation = (annotation: Annotation, groupKey?: string): void => {\n    const { metadata } = annotation;\n    const { FrameOfReferenceUID, toolName } = metadata;\n\n    groupKey = groupKey || FrameOfReferenceUID;\n\n    const annotations = this.annotations;\n\n    let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n    if (!frameOfReferenceSpecificAnnotations) {\n      annotations[groupKey] = {};\n\n      frameOfReferenceSpecificAnnotations = annotations[groupKey];\n    }\n\n    let toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n\n    if (!toolSpecificAnnotations) {\n      frameOfReferenceSpecificAnnotations[toolName] = [];\n\n      toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n    }\n\n    toolSpecificAnnotations.push(annotation);\n    checkAndDefineIsLockedProperty(annotation);\n    checkAndDefineIsVisibleProperty(annotation);\n  };\n\n  /**\n   * Given the unique identified for the some `annotation`, removes the `annotation`\n   * from the `annotations`.\n   *\n   * @param annotationUID - The unique identifier of the `annotation` to remove.\n   */\n  removeAnnotation = (annotationUID: string): void => {\n    const { annotations } = this;\n\n    for (const groupKey in annotations) {\n      const groupAnnotations = annotations[groupKey];\n\n      for (const toolName in groupAnnotations) {\n        const toolAnnotations = groupAnnotations[toolName];\n\n        const index = toolAnnotations.findIndex(\n          (annotation) => annotation.annotationUID === annotationUID\n        );\n\n        if (index !== -1) {\n          toolAnnotations.splice(index, 1);\n\n          if (toolAnnotations.length === 0) {\n            delete groupAnnotations[toolName];\n          }\n        }\n      }\n\n      if (Object.keys(groupAnnotations).length === 0) {\n        delete annotations[groupKey];\n      }\n    }\n  };\n\n  /**\n   * Removes all annotations associated with the specified group (FrameOfReferenceUID) and tool, or\n   * all annotations for the group (FrameOfReferenceUID) if the tool name is not provided.\n   *\n   * @param groupKey - The group key to remove annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - Optional. The name of the tool to remove annotations for.\n   */\n  removeAnnotations = (groupKey: string, toolName?: string): void => {\n    const annotations = this.annotations;\n    if (annotations[groupKey]) {\n      if (toolName) {\n        delete annotations[groupKey][toolName];\n      } else {\n        delete annotations[groupKey];\n      }\n    }\n  };\n\n  /**\n   * Returns a section of the annotations. Useful for serialization.\n   * If both groupKey (default manager is FrameOfReferenceUID) and toolName are provided, returns the corresponding Annotations instance\n   * for that groupKey (FrameOfReferenceUID) and toolName.\n   * If only groupKey is provided, returns the corresponding FrameOfReferenceSpecificAnnotations instance\n   * for that groupKey.\n   * If neither groupKey nor toolName is provided, returns the entire AnnotationState object.\n   * @param groupKey - Optional. The group key (e.g. FrameOfReferenceUID) to retrieve annotations for.\n   * @param toolName - Optional. The name of the tool to retrieve annotations for.\n   * @returns A section of the annotations.\n   */\n  saveAnnotations = (\n    groupKey?: string,\n    toolName?: string\n  ): AnnotationState | GroupSpecificAnnotations | Annotations => {\n    const annotations = this.annotations;\n\n    if (groupKey && toolName) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      if (!frameOfReferenceSpecificAnnotations) {\n        return;\n      }\n\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[toolName];\n\n      return cloneDeep(toolSpecificAnnotations);\n    } else if (groupKey) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      return cloneDeep(frameOfReferenceSpecificAnnotations);\n    }\n\n    return cloneDeep(annotations);\n  };\n\n  /**\n   * Restores a section of the `annotations`. Useful for loading in serialized data.\n   *\n   * - If no arguments are given, the entire `AnnotationState` instance is restored.\n   * - If the `FrameOfReferenceUID` is given, the corresponding\n   * `FrameOfReferenceSpecificAnnotations` instance is restored.\n   * - If both the `FrameOfReferenceUID` and the `toolName` are are given, the\n   * corresponding `Annotations` instance is restored.\n   *\n   * @param groupKey - A filter string for restoring only the `annotations` of a specific frame of reference.\n   * @param toolName - A filter string for restoring `annotation` for a specific tool on a specific frame of reference.\n   */\n  restoreAnnotations = (\n    state: AnnotationState | GroupSpecificAnnotations | Annotations,\n    groupKey?: string,\n    toolName?: string\n  ): void => {\n    const annotations = this.annotations;\n\n    if (groupKey && toolName) {\n      // Set Annotations for FrameOfReferenceUID and toolName.\n\n      let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      if (!frameOfReferenceSpecificAnnotations) {\n        annotations[groupKey] = {};\n\n        frameOfReferenceSpecificAnnotations = annotations[groupKey];\n      }\n\n      frameOfReferenceSpecificAnnotations[toolName] = <Annotations>state;\n    } else if (groupKey) {\n      // Set FrameOfReferenceSpecificAnnotations for FrameOfReferenceUID.\n\n      annotations[groupKey] = <GroupSpecificAnnotations>state;\n    } else {\n      // Set entire annotations\n      this.annotations = <AnnotationState>cloneDeep(state);\n    }\n  };\n\n  /**\n   * return all annotations as a single array\n   */\n  getAllAnnotations = (): Annotations => {\n    return Object.values(this.annotations)\n      .map((frameOfReferenceSpecificAnnotations) =>\n        Object.values(frameOfReferenceSpecificAnnotations)\n      )\n      .flat(2);\n  };\n\n  /**\n   * A function that returns the number of all annotations in the annotation state\n   *\n   * @returns The number of all annotations in the state\n   */\n  getNumberOfAllAnnotations = (): number => {\n    let count = 0;\n    const annotations = this.annotations;\n    for (const groupKey in annotations) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n      for (const toolName in frameOfReferenceSpecificAnnotations) {\n        const toolSpecificAnnotations =\n          frameOfReferenceSpecificAnnotations[toolName];\n        count += toolSpecificAnnotations.length;\n      }\n    }\n    return count;\n  };\n\n  /**\n   * Removes all annotations in the annotation state.\n   */\n  removeAllAnnotations = (): void => {\n    this.annotations = {};\n  };\n}\n\nconst defaultFrameOfReferenceSpecificAnnotationManager =\n  new FrameOfReferenceSpecificAnnotationManager('DEFAULT');\n\nexport { defaultFrameOfReferenceSpecificAnnotationManager };\nexport default FrameOfReferenceSpecificAnnotationManager;\n","/**\n * ChangeTypes defines the types of changes occurring on annotation and\n * segmentation data.\n */\nenum ChangeTypes {\n  /**\n   * Interaction events are done when the user is actively interacting with\n   * an annotation, and probably means the event shouldn't be handled/used.\n   */\n  Interaction = 'Interaction',\n  /**\n   * HandlesUpdated occurs when the handle data is added or removed, or moved around\n   */\n  HandlesUpdated = 'HandlesUpdated',\n  /**\n   * StatsUpdated occurs when the stats are updated/calculated.  This can be used\n   * to ignore stats calculations changes occurring on initial load, while still\n   * rendering other updates.\n   */\n  StatsUpdated = 'StatsUpdated',\n  /**\n   * InitialSetup occurs when an annotation has been created initially and\n   * has the first render/data calculation being applied.\n   */\n  InitialSetup = 'InitialSetup',\n  /**\n   * Completed occurs only for the annotation completed event, just to identify it\n   */\n  Completed = 'Completed',\n  /**\n   * Occurs when an interpolation result is updated with more tool specific data.\n   */\n  InterpolationUpdated = 'InterpolationUpdated',\n}\n\nexport default ChangeTypes;\n","let svgNodeCache = {};\n\nexport function resetSvgNodeCache(): void {\n  svgNodeCache = {};\n}\n\nexport default svgNodeCache;\n","import { IToolGroup, IToolClassReference } from '../types';\nimport Synchronizer from './SynchronizerManager/Synchronizer';\nimport svgNodeCache, { resetSvgNodeCache } from './svgNodeCache';\nimport cloneDeep from 'lodash.clonedeep';\n\ninterface ICornerstoneTools3dState {\n  isInteractingWithTool: boolean;\n  isMultiPartToolActive: boolean;\n  tools: Record<\n    string,\n    {\n      toolClass: IToolClassReference;\n    }\n  >;\n  toolGroups: Array<IToolGroup>;\n  synchronizers: Array<Synchronizer>;\n  svgNodeCache: Record<string, unknown>;\n  enabledElements: Array<unknown>;\n  handleRadius: number;\n}\n\nconst defaultState: ICornerstoneTools3dState = {\n  isInteractingWithTool: false,\n  isMultiPartToolActive: false,\n  tools: {},\n  toolGroups: [],\n  synchronizers: [],\n  svgNodeCache: svgNodeCache,\n  // Should this be named... canvases?\n  enabledElements: [], // switch to Uids?\n  handleRadius: 6,\n};\n\nlet state: ICornerstoneTools3dState = {\n  isInteractingWithTool: false,\n  isMultiPartToolActive: false,\n  tools: {},\n  toolGroups: [],\n  synchronizers: [],\n  svgNodeCache: svgNodeCache,\n  // Should this be named... canvases?\n  enabledElements: [], // switch to Uids?\n  handleRadius: 6,\n};\n\nfunction resetCornerstoneToolsState(): void {\n  resetSvgNodeCache();\n  state = {\n    ...cloneDeep({\n      ...defaultState,\n      svgNodeCache: {},\n    }),\n    svgNodeCache: {\n      ...defaultState.svgNodeCache,\n    },\n  };\n}\n\nexport {\n  ICornerstoneTools3dState,\n  resetCornerstoneToolsState,\n  state,\n  state as default,\n};\n","/**\n * ToolModes - This enum defines the 4 tool states which are available.\n */\nenum ToolModes {\n  /**\n   * Active:\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\n   * - Can add data if an annotation tool.\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Active = 'Active',\n  /**\n   * Passive:\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Passive = 'Passive',\n  /**\n   * Enabled:\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Enabled = 'Enabled',\n  /**\n   * Disabled:\n   * - Annotation does not render.\n   */\n  Disabled = 'Disabled',\n}\n\nexport default ToolModes;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\nimport { ToolModes } from '../../enums';\n\nconst MODES = [ToolModes.Active, ToolModes.Passive, ToolModes.Enabled];\n\n/**\n * Returns the toolGroups that has the given toolName as active, passive\n * or enabled.\n * @param toolName - The name of the tool\n * @returns An array of tool groups.\n */\nfunction getToolGroupsWithToolName(toolName: string): IToolGroup[] | [] {\n  return state.toolGroups.filter(({ toolOptions }) => {\n    const toolGroupToolNames = Object.keys(toolOptions);\n\n    for (let i = 0; i < toolGroupToolNames.length; i++) {\n      if (toolName !== toolGroupToolNames[i]) {\n        continue;\n      }\n\n      /* filter out tools that don't have options */\n      if (!toolOptions[toolName]) {\n        continue;\n      }\n\n      if (MODES.includes(toolOptions[toolName].mode)) {\n        return true;\n      }\n    }\n    return false;\n  });\n}\n\nexport default getToolGroupsWithToolName;\n","import {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  getEnabledElementByIds,\n} from '@cornerstonejs/core';\nimport { Events, ChangeTypes } from '../../../enums';\nimport { Annotation } from '../../../types/AnnotationTypes';\nimport { getToolGroupsWithToolName } from '../../../store/ToolGroupManager';\nimport {\n  AnnotationAddedEventDetail,\n  AnnotationModifiedEventDetail,\n  AnnotationCompletedEventDetail,\n  ContourAnnotationCompletedEventDetail,\n} from '../../../types/EventTypes';\n\n/**\n * It triggers an event for the element when an annotation is added\n * @param annotation - Annotation - The annotation that was added.\n * @param element - The element that the annotation was added to.\n */\nfunction triggerAnnotationAddedForElement(\n  annotation: Annotation,\n  element: HTMLDivElement\n) {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewportId } = enabledElement;\n\n  const eventType = Events.ANNOTATION_ADDED;\n\n  const eventDetail: AnnotationAddedEventDetail = {\n    annotation,\n    viewportId,\n    renderingEngineId: renderingEngine.id,\n  };\n\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\n/**\n * If the annotation has a FrameOfReferenceUID, it triggers the ANNOTATION_ADDED\n * event for all the viewports that has the same FrameOfReferenceUID.\n * @param annotation -  Annotation - The annotation that was added\n */\nfunction triggerAnnotationAddedForFOR(annotation: Annotation) {\n  const { toolName } = annotation.metadata;\n\n  const toolGroups = getToolGroupsWithToolName(toolName);\n  if (!toolGroups.length) {\n    return;\n  }\n\n  // Find the viewports in the toolGroups who has the same FrameOfReferenceUID\n  const viewportsToRender = [];\n  toolGroups.forEach((toolGroup) => {\n    toolGroup.viewportsInfo.forEach((viewportInfo) => {\n      const { renderingEngineId, viewportId } = viewportInfo;\n      const { FrameOfReferenceUID } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (annotation.metadata.FrameOfReferenceUID === FrameOfReferenceUID) {\n        viewportsToRender.push(viewportInfo);\n      }\n    });\n  });\n\n  const eventType = Events.ANNOTATION_ADDED;\n  const eventDetail: AnnotationAddedEventDetail = { annotation };\n\n  if (!viewportsToRender.length) {\n    triggerEvent(eventTarget, eventType, eventDetail);\n    return;\n  }\n\n  viewportsToRender.forEach(({ renderingEngineId, viewportId }) => {\n    eventDetail.viewportId = viewportId;\n    eventDetail.renderingEngineId = renderingEngineId;\n    triggerEvent(eventTarget, eventType, eventDetail);\n  });\n}\n\n/**\n * Triggers an annotation modified event.\n */\nfunction triggerAnnotationModified(\n  annotation: Annotation,\n  element: HTMLDivElement,\n  changeType = ChangeTypes.HandlesUpdated\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId, renderingEngineId } = enabledElement;\n  const eventType = Events.ANNOTATION_MODIFIED;\n  const eventDetail: AnnotationModifiedEventDetail = {\n    annotation,\n    viewportId,\n    renderingEngineId,\n    changeType,\n  };\n\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\n/**\n * Triggers an annotation completed event.\n */\nfunction triggerAnnotationCompleted(annotation: Annotation): void {\n  const eventDetail: AnnotationCompletedEventDetail = {\n    annotation,\n  };\n\n  _triggerAnnotationCompleted(eventDetail);\n}\n\n/**\n * Triggers an annotation completed event for contours (same annotation completed\n * event but with more specific details).\n */\nfunction triggerContourAnnotationCompleted(\n  annotation: Annotation,\n  contourHoleProcessingEnabled = false\n): void {\n  const eventDetail: ContourAnnotationCompletedEventDetail = {\n    annotation,\n    contourHoleProcessingEnabled,\n  };\n\n  _triggerAnnotationCompleted(eventDetail);\n}\n\n/**\n * Triggers an annotation completed event for the `detail` provided\n * @param eventDetail - Event detail\n */\nfunction _triggerAnnotationCompleted(\n  eventDetail: AnnotationCompletedEventDetail\n) {\n  const eventType = Events.ANNOTATION_COMPLETED;\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\nexport {\n  triggerAnnotationAddedForElement,\n  triggerAnnotationAddedForFOR,\n  triggerAnnotationModified,\n  triggerAnnotationCompleted,\n  triggerContourAnnotationCompleted,\n};\n","import {\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { defaultFrameOfReferenceSpecificAnnotationManager } from './FrameOfReferenceSpecificAnnotationManager';\nimport { Annotations, Annotation } from '../../types/AnnotationTypes';\nimport { AnnotationRemovedEventDetail } from '../../types/EventTypes';\nimport { AnnotationGroupSelector } from '../../types';\nimport {\n  triggerAnnotationAddedForElement,\n  triggerAnnotationAddedForFOR,\n} from './helpers/state';\n\n// our default annotation manager\nlet defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\n\n/**\n * It returns the default annotations manager.\n * @returns the singleton default annotations manager.\n */\nfunction getAnnotationManager() {\n  return defaultManager;\n}\n\n/**\n * Set the annotation manager to be used for rendering, adding, removing, etc.\n * @param annotationManager - The annotation manager to be used\n */\nfunction setAnnotationManager(annotationManager) {\n  defaultManager = annotationManager;\n}\n\n// set back to default frameOfReferenceSpecificAnnotationManager\nfunction resetAnnotationManager() {\n  defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\n}\n\n/**\n * Returns the annotations for a given tool with the provided options that is\n * used to filter annotations based on the annotation manager.\n *\n * In our default implementation, the options are the element and/or the FrameOfReferenceUID.\n * Hence, the getAnnotations function will return the annotations for the given tool\n * that are associated with the FrameOfReferenceUID.\n *\n * @param toolName - The name of the tool.\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n * @returns The annotations corresponding to the Frame of Reference and the toolName.\n */\nfunction getAnnotations(\n  toolName: string,\n  annotationGroupSelector: AnnotationGroupSelector\n): Annotations {\n  const manager = getAnnotationManager();\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\n  return manager.getAnnotations(groupKey, toolName) as Annotations;\n}\n\nfunction getAllAnnotations(): Annotations {\n  const manager = getAnnotationManager();\n  return manager.getAllAnnotations();\n}\n\n/**\n * Removes the association between the annotation passed as parameter and its\n * parent in case it has one (eg: contour holes).\n * @param annotation - Annotation\n */\nfunction clearParentAnnotation(annotation: Annotation): void {\n  const { annotationUID: childUID, parentAnnotationUID } = annotation;\n\n  if (!parentAnnotationUID) {\n    return;\n  }\n\n  const parentAnnotation = getAnnotation(parentAnnotationUID);\n  const childUIDIndex = parentAnnotation.childAnnotationUIDs.indexOf(childUID);\n\n  parentAnnotation.childAnnotationUIDs.splice(childUIDIndex, 1);\n  annotation.parentAnnotationUID = undefined;\n}\n\n/**\n * Creates a parent/child association between annotations.\n * A annotation may have only one parent and multiple children (eg: a contour\n * may have multiple holes in it).\n * @param parentAnnotation - Parent annotation\n * @param childAnnotation - Child annotation\n */\nfunction addChildAnnotation(\n  parentAnnotation: Annotation,\n  childAnnotation: Annotation\n): void {\n  const { annotationUID: parentUID } = parentAnnotation;\n  const { annotationUID: childUID } = childAnnotation;\n\n  // Make sure it is not associated with any other tool\n  clearParentAnnotation(childAnnotation);\n\n  if (!parentAnnotation.childAnnotationUIDs) {\n    parentAnnotation.childAnnotationUIDs = [];\n  }\n\n  // Check if it is already a child\n  if (parentAnnotation.childAnnotationUIDs.includes(childUID)) {\n    return;\n  }\n\n  parentAnnotation.childAnnotationUIDs.push(childUID);\n  childAnnotation.parentAnnotationUID = parentUID;\n}\n\n/**\n * Returns the parent annotation of a given one since annotations can be\n * associated in a parent/child way (eg: polyline holes)\n * @param annotation - Annotation\n * @returns Parent annotation\n */\nfunction getParentAnnotation(annotation: Annotation) {\n  return annotation.parentAnnotationUID\n    ? getAnnotation(annotation.parentAnnotationUID)\n    : undefined;\n}\n\n/**\n * Returns all children annotation of a given one since annotations can be\n * associated in a parent/child way (eg: polyline holes)\n * @param annotation - Annotation\n * @returns Child annotations\n */\nfunction getChildAnnotations(annotation: Annotation) {\n  return (\n    annotation.childAnnotationUIDs?.map((childAnnotationUID) =>\n      getAnnotation(childAnnotationUID)\n    ) ?? []\n  );\n}\n\n/**\n * Add the annotation to the annotation manager along with the options that is\n * used to filter the annotation manager and the annotation group that\n * the annotation belongs to.\n *\n * As a result, our default implementation will add the annotation to the\n * default manager using the FrameOfReferenceUID as the group key.\n *\n * @param annotation - The annotation that is being added to the annotations manager.\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n */\nfunction addAnnotation(\n  annotation: Annotation,\n  annotationGroupSelector: AnnotationGroupSelector\n): string {\n  if (!annotation.annotationUID) {\n    annotation.annotationUID = csUtils.uuidv4() as string;\n  }\n\n  const manager = getAnnotationManager();\n\n  // if the annotation manager selector is an element, trigger the\n  // annotation added event for that element.\n  if (annotationGroupSelector instanceof HTMLDivElement) {\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\n    manager.addAnnotation(annotation, groupKey);\n    triggerAnnotationAddedForElement(annotation, annotationGroupSelector);\n  } else {\n    // if no element is provided, render all viewports that have the\n    // same frame of reference.\n    // Todo: we should do something else here for other types of annotation managers.\n    manager.addAnnotation(annotation);\n    triggerAnnotationAddedForFOR(annotation);\n  }\n\n  return annotation.annotationUID;\n}\n\n/**\n * Get the number of annotations for a given tool with the provided options that is\n * used to filter annotations based on the annotation manager.\n *\n * In our default implementation, the options are the element and/or the FrameOfReferenceUID.\n * Hence, the getNumberOfAnnotations function will return the number of annotations for the given tool\n * that are associated with the FrameOfReferenceUID.\n *\n * @param toolName - The name of the tool\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n *\n */\nfunction getNumberOfAnnotations(\n  toolName: string,\n  annotationGroupSelector: AnnotationGroupSelector\n): number {\n  const manager = getAnnotationManager();\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\n\n  return manager.getNumberOfAnnotations(groupKey, toolName);\n}\n\n/**\n * Remove the annotation by UID of the annotation.\n * @param annotationUID - The unique identifier for the annotation.\n */\nfunction removeAnnotation(annotationUID: string): void {\n  if (!annotationUID) {\n    return;\n  }\n  const manager = getAnnotationManager();\n  const annotation = manager.getAnnotation(annotationUID);\n\n  // no need to continue in case there is no annotation.\n  if (!annotation) {\n    return;\n  }\n\n  // Remove all child annotations first\n  annotation.childAnnotationUIDs?.forEach((childAnnotationUID) =>\n    removeAnnotation(childAnnotationUID)\n  );\n\n  manager.removeAnnotation(annotationUID);\n\n  // trigger annotation removed\n  const eventType = Events.ANNOTATION_REMOVED;\n\n  const eventDetail: AnnotationRemovedEventDetail = {\n    annotation,\n    annotationManagerUID: manager.uid,\n  };\n\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\n/**\n * Get the Annotation object by its UID\n * @param annotationUID - The unique identifier of the annotation.\n */\nfunction getAnnotation(annotationUID: string): Annotation {\n  const manager = getAnnotationManager();\n  const annotation = manager.getAnnotation(annotationUID);\n\n  return annotation;\n}\n\n/**\n * It removes all annotations from the default annotation manager\n */\nfunction removeAllAnnotations(): void {\n  const manager = getAnnotationManager();\n  manager.removeAllAnnotations();\n}\n\n/**\n * Invalidate current and all parent annotations (eg: contour holes)\n * @param annotation - Annotation\n */\nfunction invalidateAnnotation(annotation: Annotation): void {\n  let currAnnotation = annotation;\n\n  while (currAnnotation) {\n    currAnnotation.invalidated = true;\n\n    currAnnotation = currAnnotation.parentAnnotationUID\n      ? getAnnotation(currAnnotation.parentAnnotationUID)\n      : undefined;\n  }\n}\n\nexport {\n  getAllAnnotations,\n  getAnnotations,\n  getParentAnnotation,\n  getChildAnnotations,\n  clearParentAnnotation,\n  addChildAnnotation,\n  getNumberOfAnnotations,\n  addAnnotation,\n  getAnnotation,\n  removeAnnotation,\n  removeAllAnnotations,\n  // annotation manager\n  setAnnotationManager,\n  getAnnotationManager,\n  resetAnnotationManager,\n  invalidateAnnotation,\n};\n","/**\n * Segmentations on viewports can be visualized in different ways. This enum\n * defines the different ways of visualizing segmentations. Currently, only\n * labelmap is supported.\n */\nenum SegmentationRepresentations {\n  Labelmap = 'LABELMAP',\n  Contour = 'CONTOUR',\n  Surface = 'SURFACE',\n}\n\nexport default SegmentationRepresentations;\n","import { ContourConfig } from '../../../types/ContourTypes';\n\nconst defaultContourConfig: ContourConfig = {\n  renderOutline: true,\n  outlineWidthAutoGenerated: 3,\n  outlineWidthActive: 2,\n  outlineWidthInactive: 1,\n  outlineOpacity: 1,\n  outlineOpacityInactive: 0.85,\n  outlineDashActive: undefined,\n  outlineDashInactive: undefined,\n  outlineDashAutoGenerated: '5,3',\n  activeSegmentOutlineWidthDelta: 0,\n  renderFill: true,\n  fillAlpha: 0.5,\n  fillAlphaInactive: 0.3,\n  fillAlphaAutoGenerated: 0.3,\n};\n\nfunction getDefaultContourConfig(): ContourConfig {\n  return defaultContourConfig;\n}\n\nexport default getDefaultContourConfig;\n","import { LabelmapConfig } from '../../../types/LabelmapTypes';\n\nconst defaultLabelmapConfig: LabelmapConfig = {\n  renderOutline: true,\n  outlineWidthActive: 3,\n  outlineWidthInactive: 2,\n  activeSegmentOutlineWidthDelta: 0,\n  renderFill: true,\n  renderFillInactive: true,\n  fillAlpha: 0.7,\n  fillAlphaInactive: 0.65,\n  outlineOpacity: 1,\n  outlineOpacityInactive: 0.85,\n};\n\nfunction getDefaultLabelmapConfig(): LabelmapConfig {\n  return defaultLabelmapConfig;\n}\n\n// Checks if the labelmap config is valid, which means\n// if all the required fields are present and have the correct type\nfunction isValidLabelmapConfig(config): boolean {\n  return (\n    config &&\n    typeof config.renderOutline === 'boolean' &&\n    typeof config.outlineWidthActive === 'number' &&\n    typeof config.outlineWidthInactive === 'number' &&\n    typeof config.activeSegmentOutlineWidthDelta === 'number' &&\n    typeof config.renderFill === 'boolean' &&\n    typeof config.renderFillInactive === 'boolean' &&\n    typeof config.fillAlpha === 'number' &&\n    typeof config.fillAlphaInactive === 'number' &&\n    typeof config.outlineOpacity === 'number' &&\n    typeof config.outlineOpacityInactive === 'number'\n  );\n}\n\nexport default getDefaultLabelmapConfig;\nexport { isValidLabelmapConfig };\n","import { SurfaceRenderingConfig } from '../../../types/SurfaceTypes';\n\nconst defaultSurfaceConfig: SurfaceRenderingConfig = {\n  renderFill: true,\n  fillAlpha: 1,\n};\n\nfunction getDefaultSurfaceConfig(): SurfaceRenderingConfig {\n  return defaultSurfaceConfig;\n}\n\nexport default getDefaultSurfaceConfig;\n","import cloneDeep from 'lodash.clonedeep';\nimport type { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\n\nimport { SegmentationRepresentations } from '../../enums';\nimport getDefaultContourConfig from '../../tools/displayTools/Contour/contourConfig';\nimport getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport getDefaultSurfaceConfig from '../../tools/displayTools/Surface/surfaceConfig';\nimport type {\n  RepresentationConfig,\n  Segmentation,\n  SegmentationRepresentationConfig,\n  SegmentationState,\n  SegmentSpecificRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n  ToolGroupSpecificRepresentations,\n} from '../../types/SegmentationStateTypes';\n\n// Initialize the default configuration\n// Note: when we get other representations, we should set their default representations too.\nconst defaultLabelmapConfig = getDefaultLabelmapConfig();\nconst defaultContourConfig = getDefaultContourConfig();\nconst defaultSurfaceConfig = getDefaultSurfaceConfig();\n\nconst newGlobalConfig: SegmentationRepresentationConfig = {\n  renderInactiveSegmentations: true,\n  representations: {\n    [SegmentationRepresentations.Labelmap]: defaultLabelmapConfig,\n    [SegmentationRepresentations.Contour]: defaultContourConfig,\n    [SegmentationRepresentations.Surface]: defaultSurfaceConfig,\n  },\n};\n\n/* A default initial state for the segmentation manager. */\nconst initialDefaultState: SegmentationState = {\n  colorLUT: [],\n  segmentations: [],\n  globalConfig: newGlobalConfig,\n  toolGroups: {},\n};\n\n/**\n * The SegmentationStateManager Class is responsible for managing the state of the\n * segmentations. It stores the segmentations and toolGroup specific representations\n * of the segmentation. It also stores a global config and a toolGroup specific\n * config. Note that this is a singleton state manager.\n */\nexport default class SegmentationStateManager {\n  private state: SegmentationState;\n  public readonly uid: string;\n\n  constructor(uid?: string) {\n    if (!uid) {\n      uid = csUtils.uuidv4();\n    }\n    this.state = cloneDeep(initialDefaultState);\n    this.uid = uid;\n  }\n\n  /**\n   * It returns a copy of the current state of the segmentation\n   * @returns A deep copy of the state.\n   */\n  getState(): SegmentationState {\n    return this.state;\n  }\n\n  /**\n   * It returns an array of toolGroupIds currently in the segmentation state.\n   * @returns An array of strings.\n   */\n  getToolGroups(): string[] {\n    return Object.keys(this.state.toolGroups);\n  }\n\n  /**\n   * It returns the colorLUT at the specified index.\n   * @param lutIndex - The index of the color LUT to retrieve.\n   * @returns A ColorLUT object.\n   */\n  getColorLUT(lutIndex: number): Types.ColorLUT | undefined {\n    return this.state.colorLUT[lutIndex];\n  }\n\n  getNextColorLUTIndex(): number {\n    return this.state.colorLUT.length;\n  }\n\n  /**\n   * Reset the state to the default state\n   */\n  resetState(): void {\n    this.state = cloneDeep(initialDefaultState);\n  }\n\n  /**\n   * Given a segmentation Id, return the segmentation state\n   * @param segmentationId - The id of the segmentation to get the data for.\n   * @returns - The segmentation data\n   */\n  getSegmentation(segmentationId: string): Segmentation | undefined {\n    return this.state.segmentations.find(\n      (segmentation) => segmentation.segmentationId === segmentationId\n    );\n  }\n\n  /**\n   * It adds a segmentation to the segmentations array.\n   * @param segmentation - Segmentation\n   */\n  addSegmentation(segmentation: Segmentation): void {\n    // Check if the segmentation already exists with the segmentationId\n    if (this.getSegmentation(segmentation.segmentationId)) {\n      throw new Error(\n        `Segmentation with id ${segmentation.segmentationId} already exists`\n      );\n    }\n\n    this.state.segmentations.push(segmentation);\n  }\n\n  /**\n   * Get the segmentation representations for a tool group\n   * @param toolGroupId - string\n   * @returns A list of segmentation representations.\n   */\n  getSegmentationRepresentations(\n    toolGroupId: string\n  ): ToolGroupSpecificRepresentations | undefined {\n    const toolGroupSegRepresentationsWithConfig =\n      this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupSegRepresentationsWithConfig) {\n      return;\n    }\n\n    return toolGroupSegRepresentationsWithConfig.segmentationRepresentations;\n  }\n\n  /**\n   * Returns an array of all segmentation representations for all tool groups.\n   * @returns An array of ToolGroupSpecificRepresentations.\n   */\n  getAllSegmentationRepresentations(): Record<\n    string,\n    ToolGroupSpecificRepresentation[]\n  > {\n    const toolGroupSegReps: Record<string, ToolGroupSpecificRepresentation[]> =\n      {};\n    Object.entries(this.state.toolGroups).forEach(\n      ([toolGroupId, toolGroupSegRepresentationsWithConfig]) => {\n        toolGroupSegReps[toolGroupId] =\n          toolGroupSegRepresentationsWithConfig.segmentationRepresentations;\n      }\n    );\n    return toolGroupSegReps;\n  }\n\n  /**\n   * Add a new segmentation representation to the toolGroup's segmentation representations.\n   * @param toolGroupId - The Id of the tool group .\n   * @param segmentationRepresentation - The segmentation representation to add.\n   */\n  addSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentation: ToolGroupSpecificRepresentation\n  ): void {\n    // Initialize the default toolGroup state if not created yet\n    if (!this.state.toolGroups[toolGroupId]) {\n      this.state.toolGroups[toolGroupId] = {\n        segmentationRepresentations: [],\n        config: {} as SegmentationRepresentationConfig,\n      };\n    }\n\n    // local toolGroupSpecificSegmentationState\n    this.state.toolGroups[toolGroupId].segmentationRepresentations.push(\n      segmentationRepresentation\n    );\n\n    this._handleActiveSegmentation(toolGroupId, segmentationRepresentation);\n  }\n\n  /**\n   * Get the global config containing both representation config\n   * and render inactive segmentations config\n   * @returns The global config object.\n   */\n  getGlobalConfig(): SegmentationRepresentationConfig {\n    return this.state.globalConfig;\n  }\n\n  /**\n   * It sets the global segmentation config including both representation config\n   * and render inactive segmentations config\n   * @param config - The global configuration for the segmentations.\n   */\n  setGlobalConfig(config: SegmentationRepresentationConfig): void {\n    this.state.globalConfig = config;\n  }\n\n  /**\n   * Given a toolGroupId and a segmentationRepresentationUID, return the segmentation\n   * representation for that tool group.\n   * @param toolGroupId - The Id of the tool group\n   * @param segmentationRepresentationUID - string\n   * @returns The segmentation representation.\n   */\n  getSegmentationRepresentationByUID(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): ToolGroupSpecificRepresentation | undefined {\n    const toolGroupSegRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    const segmentationData = toolGroupSegRepresentations?.find(\n      (representation) =>\n        representation.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    return segmentationData;\n  }\n\n  /**\n   * It removes the segmentation from the segmentation state.\n   * @param segmentationId - The id of the segmentation to remove.\n   */\n  removeSegmentation(segmentationId: string): void {\n    this.state.segmentations = this.state.segmentations.filter(\n      (segmentation) => segmentation.segmentationId !== segmentationId\n    );\n  }\n\n  /**\n   * Remove a segmentation representation from the toolGroup\n   * @param toolGroupId - The Id of the tool group\n   * @param segmentationRepresentationUID - the uid of the segmentation representation to remove\n   * @param immediate - If true, the viewport will be updated immediately.\n   */\n  removeSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): void {\n    const toolGroupSegmentationRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      !toolGroupSegmentationRepresentations.length\n    ) {\n      throw new Error(\n        `No viewport specific segmentation state found for viewport ${toolGroupId}`\n      );\n    }\n\n    const state =\n      toolGroupSegmentationRepresentations as ToolGroupSpecificRepresentations;\n    const index = state.findIndex(\n      (segData) =>\n        segData.segmentationRepresentationUID === segmentationRepresentationUID\n    );\n\n    if (index === -1) {\n      console.warn(\n        `No viewport specific segmentation state data found for viewport ${toolGroupId} and segmentation data UID ${segmentationRepresentationUID}`\n      );\n    }\n\n    const removedSegmentationRepresentation =\n      toolGroupSegmentationRepresentations[index];\n\n    toolGroupSegmentationRepresentations.splice(index, 1);\n\n    this._handleActiveSegmentation(\n      toolGroupId,\n      removedSegmentationRepresentation\n    );\n  }\n\n  /**\n   * Set the active segmentation data for a tool group\n   * @param toolGroupId - The Id of the tool group that owns the\n   * segmentation data.\n   * @param segmentationRepresentationUID - string\n   */\n  setActiveSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): void {\n    const toolGroupSegmentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    if (!toolGroupSegmentations || !toolGroupSegmentations.length) {\n      throw new Error(\n        `No segmentation data found for toolGroupId: ${toolGroupId}`\n      );\n    }\n\n    const segmentationData = toolGroupSegmentations.find(\n      (segmentationData) =>\n        segmentationData.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    if (!segmentationData) {\n      throw new Error(\n        `No segmentation data found for segmentation data UID ${segmentationRepresentationUID}`\n      );\n    }\n\n    segmentationData.active = true;\n    this._handleActiveSegmentation(toolGroupId, segmentationData);\n  }\n\n  /**\n   * Given a tool group Id it returns the tool group specific representation config\n   *\n   * @param toolGroupId - The Id of the tool group\n   * @returns A SegmentationConfig object.\n   */\n  getToolGroupSpecificConfig(\n    toolGroupId: string\n  ): SegmentationRepresentationConfig | undefined {\n    const toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupStateWithConfig) {\n      return;\n    }\n\n    return toolGroupStateWithConfig.config;\n  }\n\n  getSegmentationRepresentationSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): RepresentationConfig {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    return segmentationRepresentation.segmentationRepresentationSpecificConfig;\n  }\n\n  setSegmentationRepresentationSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    config: RepresentationConfig\n  ): void {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    segmentationRepresentation.segmentationRepresentationSpecificConfig =\n      config;\n  }\n\n  getSegmentSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    segmentIndex: number\n  ): RepresentationConfig {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    return segmentationRepresentation.segmentSpecificConfig[segmentIndex];\n  }\n\n  setSegmentSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    config: SegmentSpecificRepresentationConfig,\n    options?: {\n      clear: false;\n    }\n  ): void {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    if (!segmentationRepresentation.segmentSpecificConfig || options?.clear) {\n      segmentationRepresentation.segmentSpecificConfig = {};\n    }\n\n    Object.keys(config).forEach((key) => {\n      segmentationRepresentation.segmentSpecificConfig[key] = config[key];\n    });\n  }\n\n  /**\n   * Set the segmentation representations config for a given tool group. It will create a new\n   * tool group specific config if one does not exist.\n   *\n   * @param toolGroupId - The Id of the tool group that the segmentation\n   * belongs to.\n   * @param config - SegmentationConfig\n   */\n  setSegmentationRepresentationConfig(\n    toolGroupId: string,\n    config: SegmentationRepresentationConfig\n  ): void {\n    let toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupStateWithConfig) {\n      this.state.toolGroups[toolGroupId] = {\n        segmentationRepresentations: [],\n        config: {\n          renderInactiveSegmentations: true,\n          representations: {},\n        },\n      };\n\n      toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n    }\n\n    toolGroupStateWithConfig.config = {\n      ...toolGroupStateWithConfig.config,\n      ...config,\n    };\n  }\n\n  /**\n   * It adds a color LUT to the state.\n   * @param colorLUT - ColorLUT\n   * @param lutIndex - The index of the color LUT table to add.\n   */\n  addColorLUT(colorLUT: Types.ColorLUT, lutIndex: number): void {\n    if (this.state.colorLUT[lutIndex]) {\n      console.warn('Color LUT table already exists, overwriting');\n    }\n\n    this.state.colorLUT[lutIndex] = cloneDeep(colorLUT);\n  }\n\n  /**\n   * Removes a color LUT to the state.\n   * @param colorLUTIndex - The index of the color LUT table to remove.\n   */\n  removeColorLUT(colorLUTIndex: number): void {\n    delete this.state.colorLUT[colorLUTIndex];\n  }\n\n  /**\n   * It handles the active segmentation representation based on the active status of the\n   * segmentation representation that was added or removed.\n   *\n   * @param toolGroupId - The Id of the tool group that the segmentation representation belongs to.\n   * @param recentlyAddedOrRemovedSegmentationRepresentation - ToolGroupSpecificSegmentationData\n   */\n  _handleActiveSegmentation(\n    toolGroupId: string,\n    recentlyAddedOrRemovedSegmentationRepresentation: ToolGroupSpecificRepresentation\n  ): void {\n    const segmentationRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    // 1. If there is no segmentation representations, return early\n    if (segmentationRepresentations.length === 0) {\n      return;\n    }\n\n    // 2. If there is only one segmentation representation, make that one active\n    if (segmentationRepresentations.length === 1) {\n      segmentationRepresentations[0].active = true;\n      return;\n    }\n\n    // 3. If removed Segmentation representation was active, make the first one active\n    const activeSegmentationRepresentations =\n      segmentationRepresentations.filter(\n        (representation) => representation.active\n      );\n\n    if (activeSegmentationRepresentations.length === 0) {\n      segmentationRepresentations[0].active = true;\n      return;\n    }\n\n    // 4. If the added segmentation representation is active, make other segmentation\n    // representations inactive\n    if (recentlyAddedOrRemovedSegmentationRepresentation.active) {\n      segmentationRepresentations.forEach((representation) => {\n        if (\n          representation.segmentationRepresentationUID !==\n          recentlyAddedOrRemovedSegmentationRepresentation.segmentationRepresentationUID\n        ) {\n          representation.active = false;\n        }\n      });\n    }\n\n    // 5. if added/removed segmentation is is inactive, do nothing\n  }\n}\n\nconst defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');\nexport { defaultSegmentationStateManager };\n","import {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataVolume,\n} from '../../../../types/LabelmapTypes';\nimport {\n  LabelmapToolOperationData,\n  LabelmapToolOperationDataStack,\n  LabelmapToolOperationDataVolume,\n} from '../../../../types';\nimport { Types, VolumeViewport } from '@cornerstonejs/core';\n\nfunction isVolumeSegmentation(\n  operationData: LabelmapToolOperationData | LabelmapSegmentationData,\n  viewport?: Types.IViewport\n): operationData is\n  | LabelmapToolOperationDataVolume\n  | LabelmapSegmentationDataVolume {\n  const { imageIdReferenceMap } =\n    operationData as LabelmapToolOperationDataStack;\n  const { volumeId } = operationData as LabelmapToolOperationDataVolume;\n\n  if (volumeId && !imageIdReferenceMap) {\n    return true;\n  }\n\n  if (imageIdReferenceMap && !volumeId) {\n    return false;\n  }\n\n  if (volumeId && imageIdReferenceMap && !viewport) {\n    throw new Error(\n      'isVolumeSegmentation: viewport is required when both volumeId and imageIdReferenceMap are provided'\n    );\n  }\n\n  // we can get the viewport to decide\n  return viewport instanceof VolumeViewport;\n}\n\nexport { isVolumeSegmentation };\n","import { Types, cache } from '@cornerstonejs/core';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\nimport { SegmentationRepresentations } from '../../enums';\n\nconst segmentIndicesCache = new Map<\n  string,\n  { indices: number[]; isDirty: boolean }\n>();\n\n/**\n * Sets the segmentation as dirty, indicating that it needs to be updated.\n * @param segmentationId - The ID of the segmentation.\n */\nexport const setSegmentationDirty = (segmentationId: string) => {\n  const cached = segmentIndicesCache.get(segmentationId);\n  if (cached) {\n    cached.isDirty = true;\n  }\n};\n\nexport const setSegmentationClean = (segmentationId: string) => {\n  const cached = segmentIndicesCache.get(segmentationId);\n  if (cached) {\n    cached.isDirty = false;\n  }\n};\n\nfunction getCachedSegmentIndices(segmentationId) {\n  const cached = segmentIndicesCache.get(segmentationId);\n  if (cached && !cached.isDirty) {\n    return cached.indices;\n  }\n  return null;\n}\n\n/**\n * Retrieves the unique segment indices from a given segmentation.\n *\n * @param segmentationId - The ID of the segmentation.\n * @returns An array of unique segment indices.\n * @throws If no geometryIds are found for the segmentationId.\n */\nfunction getUniqueSegmentIndices(segmentationId) {\n  // Attempt to fetch from cache first\n  const cachedResult = getCachedSegmentIndices(segmentationId);\n  if (cachedResult) {\n    return cachedResult;\n  }\n\n  const segmentation = getSegmentation(segmentationId);\n  if (!segmentation) {\n    throw new Error(\n      `No segmentation found for segmentationId ${segmentationId}`\n    );\n  }\n\n  let indices;\n  switch (segmentation.type) {\n    case SegmentationRepresentations.Labelmap:\n      indices = handleLabelmapSegmentation(segmentation, segmentationId);\n      break;\n    case SegmentationRepresentations.Contour:\n      indices = handleContourSegmentation(segmentation);\n      break;\n    case SegmentationRepresentations.Surface:\n      indices = handleSurfaceSegmentation(segmentation);\n      break;\n    default:\n      throw new Error(`Unsupported segmentation type: ${segmentation.type}`);\n  }\n\n  // Update cache\n  segmentIndicesCache.set(segmentationId, { indices, isDirty: false });\n  return indices;\n}\n\nfunction handleLabelmapSegmentation(segmentation, segmentationId) {\n  const labelmapData =\n    segmentation.representationData[SegmentationRepresentations.Labelmap];\n  const keySet = new Set();\n\n  if (isVolumeSegmentation(labelmapData)) {\n    addVolumeSegmentIndices(keySet, segmentationId);\n  } else {\n    addImageSegmentIndices(keySet, labelmapData.imageIdReferenceMap);\n  }\n\n  return Array.from(keySet)\n    .map(Number)\n    .sort((a, b) => a - b);\n}\n\nfunction addVolumeSegmentIndices(keySet, segmentationId) {\n  const volume = cache.getVolume(segmentationId);\n  const scalarData = volume.getScalarData();\n  scalarData.forEach((segmentIndex) => {\n    if (segmentIndex !== 0) {\n      keySet.add(segmentIndex);\n    }\n  });\n}\n\nfunction addImageSegmentIndices(keySet, imageIdReferenceMap) {\n  imageIdReferenceMap.forEach((segmentationImageId) => {\n    const image = cache.getImage(segmentationImageId);\n    const scalarData = image.getPixelData();\n    scalarData.forEach((segmentIndex) => {\n      if (segmentIndex !== 0) {\n        keySet.add(segmentIndex);\n      }\n    });\n  });\n}\n\nfunction handleContourSegmentation(segmentation) {\n  const { annotationUIDsMap, geometryIds } =\n    segmentation.representationData.CONTOUR || {};\n  if (!geometryIds) {\n    throw new Error(\n      `No geometryIds found for segmentationId ${segmentation.segmentationId}`\n    );\n  }\n\n  const indices = new Set([...annotationUIDsMap.keys()]);\n  geometryIds.forEach((geometryId) => {\n    const geometry = cache.getGeometry(geometryId);\n    indices.add((geometry.data as Types.IContourSet).getSegmentIndex());\n  });\n\n  return Array.from(indices).sort((a, b) => a - b);\n}\n\nfunction handleSurfaceSegmentation(segmentation) {\n  const geometryIds =\n    segmentation.representationData.SURFACE?.geometryIds ?? [];\n  return Array.from(geometryIds.keys())\n    .map(Number)\n    .sort((a, b) => a - b);\n}\n\nexport { getUniqueSegmentIndices };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\n\nimport { Events } from '../../enums';\nimport {\n  getSegmentationRepresentations,\n  getSegmentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport {\n  SegmentationRepresentationModifiedEventDetail,\n  SegmentationDataModifiedEventDetail,\n  SegmentationModifiedEventDetail,\n  SegmentationRepresentationRemovedEventDetail,\n  SegmentationRemovedEventDetail,\n} from '../../types/EventTypes';\nimport { setSegmentationDirty } from '../../utilities/segmentation/getUniqueSegmentIndices';\n\n/**\n * Trigger an event that a segmentation is removed\n * @param segmentationId - The Id of segmentation\n */\nfunction triggerSegmentationRemoved(segmentationId: string): void {\n  const eventDetail: SegmentationRemovedEventDetail = {\n    segmentationId,\n  };\n\n  triggerEvent(eventTarget, Events.SEGMENTATION_REMOVED, eventDetail);\n}\n\n/**\n * Trigger an event that a segmentation representation was removed\n * @param toolGroupId - The id of the tool group that the segmentation\n * representation was removed from.\n * @param segmentationRepresentationUID - The UID of the segmentation\n * representation that was removed.\n */\nfunction triggerSegmentationRepresentationRemoved(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const eventDetail: SegmentationRepresentationRemovedEventDetail = {\n    toolGroupId,\n    segmentationRepresentationUID,\n  };\n\n  triggerEvent(\n    eventTarget,\n    Events.SEGMENTATION_REPRESENTATION_REMOVED,\n    eventDetail\n  );\n}\n\n/**\n * Trigger an event on the eventTarget that the segmentation representation for\n * toolGroupId has been updated\n * @param toolGroupId - The Id of the toolGroup\n */\nfunction triggerSegmentationRepresentationModified(\n  toolGroupId: string,\n  segmentationRepresentationUID?: string\n): void {\n  const eventDetail: SegmentationRepresentationModifiedEventDetail = {\n    toolGroupId,\n    segmentationRepresentationUID,\n  };\n\n  if (segmentationRepresentationUID) {\n    triggerEvent(\n      eventTarget,\n      Events.SEGMENTATION_REPRESENTATION_MODIFIED,\n      eventDetail\n    );\n    return;\n  }\n\n  // If no segmentationRepresentationUID is provided, then we need to trigger\n  // the event for all segmentation representations in the toolGroup\n\n  // Get all segmentation representations in the toolGroup\n  const segmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId) || [];\n\n  segmentationRepresentations.forEach((segmentationRepresentation) => {\n    const { segmentationRepresentationUID } = segmentationRepresentation;\n    const eventDetail: SegmentationRepresentationModifiedEventDetail = {\n      toolGroupId,\n      segmentationRepresentationUID,\n    };\n\n    triggerEvent(\n      eventTarget,\n      Events.SEGMENTATION_REPRESENTATION_MODIFIED,\n      eventDetail\n    );\n  });\n}\n\n/**\n * Triggers segmentation global state updated event, notifying all toolGroups\n * that the global state has been updated, If a segmentationId is provided\n * the event will only be triggered for that segmentation, otherwise it will\n * be triggered for all segmentations.\n *\n * @param segmentationId - The id of the segmentation that has been updated\n */\nfunction triggerSegmentationModified(segmentationId?: string): void {\n  let segmentationIds;\n\n  if (segmentationId) {\n    segmentationIds = [segmentationId];\n  } else {\n    // get all toolGroups\n    segmentationIds = getSegmentations().map(\n      ({ segmentationId }) => segmentationId\n    );\n  }\n\n  // 1. Trigger an event notifying all listeners about the segmentationId\n  // that has been updated.\n  segmentationIds.forEach((segmentationId) => {\n    const eventDetail: SegmentationModifiedEventDetail = {\n      segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_MODIFIED, eventDetail);\n  });\n\n  // Todo: I don't think we need the following lines of code\n  // // 2. Notify all viewports that render the segmentationId in order to update the\n  // // rendering based on the new global state.\n  // toolGroupIds.forEach((toolGroupId) => {\n  //   triggerSegmentationRepresentationModified(toolGroupId)\n  // })\n}\n\n/**\n * Trigger an event that a segmentation data has been modified\n * @param segmentationId - The Id of segmentation\n */\nfunction triggerSegmentationDataModified(\n  segmentationId: string,\n  modifiedSlicesToUse?: number[]\n): void {\n  const eventDetail: SegmentationDataModifiedEventDetail = {\n    segmentationId,\n    modifiedSlicesToUse,\n  };\n\n  // set it to dirty to force the next call to getUniqueSegmentIndices to\n  // recalculate the segment indices\n  setSegmentationDirty(segmentationId);\n\n  triggerEvent(eventTarget, Events.SEGMENTATION_DATA_MODIFIED, eventDetail);\n}\n\nexport {\n  // ToolGroup Specific\n  triggerSegmentationRepresentationModified,\n  triggerSegmentationRepresentationRemoved,\n  // Global\n  triggerSegmentationDataModified,\n  triggerSegmentationModified,\n  triggerSegmentationRemoved,\n};\n","import { SegmentationRepresentations } from '../../../enums';\nimport {\n  SegmentationPublicInput,\n  Segmentation,\n} from '../../../types/SegmentationStateTypes';\nimport type { ContourSegmentationData } from '../../../types/ContourTypes';\n\n/**\n * It takes in a segmentation input and returns a segmentation with default values\n * @param segmentationInput - The input to the segmentation.\n * @returns A Segmentation object.\n * @internal\n */\nfunction normalizeSegmentationInput(\n  segmentationInput: SegmentationPublicInput\n): Segmentation {\n  const { segmentationId, representation } = segmentationInput;\n  const isContourRepresentation =\n    representation.type === SegmentationRepresentations.Contour;\n  let data = representation.data ? { ...representation.data } : null;\n\n  // Contour representation data is defined internally\n  data = !data && isContourRepresentation ? {} : data;\n\n  // Data cannot be undefined for labelmap and surface\n  if (!data) {\n    throw new Error('Segmentation representation data may not be undefined');\n  }\n\n  if (isContourRepresentation) {\n    const contourData = <ContourSegmentationData>data;\n\n    // geometryIds will be removed in a near future. It still exist in the\n    // code for compatibility only but it is optional from now on.\n    contourData.geometryIds = contourData.geometryIds ?? [];\n\n    // Make sure annotationUIDsMap is defined because an empty contour is\n    // created before adding contour annotations to the map. Also it prevents\n    // breaking legacy code after moving from geometryIds to annotationUIDsMap.\n    contourData.annotationUIDsMap = contourData.annotationUIDsMap ?? new Map();\n  }\n\n  // Todo: we should be able to let the user pass in non-default values for\n  // cachedStats, label, activeSegmentIndex, etc.\n  return {\n    segmentationId,\n    cachedStats: {},\n    segmentLabels: {},\n    label: null,\n    segmentsLocked: new Set(),\n    type: representation.type,\n    activeSegmentIndex: 1,\n    representationData: {\n      [representation.type]: {\n        ...data,\n      },\n    },\n  };\n}\n\nexport default normalizeSegmentationInput;\n","import type { Types } from '@cornerstonejs/core';\nimport type {\n  RepresentationConfig,\n  Segmentation,\n  SegmentationPublicInput,\n  SegmentationRepresentationConfig,\n  SegmentSpecificRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n  ToolGroupSpecificRepresentations,\n} from '../../types/SegmentationStateTypes';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport {\n  triggerSegmentationModified,\n  triggerSegmentationRemoved,\n  triggerSegmentationRepresentationModified,\n  triggerSegmentationRepresentationRemoved,\n} from './triggerSegmentationEvents';\n\nimport normalizeSegmentationInput from './helpers/normalizeSegmentationInput';\n\n/**\n * It returns the defaultSegmentationStateManager.\n */\nfunction getDefaultSegmentationStateManager() {\n  return defaultSegmentationStateManager;\n}\n\n/*************************\n *\n * Segmentation State\n *\n **************************/\n\n/**\n * Get the segmentation for the given segmentationId\n * @param segmentationId - The Id of the segmentation\n * @returns A GlobalSegmentationData object\n */\nfunction getSegmentation(segmentationId: string): Segmentation | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentation(segmentationId);\n}\n\n/**\n * Get the segmentations inside the state\n * @returns Segmentation array\n */\nfunction getSegmentations(): Segmentation[] | [] {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  const state = segmentationStateManager.getState();\n\n  return state.segmentations;\n}\n\n/**\n * It takes a segmentation input and adds it to the segmentation state manager\n * @param segmentationInput - The segmentation to add.\n * @param suppressEvents - If true, the event will not be triggered.\n */\nfunction addSegmentation(\n  segmentationInput: SegmentationPublicInput,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  const segmentation = normalizeSegmentationInput(segmentationInput);\n\n  segmentationStateManager.addSegmentation(segmentation);\n\n  if (!suppressEvents) {\n    triggerSegmentationModified(segmentation.segmentationId);\n  }\n}\n\n/**\n * Get the segmentation state for a tool group. It will return an array of\n * segmentation representation objects.\n * @param toolGroupId - The unique identifier of the tool group.\n * @returns An array of segmentation representation objects.\n */\nfunction getSegmentationRepresentations(\n  toolGroupId: string\n): ToolGroupSpecificRepresentations | [] {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n}\n\n/**\n * Get all segmentation representations in the state\n * @returns An array of segmentation representation objects.\n */\nfunction getAllSegmentationRepresentations(): Record<\n  string,\n  ToolGroupSpecificRepresentation[]\n> {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getAllSegmentationRepresentations();\n}\n\n/**\n * Finds all segmentation representations with the given segmentationId.\n * @param segmentationId - The ID of the segmentation.\n * @returns An array of found segmentation representations.\n */\nfunction getSegmentationIdRepresentations(segmentationId) {\n  const allRepresentations = getAllSegmentationRepresentations() || {};\n  const foundRepresentations = [];\n\n  for (const toolGroupId in allRepresentations) {\n    const toolGroupRepresentations = allRepresentations[toolGroupId];\n\n    const foundRepresentation = toolGroupRepresentations.find(\n      (representation) => representation.segmentationId === segmentationId\n    );\n\n    if (foundRepresentation) {\n      foundRepresentations.push(foundRepresentation);\n    }\n  }\n\n  return foundRepresentations;\n}\n\n/**\n * Finds a segmentation representation by its UID.\n *\n * @param segmentationRepresentationUID - The UID of the segmentation representation to find.\n * @returns The found segmentation representation, or undefined if not found.\n */\nfunction findSegmentationRepresentationByUID(\n  segmentationRepresentationUID: string\n): {\n  toolGroupId: string;\n  segmentationRepresentation: ToolGroupSpecificRepresentation;\n} {\n  const allToolGroupRepresentations = getAllSegmentationRepresentations() || [];\n\n  const toolGroupIds = Object.keys(allToolGroupRepresentations);\n\n  for (const toolGroupId of toolGroupIds) {\n    const toolGroupRepresentations =\n      getAllSegmentationRepresentations()[toolGroupId];\n\n    const foundRepresentation = toolGroupRepresentations.find(\n      (representation) =>\n        representation.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    if (foundRepresentation) {\n      return {\n        segmentationRepresentation: foundRepresentation,\n        toolGroupId,\n      };\n    }\n  }\n}\n\n/**\n * Get the tool group IDs that have a segmentation representation with the given\n * segmentationId\n * @param segmentationId - The id of the segmentation\n * @returns An array of tool group IDs.\n */\nfunction getToolGroupIdsWithSegmentation(segmentationId: string): string[] {\n  if (!segmentationId) {\n    throw new Error('getToolGroupIdsWithSegmentation: segmentationId is empty');\n  }\n\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  const state = segmentationStateManager.getState();\n  const toolGroupIds = Object.keys(state.toolGroups);\n\n  const foundToolGroupIds = [];\n  toolGroupIds.forEach((toolGroupId) => {\n    const toolGroupSegmentationRepresentations =\n      segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n\n    toolGroupSegmentationRepresentations.forEach((representation) => {\n      if (representation.segmentationId === segmentationId) {\n        foundToolGroupIds.push(toolGroupId);\n      }\n    });\n  });\n\n  return foundToolGroupIds;\n}\n\n/**\n * Get the segmentation representations config for a given tool group\n * @param toolGroupId - The Id of the tool group that the segmentation\n * config belongs to.\n * @returns A SegmentationConfig object.\n */\nfunction getToolGroupSpecificConfig(\n  toolGroupId: string\n): SegmentationRepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getToolGroupSpecificConfig(toolGroupId);\n}\n\n/**\n * Set the segmentation representation config for the provided toolGroup. ToolGroup specific\n * configuration overwrites the global configuration for each representation.\n * It fires SEGMENTATION_REPRESENTATION_MODIFIED event if not suppressed.\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n * @param toolGroupId - The Id of the tool group that the segmentation\n * config is being set for.\n * @param config - The new configuration for the tool group.\n * @param suppressEvents - If true, the event will not be triggered.\n */\nfunction setToolGroupSpecificConfig(\n  toolGroupId: string,\n  config: SegmentationRepresentationConfig,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentationRepresentationConfig(\n    toolGroupId,\n    config\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(toolGroupId);\n  }\n}\n\n/**\n * It sets the segmentation representation specific config for all the segments\n * inside the segmentation.\n * @param segmentationRepresentationUID - The unique identifier of the segmentation representation.\n * @param config  - The new configuration for the segmentation representation it is an object with keys of\n * different representation types, and values of the configuration for each representation type.\n */\nfunction setSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: RepresentationConfig,\n  suppressEvents = false\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n  }\n}\n\n/**\n * It returns the segmentation representation specific config which is the same for all the segments\n * @param segmentationRepresentationUID - The unique identifier of the segmentation representation.\n * @returns - The segmentation representation specific config.\n */\nfunction getSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): RepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nfunction getSegmentSpecificRepresentationConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): RepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n}\n\nfunction setSegmentSpecificRepresentationConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: SegmentSpecificRepresentationConfig,\n  suppressEvents = false\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n\n  // Todo: this can be even more performant if we create a new event for\n  // triggering a specific segment config change.\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n  }\n}\n\nfunction getToolGroupIdFromSegmentationRepresentationUID(\n  segmentationRepresentationUID: string\n): string {\n  const allToolGroupRepresentations = getAllSegmentationRepresentations() || [];\n\n  const toolGroupIds = Object.keys(allToolGroupRepresentations);\n\n  for (const toolGroupId of toolGroupIds) {\n    const toolGroupRepresentations =\n      getAllSegmentationRepresentations()[toolGroupId];\n\n    const foundRepresentation = toolGroupRepresentations.find(\n      (representation) =>\n        representation.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    if (foundRepresentation) {\n      return toolGroupId;\n    }\n  }\n}\n\n/**\n * Add the given segmentation representation data to the given tool group state. It fires\n * SEGMENTATION_REPRESENTATION_MODIFIED event if not suppressed.\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n *\n * @param toolGroupId - The Id of the tool group that the segmentation representation is for.\n * @param segmentationData - The data to add to the segmentation state.\n * @param suppressEvents - boolean\n */\nfunction addSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentation: ToolGroupSpecificRepresentation,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.addSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentation\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentation.segmentationRepresentationUID\n    );\n  }\n}\n\n/**\n * It returns the global segmentation config. Note that the toolGroup-specific\n * configuration has higher priority than the global configuration and overwrites\n * the global configuration for each representation.\n * @returns The global segmentation configuration for all segmentations.\n */\nfunction getGlobalConfig(): SegmentationRepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getGlobalConfig();\n}\n\n/**\n * Set the global segmentation configuration. It fires SEGMENTATION_MODIFIED\n * event if not suppressed.\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param config - The new global segmentation config.\n * @param suppressEvents - If true, the `segmentationGlobalStateModified` event will not be triggered.\n */\nfunction setGlobalConfig(\n  config: SegmentationRepresentationConfig,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setGlobalConfig(config);\n\n  if (!suppressEvents) {\n    triggerSegmentationModified();\n  }\n}\n\n/**\n * Get the segmentation data object for a given tool group and\n * segmentation data UID. It searches all the toolGroup specific segmentation\n * data objects and returns the first one that matches the UID.\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @returns Segmentation Data object.\n */\nfunction getSegmentationRepresentationByUID(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): ToolGroupSpecificRepresentation | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentationByUID(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * It removes the segmentation from the segmentation state manager\n *\n * @triggers SEGMENTATION_REMOVED\n *\n * @param segmentationId - The id of the segmentation\n */\nfunction removeSegmentation(segmentationId: string): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeSegmentation(segmentationId);\n  triggerSegmentationRemoved(segmentationId);\n}\n\n/**\n * Remove a segmentation representation from the segmentation state manager for a toolGroup.\n * It fires SEGMENTATION_REPRESENTATION_MODIFIED event.\n *\n * @triggers SEGMENTATION_REPRESENTATION_REMOVED\n *\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation to remove.\n * remove.\n * @param - immediate - If true, the viewports will be updated immediately.\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  triggerSegmentationRepresentationRemoved(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Removes all segmentation representations associated with a tool group.\n * @param toolGroupId - The ID of the tool group.\n */\nfunction removeSegmentationRepresentations(toolGroupId: string): void {\n  const segmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId) || [];\n\n  segmentationRepresentations.forEach((representation) => {\n    removeSegmentationRepresentation(\n      toolGroupId,\n      representation.segmentationRepresentationUID\n    );\n  });\n}\n\n/**\n * Add a color LUT to the segmentation state manager\n * @param colorLUT - The color LUT array to add.\n * @param index - The index of the color LUT to add.\n */\nfunction removeColorLUT(colorLUTIndex: number): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeColorLUT(colorLUTIndex);\n}\n\n/**\n * Get the color lut for a given index\n * @param index - The index of the color lut to retrieve.\n * @returns A ColorLUT array.\n */\nfunction getColorLUT(index: number): Types.ColorLUT | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getColorLUT(index);\n}\n\nfunction getNextColorLUTIndex(): number {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getNextColorLUTIndex();\n}\n\n/**\n * Add a color LUT to the segmentation state manager\n * @param colorLUT - The color LUT array to add.\n * @param index - The index of the color LUT to add.\n */\nfunction addColorLUT(colorLUT: Types.ColorLUT, index: number): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.addColorLUT(colorLUT, index);\n  // Todo: trigger event color LUT added\n}\n\nexport {\n  getDefaultSegmentationStateManager,\n  // Segmentation\n  getSegmentation,\n  getSegmentations,\n  addSegmentation,\n  removeSegmentation,\n  // ToolGroup specific Segmentation Representation\n  getSegmentationRepresentations,\n  addSegmentationRepresentation,\n  removeSegmentationRepresentation,\n  removeSegmentationRepresentations,\n  // config\n  getToolGroupSpecificConfig,\n  setToolGroupSpecificConfig,\n  getGlobalConfig,\n  setGlobalConfig,\n  getSegmentationRepresentationSpecificConfig,\n  setSegmentationRepresentationSpecificConfig,\n  getSegmentSpecificRepresentationConfig,\n  setSegmentSpecificRepresentationConfig,\n  // helpers s\n  getToolGroupIdsWithSegmentation,\n  getAllSegmentationRepresentations,\n  getSegmentationRepresentationByUID,\n  getSegmentationIdRepresentations,\n  // color\n  addColorLUT,\n  getColorLUT,\n  getNextColorLUTIndex,\n  removeColorLUT,\n  //\n  findSegmentationRepresentationByUID,\n  getToolGroupIdFromSegmentationRepresentationUID,\n};\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { IPoints } from '../../types';\n\n/**\n * Given a native mouse event, get the associated cornerstone3D enabled element\n * and derive a set of coordinates useful for tools.\n * @param evt - The Mouse event.\n * @param element - The DOM HTMLDivElement that the event was triggered on.\n * @returns The points related to the event in the form of a `IPoints` object containing\n * the following properties: `page`, `client`, `canvas`, and `world` details of the event.\n */\nexport default function getMouseEventPoints(\n  evt: MouseEvent,\n  element?: HTMLDivElement\n): IPoints {\n  const elementToUse = element || (evt.currentTarget as HTMLDivElement);\n  const { viewport } = getEnabledElement(elementToUse);\n  const clientPoint = _clientToPoint(evt);\n  const pagePoint = _pageToPoint(evt);\n  const canvasPoint = _pagePointsToCanvasPoints(elementToUse, pagePoint);\n  const worldPoint = viewport.canvasToWorld(canvasPoint);\n\n  return {\n    page: pagePoint,\n    client: clientPoint,\n    canvas: canvasPoint,\n    world: worldPoint,\n  };\n}\n\n/**\n * Converts point from page coordinates to canvas coordinates.\n * @param element - HTMLDivElement\n * @param pagePoint - Point in page coordinates pageX and pageY\n *\n * @returns The canvas coordinate points\n */\nfunction _pagePointsToCanvasPoints(\n  element: HTMLDivElement,\n  pagePoint: Types.Point2\n): Types.Point2 {\n  const rect = element.getBoundingClientRect();\n  return [\n    pagePoint[0] - rect.left - window.pageXOffset,\n    pagePoint[1] - rect.top - window.pageYOffset,\n  ];\n}\n\n/**\n * Converts the event's `pageX` and `pageY` properties to Types.Point2 format\n *\n * @param evt - The Mouse `Event`\n */\nfunction _pageToPoint(evt: MouseEvent): Types.Point2 {\n  return [evt.pageX, evt.pageY];\n}\n\n/**\n * Converts the event's `clientX` and `clientY` properties to Types.Point2 format\n * @param evt - The Mouse `Event`\n */\nfunction _clientToPoint(evt: MouseEvent): Types.Point2 {\n  return [evt.clientX, evt.clientY];\n}\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport getMouseEventPoints from './getMouseEventPoints';\nimport { EventTypes, IPoints } from '../../types';\n\n/**\n * Captures and normalizes the double click event. Emits as a cornerstoneTools3D\n * double click event.\n *\n * @param evt - The mouse event.\n */\nfunction mouseDoubleClickListener(evt: MouseEvent): void {\n  const element = <HTMLDivElement>evt.currentTarget;\n\n  const { viewportId, renderingEngineId } = getEnabledElement(element);\n\n  const startPoints = getMouseEventPoints(evt, element);\n  const deltaPoints: IPoints = {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  };\n\n  const eventDetail: EventTypes.MouseDoubleClickEventDetail = {\n    event: evt,\n    eventName: Events.MOUSE_DOUBLE_CLICK,\n    viewportId,\n    renderingEngineId,\n    camera: {},\n    element,\n    startPoints,\n    lastPoints: startPoints,\n    currentPoints: startPoints,\n    deltaPoints,\n  };\n\n  const consumed = !triggerEvent(\n    element,\n    Events.MOUSE_DOUBLE_CLICK,\n    eventDetail\n  );\n\n  if (consumed) {\n    // The Events.MOUSE_DOUBLE_CLICK was consumed, thus no other listener should handle this 'dblclick' event.\n\n    // Use stopImmediatePropagation to lessen the possibility that a third party 'dblclick'\n    // listener receives this event. However, there still is no guarantee\n    // that any third party listener has not already handled the event.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  }\n}\n\nexport default mouseDoubleClickListener;\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport getMouseEventPoints from './getMouseEventPoints';\nimport { MouseMoveEventDetail } from '../../types/EventTypes';\n\nconst eventName = Events.MOUSE_MOVE;\n\n/**\n * Captures and normalizes the mouse move event. Emits as a cornerstoneTools3D\n * mouse move event.\n *\n * @param evt - The mouse event.\n */\nfunction mouseMoveListener(evt: MouseEvent) {\n  const element = <HTMLDivElement>evt.currentTarget;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  const currentPoints = getMouseEventPoints(evt);\n  const eventDetail: MouseMoveEventDetail = {\n    renderingEngineId,\n    viewportId,\n    camera: {},\n    element,\n    currentPoints,\n    eventName,\n    event: evt,\n  };\n\n  const consumed = !triggerEvent(element, eventName, eventDetail);\n\n  // Events.MOUSE_MOVE was consumed, thus no other listener should handle this event.\n  if (consumed) {\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  }\n}\n\nexport default mouseMoveListener;\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport Events from '../../enums/Events';\nimport { MouseBindings } from '../../enums/ToolBindings';\nimport mouseMoveListener from './mouseMoveListener';\nimport { EventTypes, IPoints } from '../../types';\nimport getMouseEventPoints from './getMouseEventPoints';\n\nconst { MOUSE_DOWN, MOUSE_DOWN_ACTIVATE, MOUSE_CLICK, MOUSE_UP, MOUSE_DRAG } =\n  Events;\n\n// The amount of time in milliseconds within which a browser 'dblclick' event has to occur.\n// Any mouse down, up, down and up sequence taking longer than this time is considered to\n// NOT be a double click and any browser 'dblclick' event that subsequently occurs as a result\n// of such a sequence will be ignored. It is best to set this to a value that is less\n// than the system value for detecting a double click. Setting something too large\n// might detect a double click that does not constitute a browser 'dblclick' and thus\n// no mouse events for the sequence will get fired at all.\n//\n// TODO This module should detect and fire 'dblclick' events at its discretion and\n// ignore all those generated by the browser.\n//\nconst DOUBLE_CLICK_TOLERANCE_MS = 400;\n\n// This tolerance is how long to accept a secondary button down\nconst MULTI_BUTTON_TOLERANCE_MS = 150;\n\n// A drag (projected distance) during the double click timeout that is greater than this\n// value will cancel the timeout and suppress any double click that might occur.\n// This tolerance is particularly important on touch devices where some movement\n// might occur between the two clicks.\n//\n// TODO revisit this value for touch devices\n//\nconst DOUBLE_CLICK_DRAG_TOLERANCE = 3;\n\ninterface IMouseDownListenerState {\n  mouseButton: number;\n  element: HTMLDivElement;\n  renderingEngineId: string;\n  viewportId: string;\n  isClickEvent: boolean;\n  clickDelay: number;\n  preventClickTimeout: ReturnType<typeof setTimeout>;\n  startPoints: IPoints;\n  lastPoints: IPoints;\n}\n\ninterface IDoubleClickState {\n  doubleClickTimeout: ReturnType<typeof setTimeout>;\n  mouseDownEvent: MouseEvent;\n  mouseUpEvent: MouseEvent;\n  ignoreDoubleClick: boolean;\n}\n\n// STATE\nconst defaultState: IMouseDownListenerState = {\n  mouseButton: undefined,\n  //\n  element: null,\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  isClickEvent: true,\n  clickDelay: 200,\n  preventClickTimeout: null,\n  startPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n  lastPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n};\n\nlet state: IMouseDownListenerState = {\n  mouseButton: undefined,\n  //\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  isClickEvent: true,\n  clickDelay: 200,\n  element: null,\n  preventClickTimeout: null,\n  startPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n  lastPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n};\n\nconst doubleClickState: IDoubleClickState = {\n  doubleClickTimeout: null,\n  mouseDownEvent: null,\n  mouseUpEvent: null,\n  ignoreDoubleClick: false,\n};\n\n/**\n * Listens to mouse down events from the DOM and depending on interaction and further\n * interaction can emit the following mouse events:\n *\n * - MOUSE_DOWN\n * - MOUSE_DOWN_ACTIVATE\n * - MOUSE_DRAG (move while down)\n * - MOUSE_UP\n * - MOUSE_CLICK\n *\n * The mouse down is NOT handled immediately. Instead, a timeout is started to\n * determine if this mouse down is the first in a sequence that constitutes a\n * double click.\n *\n * @param evt - The Mouse event.\n * @private\n */\nfunction mouseDownListener(evt: MouseEvent) {\n  if (doubleClickState.doubleClickTimeout) {\n    // A second identical click will be a double click event, so ignore it\n    if (evt.buttons === doubleClickState.mouseDownEvent.buttons) {\n      return;\n    }\n\n    // Record the second button or the changed button event as the initial\n    // button down state so that the multi-button event can be detected\n    doubleClickState.mouseDownEvent = evt;\n\n    // If second button is added, then ensure double click timeout is terminated\n    // and do not handle three or more button gestures.\n    _doStateMouseDownAndUp();\n    return;\n  }\n\n  // Handle multi-button clicks by adding a delay before handling them.\n  // Double clicks (left button only) physically take the user longer, so\n  // use a longer timeout, and for multi-button at the same time, the clicks\n  // are done at the same time by the user, just the system perceives them\n  // separately, so have a short timeout to allow catching both buttons.\n  doubleClickState.doubleClickTimeout = setTimeout(\n    _doStateMouseDownAndUp,\n    evt.buttons === 1 ? DOUBLE_CLICK_TOLERANCE_MS : MULTI_BUTTON_TOLERANCE_MS\n  );\n\n  // First mouse down of a potential double click. So save it and start\n  // a timeout to determine a double click.\n  doubleClickState.mouseDownEvent = evt;\n  doubleClickState.ignoreDoubleClick = false;\n\n  state.element = <HTMLDivElement>evt.currentTarget;\n\n  state.mouseButton = evt.buttons;\n\n  const enabledElement = getEnabledElement(state.element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  state.renderingEngineId = renderingEngineId;\n  state.viewportId = viewportId;\n\n  state.preventClickTimeout = setTimeout(\n    _preventClickHandler,\n    state.clickDelay\n  );\n\n  // Prevent CornerstoneToolsMouseMove while mouse is down\n  state.element.removeEventListener('mousemove', mouseMoveListener);\n\n  const startPoints = getMouseEventPoints(evt, state.element);\n  state.startPoints = _copyPoints(startPoints);\n  state.lastPoints = _copyPoints(startPoints);\n\n  document.addEventListener('mouseup', _onMouseUp);\n  document.addEventListener('mousemove', _onMouseDrag);\n}\n\n/**\n * Does the actual mouse down logic if the double click timer has expired or\n * a mouse drag has started.\n * @param evt the mouse down event\n * @private\n */\nfunction _doMouseDown(evt: MouseEvent) {\n  const deltaPoints = _getDeltaPoints(state.startPoints, state.startPoints);\n\n  const eventDetail: EventTypes.MouseDownEventDetail = {\n    event: evt,\n    eventName: MOUSE_DOWN,\n    element: state.element,\n    mouseButton: state.mouseButton,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    startPoints: state.startPoints,\n    lastPoints: state.startPoints,\n    currentPoints: state.startPoints,\n    deltaPoints,\n  };\n\n  state.lastPoints = _copyPoints(eventDetail.lastPoints);\n\n  // by triggering MOUSE_DOWN it checks if this is toolSelection, handle modification etc.\n  // of already existing tools\n  const notConsumed = triggerEvent(\n    eventDetail.element,\n    MOUSE_DOWN,\n    eventDetail\n  );\n\n  // if no tools responded to this event and prevented its default behavior,\n  // create a new tool\n  if (notConsumed) {\n    triggerEvent(eventDetail.element, MOUSE_DOWN_ACTIVATE, eventDetail);\n  }\n}\n\n/**\n *_onMouseDrag - Handle emission of drag events whilst the mouse is depressed.\n *\n * @private\n * @param evt - The mouse event.\n */\nfunction _onMouseDrag(evt: MouseEvent) {\n  const currentPoints = getMouseEventPoints(evt, state.element);\n  const lastPoints = _updateMouseEventsLastPoints(\n    state.element,\n    state.lastPoints\n  );\n\n  const deltaPoints = _getDeltaPoints(currentPoints, lastPoints);\n\n  if (doubleClickState.doubleClickTimeout) {\n    if (_isDragPastDoubleClickTolerance(deltaPoints.canvas)) {\n      // Dragging past the tolerance means no double click should occur.\n      _doStateMouseDownAndUp();\n    } else {\n      return;\n    }\n  }\n\n  const eventDetail: EventTypes.MouseDragEventDetail = {\n    event: evt,\n    eventName: MOUSE_DRAG,\n    mouseButton: state.mouseButton,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    startPoints: _copyPoints(state.startPoints),\n    lastPoints: _copyPoints(lastPoints),\n    currentPoints,\n    deltaPoints,\n  };\n\n  const consumed = !triggerEvent(state.element, MOUSE_DRAG, eventDetail);\n\n  // Events.MOUSE_DRAG was consumed, thus no other listener should handle this event.\n  if (consumed) {\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  }\n\n  // Update the last points\n  state.lastPoints = _copyPoints(currentPoints);\n}\n\n/**\n *_onMouseUp - Handle emission of mouse up events, and re-enabling mouse move events.\n *\n * If the mouse up event occurs during a double click timeout, it is either the first or\n * second mouse up of a potential double click sequence. If the first, then it\n * is saved in case the double click timeout expires and a simple mouse down and\n * up have to get executed. If the second, then the latest mouse down, up, down and\n * up constitute a double click and the mouseDoubleClickListener needs to execute.\n *\n * If the mouse up event comes after the double click timeout, then it is simply\n * handled as the up of a mouse down and up sequence.\n *\n * @private\n * @param evt - The mouse event.\n */\nfunction _onMouseUp(evt: MouseEvent): void {\n  // Cancel the timeout preventing the click event from triggering\n  clearTimeout(state.preventClickTimeout);\n\n  if (doubleClickState.doubleClickTimeout) {\n    // received a mouse up while waiting for a double click (via a timeout)\n\n    if (!doubleClickState.mouseUpEvent) {\n      // this is the first mouse up during the double click timeout; we'll need it later if the timeout expires\n      doubleClickState.mouseUpEvent = evt;\n\n      state.element.addEventListener('mousemove', _onMouseMove);\n    } else {\n      // this is the second mouse up of a double click!\n      _cleanUp();\n    }\n  } else {\n    // Handle the actual mouse up. Note that it may have occurred during the double click timeout or\n    // after it expired. In either case this block is being executed after the time out has expired\n    // or after a drag started.\n\n    const eventName = state.isClickEvent ? MOUSE_CLICK : MOUSE_UP;\n\n    const currentPoints = getMouseEventPoints(evt, state.element);\n    const deltaPoints = _getDeltaPoints(currentPoints, state.lastPoints);\n\n    const eventDetail:\n      | EventTypes.MouseUpEventDetail\n      | EventTypes.MouseClickEventType = {\n      event: evt,\n      eventName,\n      mouseButton: state.mouseButton,\n      element: state.element,\n      renderingEngineId: state.renderingEngineId,\n      viewportId: state.viewportId,\n      camera: {},\n      startPoints: _copyPoints(state.startPoints),\n      lastPoints: _copyPoints(state.lastPoints),\n      currentPoints,\n      deltaPoints,\n    };\n\n    triggerEvent(eventDetail.element, eventName, eventDetail);\n\n    _cleanUp();\n  }\n\n  // Remove the drag as soon as we get the mouse up because either we have executed\n  // the mouse up logic, or we have not even handled the mouse down logic yet\n  // - either way no drag should/can occur.\n  document.removeEventListener('mousemove', _onMouseDrag);\n}\n\n/**\n * Handles a mouse move on the state element after a mouse down AND up AND\n * while the double click timeout is still running.\n * @private\n * @param evt - The mouse event.\n */\nfunction _onMouseMove(evt: MouseEvent) {\n  const currentPoints = getMouseEventPoints(evt, state.element);\n  const lastPoints = _updateMouseEventsLastPoints(\n    state.element,\n    state.lastPoints\n  );\n\n  const deltaPoints = _getDeltaPoints(currentPoints, lastPoints);\n\n  if (!_isDragPastDoubleClickTolerance(deltaPoints.canvas)) {\n    return;\n  }\n\n  _doStateMouseDownAndUp();\n\n  // Do the move again because during the timeout the global mouse move listener was removed.\n  // Now it is back.\n  mouseMoveListener(evt);\n}\n\n/**\n * Determines if the given delta is past the double click, (projected) drag distance\n * tolerance.\n * @param delta the delta\n * @returns true iff the delta is past the tolerance\n */\nfunction _isDragPastDoubleClickTolerance(delta: Types.Point2): boolean {\n  return Math.abs(delta[0]) + Math.abs(delta[1]) > DOUBLE_CLICK_DRAG_TOLERANCE;\n}\n\nfunction _preventClickHandler() {\n  state.isClickEvent = false;\n}\n\n/**\n * Do a mouse down and potential mouse up using each of the events in the double click state.\n * The events were stored in the state during the timeout to determine a double click.\n *\n * This function should be invoked whenever it is determined that the latest\n * sequence of mouse down(s) and up(s) is NOT a double click. Examples of this include\n * - the expiration of the double click timeout\n * - a mouse drag/move beyond the DOUBLE_CLICK_DRAG_TOLERANCE\n *\n * This function sets the doubleClickState.ignoreDoubleClick flag in case our timeout value\n * or mouse move/drag tolerance is inaccurate and we do indeed get a double click event from\n * the browser later. The flag will be cleared in the mouseDoubleClickIgnoreListener should a\n * double click event get fired. If there is no eventual double click for the latest sequence,\n * the flag spills into the next sequence where it will get cleared at the beginning of that next\n * sequence in mouseDownListener. It is perfectly safe for the flag to be\n * left true when no double click actually occurs because any future double click must start with\n * a mouse down that is handled in this module.\n *\n * @private\n */\nfunction _doStateMouseDownAndUp() {\n  doubleClickState.ignoreDoubleClick = true;\n\n  const mouseDownEvent = doubleClickState.mouseDownEvent;\n  const mouseUpEvent = doubleClickState.mouseUpEvent;\n\n  _clearDoubleClickTimeoutAndEvents();\n\n  _doMouseDown(mouseDownEvent);\n\n  if (mouseUpEvent) {\n    _onMouseUp(mouseUpEvent);\n  }\n}\n\n/**\n * Clears the mouse events and double click timeout id in the double click state object.\n * The timeout itself is also cleared so that no callback is invoked.\n */\nfunction _clearDoubleClickTimeoutAndEvents() {\n  if (doubleClickState.doubleClickTimeout) {\n    clearTimeout(doubleClickState.doubleClickTimeout);\n    doubleClickState.doubleClickTimeout = null;\n  }\n\n  doubleClickState.mouseDownEvent = null;\n  doubleClickState.mouseUpEvent = null;\n}\n\nfunction _cleanUp() {\n  document.removeEventListener('mouseup', _onMouseUp);\n  state.element?.removeEventListener('mousemove', _onMouseMove);\n\n  // Restore our global mousemove listener\n  state.element?.addEventListener('mousemove', mouseMoveListener);\n\n  _clearDoubleClickTimeoutAndEvents();\n\n  state = JSON.parse(JSON.stringify(defaultState));\n}\n\n/**\n * Copies a set of points.\n * @param points - The `IPoints` instance to copy.\n *\n * @returns A copy of the points.\n */\nfunction _copyPoints(points: IPoints): IPoints {\n  return JSON.parse(JSON.stringify(points));\n}\n\n/**\n * Recalculates the last world coordinate, as the linear transform from client\n * to world could be different if the camera was updated.\n * @param element - The HTML element\n * @param lastPoints - The last points\n */\nfunction _updateMouseEventsLastPoints(\n  element: HTMLDivElement,\n  lastPoints: IPoints\n): IPoints {\n  const { viewport } = getEnabledElement(element);\n  // Need to update the world point to be calculated from the current reference frame,\n  // Which might have changed since the last interaction.\n  const world = viewport.canvasToWorld(lastPoints.canvas);\n\n  return {\n    page: lastPoints.page,\n    client: lastPoints.client,\n    canvas: lastPoints.canvas,\n    world,\n  };\n}\n\n/**\n * Returns the difference between two `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints -- The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The difference in IPoints format\n */\nfunction _getDeltaPoints(currentPoints: IPoints, lastPoints: IPoints): IPoints {\n  return {\n    page: _subtractPoints2D(currentPoints.page, lastPoints.page),\n    client: _subtractPoints2D(currentPoints.client, lastPoints.client),\n    canvas: _subtractPoints2D(currentPoints.canvas, lastPoints.canvas),\n    world: _subtractPoints3D(currentPoints.world, lastPoints.world),\n  };\n}\n\n/**\n * _subtractPoints - Subtracts `point1` from `point0`.\n * @param point0 - The first point.\n * @param point1 - The second point to subtract from the first.\n *\n * @returns The difference.\n */\nfunction _subtractPoints2D(\n  point0: Types.Point2,\n  point1: Types.Point2\n): Types.Point2 {\n  return [point0[0] - point1[0], point0[1] - point1[1]];\n}\n\nfunction _subtractPoints3D(\n  point0: Types.Point3,\n  point1: Types.Point3\n): Types.Point3 {\n  return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\n\nexport function getMouseButton(): number {\n  return state.mouseButton;\n}\n\n/**\n * Handles a dblclick event to determine if it should be ignored based on the\n * double click state's ignoreDoubleClick flag. stopImmediatePropagation and\n * preventDefault are used to ignore the event.\n * @param evt browser dblclick event\n */\nexport function mouseDoubleClickIgnoreListener(evt: MouseEvent) {\n  if (doubleClickState.ignoreDoubleClick) {\n    doubleClickState.ignoreDoubleClick = false;\n\n    // Use stopImmediatePropagation to lessen the possibility that a third party 'dblclick'\n    // listener receives this event. However, there still is no guarantee\n    // that any third party listener has not already handled the event.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  } else {\n    // If the embedding application blocked the first mouse down and up\n    // of a double click sequence from reaching this module, then this module\n    // has handled the second mouse down and up and thus needs to clean them up.\n    // Doing a clean up here for the typical double click case is harmless.\n    _cleanUp();\n  }\n}\n\nexport default mouseDownListener;\n","import mouseDoubleClickListener from './mouseDoubleClickListener';\nimport mouseDownListener, {\n  mouseDoubleClickIgnoreListener,\n} from './mouseDownListener';\nimport mouseMoveListener from './mouseMoveListener';\n\n/**\n * Removes mouse event listeners for native mouse event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to remove event listeners from.\n */\nfunction disable(element: HTMLDivElement): void {\n  element.removeEventListener('dblclick', mouseDoubleClickListener);\n  element.removeEventListener('mousedown', mouseDownListener);\n  element.removeEventListener('mousemove', mouseMoveListener);\n  // The mouseDoubleClickIgnoreListener prevents those browser 'dblclick'\n  // events that cornerstone has determined are single clicks from propagating\n  // to other (3rd party) listeners. A capture phase listener is used so that\n  // the 'dblclick' event can be ignored and not propagated ASAP.\n  element.removeEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n    capture: true,\n  });\n}\n\n/**\n * Registers mouse event listeners for native mouse event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to register event listeners on.\n */\nfunction enable(element: HTMLDivElement): void {\n  // Prevent handlers from being attached multiple times\n  disable(element);\n\n  element.addEventListener('dblclick', mouseDoubleClickListener);\n  element.addEventListener('mousedown', mouseDownListener);\n  element.addEventListener('mousemove', mouseMoveListener);\n  // The mouseDoubleClickIgnoreListener prevents those browser 'dblclick'\n  // events that cornerstone has determined are single clicks from propagating\n  // to other (3rd party) listeners. A capture phase listener is used so that\n  // the 'dblclick' event can be ignored and not propagated ASAP.\n  element.addEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n    capture: true,\n  });\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport normalizeWheel from './normalizeWheel';\nimport Events from '../../enums/Events';\n// ~~ VIEWPORT LIBRARY\nimport getMouseEventPoints from '../mouse/getMouseEventPoints';\nimport { MouseWheelEventDetail } from '../../types/EventTypes';\n\n/**\n * wheelListener - Captures and normalizes mouse wheel events. Emits as a\n * cornerstoneTools3D mouse wheel event.\n * @param evt - The mouse wheel event.\n */\nfunction wheelListener(evt: WheelEvent) {\n  const element = <HTMLDivElement>evt.currentTarget;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  // Prevent triggering MouseWheel events that are not real scroll events:\n  // E.g. when clicking the MiddleMouseWheelButton, a deltaY of 0 is emitted.\n  // See https://github.com/cornerstonejs/cornerstoneTools/issues/935\n  if (evt.deltaY > -1 && evt.deltaY < 1) {\n    return;\n  }\n\n  evt.preventDefault();\n\n  const { spinX, spinY, pixelX, pixelY } = normalizeWheel(evt);\n  const direction = spinY < 0 ? -1 : 1;\n\n  const eventDetail: MouseWheelEventDetail = {\n    event: evt,\n    eventName: Events.MOUSE_WHEEL,\n    renderingEngineId,\n    viewportId,\n    element,\n    camera: {},\n    detail: evt,\n    wheel: {\n      spinX,\n      spinY,\n      pixelX,\n      pixelY,\n      direction,\n    },\n    points: getMouseEventPoints(evt),\n  };\n\n  triggerEvent(element, Events.MOUSE_WHEEL, eventDetail);\n}\n\nexport default wheelListener;\n","// Reasonable defaults\nconst PIXEL_STEP = 10;\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\n\n/**\n * Normalizes wheel events and provides properties that are more\n * consistent and helpful across different browsers\n *\n * @param event - the original mouse event\n * @returns a normalized eventDetail\n */\nexport default function normalizeWheel(event) {\n  let spinX = 0,\n    spinY = 0,\n    pixelX = 0,\n    pixelY = 0;\n\n  // Legacy\n  if ('detail' in event) {\n    spinY = event.detail;\n  }\n  if ('wheelDelta' in event) {\n    spinY = -event.wheelDelta / 120;\n  }\n  if ('wheelDeltaY' in event) {\n    spinY = -event.wheelDeltaY / 120;\n  }\n  if ('wheelDeltaX' in event) {\n    spinX = -event.wheelDeltaX / 120;\n  }\n\n  pixelX = spinX * PIXEL_STEP;\n  pixelY = spinY * PIXEL_STEP;\n\n  if ('deltaY' in event) {\n    pixelY = event.deltaY;\n  }\n  if ('deltaX' in event) {\n    pixelX = event.deltaX;\n  }\n\n  if ((pixelX || pixelY) && event.deltaMode) {\n    if (event.deltaMode === 1) {\n      // Delta in LINE units\n      pixelX *= LINE_HEIGHT;\n      pixelY *= LINE_HEIGHT;\n    } else {\n      // Delta in PAGE units\n      pixelX *= PAGE_HEIGHT;\n      pixelY *= PAGE_HEIGHT;\n    }\n  }\n\n  // Fall-back if spin cannot be determined\n  if (pixelX && !spinX) {\n    spinX = pixelX < 1 ? -1 : 1;\n  }\n  if (pixelY && !spinY) {\n    spinY = pixelY < 1 ? -1 : 1;\n  }\n\n  return {\n    spinX,\n    spinY,\n    pixelX,\n    pixelY,\n  };\n}\n","import wheelListener from './wheelListener';\n\n/**\n * Listens for the wheel event, and handles it. Handled event\n * will be \"normalized\" and re-emitted as `Events.MOUSE_WHEEL`\n *\n * @param element - The HTML element\n */\nfunction enable(element: HTMLDivElement) {\n  disable(element);\n  element.addEventListener('wheel', wheelListener, { passive: false });\n}\n\n/**\n * Removes listener and handler for wheel event. `Events.MOUSE_WHEEL`\n * will no longer be emitted.\n *\n * @param element - THe HTML element\n */\nfunction disable(element: HTMLDivElement) {\n  element.removeEventListener('wheel', wheelListener);\n}\n\nexport default {\n  enable,\n  disable,\n};\n","// Functions to prevent ghost clicks following a touch\n// Since the event lifecycle is touchstart, mousedown, touchend, mouseup\n// we want to prevent mousedown and mouseup events after touch events\n// All credit to @kosich\n// https://gist.github.com/kosich/23188dd86633b6c2efb7\n\nconst antiGhostDelay = 2000,\n  pointerType = {\n    mouse: 0,\n    touch: 1,\n  };\n\nlet lastInteractionType, lastInteractionTime;\n\nfunction handleTap(type, e) {\n  const now = Date.now();\n\n  if (type !== lastInteractionType) {\n    if (now - lastInteractionTime <= antiGhostDelay) {\n      e.preventDefault();\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n\n      return false;\n    }\n\n    lastInteractionType = type;\n  }\n\n  lastInteractionTime = now;\n}\n\n// Cacheing the function references\n// Necessary because a new function reference is created after .bind() is called\n// http://stackoverflow.com/questions/11565471/removing-event-listener-which-was-added-with-bind\nconst handleTapMouse = handleTap.bind(null, pointerType.mouse);\nconst handleTapTouch = handleTap.bind(null, pointerType.touch);\n\nfunction attachEvents(element, eventList, interactionType) {\n  const tapHandler = interactionType ? handleTapMouse : handleTapTouch;\n\n  eventList.forEach(function (eventName) {\n    element.addEventListener(eventName, tapHandler, { passive: false });\n  });\n}\n\nfunction removeEvents(element, eventList, interactionType) {\n  const tapHandler = interactionType ? handleTapMouse : handleTapTouch;\n\n  eventList.forEach(function (eventName) {\n    element.removeEventListener(eventName, tapHandler);\n  });\n}\n\nconst mouseEvents = ['mousedown', 'mouseup', 'mousemove'];\nconst touchEvents = ['touchstart', 'touchend'];\n\nfunction disable(element) {\n  removeEvents(element, mouseEvents, pointerType.mouse);\n  removeEvents(element, touchEvents, pointerType.touch);\n}\n\nfunction enable(element) {\n  disable(element);\n  attachEvents(element, mouseEvents, pointerType.mouse);\n  attachEvents(element, touchEvents, pointerType.touch);\n}\n\nexport default {\n  enable,\n  disable,\n};\n","enum Swipe {\n  UP = 'UP',\n  DOWN = 'DOWN',\n  LEFT = 'LEFT',\n  RIGHT = 'RIGHT',\n}\n\nexport { Swipe };\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { ITouchPoints } from '../../types';\n\n/**\n * Given a native touch event, get the associated cornerstone3D enabled element\n * and derive a set of coordinates useful for tools.\n * @param evt - The Touch event.\n * @param element - The DOM HTMLDivElement that the event was triggered on.\n * @returns The points related to the event in the form of a `IPoints` object containing\n * the following properties: `page`, `client`, `canvas`, and `world` details of the event.\n */\nexport default function getTouchEventPoints(\n  evt: TouchEvent,\n  element?: HTMLDivElement\n): ITouchPoints[] {\n  const elementToUse = element || (evt.currentTarget as HTMLDivElement);\n  const touches = evt.type === 'touchend' ? evt.changedTouches : evt.touches;\n  return Object.keys(touches).map((i) => {\n    const clientPoint = _clientToPoint(touches[i]);\n    const pagePoint = _pageToPoint(touches[i]);\n    const canvasPoint = _pagePointsToCanvasPoints(elementToUse, pagePoint);\n    const { viewport } = getEnabledElement(elementToUse);\n    const worldPoint = viewport.canvasToWorld(canvasPoint);\n    return {\n      page: pagePoint,\n      client: clientPoint,\n      canvas: canvasPoint,\n      world: worldPoint,\n      touch: {\n        identifier: i,\n        radiusX: touches[i].radiusX,\n        radiusY: touches[i].radiusY,\n        force: touches[i].force,\n        rotationAngle: touches[i].rotationAngle,\n      },\n    };\n  });\n}\n\n/**\n * Converts point from page coordinates to canvas coordinates.\n * @param element - HTMLDivElement\n * @param pagePoint - Point in page coordinates pageX and pageY\n *\n * @returns The canvas coordinate points\n */\nfunction _pagePointsToCanvasPoints(\n  element: HTMLDivElement,\n  pagePoint: Types.Point2\n): Types.Point2 {\n  const rect = element.getBoundingClientRect();\n  return [\n    pagePoint[0] - rect.left - window.pageXOffset,\n    pagePoint[1] - rect.top - window.pageYOffset,\n  ];\n}\n\n/**\n * Converts the event's `pageX` and `pageY` properties to Types.Point2 format\n *\n * @param touch - The Touch\n */\nfunction _pageToPoint(touch: Touch): Types.Point2 {\n  return [touch.pageX, touch.pageY];\n}\n\n/**\n * Converts the event's `clientX` and `clientY` properties to Types.Point2 format\n * @param evt - The Touch `Event`\n */\nfunction _clientToPoint(touch: Touch): Types.Point2 {\n  return [touch.clientX, touch.clientY];\n}\n","import { IDistance, IPoints, ITouchPoints } from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IPoints {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _subtractPoints2D(curr.page, last.page),\n    client: _subtractPoints2D(curr.client, last.client),\n    canvas: _subtractPoints2D(curr.canvas, last.canvas),\n    world: _subtractPoints3D(curr.world, last.world),\n  };\n}\n\n/**\n * Returns the distance between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The distance difference in IDistance format\n */\nfunction getDeltaDistance(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _getDistance2D(curr.page, last.page),\n    client: _getDistance2D(curr.client, last.client),\n    canvas: _getDistance2D(curr.canvas, last.canvas),\n    world: _getDistance3D(curr.world, last.world),\n  };\n}\n\nfunction getDeltaRotation(\n  currentPoints: ITouchPoints[],\n  lastPoints: ITouchPoints[]\n) {\n  // TODO\n}\n\n/**\n * Returns the distance difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints -- The last points.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaDistanceBetweenIPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);\n  const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);\n  const deltaDistance = {\n    page: currentDistance.page - lastDistance.page,\n    client: currentDistance.client - lastDistance.client,\n    canvas: currentDistance.canvas - lastDistance.canvas,\n    world: currentDistance.world - lastDistance.world,\n  };\n  return deltaDistance;\n}\n\n/**\n * Copies a set of points.\n * @param points - The `IPoints` instance to copy.\n *\n * @returns A copy of the points.\n */\nfunction copyPointsList(points: ITouchPoints[]): ITouchPoints[] {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction copyPoints(points: ITouchPoints): ITouchPoints {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction getMeanPoints(points: IPoints[]): IPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n    }\n  );\n}\n\nfunction getMeanTouchPoints(points: ITouchPoints[]): ITouchPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n        touch: {\n          identifier: null,\n          radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,\n          radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,\n          force: prev.touch.force + curr.touch.force / points.length,\n          rotationAngle:\n            prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,\n        },\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n      touch: {\n        identifier: null,\n        radiusX: 0,\n        radiusY: 0,\n        force: 0,\n        rotationAngle: 0,\n      },\n    }\n  );\n}\n/**\n * _subtractPoints - Subtracts `point1` from `point0`.\n * @param point0 - The first point.\n * @param point1 - The second point to subtract from the first.\n *\n * @returns The difference.\n */\nfunction _subtractPoints2D(\n  point0: Types.Point2,\n  point1: Types.Point2\n): Types.Point2 {\n  return [point0[0] - point1[0], point0[1] - point1[1]];\n}\n\nfunction _subtractPoints3D(\n  point0: Types.Point3,\n  point1: Types.Point3\n): Types.Point3 {\n  return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\n\nfunction _getMeanDistanceBetweenAllIPoints(points: IPoints[]): IDistance {\n  // get mean distance between all unordered pairs of points\n  const pairedDistance: IDistance[] = [];\n  for (let i = 0; i < points.length; i++) {\n    for (let j = 0; j < points.length; j++) {\n      if (i < j) {\n        pairedDistance.push({\n          page: _getDistance2D(points[i].page, points[j].page),\n          client: _getDistance2D(points[i].client, points[j].client),\n          canvas: _getDistance2D(points[i].canvas, points[j].canvas),\n          world: _getDistance3D(points[i].world, points[j].world),\n        });\n      }\n    }\n  }\n\n  // take the average distance\n  return pairedDistance.reduce(\n    (prev, curr) => {\n      return {\n        page: prev.page + curr.page / pairedDistance.length,\n        client: prev.client + curr.client / pairedDistance.length,\n        canvas: prev.canvas + curr.canvas / pairedDistance.length,\n        world: prev.world + curr.world / pairedDistance.length,\n      };\n    },\n    {\n      page: 0,\n      client: 0,\n      canvas: 0,\n      world: 0,\n    }\n  );\n}\n\nfunction _getDistance2D(point0: Types.Point2, point1: Types.Point2): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2)\n  );\n}\n\nfunction _getDistance3D(point0: Types.Point3, point1: Types.Point3): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) +\n      Math.pow(point0[1] - point1[1], 2) +\n      Math.pow(point0[2] - point1[2], 2)\n  );\n}\n\nexport {\n  getMeanPoints,\n  getMeanTouchPoints,\n  copyPoints,\n  copyPointsList,\n  getDeltaDistanceBetweenIPoints,\n  getDeltaPoints,\n  getDeltaDistance,\n  getDeltaRotation,\n};\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport { Swipe } from '../../enums/Touch';\n\nimport { EventTypes, ITouchPoints, IPoints, IDistance } from '../../types';\n\nimport getTouchEventPoints from './getTouchEventPoints';\nimport {\n  copyPoints,\n  copyPointsList,\n  getDeltaDistanceBetweenIPoints,\n  getDeltaDistance,\n  getDeltaPoints,\n  getMeanTouchPoints,\n  // getRotation\n} from '../../utilities/touch';\nimport { Settings } from '@cornerstonejs/core';\n\nconst runtimeSettings = Settings.getRuntimeSettings();\n\nconst {\n  TOUCH_START,\n  TOUCH_START_ACTIVATE,\n  TOUCH_PRESS,\n  TOUCH_DRAG,\n  TOUCH_END,\n  TOUCH_TAP,\n  TOUCH_SWIPE,\n} = Events;\n\ninterface ITouchTapListenerState {\n  element: HTMLDivElement;\n  renderingEngineId: string;\n  viewportId: string;\n  startPointsList: ITouchPoints[];\n  tapMaxDistance: number;\n  tapTimeout: ReturnType<typeof setTimeout>;\n  taps: number;\n  tapToleranceMs: number;\n}\n\ninterface ITouchStartListenerState {\n  element: HTMLDivElement;\n  renderingEngineId: string;\n  viewportId: string;\n  startPointsList: ITouchPoints[];\n  lastPointsList: ITouchPoints[];\n\n  // only trigger one touch event in the case the user puts down multiple fingers\n  isTouchStart: boolean;\n  startTime: Date;\n\n  // handle long press\n  pressTimeout: ReturnType<typeof setTimeout>;\n  pressDelay: number;\n  pressMaxDistance: number;\n  accumulatedDistance: IDistance;\n\n  // handle swipes\n  swipeDistanceThreshold: number;\n  swiped: boolean;\n  swipeToleranceMs: number;\n}\n\nconst zeroIPoint: IPoints = {\n  page: [0, 0],\n  client: [0, 0],\n  canvas: [0, 0],\n  world: [0, 0, 0],\n};\n\nconst zeroIDistance: IDistance = {\n  page: 0,\n  client: 0,\n  canvas: 0,\n  world: 0,\n};\n\n// STATE\nconst defaultState: ITouchStartListenerState = {\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  element: null,\n  startPointsList: [\n    {\n      ...zeroIPoint,\n      touch: null,\n    },\n  ],\n  lastPointsList: [\n    {\n      ...zeroIPoint,\n      touch: null,\n    },\n  ],\n  isTouchStart: false,\n  startTime: null,\n\n  pressTimeout: null,\n  pressDelay: 700,\n  pressMaxDistance: 5,\n  accumulatedDistance: zeroIDistance,\n\n  swipeDistanceThreshold: 48,\n  swiped: false,\n  swipeToleranceMs: 300, // user has 300ms to swipe after touch start or no swipe will trigger\n};\n\n// TODO: these values should be configurable to handle different use cases such\n// as pen, left/right handed, index finger vs thumb, etc. These current values\n// assume thumb usage for single finger and index/middle finger for two finger\n// gestures in an attempt to cover the 90% use case.\nconst defaultTapState: ITouchTapListenerState = {\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  element: null,\n  startPointsList: [\n    {\n      ...zeroIPoint,\n      touch: null,\n    },\n  ],\n  taps: 0,\n  tapTimeout: null,\n  tapMaxDistance: 24,\n  tapToleranceMs: 300,\n};\n\nlet state: ITouchStartListenerState = JSON.parse(JSON.stringify(defaultState));\nlet tapState: ITouchTapListenerState = JSON.parse(\n  JSON.stringify(defaultTapState)\n);\n\nfunction triggerEventCallback(ele, name, eventDetail) {\n  return triggerEvent(ele, name, eventDetail);\n}\n\n/**\n * Listens to touch events from the DOM (touchstart, touchmove, touchend)\n * and depending on interaction and further interaction can emit the\n * following touch events:\n *\n * - TOUCH_START\n * - TOUCH_START_ACTIVATE\n * - TOUCH_PRESS\n * - TOUCH_DRAG (move while down)\n * - TOUCH_SWIPE\n * - TOUCH_END (also an end for multi touch)\n *\n * - TOUCH_TAP\n *\n * @param evt - The Touch event (touchstart).\n * @private\n */\nfunction touchStartListener(evt: TouchEvent) {\n  // if a user adds an extra finger when a touch/multi touch has already started\n  // don't trigger another touch.\n  state.element = <HTMLDivElement>evt.currentTarget;\n  const enabledElement = getEnabledElement(state.element);\n  const { renderingEngineId, viewportId } = enabledElement;\n  state.renderingEngineId = renderingEngineId;\n  state.viewportId = viewportId;\n  // this prevents multiple start firing\n  if (state.isTouchStart) {\n    return;\n  }\n  // this will clear on touchstart and touchend\n  clearTimeout(state.pressTimeout);\n  state.pressTimeout = setTimeout(() => _onTouchPress(evt), state.pressDelay);\n\n  _onTouchStart(evt);\n  document.addEventListener('touchmove', _onTouchDrag); // also checks for swipe\n  document.addEventListener('touchend', _onTouchEnd); // also checks for tap\n}\n\n/**\n * _onTouchPress - Handle emission of touchstart events which are held down for a longer\n * period of time\n *\n * @private\n * @param evt - The touch event (touchstart)\n */\nfunction _onTouchPress(evt: TouchEvent) {\n  const totalDistance = state.accumulatedDistance.canvas;\n  if (totalDistance > state.pressMaxDistance) {\n    return;\n  }\n  const eventDetail: EventTypes.TouchPressEventDetail = {\n    event: evt, // touchstart native event\n    eventName: TOUCH_PRESS,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    startPointsList: copyPointsList(state.startPointsList),\n    lastPointsList: copyPointsList(state.lastPointsList),\n    startPoints: copyPoints(getMeanTouchPoints(state.startPointsList)),\n    lastPoints: copyPoints(getMeanTouchPoints(state.lastPointsList)),\n  };\n  triggerEventCallback(eventDetail.element, TOUCH_PRESS, eventDetail);\n}\n\n/**\n * _onTouchStart - Handle emission of touchstart events.\n *\n * @private\n * @param evt - The touch event (touchstart)\n */\nfunction _onTouchStart(evt: TouchEvent) {\n  state.isTouchStart = true;\n  state.startTime = new Date();\n  const startPointsList = getTouchEventPoints(evt, state.element);\n  const startPoints = getMeanTouchPoints(startPointsList);\n  const deltaPoints = zeroIPoint;\n  const deltaDistance = zeroIDistance;\n  // deltaRotation same as deltaDistance but values are theta\n  const eventDetail: EventTypes.TouchStartEventDetail = {\n    event: evt,\n    eventName: TOUCH_START,\n    element: state.element,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    startPointsList: startPointsList,\n    lastPointsList: startPointsList,\n    currentPointsList: startPointsList,\n    startPoints: startPoints,\n    lastPoints: startPoints,\n    currentPoints: startPoints,\n    deltaPoints,\n    deltaDistance,\n    // deltaRotation\n  };\n\n  state.startPointsList = copyPointsList(eventDetail.startPointsList);\n  state.lastPointsList = copyPointsList(eventDetail.lastPointsList);\n  // by triggering TOUCH_START it checks if this is toolSelection, handle modification etc.\n  // of already existing tools\n  const eventDidPropagate = triggerEventCallback(\n    eventDetail.element,\n    TOUCH_START,\n    eventDetail\n  );\n\n  // if no tools responded to this event and prevented its default propagation behavior,\n  // create a new tool\n  if (eventDidPropagate) {\n    triggerEventCallback(\n      eventDetail.element,\n      TOUCH_START_ACTIVATE,\n      eventDetail\n    );\n  }\n}\n\n/**\n * _onTouchDrag - Handle emission of drag events whilst the touch is depressed.\n *\n * @private\n * @param evt - The touch event (touchmove)\n */\nfunction _onTouchDrag(evt: TouchEvent) {\n  const currentPointsList = getTouchEventPoints(evt, state.element);\n  const lastPointsList = _updateTouchEventsLastPoints(\n    state.element,\n    state.lastPointsList\n  );\n\n  const deltaPoints =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaPoints(currentPointsList, lastPointsList)\n      : zeroIPoint;\n\n  const deltaDistance =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaDistanceBetweenIPoints(currentPointsList, lastPointsList)\n      : zeroIDistance;\n\n  const totalDistance =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaDistance(currentPointsList, state.lastPointsList)\n      : zeroIDistance;\n\n  state.accumulatedDistance = {\n    page: state.accumulatedDistance.page + totalDistance.page,\n    client: state.accumulatedDistance.client + totalDistance.client,\n    canvas: state.accumulatedDistance.canvas + totalDistance.canvas,\n    world: state.accumulatedDistance.world + totalDistance.world,\n  };\n\n  /**\n   * this is can be uncommented to make dragging smoother. In the future, these values\n   * should be in a configuration file. There may also need to be different\n   * profiles for left handed and right handed thumb use. These values\n   * are currently optimized for left handed use.\n   *\n   * const clamp = (num) => Math.min(Math.max(num, -15), 10);\n   * const deltaDistanceClamped = \\{\n   *     page: clamp(deltaDistance.page),\n   *     client: clamp(deltaDistance.client),\n   *     canvas: clamp(deltaDistance.canvas),\n   *     world: clamp(deltaDistance.world),\n   * \\};\n   */\n\n  const eventDetail: EventTypes.TouchDragEventDetail = {\n    event: evt,\n    eventName: TOUCH_DRAG,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    startPoints: getMeanTouchPoints(state.startPointsList),\n    lastPoints: getMeanTouchPoints(lastPointsList),\n    currentPoints: getMeanTouchPoints(currentPointsList),\n    startPointsList: copyPointsList(state.startPointsList),\n    lastPointsList: copyPointsList(lastPointsList),\n    currentPointsList,\n    deltaPoints: deltaPoints,\n    deltaDistance: deltaDistance,\n  };\n\n  triggerEventCallback(state.element, TOUCH_DRAG, eventDetail);\n\n  // check for swipe events\n  _checkTouchSwipe(evt, deltaPoints);\n\n  // Update the last points\n  state.lastPointsList = copyPointsList(currentPointsList);\n}\n\n/**\n * _onTouchEnd - Handle emission of touch end events\n *\n * @private\n * @param evt - The touch event.\n */\nfunction _onTouchEnd(evt: TouchEvent): void {\n  // in case it was a tap event we don't want to fire the cornerstone normalized\n  // touch end event if the touch start never happend\n  clearTimeout(state.pressTimeout);\n  const currentPointsList = getTouchEventPoints(evt, state.element);\n  const lastPointsList = _updateTouchEventsLastPoints(\n    state.element,\n    state.lastPointsList\n  );\n  const deltaPoints =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaPoints(currentPointsList, lastPointsList)\n      : getDeltaPoints(currentPointsList, currentPointsList);\n  const deltaDistance =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaDistanceBetweenIPoints(currentPointsList, lastPointsList)\n      : getDeltaDistanceBetweenIPoints(currentPointsList, currentPointsList);\n  const eventDetail: EventTypes.TouchEndEventDetail = {\n    event: evt,\n    eventName: TOUCH_END,\n    element: state.element,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    startPointsList: copyPointsList(state.startPointsList),\n    lastPointsList: copyPointsList(lastPointsList),\n    currentPointsList,\n    startPoints: getMeanTouchPoints(state.startPointsList),\n    lastPoints: getMeanTouchPoints(lastPointsList),\n    currentPoints: getMeanTouchPoints(currentPointsList),\n    deltaPoints,\n    deltaDistance,\n  };\n\n  triggerEventCallback(eventDetail.element, TOUCH_END, eventDetail);\n  _checkTouchTap(evt);\n\n  // reset to default state\n  state = JSON.parse(JSON.stringify(defaultState));\n  document.removeEventListener('touchmove', _onTouchDrag);\n  document.removeEventListener('touchend', _onTouchEnd);\n}\n\nfunction _checkTouchTap(evt: TouchEvent): void {\n  const currentTime = new Date().getTime();\n  const startTime = state.startTime.getTime();\n  if (currentTime - startTime > tapState.tapToleranceMs) {\n    return;\n  }\n\n  // first tap, initialize the state\n  if (tapState.taps === 0) {\n    tapState.element = state.element;\n    tapState.renderingEngineId = state.renderingEngineId;\n    tapState.viewportId = state.viewportId;\n    tapState.startPointsList = state.startPointsList;\n  }\n\n  // subsequent tap is on a different element\n  if (\n    tapState.taps > 0 &&\n    !(\n      tapState.element == state.element &&\n      tapState.renderingEngineId == state.renderingEngineId &&\n      tapState.viewportId == state.viewportId\n    )\n  ) {\n    return;\n  }\n\n  const currentPointsList = getTouchEventPoints(evt, tapState.element);\n  const distanceFromStart = getDeltaDistance(\n    currentPointsList,\n    tapState.startPointsList\n  ).canvas;\n\n  // if the tap is too far from starting tap, we can ignore it.\n  // TODO: in the case the user means to tap in two separate areas within the\n  // tapTolerance (300ms), the second tap will not trigger. This is because it\n  // is ignored below for simplicity to track multiple taps (double, triple etc)\n  // in order to support two separate single taps that occur < 300ms on the\n  // screen. One can create the concept of \"TapChains\". Our current implementation\n  // only supports a single tap chain on the screen. You can think of it as a\n  // region where the user has the option to perform unlimited multitaps as long\n  // as they are < the tapToleranceMs value. So a tap somewhere else on the screen\n  // that is > the tapMaxDistance will start a separate and new \"TapChain\".\n  if (distanceFromStart > tapState.tapMaxDistance) {\n    return;\n  }\n\n  clearTimeout(tapState.tapTimeout);\n  tapState.taps += 1;\n\n  tapState.tapTimeout = setTimeout(() => {\n    const eventDetail: EventTypes.TouchTapEventDetail = {\n      event: evt,\n      eventName: TOUCH_TAP,\n      element: tapState.element,\n      renderingEngineId: tapState.renderingEngineId,\n      viewportId: tapState.viewportId,\n      camera: {},\n      currentPointsList,\n      currentPoints: getMeanTouchPoints(currentPointsList),\n      taps: tapState.taps,\n    };\n    triggerEventCallback(eventDetail.element, TOUCH_TAP, eventDetail);\n    tapState = JSON.parse(JSON.stringify(defaultTapState));\n  }, tapState.tapToleranceMs);\n}\n\nfunction _checkTouchSwipe(evt: TouchEvent, deltaPoints: IPoints) {\n  const currentTime = new Date().getTime();\n  const startTime = state.startTime.getTime();\n  if (state.swiped || currentTime - startTime > state.swipeToleranceMs) {\n    return;\n  }\n  const [x, y] = deltaPoints.canvas;\n  const eventDetail: EventTypes.TouchSwipeEventDetail = {\n    event: evt,\n    eventName: TOUCH_SWIPE,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    swipe: null,\n  };\n  if (Math.abs(x) > state.swipeDistanceThreshold) {\n    eventDetail.swipe = x > 0 ? Swipe.RIGHT : Swipe.LEFT;\n    triggerEventCallback(eventDetail.element, TOUCH_SWIPE, eventDetail);\n    state.swiped = true;\n  }\n\n  if (Math.abs(y) > state.swipeDistanceThreshold) {\n    eventDetail.swipe = y > 0 ? Swipe.DOWN : Swipe.UP;\n    triggerEventCallback(eventDetail.element, TOUCH_SWIPE, eventDetail);\n    state.swiped = true;\n  }\n}\n\n/**\n * Recalculates the last world coordinate, as the linear transform from client\n * to world could be different if the camera was updated.\n * @param element - The HTML element\n * @param lastPoints - The last points\n */\nfunction _updateTouchEventsLastPoints(\n  element: HTMLDivElement,\n  lastPoints: ITouchPoints[]\n): ITouchPoints[] {\n  const { viewport } = getEnabledElement(element);\n  // Need to update the world point to be calculated from the current reference frame,\n  // Which might have changed since the last interaction.\n  return lastPoints.map((lp) => {\n    const world = viewport.canvasToWorld(lp.canvas);\n    return {\n      page: lp.page,\n      client: lp.client,\n      canvas: lp.canvas,\n      world,\n      touch: lp.touch,\n    };\n  });\n}\n\nexport default touchStartListener;\n","import preventGhostClick from './preventGhostClick';\nimport touchStartListener from './touchStartListener';\n\n/**\n * Removes touch event listeners for native touch event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to remove event listeners from.\n */\nfunction disable(element: HTMLDivElement): void {\n  preventGhostClick.disable(element);\n  element.removeEventListener('touchstart', touchStartListener);\n}\n\n/**\n * Registers touch event listeners for native touch event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to register event listeners on.\n */\nfunction enable(element: HTMLDivElement): void {\n  // Prevent handlers from being attached multiple times\n  disable(element);\n  preventGhostClick.enable(element);\n  element.addEventListener('touchstart', touchStartListener, {\n    passive: false,\n  });\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport cloneDeep from 'lodash.clonedeep';\nimport Events from '../../enums/Events';\nimport { KeyDownEventDetail, KeyUpEventDetail } from '../../types/EventTypes';\n\ninterface IKeyDownListenerState {\n  renderingEngineId: string;\n  viewportId: string;\n  key: string | null;\n  keyCode: number | null;\n  element: HTMLDivElement;\n}\n\nconst defaultState: IKeyDownListenerState = {\n  //\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  key: undefined,\n  keyCode: undefined,\n  element: null,\n};\n\nlet state: IKeyDownListenerState = {\n  //\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  key: undefined,\n  keyCode: undefined,\n  element: null,\n};\n\n/**\n * Normalizes the keyboard event and triggers KEY_DOWN event from CornerstoneTools3D events\n * @param evt - DOM Keyboard event\n */\nfunction keyListener(evt: KeyboardEvent): void {\n  state.element = <HTMLDivElement>evt.currentTarget;\n\n  const enabledElement = getEnabledElement(state.element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  state.renderingEngineId = renderingEngineId;\n  state.viewportId = viewportId;\n  state.key = evt.key;\n  state.keyCode = evt.keyCode;\n\n  evt.preventDefault();\n  const eventDetail: KeyDownEventDetail = {\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    element: state.element,\n    key: state.key,\n    keyCode: state.keyCode,\n\n    // detail: evt,\n    // Todo: mouse event points can be used later for placing tools with a key\n    // e.g., putting an arrow/probe/etc. on the mouse position. Another use case\n    // hovering and deleting the tool\n    // points: getMouseEventPoints(evt),\n  };\n\n  triggerEvent(eventDetail.element, Events.KEY_DOWN, eventDetail);\n\n  document.addEventListener('keyup', _onKeyUp);\n  document.addEventListener('visibilitychange', _onVisibilityChange);\n\n  // Todo: handle combination of keys\n  state.element.removeEventListener('keydown', keyListener);\n}\n\n/**\n * Whenever the visibility (i.e. tab focus) changes such that the tab is NOT the\n * active tab, reset the modifier key.\n */\nfunction _onVisibilityChange(): void {\n  document.removeEventListener('visibilitychange', _onVisibilityChange);\n  if (document.visibilityState === 'hidden') {\n    resetModifierKey();\n  }\n}\n\nfunction _onKeyUp(evt: KeyboardEvent): void {\n  const eventDetail: KeyUpEventDetail = {\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    element: state.element,\n    key: state.key,\n    keyCode: state.keyCode,\n    // detail: evt,\n  };\n\n  // Remove our temporary handlers\n  document.removeEventListener('keyup', _onKeyUp);\n  document.removeEventListener('visibilitychange', _onVisibilityChange);\n  state.element.addEventListener('keydown', keyListener);\n\n  // Restore `state` to `defaultState`\n  state = cloneDeep(defaultState);\n  triggerEvent(eventDetail.element, Events.KEY_UP, eventDetail);\n}\n\nexport function getModifierKey(): number | undefined {\n  return state.keyCode;\n}\n\nexport function resetModifierKey(): void {\n  state.keyCode = undefined;\n}\n\nexport default keyListener;\n","import keyDownListener, { getModifierKey } from './keyDownListener';\n\nfunction enable(element: HTMLDivElement): void {\n  disable(element);\n  element.addEventListener('keydown', keyDownListener);\n}\n\nfunction disable(element: HTMLDivElement): void {\n  element.removeEventListener('keydown', keyDownListener);\n}\n\nexport default {\n  enable,\n  disable,\n  getModifierKey,\n};\n","import { getRenderingEngines } from '@cornerstonejs/core';\nimport { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Given a rendering engine Id and a viewport Id, return the tool group that\n * contains that rendering engine and viewport. Note: A viewport can only be\n * associated with a single tool group. You cannot have a viewport that belongs\n * to multiple tool groups. To achieve so, create a new viewport and a new toolGroup\n * for it. This will not impact memory usage much as the volume textures are\n * shared across all viewports rendering the same image.\n *\n * @param viewportId - The Id of the viewport that the tool is being\n * added to.\n * @param renderingEngineId - The Id of the rendering engine that the\n * tool group is associated with.\n * @returns A tool group.\n */\nfunction getToolGroupForViewport(\n  viewportId: string,\n  renderingEngineId?: string\n): IToolGroup | undefined {\n  if (!renderingEngineId) {\n    renderingEngineId = getRenderingEngines().find((re) =>\n      re.getViewports().find((vp) => vp.id === viewportId)\n    )?.id;\n  }\n\n  const toolGroupFilteredByIds = state.toolGroups.filter((tg) =>\n    tg.viewportsInfo.some(\n      (vp) =>\n        vp.renderingEngineId === renderingEngineId &&\n        (!vp.viewportId || vp.viewportId === viewportId)\n    )\n  );\n\n  if (!toolGroupFilteredByIds.length) {\n    return;\n  }\n\n  if (toolGroupFilteredByIds.length > 1) {\n    throw new Error(\n      `Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only\n      have one tool group per viewport in a renderingEngine.`\n    );\n  }\n\n  return toolGroupFilteredByIds[0];\n}\n\nexport default getToolGroupForViewport;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Given a tool group Id, return the tool group\n * @param toolGroupId - The Id of the tool group to be retrieved.\n * @returns The tool group that has the same id as the tool group id that was\n * passed in.\n */\nfunction getToolGroup(toolGroupId: string): IToolGroup | undefined {\n  return state.toolGroups.find((s) => s.id === toolGroupId);\n}\n\nexport default getToolGroup;\n","import SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\n\nimport {\n  RepresentationConfig,\n  SegmentationRepresentationConfig,\n  SegmentSpecificRepresentationConfig,\n} from '../../../types/SegmentationStateTypes';\n\n/**\n * It returns the global segmentation config.\n * @returns The global segmentation config containing the representations\n * config for each representation type and renderInactiveSegmentations flag.\n */\nfunction getGlobalConfig(): SegmentationRepresentationConfig {\n  return SegmentationState.getGlobalConfig();\n}\n\n/**\n * Set the global segmentation config\n * @param segmentationConfig - SegmentationConfig\n */\nfunction setGlobalConfig(\n  segmentationConfig: SegmentationRepresentationConfig\n): void {\n  SegmentationState.setGlobalConfig(segmentationConfig);\n}\n\n/**\n * Given a representation type, return the corresponding global representation config\n * @param representationType - The type of representation to query\n * @returns A representation configuration object.\n */\nfunction getGlobalRepresentationConfig(\n  representationType: SegmentationRepresentations\n): RepresentationConfig['LABELMAP'] {\n  const globalConfig = getGlobalConfig();\n  return globalConfig.representations[representationType];\n}\n\n/**\n * Set the global configuration for a given representation type. It fires\n * a SEGMENTATION_MODIFIED event.\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param representationType - The type of representation to set config for\n * @param config - The configuration for the representation.\n */\nfunction setGlobalRepresentationConfig(\n  representationType: SegmentationRepresentations,\n  config: RepresentationConfig['LABELMAP']\n): void {\n  const globalConfig = getGlobalConfig();\n\n  setGlobalConfig({\n    ...globalConfig,\n    representations: {\n      ...globalConfig.representations,\n      [representationType]: {\n        ...globalConfig.representations[representationType],\n        ...config,\n      },\n    },\n  });\n}\n\n/**\n * Get the toolGroup specific segmentation config\n * @param toolGroupId - The Id of the tool group\n * @returns A SegmentationConfig object.\n */\nfunction getToolGroupSpecificConfig(\n  toolGroupId: string\n): SegmentationRepresentationConfig {\n  return SegmentationState.getToolGroupSpecificConfig(toolGroupId);\n}\n\n/**\n * Sets the tool group specific configuration for the segmentation\n * representation. This will apply to all segmentation representations.\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationConfig - This is the configuration object that you will use to set the default values for\n * the segmentation representation.\n */\nfunction setToolGroupSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationConfig: SegmentationRepresentationConfig\n): void {\n  SegmentationState.setToolGroupSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationConfig\n  );\n}\n\n/**\n * Give the segmentation representation UID, return the corresponding config\n * which is shared by all segments in the segmentation representation. This is\n * an optional level of configuration that can be set by the user, by default\n * it will fallback to the toolGroup specific config, if not set, it will fallback\n * to the global config.\n *\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param config - The configuration for the representation. This is an object\n * only containing the representation type as key and the config as value.\n * @returns - The configuration for the representation.\n */\nfunction getSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): RepresentationConfig {\n  return SegmentationState.getSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Set the segmentation representation specific configuration for the\n * segmentation representation. This will apply to all segments in the\n * segmentation representation and has higher priority than the toolGroup\n * specific config.\n *\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param config - The configuration for the representation. This is an object\n * only containing the representation type as key and the config as value.\n */\nfunction setSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: RepresentationConfig\n): void {\n  SegmentationState.setSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n}\n\n/**\n * Get the segment specific configuration for the segmentation representation.\n *\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationUID  - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment\n * @returns - The configuration for the segment index in the segmentation representation that is shown in the toolGroup's viewport\n */\nfunction getSegmentSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): RepresentationConfig {\n  return SegmentationState.getSegmentSpecificRepresentationConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n}\n\n/**\n * Set the segment specific configuration for the segmentation representation.\n * This configuration, if specified, has higher priority than the segmentation representation specific config,\n * and the toolGroup specific config. The order of priority is: segment specific config > segmentation representation specific config > toolGroup specific config > global config\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment\n * @param config - The configuration for the representation. This is an object\n */\nfunction setSegmentSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: SegmentSpecificRepresentationConfig\n): void {\n  SegmentationState.setSegmentSpecificRepresentationConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n}\n\nexport {\n  // Global\n  getGlobalConfig,\n  setGlobalConfig,\n  getGlobalRepresentationConfig,\n  setGlobalRepresentationConfig,\n  // ToolGroup Specific\n  getToolGroupSpecificConfig,\n  setToolGroupSpecificConfig,\n  // segmentation representation specific config\n  getSegmentationRepresentationSpecificConfig,\n  setSegmentationRepresentationSpecificConfig,\n  // segment specific config\n  getSegmentSpecificConfig,\n  setSegmentSpecificConfig,\n};\n","import * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getSegmentationRepresentations } from '../../../stateManagement/segmentation/segmentationState';\nimport { ToolGroupSpecificRepresentation } from '../../../types/SegmentationStateTypes';\nimport { getUniqueSegmentIndices } from '../../../utilities/segmentation';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\n\n/**\n * Set the visibility of a segmentation representation for a given tool group. It fires\n * a SEGMENTATION_REPRESENTATION_MODIFIED event. Visibility true will show all segments\n * and visibility false will hide all segments\"\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n * @param toolGroupId - The Id of the tool group that contains the segmentation.\n * @param segmentationRepresentationUID - The id of the segmentation representation to modify its visibility.\n * @param visibility - boolean\n */\nfunction setSegmentationVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  visibility: boolean\n): void {\n  const toolGroupSegmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  if (!toolGroupSegmentationRepresentations) {\n    return;\n  }\n\n  const representation = toolGroupSegmentationRepresentations.find(\n    (representation: ToolGroupSpecificRepresentation) =>\n      representation.segmentationRepresentationUID ===\n      segmentationRepresentationUID\n  );\n\n  if (!representation) {\n    return;\n  }\n\n  const { segmentsHidden, segmentationId } = representation;\n\n  const indices = getUniqueSegmentIndices(segmentationId);\n\n  // if visibility is set to be true, we need to remove all the segments\n  // from the segmentsHidden set, otherwise we need to add all the segments\n  // to the segmentsHidden set\n  if (visibility) {\n    segmentsHidden.clear();\n  } else {\n    indices.forEach((index) => {\n      segmentsHidden.add(index);\n    });\n  }\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    representation.segmentationRepresentationUID\n  );\n}\n\n/**\n * Get the visibility of a segmentation data for a given tool group.\n *\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The id of the segmentation data to get\n * @returns A boolean value that indicates whether the segmentation data is visible or\n * not on the toolGroup\n */\nfunction getSegmentationVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): boolean | undefined {\n  const toolGroupSegmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  const representation = toolGroupSegmentationRepresentations.find(\n    (representation: ToolGroupSpecificRepresentation) =>\n      representation.segmentationRepresentationUID ===\n      segmentationRepresentationUID\n  );\n\n  if (!representation) {\n    return;\n  }\n\n  const { segmentsHidden, segmentationId } = representation;\n  const indices = getUniqueSegmentIndices(segmentationId);\n\n  // Create a set that contains all segments indices\n  const indicesSet = new Set(indices);\n\n  // Remove a indices that are hidden\n  segmentsHidden.forEach((segmentIndex) => indicesSet.delete(segmentIndex));\n\n  // Check if there is at least one segment visible\n  return !!indicesSet.size;\n}\n\n/**\n * Set the visibility of the given segment indices to the given visibility. This\n * is a helper to set the visibility of multiple segments at once and reduces\n * the number of events fired.\n *\n * @param toolGroupId -  The tool group id of the segmentation representation.\n * @param segmentationRepresentationUID -  The UID of the segmentation\n * representation.\n * @param segmentIndices -  The indices of the segments to be hidden/shown.\n * @param visibility -  The visibility to set the segments to.\n *\n */\nfunction setSegmentsVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndices: number[],\n  visibility: boolean\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    return;\n  }\n\n  segmentIndices.forEach((segmentIndex) => {\n    visibility\n      ? segRepresentation.segmentsHidden.delete(segmentIndex)\n      : segRepresentation.segmentsHidden.add(segmentIndex);\n  });\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * @param toolGroupId - The Id of the tool group that contains the segmentation\n * @param segmentationRepresentationUID - The id of the segmentation representation that contains the segment\n * @param segmentIndex - Index of the segment that will be updated\n * @param visibility - True to show the segment or false to hide it\n * @returns True if the segment is visible or false otherwise\n */\nfunction setSegmentVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number,\n  visibility: boolean\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    return;\n  }\n\n  visibility\n    ? segRepresentation.segmentsHidden.delete(segmentIndex)\n    : segRepresentation.segmentsHidden.add(segmentIndex);\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * @param toolGroupId - The Id of the tool group that contains the segmentation.\n * @param segmentationRepresentationUID - The id of the segmentation representation to modify its visibility.\n * @param segmentIndex - Index of the segment\n * @returns True if the segment is visible or false otherwise\n */\nfunction getSegmentVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): boolean {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    return false;\n  }\n\n  return !segRepresentation.segmentsHidden.has(segmentIndex);\n}\n\nexport {\n  setSegmentationVisibility,\n  getSegmentationVisibility,\n  setSegmentVisibility,\n  setSegmentsVisibility,\n  getSegmentVisibility,\n};\n","import { utilities, BaseVolumeViewport } from '@cornerstonejs/core';\nimport { Types } from '@cornerstonejs/core';\nimport ToolModes from '../../enums/ToolModes';\nimport StrategyCallbacks from '../../enums/StrategyCallbacks';\nimport { InteractionTypes, ToolProps, PublicToolProps } from '../../types';\n\nexport interface IBaseTool {\n  /** ToolGroup ID the tool instance belongs to */\n  toolGroupId: string;\n  /** Tool supported interaction types */\n  supportedInteractionTypes: InteractionTypes[];\n  /** Tool Mode : Active, Passive, Enabled, Disabled */\n  mode: ToolModes;\n  /** Tool Configuration */\n  configuration: {\n    preventHandleOutsideImage?: boolean;\n    strategies?: Record<string, any>;\n    defaultStrategy?: string;\n    activeStrategy?: string;\n    strategyOptions?: Record<string, unknown>;\n  };\n}\n\n/**\n * Abstract base class from which all tools derive.\n * Deals with cleanly merging custom and default configuration, and strategy\n * application.\n */\nabstract class BaseTool implements IBaseTool {\n  static toolName;\n  /** Supported Interaction Types - currently only Mouse */\n  public supportedInteractionTypes: InteractionTypes[];\n  public configuration: Record<string, any>;\n  /** ToolGroup ID the tool instance belongs to */\n  public toolGroupId: string;\n  /** Tool Mode - Active/Passive/Enabled/Disabled/ */\n  public mode: ToolModes;\n\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    const initialProps = utilities.deepMerge(defaultToolProps, toolProps);\n\n    const {\n      configuration = {},\n      supportedInteractionTypes,\n      toolGroupId,\n    } = initialProps;\n\n    // If strategies are not initialized in the tool config\n    if (!configuration.strategies) {\n      configuration.strategies = {};\n      configuration.defaultStrategy = undefined;\n      configuration.activeStrategy = undefined;\n      configuration.strategyOptions = {};\n    }\n\n    this.toolGroupId = toolGroupId;\n    this.supportedInteractionTypes = supportedInteractionTypes || [];\n    this.configuration = Object.assign({}, configuration);\n    this.mode = ToolModes.Disabled;\n  }\n\n  /**\n   * Returns the name of the tool\n   * @returns The name of the tool.\n   */\n  public getToolName(): string {\n    // Since toolName is static we get it from the class constructor\n    return (<typeof BaseTool>this.constructor).toolName;\n  }\n\n  /**\n   * Applies the active strategy function to the enabled element with the specified\n   * operation data.\n   * @param enabledElement - The element that is being operated on.\n   * @param operationData - The data that needs to be passed to the strategy.\n   * @returns The result of the strategy.\n   */\n  public applyActiveStrategy(\n    enabledElement: Types.IEnabledElement,\n    operationData: unknown\n  ): any {\n    const { strategies, activeStrategy } = this.configuration;\n    return strategies[activeStrategy]?.call(\n      this,\n      enabledElement,\n      operationData\n    );\n  }\n\n  /**\n   * Applies the active strategy, with a given event type being applied.\n   * The event type function is found by indexing it on the active strategy\n   * function.\n   *\n   * @param enabledElement - The element that is being operated on.\n   * @param operationData - The data that needs to be passed to the strategy.\n   * @param callbackType - the type of the callback\n   *\n   * @returns The result of the strategy.\n   */\n  public applyActiveStrategyCallback(\n    enabledElement: Types.IEnabledElement,\n    operationData: unknown,\n    callbackType: StrategyCallbacks | string\n  ): any {\n    const { strategies, activeStrategy } = this.configuration;\n\n    if (!strategies[activeStrategy]) {\n      throw new Error(\n        `applyActiveStrategyCallback: active strategy ${activeStrategy} not found, check tool configuration or spellings`\n      );\n    }\n\n    return strategies[activeStrategy][callbackType]?.call(\n      this,\n      enabledElement,\n      operationData\n    );\n  }\n\n  /**\n   * merges the new configuration with the tool configuration\n   * @param configuration - toolConfiguration\n   */\n  public setConfiguration(newConfiguration: Record<string, any>): void {\n    this.configuration = utilities.deepMerge(\n      this.configuration,\n      newConfiguration\n    );\n  }\n\n  /**\n   * Sets the active strategy for a tool. Strategies are\n   * multiple implementations of tool behavior that can be switched by tool\n   * configuration.\n   *\n   * @param strategyName - name of the strategy to be set as active\n   */\n  public setActiveStrategy(strategyName: string): void {\n    this.setConfiguration({ activeStrategy: strategyName });\n  }\n\n  /**\n   * Returns the volumeId for the volume viewport. It will grabbed the volumeId\n   * from the volumeId if particularly specified in the tool configuration, or if\n   * not, the first actorUID in the viewport is returned as the volumeId. NOTE: for\n   * segmentations, actorUID is not necessarily the volumeId since the segmentation\n   * can have multiple representations, use segmentation helpers to get the volumeId\n   * based on the actorUID.\n   *\n   * @param viewport - Volume viewport\n   * @returns the volumeId for the viewport if specified in the tool configuration,\n   * or the first actorUID in the viewport if not.\n   */\n  private getTargetVolumeId(viewport: Types.IViewport): string | undefined {\n    if (this.configuration.volumeId) {\n      return this.configuration.volumeId;\n    }\n\n    // If volume not specified, then return the actorUID for the\n    // default actor - first actor\n    const actorEntries = viewport.getActors();\n\n    if (!actorEntries) {\n      return;\n    }\n\n    // find the first image actor of instance type vtkVolume\n    return actorEntries.find(\n      (actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume'\n    )?.uid;\n  }\n\n  /**\n   * Get the image that is displayed for the targetId in the cachedStats\n   * which can be\n   * * imageId:<imageId>\n   * * volumeId:<volumeId>\n   * * videoId:<basePathForVideo>/frames/<frameSpecifier>\n   *\n   * @param targetId - annotation targetId stored in the cached stats\n   * @param renderingEngine - The rendering engine\n   * @returns The image data for the target.\n   */\n  protected getTargetIdImage(\n    targetId: string,\n    renderingEngine: Types.IRenderingEngine\n  ): Types.IImageData | Types.CPUIImageData | Types.IImageVolume {\n    if (targetId.startsWith('imageId:')) {\n      const imageId = targetId.split('imageId:')[1];\n      const imageURI = utilities.imageIdToURI(imageId);\n      let viewports = utilities.getViewportsWithImageURI(\n        imageURI,\n        renderingEngine.id\n      );\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      viewports = viewports.filter((viewport) => {\n        return viewport.getCurrentImageId() === imageId;\n      });\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      return viewports[0].getImageData();\n    } else if (targetId.startsWith('volumeId:')) {\n      const volumeId = utilities.getVolumeId(targetId);\n      const viewports = utilities.getViewportsWithVolumeId(\n        volumeId,\n        renderingEngine.id\n      );\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      return viewports[0].getImageData();\n    } else if (targetId.startsWith('videoId:')) {\n      // Video id can be multi-valued for the frame information\n      const imageURI = utilities.imageIdToURI(targetId);\n      const viewports = utilities.getViewportsWithImageURI(\n        imageURI,\n        renderingEngine.id\n      );\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      return viewports[0].getImageData();\n    } else {\n      throw new Error(\n        'getTargetIdImage: targetId must start with \"imageId:\" or \"volumeId:\"'\n      );\n    }\n  }\n\n  /**\n   * Get the target Id for the viewport which will be used to store the cached\n   * statistics scoped to that target in the annotations.\n   * For StackViewport, targetId is the viewportId, but for the volume viewport,\n   * the targetId will be grabbed from the volumeId if particularly specified\n   * in the tool configuration, or if not, the first actorUID in the viewport.\n   *\n   * @param viewport - viewport to get the targetId for\n   * @returns targetId\n   */\n  protected getTargetId(viewport: Types.IViewport): string | undefined {\n    const targetId = viewport.getReferenceId?.();\n    if (targetId) {\n      return targetId;\n    }\n    if (viewport instanceof BaseVolumeViewport) {\n      return `volumeId:${this.getTargetVolumeId(viewport)}`;\n    }\n    throw new Error('getTargetId: viewport must have a getTargetId method');\n  }\n}\n\n// Note: this is a workaround since terser plugin does not support static blocks\n// yet and we can't easily say static toolName = \"BaseTool\" in the class definition.\nBaseTool.toolName = 'BaseTool';\nexport default BaseTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Remove the surface representation from the viewport's HTML Element.\n * NOTE: This function should not be called directly.\n *\n * @param element - The element that the segmentation is being added to.\n * @param segmentationRepresentationUID - The UID of the surface representation to remove.\n * @param removeFromCache - boolean\n *\n * @internal\n */\nfunction removeContourFromElement(\n  element: HTMLDivElement,\n  segmentationRepresentationUID: string,\n  removeFromCache = false // Todo\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const actorEntries = (viewport as Types.IVolumeViewport).getActors();\n\n  // remove actors whose id has the same prefix as the segmentationRepresentationUID\n  const actorUIDsToRemove = actorEntries\n    .map(({ uid }) =>\n      uid.startsWith(segmentationRepresentationUID) ? uid : undefined\n    )\n    .filter(Boolean);\n\n  // @ts-ignore\n  viewport.removeActors(actorUIDsToRemove);\n}\n\nexport default removeContourFromElement;\n","/**\n * Worker Types are used to define the types the worker that is getting performed\n */\nenum ChangeTypes {\n  POLYSEG_CONTOUR_TO_LABELMAP = 'polySeg/convertContourToVolumeLabelmap',\n\n  POLYSEG_SURFACE_TO_LABELMAP = 'polySeg/convertSurfacesToVolumeLabelmap',\n\n  POLYSEG_CONTOUR_TO_SURFACE = 'polySeg/convertContourToSurface',\n\n  POLYSEG_LABELMAP_TO_SURFACE = 'polySeg/convertLabelmapToSurface',\n\n  SURFACE_CLIPPING = 'surfaceClipping',\n}\n\nexport default ChangeTypes;\n","export function pointToString(point, decimals = 5) {\n  return (\n    parseFloat(point[0]).toFixed(decimals) +\n    ',' +\n    parseFloat(point[1]).toFixed(decimals) +\n    ',' +\n    parseFloat(point[2]).toFixed(decimals) +\n    ','\n  );\n}\n","import { getWebWorkerManager } from '@cornerstonejs/core';\n\nlet registered = false;\n\nexport function registerPolySegWorker() {\n  if (registered) {\n    return;\n  }\n\n  registered = true;\n\n  const workerFn = () => {\n    // @ts-ignore\n    return new Worker(\n      // @ts-ignore\n      new URL('../../../workers/polySegConverters', import.meta.url),\n      {\n        name: 'polySeg',\n      }\n    );\n  };\n\n  const workerManager = getWebWorkerManager();\n\n  const options = {\n    maxWorkerInstances: 1, // Todo, make this configurable\n    autoTerminateOnIdle: {\n      enabled: true,\n      idleTimeThreshold: 2000,\n    },\n  };\n\n  workerManager.registerWorker('polySeg', workerFn, options);\n}\n","import {\n  Types,\n  Enums,\n  getWebWorkerManager,\n  eventTarget,\n  triggerEvent,\n} from '@cornerstonejs/core';\n\nimport { WorkerTypes } from '../../../enums';\nimport { pointToString } from '../../../utilities';\nimport { registerPolySegWorker } from '../polySeg/registerPolySegWorker';\nconst workerManager = getWebWorkerManager();\n\n/**\n * Surfaces info for clipping\n */\nexport type SurfacesInfo = {\n  id: string;\n  points: number[];\n  polys: number[];\n  segmentIndex: number;\n};\n\n/**\n * The result of the surface clipping\n */\nexport type SurfaceClipResult = {\n  points: number[];\n  lines: number[];\n  numberOfCells: number;\n};\n\nexport type PolyDataClipCacheType = Map<string, Map<string, SurfaceClipResult>>;\n\n/**\n * a cache from actorUID to cacheId to SurfaceClipResult\n * Map<actorUID, Map<cacheId, SurfaceClipResult>>\n * cacheId is slice specific (viewPlaneNormal, sliceIndex)\n */\nconst polyDataCache = new Map() as PolyDataClipCacheType;\nconst surfacesAABBCache = new Map();\n\nconst triggerWorkerProgress = (eventTarget, progress) => {\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n    progress,\n    type: WorkerTypes.SURFACE_CLIPPING,\n  });\n};\n\n/**\n * Clips and caches surfaces for a specific viewport.\n *\n * @param surfacesInfo - An array of surfaces information.\n * @param viewport - The volume viewport.\n * @param segmentationRepresentationUID - The UID of the segmentation representation.\n * @returns The cached polydata.\n */\nexport async function clipAndCacheSurfacesForViewport(\n  surfacesInfo: SurfacesInfo[],\n  viewport: Types.IVolumeViewport,\n  segmentationRepresentationUID: string\n) {\n  registerPolySegWorker();\n  // All planes is an array of planes pairs for each slice, so we should loop over them and\n  // add the planes to the clipping filter and cache the results for that slice\n\n  // Fix these ts ignores\n  // @ts-ignore\n  const planesInfo = viewport.getSlicesClippingPlanes?.();\n\n  if (!planesInfo) {\n    // this means it is probably the stack viewport not being ready\n    // in terms of planes which we should wait for the first render to\n    // get the planes\n    return;\n  }\n\n  // @ts-ignore\n  const currentSliceIndex = viewport.getSliceIndex();\n\n  // Reorder planesInfo based on proximity to currentSliceIndex\n  planesInfo.sort((a, b) => {\n    const diffA = Math.abs(a.sliceIndex - currentSliceIndex);\n    const diffB = Math.abs(b.sliceIndex - currentSliceIndex);\n    return diffA - diffB;\n  });\n\n  triggerWorkerProgress(eventTarget, 0);\n\n  // check which surfaces don't have a cached AABB\n  // make a list of the surfaces that don't have a cached AABB\n  await updateSurfacesAABBCache(surfacesInfo);\n\n  const surfacesAABB = new Map();\n  surfacesInfo.forEach((surface) => {\n    surfacesAABB.set(surface.id, surfacesAABBCache.get(surface.id));\n  });\n\n  const camera = viewport.getCamera();\n\n  await workerManager\n    .executeTask(\n      'polySeg',\n      'cutSurfacesIntoPlanes',\n      {\n        surfacesInfo,\n        planesInfo,\n        surfacesAABB,\n      },\n      {\n        callbacks: [\n          // progress callback\n          ({ progress }) => {\n            triggerWorkerProgress(eventTarget, progress);\n          },\n          // update cache callback\n          ({ sliceIndex, polyDataResults }) => {\n            polyDataResults.forEach((polyDataResult, surfaceId) => {\n              const actorUID = `${segmentationRepresentationUID}_${surfaceId}`;\n              const cacheId = generateCacheId(\n                viewport,\n                camera.viewPlaneNormal,\n                sliceIndex\n              );\n              updatePolyDataCache(actorUID, cacheId, polyDataResult);\n            });\n          },\n        ],\n      }\n    )\n    .catch((error) => {\n      console.error(error);\n    });\n\n  triggerWorkerProgress(eventTarget, 1);\n\n  return polyDataCache;\n}\n\n/**\n * Updates the surfaces AABB cache with the AABB information for the given surfaces.\n * If the AABB information for a surface already exists in the cache, it will not be updated.\n * @param surfacesInfo - An array of surfaces information.\n * @returns A Promise that resolves when the surfaces AABB cache has been updated.\n */\nasync function updateSurfacesAABBCache(surfacesInfo: SurfacesInfo[]) {\n  const surfacesWithoutAABB = surfacesInfo.filter(\n    (surface) => !surfacesAABBCache.has(surface.id)\n  );\n\n  if (!surfacesWithoutAABB.length) {\n    return;\n  }\n\n  const surfacesAABB = await workerManager.executeTask(\n    'polySeg',\n    'getSurfacesAABBs',\n    {\n      surfacesInfo: surfacesWithoutAABB,\n    },\n    {\n      callbacks: [\n        // progress callback\n        ({ progress }) => {\n          triggerWorkerProgress(eventTarget, progress);\n        },\n      ],\n    }\n  );\n\n  // update the surfacesAABBCache with the new surfacesAABB\n  surfacesAABB.forEach((aabb, id) => {\n    surfacesAABBCache.set(id, aabb);\n  });\n}\n\nexport function getSurfaceActorUID(\n  segmentationRepresentationUID: string,\n  surfaceId: string\n) {\n  return `${segmentationRepresentationUID}_${surfaceId}`;\n}\n\n// Helper function to generate a cache ID\nexport function generateCacheId(viewport, viewPlaneNormal, sliceIndex) {\n  return `${viewport.id}-${pointToString(viewPlaneNormal)}-${sliceIndex}`;\n}\n\n// Helper function to update PolyData cache\nexport function updatePolyDataCache(\n  actorUID: string,\n  cacheId: string,\n  polyDataResult: SurfaceClipResult\n) {\n  const { points, lines, numberOfCells } = polyDataResult;\n\n  let actorCache = polyDataCache.get(actorUID);\n  if (!actorCache) {\n    actorCache = new Map<string, SurfaceClipResult>();\n    polyDataCache.set(actorUID, actorCache);\n  }\n  actorCache.set(cacheId, { points, lines, numberOfCells });\n}\n","import { cache } from '@cornerstonejs/core';\nimport { SegmentationPublicInput } from '../../../types/SegmentationStateTypes';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../../types/LabelmapTypes';\n\nfunction validateRepresentationData(\n  segmentationRepresentationData: LabelmapSegmentationData\n): void {\n  if ('volumeId' in segmentationRepresentationData) {\n    segmentationRepresentationData =\n      segmentationRepresentationData as LabelmapSegmentationDataVolume;\n\n    const cachedVolume = cache.getVolume(\n      segmentationRepresentationData.volumeId\n    );\n\n    if (!cachedVolume) {\n      throw new Error(\n        `volumeId of ${segmentationRepresentationData.volumeId} not found in cache, you should load and cache volume before adding segmentation`\n      );\n    }\n  } else if ('imageIdReferenceMap' in segmentationRepresentationData) {\n    segmentationRepresentationData =\n      segmentationRepresentationData as LabelmapSegmentationDataStack;\n\n    if (!segmentationRepresentationData.imageIdReferenceMap) {\n      throw new Error(\n        'The segmentationInput.representationData.imageIdReferenceMap is undefined, please provide a valid representationData.imageIdReferenceMap'\n      );\n    }\n  } else {\n    throw new Error(\n      'The segmentationInput.representationData is undefined, please provide a valid representationData'\n    );\n  }\n}\n\n/**\n * Validates the public segmentation input.\n * Throws an error if the segmentation input is invalid.\n *\n * @param segmentationInput - The segmentation input to validate.\n */\nexport function validatePublic(\n  segmentationInput: SegmentationPublicInput\n): void {\n  if (!segmentationInput.representation.data) {\n    throw new Error(\n      'The segmentationInput.representationData.data is undefined, please provide a valid representationData.data'\n    );\n  }\n\n  const representationData = segmentationInput.representation\n    .data as LabelmapSegmentationData;\n\n  validateRepresentationData(representationData);\n}\n\n/**\n * Validates the given segmentation representation data.\n *\n * @param segmentationRepresentationData The segmentation representation data to validate.\n */\nexport function validate(\n  segmentationRepresentationData: LabelmapSegmentationData\n) {\n  validateRepresentationData(segmentationRepresentationData);\n}\n","import { SegmentationRepresentations } from '../../../enums';\nimport { validateLabelmap } from '../../../tools/displayTools/Labelmap';\nimport { SegmentationRepresentationData } from '../../../types';\nimport {\n  findSegmentationRepresentationByUID,\n  getSegmentation,\n} from '../segmentationState';\n\n// Map of conversion paths between source and target representations\n// You should read it as \"source\" -> \"targets\"\nconst conversionPaths = new Map<\n  SegmentationRepresentations,\n  Set<SegmentationRepresentations>\n>([\n  [\n    SegmentationRepresentations.Labelmap,\n    new Set([\n      SegmentationRepresentations.Surface,\n      SegmentationRepresentations.Contour,\n    ]),\n  ],\n  [\n    SegmentationRepresentations.Contour,\n    new Set([\n      SegmentationRepresentations.Labelmap,\n      SegmentationRepresentations.Surface,\n    ]),\n  ],\n  [\n    SegmentationRepresentations.Surface,\n    new Set([SegmentationRepresentations.Labelmap]),\n  ],\n]);\n\n/**\n * Determines whether the requested representation can be computed, based on\n * the existing representation types and available conversion paths.\n * This is used in the labelmapDisplay and surfaceDisplay logic if the\n * requested representation is not available whether we can use the existing\n * representation to compute the requested representation. You can checkout the polySeg\n * examples to see how this is used polyDataActorManipulationTools and others\n *\n * @param segmentationRepresentationUID - The UID of the desired segmentation representation.\n * @returns true if the requested representation can be computed, otherwise false.\n */\nfunction canComputeRequestedRepresentation(\n  segmentationRepresentationUID: string\n): boolean {\n  const representationInfo = findSegmentationRepresentationByUID(\n    segmentationRepresentationUID\n  );\n\n  if (!representationInfo?.segmentationRepresentation) {\n    return false;\n  }\n\n  const { segmentationRepresentation } = representationInfo;\n  const { type: representationType, polySeg } = segmentationRepresentation;\n\n  if (!polySeg || !polySeg.enabled) {\n    return false;\n  }\n\n  const { representationData } = getSegmentation(\n    segmentationRepresentation.segmentationId\n  );\n\n  const existingRepresentationTypes =\n    getExistingRepresentationTypes(representationData);\n\n  return existingRepresentationTypes.some((existingRepresentationType) =>\n    canConvertFromTo(existingRepresentationType, representationType)\n  );\n}\n\n/**\n * Retrieves the existing representation types for the given representationData\n * by verifying the validity of each representation type.\n *\n * @param representationData - The representation data\n * @returns supportedTypes - An array of valid representation types\n */\nfunction getExistingRepresentationTypes(\n  representationData: SegmentationRepresentationData\n): string[] {\n  const supportedTypes: string[] = [];\n\n  Object.keys(representationData).forEach((representationType) => {\n    const representationTypeData = representationData[representationType];\n\n    let validateFn;\n    switch (representationType) {\n      case SegmentationRepresentations.Labelmap:\n        validateFn = validateLabelmap;\n        break;\n      // Todo: add validation for other representation types\n    }\n\n    if (validateFn) {\n      try {\n        validateFn(representationTypeData);\n        supportedTypes.push(representationType);\n      } catch (error) {\n        console.warn(\n          `Validation failed for labelmap of type ${representationType}`\n        );\n      }\n    } else {\n      supportedTypes.push(representationType);\n    }\n  });\n\n  return supportedTypes;\n}\n\nasync function canConvertFromTo(fromRepresentationType, toRepresentationType) {\n  return (\n    conversionPaths.get(fromRepresentationType)?.has(toRepresentationType) ||\n    false\n  );\n}\n\nexport { canComputeRequestedRepresentation };\n","import { LabelmapSegmentationData } from '../../types/LabelmapTypes';\nimport { ContourSegmentationData } from '../../types/ContourTypes';\nimport { SurfaceSegmentationData } from '../../types/SurfaceTypes';\nimport { getSegmentation } from './segmentationState';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\n\ntype SegmentationData =\n  | LabelmapSegmentationData\n  | ContourSegmentationData\n  | SurfaceSegmentationData;\n\ntype AddRepresentationData = {\n  segmentationId: string;\n  type: SegmentationRepresentations;\n  data: SegmentationData;\n};\n\n/**\n * This will add representation data to the segmentation, for rendering.\n * Each segmentation can have multiple representation data, for example\n * labelmap, contour and surface representation data. For each representation\n * the relevant data should be provided, for instance for the labelmap\n * representation the volumeId should be provided, for contour the contour data\n * which includes geometryIds of the contour sets, and for surface the surface\n * data which includes geometryId of the points and cells.\n *\n * Note: if the representation data already exists for the segmentation, it will\n * be overwritten.\n *\n * @param segmentationId - id of the segmentation\n * @param representationData - representation data to add, it can be either\n * labelmap, contour or surface representation data.\n */\nfunction addRepresentationData({\n  segmentationId,\n  type,\n  data,\n}: AddRepresentationData) {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (segmentation.representationData[type]) {\n    console.warn(\n      `Representation data of type ${type} already exists for segmentation ${segmentationId}, overwriting it.`\n    );\n\n    // update the representation data class\n  }\n\n  switch (type) {\n    case SegmentationRepresentations.Labelmap:\n      if (data) {\n        segmentation.representationData[type] =\n          data as LabelmapSegmentationData;\n      }\n      break;\n    case SegmentationRepresentations.Contour:\n      if (data) {\n        segmentation.representationData[type] = data as ContourSegmentationData;\n      }\n      break;\n    case SegmentationRepresentations.Surface:\n      if (data) {\n        segmentation.representationData[type] = data as SurfaceSegmentationData;\n      }\n      break;\n    default:\n      throw new Error(`Invalid representation type ${type}`);\n  }\n}\n\nexport default addRepresentationData;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @since 0.1.0\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * isObject({})\n * // => true\n *\n * isObject([1, 2, 3])\n * // => true\n *\n * isObject(Function)\n * // => true\n *\n * isObject(null)\n * // => false\n */\nfunction isObject(value) {\n  const type = typeof value;\n\n  return value !== null && (type === 'object' || type === 'function');\n}\n\nexport default isObject;\n","import isObject from './isObject';\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked, or until the next browser frame is drawn. The debounced function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * debounced function. Subsequent calls to the debounced function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `debounce` and `throttle`.\n *\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0]\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\n *  used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', debounce(calculateLayout, 150))\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }))\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * const debounced = debounce(batchLog, 250, { 'maxWait': 1000 })\n * const source = new EventSource('/stream')\n * jQuery(source).on('message', debounced)\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel)\n *\n * // Check for pending invocations.\n * const status = debounced.pending() ? \"Pending...\" : \"Ready\"\n */\nfunction debounce(func, wait, options) {\n  let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n\n  let lastInvokeTime = 0;\n  let leading = false;\n  let maxing = false;\n  let trailing = true;\n\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n  const useRAF =\n    !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  wait = Number(wait) || 0;\n  if (isObject(options)) {\n    leading = Boolean(options.leading);\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  function invokeFunc(time) {\n    const args = lastArgs;\n    const thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n\n    return result;\n  }\n\n  function startTimer(pendingFunc, wait) {\n    if (useRAF) {\n      return window.requestAnimationFrame(pendingFunc);\n    }\n\n    return setTimeout(pendingFunc, wait);\n  }\n\n  function cancelTimer(id) {\n    if (useRAF) {\n      return window.cancelAnimationFrame(id);\n    }\n    clearTimeout(id);\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = startTimer(timerExpired, wait);\n\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (\n      lastCallTime === undefined ||\n      timeSinceLastCall >= wait ||\n      timeSinceLastCall < 0 ||\n      (maxing && timeSinceLastInvoke >= maxWait)\n    );\n  }\n\n  function timerExpired() {\n    const time = Date.now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = startTimer(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      cancelTimer(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(Date.now());\n  }\n\n  function pending() {\n    return timerId !== undefined;\n  }\n\n  function debounced(...args) {\n    const time = Date.now();\n    const isInvoking = shouldInvoke(time);\n\n    lastArgs = args;\n    lastThis = this; // eslint-disable-line consistent-this\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = startTimer(timerExpired, wait);\n\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  debounced.pending = pending;\n\n  return debounced;\n}\n\nexport default debounce;\n","import { eventTarget } from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../../enums';\nimport addRepresentationData from '../addRepresentationData';\nimport { triggerSegmentationModified } from '../triggerSegmentationEvents';\nimport { debounce } from '../../../utilities';\nimport { registerPolySegWorker } from './registerPolySegWorker';\n\nconst computedRepresentations = new Map<\n  string,\n  SegmentationRepresentations[]\n>();\n\n/**\n * Computes a representation using the provided computation function, adds the computed data,\n * subscribes to segmentation changes, and triggers segmentation modification.\n *\n * @param segmentationId - The ID of the segmentation.\n * @param representationType - The type of the segmentation representation.\n * @param computeFunction - The function that computes the representation data.\n * @param options - Additional options for computing the representation.\n * @returns - A promise that resolves with the computed representation data.\n */\nasync function computeAndAddRepresentation<T>(\n  segmentationId: string,\n  representationType: SegmentationRepresentations,\n  computeFunction: () => Promise<T>,\n  updateFunction?: () => void\n): Promise<T> {\n  // register the worker if it hasn't been registered yet\n  registerPolySegWorker();\n\n  // Compute the specific representation data\n  const data = await computeFunction();\n\n  // Add the computed data to the system\n  addRepresentationData({\n    segmentationId,\n    type: representationType,\n    data,\n  });\n\n  // Update internal structures and possibly UI components\n  if (!computedRepresentations.has(segmentationId)) {\n    computedRepresentations.set(segmentationId, []);\n  }\n\n  const representations = computedRepresentations.get(segmentationId);\n  if (!representations.includes(representationType)) {\n    representations.push(representationType);\n  }\n\n  // Subscribe to any changes in the segmentation data for real-time updates\n  subscribeToSegmentationChanges(updateFunction);\n\n  // Notify other system parts that segmentation data has been modified\n  triggerSegmentationModified(segmentationId);\n\n  return data;\n}\n\n/**\n * Subscribes to segmentation changes by adding an event listener for the SEGMENTATION_DATA_MODIFIED event.\n * If there is an existing listener, it will be unsubscribed before adding the new listener.\n */\nfunction subscribeToSegmentationChanges(updateFunction) {\n  const debouncedUpdateFunction = (event) => {\n    _debouncedSegmentationModified(event, updateFunction);\n  };\n\n  updateFunction._debouncedUpdateFunction = debouncedUpdateFunction;\n\n  eventTarget.removeEventListener(\n    Events.SEGMENTATION_DATA_MODIFIED,\n    updateFunction._debouncedUpdateFunction\n  );\n\n  eventTarget.addEventListener(\n    Events.SEGMENTATION_DATA_MODIFIED,\n    updateFunction._debouncedUpdateFunction\n  );\n}\n\nconst _debouncedSegmentationModified = debounce((event, updateFunction) => {\n  const segmentationId = event.detail.segmentationId;\n  const representations = computedRepresentations.get(segmentationId);\n  if (!representations || !representations.length) {\n    return;\n  }\n\n  updateFunction(segmentationId);\n\n  if (representations.length) {\n    triggerSegmentationModified(segmentationId);\n  }\n}, 300);\n\nexport { computeAndAddRepresentation };\n","import { Enums, Types, eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { getWebWorkerManager } from '@cornerstonejs/core';\nimport { ContourSegmentationData } from '../../../../types';\nimport { getAnnotation } from '../../../annotation/annotationState';\nimport { WorkerTypes } from '../../../../enums';\n\nconst workerManager = getWebWorkerManager();\n\nconst triggerWorkerProgress = (eventTarget, progress) => {\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n    progress,\n    type: WorkerTypes.POLYSEG_CONTOUR_TO_SURFACE,\n  });\n};\n\n/**\n * Converts a contour representation to a surface representation.\n *\n * @param contourRepresentationData - The contour segmentation data.\n * @param segmentIndex - The index of the segment to convert.\n * @returns A promise that resolves to the surface data.\n */\nexport async function convertContourToSurface(\n  contourRepresentationData: ContourSegmentationData,\n  segmentIndex: number\n): Promise<Types.SurfaceData> {\n  const { annotationUIDsMap } = contourRepresentationData;\n\n  // loop over all annotations in the segment and flatten their polylines\n  const polylines = [];\n  const numPointsArray = [];\n  const annotationUIDs = annotationUIDsMap.get(segmentIndex);\n\n  for (const annotationUID of annotationUIDs) {\n    const annotation = getAnnotation(annotationUID);\n    const { polyline } = annotation.data.contour;\n    numPointsArray.push(polyline.length);\n    polyline.forEach((polyline) => polylines.push(...polyline));\n  }\n\n  triggerWorkerProgress(eventTarget, 0);\n\n  const results = await workerManager.executeTask(\n    'polySeg',\n    'convertContourToSurface',\n    {\n      polylines,\n      numPointsArray,\n    },\n    {\n      callbacks: [\n        (progress) => {\n          triggerWorkerProgress(eventTarget, progress);\n        },\n      ],\n    }\n  );\n\n  triggerWorkerProgress(eventTarget, 1);\n\n  return results;\n}\n","import { utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\n\n/**\n * addColorLUT - Adds a new color LUT to the state at the given colorLUTIndex.\n * If no colorLUT is provided, a new color LUT is generated.\n *\n * @param colorLUTIndex - the index of the colorLUT in the state\n * @param colorLUT - An array of The colorLUT to set.\n * @returns\n */\nfunction addColorLUT(colorLUT: Types.ColorLUT, colorLUTIndex: number): void {\n  if (!colorLUT) {\n    throw new Error('addColorLUT: colorLUT is required');\n  }\n\n  // Append the \"zero\" (no label) color to the front of the LUT, if necessary.\n  if (!utilities.isEqual(colorLUT[0], [0, 0, 0, 0])) {\n    console.warn(\n      'addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it'\n    );\n    colorLUT.unshift([0, 0, 0, 0]);\n  }\n\n  SegmentationState.addColorLUT(colorLUT, colorLUTIndex);\n}\n\n/**\n * It sets the toolGroup's segmentationRepresentation to use the provided\n * colorLUT at the given colorLUTIndex.\n * @param toolGroupId - the id of the toolGroup that renders the representation\n * @param segmentationRepresentationUID - the representationUID for the segmentation\n * @param colorLUTIndex - the index of the colorLUT to use\n */\nfunction setColorLUT(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  colorLUTIndex: number\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    throw new Error(\n      `setColorLUT: could not find segmentation representation with UID ${segmentationRepresentationUID}`\n    );\n  }\n\n  if (!SegmentationState.getColorLUT(colorLUTIndex)) {\n    throw new Error(\n      `setColorLUT: could not find colorLUT with index ${colorLUTIndex}`\n    );\n  }\n\n  segRepresentation.colorLUTIndex = colorLUTIndex;\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Given a tool group UID, a segmentation representationUID, and a segment index, return the\n * color for that segment. It can be used for segmentation tools that need to\n * display the color of their annotation.\n *\n * @param toolGroupId - The Id of the tool group that owns the segmentation representation.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment in the segmentation\n * @returns A color.\n */\nfunction getColorForSegmentIndex(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): Types.Color {\n  const segmentationRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segmentationRepresentation) {\n    throw new Error(\n      `segmentation representation with UID ${segmentationRepresentationUID} does not exist for tool group ${toolGroupId}`\n    );\n  }\n\n  const { colorLUTIndex } = segmentationRepresentation;\n\n  // get colorLUT\n  const colorLUT = SegmentationState.getColorLUT(colorLUTIndex);\n  let colorValue = colorLUT[segmentIndex];\n  if (!colorValue) {\n    if (typeof segmentIndex !== 'number') {\n      throw new Error(`Can't create colour for LUT index ${segmentIndex}`);\n    }\n    colorValue = colorLUT[segmentIndex] = [0, 0, 0, 0];\n  }\n  return colorValue;\n}\n\nfunction setColorForSegmentIndex(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number,\n  color: Types.Color\n): void {\n  // Get the reference to the color in the colorLUT.\n  const colorReference = getColorForSegmentIndex(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n\n  // Modify the values by reference\n  for (let i = 0; i < color.length; i++) {\n    colorReference[i] = color[i];\n  }\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nexport {\n  getColorForSegmentIndex,\n  addColorLUT,\n  setColorLUT,\n  setColorForSegmentIndex,\n};\n","import { Enums, Types, geometryLoader } from '@cornerstonejs/core';\nimport { getColorForSegmentIndex } from '../../config/segmentationColor';\nimport {\n  findSegmentationRepresentationByUID,\n  getSegmentation,\n} from '../../segmentationState';\nimport { RawSurfacesData } from './surfaceComputationStrategies';\nimport { PolySegConversionOptions } from '../../../../types';\n\n/**\n * Creates and caches surfaces from raw surface data.\n *\n * @param segmentationId - The ID of the segmentation.\n * @param rawSurfacesData - The raw surface data.\n * @param options - Additional options for creating and caching surfaces.\n * @param options.segmentIndices - An array of segment indices.\n * @param options.segmentationRepresentationUID - The UID of the segmentation representation.\n * @returns An object containing the IDs of the created surfaces.\n */\nexport async function createAndCacheSurfacesFromRaw(\n  segmentationId: string,\n  rawSurfacesData: RawSurfacesData,\n  options: PolySegConversionOptions = {}\n) {\n  // Initialize segmentationRepresentation and toolGroupId if a representation UID is provided\n  let segmentationRepresentation: any, toolGroupId: any;\n  if (options.segmentationRepresentationUID) {\n    ({ segmentationRepresentation, toolGroupId } =\n      findSegmentationRepresentationByUID(\n        options.segmentationRepresentationUID\n      ));\n  }\n\n  const segmentation = getSegmentation(segmentationId);\n\n  const geometryIds = new Map<number, string>();\n\n  // Loop through raw surfaces data and create surfaces\n  const promises = Object.keys(rawSurfacesData).map(async (index: string) => {\n    const rawSurfaceData = rawSurfacesData[index];\n    const segmentIndex = rawSurfaceData.segmentIndex;\n\n    // Get the color either from the segmentation representation or randomly generated\n    const color = segmentationRepresentation;\n    getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentation.segmentationRepresentationUID,\n      segmentIndex\n    ).slice(0, 3);\n\n    if (!color) {\n      throw new Error(\n        'No color found for segment index, unable to create surface'\n      );\n    }\n\n    const closedSurface = {\n      id: `segmentation_${segmentation.segmentationId}_surface_${segmentIndex}`,\n      color,\n      frameOfReferenceUID: 'test-frameOfReferenceUID',\n      data: {\n        points: rawSurfaceData.data.points,\n        polys: rawSurfaceData.data.polys,\n      },\n    };\n\n    const geometryId = closedSurface.id;\n    geometryIds.set(segmentIndex, geometryId);\n\n    return geometryLoader.createAndCacheGeometry(geometryId, {\n      type: Enums.GeometryType.SURFACE,\n      geometryData: closedSurface as Types.PublicSurfaceData,\n    });\n  });\n\n  await Promise.all(promises);\n\n  return {\n    geometryIds,\n  };\n}\n","import {\n  getEnabledElement,\n  addVolumesToViewports,\n  addImageSlicesToViewports,\n  Types,\n  Enums,\n} from '@cornerstonejs/core';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataStack,\n} from '../../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../segmentation/strategies/utils/stackVolumeCheck';\n/**\n * It adds a labelmap segmentation representation of the viewport's HTML Element.\n * NOTE: This function should not be called directly.\n *\n * @param element - The element that will be rendered.\n * @param volumeId - The volume id of the labelmap.\n * @param segmentationRepresentationUID - The segmentation representation UID.\n *\n * @internal\n */\nasync function addLabelmapToElement(\n  element: HTMLDivElement,\n  labelMapData: LabelmapSegmentationData,\n  segmentationRepresentationUID: string\n): Promise<void> {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n  const { id: viewportId } = viewport;\n\n  // Default to true since we are setting a new segmentation, however,\n  // in the event listener, we will make other segmentations visible/invisible\n  // based on the config\n  const visibility = true;\n  const immediateRender = false;\n  const suppressEvents = true;\n\n  if (isVolumeSegmentation(labelMapData, viewport)) {\n    // Todo: Right now we use MIP blend mode for the labelmap, since the\n    // composite blend mode has a non linear behavior regarding fill and line\n    // opacity. This should be changed to a custom labelmap blendMode which does\n    // what composite does, but with a linear behavior.\n    const volumeInputs: Types.IVolumeInput[] = [\n      {\n        volumeId: labelMapData.volumeId,\n        actorUID: segmentationRepresentationUID,\n        visibility,\n        blendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n      },\n    ];\n\n    // Add labelmap volumes to the viewports to be be rendered, but not force the render\n    await addVolumesToViewports(\n      renderingEngine,\n      volumeInputs,\n      [viewportId],\n      immediateRender,\n      suppressEvents\n    );\n  } else {\n    // We can use the current imageId in the viewport to get the segmentation imageId\n    // which later is used to create the actor and mapper.\n    const segmentationImageId = (\n      labelMapData as LabelmapSegmentationDataStack\n    ).imageIdReferenceMap.get(viewport.getCurrentImageId());\n\n    const stackInputs: Types.IStackInput[] = [\n      {\n        imageId: segmentationImageId,\n        actorUID: segmentationRepresentationUID,\n      },\n    ];\n\n    // Add labelmap volumes to the viewports to be be rendered, but not force the render\n    await addImageSlicesToViewports(\n      renderingEngine,\n      stackInputs,\n      [viewportId],\n      immediateRender,\n      suppressEvents\n    );\n  }\n}\n\nexport default addLabelmapToElement;\n","import { getEnabledElement } from '@cornerstonejs/core';\n\n/**\n * Remove the labelmap segmentation representation from the viewport's HTML Element.\n * NOTE: This function should not be called directly.\n *\n * @param element - The element that the segmentation is being added to.\n * @param segmentationRepresentationUID - The UID of the labelmap representation to remove.\n * @param removeFromCache - boolean\n *\n * @internal\n */\nfunction removeLabelmapFromElement(\n  element: HTMLDivElement,\n  segmentationRepresentationUID: string,\n  removeFromCache = false // Todo\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  viewport.removeActors([segmentationRepresentationUID]);\n}\n\nexport default removeLabelmapFromElement;\n","import { vec3 } from 'gl-matrix';\nimport {\n  Types,\n  cache,\n  utilities,\n  getWebWorkerManager,\n  volumeLoader,\n  imageLoader,\n  metaData,\n  Enums,\n  triggerEvent,\n  eventTarget,\n} from '@cornerstonejs/core';\nimport {\n  Annotation,\n  ContourAnnotation,\n  ContourSegmentationData,\n  PolySegConversionOptions,\n} from '../../../../types';\nimport { getAnnotation } from '../../..';\nimport { WorkerTypes } from '../../../../enums';\n\nconst workerManager = getWebWorkerManager();\n\nconst triggerWorkerProgress = (eventTarget, progress) => {\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n    progress,\n    type: WorkerTypes.POLYSEG_CONTOUR_TO_LABELMAP,\n  });\n};\n\nexport async function convertContourToVolumeLabelmap(\n  contourRepresentationData: ContourSegmentationData,\n  options: PolySegConversionOptions = {}\n) {\n  const { viewport } = options;\n\n  const imageIds = utilities.getViewportImageIds(viewport);\n\n  if (!imageIds) {\n    throw new Error(\n      'No imageIds found, labelmap computation from contour requires viewports with imageIds'\n    );\n  }\n\n  const segmentationVolumeId = utilities.uuidv4();\n\n  const volumeProps = utilities.generateVolumePropsFromImageIds(\n    imageIds,\n    segmentationVolumeId\n  );\n\n  const { metadata, dimensions, origin, direction, spacing, scalarData } =\n    volumeProps;\n\n  const segmentationVolume = await volumeLoader.createLocalSegmentationVolume(\n    {\n      dimensions,\n      origin,\n      direction,\n      spacing,\n      metadata,\n      imageIds: imageIds.map((imageId) => `generated://${imageId}`),\n      referencedImageIds: imageIds,\n    },\n    segmentationVolumeId\n  );\n\n  const { segmentIndices, annotationUIDsInSegmentMap } =\n    _getAnnotationMapFromSegmentation(contourRepresentationData, options);\n\n  triggerWorkerProgress(eventTarget, 0);\n\n  const newScalarData = await workerManager.executeTask(\n    'polySeg',\n    'convertContourToVolumeLabelmap',\n    {\n      segmentIndices,\n      dimensions,\n      scalarData,\n      origin,\n      direction,\n      spacing,\n      annotationUIDsInSegmentMap,\n    },\n    {\n      callbacks: [\n        (progress) => {\n          triggerWorkerProgress(eventTarget, progress);\n        },\n      ],\n    }\n  );\n\n  triggerWorkerProgress(eventTarget, 1);\n\n  segmentationVolume.imageData\n    .getPointData()\n    .getScalars()\n    .setData(newScalarData);\n  segmentationVolume.imageData.modified();\n\n  // update the scalarData in the volume as well\n  segmentationVolume.modified();\n\n  return {\n    volumeId: segmentationVolume.volumeId,\n  };\n}\n\nexport async function convertContourToStackLabelmap(\n  contourRepresentationData: ContourSegmentationData,\n  options: PolySegConversionOptions = {}\n) {\n  if (!options.viewport) {\n    throw new Error(\n      'No viewport provided, labelmap computation from contour requires viewports'\n    );\n  }\n\n  const viewport = options.viewport as Types.IStackViewport;\n\n  const imageIds = viewport.getImageIds();\n\n  if (!imageIds) {\n    throw new Error(\n      'No imageIds found, labelmap computation from contour requires viewports with imageIds'\n    );\n  }\n\n  // check if the imageIds are already cached\n  imageIds.forEach((imageId) => {\n    if (!cache.getImageLoadObject(imageId)) {\n      throw new Error(\n        'ImageIds must be cached before converting contour to labelmap'\n      );\n    }\n  });\n\n  // create\n  const { imageIds: segmentationImageIds } =\n    await imageLoader.createAndCacheDerivedSegmentationImages(imageIds);\n\n  const { segmentIndices, annotationUIDsInSegmentMap } =\n    _getAnnotationMapFromSegmentation(contourRepresentationData, options);\n\n  // information for the referenced to the segmentation image\n  // Define constant to hold segmentation information\n  const segmentationsInfo = new Map();\n\n  // Loop through each segmentation image ID\n  segmentationImageIds.forEach((segImageId, index) => {\n    // Fetch the image from cache\n    const segImage = cache.getImage(segImageId);\n\n    // Fetch metadata for the image\n    const imagePlaneModule = metaData.get(\n      Enums.MetadataModules.IMAGE_PLANE,\n      segImageId\n    );\n\n    // Extract properties from image metadata\n    let {\n      columnCosines,\n      rowCosines,\n      rowPixelSpacing,\n      columnPixelSpacing,\n      imagePositionPatient,\n    } = imagePlaneModule;\n\n    // Set defaults if necessary\n    columnCosines = columnCosines ?? [0, 1, 0];\n    rowCosines = rowCosines ?? [1, 0, 0];\n    rowPixelSpacing = rowPixelSpacing ?? 1;\n    columnPixelSpacing = columnPixelSpacing ?? 1;\n    imagePositionPatient = imagePositionPatient ?? [0, 0, 0];\n\n    // Create vector from row and column cosines\n    const rowCosineVec = vec3.fromValues(\n      rowCosines[0],\n      rowCosines[1],\n      rowCosines[2]\n    );\n    const colCosineVec = vec3.fromValues(\n      columnCosines[0],\n      columnCosines[1],\n      columnCosines[2]\n    );\n\n    // Calculate scan axis normal\n    const scanAxisNormal = vec3.create();\n    vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);\n\n    // Define direction and spacing\n    const direction = [...rowCosineVec, ...colCosineVec, ...scanAxisNormal];\n    const spacing = [rowPixelSpacing, columnPixelSpacing, 1];\n\n    // Set origin\n    const origin = imagePositionPatient;\n\n    // Store segmentation information\n    segmentationsInfo.set(imageIds[index], {\n      direction,\n      spacing,\n      origin,\n      scalarData: segImage.getPixelData(),\n      imageId: segImageId,\n      dimensions: [segImage.width, segImage.height, 1],\n    });\n  });\n\n  triggerWorkerProgress(eventTarget, 0);\n\n  const newSegmentationsScalarData = await workerManager.executeTask(\n    'polySeg',\n    'convertContourToStackLabelmap',\n    {\n      segmentationsInfo,\n      annotationUIDsInSegmentMap,\n      segmentIndices,\n    },\n    {\n      callbacks: [\n        (progress) => {\n          triggerWorkerProgress(eventTarget, progress);\n        },\n      ],\n    }\n  );\n\n  triggerWorkerProgress(eventTarget, 1);\n\n  const imageIdReferenceMap = new Map();\n  newSegmentationsScalarData.forEach(({ scalarData }, referencedImageId) => {\n    const segmentationInfo = segmentationsInfo.get(referencedImageId);\n    const { imageId: segImageId } = segmentationInfo;\n\n    const segImage = cache.getImage(segImageId);\n    segImage.getPixelData().set(scalarData);\n    segImage.imageFrame?.pixelData?.set(scalarData);\n\n    imageIdReferenceMap.set(referencedImageId, segImageId);\n  });\n\n  return {\n    imageIdReferenceMap,\n  };\n}\n\nfunction _getAnnotationMapFromSegmentation(\n  contourRepresentationData: ContourSegmentationData,\n  options: PolySegConversionOptions = {}\n) {\n  const annotationMap = contourRepresentationData.annotationUIDsMap;\n\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : Array.from(annotationMap.keys());\n\n  const annotationUIDsInSegmentMap = new Map<number, any>();\n  segmentIndices.forEach((index) => {\n    const annotationUIDsInSegment = annotationMap.get(index);\n\n    // Todo: there is a bug right now where the annotationUIDsInSegment has both\n    // children and parent annotations, so we need to filter out the parent\n    // annotations only\n\n    let uids = Array.from(annotationUIDsInSegment);\n\n    uids = uids.filter(\n      (uid) => !(getAnnotation(uid) as Annotation).parentAnnotationUID\n    );\n\n    const annotations = uids.map((uid) => {\n      const annotation = getAnnotation(uid) as ContourAnnotation;\n      const hasChildAnnotations = annotation.childAnnotationUIDs?.length;\n\n      return {\n        polyline: annotation.data.contour.polyline,\n        referencedImageId: annotation.metadata.referencedImageId,\n        holesPolyline:\n          hasChildAnnotations &&\n          annotation.childAnnotationUIDs.map((childUID) => {\n            const childAnnotation = getAnnotation(\n              childUID\n            ) as ContourAnnotation;\n            return childAnnotation.data.contour.polyline;\n          }),\n      };\n    });\n\n    annotationUIDsInSegmentMap.set(index, annotations);\n  });\n\n  return { segmentIndices, annotationUIDsInSegmentMap };\n}\n","import {\n  Enums,\n  Types,\n  cache,\n  eventTarget,\n  getWebWorkerManager,\n  triggerEvent,\n} from '@cornerstonejs/core';\nimport { SurfaceSegmentationData } from '../../../../types/SurfaceTypes';\nimport { WorkerTypes } from '../../../../enums';\n\nconst workerManager = getWebWorkerManager();\n\nconst triggerWorkerProgress = (eventTarget, progress) => {\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n    progress,\n    type: WorkerTypes.POLYSEG_SURFACE_TO_LABELMAP,\n  });\n};\n\nexport async function convertSurfaceToVolumeLabelmap(\n  surfaceRepresentationData: SurfaceSegmentationData,\n  segmentationVolume: Types.IImageVolume\n) {\n  const { geometryIds } = surfaceRepresentationData;\n  if (!geometryIds?.size) {\n    throw new Error('No geometry IDs found for surface representation');\n  }\n\n  const segmentsInfo = new Map() as Map<\n    number,\n    {\n      points: number[];\n      polys: number[];\n    }\n  >;\n\n  geometryIds.forEach((geometryId, segmentIndex) => {\n    const geometry = cache.getGeometry(geometryId);\n    const geometryData = geometry.data as Types.ISurface;\n    const points = geometryData.getPoints();\n    const polys = geometryData.getPolys();\n\n    segmentsInfo.set(segmentIndex, {\n      points,\n      polys,\n    });\n  });\n\n  const { dimensions, direction, origin, spacing } = segmentationVolume;\n\n  triggerWorkerProgress(eventTarget, 0);\n\n  const newScalarData = await workerManager.executeTask(\n    'polySeg',\n    'convertSurfacesToVolumeLabelmap',\n    {\n      segmentsInfo,\n      dimensions,\n      spacing,\n      direction,\n      origin,\n    },\n    {\n      callbacks: [\n        (progress) => {\n          triggerWorkerProgress(eventTarget, progress);\n        },\n      ],\n    }\n  );\n\n  triggerWorkerProgress(eventTarget, 1);\n\n  segmentationVolume.imageData\n    .getPointData()\n    .getScalars()\n    .setData(newScalarData);\n  segmentationVolume.imageData.modified();\n\n  // update the scalarData in the volume as well\n  segmentationVolume.modified();\n\n  return {\n    volumeId: segmentationVolume.volumeId,\n  };\n}\n\nexport async function convertSurfaceToStackLabelmap() {\n  // TODO\n}\n","/**\n * Creates a map that associates each imageId with a set of segmentation imageIds.\n * Note that this function assumes that the imageIds and segmentationImageIds arrays\n * are the same length and same order.\n *\n * @param imageIdsArray - An array of imageIds.\n * @param segmentationImageIds - An array of segmentation imageIds.\n * @returns A map that maps each imageId to a set of segmentation imageIds.\n */\nfunction createImageIdReferenceMap(\n  imageIdsArray: string[],\n  segmentationImageIds: string[]\n): Map<string, string> {\n  const imageIdReferenceMap = new Map<string, string>(\n    imageIdsArray.map((imageId, index) => {\n      return [imageId, segmentationImageIds[index]];\n    })\n  );\n\n  return imageIdReferenceMap;\n}\n\nexport { createImageIdReferenceMap };\n","import {\n  Types,\n  cache,\n  eventTarget,\n  getRenderingEngines,\n} from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport addSegmentationRepresentations from './addSegmentationRepresentations';\nimport {\n  triggerSegmentationRender,\n  createImageIdReferenceMap,\n} from '../../utilities/segmentation';\nimport { getSegmentation } from './segmentationState';\nimport { LabelmapSegmentationDataVolume } from '../../types/LabelmapTypes';\nimport { triggerSegmentationDataModified } from './triggerSegmentationEvents';\n\n// This function is responsible for the conversion calculations\nexport async function computeStackSegmentationFromVolume({\n  volumeId,\n}: {\n  volumeId: string;\n}): Promise<{ imageIdReferenceMap: Map<string, string> }> {\n  const segmentationVolume = cache.getVolume(volumeId) as Types.IImageVolume;\n\n  // we need to decache the segmentation Volume so that we use it\n  // for the conversion\n\n  // So here we have two scenarios that we need to handle:\n  // 1. the volume was derived from a stack and we need to decache it, this is easy\n  // since we just need purge the volume from the cache and those images will get\n  // their copy of the image back\n  // 2. It was actually a native volume and we need to decache it, this is a bit more\n  // complicated since then we need to decide on the imageIds for it to get\n  // decached to\n  const hasCachedImages = segmentationVolume.imageCacheOffsetMap.size > 0;\n  // Initialize the variable to hold the final result\n  let isAllImagesCached = false;\n\n  if (hasCachedImages) {\n    // Check if every imageId in the volume is in the _imageCache\n    isAllImagesCached = segmentationVolume.imageIds.every((imageId) =>\n      cache.getImage(imageId)\n    );\n  }\n\n  //Todo: This is a hack to get the rendering engine\n  const renderingEngine = getRenderingEngines()[0];\n  const volumeUsedInOtherViewports = renderingEngine\n    .getVolumeViewports()\n    .find((vp) => vp.hasVolumeId(volumeId));\n\n  segmentationVolume.decache(!volumeUsedInOtherViewports && isAllImagesCached);\n\n  const imageIdReferenceMap =\n    _getImageIdReferenceMapForStackSegmentation(segmentationVolume);\n\n  // check if the imageIds have been cache, if not we should actually copy\n\n  return { imageIdReferenceMap };\n}\n\n// Updated original function to call the new separate functions\nexport async function convertVolumeToStackSegmentation({\n  segmentationId,\n  options,\n}: {\n  segmentationId: string;\n  options?: {\n    toolGroupId: string;\n    newSegmentationId?: string;\n    removeOriginal?: boolean;\n  };\n}): Promise<void> {\n  const segmentation = getSegmentation(segmentationId);\n\n  const data = segmentation.representationData\n    .LABELMAP as LabelmapSegmentationDataVolume;\n  const { imageIdReferenceMap } = await computeStackSegmentationFromVolume({\n    volumeId: data.volumeId,\n  });\n\n  await updateStackSegmentationState({\n    segmentationId,\n    toolGroupId: options.toolGroupId,\n    imageIdReferenceMap,\n    options,\n  });\n}\n\n/**\n * Converts a volume segmentation to a stack segmentation.\n *\n * @param params - The parameters for the conversion.\n * @param params.segmentationId - The segmentationId to convert.\n * @param [params.options] - The conversion options.\n * @param params.options.toolGroupId - The new toolGroupId that the new segmentation will belong to.\n * @param [params.options.newSegmentationId] -  The new segmentationId to use for the segmentation. If not provided, a new ID will be generated.\n * @param [params.options.removeOriginal] - Whether or not to remove the original segmentation. Defaults to true.\n *\n * @returns A promise that resolves when the conversion is complete.\n */\nexport async function updateStackSegmentationState({\n  segmentationId,\n  toolGroupId,\n  imageIdReferenceMap,\n  options,\n}: {\n  segmentationId: string;\n  toolGroupId: string;\n  imageIdReferenceMap: Map<any, any>;\n  options?: {\n    removeOriginal?: boolean;\n  };\n}): Promise<void> {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (options?.removeOriginal) {\n    const data = segmentation.representationData\n      .LABELMAP as LabelmapSegmentationDataVolume;\n\n    if (cache.getVolume(data.volumeId)) {\n      cache.removeVolumeLoadObject(data.volumeId);\n    }\n\n    segmentation.representationData.LABELMAP = {\n      imageIdReferenceMap,\n    };\n  } else {\n    segmentation.representationData.LABELMAP = {\n      ...segmentation.representationData.LABELMAP,\n      imageIdReferenceMap,\n    };\n  }\n\n  await addSegmentationRepresentations(toolGroupId, [\n    {\n      segmentationId,\n      type: SegmentationRepresentations.Labelmap,\n    },\n  ]);\n\n  triggerSegmentationRender(toolGroupId);\n  eventTarget.addEventListenerOnce(Events.SEGMENTATION_RENDERED, () =>\n    triggerSegmentationDataModified(segmentationId)\n  );\n}\n\nfunction _getImageIdReferenceMapForStackSegmentation(\n  segmentationVolume: Types.IImageVolume\n) {\n  // There might be or might not be segmentationImageIds, if it is a volume\n  // segmentation converted from stack segmentation, there will be segmentationImageIds\n  // otherwise, if it is empty volume segmentation derived from\n  // a volume that is not a stack, there will be no segmentationImageIds\n\n  if (segmentationVolume.additionalDetails?.imageIdReferenceMap) {\n    // this means the segmentation volume is derived from a stack segmentation\n    // and we can use the imageIdReferenceMap from the additionalDetails\n    return segmentationVolume.additionalDetails.imageIdReferenceMap;\n  } else if (\n    segmentationVolume.referencedImageIds?.length &&\n    !segmentationVolume.referencedImageIds[0].startsWith('derived')\n  ) {\n    // this means the segmentation volume is derived from a stack segmentation\n    // and we can use the referencedImageIds from the segmentationVolume\n    const referencedImageIds = segmentationVolume.referencedImageIds;\n    const segmentationImageIds = segmentationVolume.imageIds;\n\n    return createImageIdReferenceMap(\n      referencedImageIds,\n      [...segmentationImageIds].reverse()\n    );\n  } else {\n    // check if the segmentation volume is derived from another volume and\n    // whether if that volume has imageIds\n    const referencedVolumeId = segmentationVolume.referencedVolumeId;\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n\n    if (!referencedVolume) {\n      throw new Error(\n        'Cannot convert volumetric segmentation without referenced volume to stack segmentation yet'\n      );\n    }\n\n    if (!referencedVolume?.imageIds?.length) {\n      throw new Error(\n        'Cannot convert volumetric segmentation without imageIds to stack segmentation yet'\n      );\n    }\n\n    if (referencedVolume.imageIds?.[0].startsWith('derived')) {\n      throw new Error(\n        `Cannot convert volume segmentation that is derived from another segmentation\n         to stack segmentation yet, include the additionalDetails.imageIdReferenceMap\n         in the volume segmentation in case you need it for the conversion`\n      );\n    }\n\n    // if the referenced volume has imageIds, and itself is not derived from\n    // another segmentation then we can use the imageIds from the referenced volume\n    const referencedImageIds = referencedVolume.imageIds;\n\n    let segmentationImageIdsToUse = segmentationVolume.imageIds;\n    if (!segmentationImageIdsToUse?.length) {\n      // If segmentation Ids don't exist it means that the segmentation is literally\n      // just a volume so we need to assume imageIds and decache it to the _imageCache\n      // so that it can be used for the conversion\n      segmentationImageIdsToUse =\n        segmentationVolume.convertToImageSlicesAndCache();\n    }\n\n    return createImageIdReferenceMap(\n      referencedImageIds,\n      [...segmentationImageIdsToUse].reverse()\n    );\n  }\n}\n","import { SegmentationRepresentations } from '../../../../enums';\nimport { computeAndAddRepresentation } from '../computeAndAddRepresentation';\nimport { computeLabelmapData } from './labelmapComputationStrategies';\nimport { PolySegConversionOptions } from '../../../../types';\n\n/**\n * Computes and adds the labelmap representation for a given segmentation.\n *\n * @param segmentationId - The ID of the segmentation.\n * @param options - Optional parameters for computing the labelmap representation.\n * @param options.segmentIndices - An array of segment indices to include in the labelmap representation.\n * @param options.segmentationRepresentationUID - The UID of the segmentation representation.\n * @returns A promise that resolves when the labelmap representation is computed and added.\n */\nexport function computeAndAddLabelmapRepresentation(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n) {\n  return computeAndAddRepresentation(\n    segmentationId,\n    SegmentationRepresentations.Labelmap,\n    () => computeLabelmapData(segmentationId, options),\n    () => undefined\n  );\n}\n","import { VolumeViewport, volumeLoader, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { getUniqueSegmentIndices } from '../../../../utilities/segmentation';\nimport { getSegmentation } from '../../segmentationState';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../../../types/LabelmapTypes';\nimport {\n  convertContourToStackLabelmap,\n  convertContourToVolumeLabelmap,\n} from './convertContourToLabelmap';\nimport { convertSurfaceToVolumeLabelmap } from './convertSurfaceToLabelmap';\nimport { computeStackSegmentationFromVolume } from '../../convertVolumeToStackSegmentation';\nimport { PolySegConversionOptions } from '../../../../types';\n\nexport type RawLabelmapData =\n  | LabelmapSegmentationDataVolume\n  | LabelmapSegmentationDataStack;\n\nexport async function computeLabelmapData(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n) {\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : getUniqueSegmentIndices(segmentationId);\n\n  let rawLabelmapData: RawLabelmapData;\n  const segmentation = getSegmentation(segmentationId);\n  const representationData = segmentation.representationData;\n\n  try {\n    if (representationData.CONTOUR) {\n      rawLabelmapData = await computeLabelmapFromContourSegmentation(\n        segmentationId,\n        {\n          segmentIndices,\n          ...options,\n        }\n      );\n    } else if (representationData.SURFACE) {\n      rawLabelmapData = await computeLabelmapFromSurfaceSegmentation(\n        segmentation.segmentationId,\n        {\n          segmentIndices,\n          ...options,\n        }\n      );\n    }\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n\n  if (!rawLabelmapData) {\n    throw new Error(\n      'Not enough data to convert to surface, currently only support converting volume labelmap to surface if available'\n    );\n  }\n\n  return rawLabelmapData;\n}\n\nasync function computeLabelmapFromContourSegmentation(\n  segmentationId,\n  options: PolySegConversionOptions = {}\n): Promise<LabelmapSegmentationDataVolume | LabelmapSegmentationDataStack> {\n  const isVolume = options.viewport instanceof VolumeViewport ?? true;\n\n  if (isVolume && !options.viewport) {\n    // Todo: we don't have support for volume viewport without providing the\n    // viewport, since we need to get the referenced volumeId from the viewport\n    // but we can alternatively provide the volumeId directly, or even better\n    // the target metadata for the volume (spacing, origin, dimensions, etc.)\n    // and then we can create the volume from that\n    throw new Error(\n      'Cannot compute labelmap from contour segmentation without providing the viewport'\n    );\n  }\n\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : getUniqueSegmentIndices(segmentationId);\n\n  const segmentation = getSegmentation(segmentationId);\n  const representationData = segmentation.representationData.CONTOUR;\n\n  const convertFunction = isVolume\n    ? convertContourToVolumeLabelmap\n    : convertContourToStackLabelmap;\n\n  const result = await convertFunction(representationData, {\n    segmentIndices,\n    segmentationRepresentationUID: options.segmentationRepresentationUID,\n    viewport: options.viewport,\n  });\n\n  return result;\n}\n\nasync function computeLabelmapFromSurfaceSegmentation(\n  segmentationId,\n  options: PolySegConversionOptions = {}\n): Promise<LabelmapSegmentationDataVolume | LabelmapSegmentationDataStack> {\n  const isVolume = options.viewport instanceof VolumeViewport ?? true;\n\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : getUniqueSegmentIndices(segmentationId);\n\n  const segmentation = getSegmentation(segmentationId);\n\n  const segmentsGeometryIds = new Map() as Map<number, string>;\n  const representationData = segmentation.representationData.SURFACE;\n  representationData.geometryIds.forEach((geometryId, segmentIndex) => {\n    if (segmentIndices.includes(segmentIndex)) {\n      segmentsGeometryIds.set(segmentIndex, geometryId);\n    }\n  });\n\n  if (isVolume && !options.viewport) {\n    // Todo: we don't have support for volume viewport without providing the\n    // viewport, since we need to get the referenced volumeId from the viewport\n    // but we can alternatively provide the volumeId directly, or even better\n    // the target metadata for the volume (spacing, origin, dimensions, etc.)\n    // and then we can create the volume from that\n    throw new Error(\n      'Cannot compute labelmap from surface segmentation without providing the viewport'\n    );\n  }\n\n  let segmentationVolume;\n  if (isVolume) {\n    const defaultActor = options.viewport.getDefaultActor();\n    const { uid: volumeId } = defaultActor;\n    segmentationVolume =\n      await volumeLoader.createAndCacheDerivedSegmentationVolume(volumeId);\n  } else {\n    // for stack we basically need to create a volume from the stack\n    // imageIds and then create a segmentation volume from that and finally\n    // convert the surface to a labelmap and later on convert the labelmap\n    // to a stack labelmap\n    const imageIds = (options.viewport as Types.IStackViewport).getImageIds();\n    const volumeId = 'generatedSegmentationVolumeId';\n    const volumeProps = utilities.generateVolumePropsFromImageIds(\n      imageIds,\n      volumeId\n    );\n\n    // we don't need the imageIds for the viewport (e.g., CT), but rather\n    // want to use the imageIds as a reference\n    delete volumeProps.imageIds;\n\n    segmentationVolume = await volumeLoader.createLocalSegmentationVolume(\n      {\n        ...volumeProps,\n        scalarData: volumeProps.scalarData as Types.PixelDataTypedArray,\n        referencedImageIds: imageIds,\n      },\n      volumeId\n    );\n  }\n\n  const result = await convertSurfaceToVolumeLabelmap(\n    { geometryIds: segmentsGeometryIds },\n    segmentationVolume\n  );\n\n  if (isVolume) {\n    return result;\n  }\n\n  // we need to convert the volume labelmap to a stack labelmap\n  const stackData = (await computeStackSegmentationFromVolume({\n    volumeId: segmentationVolume.volumeId,\n  })) as LabelmapSegmentationDataStack;\n\n  return stackData;\n}\n\nexport { computeLabelmapFromContourSegmentation };\n","import vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nimport vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\n\nimport {\n  cache,\n  getEnabledElementByIds,\n  StackViewport,\n  Types,\n  VolumeViewport,\n} from '@cornerstonejs/core';\n\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\nimport type {\n  LabelmapConfig,\n  LabelmapRenderingConfig,\n  LabelmapSegmentationData,\n} from '../../../types/LabelmapTypes';\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../../types/SegmentationStateTypes';\n\nimport addLabelmapToElement from './addLabelmapToElement';\nimport removeLabelmapFromElement from './removeLabelmapFromElement';\nimport { isVolumeSegmentation } from '../../segmentation/strategies/utils/stackVolumeCheck';\nimport { polySeg } from '../../../stateManagement/segmentation';\n\nconst MAX_NUMBER_COLORS = 255;\nconst labelMapConfigCache = new Map();\n\nfunction getRepresentationRenderingConfig() {\n  const cfun = vtkColorTransferFunction.newInstance();\n  const ofun = vtkPiecewiseFunction.newInstance();\n  ofun.addPoint(0, 0);\n  return {\n    ofun,\n    cfun,\n  };\n}\n\nlet polySegConversionInProgress = false;\n\n/**\n * For each viewport, and for each segmentation, set the segmentation for the viewport's enabled element\n * Initializes the global and viewport specific state for the segmentation in the\n * SegmentationStateManager.\n * @param toolGroup - the tool group that contains the viewports\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param renderImmediate - If true, there will be a render call after the labelmap is removed\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  renderImmediate = false\n): void {\n  _removeLabelmapFromToolGroupViewports(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n  SegmentationState.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  if (renderImmediate) {\n    const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      enabledElement.viewport.render();\n    });\n  }\n}\n\n/**\n * Checks if a segmentation data have the same frameOfReference as the series\n * displayed in a given viewport\n * @param viewport\n * @param referencedVolumeId volume id of the segmentation reference series\n * @returns\n */\nfunction isSameFrameOfReference(viewport, referencedVolumeId) {\n  // if the referencedVolumeId is not defined, we acted as before to not break\n  // applications as referencedVolumeId is inserted in this change\n  // Can modify that in the future commits\n  if (!referencedVolumeId) {\n    return true;\n  }\n  const defaultActor = viewport.getDefaultActor();\n  if (!defaultActor) {\n    return false;\n  }\n  const { uid: defaultActorUID } = defaultActor;\n  const volume = cache.getVolume(defaultActorUID);\n\n  if (volume) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    if (\n      referencedVolume &&\n      volume.metadata.FrameOfReferenceUID ===\n        referencedVolume.metadata.FrameOfReferenceUID\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * It takes the enabled element, the segmentation Id, and the configuration, and\n * it sets the segmentation for the enabled element as a labelmap\n * @param enabledElement - The cornerstone enabled element\n * @param segmentationId - The id of the segmentation to be rendered.\n * @param configuration - The configuration object for the labelmap.\n */\nasync function render(\n  viewport: Types.IVolumeViewport | Types.IStackViewport,\n  representation: ToolGroupSpecificRepresentation,\n  toolGroupConfig: SegmentationRepresentationConfig\n): Promise<void> {\n  const {\n    colorLUTIndex,\n    active,\n    segmentationId,\n    segmentationRepresentationUID,\n    segmentsHidden,\n    config: renderingConfig,\n  } = representation;\n\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    console.warn('No segmentation found for segmentationId: ', segmentationId);\n    return;\n  }\n\n  let labelmapData = segmentation.representationData[Representations.Labelmap];\n\n  let actorEntry = viewport.getActor(segmentationRepresentationUID);\n\n  if (\n    !labelmapData &&\n    polySeg.canComputeRequestedRepresentation(segmentationRepresentationUID) &&\n    !polySegConversionInProgress\n  ) {\n    // meaning the requested segmentation representationUID does not have\n    // labelmap data, BUT we might be able to request a conversion from\n    // another representation to labelmap\n    // we need to check if we can request polySEG to convert the other\n    // underlying representations to Surface\n    polySegConversionInProgress = true;\n\n    labelmapData = await polySeg.computeAndAddLabelmapRepresentation(\n      segmentationId,\n      {\n        segmentationRepresentationUID,\n        viewport,\n      }\n    );\n\n    if (!labelmapData) {\n      throw new Error(\n        `No labelmap data found for segmentationId ${segmentationId}.`\n      );\n    }\n\n    polySegConversionInProgress = false;\n  }\n\n  if (!labelmapData) {\n    return;\n  }\n\n  if (isVolumeSegmentation(labelmapData, viewport)) {\n    if (viewport instanceof StackViewport) {\n      return;\n    }\n\n    const { volumeId: labelmapUID } = labelmapData;\n\n    const labelmap = cache.getVolume(labelmapUID);\n\n    if (!labelmap) {\n      throw new Error(`No Labelmap found for volumeId: ${labelmapUID}`);\n    }\n\n    if (!isSameFrameOfReference(viewport, labelmapData?.referencedVolumeId)) {\n      return;\n    }\n\n    if (!actorEntry) {\n      // only add the labelmap to ToolGroup viewports if it is not already added\n      await _addLabelmapToViewport(\n        viewport,\n        labelmapData,\n        segmentationRepresentationUID\n      );\n    }\n\n    actorEntry = viewport.getActor(segmentationRepresentationUID);\n  } else {\n    if (viewport instanceof VolumeViewport) {\n      return;\n    }\n\n    // stack segmentation\n    const imageId = viewport.getCurrentImageId();\n    const { imageIdReferenceMap } = labelmapData;\n\n    // if the stack labelmap is not built for the current imageId that is\n    // rendered at the viewport then return\n    if (!imageIdReferenceMap.has(imageId)) {\n      return;\n    }\n\n    if (!actorEntry) {\n      // only add the labelmap to ToolGroup viewports if it is not already added\n      await _addLabelmapToViewport(\n        viewport,\n        labelmapData,\n        segmentationRepresentationUID\n      );\n    }\n\n    actorEntry = viewport.getActor(segmentationRepresentationUID);\n  }\n\n  if (!actorEntry) {\n    return;\n  }\n\n  const { cfun, ofun } = renderingConfig as LabelmapRenderingConfig;\n\n  const renderInactiveSegmentations =\n    toolGroupConfig.renderInactiveSegmentations;\n\n  _setLabelmapColorAndOpacity(\n    viewport.id,\n    actorEntry,\n    cfun,\n    ofun,\n    colorLUTIndex,\n    toolGroupConfig.representations[Representations.Labelmap],\n    representation,\n    active,\n    renderInactiveSegmentations,\n    segmentsHidden\n  );\n}\n\nfunction _setLabelmapColorAndOpacity(\n  viewportId: string,\n  actorEntry: Types.ActorEntry,\n  cfun: vtkColorTransferFunction,\n  ofun: vtkPiecewiseFunction,\n  colorLUTIndex: number,\n  toolGroupLabelmapConfig: LabelmapConfig,\n  segmentationRepresentation: ToolGroupSpecificRepresentation,\n  isActiveLabelmap: boolean,\n  renderInactiveSegmentations: boolean,\n  segmentsHidden: Set<number>\n): void {\n  const { segmentSpecificConfig, segmentationRepresentationSpecificConfig } =\n    segmentationRepresentation;\n\n  const segmentationRepresentationLabelmapConfig =\n    segmentationRepresentationSpecificConfig[Representations.Labelmap];\n\n  // Note: MAX_NUMBER_COLORS = 256 is needed because the current method to generate\n  // the default color table uses RGB.\n  const colorLUT = SegmentationState.getColorLUT(colorLUTIndex);\n  const numColors = Math.min(256, colorLUT.length);\n  const { uid: actorUID } = actorEntry;\n\n  // Note: right now outlineWidth and renderOutline are not configurable\n  // at the segment level, so we don't need to check for segment specific\n  // configuration in the loop, Todo: make them configurable at the segment level\n  const { outlineWidth, renderOutline, outlineOpacity } = _getLabelmapConfig(\n    toolGroupLabelmapConfig,\n    segmentationRepresentationLabelmapConfig,\n    isActiveLabelmap\n  );\n\n  // Todo: the below loop probably can be optimized so that we don't hit it\n  // unless a config has changed. Right now we get into the following loop\n  // even for brush drawing which does not makes sense\n  for (let i = 0; i < numColors; i++) {\n    const segmentIndex = i;\n    const segmentColor = colorLUT[segmentIndex];\n\n    const segmentSpecificLabelmapConfig =\n      segmentSpecificConfig[segmentIndex]?.[Representations.Labelmap];\n\n    const { fillAlpha, outlineWidth, renderFill, renderOutline } =\n      _getLabelmapConfig(\n        toolGroupLabelmapConfig,\n        segmentationRepresentationLabelmapConfig,\n        isActiveLabelmap,\n        segmentSpecificLabelmapConfig\n      );\n\n    const { forceOpacityUpdate, forceColorUpdate } =\n      _needsTransferFunctionUpdate(viewportId, actorUID, segmentIndex, {\n        fillAlpha,\n        renderFill,\n        renderOutline,\n        segmentColor,\n        outlineWidth,\n        segmentsHidden,\n      });\n\n    if (forceColorUpdate) {\n      cfun.addRGBPoint(\n        segmentIndex,\n        segmentColor[0] / MAX_NUMBER_COLORS,\n        segmentColor[1] / MAX_NUMBER_COLORS,\n        segmentColor[2] / MAX_NUMBER_COLORS\n      );\n    }\n\n    if (forceOpacityUpdate) {\n      if (renderFill) {\n        const segmentOpacity = segmentsHidden.has(segmentIndex)\n          ? 0\n          : (segmentColor[3] / 255) * fillAlpha;\n\n        ofun.removePoint(segmentIndex);\n        ofun.addPointLong(segmentIndex, segmentOpacity, 0.5, 1.0);\n      } else {\n        ofun.addPointLong(segmentIndex, 0.01, 0.5, 1.0);\n      }\n    }\n  }\n\n  const actor = actorEntry.actor as Types.VolumeActor;\n\n  actor.getProperty().setRGBTransferFunction(0, cfun);\n\n  ofun.setClamping(false);\n\n  actor.getProperty().setScalarOpacity(0, ofun);\n  actor.getProperty().setInterpolationTypeToNearest();\n  actor.getProperty().setUseLabelOutline(renderOutline);\n\n  // @ts-ignore - fix type in vtk\n  actor.getProperty().setLabelOutlineOpacity(outlineOpacity);\n\n  const { activeSegmentIndex } = SegmentationState.getSegmentation(\n    segmentationRepresentation.segmentationId\n  );\n\n  // create an array that contains all the segment indices and for the active\n  // segment index, use the activeSegmentOutlineWidthDelta, otherwise use the\n  // outlineWidth\n  // Pre-allocate the array with the required size to avoid dynamic resizing.\n  const outlineWidths = new Array(numColors - 1);\n\n  for (let i = 1; i < numColors; i++) {\n    // Start from 1 to skip the background segment index.\n    const isHidden = segmentsHidden.has(i);\n\n    if (isHidden) {\n      outlineWidths[i - 1] = 0;\n      continue;\n    }\n\n    outlineWidths[i - 1] =\n      i === activeSegmentIndex\n        ? outlineWidth + toolGroupLabelmapConfig.activeSegmentOutlineWidthDelta\n        : outlineWidth;\n  }\n\n  actor.getProperty().setLabelOutlineThickness(outlineWidths);\n\n  // Set visibility based on whether actor visibility is specifically asked\n  // to be turned on/off (on by default) AND whether is is in active but\n  // we are rendering inactive labelmap\n  const visible = isActiveLabelmap || renderInactiveSegmentations;\n  actor.setVisibility(visible);\n}\n\nfunction _getLabelmapConfig(\n  toolGroupLabelmapConfig: LabelmapConfig,\n  segmentationRepresentationLabelmapConfig: LabelmapConfig,\n  isActiveLabelmap: boolean,\n  segmentsLabelmapConfig?: LabelmapConfig\n) {\n  const segmentLabelmapConfig = segmentsLabelmapConfig || {};\n\n  const configToUse = {\n    ...toolGroupLabelmapConfig,\n    ...segmentationRepresentationLabelmapConfig,\n    ...segmentLabelmapConfig,\n  };\n\n  const fillAlpha = isActiveLabelmap\n    ? configToUse.fillAlpha\n    : configToUse.fillAlphaInactive;\n  const outlineWidth = isActiveLabelmap\n    ? configToUse.outlineWidthActive\n    : configToUse.outlineWidthInactive;\n\n  const renderFill = isActiveLabelmap\n    ? configToUse.renderFill\n    : configToUse.renderFillInactive;\n\n  const renderOutline = configToUse.renderOutline;\n\n  const outlineOpacity = isActiveLabelmap\n    ? configToUse.outlineOpacity\n    : configToUse.outlineOpacityInactive;\n\n  return {\n    fillAlpha,\n    outlineWidth,\n    renderFill,\n    renderOutline,\n    outlineOpacity,\n  };\n}\n\nfunction _needsTransferFunctionUpdate(\n  viewportId: string,\n  actorUID: string,\n  segmentIndex: number,\n  {\n    fillAlpha,\n    renderFill,\n    renderOutline,\n    segmentColor,\n    outlineWidth,\n    segmentsHidden,\n  }: {\n    fillAlpha: number;\n    renderFill: boolean;\n    renderOutline: boolean;\n    outlineWidth: number;\n    segmentColor: number[];\n    segmentsHidden: Set<number>;\n  }\n) {\n  const cacheUID = `${viewportId}-${actorUID}-${segmentIndex}`;\n  const oldConfig = labelMapConfigCache.get(cacheUID);\n\n  if (!oldConfig) {\n    labelMapConfigCache.set(cacheUID, {\n      fillAlpha,\n      renderFill,\n      renderOutline,\n      outlineWidth,\n      segmentColor: segmentColor.slice(), // Create a copy\n      segmentsHidden: new Set(segmentsHidden), // Create a copy\n    });\n\n    return {\n      forceOpacityUpdate: true,\n      forceColorUpdate: true,\n    };\n  }\n\n  const {\n    fillAlpha: oldFillAlpha,\n    renderFill: oldRenderFill,\n    renderOutline: oldRenderOutline,\n    outlineWidth: oldOutlineWidth,\n    segmentColor: oldSegmentColor,\n    segmentsHidden: oldSegmentsHidden,\n  } = oldConfig;\n\n  const forceColorUpdate =\n    oldSegmentColor[0] !== segmentColor[0] ||\n    oldSegmentColor[1] !== segmentColor[1] ||\n    oldSegmentColor[2] !== segmentColor[2];\n\n  const forceOpacityUpdate =\n    oldSegmentColor[3] !== segmentColor[3] ||\n    oldFillAlpha !== fillAlpha ||\n    oldRenderFill !== renderFill ||\n    oldRenderOutline !== renderOutline ||\n    oldOutlineWidth !== outlineWidth ||\n    oldSegmentsHidden.has(segmentIndex) !== segmentsHidden.has(segmentIndex);\n\n  // update the cache\n  labelMapConfigCache.set(cacheUID, {\n    fillAlpha,\n    renderFill,\n    renderOutline,\n    outlineWidth,\n    segmentColor: segmentColor.slice(), // Create a copy\n    segmentsHidden: new Set(segmentsHidden), // Create a copy\n  });\n\n  return {\n    forceOpacityUpdate,\n    forceColorUpdate,\n  };\n}\n\nfunction _removeLabelmapFromToolGroupViewports(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);\n  }\n\n  const { viewportsInfo } = toolGroup;\n\n  for (const viewportInfo of viewportsInfo) {\n    const { viewportId, renderingEngineId } = viewportInfo;\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    removeLabelmapFromElement(\n      enabledElement.viewport.element,\n      segmentationRepresentationUID\n    );\n  }\n}\n\nasync function _addLabelmapToViewport(\n  viewport: Types.IVolumeViewport | Types.IStackViewport,\n  labelmapData: LabelmapSegmentationData,\n  segmentationRepresentationUID\n): Promise<void> {\n  await addLabelmapToElement(\n    viewport.element,\n    labelmapData,\n    segmentationRepresentationUID\n  );\n}\n\nexport default {\n  getRepresentationRenderingConfig,\n  render,\n  removeSegmentationRepresentation,\n};\n\nexport {\n  getRepresentationRenderingConfig,\n  render,\n  removeSegmentationRepresentation,\n};\n","import SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\nimport { RepresentationPublicInput } from '../../../types';\nimport { getRepresentationRenderingConfig as getLabelmapRenderingConfig } from '../../../tools/displayTools/Labelmap/labelmapDisplay';\n\nexport function getRepresentationSpecificConfig(\n  representationInput: RepresentationPublicInput\n) {\n  const { type } = representationInput;\n\n  if (type === SegmentationRepresentations.Labelmap) {\n    return getLabelmapRenderingConfig();\n  } else {\n    return {};\n  }\n}\n","/**\n * Cornerstone Color LUT used for Segmentations\n */\nconst CORNERSTONE_COLOR_LUT = [\n  [0, 0, 0, 0],\n  [221, 84, 84, 255],\n  [77, 228, 121, 255],\n  [166, 70, 235, 255],\n  [189, 180, 116, 255],\n  [109, 182, 196, 255],\n  [204, 101, 157, 255],\n  [123, 211, 94, 255],\n  [93, 87, 218, 255],\n  [225, 128, 80, 255],\n  [73, 232, 172, 255],\n  [181, 119, 186, 255],\n  [176, 193, 112, 255],\n  [105, 153, 200, 255],\n  [208, 97, 120, 255],\n  [90, 215, 101, 255],\n  [135, 83, 222, 255],\n  [229, 178, 76, 255],\n  [122, 183, 181, 255],\n  [190, 115, 171, 255],\n  [149, 197, 108, 255],\n  [100, 118, 205, 255],\n  [212, 108, 93, 255],\n  [86, 219, 141, 255],\n  [183, 79, 226, 255],\n  [233, 233, 72, 255],\n  [118, 167, 187, 255],\n  [194, 111, 146, 255],\n  [116, 201, 104, 255],\n  [115, 96, 209, 255],\n  [216, 147, 89, 255],\n  [82, 223, 188, 255],\n  [230, 75, 224, 255],\n  [163, 184, 121, 255],\n  [114, 143, 191, 255],\n  [198, 107, 114, 255],\n  [99, 206, 122, 255],\n  [153, 92, 213, 255],\n  [220, 192, 85, 255],\n  [78, 215, 227, 255],\n  [234, 71, 173, 255],\n  [141, 188, 117, 255],\n  [110, 113, 195, 255],\n  [202, 128, 103, 255],\n  [95, 210, 157, 255],\n  [195, 88, 217, 255],\n  [206, 224, 81, 255],\n  [74, 166, 231, 255],\n  [185, 120, 139, 255],\n  [113, 192, 113, 255],\n  [133, 106, 199, 255],\n  [207, 162, 98, 255],\n  [91, 214, 198, 255],\n  [221, 84, 198, 255],\n  [159, 228, 77, 255],\n  [70, 111, 235, 255],\n  [189, 119, 116, 255],\n  [109, 196, 138, 255],\n  [165, 101, 204, 255],\n  [211, 201, 94, 255],\n  [87, 191, 218, 255],\n  [225, 80, 153, 255],\n  [106, 232, 73, 255],\n  [124, 119, 186, 255],\n  [193, 142, 112, 255],\n  [105, 200, 168, 255],\n  [203, 97, 208, 255],\n  [184, 215, 90, 255],\n  [83, 147, 222, 255],\n  [229, 76, 101, 255],\n  [122, 183, 130, 255],\n  [146, 115, 190, 255],\n  [197, 171, 108, 255],\n  [100, 205, 205, 255],\n  [212, 93, 177, 255],\n  [141, 219, 86, 255],\n  [79, 97, 226, 255],\n  [233, 99, 72, 255],\n  [118, 187, 150, 255],\n  [173, 111, 194, 255],\n  [197, 201, 104, 255],\n  [96, 171, 209, 255],\n  [216, 89, 137, 255],\n  [94, 223, 82, 255],\n  [107, 75, 230, 255],\n  [184, 153, 121, 255],\n  [114, 191, 175, 255],\n  [198, 107, 191, 255],\n  [166, 206, 99, 255],\n  [92, 132, 213, 255],\n  [220, 85, 91, 255],\n  [78, 227, 115, 255],\n  [159, 71, 234, 255],\n  [188, 176, 117, 255],\n  [110, 185, 195, 255],\n  [202, 103, 161, 255],\n  [129, 210, 95, 255],\n  [88, 88, 217, 255],\n  [224, 123, 81, 255],\n  [74, 231, 166, 255],\n  [177, 120, 185, 255],\n  [179, 192, 113, 255],\n  [106, 156, 199, 255],\n  [207, 98, 125, 255],\n  [91, 214, 96, 255],\n  [130, 84, 221, 255],\n  [228, 171, 77, 255],\n  [70, 235, 221, 255],\n  [189, 116, 174, 255],\n  [153, 196, 109, 255],\n  [101, 123, 204, 255],\n  [211, 104, 94, 255],\n  [87, 218, 136, 255],\n  [177, 80, 225, 255],\n  [232, 225, 73, 255],\n  [119, 169, 186, 255],\n  [193, 112, 149, 255],\n  [121, 200, 105, 255],\n  [111, 97, 208, 255],\n  [215, 142, 90, 255],\n  [83, 222, 181, 255],\n  [229, 76, 229, 255],\n  [165, 183, 122, 255],\n  [115, 146, 190, 255],\n  [197, 108, 119, 255],\n  [100, 205, 118, 255],\n  [148, 93, 212, 255],\n  [219, 186, 86, 255],\n  [79, 220, 226, 255],\n  [233, 72, 179, 255],\n  [144, 187, 118, 255],\n  [111, 118, 194, 255],\n  [201, 124, 104, 255],\n  [96, 209, 153, 255],\n  [189, 89, 216, 255],\n  [211, 223, 82, 255],\n  [75, 172, 230, 255],\n  [184, 121, 142, 255],\n  [117, 191, 114, 255],\n  [130, 107, 198, 255],\n  [206, 157, 99, 255],\n  [92, 213, 193, 255],\n  [220, 85, 203, 255],\n  [165, 227, 78, 255],\n  [71, 118, 234, 255],\n  [188, 117, 117, 255],\n  [110, 195, 135, 255],\n  [161, 103, 202, 255],\n  [210, 195, 95, 255],\n  [88, 195, 217, 255],\n  [224, 81, 158, 255],\n  [113, 231, 74, 255],\n  [123, 120, 185, 255],\n  [192, 139, 113, 255],\n  [106, 199, 164, 255],\n  [198, 98, 207, 255],\n  [188, 214, 91, 255],\n  [84, 153, 221, 255],\n  [228, 77, 108, 255],\n  [70, 235, 84, 255],\n  [143, 116, 189, 255],\n  [196, 167, 109, 255],\n  [101, 204, 199, 255],\n  [211, 94, 182, 255],\n  [147, 218, 87, 255],\n  [80, 104, 225, 255],\n  [232, 93, 73, 255],\n  [119, 186, 147, 255],\n  [170, 112, 193, 255],\n  [200, 200, 105, 255],\n  [97, 175, 208, 255],\n  [215, 90, 142, 255],\n  [100, 222, 83, 255],\n  [101, 76, 229, 255],\n  [183, 150, 122, 255],\n  [115, 190, 171, 255],\n  [197, 108, 194, 255],\n  [170, 205, 100, 255],\n  [93, 138, 212, 255],\n  [219, 86, 97, 255],\n  [79, 226, 110, 255],\n  [153, 72, 233, 255],\n  [187, 173, 118, 255],\n  [111, 187, 194, 255],\n  [201, 104, 165, 255],\n  [134, 209, 96, 255],\n  [89, 95, 216, 255],\n  [223, 117, 82, 255],\n  [75, 230, 159, 255],\n  [174, 121, 184, 255],\n  [182, 191, 114, 255],\n  [107, 160, 198, 255],\n  [206, 99, 130, 255],\n  [92, 213, 92, 255],\n  [124, 85, 220, 255],\n  [227, 165, 78, 255],\n  [71, 234, 214, 255],\n  [188, 117, 176, 255],\n  [156, 195, 110, 255],\n  [103, 128, 202, 255],\n  [210, 100, 95, 255],\n  [88, 217, 131, 255],\n  [170, 81, 224, 255],\n  [231, 218, 74, 255],\n  [120, 172, 185, 255],\n  [192, 113, 153, 255],\n  [125, 199, 106, 255],\n  [107, 98, 207, 255],\n  [214, 137, 91, 255],\n  [84, 221, 175, 255],\n  [222, 77, 228, 255],\n  [194, 235, 70, 255],\n  [116, 149, 189, 255],\n  [196, 109, 123, 255],\n  [101, 204, 114, 255],\n  [143, 94, 211, 255],\n  [218, 180, 87, 255],\n  [80, 225, 225, 255],\n  [232, 73, 186, 255],\n  [147, 186, 119, 255],\n  [112, 122, 193, 255],\n  [200, 121, 105, 255],\n  [97, 208, 148, 255],\n  [184, 90, 215, 255],\n  [216, 222, 83, 255],\n  [76, 178, 229, 255],\n  [183, 122, 145, 255],\n  [121, 190, 115, 255],\n  [126, 108, 197, 255],\n  [205, 153, 100, 255],\n  [93, 212, 187, 255],\n  [219, 86, 208, 255],\n  [171, 226, 79, 255],\n  [72, 126, 233, 255],\n  [187, 118, 121, 255],\n  [111, 194, 132, 255],\n  [157, 104, 201, 255],\n  [209, 190, 96, 255],\n  [89, 200, 216, 255],\n  [223, 82, 164, 255],\n  [120, 230, 75, 255],\n  [121, 121, 184, 255],\n  [191, 136, 114, 255],\n  [107, 198, 160, 255],\n  [192, 99, 206, 255],\n  [193, 213, 92, 255],\n  [85, 158, 220, 255],\n  [227, 78, 115, 255],\n  [71, 234, 78, 255],\n  [141, 117, 188, 255],\n  [195, 163, 110, 255],\n  [103, 202, 194, 255],\n  [210, 95, 186, 255],\n  [153, 217, 88, 255],\n  [81, 111, 224, 255],\n];\n\nexport default CORNERSTONE_COLOR_LUT;\n","import { state } from '../store';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nconst VIEWPORT_ELEMENT = 'viewport-element';\n\n/**\n * Returns the SVG drawing helper for the given HTML element.\n * @param element - The HTML element to get the SVG drawing helper for.\n * @private\n */\nfunction getSvgDrawingHelper(element: HTMLDivElement): SVGDrawingHelper {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId, renderingEngineId } = enabledElement;\n  const canvasHash = `${viewportId}:${renderingEngineId}`;\n  const svgLayerElement = _getSvgLayer(element);\n\n  // Reset touched\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n    state.svgNodeCache[canvasHash][cacheKey].touched = false;\n  });\n\n  return {\n    svgLayerElement: svgLayerElement,\n    svgNodeCacheForCanvas: state.svgNodeCache,\n    getSvgNode: getSvgNode.bind(this, canvasHash),\n    appendNode: appendNode.bind(this, svgLayerElement, canvasHash),\n    setNodeTouched: setNodeTouched.bind(this, canvasHash),\n    clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),\n  };\n}\n\n/**\n *\n * @param element\n * @private\n */\nfunction _getSvgLayer(element) {\n  const viewportElement = `.${VIEWPORT_ELEMENT}`;\n  const internalDivElement = element.querySelector(viewportElement);\n\n  // Using :scope to make sure the right svg layer is selected otherwise it\n  // may select one from a nested viewport (eg: AdvancedMagnifyTool).\n  const svgLayer = internalDivElement.querySelector(':scope > .svg-layer');\n\n  return svgLayer;\n}\n\nfunction getSvgNode(canvasHash, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\n    return state.svgNodeCache[canvasHash][cacheKey].domRef;\n  }\n}\n\nfunction appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return null;\n  }\n\n  state.svgNodeCache[canvasHash][cacheKey] = {\n    touched: true,\n    domRef: svgNode,\n  };\n\n  svgLayerElement.appendChild(svgNode);\n}\n\nfunction setNodeTouched(canvasHash, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\n    state.svgNodeCache[canvasHash][cacheKey].touched = true;\n  }\n}\n\nfunction clearUntouched(svgLayerElement, canvasHash) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n    const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];\n\n    if (!cacheEntry.touched && cacheEntry.domRef) {\n      svgLayerElement.removeChild(cacheEntry.domRef);\n      delete state.svgNodeCache[canvasHash][cacheKey];\n    }\n  });\n}\n\nexport default getSvgDrawingHelper;\n","import getSvgDrawingHelper from './getSvgDrawingHelper';\n\nfunction draw(\n  element: HTMLDivElement,\n  fn: (svgDrawingElement: any) => any\n): void {\n  const svgDrawingHelper = getSvgDrawingHelper(element);\n\n  // Save...\n  fn(svgDrawingHelper);\n  // Restore...\n\n  svgDrawingHelper.clearUntouched();\n}\n\nexport default draw;\n","import { ToolGroupManager } from '../store';\nimport { ToolModes } from '../enums';\nimport { getEnabledElement } from '@cornerstonejs/core';\n\ntype ModesFilter = Array<ToolModes>;\n\n/**\n * Finds the enabled element, and iterates over the tools inside its\n * toolGroup. Returns the list of tool instances that are valid based\n * on the provided tool mode.\n *\n * @param element Canvas element\n * @param modesFilter tool modes: active, passive, enabled, disabled\n * @returns enabled tool instances\n */\nexport default function getToolsWithModesForElement(\n  element: HTMLDivElement,\n  modesFilter: ModesFilter\n) {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return [];\n  }\n\n  const enabledTools = [];\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    /* filter out tools that don't have options */\n    if (!toolOptions) {\n      continue;\n    }\n\n    if (modesFilter.includes(toolOptions.mode)) {\n      const toolInstance = toolGroup.getToolInstance(toolName);\n      enabledTools.push(toolInstance);\n    }\n  }\n\n  return enabledTools;\n}\n","import {\n  getEnabledElement,\n  triggerEvent,\n  getRenderingEngine,\n} from '@cornerstonejs/core';\nimport { Events, ToolModes } from '../enums';\nimport { draw as drawSvg } from '../drawingSvg';\nimport getToolsWithModesForElement from './getToolsWithModesForElement';\nimport { AnnotationRenderedEventDetail } from '../types/EventTypes';\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * AnnotationRenderingEngine is a class that is responsible for rendering\n * annotations defined in the renderAnnotation method of annotation tools on the page.\n * It mimics the RenderingEngine in the Cornerstone Core. Here it uses requestAnimationFrame\n * is used to render annotations by calling renderAnnotations() on each enabled tool. Note: This\n * is a Singleton class and should not be instantiated directly. To trigger\n * an annotation render for an HTML element containing a viewport you can use\n *\n * ```\n * triggerAnnotationRender(element)\n * ```\n */\nclass AnnotationRenderingEngine {\n  public hasBeenDestroyed: boolean;\n  private _needsRender: Set<HTMLDivElement> = new Set();\n  private _animationFrameSet = false;\n  private _animationFrameHandle: number | null = null;\n  private _viewportElements: Map<string, HTMLDivElement>;\n\n  constructor() {\n    this._viewportElements = new Map();\n  }\n\n  /**\n   * Add the viewport's HTMLDivElement to the viewports for rendering. This method\n   * just informs the annotationRenderingEngine about the viewport and\n   * does not initiate a render.\n   * @param viewportId - Viewport Unique identifier\n   * @param element - HTMLDivElement\n   */\n  public addViewportElement(viewportId: string, element: HTMLDivElement) {\n    this._viewportElements.set(viewportId, element);\n  }\n\n  /**\n   * Remove the viewport's HTMLDivElement from subsequent annotation renders\n   * @param viewportId - Viewport Unique identifier\n   */\n  public removeViewportElement(viewportId: string, element: HTMLDivElement) {\n    this._viewportElements.delete(viewportId);\n\n    // delete element from needsRender if element exist\n    this._needsRender.delete(element);\n\n    // I don' think there is any disadvantage to canceling the animation frame\n    // and resetting the flags on viewport's element removal, since the removeVIewportElement\n    // might be as a result of reEnabling the element (in re-enable we disable first), hence the need to render the\n    // new one while removing the old one\n    this._reset();\n  }\n\n  /**\n   * It tells the AnnotationRenderingEngine to render the viewport element the next\n   * time it renders.\n   *\n   * @param element - The element to render.\n   */\n  public renderViewport(element: HTMLDivElement): void {\n    this._setViewportsToBeRenderedNextFrame([element]);\n  }\n\n  /**\n   * _throwIfDestroyed Throws an error if trying to interact with the `RenderingEngine`\n   * instance after its `destroy` method has been called.\n   */\n  private _throwIfDestroyed() {\n    if (this.hasBeenDestroyed) {\n      throw new Error(\n        'this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.'\n      );\n    }\n  }\n\n  private _renderFlaggedViewports = () => {\n    this._throwIfDestroyed();\n\n    const elements = Array.from(this._viewportElements.values());\n\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      if (this._needsRender.has(element)) {\n        this._triggerRender(element);\n\n        // This viewport has been rendered, we can remove it from the set\n        this._needsRender.delete(element);\n\n        // If there is nothing left that is flagged for rendering, stop here\n        // and allow RAF to be called again\n        if (this._needsRender.size === 0) {\n          break;\n        }\n      }\n    }\n\n    this._animationFrameSet = false;\n    this._animationFrameHandle = null;\n\n    // Call render again which will use RAF to call this function asynchronously\n    // if there is any viewport that needs to be rendered because when\n    // `triggerRender` is called inside the render loop a listener can flag new\n    // viewports that need to be rendered and some of the viewports that were\n    // already rendered can be added back to `_needsRender`.\n    this._render();\n  };\n\n  private _setAllViewportsToBeRenderedNextFrame() {\n    const elements = [...this._viewportElements.values()];\n\n    elements.forEach((element) => {\n      this._needsRender.add(element);\n    });\n\n    this._renderFlaggedViewports();\n  }\n\n  private _setViewportsToBeRenderedNextFrame(elements: HTMLDivElement[]) {\n    const elementsEnabled = [...this._viewportElements.values()];\n\n    // Add the viewports to the set of flagged viewports\n    elements.forEach((element) => {\n      // only enabledElement need to render\n      if (elementsEnabled.indexOf(element) !== -1) {\n        this._needsRender.add(element);\n      }\n    });\n\n    // Render any flagged viewports\n    this._render();\n  }\n\n  /**\n   * _render Sets up animation frame if necessary\n   */\n  private _render() {\n    // If we have viewports that need rendering and we have not already\n    // set the RAF callback to run on the next frame.\n    if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n      this._animationFrameHandle = window.requestAnimationFrame(\n        this._renderFlaggedViewports\n      );\n\n      // Set the flag that we have already set up the next RAF call.\n      this._animationFrameSet = true;\n    }\n  }\n\n  _triggerRender(element) {\n    const enabledElement = getEnabledElement(element);\n\n    if (!enabledElement) {\n      // Happens during testing, and isn't an issue as it just means there\n      // is overlap between shutdown and re-render\n      // console.warn('Element has been disabled');\n      return;\n    }\n\n    const renderingEngine = getRenderingEngine(\n      enabledElement.renderingEngineId\n    );\n    if (!renderingEngine) {\n      console.warn('rendering Engine has been destroyed');\n      return;\n    }\n\n    const enabledTools = getToolsWithModesForElement(element, [\n      Active,\n      Passive,\n      Enabled,\n    ]);\n\n    const { renderingEngineId, viewportId } = enabledElement;\n    const eventDetail: AnnotationRenderedEventDetail = {\n      element,\n      renderingEngineId,\n      viewportId,\n    };\n\n    // const enabledToolsWithAnnotations = enabledTools.filter((tool) => {\n    //   const annotations = getAnnotations(tool.getToolName(), {FrameOfReferenceUID});\n    //   return annotations && annotations.length;\n    // });\n\n    drawSvg(element, (svgDrawingHelper) => {\n      let anyRendered = false;\n      const handleDrawSvg = (tool) => {\n        if (tool.renderAnnotation) {\n          const rendered = tool.renderAnnotation(\n            enabledElement,\n            svgDrawingHelper\n          );\n          anyRendered = anyRendered || rendered;\n        }\n      };\n\n      /**\n       * We should be able to filter tools that don't have annotations, but\n       * currently some of tools have renderAnnotation method BUT\n       * don't keep annotation in the state, so if we do so, the tool will not be\n       * rendered.\n       */\n      enabledTools.forEach(handleDrawSvg);\n\n      if (anyRendered) {\n        triggerEvent(element, Events.ANNOTATION_RENDERED, { ...eventDetail });\n      }\n    });\n  }\n\n  /**\n   * _reset Resets the `RenderingEngine`\n   */\n  private _reset() {\n    window.cancelAnimationFrame(this._animationFrameHandle);\n\n    this._needsRender.clear();\n    this._animationFrameSet = false;\n    this._animationFrameHandle = null;\n\n    this._setAllViewportsToBeRenderedNextFrame();\n  }\n}\n\nconst annotationRenderingEngine = new AnnotationRenderingEngine();\n\n/**\n * It triggers the rendering of the annotations for the given HTML element using\n * the `AnnotationRenderingEngine`\n * @param element - The element to render the annotation on.\n */\nfunction triggerAnnotationRender(element: HTMLDivElement): void {\n  annotationRenderingEngine.renderViewport(element);\n}\n\nexport { annotationRenderingEngine, triggerAnnotationRender };\n\nexport default triggerAnnotationRender;\n","import type { Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\n\nexport function triggerAnnotationRenderForViewportIds(\n  renderingEngine: Types.IRenderingEngine,\n  viewportIdsToRender: string[]\n): void {\n  if (!viewportIdsToRender.length || !renderingEngine) {\n    return;\n  }\n\n  viewportIdsToRender.forEach((viewportId) => {\n    const viewport = renderingEngine.getViewport(viewportId);\n    if (!viewport) {\n      console.warn(`Viewport not available for ${viewportId}`);\n      return;\n    }\n    const { element } = viewport;\n    triggerAnnotationRender(element);\n  });\n}\n\nexport default triggerAnnotationRenderForViewportIds;\n","import {\n  SegmentationRepresentationConfig,\n  RepresentationPublicInput,\n} from '../../types/SegmentationStateTypes';\nimport { getToolGroup } from '../../store/ToolGroupManager';\n\nimport { addSegmentationRepresentation } from './addSegmentationRepresentation';\n\n/**\n * Set the specified segmentation representations on the viewports of the specified\n * toolGroup. It accepts a second argument which is a toolGroup specific representation\n * configuration.\n *\n * @param toolGroupId - The Id of the toolGroup to add the segmentation representations to\n * @param representationInputArray - An array of segmentation representations to add to the toolGroup\n * @param toolGroupSpecificRepresentationConfig - The toolGroup specific configuration\n * for the segmentation representations\n */\nasync function addSegmentationRepresentations(\n  toolGroupId: string,\n  representationInputArray: RepresentationPublicInput[],\n  toolGroupSpecificRepresentationConfig?: SegmentationRepresentationConfig\n): Promise<string[]> {\n  // Check if there exists a toolGroup with the toolGroupId\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (!toolGroup) {\n    throw new Error(`No tool group found for toolGroupId: ${toolGroupId}`);\n  }\n\n  const promises = representationInputArray.map((representationInput) => {\n    return addSegmentationRepresentation(\n      toolGroupId,\n      representationInput,\n      toolGroupSpecificRepresentationConfig\n    );\n  });\n\n  const segmentationRepresentationUIDs = await Promise.all(promises);\n\n  return segmentationRepresentationUIDs;\n}\n\nexport default addSegmentationRepresentations;\n","import { getRenderingEngine, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  SegmentationRepresentationConfig,\n  RepresentationPublicInput,\n  ToolGroupSpecificRepresentation,\n  RepresentationPublicInputOptions,\n} from '../../types/SegmentationStateTypes';\nimport * as SegmentationConfig from './config/segmentationConfig';\nimport {\n  addSegmentationRepresentation as addSegmentationRepresentationToState,\n  getNextColorLUTIndex,\n  addColorLUT,\n} from './segmentationState';\nimport { getRepresentationSpecificConfig } from './helpers/getRepresentationSpecificConfig';\nimport CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\nimport { SegmentationRepresentations } from '../../enums';\n\nasync function addSegmentationRepresentation(\n  toolGroupId: string,\n  representationInput: RepresentationPublicInput,\n  toolGroupSpecificConfig?: SegmentationRepresentationConfig\n): Promise<string> {\n  const { segmentationId, options = {} as RepresentationPublicInputOptions } =\n    representationInput;\n\n  const segmentationRepresentationUID =\n    representationInput.options?.segmentationRepresentationUID ||\n    utilities.uuidv4();\n\n  // Todo: make segmentsHidden also an option that can get passed by\n  // the user\n  const segmentsHidden = new Set() as Set<number>;\n\n  const colorLUTIndexToUse = getColorLUTIndex(options);\n\n  const toolGroupSpecificRepresentation: ToolGroupSpecificRepresentation = {\n    segmentationId,\n    segmentationRepresentationUID,\n    type: representationInput.type,\n    segmentsHidden,\n    colorLUTIndex: colorLUTIndexToUse,\n    active: true,\n    segmentationRepresentationSpecificConfig: {},\n    segmentSpecificConfig: {},\n    config: getRepresentationSpecificConfig(representationInput),\n    polySeg: options.polySeg,\n  };\n\n  // Update the toolGroup specific configuration\n  if (toolGroupSpecificConfig) {\n    // Since setting configuration on toolGroup will trigger a segmentationRepresentation\n    // update event, we don't want to trigger the event twice, so we suppress\n    // the first one\n    const currentToolGroupConfig =\n      SegmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n\n    const mergedConfig = utilities.deepMerge(\n      currentToolGroupConfig,\n      toolGroupSpecificConfig\n    );\n\n    SegmentationConfig.setToolGroupSpecificConfig(toolGroupId, {\n      renderInactiveSegmentations:\n        mergedConfig.renderInactiveSegmentations || true,\n      representations: {\n        ...mergedConfig.representations,\n      },\n    });\n  }\n\n  addSegmentationRepresentationToState(\n    toolGroupId,\n    toolGroupSpecificRepresentation\n  );\n\n  if (representationInput.type === SegmentationRepresentations.Contour) {\n    getToolGroup(toolGroupId)\n      .getViewportsInfo()\n      .forEach(({ viewportId, renderingEngineId }) => {\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n        triggerAnnotationRenderForViewportIds(renderingEngine, [viewportId]);\n      });\n  }\n\n  return segmentationRepresentationUID;\n}\n\nfunction getColorLUTIndex(options = {} as RepresentationPublicInputOptions) {\n  const colorLUTOrIndexInput = options.colorLUTOrIndex;\n  let colorLUTIndexToUse;\n\n  if (typeof colorLUTOrIndexInput === 'number') {\n    colorLUTIndexToUse = colorLUTOrIndexInput;\n  } else {\n    const nextIndex = getNextColorLUTIndex();\n    const colorLUTToAdd = Array.isArray(colorLUTOrIndexInput)\n      ? colorLUTOrIndexInput\n      : CORNERSTONE_COLOR_LUT;\n    addColorLUT(colorLUTToAdd as Types.ColorLUT, nextIndex);\n    colorLUTIndexToUse = nextIndex;\n  }\n  return colorLUTIndexToUse;\n}\n\nexport { addSegmentationRepresentation };\n","import {\n  volumeLoader,\n  utilities as csUtils,\n  eventTarget,\n  cache,\n} from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport addSegmentationRepresentations from './addSegmentationRepresentations';\nimport { triggerSegmentationRender } from '../../utilities/segmentation';\nimport { getSegmentation } from './segmentationState';\nimport { LabelmapSegmentationDataStack } from '../../types/LabelmapTypes';\nimport { triggerSegmentationDataModified } from './triggerSegmentationEvents';\n\nasync function computeVolumeSegmentationFromStack({\n  imageIdReferenceMap,\n  options,\n}: {\n  imageIdReferenceMap: Map<string, string>;\n  options?: {\n    volumeId?: string;\n  };\n}): Promise<{ volumeId: string }> {\n  const segmentationImageIds = Array.from(imageIdReferenceMap.values());\n\n  const additionalDetails = {\n    imageIdReferenceMap,\n  };\n\n  const volumeId = options?.volumeId ?? csUtils.uuidv4();\n\n  await volumeLoader.createAndCacheVolumeFromImages(\n    volumeId,\n    segmentationImageIds,\n    {\n      additionalDetails,\n    }\n  );\n\n  return { volumeId };\n}\n\n/**\n * Converts a stack-based segmentation to a volume-based segmentation.\n *\n * @param params - The parameters for the conversion.\n * @param params.segmentationId - The segmentationId to convert.\n * @param [params.options] - The conversion options.\n * @param params.options.toolGroupId - The new toolGroupId to use for the segmentation.\n * @param [params.options.volumeId] - the new volumeId to use for the segmentation. If not provided, a new ID will be generated.\n * @param [params.options.newSegmentationId] - the new segmentationId to use for the segmentation. If not provided, a new ID will be generated.\n * @param [params.options.removeOriginal] - Whether or not to remove the original segmentation. Defaults to true.\n *\n * @returns A promise that resolves when the conversion is complete.\n */\nasync function convertStackToVolumeSegmentation({\n  segmentationId,\n  options,\n}: {\n  segmentationId: string;\n  options?: {\n    toolGroupId: string;\n    volumeId?: string;\n    removeOriginal?: boolean;\n  };\n}): Promise<void> {\n  const segmentation = getSegmentation(segmentationId);\n\n  const data = segmentation.representationData\n    .LABELMAP as LabelmapSegmentationDataStack;\n\n  const { volumeId } = await computeVolumeSegmentationFromStack({\n    imageIdReferenceMap: data.imageIdReferenceMap,\n    options,\n  });\n\n  await updateSegmentationState({\n    segmentationId,\n    toolGroupId: options.toolGroupId,\n    options,\n    volumeId,\n  });\n}\n\n// This function is responsible for updating the segmentation state\nasync function updateSegmentationState({\n  segmentationId,\n  toolGroupId,\n  volumeId,\n  options,\n}: {\n  segmentationId: string;\n  toolGroupId: string;\n  volumeId: string;\n  options?: {\n    removeOriginal?: boolean;\n  };\n}): Promise<void> {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (options?.removeOriginal) {\n    const data = segmentation.representationData\n      .LABELMAP as LabelmapSegmentationDataStack;\n\n    const imageIdReferenceMap = data.imageIdReferenceMap;\n\n    Array.from(imageIdReferenceMap.values()).forEach((imageId) => {\n      cache.removeImageLoadObject(imageId);\n    });\n\n    segmentation.representationData.LABELMAP = {\n      volumeId,\n    };\n  } else {\n    segmentation.representationData.LABELMAP = {\n      ...segmentation.representationData.LABELMAP,\n      volumeId,\n    };\n  }\n\n  await addSegmentationRepresentations(toolGroupId, [\n    {\n      segmentationId,\n      type: SegmentationRepresentations.Labelmap,\n    },\n  ]);\n\n  triggerSegmentationRender(toolGroupId);\n  // Note: It is crucial to trigger the data modified event. This ensures that the\n  // old texture is updated to the GPU, especially in scenarios where it may not be getting updated.\n  eventTarget.addEventListenerOnce(Events.SEGMENTATION_RENDERED, () =>\n    triggerSegmentationDataModified(segmentationId)\n  );\n}\n\nexport { convertStackToVolumeSegmentation, computeVolumeSegmentationFromStack };\n","import {\n  Types,\n  cache,\n  eventTarget,\n  triggerEvent,\n  Enums,\n} from '@cornerstonejs/core';\nimport { getWebWorkerManager } from '@cornerstonejs/core';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../../../types/LabelmapTypes';\nimport { computeVolumeSegmentationFromStack } from '../../convertStackToVolumeSegmentation';\nimport { WorkerTypes } from '../../../../enums';\n\nconst workerManager = getWebWorkerManager();\n\nconst triggerWorkerProgress = (eventTarget, progress) => {\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n    progress,\n    type: WorkerTypes.POLYSEG_LABELMAP_TO_SURFACE,\n  });\n};\n\n/**\n * Converts a labelmap representation to a surface representation.\n *\n * @param labelmapRepresentationData - The labelmap segmentation data.\n * @param segmentIndex - The index of the segment to convert.\n * @param isVolume - Optional flag indicating whether the labelmap is a volume or a stack. Default is true.\n * @returns A promise that resolves to the surface data.\n */\nexport async function convertLabelmapToSurface(\n  labelmapRepresentationData: LabelmapSegmentationData,\n  segmentIndex: number,\n  isVolume = true\n): Promise<Types.SurfaceData> {\n  let volumeId;\n  if (isVolume) {\n    volumeId = (labelmapRepresentationData as LabelmapSegmentationDataVolume)\n      .volumeId;\n  } else {\n    const { imageIdReferenceMap } =\n      labelmapRepresentationData as LabelmapSegmentationDataStack;\n    ({ volumeId } = await computeVolumeSegmentationFromStack({\n      imageIdReferenceMap,\n    }));\n  }\n\n  const volume = cache.getVolume(volumeId);\n\n  const scalarData = volume.getScalarData();\n  const { dimensions, spacing, origin, direction } = volume;\n\n  triggerWorkerProgress(eventTarget, 0);\n\n  const results = await workerManager.executeTask(\n    'polySeg',\n    'convertLabelmapToSurface',\n    {\n      scalarData,\n      dimensions,\n      spacing,\n      origin,\n      direction,\n      segmentIndex,\n    },\n    {\n      callbacks: [\n        (progress) => {\n          triggerWorkerProgress(eventTarget, progress);\n        },\n      ],\n    }\n  );\n\n  triggerWorkerProgress(eventTarget, 1);\n\n  return results;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport {\n  ContourSegmentationData,\n  PolySegConversionOptions,\n} from '../../../../types';\nimport { getUniqueSegmentIndices } from '../../../../utilities/segmentation';\nimport { getSegmentation } from '../../segmentationState';\nimport { convertContourToSurface } from './convertContourToSurface';\nimport { createAndCacheSurfacesFromRaw } from './createAndCacheSurfacesFromRaw';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../../../tools/segmentation/strategies/utils/stackVolumeCheck';\nimport { convertLabelmapToSurface } from './convertLabelmapToSurface';\n\nexport type RawSurfacesData = {\n  segmentIndex: number;\n  data: Types.SurfaceData;\n}[];\n\n/**\n * Computes surface data for a given segmentation.\n * @param segmentationId - The ID of the segmentation.\n * @param options - Additional options for surface computation.\n * @returns A promise that resolves to the computed surface data.\n * @throws An error if there is no surface data available for the segmentation.\n */\nexport async function computeSurfaceData(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n) {\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : getUniqueSegmentIndices(segmentationId);\n\n  let rawSurfacesData: RawSurfacesData;\n  const segmentation = getSegmentation(segmentationId);\n  const representationData = segmentation.representationData;\n\n  try {\n    if (representationData.CONTOUR) {\n      rawSurfacesData = await computeSurfaceFromContourSegmentation(\n        segmentationId,\n        {\n          segmentIndices,\n          ...options,\n        }\n      );\n    } else if (representationData.LABELMAP as LabelmapSegmentationData) {\n      // convert volume labelmap to surface\n      rawSurfacesData = await computeSurfaceFromLabelmapSegmentation(\n        segmentation.segmentationId,\n        {\n          segmentIndices,\n          ...options,\n        }\n      );\n    }\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n\n  if (!rawSurfacesData) {\n    throw new Error(\n      'Not enough data to convert to surface, currently only support converting volume labelmap to surface if available'\n    );\n  }\n\n  const surfacesData = await createAndCacheSurfacesFromRaw(\n    segmentationId,\n    rawSurfacesData,\n    options\n  );\n\n  return surfacesData;\n}\n\nasync function computeSurfaceFromLabelmapSegmentation(\n  segmentationId,\n  options: PolySegConversionOptions = {}\n): Promise<RawSurfacesData> {\n  // Todo: validate valid labelmap representation\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation?.representationData?.LABELMAP) {\n    console.warn('Only support surface update from labelmaps');\n    return;\n  }\n\n  const isVolume = isVolumeSegmentation(\n    segmentation.representationData.LABELMAP\n  );\n\n  const labelmapRepresentationData = segmentation.representationData.LABELMAP;\n\n  const segmentIndices =\n    options.segmentIndices || getUniqueSegmentIndices(segmentationId);\n\n  const promises = segmentIndices.map((index) => {\n    const surface = convertLabelmapToSurface(\n      labelmapRepresentationData as\n        | LabelmapSegmentationDataVolume\n        | LabelmapSegmentationDataStack,\n      index,\n      isVolume\n    );\n\n    return surface;\n  });\n\n  const surfaces = await Promise.allSettled(promises);\n  const errors = surfaces.filter((p) => p.status === 'rejected');\n\n  if (errors.length > 0) {\n    console.error(errors);\n    throw new Error('Failed to convert labelmap to surface');\n  }\n\n  const rawSurfacesData = surfaces\n    .map((surface, index) => {\n      if (surface.status === 'fulfilled') {\n        return { segmentIndex: segmentIndices[index], data: surface.value };\n      }\n    })\n    .filter(Boolean);\n\n  return rawSurfacesData;\n}\n\n/**\n * Computes the surface from contour segmentation.\n * @param segmentationId - The ID of the segmentation.\n * @param options - The options for surface computation.\n * @returns A promise that resolves to the raw surfaces data.\n */\nasync function computeSurfaceFromContourSegmentation(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n): Promise<RawSurfacesData> {\n  const segmentation = getSegmentation(segmentationId);\n\n  const contourRepresentationData = segmentation.representationData.CONTOUR;\n\n  const segmentIndices =\n    options.segmentIndices || getUniqueSegmentIndices(segmentationId);\n\n  const promises = segmentIndices.map(async (index) => {\n    const surface = await convertContourToSurface(\n      contourRepresentationData as ContourSegmentationData,\n      index\n    );\n\n    return { segmentIndex: index, data: surface };\n  });\n\n  const surfaces = await Promise.all(promises);\n\n  return surfaces;\n}\n\nexport {\n  computeSurfaceFromContourSegmentation,\n  computeSurfaceFromLabelmapSegmentation,\n};\n","import { SegmentationRepresentations } from '../../../../enums';\nimport { PolySegConversionOptions } from '../../../../types';\nimport { computeAndAddRepresentation } from '../computeAndAddRepresentation';\nimport { computeSurfaceData } from './surfaceComputationStrategies';\nimport { updateSurfaceData } from './updateSurfaceData';\n\n/**\n * Computes and adds a surface representation for a given segmentation.\n * @param segmentationId - The ID of the segmentation.\n * @param options - Additional options for computing the surface representation.\n * @param options.segmentIndices - The indices of the segments to compute the surface for.\n * @param options.segmentationRepresentationUID - The UID of the segmentation representation to compute the surface for.\n *\n * @returns A promise that resolves when the surface representation is computed and added.\n */\nexport function computeAndAddSurfaceRepresentation(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n) {\n  return computeAndAddRepresentation(\n    segmentationId,\n    SegmentationRepresentations.Surface,\n    () => computeSurfaceData(segmentationId, options),\n    () => updateSurfaceData(segmentationId)\n  );\n}\n","import { Types, cache } from '@cornerstonejs/core';\nimport { getUniqueSegmentIndices } from '../../../../utilities/segmentation';\nimport {\n  getSegmentation,\n  getSegmentationRepresentations,\n  getToolGroupIdsWithSegmentation,\n} from '../../segmentationState';\nimport { triggerSegmentationModified } from '../../triggerSegmentationEvents';\nimport { ToolGroupSpecificRepresentations } from '../../../../types/SegmentationStateTypes';\nimport { SegmentationRepresentations } from '../../../../enums';\nimport { computeSurfaceFromLabelmapSegmentation } from './surfaceComputationStrategies';\nimport { createAndCacheSurfacesFromRaw } from './createAndCacheSurfacesFromRaw';\n\nexport async function updateSurfaceData(segmentationId) {\n  const surfacesObj = await computeSurfaceFromLabelmapSegmentation(\n    segmentationId\n  );\n\n  if (!surfacesObj) {\n    return;\n  }\n\n  const segmentation = getSegmentation(segmentationId);\n  const indices = getUniqueSegmentIndices(segmentationId);\n\n  if (!indices.length) {\n    // means all segments were removed so we need to empty out\n    // the geometry data\n    const geometryIds = segmentation.representationData.SURFACE.geometryIds;\n    geometryIds.forEach((geometryId) => {\n      const geometry = cache.getGeometry(geometryId);\n      const surface = geometry.data as Types.ISurface;\n      surface.setPoints([]);\n      surface.setPolys([]);\n    });\n\n    triggerSegmentationModified(segmentationId);\n\n    return;\n  }\n\n  const promises = surfacesObj.map(({ data, segmentIndex }) => {\n    const geometryId = `segmentation_${segmentationId}_surface_${segmentIndex}`;\n\n    const geometry = cache.getGeometry(geometryId);\n\n    if (!geometry) {\n      // means it is a new segment getting added while we were\n      // listening to the segmentation data modified event\n      const toolGroupIds = getToolGroupIdsWithSegmentation(segmentationId);\n\n      return toolGroupIds.map((toolGroupId) => {\n        const segmentationRepresentations = getSegmentationRepresentations(\n          toolGroupId\n        ) as ToolGroupSpecificRepresentations;\n\n        return segmentationRepresentations.map((segmentationRepresentation) => {\n          if (\n            segmentationRepresentation.type !==\n            SegmentationRepresentations.Surface\n          ) {\n            return;\n          }\n          segmentation.representationData.SURFACE.geometryIds.set(\n            segmentIndex,\n            geometryId\n          );\n\n          return createAndCacheSurfacesFromRaw(\n            segmentationId,\n            [{ segmentIndex, data }],\n            {\n              segmentationRepresentationUID:\n                segmentationRepresentation.segmentationRepresentationUID,\n            }\n          );\n        });\n      });\n    } else if (indices.includes(segmentIndex)) {\n      // if the geometry already exists and the segmentIndex is\n      // still present, update the geometry data\n      const surface = geometry.data as Types.ISurface;\n      surface.setPoints(data.points);\n      surface.setPolys(data.polys);\n    } else {\n      const surface = geometry.data as Types.ISurface;\n      surface.setPoints([]);\n      surface.setPolys([]);\n    }\n  });\n\n  await Promise.all(promises);\n\n  triggerSegmentationModified(segmentationId);\n}\n","import {\n  cache,\n  getEnabledElementByIds,\n  Types,\n  VolumeViewport3D,\n} from '@cornerstonejs/core';\n\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\nimport { ToolGroupSpecificRepresentation } from '../../../types/SegmentationStateTypes';\n\nimport removeSurfaceFromElement from './removeSurfaceFromElement';\nimport addOrUpdateSurfaceToElement from './addOrUpdateSurfaceToElement';\nimport { polySeg } from '../../../stateManagement/segmentation';\n\n/**\n * It removes a segmentation representation from the tool group's viewports and\n * from the segmentation state\n * @param toolGroupId - The toolGroupId of the toolGroup that the\n * segmentationRepresentation belongs to.\n * @param segmentationRepresentationUID - This is the unique identifier\n * for the segmentation representation.\n * @param renderImmediate - If true, the viewport will be rendered\n * immediately after the segmentation representation is removed.\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  renderImmediate = false\n): void {\n  _removeSurfaceFromToolGroupViewports(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n  SegmentationState.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  if (renderImmediate) {\n    const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      enabledElement.viewport.render();\n    });\n  }\n}\n\n/**\n * It renders the Surface  for the given segmentation\n * @param viewport - The viewport object\n * @param representation - ToolGroupSpecificRepresentation\n * @param toolGroupConfig - This is the configuration object for the tool group\n */\nasync function render(\n  viewport: Types.IVolumeViewport,\n  representation: ToolGroupSpecificRepresentation\n): Promise<void> {\n  const { colorLUTIndex, segmentationId, segmentationRepresentationUID } =\n    representation;\n\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    return;\n  }\n\n  if (!(viewport instanceof VolumeViewport3D)) {\n    throw new Error(\n      'Surface rendering is only supported in 3D viewports, if you need to visualize the surface cuts in 2D viewports, you can use the Contour representation, see polySeg converters'\n    );\n  }\n\n  let SurfaceData = segmentation.representationData[Representations.Surface];\n\n  if (\n    !SurfaceData &&\n    polySeg.canComputeRequestedRepresentation(segmentationRepresentationUID)\n  ) {\n    // we need to check if we can request polySEG to convert the other\n    // underlying representations to Surface\n    SurfaceData = await polySeg.computeAndAddSurfaceRepresentation(\n      segmentationId,\n      {\n        segmentationRepresentationUID,\n      }\n    );\n\n    if (!SurfaceData) {\n      throw new Error(\n        `No Surface data found for segmentationId ${segmentationId}.`\n      );\n    }\n  }\n\n  const { geometryIds } = SurfaceData;\n\n  if (!geometryIds?.size) {\n    console.warn(\n      `No Surfaces found for segmentationId ${segmentationId}. Skipping render.`\n    );\n  }\n\n  const colorLUT = SegmentationState.getColorLUT(colorLUTIndex);\n\n  const surfaces = [];\n  geometryIds.forEach((geometryId, segmentIndex) => {\n    const geometry = cache.getGeometry(geometryId);\n    if (!geometry?.data) {\n      console.warn(\n        `No Surfaces found for geometryId ${geometryId}. Skipping render.`\n      );\n      return;\n    }\n\n    const surface = geometry.data as Types.ISurface;\n\n    const color = colorLUT[segmentIndex];\n    surface.setColor(color.slice(0, 3) as Types.Point3);\n\n    addOrUpdateSurfaceToElement(\n      viewport.element,\n      surface as Types.ISurface,\n      segmentationRepresentationUID\n    );\n\n    surfaces.push(surface);\n  });\n\n  viewport.render();\n}\n\nfunction _removeSurfaceFromToolGroupViewports(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);\n  }\n\n  const { viewportsInfo } = toolGroup;\n\n  for (const viewportInfo of viewportsInfo) {\n    const { viewportId, renderingEngineId } = viewportInfo;\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    removeSurfaceFromElement(\n      enabledElement.viewport.element,\n      segmentationRepresentationUID\n    );\n  }\n}\n\nexport default {\n  render,\n  removeSegmentationRepresentation,\n};\n\nexport { render, removeSegmentationRepresentation };\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport { getSurfaceActorUID } from '../../../stateManagement/segmentation/helpers/clipAndCacheSurfacesForViewport';\n\nfunction addOrUpdateSurfaceToElement(\n  element: HTMLDivElement,\n  surface: Types.ISurface,\n  segmentationRepresentationUID: string\n): void {\n  const actorUID = getSurfaceActorUID(\n    segmentationRepresentationUID,\n    surface.id\n  );\n\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n  const surfaceActor = viewport.getActor(actorUID)?.actor as Types.Actor;\n\n  if (surfaceActor) {\n    // we already have an actor for this surface, we just need to update it\n\n    // Todo: figure out if the surface configuration has changed\n\n    const surfaceMapper = surfaceActor.getMapper();\n    const currentPolyData = surfaceMapper.getInputData();\n\n    // check if the new data is the same as the old data by checking the\n    // length of the points and the length of the polys\n\n    const newPoints = surface.getPoints();\n    const newPolys = surface.getPolys();\n\n    const currentPoints = currentPolyData.getPoints().getData();\n    const currentPolys = currentPolyData.getPolys().getData();\n\n    if (\n      newPoints.length === currentPoints.length &&\n      newPolys.length === currentPolys.length\n    ) {\n      // the data is the same, we don't need to update the actor\n\n      return;\n    }\n\n    const polyData = vtkPolyData.newInstance();\n    polyData.getPoints().setData(newPoints, 3);\n\n    const triangles = vtkCellArray.newInstance({\n      values: Float32Array.from(newPolys),\n    });\n\n    polyData.setPolys(triangles);\n\n    surfaceMapper.setInputData(polyData);\n    surfaceMapper.modified();\n\n    setTimeout(() => {\n      viewport.getRenderer().resetCameraClippingRange();\n    }, 0);\n\n    return;\n  }\n\n  // Default to true since we are setting a new segmentation, however,\n  // in the event listener, we will make other segmentations visible/invisible\n  // based on the config\n  const points = surface.getPoints();\n  const polys = surface.getPolys();\n  const color = surface.getColor();\n\n  const surfacePolyData = vtkPolyData.newInstance();\n  surfacePolyData.getPoints().setData(points, 3);\n\n  const triangles = vtkCellArray.newInstance({\n    values: Float32Array.from(polys),\n  });\n  surfacePolyData.setPolys(triangles);\n\n  const mapper = vtkMapper.newInstance({});\n\n  let clippingFilter;\n  mapper.setInputData(surfacePolyData);\n\n  const actor = vtkActor.newInstance();\n  actor.setMapper(mapper);\n\n  // sets the color of the surface actor\n  actor.getProperty().setColor(color[0] / 255, color[1] / 255, color[2] / 255);\n\n  // set line width\n  // Todo: make this configurable\n  actor.getProperty().setLineWidth(2);\n\n  viewport.addActor({\n    // @ts-ignore\n    actor: actor as vtkActor,\n    uid: actorUID,\n    clippingFilter,\n  });\n\n  viewport.resetCamera();\n  viewport.render();\n\n  setTimeout(() => {\n    viewport.getRenderer().resetCameraClippingRange();\n  }, 0);\n}\n\nexport default addOrUpdateSurfaceToElement;\n","import { Enums, Types } from '@cornerstonejs/core';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport vtkPoints from '@kitware/vtk.js/Common/Core/Points';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport { ToolGroupSpecificContourRepresentation } from '../../../../types';\n\n/**\n * If the segment specific config exists for the given segment id, it returns\n * the segment specific config. Otherwise, it looks for the segment specific\n * config for the given index. If it doesn't exist, it returns null.\n *\n * @param contourRepresentation -  The representation object that is passed\n * to the tool.\n * @param segmentId -  The id of the segment.\n * @param index -  The index of the segment in the list of segments.\n * @returns the segment specific config for the given segment id.\n *\n */\nexport function getSegmentSpecificConfig(\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  segmentId: string,\n  index: number\n) {\n  let segmentSpecificConfig =\n    contourRepresentation.segmentSpecificConfig?.[segmentId];\n\n  if (!segmentSpecificConfig) {\n    // try the index\n    segmentSpecificConfig =\n      contourRepresentation.segmentSpecificConfig?.[index];\n  }\n\n  if (!segmentSpecificConfig) {\n    return null;\n  }\n\n  return segmentSpecificConfig.CONTOUR;\n}\n\n/**\n * takes a geometry object as an argument\n * and throws an error if the geometry object is not a contour\n * @param geometry -  The geometry object to be rendered.\n */\nexport function validateGeometry(geometry: Types.IGeometry): void {\n  if (!geometry) {\n    throw new Error(`No contours found for geometryId ${geometry.id}`);\n  }\n\n  const geometryId = geometry.id;\n\n  if (geometry.type !== Enums.GeometryType.CONTOUR) {\n    throw new Error(\n      `Geometry type ${geometry.type} not supported for rendering.`\n    );\n  }\n\n  if (!geometry.data) {\n    console.warn(\n      `No contours found for geometryId ${geometryId}. Skipping render.`\n    );\n    return;\n  }\n}\n\n/**\n * It takes a contourSet and returns a vtkPolyData for that contourSet. A contour set\n * is a collection of contours. Each contour is a collection of points. Each point\n * is x,y,z in the world coordinate system.\n *\n * @param contourSet -  the contour set that you want to convert to polyData\n * @returns A vtkPolyData object\n */\nexport function getPolyData(contourSet: Types.IContourSet) {\n  const pointArray = [];\n\n  const points = vtkPoints.newInstance();\n  const lines = vtkCellArray.newInstance();\n\n  // this variable will indicate the index of the first point in the current line\n  // so we can correctly generate the point index list to add in the cellArray\n  let pointIndex = 0;\n  contourSet.getContours().forEach((contour: Types.IContour) => {\n    const pointList = contour.getPoints();\n    const flatPoints = contour.getFlatPointsArray();\n    const type = contour.getType();\n\n    // creating a point index list that defines a line\n    const pointIndexes = pointList.map(\n      (_, pointListIndex) => pointListIndex + pointIndex\n    );\n\n    // if close planar, add the first point index to the list\n    if (type === Enums.ContourType.CLOSED_PLANAR) {\n      pointIndexes.push(pointIndexes[0]);\n    }\n\n    const linePoints = Float32Array.from(flatPoints);\n    // add the current points into the point list\n    pointArray.push(...linePoints);\n    // add the point indexes into the cell array\n    lines.insertNextCell([...pointIndexes]);\n    // update the first point index\n    pointIndex = pointIndex + pointList.length;\n  });\n\n  // converts the pointArray into vtkPoints\n  points.setData(pointArray, 3);\n\n  // creates the polyData\n  const polygon = vtkPolyData.newInstance();\n  polygon.setPoints(points);\n  polygon.setLines(lines);\n\n  return polygon;\n}\n","type ConfigCache = {\n  segmentsHidden: Set<number>;\n  outlineWidthActive: number;\n  visibility: boolean;\n};\n\n/**\n * Config cache is used to store the config for a given segmentation\n * representation. This is used to avoid having to recompute the config\n * every time the user changes the active segment, and also for performance\n * reasons.\n */\nconst configCachePerSegmentationRepresentationUID = new Map();\n\nexport function getConfigCache(\n  segmentationRepresentationUID: string\n): ConfigCache {\n  return configCachePerSegmentationRepresentationUID.get(\n    segmentationRepresentationUID\n  );\n}\n\nexport function setConfigCache(\n  segmentationRepresentationUID: string,\n  config: ConfigCache\n) {\n  configCachePerSegmentationRepresentationUID.set(\n    segmentationRepresentationUID,\n    config\n  );\n}\n\nexport function deleteConfigCache(segmentationRepresentationUID: string) {\n  configCachePerSegmentationRepresentationUID.delete(\n    segmentationRepresentationUID\n  );\n}\n","import { cache, Types } from '@cornerstonejs/core';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkAppendPolyData from '@kitware/vtk.js/Filters/General/AppendPolyData';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\n\nimport {\n  getPolyData,\n  getSegmentSpecificConfig,\n  validateGeometry,\n} from './utils';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificContourRepresentation,\n} from '../../../../types';\nimport { getConfigCache, setConfigCache } from './contourConfigCache';\n\nexport function addContourSetsToElement(\n  viewport: Types.IVolumeViewport,\n  geometryIds: string[],\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  contourRepresentationConfig: SegmentationRepresentationConfig,\n  contourActorUID: string\n) {\n  const { segmentationRepresentationUID, segmentsHidden } =\n    contourRepresentation;\n  const appendPolyData = vtkAppendPolyData.newInstance();\n\n  const scalarToColorMap = new Map();\n  const segmentSpecificMap = new Map();\n\n  geometryIds.forEach((geometryId) => {\n    const geometry = cache.getGeometry(geometryId);\n\n    if (!geometry) {\n      console.warn(\n        `No geometry found for geometryId ${geometryId}. Skipping render.`\n      );\n      return;\n    }\n\n    const segmentIndex = (geometry.data as Types.IContourSet).getSegmentIndex();\n\n    validateGeometry(geometry);\n\n    const segmentSpecificConfig = getSegmentSpecificConfig(\n      contourRepresentation,\n      geometryId,\n      segmentIndex\n    );\n\n    const contourSet = geometry.data;\n    const polyData = getPolyData(contourSet as Types.IContourSet);\n    const color = contourSet.getColor();\n\n    const size = polyData.getPoints().getNumberOfPoints();\n\n    const scalars = vtkDataArray.newInstance({\n      size: size * 4,\n      numberOfComponents: 4,\n      dataType: 'Uint8Array',\n    });\n    for (let i = 0; i < size; ++i) {\n      scalars.setTuple(i, [...color, 255]);\n    }\n    polyData.getPointData().setScalars(scalars);\n\n    if (segmentSpecificConfig) {\n      segmentSpecificMap.set(segmentIndex, segmentSpecificConfig);\n    }\n\n    scalarToColorMap.set(segmentIndex, [\n      ...color,\n      segmentsHidden.has(segmentIndex) ? 0 : 255,\n    ]);\n\n    segmentIndex === 0\n      ? appendPolyData.setInputData(polyData)\n      : appendPolyData.addInputData(polyData);\n  });\n\n  const polyDataOutput = appendPolyData.getOutputData();\n\n  const outlineWidthActive =\n    contourRepresentationConfig.representations.CONTOUR.outlineWidthActive;\n\n  const mapper = vtkMapper.newInstance();\n  mapper.setInputData(polyDataOutput);\n\n  const actor = vtkActor.newInstance();\n  actor.setMapper(mapper);\n  actor.getProperty().setLineWidth(outlineWidthActive);\n\n  // set the config cache for later update of the contour\n  setConfigCache(\n    segmentationRepresentationUID,\n    Object.assign({}, getConfigCache(segmentationRepresentationUID), {\n      segmentsHidden: new Set(segmentsHidden),\n      segmentSpecificMap,\n      outlineWidthActive,\n    })\n  );\n\n  actor.setForceOpaque(true);\n\n  viewport.addActor({\n    uid: contourActorUID,\n    actor: actor as unknown as Types.Actor,\n  });\n  viewport.resetCamera();\n  viewport.render();\n}\n","import { cache, Types } from '@cornerstonejs/core';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificContourRepresentation,\n} from '../../../../types';\nimport { getConfigCache, setConfigCache } from './contourConfigCache';\nimport { getSegmentSpecificConfig } from './utils';\n\nexport function updateVTKContourSets(\n  viewport: Types.IVolumeViewport,\n  geometryIds: string[],\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  contourRepresentationConfig: SegmentationRepresentationConfig,\n  contourActorUID: string\n) {\n  const { segmentationRepresentationUID, segmentsHidden } =\n    contourRepresentation;\n  const newContourConfig = contourRepresentationConfig.representations.CONTOUR;\n  const cachedConfig = getConfigCache(segmentationRepresentationUID);\n\n  const contourSetsActor = viewport.getActor(contourActorUID);\n\n  if (!contourSetsActor) {\n    console.warn(\n      `No contour actor found for actorUID ${contourActorUID}. Skipping render.`\n    );\n    return;\n  }\n\n  const { actor } = contourSetsActor;\n\n  const newOutlineWithActive = newContourConfig.outlineWidthActive;\n\n  if (cachedConfig?.outlineWidthActive !== newOutlineWithActive) {\n    (actor as unknown as vtkActor)\n      .getProperty()\n      .setLineWidth(newOutlineWithActive);\n\n    setConfigCache(\n      segmentationRepresentationUID,\n      Object.assign({}, cachedConfig, {\n        outlineWidthActive: newOutlineWithActive,\n      })\n    );\n  }\n\n  const mapper = (actor as unknown as vtkActor).getMapper();\n  const lut = mapper.getLookupTable();\n\n  const segmentsToSetToInvisible = [];\n  const segmentsToSetToVisible = [];\n\n  for (const segmentIndex of segmentsHidden) {\n    if (!cachedConfig.segmentsHidden.has(segmentIndex)) {\n      segmentsToSetToInvisible.push(segmentIndex);\n    }\n  }\n\n  // the other way around\n  for (const segmentIndex of cachedConfig.segmentsHidden) {\n    if (!segmentsHidden.has(segmentIndex)) {\n      segmentsToSetToVisible.push(segmentIndex);\n    }\n  }\n\n  const mergedInvisibleSegments = Array.from(cachedConfig.segmentsHidden)\n    .filter((segmentIndex) => !segmentsToSetToVisible.includes(segmentIndex))\n    .concat(segmentsToSetToInvisible);\n\n  const { contourSets, segmentSpecificConfigs } = geometryIds.reduce(\n    (acc, geometryId) => {\n      const geometry = cache.getGeometry(geometryId);\n      const { data: contourSet } = geometry;\n      const segmentIndex = (contourSet as Types.IContourSet).getSegmentIndex();\n      const segmentSpecificConfig = getSegmentSpecificConfig(\n        contourRepresentation,\n        geometryId,\n        segmentIndex\n      );\n\n      acc.contourSets.push(contourSet);\n      acc.segmentSpecificConfigs[segmentIndex] = segmentSpecificConfig ?? {};\n\n      return acc;\n    },\n    { contourSets: [], segmentSpecificConfigs: {} }\n  );\n\n  const affectedSegments = [\n    ...mergedInvisibleSegments,\n    ...segmentsToSetToVisible,\n  ];\n\n  const hasCustomSegmentSpecificConfig = Object.values(\n    segmentSpecificConfigs\n  ).some((config) => Object.keys(config).length > 0);\n\n  let polyDataModified = false;\n\n  if (affectedSegments.length || hasCustomSegmentSpecificConfig) {\n    const appendPolyData = mapper.getInputData();\n    const appendScalars = appendPolyData.getPointData().getScalars();\n    const appendScalarsData = appendScalars.getData();\n    // below we will only manipulate the polyData of the contourSets that are affected\n    // by picking the correct offset in the scalarData array\n    let offset = 0;\n    contourSets.forEach((contourSet) => {\n      const segmentIndex = (contourSet as Types.IContourSet).getSegmentIndex();\n      const size = contourSet.getTotalNumberOfPoints();\n\n      if (\n        affectedSegments.includes(segmentIndex) ||\n        segmentSpecificConfigs[segmentIndex]?.fillAlpha // Todo: add others\n      ) {\n        const color = contourSet.getColor();\n        let visibility = mergedInvisibleSegments.includes(segmentIndex)\n          ? 0\n          : 255;\n\n        const segmentConfig = segmentSpecificConfigs[segmentIndex];\n        if (segmentConfig.fillAlpha !== undefined) {\n          visibility = segmentConfig.fillAlpha * 255;\n        }\n\n        for (let i = 0; i < size; ++i) {\n          appendScalarsData[offset + i * 4] = color[0];\n          appendScalarsData[offset + i * 4 + 1] = color[1];\n          appendScalarsData[offset + i * 4 + 2] = color[2];\n          appendScalarsData[offset + i * 4 + 3] = visibility;\n        }\n\n        polyDataModified = true;\n      }\n\n      offset = offset + size * 4;\n    });\n\n    if (polyDataModified) {\n      appendPolyData.modified();\n    }\n\n    setConfigCache(\n      segmentationRepresentationUID,\n      Object.assign({}, cachedConfig, {\n        segmentsHidden: new Set(segmentsHidden),\n      })\n    );\n\n    mapper.setLookupTable(lut);\n  }\n\n  viewport.render();\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Remove the contour representation from the viewport's HTML Element.\n * NOTE: This function should not be called directly.\n *\n * @param element - The element that the segmentation is being added to.\n * @param segmentationRepresentationUID - The UID of the contour representation to remove.\n * @param removeFromCache - boolean\n *\n * @internal\n */\nfunction removeContourFromElement(\n  element: HTMLDivElement,\n  segmentationRepresentationUID: string,\n  removeFromCache = false // Todo\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const actorEntries = (viewport as Types.IVolumeViewport).getActors();\n\n  // remove actors whose id has the same prefix as the segmentationRepresentationUID\n  const actorUIDsToRemove = actorEntries\n    .map(({ uid }) =>\n      uid.includes(segmentationRepresentationUID) ? uid : undefined\n    )\n    .filter(Boolean);\n\n  // @ts-ignore\n  viewport.removeActors(actorUIDsToRemove);\n\n  // Todo: add the logic to remove the svg contour segmentation representations as well\n}\n\nexport default removeContourFromElement;\n","import { PolyDataClipCacheType } from '../../../helpers/clipAndCacheSurfacesForViewport';\nimport { RawContourData } from '../contourComputationStrategies';\n\n/**\n * Extracts contour data from the given polyDataCache.\n * @param polyDataCache - The polyData cache containing intersection information.\n * @param segmentIndexMap - Optional map for mapping surface IDs to segment indices.\n * @returns A map of segment indices to an array of contour results.\n */\nexport function extractContourData(\n  polyDataCache: PolyDataClipCacheType,\n  segmentIndexMap?: Map<string, number>\n) {\n  const rawResults = new Map() as RawContourData;\n\n  for (const [cacheId, intersectionInfo] of polyDataCache) {\n    // Todo; fix this\n    const surfaceId = cacheId.split('_')[1];\n\n    for (const [_, result] of intersectionInfo) {\n      if (!result) {\n        continue;\n      }\n      const segmentIndex = Number(surfaceId) || segmentIndexMap?.get(surfaceId);\n\n      if (!segmentIndex) {\n        continue;\n      }\n\n      if (!rawResults.has(segmentIndex)) {\n        rawResults.set(segmentIndex, []);\n      }\n\n      rawResults.get(segmentIndex).push(result);\n    }\n  }\n  return rawResults;\n}\n","import { Enums, utilities } from '@cornerstonejs/core';\n\nconst { CalibrationTypes } = Enums;\nconst PIXEL_UNITS = 'px';\n\nconst SUPPORTED_REGION_DATA_TYPES = [\n  1, // Tissue\n];\n\nconst SUPPORTED_LENGTH_VARIANT = [\n  '3,3', // x: cm  &  y:cm\n];\n\nconst SUPPORTED_PROBE_VARIANT = [\n  '4,3', // x: seconds  &  y : cm\n];\n\nconst UNIT_MAPPING = {\n  3: 'cm',\n  4: 'seconds',\n};\n\nconst EPS = 1e-3;\nconst SQUARE = '\\xb2';\n/**\n * Extracts the calibrated length units, area units, and the scale\n * for converting from internal spacing to image spacing.\n *\n * @param handles - to detect if spacing information is different between points\n * @param image - to extract the calibration from\n * @returns Object containing the units, area units, and scale\n */\nconst getCalibratedLengthUnitsAndScale = (image, handles) => {\n  const { calibration, hasPixelSpacing } = image;\n  let units = hasPixelSpacing ? 'mm' : PIXEL_UNITS;\n  let areaUnits = units + SQUARE;\n  let scale = 1;\n  let calibrationType = '';\n\n  if (\n    !calibration ||\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\n  ) {\n    return { units, areaUnits, scale };\n  }\n\n  if (calibration.type === CalibrationTypes.UNCALIBRATED) {\n    return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n  }\n\n  if (calibration.sequenceOfUltrasoundRegions) {\n    let imageIndex1, imageIndex2;\n    if (Array.isArray(handles) && handles.length === 2) {\n      [imageIndex1, imageIndex2] = handles;\n    } else if (typeof handles === 'function') {\n      const points = handles();\n      imageIndex1 = points[0];\n      imageIndex2 = points[1];\n    }\n\n    let regions = calibration.sequenceOfUltrasoundRegions.filter(\n      (region) =>\n        imageIndex1[0] >= region.regionLocationMinX0 &&\n        imageIndex1[0] <= region.regionLocationMaxX1 &&\n        imageIndex1[1] >= region.regionLocationMinY0 &&\n        imageIndex1[1] <= region.regionLocationMaxY1 &&\n        imageIndex2[0] >= region.regionLocationMinX0 &&\n        imageIndex2[0] <= region.regionLocationMaxX1 &&\n        imageIndex2[1] >= region.regionLocationMinY0 &&\n        imageIndex2[1] <= region.regionLocationMaxY1\n    );\n\n    // If we are not in a region at all we should show the underlying calibration\n    // which might be the mm spacing for the image\n    if (!regions?.length) {\n      return { units, areaUnits, scale };\n    }\n\n    // if we are in a region then it is the question of whether we support it\n    // or not. If we do not support it we should show px\n\n    regions = regions.filter(\n      (region) =>\n        SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n        SUPPORTED_LENGTH_VARIANT.includes(\n          `${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`\n        )\n    );\n\n    if (!regions.length) {\n      return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n    }\n\n    // Todo: expand on this logic\n    const region = regions[0];\n\n    const physicalDeltaX = Math.abs(region.physicalDeltaX);\n    const physicalDeltaY = Math.abs(region.physicalDeltaY);\n\n    // if we are in a supported region then we should check if the\n    // physicalDeltaX and physicalDeltaY are the same. If they are not\n    // then we should show px again, but if they are the same then we should\n    // show the units\n    const isSamePhysicalDelta = utilities.isEqual(\n      physicalDeltaX,\n      physicalDeltaY,\n      EPS\n    );\n\n    if (isSamePhysicalDelta) {\n      // 1 to 1 aspect ratio, we use just one of them\n      scale = 1 / (physicalDeltaX * 10);\n      calibrationType = 'US Region';\n      units = 'mm';\n      areaUnits = 'mm' + SQUARE;\n    } else {\n      // here we are showing at the aspect ratio of the physical delta\n      // if they are not the same, then we should show px, but the correct solution\n      // is to grab each point separately and scale them individually\n      // Todo: implement this\n      return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n    }\n  } else if (calibration.scale) {\n    scale = calibration.scale;\n  }\n\n  // everything except REGION/Uncalibrated\n  const types = [\n    CalibrationTypes.ERMF,\n    CalibrationTypes.USER,\n    CalibrationTypes.ERROR,\n    CalibrationTypes.PROJECTION,\n  ];\n\n  if (types.includes(calibration?.type)) {\n    calibrationType = calibration.type;\n  }\n\n  return {\n    units: units + (calibrationType ? ` ${calibrationType}` : ''),\n    areaUnits: areaUnits + (calibrationType ? ` ${calibrationType}` : ''),\n    scale,\n  };\n};\n\nconst getCalibratedProbeUnitsAndValue = (image, handles) => {\n  const [imageIndex] = handles;\n  const { calibration } = image;\n  let units = ['raw'];\n  let values = [null];\n  let calibrationType = '';\n\n  if (\n    !calibration ||\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\n  ) {\n    return { units, values };\n    // Todo: add support for other scenarios\n  }\n\n  if (calibration.sequenceOfUltrasoundRegions) {\n    // for Probe tool\n    const supportedRegionsMetadata =\n      calibration.sequenceOfUltrasoundRegions.filter(\n        (region) =>\n          SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n          SUPPORTED_PROBE_VARIANT.includes(\n            `${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`\n          )\n      );\n\n    if (!supportedRegionsMetadata?.length) {\n      return { units, values };\n    }\n\n    const region = supportedRegionsMetadata.find(\n      (region) =>\n        imageIndex[0] >= region.regionLocationMinX0 &&\n        imageIndex[0] <= region.regionLocationMaxX1 &&\n        imageIndex[1] >= region.regionLocationMinY0 &&\n        imageIndex[1] <= region.regionLocationMaxY1\n    );\n\n    if (!region) {\n      return { units, values };\n    }\n\n    // Todo: I think this is a ok assumption for now that if the referencePixelX0 and referencePixelY0\n    // are not defined, then we can assume 0 for them\n    const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;\n    const { physicalDeltaX, physicalDeltaY } = region;\n\n    const yValue =\n      (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) *\n      physicalDeltaY;\n\n    const xValue =\n      (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) *\n      physicalDeltaX;\n\n    calibrationType = 'US Region';\n    values = [xValue, yValue];\n    units = [\n      UNIT_MAPPING[region.physicalUnitsXDirection],\n      UNIT_MAPPING[region.physicalUnitsYDirection],\n    ];\n  }\n\n  return {\n    units,\n    values,\n    calibrationType,\n  };\n};\n\n/** Gets the aspect ratio of the screen display relative to the image\n * display in order to square up measurement values.\n * That is, suppose the spacing on the image is 1, 0.5 (x,y spacing)\n * This is displayed at 1, 1 spacing on screen, then the\n * aspect value will be 1/0.5 = 2\n */\nconst getCalibratedAspect = (image) => image.calibration?.aspect || 1;\n\nexport {\n  getCalibratedLengthUnitsAndScale,\n  getCalibratedAspect,\n  getCalibratedProbeUnitsAndValue,\n};\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the axis-aligned bounding box (AABB) of a polyline.\n *\n * @param polyline - The polyline represented as an array of points.\n * @param options - Additional options for calculating the AABB.\n * @param options.isWorld - Indicates whether the polyline represents points in 3D space (true) or 2D space (false).\n *\n * @returns The AABB of the polyline. If the polyline represents points in 3D space, returns an AABB3 object with properties minX, maxX, minY, maxY, minZ, and maxZ. If the polyline represents points in 2D space, returns an AABB2 object with properties minX, maxX, minY, and maxY.\n */\nexport default function getAABB(\n  polyline: Types.Point2[] | Types.Point3[] | number[],\n  options?: {\n    numDimensions: number;\n  }\n): Types.AABB2 | Types.AABB3 {\n  // need to check if the polyline is array of arrays or just\n  // a flat array of numbers\n  let polylineToUse = polyline;\n  const numDimensions = options?.numDimensions || 2;\n  const is3D = numDimensions === 3;\n\n  if (!Array.isArray(polyline[0])) {\n    const currentPolyline = polyline as number[];\n    // check the isWorld flag is provided or not which means every\n    // 3 elements in the array represent a point in 3D space\n    // otherwise, every 2 elements in the array represent a point in 2D space\n    const totalPoints = currentPolyline.length / numDimensions;\n\n    polylineToUse = new Array(currentPolyline.length / numDimensions) as\n      | Types.Point2[]\n      | Types.Point3[];\n\n    for (let i = 0, len = totalPoints; i < len; i++) {\n      polylineToUse[i] = [\n        currentPolyline[i * numDimensions],\n        currentPolyline[i * numDimensions + 1],\n      ];\n\n      if (is3D) {\n        polylineToUse[i].push(currentPolyline[i * numDimensions + 2]);\n      }\n    }\n  }\n\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let minZ = Infinity;\n  let maxZ = -Infinity;\n\n  polylineToUse = polylineToUse as Types.Point2[] | Types.Point3[];\n\n  for (let i = 0, len = polylineToUse.length; i < len; i++) {\n    const [x, y, z] = polylineToUse[i];\n\n    // No Math.min/max calls for better performance\n    minX = minX < x ? minX : x;\n    minY = minY < y ? minY : y;\n    maxX = maxX > x ? maxX : x;\n    maxY = maxY > y ? maxY : y;\n\n    if (is3D) {\n      minZ = minZ < z ? minZ : z;\n      maxZ = maxZ > z ? maxZ : z;\n    }\n  }\n\n  return is3D\n    ? { minX, maxX, minY, maxY, minZ, maxZ } // AABB3\n    : { minX, maxX, minY, maxY }; // AABB2\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool, BaseTool } from '../tools';\nimport { Annotation } from '../types';\nimport { getAnnotations } from '../stateManagement/annotation/annotationState';\nimport * as ToolGroupManager from '../store/ToolGroupManager';\n\n/**\n * Get the annotation that is close to the provided canvas point, it will return\n * the first annotation that is found.\n *\n * @param element - The element to search for an annotation on.\n * @param canvasPoint - The canvasPoint on the page where the user clicked.\n * @param proximity - The distance from the canvasPoint to the annotation.\n * @returns The annotation for the element\n */\nfunction getAnnotationNearPoint(\n  element: HTMLDivElement,\n  canvasPoint: Types.Point2,\n  proximity = 5\n): Annotation | null {\n  // Todo: this function should return closest annotation, BUT, we are not using\n  // the function anywhere.\n  const enabledElement = getEnabledElement(element);\n  if (!enabledElement) {\n    throw new Error('getAnnotationNearPoint: enabledElement not found');\n  }\n\n  return getAnnotationNearPointOnEnabledElement(\n    enabledElement,\n    canvasPoint,\n    proximity\n  );\n}\n\n/**\n * \"Find the annotation near the point on the enabled element.\" it will return the\n * first annotation that is found.\n *\n * @param enabledElement - The element that is currently active.\n * @param point - The point to search near.\n * @param proximity - The distance from the point that the annotation must\n * be within.\n * @returns A Annotation object.\n */\nfunction getAnnotationNearPointOnEnabledElement(\n  enabledElement: Types.IEnabledElement,\n  point: Types.Point2,\n  proximity: number\n): Annotation | null {\n  // Todo: this function should return closest annotation, BUT, we are not using\n  // the function anywhere.\n  const { renderingEngineId, viewportId } = enabledElement;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const { _toolInstances: tools } = toolGroup;\n  for (const name in tools) {\n    const found = findAnnotationNearPointByTool(\n      tools[name],\n      enabledElement,\n      point,\n      proximity\n    );\n    if (found) {\n      return found;\n    }\n  }\n\n  return null;\n}\n\n/**\n * For the provided toolClass, it will find the annotation that is near the point,\n * it will return the first annotation that is found.\n *\n * @param tool - AnnotationTool\n * @param enabledElement - The element that is currently active.\n * @param point - The point in the image where the user clicked.\n * @param proximity - The distance from the point that the tool must be\n * within to be considered \"near\" the point.\n * @returns The annotation object that is being returned is the annotation object that\n * is being used in the tool.\n */\nfunction findAnnotationNearPointByTool(\n  tool: AnnotationTool,\n  enabledElement: Types.IEnabledElement,\n  point: Types.Point2,\n  proximity: number\n): Annotation | null {\n  // Todo: this function does not return closest annotation. It just returns\n  // the first annotation that is found in the proximity. BUT, we are not using\n  // the function anywhere.\n  const { viewport } = enabledElement;\n\n  const annotations = getAnnotations(\n    (tool.constructor as typeof BaseTool).toolName,\n    viewport?.element\n  );\n  const currentId = viewport?.getCurrentImageId?.();\n  if (annotations?.length) {\n    const { element } = enabledElement.viewport;\n    for (const annotation of annotations) {\n      const referencedImageId = annotation.metadata?.referencedImageId;\n      if (\n        (currentId && referencedImageId && currentId !== referencedImageId) ||\n        !tool.isPointNearTool\n      ) {\n        continue;\n      }\n\n      if (\n        tool.isPointNearTool(element, annotation, point, proximity, '') ||\n        tool.getHandleNearImagePoint(element, annotation, point, proximity)\n      ) {\n        return annotation;\n      }\n    }\n  }\n  return null;\n}\n\nexport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement };\n","import debounce from './debounce';\nimport isObject from './isObject';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds (or once per browser frame). The throttled function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `throttle` and `debounce`.\n *\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0]\n *  The number of milliseconds to throttle invocations to; if omitted,\n *  `requestAnimationFrame` is used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', throttle(updatePosition, 100))\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * const throttled = throttle(renewToken, 300000, { 'trailing': false })\n * jQuery(element).on('click', throttled)\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel)\n */\nfunction throttle(func, wait, options) {\n  let leading = true;\n  let trailing = true;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? Boolean(options.leading) : leading;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  return debounce(func, wait, {\n    leading,\n    trailing,\n    maxWait: wait,\n  });\n}\n\nexport default throttle;\n","/**\n * Clips a value to an upper and lower bound.\n * @export @public @method\n * @name clip\n *\n * @param  {number} val  The value to clip.\n * @param  {number} low  The lower bound.\n * @param  {number} high The upper bound.\n * @returns {number}      The clipped value.\n */\nexport function clip(val, low, high) {\n  return Math.min(Math.max(low, val), high);\n}\n\n/**\n * Clips a value within a box.\n * @export @public @method\n * @name clipToBox\n *\n * @param  {Object} point The point to clip\n * @param  {Object} box   The bounding box to clip to.\n * @returns {Object}       The clipped point.\n */\nexport function clipToBox(point, box) {\n  // Clip an {x, y} point to a box of size {width, height}\n  point.x = clip(point.x, 0, box.width);\n  point.y = clip(point.y, 0, box.height);\n}\n\nexport default clip;\n","import { utilities, Enums } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nconst { calibratedPixelSpacingMetadataProvider } = utilities;\n\n/**\n * It adds the provided spacing to the Cornerstone internal calibratedPixelSpacing\n * metadata provider, then it invalidates all the tools that have the imageId as\n * their reference imageIds. Finally, it triggers a re-render for invalidated annotations.\n * @param imageId - ImageId for the calibrated image\n * @param rowPixelSpacing - Spacing in row direction\n * @param calibrationOrScale - either the calibration object or a scale value\n */\nexport default function calibrateImageSpacing(\n  imageId: string,\n  renderingEngine: Types.IRenderingEngine,\n  calibrationOrScale: Types.IImageCalibration | number\n): void {\n  // Handle simple parameter version\n  if (typeof calibrationOrScale === 'number') {\n    calibrationOrScale = {\n      type: Enums.CalibrationTypes.USER,\n      scale: calibrationOrScale,\n    };\n  }\n  // 1. Add the calibratedPixelSpacing metadata to the metadata\n  calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);\n\n  // 2. Update the actor for stackViewports\n  const viewports = renderingEngine.getStackViewports();\n\n  // 2.1 If imageId is already being used in a stackViewport -> update actor\n  viewports.forEach((viewport) => {\n    const imageIds = viewport.getImageIds();\n    if (imageIds.includes(imageId)) {\n      viewport.calibrateSpacing(imageId);\n    }\n  });\n\n  // 2.2 If imageId is cached but not being displayed in a viewport, stackViewport\n  // will handle using the calibratedPixelSpacing since it has been added\n  // to the provider\n}\n","import { getRenderingEngine, type Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\n/**\n * Triggers annotation rendering for the specified tool group IDs.\n *\n * @param toolGroupIds - An array of tool group IDs.\n */\nexport function triggerAnnotationRenderForToolGroupIds(\n  toolGroupIds: string[]\n): void {\n  toolGroupIds.forEach((toolGroupId) => {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      console.warn(`ToolGroup not available for ${toolGroupId}`);\n      return;\n    }\n\n    const viewportsInfo = toolGroup.getViewportsInfo();\n\n    viewportsInfo.forEach((viewportInfo) => {\n      const { renderingEngineId, viewportId } = viewportInfo;\n\n      const renderingEngine = getRenderingEngine(renderingEngineId);\n      if (!renderingEngine) {\n        console.warn(`RenderingEngine not available for ${renderingEngineId}`);\n        return;\n      }\n\n      const viewport = renderingEngine.getViewport(viewportId);\n      triggerAnnotationRender(viewport.element);\n    });\n  });\n}\n\nexport default triggerAnnotationRenderForToolGroupIds;\n","import {\n  StackViewport,\n  Types,\n  VolumeViewport,\n  eventTarget,\n  EVENTS,\n  utilities as csUtils,\n  getEnabledElement,\n  VideoViewport,\n} from '@cornerstonejs/core';\nimport { ScrollOptions, EventTypes } from '../types';\n\n/**\n * It scrolls one slice in the Stack or Volume Viewport, it uses the options provided\n * to determine the slice to scroll to. For Stack Viewport, it scrolls in the 1 or -1\n * direction, for Volume Viewport, it uses the camera and focal point to determine the\n * slice to scroll to based on the spacings.\n * @param viewport - The viewport in which to scroll\n * @param options - Options to use for scrolling, including direction, invert, and volumeId\n * @returns\n */\nexport default function scroll(\n  viewport: Types.IViewport,\n  options: ScrollOptions\n): void {\n  // check if viewport is disabled then throw error\n  const enabledElement = getEnabledElement(viewport.element);\n\n  if (!enabledElement) {\n    throw new Error('Scroll::Viewport is not enabled (it might be disabled)');\n  }\n\n  if (\n    viewport instanceof StackViewport &&\n    viewport.getImageIds().length === 0\n  ) {\n    throw new Error('Scroll::Stack Viewport has no images');\n  }\n\n  const { type: viewportType } = viewport;\n  const { volumeId, delta, scrollSlabs } = options;\n\n  if (viewport instanceof StackViewport) {\n    viewport.scroll(delta, options.debounceLoading, options.loop);\n  } else if (viewport instanceof VolumeViewport) {\n    scrollVolume(viewport, volumeId, delta, scrollSlabs);\n  } else if (viewport instanceof VideoViewport) {\n    viewport.scroll(delta);\n  } else {\n    throw new Error(`Not implemented for Viewport Type: ${viewportType}`);\n  }\n}\n\nexport function scrollVolume(\n  viewport: VolumeViewport,\n  volumeId: string,\n  delta: number,\n  scrollSlabs = false\n) {\n  const useSlabThickness = scrollSlabs;\n\n  const { numScrollSteps, currentStepIndex, sliceRangeInfo } =\n    csUtils.getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness);\n\n  if (!sliceRangeInfo) {\n    return;\n  }\n\n  const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;\n  const { focalPoint, viewPlaneNormal, position } = camera;\n\n  const { newFocalPoint, newPosition } = csUtils.snapFocalPointToSlice(\n    focalPoint,\n    position,\n    sliceRange,\n    viewPlaneNormal,\n    spacingInNormalDirection,\n    delta\n  );\n\n  viewport.setCamera({\n    focalPoint: newFocalPoint,\n    position: newPosition,\n  });\n  viewport.render();\n\n  const desiredStepIndex = currentStepIndex + delta;\n\n  const VolumeScrollEventDetail: EventTypes.VolumeScrollOutOfBoundsEventDetail =\n    {\n      volumeId,\n      viewport,\n      delta,\n      desiredStepIndex,\n      currentStepIndex,\n      numScrollSteps,\n      currentImageId: viewport.getCurrentImageId(),\n    };\n\n  if (\n    (desiredStepIndex > numScrollSteps || desiredStepIndex < 0) &&\n    viewport.getCurrentImageId() // Check that we are in the plane of acquistion\n  ) {\n    // One common use case of this trigger might be to load the next\n    // volume in a time series or the next segment of a partially loaded volume.\n\n    csUtils.triggerEvent(\n      eventTarget,\n      EVENTS.VOLUME_SCROLL_OUT_OF_BOUNDS,\n      VolumeScrollEventDetail\n    );\n  } else {\n    csUtils.triggerEvent(\n      eventTarget,\n      EVENTS.VOLUME_VIEWPORT_SCROLL,\n      VolumeScrollEventDetail\n    );\n  }\n}\n","import {\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  utilities as csUtils,\n  Types,\n} from '@cornerstonejs/core';\nimport JumpToSliceOptions from '../../types/JumpToSliceOptions';\nimport clip from '../clip';\nimport scroll from '../scroll';\n\n/**\n * It uses the imageIndex in the Options to scroll to the slice that is intended.\n * It works for both Stack and Volume viewports. In VolumeViewports, the imageIndex\n * should be given with respect to the index in the 3D image in the view direction\n * (i.e. the index of the slice in Axial, Sagittal, Coronal, or Oblique).\n *\n * @param element - the HTML Div element scrolling inside\n * @param options - the options used for jumping to a slice\n * @returns Promise that resolves to ImageIdIndex\n */\nasync function jumpToSlice(\n  element: HTMLDivElement,\n  options = {} as JumpToSliceOptions\n): Promise<void> {\n  const { imageIndex, debounceLoading, volumeId } = options;\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error('Element has been disabled');\n  }\n\n  const { viewport } = enabledElement;\n\n  const { imageIndex: currentImageIndex, numberOfSlices } = _getImageSliceData(\n    viewport,\n    debounceLoading\n  );\n\n  const imageIndexToJump = _getImageIndexToJump(numberOfSlices, imageIndex);\n  const delta = imageIndexToJump - currentImageIndex;\n\n  scroll(viewport, { delta, debounceLoading, volumeId });\n}\n\nfunction _getImageSliceData(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  debounceLoading?: boolean\n): Types.ImageSliceData {\n  if (viewport instanceof StackViewport) {\n    return {\n      numberOfSlices: viewport.getImageIds().length,\n      imageIndex: debounceLoading\n        ? viewport.getTargetImageIdIndex()\n        : viewport.getCurrentImageIdIndex(),\n    };\n  } else if (viewport instanceof VolumeViewport) {\n    return csUtils.getImageSliceDataForVolumeViewport(viewport);\n  } else {\n    throw new Error('Unsupported viewport type');\n  }\n}\n\nfunction _getImageIndexToJump(\n  numberOfSlices: number,\n  imageIndex: number\n): number {\n  const lastSliceIndex = numberOfSlices - 1;\n\n  return clip(imageIndex, 0, lastSliceIndex);\n}\n\nexport default jumpToSlice;\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport BoundsIJK from '../types/BoundsIJK';\n\nexport type PointInShape = {\n  value: number;\n  index: number;\n  pointIJK: vec3;\n  pointLPS: vec3 | number[];\n};\n\nexport type PointInShapeCallback = ({\n  value,\n  index,\n  pointIJK,\n  pointLPS,\n}: {\n  value: number;\n  index: number;\n  pointIJK: vec3;\n  pointLPS: vec3;\n}) => void;\n\nexport type ShapeFnCriteria = (pointLPS: vec3, pointIJK: vec3) => boolean;\n\n/**\n * For each point in the image (If boundsIJK is not provided, otherwise, for each\n * point in the provided bounding box), It runs the provided callback IF the point\n * passes the provided criteria to be inside the shape (which is defined by the\n * provided pointInShapeFn)\n *\n * @param imageData - The image data object.\n * @param dimensions - The dimensions of the image.\n * @param pointInShapeFn - A function that takes a point in LPS space and returns\n * true if the point is in the shape and false if it is not.\n * @param callback - A function that will be called for\n * every point in the shape.\n * @param boundsIJK - The bounds of the volume in IJK coordinates.\n */\nexport default function pointInShapeCallback(\n  imageData: vtkImageData | Types.CPUImageData,\n  pointInShapeFn: ShapeFnCriteria,\n  callback?: PointInShapeCallback,\n  boundsIJK?: BoundsIJK\n): Array<PointInShape> {\n  let iMin, iMax, jMin, jMax, kMin, kMax;\n\n  let scalarData;\n  const { numComps } = imageData as any;\n\n  // if getScalarData is a method on imageData\n  if ((imageData as Types.CPUImageData).getScalarData) {\n    scalarData = (imageData as Types.CPUImageData).getScalarData();\n  } else {\n    scalarData = (imageData as vtkImageData)\n      .getPointData()\n      .getScalars()\n      .getData();\n  }\n\n  const dimensions = imageData.getDimensions();\n\n  if (!boundsIJK) {\n    iMin = 0;\n    iMax = dimensions[0];\n    jMin = 0;\n    jMax = dimensions[1];\n    kMin = 0;\n    kMax = dimensions[2];\n  } else {\n    [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = boundsIJK;\n  }\n\n  const start = vec3.fromValues(iMin, jMin, kMin);\n\n  const direction = imageData.getDirection();\n  const rowCosines = direction.slice(0, 3);\n  const columnCosines = direction.slice(3, 6);\n  const scanAxisNormal = direction.slice(6, 9);\n\n  const spacing = imageData.getSpacing();\n  const [rowSpacing, columnSpacing, scanAxisSpacing] = spacing;\n\n  // @ts-ignore will be fixed in vtk-master\n  const worldPosStart = imageData.indexToWorld(start);\n\n  const rowStep = vec3.fromValues(\n    rowCosines[0] * rowSpacing,\n    rowCosines[1] * rowSpacing,\n    rowCosines[2] * rowSpacing\n  );\n\n  const columnStep = vec3.fromValues(\n    columnCosines[0] * columnSpacing,\n    columnCosines[1] * columnSpacing,\n    columnCosines[2] * columnSpacing\n  );\n\n  const scanAxisStep = vec3.fromValues(\n    scanAxisNormal[0] * scanAxisSpacing,\n    scanAxisNormal[1] * scanAxisSpacing,\n    scanAxisNormal[2] * scanAxisSpacing\n  );\n\n  const xMultiple =\n    numComps ||\n    scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\n  const yMultiple = dimensions[0] * xMultiple;\n  const zMultiple = dimensions[1] * yMultiple;\n\n  const pointsInShape: Array<PointInShape> = [];\n\n  const currentPos = vec3.clone(worldPosStart);\n\n  for (let k = kMin; k <= kMax; k++) {\n    const startPosJ = vec3.clone(currentPos);\n\n    for (let j = jMin; j <= jMax; j++) {\n      const startPosI = vec3.clone(currentPos);\n\n      for (let i = iMin; i <= iMax; i++) {\n        const pointIJK: Types.Point3 = [i, j, k];\n\n        // The current world position (pointLPS) is now in currentPos\n        if (pointInShapeFn(currentPos as Types.Point3, pointIJK)) {\n          const index = k * zMultiple + j * yMultiple + i * xMultiple;\n          let value;\n          if (xMultiple > 2) {\n            value = [\n              scalarData[index],\n              scalarData[index + 1],\n              scalarData[index + 2],\n            ];\n          } else {\n            value = scalarData[index];\n          }\n\n          pointsInShape.push({\n            value,\n            index,\n            pointIJK,\n            pointLPS: currentPos.slice(),\n          });\n          if (callback) {\n            callback({ value, index, pointIJK, pointLPS: currentPos });\n          }\n        }\n\n        // Increment currentPos by rowStep for the next iteration\n        vec3.add(currentPos, currentPos, rowStep);\n      }\n\n      // Reset currentPos to the start of the next J line and increment by columnStep\n      vec3.copy(currentPos, startPosI);\n      vec3.add(currentPos, currentPos, columnStep);\n    }\n\n    // Reset currentPos to the start of the next K slice and increment by scanAxisStep\n    vec3.copy(currentPos, startPosJ);\n    vec3.add(currentPos, currentPos, scanAxisStep);\n  }\n\n  return pointsInShape;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { CONSTANTS } from '@cornerstonejs/core';\n\nconst { EPSILON } = CONSTANTS;\n\n/** Bounding box type */\ntype BoundingBox =\n  | [Types.Point2, Types.Point2, null]\n  | [Types.Point2, Types.Point2, Types.Point2];\n\nfunction calculateBoundingBox(\n  points,\n  dimensions,\n  isWorld = false\n): BoundingBox {\n  let xMin = Infinity;\n  let xMax = isWorld ? -Infinity : 0;\n  let yMin = Infinity;\n  let yMax = isWorld ? -Infinity : 0;\n  let zMin = Infinity;\n  let zMax = isWorld ? -Infinity : 0;\n\n  const is3D = points[0]?.length === 3;\n\n  // use for loop for performance\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n    xMin = Math.min(p[0], xMin);\n    xMax = Math.max(p[0], xMax);\n    yMin = Math.min(p[1], yMin);\n    yMax = Math.max(p[1], yMax);\n\n    if (is3D) {\n      zMin = Math.min(p[2] ?? zMin, zMin);\n      zMax = Math.max(p[2] ?? zMax, zMax);\n    }\n  }\n\n  if (dimensions) {\n    xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);\n    xMax = Math.min(\n      isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1,\n      xMax\n    );\n    yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);\n    yMax = Math.min(\n      isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1,\n      yMax\n    );\n\n    if (is3D && dimensions.length === 3) {\n      zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);\n      zMax = Math.min(\n        isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1,\n        zMax\n      );\n    }\n  } else if (!isWorld) {\n    // still need to bound to 0 and Infinity if no dimensions are provided for ijk\n    xMin = Math.max(0, xMin);\n    xMax = Math.min(Infinity, xMax);\n    yMin = Math.max(0, yMin);\n    yMax = Math.min(Infinity, yMax);\n\n    if (is3D) {\n      zMin = Math.max(0, zMin);\n      zMax = Math.min(Infinity, zMax);\n    }\n  }\n\n  return is3D\n    ? [\n        [xMin, xMax],\n        [yMin, yMax],\n        [zMin, zMax],\n      ]\n    : [[xMin, xMax], [yMin, yMax], null];\n}\n\n/**\n * With a given vertices (points) coordinates in 2D or 3D in IJK, it calculates the minimum and maximum\n * coordinate in each axis, and returns them. If clipBounds are provided it also\n * clip the min, max to the provided width, height and depth\n *\n * @param points - shape corner points coordinates either in IJK (image coordinate)\n * @param dimensions - bounds to clip the min, max\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\n */\nexport function getBoundingBoxAroundShapeIJK(\n  points: Types.Point2[] | Types.Point3[],\n  dimensions?: Types.Point2 | Types.Point3\n): BoundingBox {\n  return calculateBoundingBox(points, dimensions, false);\n}\n\n/**\n * With a given vertices (points) coordinates in 2D or 3D in World Coordinates, it calculates the minimum and maximum\n * coordinate in each axis, and returns them. If clipBounds are provided it also\n * clip the min, max to the provided width, height and depth\n *\n * @param points - shape corner points coordinates either in IJK (image coordinate)\n * @param clipBounds - bounds to clip the min, max\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\n */\nexport function getBoundingBoxAroundShapeWorld(\n  points: Types.Point2[] | Types.Point3[],\n  clipBounds?: Types.Point2 | Types.Point3\n): BoundingBox {\n  return calculateBoundingBox(points, clipBounds, true);\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { vec3 } from 'gl-matrix';\nimport { BoundsIJK } from '../types';\nimport { getBoundingBoxAroundShapeIJK } from './boundingBox';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * Given an imageData, and the great circle top and bottom points of a sphere,\n * this function will run the callback for each point of the imageData that is\n * within the sphere defined by the great circle points. If the viewport\n * is provided, region of interest will be an accurate approximation of the\n * sphere (using viewport camera), and the resulting performance will be\n * better.\n *\n * @privateRemarks great circle also known as orthodrome is the intersection of\n * the sphere and the plane that passes through the center of the sphere\n *\n * @param imageData - The volume imageData\n * @param circlePoints - bottom and top points of the great circle in world coordinates\n * @param callback - A callback function that will be called for each point in the shape.\n */\nfunction getSphereBoundsInfo(\n  circlePoints: [Types.Point3, Types.Point3],\n  imageData: vtkImageData,\n  viewport\n): {\n  boundsIJK: BoundsIJK;\n  centerWorld: Types.Point3;\n  radiusWorld: number;\n  topLeftWorld: Types.Point3;\n  bottomRightWorld: Types.Point3;\n} {\n  const [bottom, top] = circlePoints;\n\n  // Sphere center in world\n  const centerWorld = vec3.fromValues(\n    (bottom[0] + top[0]) / 2,\n    (bottom[1] + top[1]) / 2,\n    (bottom[2] + top[2]) / 2\n  );\n\n  // sphere radius in world\n  const radiusWorld = vec3.distance(bottom, top) / 2;\n\n  if (!viewport) {\n    throw new Error(\n      'viewport is required in order to calculate the sphere bounds'\n    );\n  }\n\n  const { boundsIJK, topLeftWorld, bottomRightWorld } =\n    _computeBoundsIJKWithCamera(\n      imageData,\n      viewport,\n      circlePoints,\n      centerWorld,\n      radiusWorld\n    );\n\n  return {\n    boundsIJK,\n    centerWorld: centerWorld as Types.Point3,\n    radiusWorld,\n    topLeftWorld: topLeftWorld as Types.Point3,\n    bottomRightWorld: bottomRightWorld as Types.Point3,\n  };\n}\n\nfunction _computeBoundsIJKWithCamera(\n  imageData,\n  viewport,\n  circlePoints,\n  centerWorld,\n  radiusWorld\n) {\n  const [bottom, top] = circlePoints;\n\n  const dimensions = imageData.getDimensions() as Types.Point3;\n\n  const camera = viewport.getCamera();\n\n  // Calculate viewRight from the camera, this will get used in order to\n  // calculate circles topLeft and bottomRight on different planes of intersection\n  // between sphere and viewPlane\n  const viewUp = vec3.fromValues(\n    camera.viewUp[0],\n    camera.viewUp[1],\n    camera.viewUp[2]\n  );\n  const viewPlaneNormal = vec3.fromValues(\n    camera.viewPlaneNormal[0],\n    camera.viewPlaneNormal[1],\n    camera.viewPlaneNormal[2]\n  );\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n  // we need to find the bounding box of the sphere in the image, e.g., the\n  // topLeftWorld and bottomRightWorld points of the bounding box.\n  // We go from the sphereCenter in the normal direction of amount radius, and\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\n  // in the opposite direction and go right to find the bottomRightWorld point\n  // of the bounding box.\n  const topLeftWorld = vec3.create();\n  const bottomRightWorld = vec3.create();\n\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n\n  // go in the direction of viewRight with the value of radius\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n\n  // In order to correctly come up with the boundsIJK, we need to consider\n  // all the points IJK to get the bounds, since the viewport might have\n  // rotate views and we cannot guarantee that the topLeft and bottomRight in the\n  // world, are the ones that will define the bounds in IJK\n  const topLeftIJK = transformWorldToIndex(\n    imageData,\n    topLeftWorld as Types.Point3\n  );\n  const bottomRightIJK = transformWorldToIndex(\n    imageData,\n    bottomRightWorld as Types.Point3\n  );\n\n  const pointsIJK = circlePoints.map((p) =>\n    transformWorldToIndex(imageData, p)\n  );\n\n  // get the bounding box of the sphere in the image\n  const boundsIJK = getBoundingBoxAroundShapeIJK(\n    [topLeftIJK, bottomRightIJK, ...pointsIJK],\n    dimensions\n  );\n\n  return { boundsIJK, topLeftWorld, bottomRightWorld };\n}\n\nexport { getSphereBoundsInfo };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport { Annotation } from '../types';\n\nexport type FramesRange = [number, number] | number;\n\n/**\n * This class handles the annotation frame range values for multiframes.\n * Mostly used for the Video viewport, it allows references to\n * a range of frame values.\n */\nexport default class AnnotationFrameRange {\n  protected static frameRangeExtractor =\n    /(\\/frames\\/|[&?]frameNumber=)([^/&?]*)/i;\n\n  protected static imageIdToFrames(imageId: string): FramesRange {\n    const match = imageId.match(this.frameRangeExtractor);\n    if (!match || !match[2]) {\n      return null;\n    }\n    const range = match[2].split('-').map((it) => Number(it));\n    if (range.length === 1) {\n      return range[0];\n    }\n    return range as FramesRange;\n  }\n\n  public static framesToString(range) {\n    if (Array.isArray(range)) {\n      return `${range[0]}-${range[1]}`;\n    }\n    return String(range);\n  }\n\n  protected static framesToImageId(\n    imageId: string,\n    range: FramesRange | string\n  ): string {\n    const match = imageId.match(this.frameRangeExtractor);\n    if (!match || !match[2]) {\n      return null;\n    }\n    const newRangeString = this.framesToString(range);\n    return imageId.replace(\n      this.frameRangeExtractor,\n      `${match[1]}${newRangeString}`\n    );\n  }\n\n  /**\n   * Sets the range of frames to associate with the given annotation.\n   * The range can be a single frame number (1 based according to DICOM),\n   * or a range of values in the format `min-max` where min, max are inclusive\n   * Modifies the referencedImageID to specify the updated URL.\n   */\n  public static setFrameRange(\n    annotation: Annotation,\n    range: FramesRange | string,\n    eventBase?: { viewportId; renderingEngineId }\n  ) {\n    const { referencedImageId } = annotation.metadata;\n    annotation.metadata.referencedImageId = this.framesToImageId(\n      referencedImageId,\n      range\n    );\n    const eventDetail = {\n      ...eventBase,\n      annotation,\n    };\n    triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\n  }\n\n  public static getFrameRange(\n    annotation: Annotation\n  ): number | [number, number] {\n    return this.imageIdToFrames(annotation.metadata.referencedImageId);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\ntype Sphere = {\n  center: Types.Point3 | vec3;\n  radius: number;\n  // Square of the radius\n  radius2?: number;\n};\n\n/**\n * Checks if a point is inside a sphere. Note: this is similar to the\n * `pointInEllipse` function, but since we don't need checks for the\n * ellipse's rotation in different views, we can use a simpler equation\n * which would be faster (no if statements).\n *\n * This is safe to call for point in circle as long as you don't call it with\n * anything off-plane - that is, a circle is a degenerate sphere that is\n * intersected with the primary plane.\n *\n * @param sphere - Sphere object with center and radius and radius squared\n *     as radius2 if you are calling this a huge number of times.\n * @param pointLPS - the point to check in world coordinates\n * @returns boolean\n */\nexport default function pointInSphere(sphere: Sphere, pointLPS: vec3): boolean {\n  const { center, radius } = sphere;\n  const radius2 = sphere.radius2 || radius * radius;\n\n  return (\n    (pointLPS[0] - center[0]) * (pointLPS[0] - center[0]) +\n      (pointLPS[1] - center[1]) * (pointLPS[1] - center[1]) +\n      (pointLPS[2] - center[2]) * (pointLPS[2] - center[2]) <=\n    radius2\n  );\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { vec3 } from 'gl-matrix';\nimport { pointInSphere } from './math/sphere';\nimport pointInShapeCallback, {\n  PointInShapeCallback,\n} from './pointInShapeCallback';\nimport { BoundsIJK } from '../types';\nimport { getBoundingBoxAroundShape } from './boundingBox';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * Given an imageData, and the great circle top and bottom points of a sphere,\n * this function will run the callback for each point of the imageData that is\n * within the sphere defined by the great circle points. If the viewport\n * is provided, region of interest will be an accurate approximation of the\n * sphere (using viewport camera), and the resulting performance will be\n * better.\n *\n * @privateRemarks great circle also known as orthodrome is the intersection of\n * the sphere and the plane that passes through the center of the sphere\n *\n * @param imageData - The volume imageData\n * @param circlePoints - bottom and top points of the great circle in world coordinates\n * @param callback - A callback function that will be called for each point in the shape.\n */\nexport default function pointInSurroundingSphereCallback(\n  imageData: vtkImageData,\n  circlePoints: [Types.Point3, Types.Point3],\n  callback: PointInShapeCallback,\n  viewport?: Types.IVolumeViewport\n): void {\n  // We can run the sphere equation to determine if a point is inside\n  // the sphere; however, since the imageData dimensions can be quite large, we\n  // can narrow down the search by estimating the bounds of the sphere in index\n  // space.\n  const { boundsIJK, centerWorld, radiusWorld } = _getBounds(\n    circlePoints,\n    imageData,\n    viewport\n  );\n\n  const sphereObj = {\n    center: centerWorld,\n    radius: radiusWorld,\n  };\n\n  pointInShapeCallback(\n    imageData,\n    (pointLPS) => pointInSphere(sphereObj, pointLPS),\n    callback,\n    boundsIJK\n  );\n}\n\nfunction _getBounds(\n  circlePoints: [Types.Point3, Types.Point3],\n  imageData: vtkImageData,\n  viewport\n): {\n  boundsIJK: BoundsIJK;\n  centerWorld: Types.Point3;\n  radiusWorld: number;\n} {\n  const [bottom, top] = circlePoints;\n\n  // Sphere center in world\n  const centerWorld = vec3.fromValues(\n    (bottom[0] + top[0]) / 2,\n    (bottom[1] + top[1]) / 2,\n    (bottom[2] + top[2]) / 2\n  );\n\n  // sphere radius in world\n  const radiusWorld = vec3.distance(bottom, top) / 2;\n\n  let boundsIJK;\n\n  if (!viewport) {\n    // If no viewport is provide (no camera), we can estimate the bounding box\n    // of the sphere in index space.\n    // This is done by calculating the maximum value for radius in the index\n    // space (since the radius is in world space, we need to convert it to index, and\n    // each dimensions can have a different scale factor). Therefore, by finding\n    // the minimum spacing value in the imageData, we can calculate the maximum\n    // radius in index space and use that to calculate the bounds of the sphere\n    // This will not be accurate, but it is a good first approximation.\n    // sphere center in index\n    const centerIJK = transformWorldToIndex(\n      imageData,\n      centerWorld as Types.Point3\n    );\n\n    const spacings = imageData.getSpacing();\n    const minSpacing = Math.min(...spacings);\n\n    const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);\n\n    boundsIJK = [\n      [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],\n      [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],\n      [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],\n    ];\n\n    return {\n      boundsIJK,\n      centerWorld: centerWorld as Types.Point3,\n      radiusWorld,\n    };\n  }\n\n  boundsIJK = _computeBoundsIJKWithCamera(\n    imageData,\n    viewport,\n    circlePoints,\n    centerWorld,\n    radiusWorld\n  );\n\n  return {\n    boundsIJK,\n    centerWorld: centerWorld as Types.Point3,\n    radiusWorld,\n  };\n}\n\nfunction _computeBoundsIJKWithCamera(\n  imageData,\n  viewport,\n  circlePoints,\n  centerWorld,\n  radiusWorld\n) {\n  const [bottom, top] = circlePoints;\n\n  const dimensions = imageData.getDimensions() as Types.Point3;\n  const camera = viewport.getCamera();\n\n  // Calculate viewRight from the camera, this will get used in order to\n  // calculate circles topLeft and bottomRight on different planes of intersection\n  // between sphere and viewPlane\n  const viewUp = vec3.fromValues(\n    camera.viewUp[0],\n    camera.viewUp[1],\n    camera.viewUp[2]\n  );\n  const viewPlaneNormal = vec3.fromValues(\n    camera.viewPlaneNormal[0],\n    camera.viewPlaneNormal[1],\n    camera.viewPlaneNormal[2]\n  );\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n  // we need to find the bounding box of the sphere in the image, e.g., the\n  // topLeftWorld and bottomRightWorld points of the bounding box.\n  // We go from the sphereCenter in the normal direction of amount radius, and\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\n  // in the opposite direction and go right to find the bottomRightWorld point\n  // of the bounding box.\n  const topLeftWorld = vec3.create();\n  const bottomRightWorld = vec3.create();\n\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n\n  // go in the direction of viewRight with the value of radius\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n\n  // convert the world coordinates to index coordinates\n\n  const sphereCornersIJK = [\n    <Types.Point3>transformWorldToIndex(imageData, <Types.Point3>topLeftWorld),\n    <Types.Point3>(\n      transformWorldToIndex(imageData, <Types.Point3>bottomRightWorld)\n    ),\n  ];\n\n  // get the bounding box of the sphere in the image\n  const boundsIJK = getBoundingBoxAroundShape(sphereCornersIJK, dimensions);\n\n  return boundsIJK;\n}\n","import { getEnabledElements, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Annotation } from '../types';\n\nconst { isEqual } = csUtils;\n\n/**\n * Finds a all matching viewports in terms of the orientation of the annotation data\n * and the frame of reference. This doesn't mean the annotation IS being displayed\n * on these viewports, just that it could be by navigating the slice, and/or pan/zoom,\n * without changing the orientation.\n *\n * @param annotation - Annotation to find the viewports that it could display in\n * @returns All viewports to display in\n */\nexport default function getViewportsForAnnotation(annotation: Annotation) {\n  const { metadata } = annotation;\n\n  return getEnabledElements()\n    .filter((enabledElement) => {\n      if (enabledElement.FrameOfReferenceUID === metadata.FrameOfReferenceUID) {\n        const viewport = enabledElement.viewport;\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        return (\n          isEqual(viewPlaneNormal, metadata.viewPlaneNormal) &&\n          (!metadata.viewUp || isEqual(viewUp, metadata.viewUp))\n        );\n      }\n      return;\n    })\n    .map((enabledElement) => enabledElement.viewport);\n}\n","import type { Annotation } from '../types';\nimport getViewportsForAnnotation from './getViewportsForAnnotation';\n\n/**\n * Finds a matching viewport in terms of the orientation of the annotation data\n * and the frame of reference.  This doesn't mean the annotation IS being displayed\n * in the viewport, just that it could be by navigating the slice, and/or pan/zoom,\n * without changing the orientation.\n *\n * @param annotation - to find a viewport that it could display in\n * @returns The viewport to display in\n */\nexport default function getViewportForAnnotation(annotation: Annotation) {\n  const viewports = getViewportsForAnnotation(annotation);\n\n  return viewports.length ? viewports[0] : undefined;\n}\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport { ContourAnnotation } from '../../types/ContourAnnotation';\n\n/**\n * Check if two contour segmentation annotations are coplanar.\n *\n * A plane may be represented by a normal and a distance then to know if they\n * are coplanar we need to:\n *   - check if the normals of the two annotations are pointing to the same\n *   direction or to opposite directions (dot product equal to 1 or -1\n *   respectively)\n *   - Get one point from each polyline and project it onto the normal to get\n *   the distance from the origin (0, 0, 0).\n */\nexport default function areCoplanarContours(\n  firstAnnotation: ContourAnnotation,\n  secondAnnotation: ContourAnnotation\n) {\n  const { viewPlaneNormal: firstViewPlaneNormal } = firstAnnotation.metadata;\n  const { viewPlaneNormal: secondViewPlaneNormal } = secondAnnotation.metadata;\n  const dot = vec3.dot(firstViewPlaneNormal, secondViewPlaneNormal);\n  const parallelPlanes = glMatrix.equals(1, Math.abs(dot));\n\n  if (!parallelPlanes) {\n    return false;\n  }\n\n  const { polyline: firstPolyline } = firstAnnotation.data.contour;\n  const { polyline: secondPolyline } = secondAnnotation.data.contour;\n\n  // Choose one of the normals and calculate the distance of a point from each\n  // polyline along that normal. Both normal cannot be used with absolute dot\n  // product values because one of the view planes may be flipped or one of the\n  // points may be at the same distance but in the opposite direction\n  const firstDistance = vec3.dot(firstViewPlaneNormal, firstPolyline[0]);\n  const secondDistance = vec3.dot(firstViewPlaneNormal, secondPolyline[0]);\n\n  return glMatrix.equals(firstDistance, secondDistance);\n}\n","function findNextLink(line, lines, contourPoints) {\n  let index = -1;\n  lines.forEach((cell, i) => {\n    if (index >= 0) {\n      return;\n    }\n\n    if (cell.a == line.b) {\n      index = i;\n    }\n  });\n\n  if (index >= 0) {\n    const nextLine = lines[index];\n    lines.splice(index, 1);\n\n    contourPoints.push(nextLine.b);\n\n    if (contourPoints[0] == nextLine.b) {\n      return {\n        remainingLines: lines,\n        contourPoints,\n        type: 'CLOSED_PLANAR',\n        //type: 'CLOSEDPLANAR_XOR',\n      };\n    }\n\n    return findNextLink(nextLine, lines, contourPoints);\n  }\n\n  return {\n    remainingLines: lines,\n    contourPoints,\n    type: 'OPEN_PLANAR',\n  };\n}\n\n/**\n *\n * @param {*} lines\n */\nexport function findContours(lines) {\n  if (lines.length == 0) {\n    return [];\n  }\n\n  const contourPoints = [];\n\n  const firstCell = lines.shift();\n  contourPoints.push(firstCell.a);\n  contourPoints.push(firstCell.b);\n  const result = findNextLink(firstCell, lines, contourPoints);\n\n  if (result.remainingLines.length == 0) {\n    return [\n      {\n        type: result.type,\n        contourPoints: result.contourPoints,\n      },\n    ];\n  } else {\n    const extraContours = findContours(result.remainingLines);\n    extraContours.push({\n      type: result.type,\n      contourPoints: result.contourPoints,\n    });\n    return extraContours;\n  }\n}\n\nexport function findContoursFromReducedSet(lines) {\n  return findContours(lines);\n}\n\nexport default {\n  findContours,\n  findContoursFromReducedSet,\n};\n","/**\n * Iterate through polyData from vtkjs and merge any points that are the same\n * then update merged point references within lines array\n * @param polyData - vtkPolyData\n * @param bypass - bypass the duplicate point removal\n * @returns the updated polyData\n */\nexport function getDeduplicatedVTKPolyDataPoints(polyData, bypass = false) {\n  const points = polyData.getPoints();\n  const lines = polyData.getLines();\n\n  // Todo: This is cloning which is not ideal, we should move to use the PointsArrayManager\n  // that will get merged soon\n  const pointsArray = new Array(points.getNumberOfPoints())\n    .fill(0)\n    .map((_, i) => points.getPoint(i).slice());\n\n  const linesArray = new Array(lines.getNumberOfCells()).fill(0).map((_, i) => {\n    const cell = lines.getCell(i * 3).slice();\n    return { a: cell[0], b: cell[1] };\n  });\n\n  if (bypass) {\n    return { points: pointsArray, lines: linesArray };\n  }\n\n  const newPoints = [];\n  for (const [i, pt] of pointsArray.entries()) {\n    // Todo: This is an n^2 algorithm - consider using a Map<string,Point3>.\n    // Generates a reasonable amount of garbage, but I think the performance\n    //  of that is better than doing repeated compares across the entire array.\n    const index = newPoints.findIndex(\n      (point) => point[0] === pt[0] && point[1] === pt[1] && point[2] === pt[2]\n    );\n\n    if (index >= 0) {\n      linesArray.map((line) => {\n        if (line.a === i) {\n          line.a = index;\n        }\n        if (line.b === i) {\n          line.b = index;\n        }\n        return line;\n      });\n    } else {\n      const newIndex = newPoints.length;\n      newPoints.push(pt);\n      linesArray.map((line) => {\n        if (line.a === i) {\n          line.a = newIndex;\n        }\n        if (line.b === i) {\n          line.b = newIndex;\n        }\n        return line;\n      });\n    }\n  }\n\n  const newLines = linesArray.filter((line) => line.a !== line.b);\n\n  return { points: newPoints, lines: newLines };\n}\n\nexport default { getDeduplicatedVTKPolyDataPoints };\n","/**\n * Functions for detecting and dealing with holes within contours.\n * Expected Contour format:\n * {\n *   type,\n *   contourPoints\n * }\n */\n\n/**\n * Checks if point is inside polygon defined by vertices array\n * Code from\n * https://stackoverflow.com/questions/22521982/check-if-point-is-inside-a-polygon\n * most original version based on:\n * https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html/pnpoly.html\n * @param {*} point\n * @param {*} vertices\n * @returns\n */\nconst getIsPointInsidePolygon = (point, vertices) => {\n  // Todo: this is a duplicated logic we should merge it with the other one\n  // which is containsPoint in the utilities\n  const x = point[0];\n  const y = point[1];\n\n  let inside = false;\n  for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {\n    const xi = vertices[i][0],\n      yi = vertices[i][1];\n    const xj = vertices[j][0],\n      yj = vertices[j][1];\n\n    const intersect =\n      yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\n    if (intersect) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n};\n\n/**\n * Check if inner contour is completely surrounded by outer contour.\n * @param {*} outerContour\n * @param {*} innerContour\n * @returns\n */\nfunction checkEnclosed(outerContour, innerContour, points) {\n  const vertices = [];\n  outerContour.contourPoints.forEach((point) => {\n    vertices.push([points[point][0], points[point][1]]);\n  });\n\n  let pointsNotEnclosed = 0;\n  innerContour.contourPoints.forEach((point) => {\n    const result = getIsPointInsidePolygon(\n      [points[point][0], points[point][1]],\n      vertices\n    );\n    //console.log(result);\n\n    if (!result) {\n      pointsNotEnclosed++;\n    }\n  });\n\n  return pointsNotEnclosed === 0;\n}\n\n/**\n * Check if contours have holes, if so update contour accordingly\n * @param {*} polyData\n * @param {*} bypass\n */\nexport function processContourHoles(contours, points, useXOR = true) {\n  //console.log(points);\n\n  // Add non-closed planars to contour list\n  const retContours = contours.filter(\n    (contour) => contour.type !== 'CLOSED_PLANAR'\n  );\n\n  // Find closed planar contours\n  const closedContours = contours.filter(\n    (contour) => contour.type === 'CLOSED_PLANAR'\n  );\n\n  // Iterate through each contour in list check for contours that have holes\n  const contourWithHoles = [];\n  let contourWithoutHoles = [];\n  closedContours.forEach((contour, index) => {\n    const holes = [];\n\n    // Check if any other contour is a hole surrounded by current contour\n    closedContours.forEach((hContour, hIndex) => {\n      if (index != hIndex) {\n        // Check if inner loop contour is a hole of outer loop contour\n        if (checkEnclosed(contour, hContour, points)) {\n          holes.push(hIndex);\n        }\n      }\n    });\n\n    // Check if holes were found\n    if (holes.length > 0) {\n      // Note current contour and reference of its holes\n      contourWithHoles.push({\n        contour,\n        holes,\n      });\n    } else {\n      // Note contour index without holes\n      contourWithoutHoles.push(index);\n    }\n  });\n\n  if (useXOR) {\n    // XOR method\n    contourWithHoles.forEach((contourHoleSet) => {\n      // Modify contour with hole to type CLOSEDPLANAR_XOR\n      contourHoleSet.contour.type = 'CLOSEDPLANAR_XOR';\n      retContours.push(contourHoleSet.contour);\n\n      contourHoleSet.holes.forEach((holeIndex) => {\n        // Modify hole type to CLOSEDPLANAR_XOR\n        // and add to contour list to be returned\n        closedContours[holeIndex].type = 'CLOSEDPLANAR_XOR';\n        retContours.push(closedContours[holeIndex]);\n\n        // Remove hole from list of contours without holes\n        contourWithoutHoles = contourWithoutHoles.filter((contourIndex) => {\n          return contourIndex !== holeIndex;\n        });\n      });\n    });\n\n    // Add remaining contours to list (neither hole nor have holes)\n    contourWithoutHoles.forEach((contourIndex) => {\n      retContours.push(closedContours[contourIndex]);\n    });\n  } else {\n    // Keyhole method, not implemented\n  }\n\n  return retContours;\n}\n\nexport default { processContourHoles };\n","import { cache as cornerstoneCache } from '@cornerstonejs/core';\nimport vtkImageMarchingSquares from '@kitware/vtk.js/Filters/General/ImageMarchingSquares';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\n\nimport { getDeduplicatedVTKPolyDataPoints } from '../contours';\nimport { findContoursFromReducedSet } from './contourFinder';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\n\nconst { Labelmap } = SegmentationRepresentations;\n\nfunction generateContourSetsFromLabelmap({ segmentations }) {\n  const { representationData, segments = [0, 1] } = segmentations;\n  const { volumeId: segVolumeId } = representationData[Labelmap];\n\n  // Get segmentation volume\n  const vol = cornerstoneCache.getVolume(segVolumeId);\n  if (!vol) {\n    console.warn(`No volume found for ${segVolumeId}`);\n    return;\n  }\n\n  const numSlices = vol.dimensions[2];\n\n  // NOTE: Workaround for marching squares not finding closed contours at\n  // boundary of image volume, clear pixels along x-y border of volume\n  const segData = vol.imageData.getPointData().getScalars().getData();\n  const pixelsPerSlice = vol.dimensions[0] * vol.dimensions[1];\n\n  for (let z = 0; z < numSlices; z++) {\n    for (let y = 0; y < vol.dimensions[1]; y++) {\n      const index = y * vol.dimensions[0] + z * pixelsPerSlice;\n      segData[index] = 0;\n      segData[index + vol.dimensions[0] - 1] = 0;\n    }\n  }\n\n  // end workaround\n  //\n  //\n  const ContourSets = [];\n\n  const { FrameOfReferenceUID } = vol.metadata;\n  // Iterate through all segments in current segmentation set\n  const numSegments = segments.length;\n  for (let segIndex = 0; segIndex < numSegments; segIndex++) {\n    const segment = segments[segIndex];\n\n    // Skip empty segments\n    if (!segment) {\n      continue;\n    }\n\n    const sliceContours = [];\n    const scalars = vtkDataArray.newInstance({\n      name: 'Scalars',\n      numberOfComponents: 1,\n      size: pixelsPerSlice * numSlices,\n      dataType: 'Uint8Array',\n    });\n    const { containedSegmentIndices } = segment;\n    for (let sliceIndex = 0; sliceIndex < numSlices; sliceIndex++) {\n      // Check if the slice is empty before running marching cube\n      if (\n        isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex)\n      ) {\n        continue;\n      }\n      const frameStart = sliceIndex * pixelsPerSlice;\n\n      try {\n        // Modify segData for this specific segment directly\n        for (let i = 0; i < pixelsPerSlice; i++) {\n          const value = segData[i + frameStart];\n          if (value === segIndex || containedSegmentIndices?.has(value)) {\n            (scalars as any).setValue(i + frameStart, 1);\n          } else {\n            (scalars as any).setValue(i, 0);\n          }\n        }\n\n        const mSquares = vtkImageMarchingSquares.newInstance({\n          slice: sliceIndex,\n        });\n\n        // filter out the scalar data so that only it has background and\n        // the current segment index\n        const imageDataCopy = vtkImageData.newInstance();\n\n        imageDataCopy.shallowCopy(vol.imageData);\n        imageDataCopy.getPointData().setScalars(scalars);\n\n        // Connect pipeline\n        mSquares.setInputData(imageDataCopy);\n        const cValues = [1];\n        mSquares.setContourValues(cValues);\n        mSquares.setMergePoints(false);\n\n        // Perform marching squares\n        const msOutput = mSquares.getOutputData();\n\n        // Clean up output from marching squares\n        const reducedSet = getDeduplicatedVTKPolyDataPoints(msOutput);\n        if (reducedSet.points?.length) {\n          const contours = findContoursFromReducedSet(reducedSet.lines);\n\n          sliceContours.push({\n            contours,\n            polyData: reducedSet,\n            FrameNumber: sliceIndex + 1,\n            sliceIndex,\n            FrameOfReferenceUID,\n          });\n        }\n      } catch (e) {\n        console.warn(sliceIndex);\n        console.warn(e);\n      }\n    }\n\n    const metadata = {\n      FrameOfReferenceUID,\n    };\n\n    const ContourSet = {\n      label: segment.label,\n      color: segment.color,\n      metadata,\n      sliceContours,\n    };\n\n    ContourSets.push(ContourSet);\n  }\n\n  return ContourSets;\n}\n\nfunction isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex) {\n  const startIdx = sliceIndex * pixelsPerSlice;\n  const endIdx = startIdx + pixelsPerSlice;\n\n  for (let i = startIdx; i < endIdx; i++) {\n    if (segData[i] === segIndex) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport { generateContourSetsFromLabelmap };\n","// comment\nclass RectangleROIStartEndThreshold {\n  static toolName: string;\n\n  constructor() {\n    // empty\n  }\n\n  static getContourSequence(toolData, metadataProvider) {\n    const { data } = toolData;\n    const { projectionPoints, projectionPointsImageIds } = data.cachedStats;\n\n    return projectionPoints.map((point, index) => {\n      const ContourData = getPointData(point);\n      const ContourImageSequence = getContourImageSequence(\n        projectionPointsImageIds[index],\n        metadataProvider\n      );\n\n      return {\n        NumberOfContourPoints: ContourData.length / 3,\n        ContourImageSequence,\n        ContourGeometricType: 'CLOSED_PLANAR',\n        ContourData,\n      };\n    });\n  }\n}\n\nRectangleROIStartEndThreshold.toolName = 'RectangleROIStartEndThreshold';\n\nfunction getPointData(points) {\n  // Since this is a closed contour, the order of the points is important.\n  // re-order the points to be in the correct order clockwise\n  // Spread to make sure Float32Arrays are converted to arrays\n  const orderedPoints = [\n    ...points[0],\n    ...points[1],\n    ...points[3],\n    ...points[2],\n  ];\n  const pointsArray = orderedPoints.flat();\n\n  // reduce the precision of the points to 2 decimal places\n  const pointsArrayWithPrecision = pointsArray.map((point) => {\n    return point.toFixed(2);\n  });\n\n  return pointsArrayWithPrecision;\n}\n\nfunction getContourImageSequence(imageId, metadataProvider) {\n  const sopCommon = metadataProvider.get('sopCommonModule', imageId);\n\n  return {\n    ReferencedSOPClassUID: sopCommon.sopClassUID,\n    ReferencedSOPInstanceUID: sopCommon.sopInstanceUID,\n  };\n}\nexport default RectangleROIStartEndThreshold;\n","import RectangleROIStartEndThreshold from './RectangleROIStartEndThreshold';\n\nfunction validateAnnotation(annotation) {\n  if (!annotation?.data) {\n    throw new Error('Tool data is empty');\n  }\n\n  if (!annotation.metadata || annotation.metadata.referenceImageId) {\n    throw new Error('Tool data is not associated with any imageId');\n  }\n}\n\nclass AnnotationToPointData {\n  static TOOL_NAMES: Record<string, any> = {};\n\n  constructor() {\n    // empty\n  }\n\n  static convert(annotation, index, metadataProvider) {\n    validateAnnotation(annotation);\n\n    const { toolName } = annotation.metadata;\n    const toolClass = AnnotationToPointData.TOOL_NAMES[toolName];\n\n    if (!toolClass) {\n      throw new Error(\n        `Unknown tool type: ${toolName}, cannot convert to RTSSReport`\n      );\n    }\n\n    // Each toolData should become a list of contours, ContourSequence\n    // contains a list of contours with their pointData, their geometry\n    // type and their length.\n    const ContourSequence = toolClass.getContourSequence(\n      annotation,\n      metadataProvider\n    );\n\n    // Todo: random rgb color for now, options should be passed in\n    const color = [\n      Math.floor(Math.random() * 255),\n      Math.floor(Math.random() * 255),\n      Math.floor(Math.random() * 255),\n    ];\n\n    return {\n      ReferencedROINumber: index + 1,\n      ROIDisplayColor: color,\n      ContourSequence,\n    };\n  }\n\n  static register(toolClass) {\n    AnnotationToPointData.TOOL_NAMES[toolClass.toolName] = toolClass;\n  }\n}\n\nAnnotationToPointData.register(RectangleROIStartEndThreshold);\n\nexport default AnnotationToPointData;\n","import type { Types } from '@cornerstonejs/core';\nimport type { Annotation, ContourAnnotation } from '../../types';\nimport { getAnnotation } from '../../stateManagement';\n\n/**\n * Get child polylines data in world space for contour annotations that represent the holes\n * @param annotation - Annotation\n * @param viewport - Viewport used to convert the points from world to canvas space\n * @returns An array that contains all child polylines (holes) in world space\n */\nexport default function getContourHolesDataWorld(\n  annotation: Annotation\n): Types.Point3[][] {\n  const childAnnotationUIDs = annotation.childAnnotationUIDs ?? [];\n\n  return childAnnotationUIDs.map(\n    (uid) => (getAnnotation(uid) as ContourAnnotation).data.contour.polyline\n  );\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { Annotation } from '../../types';\nimport getContourHolesDataWorld from './getContourHolesDataWorld';\n\n/**\n * Get the polylines for the child annotations (holes)\n * @param annotation - Annotation\n * @param viewport - Viewport used to convert the points from world to canvas space\n * @returns An array that contains all child polylines\n */\nexport default function getContourHolesDataCanvas(\n  annotation: Annotation,\n  viewport: Types.IViewport\n): Types.Point2[][] {\n  const worldHoleContours = getContourHolesDataWorld(annotation);\n  const canvasHoleContours = [];\n\n  worldHoleContours.forEach((worldHoleContour) => {\n    const numPoints = worldHoleContour.length;\n\n    // Pre-allocated arrays are 3-4x faster than multiple \"push()\" calls\n    const canvasHoleContour: Types.Point2[] = new Array(numPoints);\n\n    // Using FOR loop instead of map() for better performance when processing large arrays\n    for (let i = 0; i < numPoints; i++) {\n      canvasHoleContour[i] = viewport.worldToCanvas(worldHoleContour[i]);\n    }\n\n    canvasHoleContours.push(canvasHoleContour);\n  });\n\n  return canvasHoleContours;\n}\n","import type { Types } from '@cornerstonejs/core';\n\ntype Point = Types.Point2 | Types.Point3;\n\n/**\n * Calculates the distance squared of a point to another point\n *\n * @param p1 - x,y or x,y,z of the point\n * @param p2 - x,y or x,y,z of the point\n * @returns distance\n */\nexport default function distanceToPointSquared(p1: Point, p2: Point): number {\n  if (p1.length !== p2.length) {\n    throw Error('Both points should have the same dimensionality');\n  }\n\n  const [x1, y1, z1 = 0] = p1;\n  const [x2, y2, z2 = 0] = p2;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const dz = z2 - z1;\n\n  // Time to square 10M numbers:\n  //   (n * n) = 161ms | (n ** 2) = 199ms | Math.pow(n, 2) = 29529ms\n  return dx * dx + dy * dy + dz * dz;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as math from '../';\n\n/**\n * Calculate the closest point and the squared distance between a reference point and a line segment.\n *\n * It projects the reference point onto the line segment but it shall be bounded by the\n * start/end points since this is a line segment and not a line which could be extended.\n *\n * @param lineStart - Start point of the line segment\n * @param lineEnd - End point of the line segment\n * @param point - Reference point\n * @returns Closest point and the squared distance between a `point` and a line\n *   segment defined by `lineStart` and `lineEnd` points\n */\nexport default function distanceToPointSquaredInfo(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): {\n  point: Types.Point2;\n  distanceSquared: number;\n} {\n  let closestPoint: Types.Point2;\n  const distanceSquared = math.point.distanceToPointSquared(lineStart, lineEnd);\n\n  // Check if lineStart equal to the lineEnd which means the closest point\n  // is any of these two points\n  if (lineStart[0] === lineEnd[0] && lineStart[1] === lineEnd[1]) {\n    closestPoint = lineStart;\n  }\n\n  if (!closestPoint) {\n    const dotProduct =\n      ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) +\n        (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) /\n      distanceSquared;\n\n    if (dotProduct < 0) {\n      closestPoint = lineStart;\n    } else if (dotProduct > 1) {\n      closestPoint = lineEnd;\n    } else {\n      closestPoint = [\n        lineStart[0] + dotProduct * (lineEnd[0] - lineStart[0]),\n        lineStart[1] + dotProduct * (lineEnd[1] - lineStart[1]),\n      ];\n    }\n  }\n\n  return {\n    point: [...closestPoint],\n    distanceSquared: math.point.distanceToPointSquared(point, closestPoint),\n  };\n}\n","import { Types } from '@cornerstonejs/core';\nimport distanceToPointSquaredInfo from './distanceToPointSquaredInfo';\n\n/**\n * Calculates the distance-squared of a point to a line segment\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance-squared\n */\nexport default function distanceToPointSquared(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  return distanceToPointSquaredInfo(lineStart, lineEnd, point).distanceSquared;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as mathLine from '../line';\n\nconst DEFAULT_EPSILON = 0.1;\n\n/**\n * Ramer–Douglas–Peucker algorithm implementation to decimate a polyline\n * to a similar polyline with fewer points\n *\n * https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\n * https://rosettacode.org/wiki/Ramer-Douglas-Peucker_line_simplification\n * https://karthaus.nl/rdp/\n *\n * @param polyline - Polyline to decimate\n * @param epsilon - A maximum given distance 'epsilon' to decide if a point\n * should or shouldn't be added the decimated polyline version. In each\n * iteration the polyline is split into two polylines and the distance of each\n * point from those new polylines are checked against the line that connects\n * the first and last points.\n * @returns Decimated polyline\n */\nexport default function decimate(\n  polyline: Types.Point2[],\n  epsilon = DEFAULT_EPSILON\n) {\n  const numPoints = polyline.length;\n\n  // The polyline must have at least a start and end points\n  if (numPoints < 3) {\n    return polyline;\n  }\n\n  const epsilonSquared = epsilon * epsilon;\n  const partitionQueue = [[0, numPoints - 1]];\n\n  // Used a boolean array to set each point that will be in the decimated polyline\n  // because pre-allocated arrays are 3-4x faster than thousands of push() calls\n  // to add all points to a new array.\n  const polylinePointFlags = new Array(numPoints).fill(false);\n\n  // Start and end points are always added to the decimated polyline\n  let numDecimatedPoints = 2;\n\n  // Add start and end points to the decimated polyline\n  polylinePointFlags[0] = true;\n  polylinePointFlags[numPoints - 1] = true;\n\n  // Iterative approach using a queue instead of recursion to reduce the number\n  // of function calls (performance)\n  while (partitionQueue.length) {\n    const [startIndex, endIndex] = partitionQueue.pop();\n\n    // Return if there is no point between the start and end points\n    if (endIndex - startIndex === 1) {\n      continue;\n    }\n\n    const startPoint = polyline[startIndex];\n    const endPoint = polyline[endIndex];\n    let maxDistSquared = -Infinity;\n    let maxDistIndex = -1;\n\n    // Search for the furthest point\n    for (let i = startIndex + 1; i < endIndex; i++) {\n      const currentPoint = polyline[i];\n      const distSquared = mathLine.distanceToPointSquared(\n        startPoint,\n        endPoint,\n        currentPoint\n      );\n\n      if (distSquared > maxDistSquared) {\n        maxDistSquared = distSquared;\n        maxDistIndex = i;\n      }\n    }\n\n    // Do not add any of the points because the fursthest one is very close to\n    // the line based on the epsilon value\n    if (maxDistSquared < epsilonSquared) {\n      continue;\n    }\n\n    // Update the flag for the furthest point because it will be added to the\n    // decimated polyline\n    polylinePointFlags[maxDistIndex] = true;\n    numDecimatedPoints++;\n\n    // Partition the points into two parts using maxDistIndex as the pivot point\n    // and process both sides\n    partitionQueue.push([maxDistIndex, endIndex]);\n    partitionQueue.push([startIndex, maxDistIndex]);\n  }\n\n  // A pre-allocated array is 3-4x faster then multiple push() calls\n  const decimatedPolyline: Types.Point2[] = new Array(numDecimatedPoints);\n\n  for (let srcIndex = 0, dstIndex = 0; srcIndex < numPoints; srcIndex++) {\n    if (polylinePointFlags[srcIndex]) {\n      decimatedPolyline[dstIndex++] = polyline[srcIndex];\n    }\n  }\n\n  return decimatedPolyline;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the area with signal of a 2D polyline\n * https://www.youtube.com/watch?v=GpsKrAipXm8&t=1900s\n *\n * This functions has a runtime very close to `getArea` and it is recommended to\n * be called only if you need the area signal (eg: calculate polygon normal). If\n * you do not need the area signal you should always call `getArea`.\n *\n *\n * @param polyline - Polyline points (2D)\n * @returns Area of the polyline (with signal)\n */\nexport default function getSignedArea(polyline: Types.Point2[]): number {\n  if (polyline.length < 3) {\n    return 0;\n  }\n\n  // Reference point can be any point on the same plane\n  const refPoint = polyline[0];\n  let area = 0;\n\n  // Takes three points (reference point and two other points from each line\n  // segment) and calculate the area with cross product. The magnitude of the\n  // vector returned by a cross product is equal to the area of the parallelogram\n  // that the vectors span which is two times the area of the triangle.\n  //\n  // Not calling vec3 mathods makes the function run much faster since polylines\n  // may have thousands of points when using freehand ROI tool and that would\n  // increase considerably the number of function calls.\n  for (let i = 0, len = polyline.length; i < len; i++) {\n    const p1 = polyline[i];\n    // Using ternary instead of % (mod) operator to make it faster\n    const p2Index = i === len - 1 ? 0 : i + 1;\n    const p2 = polyline[p2Index];\n    const aX = p1[0] - refPoint[0];\n    const aY = p1[1] - refPoint[1];\n    const bX = p2[0] - refPoint[0];\n    const bY = p2[1] - refPoint[1];\n\n    // Cross product between vectors \"a\" and \"b\" which returns (0, 0, crossProd)\n    // for 2D vectors.\n    area += aX * bY - aY * bX;\n  }\n\n  // Divide by two because cross product returns two times the area for each triangle\n  area *= 0.5;\n\n  return area;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport getSignedArea from './getSignedArea';\n\n/**\n * Calculate the winding direction (CW or CCW) of a polyline\n * @param polyline - Polyline (2D)\n * @returns 1 for CW or -1 for CCW polylines\n */\nexport default function getWindingDirection(polyline: Types.Point2[]): number {\n  const signedArea = getSignedArea(polyline);\n\n  // Return 1 or -1 which is also possible to convert into ContourOrientation\n  return signedArea >= 0 ? 1 : -1;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { Types } from '@cornerstonejs/core';\nimport type { ContourAnnotation } from '../../types';\nimport type { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport * as math from '../math';\nimport {\n  getParentAnnotation,\n  invalidateAnnotation,\n} from '../../stateManagement';\n\n/**\n * Update the contour polyline data\n * @param annotation - Contour annotation\n * @param viewport - Viewport\n * @param polylineData - Polyline data (points, winding direction and closed)\n * @param transforms - Methods to convert points to/from canvas and world spaces\n * @param options - Options\n *   - decimate: allow to set some parameters to decimate the polyline reducing\n *   the amount of points stored which also affects how fast it will draw the\n *   annotation in a viewport, compute the winding direction, append/remove\n *   contours and create holes. A higher `epsilon` value results in a polyline\n *   with less points.\n */\nexport default function updateContourPolyline(\n  annotation: ContourAnnotation,\n  polylineData: {\n    points: Types.Point2[];\n    closed?: boolean;\n    targetWindingDirection?: ContourWindingDirection;\n  },\n  transforms: {\n    canvasToWorld: (point: Types.Point2) => Types.Point3;\n  },\n  options?: {\n    decimate?: {\n      enabled?: boolean;\n      epsilon?: number;\n    };\n  }\n) {\n  const { canvasToWorld } = transforms;\n  const { data } = annotation;\n  const { targetWindingDirection } = polylineData;\n  let { points: polyline } = polylineData;\n\n  // Decimate the polyline to reduce tha amount of points\n  if (options?.decimate?.enabled) {\n    polyline = math.polyline.decimate(\n      polylineData.points,\n      options?.decimate?.epsilon\n    );\n  }\n\n  let { closed } = polylineData;\n  const numPoints = polyline.length;\n  const polylineWorldPoints = new Array(numPoints);\n  const currentWindingDirection = math.polyline.getWindingDirection(polyline);\n  const parentAnnotation = getParentAnnotation(annotation) as ContourAnnotation;\n\n  if (closed === undefined) {\n    let currentClosedState = false;\n\n    // With two points it is just a line and do not make sense to consider it closed\n    if (polyline.length > 3) {\n      const lastToFirstDist = math.point.distanceToPointSquared(\n        polyline[0],\n        polyline[numPoints - 1]\n      );\n\n      currentClosedState = csUtils.isEqual(0, lastToFirstDist);\n    }\n\n    closed = currentClosedState;\n  }\n\n  // It must be in the opposite direction if it is a child annotation (hole)\n  let windingDirection = parentAnnotation\n    ? parentAnnotation.data.contour.windingDirection * -1\n    : targetWindingDirection;\n\n  if (windingDirection === undefined) {\n    windingDirection = currentWindingDirection;\n  } else if (windingDirection !== currentWindingDirection) {\n    polyline.reverse();\n  }\n\n  for (let i = 0; i < numPoints; i++) {\n    polylineWorldPoints[i] = canvasToWorld(polyline[i]);\n  }\n\n  data.contour.polyline = polylineWorldPoints;\n  data.contour.closed = closed;\n  data.contour.windingDirection = windingDirection;\n\n  invalidateAnnotation(annotation);\n}\n","import type {\n  InterpolationViewportData,\n  Annotation,\n  ContourSegmentationAnnotation,\n} from '../../../types';\nimport { getAnnotations } from '../../../stateManagement/annotation/annotationState';\n\nconst DEFAULT_CONTOUR_SEG_TOOLNAME = 'PlanarFreehandContourSegmentationTool';\n\nexport type FilterParam = {\n  /**\n   * Selects a parent value from the given annotation to get the comparison values from.\n   * Was originally a key name, but this became too limited to match multiple levels\n   * of selection, so was changed to a function returning the values.\n   */\n  parentKey?: (annotation) => any;\n\n  /**\n   * The attribute to extract the value from the parent object, compared with\n   * value to see if the filter matches.\n   */\n  key: string;\n\n  /**\n   * The comparison value to compare against.  If an array, will compare sub-values.\n   */\n  value: unknown;\n};\n\n/**\n * getInterpolationData - Gets the list of the slice locations of the 2D\n * polygons that make up the interpolated annotation, along with the annotations\n * which match the specified filterParams on that slice.\n *\n * @param viewportData - the annotation/viewport to start the interpolation from\n * @param filterParams - A selector for annotations for interpolation\n * @returns The list of interpolated locations in the stack\n */\n\nexport default function getInterpolationData(\n  viewportData: InterpolationViewportData,\n  filterParams = []\n): Map<number, Annotation[]> {\n  const { viewport, sliceData, annotation } = viewportData;\n  const interpolationDatas = new Map<number, Annotation[]>();\n  const { toolName, originalToolName } = annotation.metadata;\n  const testToolName = originalToolName || toolName;\n  // Get a copy of the annotations list by filtering it for only\n  // items which are originally the right tool name\n  const annotations = (\n    (getAnnotations(\n      testToolName,\n      viewport.element\n    ) as ContourSegmentationAnnotation[]) || []\n  ).filter(\n    (annotation) =>\n      !annotation.metadata.originalToolName ||\n      annotation.metadata.originalToolName === testToolName\n  );\n\n  // Then add the default contour seg tool name which has the testTool name\n  // to the segmentations list.\n  if (testToolName !== DEFAULT_CONTOUR_SEG_TOOLNAME) {\n    const modifiedAnnotations = getAnnotations(\n      DEFAULT_CONTOUR_SEG_TOOLNAME,\n      viewport.element\n    ) as ContourSegmentationAnnotation[];\n    if (modifiedAnnotations?.length) {\n      modifiedAnnotations.forEach((annotation) => {\n        const { metadata } = annotation;\n        if (\n          metadata.originalToolName === testToolName &&\n          metadata.originalToolName !== metadata.toolName\n        ) {\n          annotations.push(annotation);\n        }\n      });\n    }\n  }\n\n  if (!annotations?.length) {\n    return interpolationDatas;\n  }\n\n  for (let i = 0; i < sliceData.numberOfSlices; i++) {\n    const imageAnnotations = annotations.filter(\n      (x) => x.metadata.sliceIndex === i\n    );\n\n    if (!imageAnnotations?.length) {\n      continue;\n    }\n\n    const filteredInterpolatedAnnotations = imageAnnotations.filter(\n      (imageAnnotation) => {\n        return filterParams.every((x) => {\n          const parent = x.parentKey\n            ? x.parentKey(imageAnnotation)\n            : imageAnnotation;\n          const value = parent?.[x.key];\n          if (Array.isArray(value)) {\n            return value.every((item, index) => item === x.value[index]);\n          }\n          return value === x.value;\n        });\n      }\n    );\n\n    if (filteredInterpolatedAnnotations.length) {\n      interpolationDatas.set(i, filteredInterpolatedAnnotations);\n    }\n  }\n\n  return interpolationDatas;\n}\n","import { Types, utilities as csUtils } from '@cornerstonejs/core';\nimport { InterpolationROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\n\n/**\n * Creates a new annotation instance given the tool data, based on the referenced tool\n * data type.\n * Note that this object takes ownership of the polyline and handlePoints data, that is,\n * directly assigns them internally to the result.\n *\n * @param polyline - data for the polyline, owned hereafter by the annotation\n * @param handlePoints - data for the edit handles, if any, owned hereafter by the annotation\n * @param referencedToolData - for base data for the new tool\n\n */\nexport default function createPolylineToolData(\n  polyline,\n  handlePoints,\n  referencedToolData\n) {\n  const annotation: InterpolationROIAnnotation = csUtils.deepMerge(\n    {\n      data: {},\n      metadata: {},\n    },\n    referencedToolData\n  );\n  Object.assign(annotation, {\n    highlighted: false,\n    invalidated: true,\n    autoGenerated: true,\n    annotationUID: undefined,\n    cachedStats: {},\n    childAnnotationUIDs: [],\n    parentAnnotationUID: undefined,\n  });\n  Object.assign(annotation.data, {\n    handles: {\n      points: handlePoints.points || handlePoints || [],\n      /**\n       * The interpolation sources contains the source points used for interpolating\n       * to generate the new handles.  This allows performing other types of\n       * interpolation to generate the new handles, such as livewire.\n       */\n      interpolationSources: handlePoints.sources,\n      activeHandleIndex: null,\n      textBox: {\n        hasMoved: false,\n        worldPosition: <Types.Point3>[0, 0, 0],\n        worldBoundingBox: {\n          topLeft: <Types.Point3>[0, 0, 0],\n          topRight: <Types.Point3>[0, 0, 0],\n          bottomLeft: <Types.Point3>[0, 0, 0],\n          bottomRight: <Types.Point3>[0, 0, 0],\n        },\n      },\n    },\n    contour: {\n      ...referencedToolData.data.contour,\n      polyline,\n    },\n  });\n\n  return annotation;\n}\n","import getInterpolationData from './getInterpolationData';\nimport type { InterpolationViewportData, Annotation } from '../../../types';\n\n/**\n * A pair of slice indices for contours, typically indicating the\n * pair of contours to interpolate between, or for a possible range to\n * compare against.\n */\nexport type ContourPair = [number, number];\n\n/**\n * Finds the list of contours to interpolate,\n * including whether they are new contours, or auto generated contours that need\n * to be updated.\n *\n * @param toolData - object, The tool data of the roi contour.\n * @param viewportData - the annotation/viewport to start the interpolation from\n * @returns An object containing the interpolationData and the\n *       interpolationList.\n */\n\nfunction findAnnotationsForInterpolation(\n  toolData,\n  viewportData: InterpolationViewportData\n) {\n  const interpolationData = getInterpolationData(viewportData, [\n    {\n      key: 'interpolationUID',\n      value: viewportData.interpolationUID,\n    },\n  ]);\n  const rangeToInterpolate = getRangeToInterpolate(interpolationData);\n  if (!rangeToInterpolate) {\n    console.warn('No annotations found to interpolate', interpolationData);\n    return;\n  }\n  const sliceEdited = _getSlicePositionOfToolData(\n    interpolationData,\n    toolData.annotationUID\n  );\n  const interpolationList = [];\n\n  // Check if contours between the extent can be interpolated.\n  for (let i = rangeToInterpolate[0] + 1; i < rangeToInterpolate[1]; i++) {\n    if (_sliceNeedsInterpolating(interpolationData, i)) {\n      const contourPair = _getBoundingPair(\n        i,\n        rangeToInterpolate,\n        interpolationData\n      );\n\n      if (\n        contourPair?.[0] === sliceEdited ||\n        contourPair?.[1] === sliceEdited\n      ) {\n        _appendInterpolationList(contourPair, interpolationList, i);\n      }\n    }\n  }\n\n  return {\n    interpolationData,\n    interpolationList,\n  };\n}\n\n/**\n * Gets the range of interpolation data which has\n * annotations in it, as indices into the interpolationData\n *\n * @param interpolationData - Data on the slice location of contours to be\n *       interpolated.\n * @returns Number[], The slice locations of the top and bottom polygon of the ROIContour.\n */\n\nfunction getRangeToInterpolate(\n  interpolationData: Map<number, Annotation[]>\n): ContourPair {\n  let first = Infinity;\n  let last = -Infinity;\n  let found = false;\n\n  for (const [sliceIndex, annotations] of interpolationData.entries()) {\n    if (annotations.length) {\n      first = Math.min(sliceIndex, first);\n      last = Math.max(sliceIndex, last);\n      found = true;\n    }\n  }\n  if (!found) {\n    return;\n  }\n\n  return [first, last];\n}\n\n/**\n * _getSlicePositionOfToolData - Finds the slice that was edited.\n *\n * @param interpolationData - Data on the slice location of contours to be\n *       interpolated.\n * @param annotationUID - the UID to find the slice position for\n * @returns index in the interpolationData containing that annotationUID\n */\nfunction _getSlicePositionOfToolData(\n  interpolationData: Map<number, Annotation[]>,\n  annotationUID: string\n): number {\n  for (const [sliceIndex, annotations] of interpolationData) {\n    for (let j = 0; j < annotations.length; j++) {\n      if (annotations[j].annotationUID === annotationUID) {\n        return sliceIndex;\n      }\n    }\n  }\n\n  return;\n}\n\n/**\n * Slices need interpolation when either:\n *   * There are no contours on this slice\n *   * There is a contour which is an interpolated contour.\n *\n * @param interpolationData - Data on the slice location of contours to be\n *       interpolated.\n * @param sliceIndex - The slice index.\n * @returns Whether or not the slice needs interpolating.\n */\nfunction _sliceNeedsInterpolating(\n  interpolationData: Map<number, Annotation[]>,\n  sliceIndex: number\n): boolean {\n  const annotations = interpolationData.get(sliceIndex);\n  return (\n    !annotations?.length ||\n    (annotations.length === 1 && annotations[0].autoGenerated)\n  );\n}\n\n/**\n * If the contour on slice i can be updated, add it to the\n * interpolationList.\n *\n * @param contourPair - the pair of items to append to\n * @param interpolationList - The list of contours to be interpolated.\n * @param itemIndex - the item index to append data to\n */\nfunction _appendInterpolationList(contourPair, interpolationList, itemIndex) {\n  const [startIndex] = contourPair;\n  interpolationList[startIndex] ||= {\n    pair: contourPair,\n    list: [],\n  };\n\n  interpolationList[startIndex].list.push(itemIndex);\n}\n\n/**\n * _getBoundingPair - Given the slice index and range of indices to apply the contour to,\n * get the pair of polygons to use for interpolation of the slice.\n * Returns undefined if there is an ambiguity and interpolation can't take place.\n *\n * @param sliceIndex - The slice index.\n * @param sliceRange - The extent of slice occupancy of the ROIContour.\n * @param interpolationData - Data on the slice location of contours to be\n *       interpolated.\n * @returns The pair of slice indices, or undefined if\n *       the contours to use for interpolation is ambiguous.\n */\n\nfunction _getBoundingPair(\n  sliceIndex: number,\n  sliceRange: ContourPair,\n  interpolationData: Map<number, Annotation[]>\n): ContourPair {\n  const annotationPair = [];\n  let canInterpolate = true;\n\n  // Check for nearest lowest sliceIndex containing contours.\n  for (let i = sliceIndex - 1; i >= sliceRange[0]; i--) {\n    const annotations = interpolationData.get(i);\n    if (annotations?.length) {\n      if (annotations[0].autoGenerated) {\n        // This contour is interpolated. We need to find a solid contour to\n        // interpolate from.\n        continue;\n      }\n\n      if (annotations.length > 1) {\n        canInterpolate = false;\n      }\n\n      // Found single, non interpolated contour to interpolate from.\n      annotationPair.push(i);\n      break;\n    }\n  }\n\n  if (!canInterpolate || !annotationPair.length) {\n    return;\n  }\n\n  // Check for nearest upper sliceIndex containing contours.\n  for (let i = sliceIndex + 1; i <= sliceRange[1]; i++) {\n    const annotations = interpolationData.get(i);\n    if (annotations?.length) {\n      if (annotations[0].autoGenerated) {\n        // This contour is interpolated. We need to\n        // Find a solid contour to interpolate from.\n        continue;\n      }\n\n      if (annotations.length > 1) {\n        canInterpolate = false;\n      }\n\n      annotationPair.push(i);\n      break;\n    }\n  }\n\n  if (!canInterpolate || annotationPair.length < 2) {\n    return;\n  }\n\n  return annotationPair as ContourPair;\n}\n\nexport default findAnnotationsForInterpolation;\n","import { vec3 } from 'gl-matrix';\nimport { utilities } from '@cornerstonejs/core';\nimport type { PointsArray3 } from './interpolate';\n\nconst { PointsManager } = utilities;\n\n/**\n * Selects handles by looking for local maximums in the angle that the local\n * vector makes\n *\n * @param polyline - an array of points, usually the polyline for the contour to\n *        select handles from.\n * @param handleCount - a guideline for how many handles to create\n */\nexport default function selectHandles(\n  polyline: PointsArray3,\n  handleCount = 12\n): PointsArray3 {\n  const handles = PointsManager.create3(handleCount) as PointsArray3;\n  handles.sources = [];\n  const { sources: destPoints } = handles;\n  const { length, sources: sourcePoints = [] } = polyline;\n  // The distance used for figuring out the local angle of a line\n  const distance = 5;\n  if (length < distance * 3) {\n    return polyline.subselect(handleCount);\n  }\n  // Need to make the interval between handles long enough to allow for some\n  // variation between points in terms of the distance of a line angle, but\n  // also not too many handles either.\n  // On average, we get twice the interval between handles, so double the length here.\n  // Or, choose a longer interval if the handle count would have too many handles (too short an interval)\n  const interval = Math.floor(\n    Math.max((2 * length) / handleCount, distance * 2)\n  );\n  sourcePoints.forEach(() =>\n    destPoints.push(PointsManager.create3(handleCount))\n  );\n\n  const dotValues = createDotValues(polyline, distance);\n\n  const minimumRegions = findMinimumRegions(dotValues, handleCount);\n  const indices = [];\n  if (minimumRegions?.length > 2) {\n    let lastHandle = -1;\n    const thirdInterval = interval / 3;\n    minimumRegions.forEach((region) => {\n      const [start, , end] = region;\n      const midIndex = Math.ceil((start + end) / 2);\n      if (end - lastHandle < thirdInterval) {\n        return;\n      }\n      if (midIndex - start > 2 * thirdInterval) {\n        addInterval(indices, lastHandle, start, interval, length);\n        lastHandle = addInterval(indices, start, midIndex, interval, length);\n      } else {\n        lastHandle = addInterval(\n          indices,\n          lastHandle,\n          midIndex,\n          interval,\n          length\n        );\n      }\n      if (end - lastHandle > thirdInterval) {\n        lastHandle = addInterval(indices, lastHandle, end, interval, length);\n      }\n    });\n    const firstHandle = indices[0];\n    const lastDistance = indexValue(firstHandle + length - lastHandle, length);\n    // Check that there is enough space between the last and first handle to\n    // need an extra handle.\n    if (lastDistance > 2 * thirdInterval) {\n      addInterval(\n        indices,\n        lastHandle,\n        // Don't add a point too close to the first handle\n        firstHandle - thirdInterval,\n        interval,\n        length\n      );\n    }\n  } else {\n    const interval = Math.floor(length / handleCount);\n    addInterval(indices, -1, length - interval, interval, length);\n  }\n\n  indices.forEach((index) => {\n    const point = polyline.getPointArray(index);\n    handles.push(point);\n    sourcePoints.forEach((source, destSourceIndex) =>\n      destPoints[destSourceIndex].push(source.getPoint(index))\n    );\n  });\n  return handles;\n}\n\n/**\n * Creates an array of the dot products between each point in the points array\n * and a point +/- distance from that point, unitized to vector length 1.\n * That is, this is a measure of the angle at the given point, where 1 is a\n * straight line, and -1 is a 180 degree angle change.\n *\n * @param polyline - the array of Point3 values\n * @param distance - previous/next distance to use for the vectors for the dot product\n * @returns - Float32Array of dot products, one per point in the source array.\n */\nexport function createDotValues(\n  polyline: PointsArray3,\n  distance = 6\n): Float32Array {\n  const { length } = polyline;\n  const prevVec3 = vec3.create();\n  const nextVec3 = vec3.create();\n  const dotValues = new Float32Array(length);\n\n  for (let i = 0; i < length; i++) {\n    const point = polyline.getPoint(i);\n    const prevPoint = polyline.getPoint(i - distance);\n    const nextPoint = polyline.getPoint((i + distance) % length);\n    vec3.sub(prevVec3, point, prevPoint);\n    vec3.sub(nextVec3, nextPoint, point);\n    const dot =\n      vec3.dot(prevVec3, nextVec3) / (vec3.len(prevVec3) * vec3.len(nextVec3));\n    dotValues[i] = dot;\n  }\n\n  return dotValues;\n}\n\n/**\n * Finds minimum regions in the dot products.  These are detected as\n * center points of the dot values regions having a minimum value - that is,\n * where the direction of the line is changing fastest.\n */\nfunction findMinimumRegions(dotValues, handleCount) {\n  const { max, deviation } = getStats(dotValues);\n  const { length } = dotValues;\n  // Fallback for very uniform ojects.\n  if (deviation < 0.01 || length < handleCount * 3) {\n    return [];\n  }\n\n  const inflection = [];\n  let pair = null;\n  let minValue;\n  let minIndex = 0;\n\n  for (let i = 0; i < length; i++) {\n    const dot = dotValues[i];\n    if (dot < max - deviation) {\n      if (pair) {\n        pair[2] = i;\n        if (dot < minValue) {\n          minValue = dot;\n          minIndex = i;\n        }\n        pair[1] = minIndex;\n      } else {\n        minValue = dot;\n        minIndex = i;\n        pair = [i, i, i];\n      }\n    } else {\n      if (pair) {\n        inflection.push(pair);\n        pair = null;\n      }\n    }\n  }\n  if (pair) {\n    if (inflection[0][0] === 0) {\n      inflection[0][0] = pair[0];\n    } else {\n      pair[1] = minIndex;\n      pair[2] = length - 1;\n      inflection.push(pair);\n    }\n  }\n\n  return inflection;\n}\n\n/**\n * Adds points in between the start and finish.\n * This is currently just the center point for short values and the start/center/end\n * for ranges where the distance between these is at least the increment.\n */\nexport function addInterval(indices, start, finish, interval, length) {\n  if (finish < start) {\n    // Always want a positive distance even if the long way round\n    finish += length;\n  }\n  const distance = finish - start;\n  const count = Math.ceil(distance / interval);\n  if (count <= 0) {\n    if (indices[indices.length - 1] !== finish) {\n      indices.push(indexValue(finish, length));\n    }\n    return finish;\n  }\n  // Don't add the start index, and always add the end index\n  for (let i = 1; i <= count; i++) {\n    const index = indexValue(start + (i * distance) / count, length);\n    indices.push(index);\n  }\n  return indices[indices.length - 1];\n}\n\n/**\n * Gets the index value of a closed polyline, rounding the value and\n * doing the module operation as required.\n */\nfunction indexValue(v, length) {\n  return (Math.round(v) + length) % length;\n}\n\n/**\n * Gets statistics on the provided array numbers.\n */\nfunction getStats(dotValues) {\n  const { length } = dotValues;\n  let sum = 0;\n  let min = Infinity;\n  let max = -Infinity;\n  let sumSq = 0;\n  for (let i = 0; i < length; i++) {\n    const dot = dotValues[i];\n    sum += dot;\n    min = Math.min(min, dot);\n    max = Math.max(max, dot);\n  }\n  const mean = sum / length;\n  for (let i = 0; i < length; i++) {\n    const valueDiff = dotValues[i] - mean;\n    sumSq += valueDiff * valueDiff;\n  }\n  return {\n    mean,\n    max,\n    min,\n    sumSq,\n    deviation: Math.sqrt(sumSq / length),\n  };\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Check if two axis-aligned bounding boxes intersect\n * @param aabb1 - First AABB\n * @param aabb2 - Second AABB\n * @returns True if they intersect or false otherwise\n */\nexport default function intersectAABB(\n  aabb1: Types.AABB2,\n  aabb2: Types.AABB2\n): boolean {\n  return (\n    aabb1.minX <= aabb2.maxX &&\n    aabb1.maxX >= aabb2.minX &&\n    aabb1.minY <= aabb2.maxY &&\n    aabb1.maxY >= aabb2.minY\n  );\n}\n","import type { Types } from '@cornerstonejs/core';\n\n// ATTENTION: this is an internal function and it should not be added to \"polyline\"\n// namespace.\n//\n// TODO: there is a similar function in math.lineSegment.intersectLine but we\n// need to investigate why it is 6x slower than this one when thousands of\n// intersections are calculated. Also that one may return [NaN, NaN] for\n// collinear points.\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects the line (`p2`,`q2`) via an\n * orientation algorithm.\n *\n * Credit and details: geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n *\n * @param p1 - Start point of line segment 1\n * @param q1 - End point of line segment 1\n * @param p2 - Start point of line segment 2\n * @param q2 - End point of line segment 2\n * @returns True if the line segments intersect or false otherwise\n */\nexport default function areLineSegmentsIntersecting(\n  p1: Types.Point2,\n  q1: Types.Point2,\n  p2: Types.Point2,\n  q2: Types.Point2\n): boolean {\n  let result = false;\n\n  // Line 1 AABB\n  const line1MinX = p1[0] < q1[0] ? p1[0] : q1[0];\n  const line1MinY = p1[1] < q1[1] ? p1[1] : q1[1];\n  const line1MaxX = p1[0] > q1[0] ? p1[0] : q1[0];\n  const line1MaxY = p1[1] > q1[1] ? p1[1] : q1[1];\n\n  // Line 2 AABB\n  const line2MinX = p2[0] < q2[0] ? p2[0] : q2[0];\n  const line2MinY = p2[1] < q2[1] ? p2[1] : q2[1];\n  const line2MaxX = p2[0] > q2[0] ? p2[0] : q2[0];\n  const line2MaxY = p2[1] > q2[1] ? p2[1] : q2[1];\n\n  // If AABBs do not intersect it is impossible for the lines to intersect.\n  // Checking AABB before doing any math makes it run ~12% faster.\n  if (\n    line1MinX > line2MaxX ||\n    line1MaxX < line2MinX ||\n    line1MinY > line2MaxY ||\n    line1MaxY < line2MinY\n  ) {\n    return false;\n  }\n\n  const orient = [\n    orientation(p1, q1, p2),\n    orientation(p1, q1, q2),\n    orientation(p2, q2, p1),\n    orientation(p2, q2, q1),\n  ];\n\n  // General Case\n  if (orient[0] !== orient[1] && orient[2] !== orient[3]) {\n    return true;\n  }\n\n  // Special Cases\n  if (orient[0] === 0 && onSegment(p1, p2, q1)) {\n    // If p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    result = true;\n  } else if (orient[1] === 0 && onSegment(p1, q2, q1)) {\n    // If p1, q1 and p2 are colinear and q2 lies on segment p1q1\n    result = true;\n  } else if (orient[2] === 0 && onSegment(p2, p1, q2)) {\n    // If p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    result = true;\n  } else if (orient[3] === 0 && onSegment(p2, q1, q2)) {\n    // If p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    result = true;\n  }\n\n  return result;\n}\n\n/**\n * Checks the orientation of 3 points, returns a 0, 1 or 2 based on\n * the orientation of the points.\n */\nfunction orientation(\n  p: Types.Point2,\n  q: Types.Point2,\n  r: Types.Point2\n): number {\n  // Take the cross product between vectors PQ and QR\n  const orientationValue =\n    (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n\n  if (orientationValue === 0) {\n    return 0; // Colinear\n  }\n\n  return orientationValue > 0 ? 1 : 2;\n}\n\n/**\n * Checks if point `q` lies on the segment (`p`,`r`).\n */\nfunction onSegment(p: Types.Point2, q: Types.Point2, r: Types.Point2): boolean {\n  if (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the first value.\n *\n * @param points - Polyline points\n * @param p1 - First point of the line segment that is being tested\n * @param q1 - Second point of the line segment that is being tested\n * @param closed - Test the intersection with the line segment that connects\n *   the last and first points of the polyline\n * @returns Indexes of the line segment points from the polyline that intersects [p1, q1]\n */\nexport default function getFirstLineSegmentIntersectionIndexes(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2 | undefined {\n  let initialI;\n  let j;\n\n  if (closed) {\n    j = points.length - 1;\n    initialI = 0;\n  } else {\n    j = 0;\n    initialI = 1;\n  }\n\n  for (let i = initialI; i < points.length; i++) {\n    const p2 = points[j];\n    const q2 = points[i];\n\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n      return [j, i];\n    }\n\n    j = i;\n  }\n}\n","import { Types } from '@cornerstonejs/core';\nimport getFirstLineSegmentIntersectionIndexes from './getFirstLineSegmentIntersectionIndexes';\n\n/**\n * Check if two polylines intersect comparing line segment by line segment.\n * @param sourcePolyline - Source polyline\n * @param targetPolyline - Target polyline\n * @returns True if the polylines intersect or false otherwise\n */\nexport default function intersectPolyline(\n  sourcePolyline: Types.Point2[],\n  targetPolyline: Types.Point2[]\n): boolean {\n  // Naive way to detect intersection between polylines in O(n^2).\n  // TODO: Implement Bentley Ottmann sweep line algorithm or maybe some\n  // algorithm that uses r-tree may make it run faster\n  for (let i = 0, sourceLen = sourcePolyline.length; i < sourceLen; i++) {\n    const sourceP1 = sourcePolyline[i];\n    const sourceP2Index = i === sourceLen - 1 ? 0 : i + 1;\n    const sourceP2 = sourcePolyline[sourceP2Index];\n\n    const intersectionPointIndexes = getFirstLineSegmentIntersectionIndexes(\n      targetPolyline,\n      sourceP1,\n      sourceP2\n    );\n\n    if (intersectionPointIndexes?.length === 2) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import { glMatrix } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport * as math from '..';\n\n/**\n * A polyline is considered closed if the start and end points are at the same position\n *\n * @param polyline - Polyline points (2D)\n * @returns True if the polyline is already closed or false otherwise\n */\nexport default function isClosed(polyline: Types.Point2[]): boolean {\n  if (polyline.length < 3) {\n    return false;\n  }\n\n  const numPolylinePoints = polyline.length;\n\n  const firstPoint = polyline[0];\n  const lastPoint = polyline[numPolylinePoints - 1];\n  const distFirstToLastPoints = math.point.distanceToPointSquared(\n    firstPoint,\n    lastPoint\n  );\n\n  return glMatrix.equals(0, distFirstToLastPoints);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport isClosed from './isClosed';\n\n/**\n * Checks if a 2D point is inside the polyline.\n *\n * A point is inside a curve/polygon if the number of intersections between the horizontal\n * ray emanating from the given point and to the right and the line segments is odd.\n * https://www.eecs.umich.edu/courses/eecs380/HANDOUTS/PROJ2/InsidePoly.html\n *\n * Note that a point on the polyline is considered inside.\n *\n * @param polyline - Polyline points (2D)\n * @param point - 2D Point\n * @returns True if the point is inside the polyline or false otherwise\n */\nexport default function containsPoint(\n  polyline: Types.Point2[],\n  point: Types.Point2,\n  options: {\n    closed?: boolean;\n    holes?: Types.Point2[][];\n  } = {\n    closed: undefined,\n  }\n): boolean {\n  if (polyline.length < 3) {\n    return false;\n  }\n\n  const numPolylinePoints = polyline.length;\n  let numIntersections = 0;\n\n  const { closed, holes } = options;\n\n  if (holes?.length) {\n    for (const hole of holes) {\n      if (containsPoint(hole, point)) {\n        return false;\n      }\n    }\n  }\n\n  // Test intersection against [end, start] line segment if it should be closed\n  const shouldClose = !(closed === undefined ? isClosed(polyline) : closed);\n  const maxSegmentIndex = polyline.length - (shouldClose ? 1 : 2);\n\n  for (let i = 0; i <= maxSegmentIndex; i++) {\n    const p1 = polyline[i];\n\n    // Calculating the next point index without using % (mod) operator like in\n    // `(i + 1) % numPolylinePoints` to make it 20% faster\n    const p2Index = i === numPolylinePoints - 1 ? 0 : i + 1;\n    const p2 = polyline[p2Index];\n\n    // Calculating min/max without using Math.min/max to make it ~3% faster\n    const maxX = p1[0] >= p2[0] ? p1[0] : p2[0];\n    const maxY = p1[1] >= p2[1] ? p1[1] : p2[1];\n    const minY = p1[1] <= p2[1] ? p1[1] : p2[1];\n\n    const mayIntersectLineSegment =\n      point[0] <= maxX && point[1] >= minY && point[1] < maxY;\n\n    if (mayIntersectLineSegment) {\n      const isVerticalLine = p1[0] === p2[0];\n      let intersects = isVerticalLine;\n\n      if (!intersects) {\n        const xIntersection =\n          ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];\n\n        intersects = point[0] <= xIntersection;\n      }\n\n      numIntersections += intersects ? 1 : 0;\n    }\n  }\n\n  return !!(numIntersections % 2);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport containsPoint from './containsPoint';\n\n/**\n * Checks if a polyline contains a set of points.\n *\n * @param polyline - Polyline points (2D)\n * @param points - 2D points to verify\n * @returns True if all points are inside the polyline or false otherwise\n */\nexport default function containsPoints(\n  polyline: Types.Point2[],\n  points: Types.Point2[]\n): boolean {\n  for (let i = 0, numPoint = points.length; i < numPoint; i++) {\n    if (!containsPoint(polyline, points[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\n\n/**\n * Get all intersections between a polyline and a line segment.\n * @param polyline - Polyline points\n * @param p1 - Start point of line segment\n * @param q1 - End point of line segment\n * @param closed - Test the intersection against the line segment that connects\n * the last to the first point when set to true\n * @returns Start/end point indexes of all line segments that intersect (p1, q1)\n */\nexport default function getLineSegmentIntersectionsIndexes(\n  polyline: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2[] {\n  const intersections: Types.Point2[] = [];\n  const numPoints = polyline.length;\n  const maxI = numPoints - (closed ? 1 : 2);\n\n  for (let i = 0; i <= maxI; i++) {\n    const p2 = polyline[i];\n    // Do not use % operator for better performance\n    const j = i === numPoints - 1 ? 0 : i + 1;\n    const q2 = polyline[j];\n\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n      intersections.push([i, j]);\n    }\n  }\n\n  return intersections;\n}\n","import { Types } from '@cornerstonejs/core';\nimport getSignedArea from './getSignedArea';\n\n/**\n * Calculate the normal of a 2D polyline\n * https://www.youtube.com/watch?v=GpsKrAipXm8&t=1982s\n *\n * @param polyline - Planar polyline in 2D space\n * @returns Normal of the 2D planar polyline\n */\nexport default function getNormal2(polyline: Types.Point2[]): Types.Point3 {\n  const area = getSignedArea(polyline);\n\n  // The normal of a 2D polyline is (0, 0, 1) or (0, 0, -1) depending if it\n  // is CW or CCW polyline\n  return [0, 0, area / Math.abs(area)] as Types.Point3;\n}\n","import type { Types } from '@cornerstonejs/core';\n\nconst ORIENTATION_TOLERANCE = 1e-2;\n\n/**\n * Test if a point is on a line segment\n * @param lineStart - Line segment start point\n * @param lineEnd - Line segment end point\n * @param point - Point to test\n * @returns True if the point lies on the line segment or false otherwise\n */\nexport default function isPointOnLineSegment(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): boolean {\n  // The code below runs ~4x faster than calling `line.distanceToPointSquared()` (155 vs 598 ms)\n\n  // No Math.min/max call for better performance when testing thousands of points\n  const minX = lineStart[0] <= lineEnd[0] ? lineStart[0] : lineEnd[0];\n  const maxX = lineStart[0] >= lineEnd[0] ? lineStart[0] : lineEnd[0];\n  const minY = lineStart[1] <= lineEnd[1] ? lineStart[1] : lineEnd[1];\n  const maxY = lineStart[1] >= lineEnd[1] ? lineStart[1] : lineEnd[1];\n\n  // Checks if the point lies inside the AABB\n  const aabbContainsPoint =\n    point[0] >= minX - ORIENTATION_TOLERANCE &&\n    point[0] <= maxX + ORIENTATION_TOLERANCE &&\n    point[1] >= minY - ORIENTATION_TOLERANCE &&\n    point[1] <= maxY + ORIENTATION_TOLERANCE;\n\n  if (!aabbContainsPoint) {\n    return false;\n  }\n\n  // Now that we know the point is inside the AABB we check if it lies on the line segment\n  const orientation =\n    (lineEnd[1] - lineStart[1]) * (point[0] - lineEnd[0]) -\n    (lineEnd[0] - lineStart[0]) * (point[1] - lineEnd[1]);\n  const absOrientation = orientation >= 0 ? orientation : -orientation;\n\n  // The orientation must be zero for points that lies on the same line\n  return absOrientation <= ORIENTATION_TOLERANCE;\n}\n","import { Types } from '@cornerstonejs/core';\nimport * as mathLine from '../line';\n\n// ATTENTION: this is an internal function and it should not be added to \"polyline\" namespace\n\n// Tested with +1M random overlapping line segments and any tolerance below this\n// one may return invalid results.\nconst PARALLEL_LINES_TOLERANCE = 1e-2;\n\n/**\n * It returns the intersection between two lines (not line segments) or a midpoint\n * when the line segments overlap. This function calculates the intersection between\n * lines because it considers that getFirstLineSegmentIntersectionIndexes,\n * getLineSegmentIntersectionsCoordinates or getLineSegmentIntersectionsIndexes\n * has already been called first which guarantees.\n *\n * @param p1 - Line segment 1 start\n * @param q1 - Line segment 1 end\n * @param p2 - Line segment 2 start\n * @param q2 - Line segment 21 end\n * @returns The intersection between two lines or a midpoint when they overlap\n */\nexport default function getLinesIntersection(\n  p1: Types.Point2,\n  q1: Types.Point2,\n  p2: Types.Point2,\n  q2: Types.Point2\n) {\n  const diffQ1P1 = [q1[0] - p1[0], q1[1] - p1[1]];\n  const diffQ2P2 = [q2[0] - p2[0], q2[1] - p2[1]];\n  const denominator = diffQ2P2[1] * diffQ1P1[0] - diffQ2P2[0] * diffQ1P1[1];\n  const absDenominator = denominator >= 0 ? denominator : -denominator;\n\n  if (absDenominator < PARALLEL_LINES_TOLERANCE) {\n    // No Math.min/max calls for better performance.\n    const line1AABB = [\n      p1[0] < q1[0] ? p1[0] : q1[0], // 0: minX\n      p1[0] > q1[0] ? p1[0] : q1[0], // 1: maxX\n      p1[1] < q1[1] ? p1[1] : q1[1], // 2: minY\n      p1[1] > q1[1] ? p1[1] : q1[1], // 3: maxY\n    ];\n\n    // No Math.min/max calls for better performance.\n    const line2AABB = [\n      p2[0] < q2[0] ? p2[0] : q2[0], // 0: minX\n      p2[0] > q2[0] ? p2[0] : q2[0], // 1: maxX\n      p2[1] < q2[1] ? p2[1] : q2[1], // 2: minY\n      p2[1] > q2[1] ? p2[1] : q2[1], // 3: maxY\n    ];\n\n    const aabbIntersects =\n      line1AABB[0] <= line2AABB[1] && // minX1 <= maxX2\n      line1AABB[1] >= line2AABB[0] && // maxX1 >= minX2\n      line1AABB[2] <= line2AABB[3] && // minY1 <= maxY2\n      line1AABB[3] >= line2AABB[2]; // maxY1 >= minY2\n\n    if (!aabbIntersects) {\n      return;\n    }\n\n    // Three tests are enough to know if the lines overlap\n    const overlap =\n      mathLine.isPointOnLineSegment(p1, q1, p2) ||\n      mathLine.isPointOnLineSegment(p1, q1, q2) ||\n      mathLine.isPointOnLineSegment(p2, q2, p1);\n\n    if (!overlap) {\n      return;\n    }\n\n    // min/max seems to be inverted but that is correct because it is looking\n    // for the intersection range. No Math.min/max calls for better performance.\n    const minX = line1AABB[0] > line2AABB[0] ? line1AABB[0] : line2AABB[0];\n    const maxX = line1AABB[1] < line2AABB[1] ? line1AABB[1] : line2AABB[1];\n    const minY = line1AABB[2] > line2AABB[2] ? line1AABB[2] : line2AABB[2];\n    const maxY = line1AABB[3] < line2AABB[3] ? line1AABB[3] : line2AABB[3];\n    const midX = (minX + maxX) * 0.5;\n    const midY = (minY + maxY) * 0.5;\n\n    return [midX, midY];\n  }\n\n  let a = p1[1] - p2[1];\n  let b = p1[0] - p2[0];\n  const numerator1 = diffQ2P2[0] * a - diffQ2P2[1] * b;\n  const numerator2 = diffQ1P1[0] * a - diffQ1P1[1] * b;\n  a = numerator1 / denominator;\n  b = numerator2 / denominator;\n\n  const resultX = p1[0] + a * diffQ1P1[0];\n  const resultY = p1[1] + a * diffQ1P1[1];\n\n  return [resultX, resultY];\n}\n","import { Types } from '@cornerstonejs/core';\nimport * as mathPoint from '../point';\nimport getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\nimport containsPoint from './containsPoint';\nimport getNormal2 from './getNormal2';\nimport { glMatrix, vec3 } from 'gl-matrix';\nimport getLinesIntersection from './getLinesIntersection';\n\nenum PolylinePointType {\n  Vertex,\n  Intersection,\n}\n\n// Position of the point related to the intersection region\nenum PolylinePointPosition {\n  Outside = -1,\n  Edge = 0,\n  Inside = 1,\n}\n\n// Direction from last point to the intersection point to know if it is entering\n// or exiting the intersection region\nenum PolylinePointDirection {\n  Exiting = -1,\n  Unknown = 0,\n  Entering = 1,\n}\n\ntype PolylinePoint = {\n  type: PolylinePointType;\n  coordinates: Types.Point2;\n  position?: PolylinePointPosition;\n  visited: boolean;\n  next: PolylinePoint;\n};\n\ntype PolylineIntersectionPoint = PolylinePoint & {\n  direction: PolylinePointDirection;\n  cloned?: boolean;\n};\n\n/**\n * Ensure all polyline point objects are pointing to the next object in case\n * it is still not point to anyone.\n * @param polylinePoints - Array that contains all polyline points (vertices and intersections)\n */\nfunction ensuresNextPointers(polylinePoints: PolylinePoint[]) {\n  // Make sure all nodes point to a valid node\n  for (let i = 0, len = polylinePoints.length; i < len; i++) {\n    const currentPoint = polylinePoints[i];\n\n    if (!currentPoint.next) {\n      currentPoint.next = polylinePoints[i === len - 1 ? 0 : i + 1];\n    }\n  }\n}\n\n/**\n * Creates one linked list per polyline that contains all vertices and intersections\n * found while walking along the edges.\n *\n * @param targetPolyline - Target polyline\n * @param sourcePolyline - Source polyline\n * @returns Two linked lists with all vertices and intersections.\n */\nfunction getSourceAndTargetPointsList(\n  targetPolyline: Types.Point2[],\n  sourcePolyline: Types.Point2[]\n) {\n  const targetPolylinePoints: PolylinePoint[] = [];\n  const sourcePolylinePoints: PolylinePoint[] = [];\n  const sourceIntersectionsCache = new Map<\n    number,\n    PolylineIntersectionPoint[]\n  >();\n\n  const isFirstPointInside = containsPoint(sourcePolyline, targetPolyline[0]);\n\n  let intersectionPointDirection = isFirstPointInside\n    ? PolylinePointDirection.Exiting\n    : PolylinePointDirection.Entering;\n\n  // Store all vertices and intersection for target contour\n  for (let i = 0, len = targetPolyline.length; i < len; i++) {\n    const p1 = targetPolyline[i];\n    const pointInside = containsPoint(sourcePolyline, p1);\n    const vertexPoint: PolylinePoint = {\n      type: PolylinePointType.Vertex,\n      coordinates: p1,\n      position: pointInside\n        ? PolylinePointPosition.Inside\n        : PolylinePointPosition.Outside,\n      visited: false,\n      next: null,\n    };\n\n    targetPolylinePoints.push(vertexPoint);\n\n    const q1 = targetPolyline[i === len - 1 ? 0 : i + 1];\n    const intersectionsInfo = getLineSegmentIntersectionsIndexes(\n      sourcePolyline,\n      p1,\n      q1\n    ).map((intersectedLineSegment) => {\n      const sourceLineSegmentId: number = intersectedLineSegment[0];\n      const p2 = sourcePolyline[intersectedLineSegment[0]];\n      const q2 = sourcePolyline[intersectedLineSegment[1]];\n\n      // lineSegment.intersectLine returns the midpoint of the four points\n      // when the lines are parallel or co-incident.  Otherwise it will return\n      // an extension of the line.\n      const intersectionCoordinate = getLinesIntersection(\n        p1,\n        q1,\n        p2,\n        q2\n      ) as Types.Point2;\n\n      const targetStartPointDistSquared = mathPoint.distanceToPointSquared(\n        p1,\n        intersectionCoordinate\n      );\n\n      return {\n        sourceLineSegmentId,\n        coordinate: intersectionCoordinate,\n        targetStartPointDistSquared,\n      };\n    });\n\n    intersectionsInfo.sort(\n      (left, right) =>\n        left.targetStartPointDistSquared - right.targetStartPointDistSquared\n    );\n\n    intersectionsInfo.forEach((intersectionInfo) => {\n      const { sourceLineSegmentId, coordinate: intersectionCoordinate } =\n        intersectionInfo;\n\n      // Intersection point to be added to the target polyline list\n      const targetEdgePoint: PolylineIntersectionPoint = {\n        type: PolylinePointType.Intersection,\n        coordinates: intersectionCoordinate,\n        position: PolylinePointPosition.Edge,\n        direction: intersectionPointDirection,\n        visited: false,\n        next: null,\n      };\n\n      // Intersection point to be added to the source polyline list.\n      // At this point there is no way to know if the point is entering or\n      // exiting the intersection region but that is not going to be used\n      // hence it is set to \"unknown\".\n      const sourceEdgePoint: PolylineIntersectionPoint = {\n        ...targetEdgePoint,\n        direction: PolylinePointDirection.Unknown,\n        cloned: true,\n      };\n\n      if (intersectionPointDirection === PolylinePointDirection.Entering) {\n        targetEdgePoint.next = sourceEdgePoint;\n      } else {\n        sourceEdgePoint.next = targetEdgePoint;\n      }\n\n      let sourceIntersectionPoints =\n        sourceIntersectionsCache.get(sourceLineSegmentId);\n\n      if (!sourceIntersectionPoints) {\n        sourceIntersectionPoints = [];\n        sourceIntersectionsCache.set(\n          sourceLineSegmentId,\n          sourceIntersectionPoints\n        );\n      }\n\n      targetPolylinePoints.push(targetEdgePoint);\n      sourceIntersectionPoints.push(sourceEdgePoint);\n\n      // Switches from \"exiting\" to \"entering\" and vice-versa\n      intersectionPointDirection *= -1;\n    });\n  }\n\n  // Store all vertices and intersections for source contour\n  for (let i = 0, len = sourcePolyline.length; i < len; i++) {\n    const lineSegmentId: number = i;\n    const p1 = sourcePolyline[i];\n    const vertexPoint: PolylinePoint = {\n      type: PolylinePointType.Vertex,\n      coordinates: p1,\n      visited: false,\n      next: null,\n    };\n\n    sourcePolylinePoints.push(vertexPoint);\n\n    const sourceIntersectionPoints =\n      sourceIntersectionsCache.get(lineSegmentId);\n\n    if (!sourceIntersectionPoints?.length) {\n      continue;\n    }\n\n    // Calculate the distance between each intersection point to the start point\n    // of the line segment, sort them by distance and return a sorted array that\n    // contains all intersection points.\n    sourceIntersectionPoints\n      .map((intersectionPoint) => ({\n        intersectionPoint,\n        lineSegStartDistSquared: mathPoint.distanceToPointSquared(\n          p1,\n          intersectionPoint.coordinates\n        ),\n      }))\n      .sort(\n        (left, right) =>\n          left.lineSegStartDistSquared - right.lineSegStartDistSquared\n      )\n      .map(({ intersectionPoint }) => intersectionPoint)\n      .forEach((intersectionPoint) =>\n        sourcePolylinePoints.push(intersectionPoint)\n      );\n  }\n\n  ensuresNextPointers(targetPolylinePoints);\n  ensuresNextPointers(sourcePolylinePoints);\n\n  return { targetPolylinePoints, sourcePolylinePoints };\n}\n\n/**\n * Get the next unvisited polyline points that is outside the intersection region.\n * @param polylinePoints - All polyline points (vertices and intersections)\n * @returns Any unvisited point that is outside the intersection region if it\n * exists or `undefined` otherwise\n */\nfunction getUnvisitedOutsidePoint(polylinePoints: PolylinePoint[]) {\n  for (let i = 0, len = polylinePoints.length; i < len; i++) {\n    const point = polylinePoints[i];\n\n    if (!point.visited && point.position === PolylinePointPosition.Outside) {\n      return point;\n    }\n  }\n}\n\n/**\n * Merge two planar polylines (2D)\n */\nfunction mergePolylines(\n  targetPolyline: Types.Point2[],\n  sourcePolyline: Types.Point2[]\n) {\n  const targetNormal = getNormal2(targetPolyline);\n  const sourceNormal = getNormal2(sourcePolyline);\n  const dotNormals = vec3.dot(sourceNormal, targetNormal);\n\n  // Both polylines need to be CW or CCW to be merged and one of them needs to\n  // be reversed if theirs orientation are not the same\n  if (!glMatrix.equals(1, dotNormals)) {\n    sourcePolyline = sourcePolyline.slice().reverse();\n  }\n\n  const { targetPolylinePoints } = getSourceAndTargetPointsList(\n    targetPolyline,\n    sourcePolyline\n  );\n  const startPoint: PolylinePoint =\n    getUnvisitedOutsidePoint(targetPolylinePoints);\n\n  // Source polyline contains target polyline\n  if (!startPoint) {\n    return targetPolyline.slice();\n  }\n\n  const mergedPolyline = [startPoint.coordinates];\n  let currentPoint = startPoint.next;\n\n  while (currentPoint !== startPoint) {\n    if (\n      currentPoint.type === PolylinePointType.Intersection &&\n      (<PolylineIntersectionPoint>currentPoint).cloned\n    ) {\n      currentPoint = currentPoint.next;\n      continue;\n    }\n\n    mergedPolyline.push(currentPoint.coordinates);\n    currentPoint = currentPoint.next;\n  }\n\n  return mergedPolyline;\n}\n\n/**\n * Subtract two planar polylines (2D)\n */\nfunction subtractPolylines(\n  targetPolyline: Types.Point2[],\n  sourcePolyline: Types.Point2[]\n): Types.Point2[][] {\n  const targetNormal = getNormal2(targetPolyline);\n  const sourceNormal = getNormal2(sourcePolyline);\n  const dotNormals = vec3.dot(sourceNormal, targetNormal);\n\n  // The polylines need to have different orientation (CW+CCW or CCW+CW) to be\n  // subtracted and one of them needs to be reversed if theirs orientation are\n  // the same\n  if (!glMatrix.equals(-1, dotNormals)) {\n    sourcePolyline = sourcePolyline.slice().reverse();\n  }\n\n  const { targetPolylinePoints } = getSourceAndTargetPointsList(\n    targetPolyline,\n    sourcePolyline\n  );\n  let startPoint: PolylinePoint = null;\n  const subtractedPolylines = [];\n\n  while ((startPoint = getUnvisitedOutsidePoint(targetPolylinePoints))) {\n    const subtractedPolyline = [startPoint.coordinates];\n    let currentPoint = startPoint.next;\n\n    startPoint.visited = true;\n\n    while (currentPoint !== startPoint) {\n      currentPoint.visited = true;\n\n      if (\n        currentPoint.type === PolylinePointType.Intersection &&\n        (<PolylineIntersectionPoint>currentPoint).cloned\n      ) {\n        currentPoint = currentPoint.next;\n        continue;\n      }\n\n      subtractedPolyline.push(currentPoint.coordinates);\n      currentPoint = currentPoint.next;\n    }\n\n    subtractedPolylines.push(subtractedPolyline);\n  }\n\n  return subtractedPolylines;\n}\n\nexport { mergePolylines, subtractPolylines };\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Given an array of viewports, returns a list of viewports that are viewing a\n * world space with the given `FrameOfReferenceUID`.\n *\n * @param viewports - An array of viewports.\n * @param FrameOfReferenceUID - The UID defining a particular world space/Frame Of Reference.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithFrameOfReferenceUID(\n  viewports: Array<Types.IViewport>,\n  FrameOfReferenceUID: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n  const viewportsWithFrameOfReferenceUID = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {\n      viewportsWithFrameOfReferenceUID.push(viewport);\n    }\n  }\n\n  return viewportsWithFrameOfReferenceUID;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { IToolGroup } from '../../types';\nimport { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * Given an array of viewports, returns a list of viewports that have the the specified tool enabled.\n *\n * @param viewports - An array of viewports.\n * @param toolName - The name of the tool to filter on.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithToolEnabled(\n  viewports: Array<Types.IViewport>,\n  toolName: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n\n  const viewportsWithToolEnabled = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n      viewport.id,\n      viewport.renderingEngineId\n    );\n\n    if (!toolGroup) {\n      continue;\n    }\n\n    const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(\n      toolGroup,\n      toolName\n    );\n\n    if (hasTool) {\n      viewportsWithToolEnabled.push(viewport);\n    }\n  }\n\n  return viewportsWithToolEnabled;\n}\n\n/**\n * Given a toolGroup, return true if it contains the tool with the given `toolName` and it is\n * active, passive or enabled.\n *\n * @param toolGroup - The `toolGroup` to check.\n * @param toolName - The name of the tool.\n *\n * @returns True if the tool is enabled, passive or active in the `toolGroup`.\n */\nfunction _toolGroupHasActiveEnabledOrPassiveTool(\n  toolGroup: IToolGroup,\n  toolName: string\n) {\n  const { toolOptions } = toolGroup;\n  const tool = toolOptions[toolName];\n\n  if (!tool) {\n    return false;\n  }\n\n  const toolMode = tool.mode;\n\n  return toolMode === Active || toolMode === Passive || toolMode === Enabled;\n}\n","import { vec3 } from 'gl-matrix';\n\n/**\n * It filters the viewports that are looking in the same view as the camera\n * It basically checks if the viewPlaneNormal is parallel to the camera viewPlaneNormal\n * @param viewports - Array of viewports to filter\n * @param camera - Camera to compare against\n * @returns - Array of viewports with the same view\n */\nexport function filterViewportsWithParallelNormals(\n  viewports,\n  camera,\n  EPS = 0.999\n) {\n  return viewports.filter((viewport) => {\n    const vpCamera = viewport.getCamera();\n\n    const isParallel =\n      Math.abs(vec3.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) >\n      EPS;\n\n    return isParallel;\n  });\n}\n\nexport default filterViewportsWithParallelNormals;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\n\n/**\n * Given a cornerstone3D enabled `element`, and a `toolName`, find all viewportIds\n * looking at the same Frame Of Reference that have the tool with the given `toolName`\n * active, passive or enabled.\n *\n * @param element - The target cornerstone3D enabled element.\n * @param toolName - The string toolName.\n * @param requireParallelNormals - If true, only return viewports that have parallel normals.\n *\n * @returns An array of viewportIds.\n */\nexport default function getViewportIdsWithToolToRender(\n  element: HTMLDivElement,\n  toolName: string,\n  requireParallelNormals = true\n): string[] {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, FrameOfReferenceUID } = enabledElement;\n\n  let viewports = renderingEngine.getViewports();\n\n  viewports = filterViewportsWithFrameOfReferenceUID(\n    viewports,\n    FrameOfReferenceUID\n  );\n  viewports = filterViewportsWithToolEnabled(viewports, toolName);\n\n  const viewport = renderingEngine.getViewport(enabledElement.viewportId);\n\n  if (requireParallelNormals) {\n    viewports = filterViewportsWithParallelNormals(\n      viewports,\n      viewport.getCamera()\n    );\n  }\n\n  const viewportIds = viewports.map((vp) => vp.id);\n\n  return viewportIds;\n}\n","import { Annotation } from '../../types';\nimport { ContourSegmentationAnnotation } from '../../types/ContourSegmentationAnnotation';\n\nexport default function isContourSegmentationAnnotation(\n  annotation: Annotation\n): annotation is ContourSegmentationAnnotation {\n  return !!(<ContourSegmentationAnnotation>annotation).data?.segmentation;\n}\n","import { ContourSegmentationAnnotation } from '../../types/ContourSegmentationAnnotation';\n\n/**\n * Check if two contour segmentations are from same segmentId,\n * segmentationRepresentationUID and segmentIndex.\n * @param firstAnnotation - First annotation\n * @param secondAnnotation - Second annotation\n * @returns True if they are from same segmentId, segmentationRepresentationUID\n * and segmentIndex or false otherwise.\n */\nexport default function areSameSegment(\n  firstAnnotation: ContourSegmentationAnnotation,\n  secondAnnotation: ContourSegmentationAnnotation\n) {\n  const { segmentation: firstSegmentation } = firstAnnotation.data;\n  const { segmentation: secondSegmentation } = secondAnnotation.data;\n\n  return (\n    firstSegmentation.segmentationId === secondSegmentation.segmentationId &&\n    firstSegmentation.segmentIndex === secondSegmentation.segmentIndex\n  );\n}\n","import { state } from '../../stateManagement/segmentation';\nimport { ContourSegmentationAnnotation } from '../../types';\n\n/**\n * Removes a contour segmentation annotation from the given annotation.\n * If the annotation does not have a segmentation data, this method returns\n * quietly.  This can occur for interpolated segmentations that have not yet\n * been converted to real segmentations or other in-process segmentations.\n * @param annotation - The contour segmentation annotation to remove.\n */\nexport function removeContourSegmentationAnnotation(\n  annotation: ContourSegmentationAnnotation\n) {\n  if (!annotation.data.segmentation) {\n    throw new Error(\n      'removeContourSegmentationAnnotation: annotation does not have a segmentation data'\n    );\n  }\n\n  const { segmentationId, segmentIndex } = annotation.data.segmentation;\n  const segmentation = state.getSegmentation(segmentationId);\n  const { annotationUIDsMap } = segmentation?.representationData.CONTOUR || {};\n  const annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);\n\n  if (!annotationsUIDsSet) {\n    return;\n  }\n\n  annotationsUIDsSet.delete(annotation.annotationUID);\n\n  // Delete segmentIndex Set if there is no more annotations\n  if (!annotationsUIDsSet.size) {\n    annotationUIDsMap.delete(segmentIndex);\n  }\n}\n","import { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { ContourSegmentationAnnotation } from '../../types';\n\n/**\n * Adds a contour segmentation annotation to the specified segmentation.\n * @param annotation - The contour segmentation annotation to add.\n */\nexport function addContourSegmentationAnnotation(\n  annotation: ContourSegmentationAnnotation\n) {\n  if (annotation.parentAnnotationUID) {\n    // Don't add it for parent annotations - this happens during interpolation\n    return;\n  }\n  if (!annotation.data.segmentation) {\n    throw new Error(\n      'addContourSegmentationAnnotation: annotation does not have a segmentation data'\n    );\n  }\n\n  const { segmentationId, segmentIndex } = annotation.data.segmentation;\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation.representationData.CONTOUR) {\n    segmentation.representationData.CONTOUR = { annotationUIDsMap: new Map() };\n  }\n\n  const { annotationUIDsMap } = segmentation.representationData.CONTOUR;\n\n  let annotationsUIDsSet = annotationUIDsMap.get(segmentIndex);\n\n  if (!annotationsUIDsSet) {\n    annotationsUIDsSet = new Set();\n    annotationUIDsMap.set(segmentIndex, annotationsUIDsSet);\n  }\n\n  annotationUIDsMap.set(\n    segmentIndex,\n    annotationsUIDsSet.add(annotation.annotationUID)\n  );\n}\n","import { state } from './state';\n\n/**\n * Adds the tool class to the cornerstoneTools to be used later. This function\n * should be called before creating the toolGroups and adding tools and setting their mode.\n * The flow is:\n * - addTool(ToolClass) // where ToolClass is the tool constructor imported from CornerstoneTools or created by a 3rd party\n * - createToolGroup(toolGroupId)\n * - toolGroup.addTool(${toolName}) // NOT THE TOOL CLASS\n * - toolGroup.setToolActive(${toolName})\n *\n * @param ToolClass - A tool calls to instantiate.\n * @param toolOptions - The tool-specific configuration options for the tool.\n * @returns\n */\nexport function addTool(ToolClass): void {\n  // Check if tool exists and name is not undefined\n  const toolName = ToolClass.toolName;\n  const toolAlreadyAdded = state.tools[toolName] !== undefined;\n\n  if (!toolName) {\n    throw new Error(`No Tool Found for the ToolClass ${ToolClass.name}`);\n  }\n\n  if (toolAlreadyAdded) {\n    throw new Error(`${toolName} has already been added globally`);\n  }\n\n  // Stores the toolNames and ToolClass to be instantiated in the toolGroup on toolGroup.addTool\n  state.tools[toolName] = {\n    toolClass: ToolClass,\n  };\n}\n\n/**\n * Check if a given tool is already registered\n * @param ToolClass - A tool class to check\n * @returns True if the tool is alredy registered or false otherwise\n */\nexport function hasTool(ToolClass): boolean {\n  const toolName = ToolClass.toolName;\n\n  return !!(toolName && state.tools[toolName]);\n}\n\n/**\n * Removes the tool class from the cornerstoneTools.\n *\n * @param ToolClass - A tool calls to instantiate.\n */\nexport function removeTool(ToolClass): void {\n  const toolName = ToolClass.toolName;\n\n  if (!toolName) {\n    throw new Error(`No tool found for: ${ToolClass.name}`);\n  }\n\n  if (!state.tools[toolName] !== undefined) {\n    delete state.tools[toolName];\n  } else {\n    throw new Error(\n      `${toolName} cannot be removed because it has not been added`\n    );\n  }\n}\n\nexport default addTool;\n","import type { Types } from '@cornerstonejs/core';\nimport { Annotation } from './AnnotationTypes';\n\n/**\n * Polyline winding direction\n *\n * It is defined as -1 and 1 to make it easier to change its direction multiplying\n * by -1 whenever polyline.reverse() is called instead of using IF/ELSE\n */\nexport enum ContourWindingDirection {\n  CounterClockwise = -1,\n  Unknown = 0,\n  Clockwise = 1,\n}\n\nexport type ContourAnnotationData = {\n  data: {\n    contour: {\n      polyline: Types.Point3[];\n      closed: boolean;\n      windingDirection?: ContourWindingDirection;\n    };\n  };\n  onInterpolationComplete?: () => void;\n};\n\nexport type ContourAnnotation = Annotation & ContourAnnotationData;\n","import {\n  getEnabledElement,\n  utilities as csUtils,\n  Types,\n} from '@cornerstonejs/core';\nimport { ContourSegmentationAnnotation } from '../../../types/ContourSegmentationAnnotation';\nimport getViewportsForAnnotation from '../../../utilities/getViewportsForAnnotation';\nimport {\n  math,\n  triggerAnnotationRenderForViewportIds,\n} from '../../../utilities';\nimport { getViewportIdsWithToolToRender } from '../../../utilities/viewportFilters';\nimport {\n  addAnnotation,\n  removeAnnotation,\n  getAllAnnotations,\n  getChildAnnotations,\n  addChildAnnotation,\n  clearParentAnnotation,\n} from '../../../stateManagement/annotation/annotationState';\nimport {\n  AnnotationCompletedEventType,\n  ContourAnnotationCompletedEventDetail,\n} from '../../../types/EventTypes';\nimport * as contourUtils from '../../../utilities/contours';\nimport * as contourSegUtils from '../../../utilities/contourSegmentation';\nimport { ToolGroupManager, hasTool as cstHasTool } from '../../../store';\nimport { PlanarFreehandContourSegmentationTool } from '../../../tools';\nimport type { Annotation } from '../../../types';\nimport type { ContourAnnotation } from '../../../types/ContourAnnotation';\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\n\nconst DEFAULT_CONTOUR_SEG_TOOLNAME = 'PlanarFreehandContourSegmentationTool';\n\nexport default async function contourSegmentationCompletedListener(\n  evt: AnnotationCompletedEventType\n) {\n  const sourceAnnotation = evt.detail\n    .annotation as ContourSegmentationAnnotation;\n\n  if (!contourSegUtils.isContourSegmentationAnnotation(sourceAnnotation)) {\n    return;\n  }\n\n  const viewport = getViewport(sourceAnnotation);\n  const contourSegmentationAnnotations = getValidContourSegmentationAnnotations(\n    viewport,\n    sourceAnnotation\n  );\n\n  if (!contourSegmentationAnnotations.length) {\n    return;\n  }\n\n  const sourcePolyline = convertContourPolylineToCanvasSpace(\n    sourceAnnotation.data.contour.polyline,\n    viewport\n  );\n\n  const targetAnnotationInfo = findIntersectingContour(\n    viewport,\n    sourcePolyline,\n    contourSegmentationAnnotations\n  );\n\n  if (!targetAnnotationInfo) {\n    return;\n  }\n\n  const { targetAnnotation, targetPolyline, isContourHole } =\n    targetAnnotationInfo;\n\n  if (isContourHole) {\n    const { contourHoleProcessingEnabled = false } =\n      evt.detail as ContourAnnotationCompletedEventDetail;\n\n    // Do not create holes when contourHoleProcessingEnabled is `false`\n    if (!contourHoleProcessingEnabled) {\n      return;\n    }\n\n    createPolylineHole(viewport, targetAnnotation, sourceAnnotation);\n  } else {\n    combinePolylines(\n      viewport,\n      targetAnnotation,\n      targetPolyline,\n      sourceAnnotation,\n      sourcePolyline\n    );\n  }\n}\n\nfunction isFreehandContourSegToolRegisteredForViewport(\n  viewport: Types.IViewport,\n  silent = false\n) {\n  const { toolName } = PlanarFreehandContourSegmentationTool;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewport.id,\n    viewport.renderingEngineId\n  );\n\n  let errorMessage;\n\n  if (!toolGroup.hasTool(toolName)) {\n    errorMessage = `Tool ${toolName} not added to ${toolGroup.id} toolGroup`;\n  } else if (!toolGroup.getToolOptions(toolName)) {\n    errorMessage = `Tool ${toolName} must be in active/passive state`;\n  }\n\n  if (errorMessage && !silent) {\n    console.warn(errorMessage);\n  }\n\n  return !errorMessage;\n}\n\nfunction getViewport(annotation: Annotation) {\n  const viewports = getViewportsForAnnotation(annotation);\n  const viewportWithToolRegistered = viewports.find((viewport) =>\n    isFreehandContourSegToolRegisteredForViewport(viewport, true)\n  );\n\n  // Returns the first viewport even if freehand contour segmentation is not\n  // registered because it can be used to project the polyline to create holes.\n  // Another verification is done before appending/removing contours which is\n  // possible only when the tool is registered.\n  return viewportWithToolRegistered ?? viewports[0];\n}\n\nfunction convertContourPolylineToCanvasSpace(\n  polyline: Types.Point3[],\n  viewport: Types.IViewport\n): Types.Point2[] {\n  const numPoints = polyline.length;\n  const projectedPolyline = new Array(numPoints);\n\n  for (let i = 0; i < numPoints; i++) {\n    projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n  }\n\n  return projectedPolyline;\n}\n\nfunction getValidContourSegmentationAnnotations(\n  viewport: Types.IViewport,\n  sourceAnnotation: ContourSegmentationAnnotation\n): ContourSegmentationAnnotation[] {\n  const { annotationUID: sourceAnnotationUID } = sourceAnnotation;\n\n  // Get all annotations and filter all contour segmentations locally\n  const allAnnotations = getAllAnnotations();\n  return allAnnotations.filter(\n    (targetAnnotation) =>\n      targetAnnotation.annotationUID &&\n      targetAnnotation.annotationUID !== sourceAnnotationUID &&\n      contourSegUtils.isContourSegmentationAnnotation(targetAnnotation) &&\n      contourSegUtils.areSameSegment(targetAnnotation, sourceAnnotation) &&\n      viewport.isReferenceViewable(targetAnnotation.metadata)\n  ) as ContourSegmentationAnnotation[];\n}\n\n/**\n * Finds other contours on the same slice which intersect the source polyline,\n * represented as canvas points.\n */\nfunction findIntersectingContour(\n  viewport: Types.IViewport,\n  sourcePolyline: Types.Point2[],\n  contourSegmentationAnnotations: ContourSegmentationAnnotation[]\n): {\n  targetAnnotation: ContourSegmentationAnnotation;\n  targetPolyline: Types.Point2[];\n  isContourHole: boolean;\n} {\n  const sourceAABB = math.polyline.getAABB(sourcePolyline);\n\n  for (let i = 0; i < contourSegmentationAnnotations.length; i++) {\n    const targetAnnotation = contourSegmentationAnnotations[i];\n    const targetPolyline = convertContourPolylineToCanvasSpace(\n      targetAnnotation.data.contour.polyline,\n      viewport\n    );\n\n    const targetAABB = math.polyline.getAABB(targetPolyline);\n    const aabbIntersect = math.aabb.intersectAABB(sourceAABB, targetAABB);\n    const lineSegmentsIntersect =\n      aabbIntersect &&\n      math.polyline.intersectPolyline(sourcePolyline, targetPolyline);\n    const isContourHole =\n      aabbIntersect &&\n      !lineSegmentsIntersect &&\n      math.polyline.containsPoints(targetPolyline, sourcePolyline);\n\n    if (lineSegmentsIntersect || isContourHole) {\n      return { targetAnnotation, targetPolyline, isContourHole };\n    }\n  }\n}\n\n/**\n * Modifies the holeAnnotation to work as a contour hole in the targetAnnotation,\n * displayed on the given viewport.\n\n */\nexport function createPolylineHole(\n  viewport: Types.IViewport,\n  targetAnnotation: ContourSegmentationAnnotation,\n  holeAnnotation: ContourSegmentationAnnotation\n) {\n  const { windingDirection: targetWindingDirection } =\n    targetAnnotation.data.contour;\n  const { windingDirection: holeWindingDirection } =\n    holeAnnotation.data.contour;\n\n  // Check if both normals are pointing to the same direction because the\n  // polyline for the hole needs to be in a different direction\n  // if (glMatrix.equals(1, dotNormals)) {\n  if (targetWindingDirection === holeWindingDirection) {\n    holeAnnotation.data.contour.polyline.reverse();\n    holeAnnotation.data.contour.windingDirection = targetWindingDirection * -1;\n  }\n\n  addChildAnnotation(targetAnnotation, holeAnnotation);\n  contourSegUtils.removeContourSegmentationAnnotation(holeAnnotation);\n\n  const { element } = viewport;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine } = enabledElement;\n\n  // Updating a Spline contours, for example, should also update freehand contours\n  const updatedToolNames = new Set([\n    DEFAULT_CONTOUR_SEG_TOOLNAME,\n    targetAnnotation.metadata.toolName,\n    holeAnnotation.metadata.toolName,\n  ]);\n\n  for (const toolName of updatedToolNames.values()) {\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      toolName\n    );\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  }\n}\n\nfunction getContourHolesData(\n  viewport: Types.IViewport,\n  annotation: ContourAnnotation\n) {\n  return getChildAnnotations(annotation).map((holeAnnotation) => {\n    const polyline = convertContourPolylineToCanvasSpace(\n      holeAnnotation.data.contour.polyline,\n      viewport\n    );\n\n    return { annotation: holeAnnotation, polyline };\n  });\n}\n\nfunction combinePolylines(\n  viewport: Types.IViewport,\n  targetAnnotation: ContourSegmentationAnnotation,\n  targetPolyline: Types.Point2[],\n  sourceAnnotation: ContourSegmentationAnnotation,\n  sourcePolyline: Types.Point2[]\n) {\n  if (!cstHasTool(PlanarFreehandContourSegmentationTool)) {\n    console.warn(\n      `${PlanarFreehandContourSegmentationTool.toolName} is not registered in cornerstone`\n    );\n    return;\n  }\n\n  // Cannot append/remove an annotation if it will not be available on any viewport\n  if (!isFreehandContourSegToolRegisteredForViewport(viewport)) {\n    return;\n  }\n\n  const sourceStartPoint = sourcePolyline[0];\n  const mergePolylines = math.polyline.containsPoint(\n    targetPolyline,\n    sourceStartPoint\n  );\n\n  const contourHolesData = getContourHolesData(viewport, targetAnnotation);\n  const unassignedContourHolesSet = new Set(contourHolesData);\n  const reassignedContourHolesMap = new Map();\n  const assignHoleToPolyline = (parentPolyline, holeData) => {\n    let holes = reassignedContourHolesMap.get(parentPolyline);\n\n    if (!holes) {\n      holes = [];\n      reassignedContourHolesMap.set(parentPolyline, holes);\n    }\n\n    holes.push(holeData);\n    unassignedContourHolesSet.delete(holeData);\n  };\n  const newPolylines = [];\n\n  if (mergePolylines) {\n    const mergedPolyline = math.polyline.mergePolylines(\n      targetPolyline,\n      sourcePolyline\n    );\n\n    newPolylines.push(mergedPolyline);\n\n    // Keep all holes because the contour can only grow when merging and there\n    // is no chance for any hole to be removed\n    Array.from(unassignedContourHolesSet.keys()).forEach((holeData) =>\n      assignHoleToPolyline(mergedPolyline, holeData)\n    );\n  } else {\n    const subtractedPolylines = math.polyline.subtractPolylines(\n      targetPolyline,\n      sourcePolyline\n    );\n\n    subtractedPolylines.forEach((newPolyline) => {\n      newPolylines.push(newPolyline);\n\n      Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => {\n        const containsHole = math.polyline.containsPoints(\n          newPolyline,\n          holeData.polyline\n        );\n\n        if (containsHole) {\n          assignHoleToPolyline(newPolyline, holeData);\n          unassignedContourHolesSet.delete(holeData);\n        }\n      });\n    });\n  }\n\n  // Make sure the holes that will be added to the new annotation are not\n  // associated to the target annotation that will be deleted\n  Array.from(reassignedContourHolesMap.values()).forEach(\n    (contourHolesDataArray) =>\n      contourHolesDataArray.forEach((contourHoleData) =>\n        clearParentAnnotation(contourHoleData.annotation)\n      )\n  );\n\n  const { element } = viewport;\n  const enabledElement = getEnabledElement(element);\n  const { metadata, data } = targetAnnotation;\n  const { handles, segmentation } = data;\n  const { textBox } = handles;\n\n  removeAnnotation(sourceAnnotation.annotationUID);\n  removeAnnotation(targetAnnotation.annotationUID);\n\n  for (let i = 0; i < newPolylines.length; i++) {\n    const polyline = newPolylines[i];\n    const startPoint = viewport.canvasToWorld(polyline[0]);\n    const endPoint = viewport.canvasToWorld(polyline[polyline.length - 1]);\n    const newAnnotation: ContourSegmentationAnnotation = {\n      metadata: {\n        ...metadata,\n        toolName: DEFAULT_CONTOUR_SEG_TOOLNAME,\n        originalToolName: metadata.originalToolName || metadata.toolName,\n      },\n      data: {\n        cachedStats: {},\n        handles: {\n          points: [startPoint, endPoint],\n          textBox: textBox ? { ...textBox } : undefined,\n        },\n        contour: {\n          polyline: [],\n          closed: true,\n        },\n        spline: targetAnnotation.data.spline,\n        segmentation: {\n          ...segmentation,\n        },\n      },\n      annotationUID: csUtils.uuidv4() as string,\n      highlighted: true,\n      invalidated: true,\n      isLocked: false,\n      isVisible: undefined,\n      // Allow this object to be interpolated against the original interpolation\n      // data.\n      interpolationUID: targetAnnotation.interpolationUID,\n      interpolationCompleted: targetAnnotation.interpolationCompleted,\n    };\n\n    // Calling `updateContourPolyline` method instead of setting it locally\n    // because it is also responsible for checking/setting the winding direction.\n    contourUtils.updateContourPolyline(\n      newAnnotation,\n      {\n        points: polyline,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n      },\n      viewport\n    );\n\n    addAnnotation(newAnnotation, element);\n    contourSegUtils.addContourSegmentationAnnotation(newAnnotation);\n    triggerAnnotationModified(newAnnotation, viewport.element);\n\n    reassignedContourHolesMap\n      .get(polyline)\n      ?.forEach((holeData) =>\n        addChildAnnotation(newAnnotation, holeData.annotation)\n      );\n  }\n\n  updateViewports(enabledElement, targetAnnotation, sourceAnnotation);\n}\n\nfunction updateViewports(enabledElement, targetAnnotation, sourceAnnotation) {\n  const { viewport } = enabledElement;\n  const { element } = viewport;\n  const { renderingEngine } = enabledElement;\n\n  const updatedTtoolNames = new Set([\n    DEFAULT_CONTOUR_SEG_TOOLNAME,\n    targetAnnotation.metadata.toolName,\n    sourceAnnotation.metadata.toolName,\n  ]);\n\n  for (const toolName of updatedTtoolNames.values()) {\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      toolName\n    );\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  }\n\n  return new Promise((resolve) => window.requestAnimationFrame(resolve));\n}\n","import { triggerEvent, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nimport createPolylineToolData from './createPolylineToolData';\nimport findAnnotationsForInterpolation from './findAnnotationForInterpolation';\nimport type { InterpolationViewportData } from '../../../types/InterpolationTypes';\nimport type { InterpolationROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport type { AnnotationInterpolationCompletedEventDetail } from '../../../types/EventTypes';\nimport EventTypes from '../../../enums/Events';\nimport * as annotationState from '../../../stateManagement/annotation';\nimport selectHandles from './selectHandles';\nimport updateChildInterpolationUID from './updateChildInterpolationUID';\nimport { createPolylineHole } from '../../../eventListeners/annotations/contourSegmentation/contourSegmentationCompleted';\n\nconst { PointsManager } = utilities;\n\n/**\n * An XYZ encoded points that also includes an indicator I for whether the\n * point is included in the original contour.\n */\nexport type PointsXYZI = Types.PointsXYZ & {\n  I?: boolean[];\n  kIndex?: number;\n};\n\nexport type PointsArray3 = Types.PointsManager<Types.Point3> & {\n  I?: boolean[];\n};\n\nconst dP = 0.2; // Aim for < 0.2mm between interpolated nodes when super-sampling.\n\n/**\n * interpolate - Interpolate missing contours in the ROIContours.\n * If input is tool data collection, it is expected to be sorted in the order\n * of stack image in which it was drawn.\n *\n * This is performed in a microtask in order to avoid delaying the event handler\n * excessively, but to ensure it is completed before the data is additionally\n * changed.  It was originally done in a setTimeout, but that allowed the data\n * to be updated between calls, causing issues with the interpolation process.\n *\n * @param viewportData - Object\n * @returns null\n */\nfunction interpolate(viewportData: InterpolationViewportData) {\n  if (!viewportData.annotation) {\n    return;\n  }\n  const { isInterpolationUpdate, annotation } = viewportData;\n  queueMicrotask(() => {\n    try {\n      if (isInterpolationUpdate) {\n        annotation.isInterpolationUpdate = true;\n        // This may not be true long term, but treat it as user generated for\n        // this run.\n        annotation.autoGenerated = false;\n      }\n      startInterpolation(viewportData);\n    } finally {\n      if (isInterpolationUpdate) {\n        // Reset the auto generated flag\n        annotation.autoGenerated = true;\n      }\n    }\n  });\n}\n\n/**\n * Start the actual interpolation from the list\n * @param viewportData - Object\n * @returns null\n */\nfunction startInterpolation(viewportData: InterpolationViewportData) {\n  const { annotation: toolData } = viewportData;\n  updateChildInterpolationUID(toolData);\n  const { interpolationData, interpolationList } =\n    findAnnotationsForInterpolation(toolData, viewportData) || {};\n\n  if (!interpolationData || !interpolationList) {\n    return;\n  }\n\n  const eventData = {\n    toolName: toolData.metadata.toolName,\n    toolType: toolData.metadata.toolName,\n    viewport: viewportData.viewport,\n  };\n  for (let i = 0; i < interpolationList.length; i++) {\n    if (interpolationList[i]) {\n      _linearlyInterpolateBetween(\n        interpolationList[i].list,\n        interpolationList[i].pair,\n        interpolationData,\n        eventData\n      );\n    }\n  }\n\n  const { id, renderingEngineId, element } = viewportData.viewport;\n\n  const eventDetails: AnnotationInterpolationCompletedEventDetail = {\n    annotation: toolData,\n    element,\n    viewportId: id,\n    renderingEngineId,\n  };\n\n  if (interpolationList.length) {\n    triggerEvent(\n      viewportData.viewport.element,\n      EventTypes.ANNOTATION_INTERPOLATION_PROCESS_COMPLETED,\n      eventDetails\n    );\n  }\n}\n\n/**\n * _linearlyInterpolateBetween - Linearly interpolate all the slices in the\n * indices array between the contourPair.\n *\n * @param indices - natural[], An array of slice indices to interpolate.\n * @param annotationPair - natural[2], The slice indices of the reference contours.\n * @param interpolationData - object\n * @param eventData - object\n * @returns null\n */\n\nfunction _linearlyInterpolateBetween(\n  indices,\n  annotationPair,\n  interpolationData,\n  eventData\n) {\n  const annotation0 = interpolationData.get(annotationPair[0])[0];\n  const annotation1 = interpolationData.get(annotationPair[1])[0];\n  const c1 = _generateClosedContour(annotation0.data.contour.polyline);\n  const c2 = _generateClosedContour(annotation1.data.contour.polyline);\n\n  const { c1Interp, c2Interp } = _generateInterpolationContourPair(c1, c2);\n  c1Interp.kIndex = annotationPair[0];\n  c2Interp.kIndex = annotationPair[1];\n\n  // Using the newly constructed contours, interpolate each ROI.\n  indices.forEach(function (index) {\n    _linearlyInterpolateContour(\n      c1Interp,\n      c2Interp,\n      index,\n      annotationPair,\n      interpolationData,\n      c1.x.length > c2.x.length,\n      eventData\n    );\n  });\n}\n\nfunction getPointCount(pointArray) {\n  let sum = 0;\n  for (let i = 0; i < pointArray.I.length; i++) {\n    if (pointArray.I[i]) {\n      sum++;\n    }\n  }\n  return sum;\n}\n\n/**\n * _linearlyInterpolateContour - Inserts a linearly interpolated contour at\n * specified slice index.\n *\n * @param c1Interp - object, The first reference contour.\n * @param c2Interp - object,  The second reference contour.\n * @param sliceIndex - Number, The slice index to interpolate.\n * @param annotationPair - Number[], The slice indices of the reference contours.\n * @param interpolationData - object[], Data for the slice location of contours\n *                                  for the ROIContour.\n * @param c1HasMoreNodes - boolean, True if c1 has more nodes than c2.\n * @param eventData - object\n * @returns null\n */\nfunction _linearlyInterpolateContour(\n  c1Interp,\n  c2Interp,\n  sliceIndex,\n  annotationPair,\n  interpolationData,\n  c1HasMoreNodes,\n  eventData\n) {\n  const [startIndex, endIndex] = annotationPair;\n  const zInterp = (sliceIndex - startIndex) / (endIndex - startIndex);\n  const annotation0 = interpolationData.get(startIndex)[0];\n  const annotation1 = interpolationData.get(endIndex)[0];\n  const interpolated3DPoints = _generateInterpolatedOpenContour(\n    c1Interp,\n    c2Interp,\n    zInterp,\n    c1HasMoreNodes\n  );\n\n  const nearestAnnotation = zInterp > 0.5 ? annotation1 : annotation0;\n\n  const handlePoints = selectHandles(interpolated3DPoints);\n\n  if (interpolationData.has(sliceIndex)) {\n    _editInterpolatedContour(\n      interpolated3DPoints,\n      handlePoints,\n      sliceIndex,\n      nearestAnnotation,\n      eventData\n    );\n  } else {\n    _addInterpolatedContour(\n      interpolated3DPoints,\n      handlePoints,\n      sliceIndex,\n      nearestAnnotation,\n      eventData\n    );\n  }\n}\n\n/**\n * _addInterpolatedContour - Adds a new contour to the imageId.\n *\n * @param interpolated3DPoints - object, The polygon to add to the ROIContour.\n * @param sliceIndex - Number, The slice index to interpolate..\n * @param referencedToolData - The toolData of another polygon in the\n * ROIContour, to assign appropriate metadata to the new polygon.\n * @param eventData - object\n * @returns null\n */\nfunction _addInterpolatedContour(\n  interpolated3DPoints: PointsArray3,\n  handlePoints: PointsArray3,\n  sliceIndex: number,\n  referencedToolData,\n  eventData\n) {\n  const points = interpolated3DPoints.points;\n  const { viewport } = eventData;\n\n  const interpolatedAnnotation = createPolylineToolData(\n    points,\n    handlePoints,\n    referencedToolData\n  );\n\n  const targetId = viewport.getReferenceId({ sliceIndex });\n  interpolatedAnnotation.metadata.referencedImageId = targetId;\n  interpolatedAnnotation.metadata.sliceIndex = sliceIndex;\n  annotationState.state.addAnnotation(interpolatedAnnotation, viewport.element);\n  referencedToolData.onInterpolationComplete?.(\n    interpolatedAnnotation,\n    referencedToolData\n  );\n\n  const { parentAnnotationUID } = referencedToolData;\n  if (parentAnnotationUID) {\n    const parentReferenced =\n      annotationState.state.getAnnotation(parentAnnotationUID);\n    const parentAnnotation = _findExistingAnnotation(\n      parentReferenced,\n      sliceIndex,\n      eventData\n    );\n    createPolylineHole(viewport, parentAnnotation, interpolatedAnnotation);\n  }\n}\n\n/**\n * Finds an existing annotation on the given slide, with the interpolation UID as\n * specified in the referenced tool data.\n */\nfunction _findExistingAnnotation(referencedToolData, sliceIndex, eventData) {\n  const { viewport } = eventData;\n  const annotations = annotationState.state.getAnnotations(\n    referencedToolData.metadata.toolName,\n    viewport.element\n  );\n\n  for (let i = 0; i < annotations.length; i++) {\n    const annotation = annotations[i] as InterpolationROIAnnotation;\n    if (\n      annotation.interpolationUID === referencedToolData.interpolationUID &&\n      annotation.metadata.sliceIndex === sliceIndex\n    ) {\n      return annotation;\n    }\n  }\n}\n/**\n * _editInterpolatedContour - Edits an interpolated polygon on the imageId\n * that corresponds to the specified ROIContour.\n *\n * @param interpolated3DPoints - object, The polygon to add to the ROIContour.\n * @param sliceIndex - Number, The slice index to interpolate.\n * @param referencedToolData - type, The toolData of another polygon in the\n * ROIContour, to assign appropriate metadata to the new polygon.\n * @param eventData - object\n */\nfunction _editInterpolatedContour(\n  interpolated3DPoints: PointsArray3,\n  handlePoints: PointsArray3,\n  sliceIndex,\n  referencedToolData,\n  eventData\n) {\n  const oldAnnotationData = _findExistingAnnotation(\n    referencedToolData,\n    sliceIndex,\n    eventData\n  );\n\n  const points = interpolated3DPoints.points;\n  const interpolatedAnnotation = createPolylineToolData(\n    points,\n    handlePoints,\n    oldAnnotationData\n  );\n  // Does a real update here instead of an add/remove, which caused delete issues in child annotations\n  Object.assign(oldAnnotationData, {\n    metadata: interpolatedAnnotation.metadata,\n    data: interpolatedAnnotation.data,\n  });\n}\n\n/**\n * _generateInterpolatedOpenContour - Interpolate an open contour between c1ir\n * and c2ir at the zInterp position.\n *\n * @param c1ir - object, The interpolated c1 contour with\n *                                  superfluous nodes removed.\n * @param c2ir - object, The interpolated c2 contour with\n *                                  superfluous nodes removed.\n * @param zInterp - Number, The z- coordinate of the desired\n *                                  interpolation.\n * @param c1HasMoreNodes - boolean, True if c1 has more original nodes\n *                                  than c2.\n * @returns object, The interpolated contour at z=zInterp.\n */\nfunction _generateInterpolatedOpenContour(\n  c1ir,\n  c2ir,\n  zInterp,\n  c1HasMoreNodes\n): PointsArray3 {\n  const indices = c1HasMoreNodes ? c1ir.I : c2ir.I;\n\n  const c1 = PointsManager.fromXYZ(c1ir);\n  const c2 = PointsManager.fromXYZ(c2ir);\n  const { length } = c1;\n  const cInterp = PointsManager.create3(length) as PointsArray3;\n\n  const vecSubtract = vec3.create();\n  const vecResult = vec3.create();\n  const c1Source = PointsManager.create3(length);\n  c1Source.kIndex = c1ir.kIndex;\n  const c2Source = PointsManager.create3(length);\n  c2Source.kIndex = c2ir.kIndex;\n\n  for (let i = 0; i < c1ir.x.length; i++) {\n    if (indices[i]) {\n      const c1point = c1.getPoint(i);\n      const c2point = c2.getPoint(i);\n      c1Source.push(c1point);\n      c2Source.push(c2point);\n      vec3.sub(vecSubtract, c2point, c1point);\n      cInterp.push(\n        vec3.scaleAndAdd(\n          vecResult,\n          c1point,\n          vecSubtract,\n          zInterp\n        ) as Types.Point3\n      );\n    }\n  }\n  cInterp.sources = [c1Source, c2Source];\n\n  return cInterp;\n}\n\n/**\n * _generateInterpolationContourPair - generates two aligned contours with an\n * equal number of nodes from which an intermediate contour may be interpolated.\n *\n * @param c1 - The first contour.\n * @param c2 - The second contour.\n * @returns -  An object containing the two contours.\n */\nfunction _generateInterpolationContourPair(c1, c2) {\n  const cumPerim1 = _getCumulativePerimeter(c1);\n  const cumPerim2 = _getCumulativePerimeter(c2);\n\n  const interpNodes = Math.max(\n    Math.ceil(cumPerim1[cumPerim1.length - 1] / dP),\n    Math.ceil(cumPerim2[cumPerim2.length - 1] / dP)\n  );\n\n  const cumPerim1Norm = _normalisedCumulativePerimeter(cumPerim1);\n  const cumPerim2Norm = _normalisedCumulativePerimeter(cumPerim2);\n\n  const numNodes1 = interpNodes + c2.x.length;\n  const numNodes2 = interpNodes + c1.x.length;\n\n  // concatenate p && cumPerimNorm\n  const perim1Interp = _getInterpolatedPerim(numNodes1, cumPerim1Norm);\n  const perim2Interp = _getInterpolatedPerim(numNodes2, cumPerim2Norm);\n\n  const perim1Ind = _getIndicatorArray(numNodes1 - 2, c1.x.length);\n  const perim2Ind = _getIndicatorArray(numNodes2 - 2, c2.x.length);\n\n  const nodesPerSegment1 = _getNodesPerSegment(perim1Interp, perim1Ind);\n  const nodesPerSegment2 = _getNodesPerSegment(perim2Interp, perim2Ind);\n\n  const c1i = _getSuperSampledContour(c1, nodesPerSegment1);\n  const c2i = _getSuperSampledContour(c2, nodesPerSegment2);\n\n  // Keep c2i fixed and shift the starting node of c1i to minimise the total length of segments.\n  _shiftSuperSampledContourInPlace(c1i, c2i);\n\n  return _reduceContoursToOriginNodes(c1i, c2i);\n}\n\n/**\n * _reduceContoursToOriginNodes - Removes any nodes from the contours that don't\n * correspond to an original contour node.\n *\n * @param c1i - The first super-sampled contour.\n * @param c2i - The second super-sampled contour.\n * @returns  An object containing the two reduced contours.\n */\nfunction _reduceContoursToOriginNodes(c1i: PointsXYZI, c2i: PointsXYZI) {\n  const c1Interp: PointsXYZI = {\n    x: [],\n    y: [],\n    z: [],\n    I: [],\n  };\n  const c2Interp: PointsXYZI = {\n    x: [],\n    y: [],\n    z: [],\n    I: [],\n  };\n\n  for (let i = 0; i < c1i.x.length; i++) {\n    if (c1i.I[i] || c2i.I[i]) {\n      c1Interp.x.push(c1i.x[i]);\n      c1Interp.y.push(c1i.y[i]);\n      c1Interp.z.push(c1i.z[i]);\n      c1Interp.I.push(c1i.I[i]);\n\n      c2Interp.x.push(c2i.x[i]);\n      c2Interp.y.push(c2i.y[i]);\n      c2Interp.z.push(c2i.z[i]);\n      c2Interp.I.push(c2i.I[i]);\n    }\n  }\n\n  return {\n    c1Interp,\n    c2Interp,\n  };\n}\n\n/**\n * _shiftSuperSampledContourInPlace - Shifts the indices of c1i around to\n * minimize: SUM (|c1i[i]-c2i[i]|) from 0 to N.\n *\n * @param c1i - The contour to shift.\n * @param c2i - The reference contour.\n * modifies c1i\n * @returns null\n */\nfunction _shiftSuperSampledContourInPlace(c1i, c2i) {\n  const c1iLength = c1i.x.length;\n\n  const optimal = {\n    startingNode: 0,\n    totalSquaredXYLengths: Infinity,\n  };\n\n  for (let startingNode = 0; startingNode < c1iLength; startingNode++) {\n    let node = startingNode;\n\n    // NOTE: 1) Ignore calculating Z, as the sum of all squared Z distances will always be a constant.\n    // NOTE: 2) Don't need actual length, so don't worry about square rooting.\n    let totalSquaredXYLengths = 0;\n\n    for (let iteration = 0; iteration < c1iLength; iteration++) {\n      totalSquaredXYLengths +=\n        (c1i.x[node] - c2i.x[iteration]) ** 2 +\n        (c1i.y[node] - c2i.y[iteration]) ** 2 +\n        (c1i.z[node] - c2i.z[iteration]) ** 2;\n\n      node++;\n\n      if (node === c1iLength) {\n        node = 0;\n      }\n    }\n\n    if (totalSquaredXYLengths < optimal.totalSquaredXYLengths) {\n      optimal.totalSquaredXYLengths = totalSquaredXYLengths;\n      optimal.startingNode = startingNode;\n    }\n  }\n\n  const node = optimal.startingNode;\n\n  _shiftCircularArray(c1i.x, node);\n  _shiftCircularArray(c1i.y, node);\n  _shiftCircularArray(c1i.z, node);\n  _shiftCircularArray(c1i.I, node);\n}\n\n/**\n * _shiftCircularArray - Shift the circular array by the count.\n *\n * @param arr - Array, The array.\n * @param count - Number, The shift.\n * @returns The shifted array.\n */\nfunction _shiftCircularArray(arr, count) {\n  count -= arr.length * Math.floor(count / arr.length);\n  const slicedArray = arr.splice(0, count);\n  arr.push(...slicedArray);\n  return arr;\n}\n\n/**\n * _getSuperSampledContour - Generates a super sampled contour with additional\n * nodes added per segment.\n *\n * @param c - object, The original contour.\n * @param nodesPerSegment - Number[], An array of the number of nodes to add\n *                                    per line segment.\n * @returns object, The super sampled contour.\n */\nfunction _getSuperSampledContour(c, nodesPerSegment): PointsXYZI {\n  const ci = {\n    x: [],\n    y: [],\n    z: [],\n    I: [],\n  };\n\n  // Length - 1, produces 'open' polygon.\n  for (let n = 0; n < c.x.length - 1; n++) {\n    // Add original node.\n    ci.x.push(c.x[n]);\n    ci.y.push(c.y[n]);\n    ci.z.push(c.z[n]);\n    ci.I.push(true);\n\n    // Add linearly interpolated nodes.\n    const xSpacing = (c.x[n + 1] - c.x[n]) / (nodesPerSegment[n] + 1);\n    const ySpacing = (c.y[n + 1] - c.y[n]) / (nodesPerSegment[n] + 1);\n    const zSpacing = (c.z[n + 1] - c.z[n]) / (nodesPerSegment[n] + 1);\n\n    // Add other nodesPerSegment - 1 other nodes (as already put in original node).\n    for (let i = 0; i < nodesPerSegment[n] - 1; i++) {\n      ci.x.push(ci.x[ci.x.length - 1] + xSpacing);\n      ci.y.push(ci.y[ci.y.length - 1] + ySpacing);\n      ci.z.push(ci.z[ci.z.length - 1] + zSpacing);\n      ci.I.push(false);\n    }\n  }\n\n  return ci;\n}\n\n/**\n * _getNodesPerSegment - Returns an array of the number of interpolated nodes\n * to be added along each line segment of a polygon.\n *\n * @param perimInterp - Number[], Normalized array of original and added nodes.\n * @param perimInd - boolean[], The indicator array describing the location of\n *                            the original contour's nodes.\n * @returns Number[], An array containing the number of nodes to be\n *                    added per original line segment.\n */\nfunction _getNodesPerSegment(perimInterp, perimInd) {\n  const idx = [];\n\n  for (let i = 0; i < perimInterp.length; ++i) {\n    idx[i] = i;\n  }\n  idx.sort(function (a, b) {\n    return perimInterp[a] < perimInterp[b] ? -1 : 1;\n  });\n\n  const perimIndSorted = [];\n\n  for (let i = 0; i < perimInd.length; i++) {\n    perimIndSorted.push(perimInd[idx[i]]);\n  }\n\n  const indicesOfOriginNodes = perimIndSorted.reduce(function (\n    arr,\n    elementValue,\n    i\n  ) {\n    if (elementValue) {\n      arr.push(i);\n    }\n    return arr;\n  },\n  []);\n\n  const nodesPerSegment = [];\n\n  for (let i = 0; i < indicesOfOriginNodes.length - 1; i++) {\n    nodesPerSegment.push(indicesOfOriginNodes[i + 1] - indicesOfOriginNodes[i]);\n  }\n\n  return nodesPerSegment;\n}\n\n/**\n * _getIndicatorArray - Produces an array of the location of the original nodes\n * in a super sampled contour.\n *\n * @param contour - object, The original contour.\n * @param numNodes - Number, The number of nodes added.\n * @returns boolean[], The indicator array of original node locations.\n */\nfunction _getIndicatorArray(numFalse, numTrue) {\n  const perimInd = new Array(numFalse + numTrue);\n  perimInd.fill(false, 0, numFalse);\n  perimInd.fill(true, numFalse, numFalse + numTrue);\n  return perimInd;\n}\n\n/**\n * _getInterpolatedPerim - Adds additional interpolated nodes to the\n * normalized perimeter array.\n *\n * @param numNodes - object, The number of nodes to add.\n * @param cumPerimNorm - The cumulative perimeter array.\n * @returns Number[], The array of nodes.\n */\nfunction _getInterpolatedPerim(numNodes, cumPerimNorm) {\n  const diff = 1 / (numNodes - 1);\n  const linspace = [diff];\n\n  // Length - 2 as we are discarding 0 and 1 for efficiency (no need to calculate them).\n  for (let i = 1; i < numNodes - 2; i++) {\n    linspace.push(linspace[linspace.length - 1] + diff);\n  }\n\n  return linspace.concat(cumPerimNorm);\n}\n\n/**\n * _normalizedCumulativePerimeter - Normalizes the cumulative perimeter array.\n *\n * @param cumPerim - An array of the cumulative perimeter at each of a contour.\n * @returns  The normalized array.\n */\nfunction _normalisedCumulativePerimeter(cumPerim) {\n  const cumPerimNorm = [];\n\n  for (let i = 0; i < cumPerim.length; i++) {\n    cumPerimNorm.push(cumPerim[i] / cumPerim[cumPerim.length - 1]);\n  }\n\n  return cumPerimNorm;\n}\n\n/**\n * _getCumulativePerimeter - Returns an array of the the cumulative perimeter at\n * each node of the contour.\n *\n * @param contour - The contour.\n * @returns An array of the cumulative perimeter at each node.\n */\nfunction _getCumulativePerimeter(contour: Types.PointsXYZ): number[] {\n  const cumulativePerimeter = [0];\n\n  for (let i = 1; i < contour.x.length; i++) {\n    const lengthOfSegment = Math.sqrt(\n      (contour.x[i] - contour.x[i - 1]) ** 2 +\n        (contour.y[i] - contour.y[i - 1]) ** 2 +\n        (contour.z[i] - contour.z[i - 1]) ** 2\n    );\n\n    cumulativePerimeter.push(cumulativePerimeter[i - 1] + lengthOfSegment);\n  }\n\n  return cumulativePerimeter;\n}\n\n/**\n * _generateClosedContour - Generate a clockwise contour object from the points\n * of a clockwise or anti-clockwise polygon.\n *\n * @param  points - The points to generate the contour from.\n * @returns The generated contour object.\n */\nfunction _generateClosedContour(points): Types.PointsXYZ {\n  const c = {\n    x: [],\n    y: [],\n    z: [],\n  };\n  for (let i = 0; i < points.length; i++) {\n    c.x[i] = points[i][0];\n    c.y[i] = points[i][1];\n    c.z[i] = points[i][2];\n  }\n\n  // Push last node to create closed contour.\n  c.x.push(c.x[0]);\n  c.y.push(c.y[0]);\n  c.z.push(c.z[0]);\n\n  return c;\n}\n\nexport default interpolate;\n","import type { InterpolationROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport * as annotationState from '../../../stateManagement/annotation';\n\n/**\n * Updates child annotation interpolation UIDs to be the parent interpolationUID\n * followed by `-{index}` where the index is the hole/child index.  This causes\n * child annotations to be matched positionally within the parent.\n */\nexport default function updateChildInterpolationUID(\n  annotation: InterpolationROIAnnotation\n) {\n  const { parentAnnotationUID, annotationUID } = annotation;\n  if (!parentAnnotationUID) {\n    return annotation.interpolationUID;\n  }\n  const parentAnnotation = annotationState.state.getAnnotation(\n    parentAnnotationUID\n  ) as InterpolationROIAnnotation;\n  const { interpolationUID } = parentAnnotation;\n  const index = parentAnnotation.childAnnotationUIDs.indexOf(annotationUID);\n  annotation.interpolationUID = `${interpolationUID}-${index}`;\n  return annotation.interpolationUID;\n}\n","import { triggerEvent } from '@cornerstonejs/core';\nimport * as annotationStateManagement from '../../../stateManagement/annotation';\nimport interpolate from '../../contours/interpolation/interpolate';\nimport type { InterpolationViewportData } from '../../../types/InterpolationTypes';\nimport getInterpolationData from '../../contours/interpolation/getInterpolationData';\nimport type { InterpolationROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport EventTypes from '../../../enums/Events';\nimport type { AnnotationInterpolationRemovedEventDetail } from '../../../types/EventTypes';\n\n/**\n * deleteRelatedAnnotations - Delete the same interpolation uid on deleting one of them.\n *\n * @param eventData - Object.\n * @returns null\n */\nexport default function deleteRelatedAnnotations(\n  viewportData: InterpolationViewportData\n) {\n  const { annotation } = viewportData;\n  const interpolationAnnotations = getInterpolationData(viewportData, [\n    { key: 'interpolationUID', value: viewportData.interpolationUID },\n  ]);\n\n  const referencedSliceIndex = annotation.metadata.sliceIndex as number;\n  let minInterpolation = -1;\n  let maxInterpolation = viewportData.sliceData.numberOfSlices;\n  for (const [sliceIndex, annotations] of interpolationAnnotations.entries()) {\n    if (sliceIndex === referencedSliceIndex) {\n      continue;\n    }\n    const nonInterpolated = annotations.find(\n      (annotation) => !annotation.autoGenerated\n    );\n    if (!nonInterpolated) {\n      continue;\n    }\n    if (sliceIndex < referencedSliceIndex) {\n      minInterpolation = Math.max(sliceIndex, minInterpolation);\n    } else {\n      maxInterpolation = Math.min(sliceIndex, maxInterpolation);\n    }\n  }\n\n  const removedAnnotations = [];\n  for (const [sliceIndex, annotations] of interpolationAnnotations.entries()) {\n    if (\n      sliceIndex <= minInterpolation ||\n      sliceIndex >= maxInterpolation ||\n      sliceIndex === referencedSliceIndex\n    ) {\n      continue;\n    }\n    annotations.forEach((annotationToDelete) => {\n      if (annotationToDelete.autoGenerated) {\n        annotationStateManagement.state.removeAnnotation(\n          annotationToDelete.annotationUID\n        );\n        removedAnnotations.push(annotationToDelete);\n      }\n    });\n  }\n\n  if (removedAnnotations.length) {\n    const eventDetails: AnnotationInterpolationRemovedEventDetail = {\n      annotations: removedAnnotations,\n      element: viewportData.viewport.element,\n      viewportId: viewportData.viewport.id,\n      renderingEngineId: viewportData.viewport.getRenderingEngine().id,\n    };\n\n    triggerEvent(\n      viewportData.viewport.element,\n      EventTypes.INTERPOLATED_ANNOTATIONS_REMOVED,\n      eventDetails\n    );\n  }\n\n  if (\n    minInterpolation >= 0 &&\n    maxInterpolation < viewportData.sliceData.numberOfSlices\n  ) {\n    const nextAnnotation = interpolationAnnotations.get(\n      maxInterpolation\n    )[0] as InterpolationROIAnnotation;\n    // Trigger interpolation for the next non-interpolated annotation\n    const viewportNewData: InterpolationViewportData = {\n      viewport: viewportData.viewport,\n      sliceData: {\n        numberOfSlices: viewportData.sliceData.numberOfSlices,\n        imageIndex: nextAnnotation.metadata.sliceIndex as number,\n      },\n      annotation: nextAnnotation,\n      interpolationUID: nextAnnotation.interpolationUID,\n    };\n    interpolate(viewportNewData);\n  }\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  AnnotationCompletedEventType,\n  AnnotationModifiedEventType,\n  AnnotationRemovedEventType,\n} from '../../../types/EventTypes';\nimport { state as annotationState } from '../../../stateManagement/annotation';\nimport type AnnotationGroupSelector from '../../../types/AnnotationGroupSelector';\nimport getInterpolationDataCollection from '../../contours/interpolation/getInterpolationDataCollection';\nimport type {\n  InterpolationViewportData,\n  AcceptInterpolationSelector,\n} from '../../../types/InterpolationTypes';\nimport interpolate from '../../contours/interpolation/interpolate';\nimport deleteRelatedAnnotations from './deleteRelatedAnnotations';\nimport { InterpolationROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport ChangeTypes from '../../../enums/ChangeTypes';\nimport getViewportForAnnotation from '../../getViewportForAnnotation';\nimport { addContourSegmentationAnnotation } from '../../contourSegmentation/addContourSegmentationAnnotation';\n\nconst { uuidv4 } = csUtils;\n\nconst ChangeTypesForInterpolation = [\n  ChangeTypes.HandlesUpdated,\n  ChangeTypes.InterpolationUpdated,\n];\n\nexport default class InterpolationManager {\n  static toolNames = [];\n\n  static addTool(toolName: string) {\n    if (!this.toolNames.includes(toolName)) {\n      this.toolNames.push(toolName);\n    }\n  }\n\n  /**\n   * Accepts the autogenerated interpolations, marking them as non-autogenerated.\n   * Can provide a selector to choose which ones to accept.\n   *\n   * Rules for which items to select:\n   * 1. Only choose annotations having the same segment index and segmentationID\n   * 2. Exclude all contours having the same interpolation UID as any other contours\n   *    on the same slice.\n   * 3. Exclude autogenerated annotations\n   * 4. Exclude any reset interpolationUIDs (this is a manual operation to allow\n   *    creating a new interpolation)\n   * 5. Find the set of interpolationUID's remaining\n   *    a. If the set is of size 0, assign a new interpolationUID\n   *    b. If the set is of size 1, assign that interpolationUID\n   *    c. Otherwise (optional, otherwise do b for size>1 randomly),\n   *       for every remaining annotation, find the one whose center\n   *       point is closest to the center point of the new annotation.\n   *       Choose that interpolationUID\n   *\n   * To allow creating new interpolated groups, the idea is to just use a new\n   * segment index, then have an operation to update the segment index of an\n   * interpolation set.  That way the user can easily draw/see the difference,\n   * and then merge them as required.\n   * However, the base rules allow creating two contours on a single image to\n   * create a separate set.\n   */\n  static acceptAutoGenerated(\n    annotationGroupSelector: AnnotationGroupSelector,\n    selector: AcceptInterpolationSelector = {}\n  ) {\n    const { toolNames, segmentationId, segmentIndex, sliceIndex } = selector;\n    for (const toolName of toolNames || InterpolationManager.toolNames) {\n      const annotations = annotationState.getAnnotations(\n        toolName,\n        annotationGroupSelector\n      ) as InterpolationROIAnnotation[];\n      if (!annotations?.length) {\n        continue;\n      }\n      for (const annotation of annotations) {\n        const { interpolationUID, data, autoGenerated, metadata } = annotation;\n        if (interpolationUID) {\n          annotation.interpolationCompleted = true;\n        }\n        if (!autoGenerated) {\n          continue;\n        }\n        if (segmentIndex && segmentIndex !== data.segmentation.segmentIndex) {\n          continue;\n        }\n        if (\n          sliceIndex !== undefined &&\n          metadata &&\n          sliceIndex !== metadata.sliceIndex\n        ) {\n          continue;\n        }\n        if (\n          segmentationId &&\n          segmentationId !== data.segmentation.segmentationId\n        ) {\n          continue;\n        }\n        addContourSegmentationAnnotation(annotation);\n        annotation.autoGenerated = false;\n      }\n    }\n  }\n\n  /**\n   * When an annotation is completed, if the configuration includes interpolation,\n   * then find matching interpolations and interpolation between this segmentation\n   * and the other segmentations of the same type.\n   */\n  static handleAnnotationCompleted = (evt: AnnotationCompletedEventType) => {\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\n    if (!annotation?.metadata) {\n      return;\n    }\n    const { toolName, originalToolName } = annotation.metadata;\n\n    if (\n      !this.toolNames.includes(toolName) &&\n      !this.toolNames.includes(originalToolName)\n    ) {\n      return;\n    }\n\n    const viewport = getViewportForAnnotation(annotation);\n    if (!viewport) {\n      console.warn('Unable to find viewport for', annotation);\n      return;\n    }\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\n    const viewportData: InterpolationViewportData = {\n      viewport,\n      sliceData,\n      annotation,\n      interpolationUID: annotation.interpolationUID,\n    };\n    const hasInterpolationUID = !!annotation.interpolationUID;\n    // If any update, triggered on an annotation, then it will be treated as non-autogenerated.\n    annotation.autoGenerated = false;\n    if (hasInterpolationUID) {\n      // This has already been configured with matching details, so just run\n      //  the interpolation again.\n      deleteRelatedAnnotations(viewportData);\n      interpolate(viewportData);\n      return;\n    }\n    const filterData = [\n      {\n        key: 'segmentIndex',\n        value: annotation.data.segmentation.segmentIndex,\n        parentKey: (annotation) => annotation.data.segmentation,\n      },\n      {\n        key: 'viewPlaneNormal',\n        value: annotation.metadata.viewPlaneNormal,\n        parentKey: (annotation) => annotation.metadata,\n      },\n      {\n        key: 'viewUp',\n        value: annotation.metadata.viewUp,\n        parentKey: (annotation) => annotation.metadata,\n      },\n    ];\n    let interpolationAnnotations = getInterpolationDataCollection(\n      viewportData,\n      filterData\n    );\n    // Skip other type of annotation interpolationUID's that are co-located\n    const { sliceIndex } = annotation.metadata;\n    const skipUIDs = new Set<string>();\n    interpolationAnnotations.forEach((interpolationAnnotation) => {\n      if (\n        interpolationAnnotation.interpolationCompleted ||\n        interpolationAnnotation.metadata.sliceIndex === sliceIndex\n      ) {\n        const { interpolationUID } = interpolationAnnotation;\n        skipUIDs.add(interpolationUID);\n      }\n    });\n    interpolationAnnotations = interpolationAnnotations.filter(\n      (interpolationAnnotation) =>\n        !skipUIDs.has(interpolationAnnotation.interpolationUID)\n    );\n\n    // Assign a new interpolationUID (this is checked above, so will be empty initially)\n    annotation.interpolationUID =\n      interpolationAnnotations[0]?.interpolationUID || uuidv4();\n    viewportData.interpolationUID = annotation.interpolationUID;\n    interpolate(viewportData);\n  };\n\n  /**\n   * This method gets called when an annotation changes.  It will then trigger\n   * related already interpolated annotations to be updated with the modified data.\n   */\n  static handleAnnotationUpdate = (evt: AnnotationModifiedEventType) => {\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\n    const { changeType = ChangeTypes.HandlesUpdated } = evt.detail;\n    if (!annotation?.metadata) {\n      return;\n    }\n    const { toolName, originalToolName } = annotation.metadata;\n\n    if (\n      (!this.toolNames.includes(toolName) &&\n        !this.toolNames.includes(originalToolName)) ||\n      !ChangeTypesForInterpolation.includes(changeType)\n    ) {\n      return;\n    }\n    const viewport = getViewportForAnnotation(annotation);\n    if (!viewport) {\n      console.warn(\n        'Unable to find matching viewport for annotation interpolation',\n        annotation\n      );\n      return;\n    }\n    if (annotation.autoGenerated) {\n      // Dont fire the annotation changed events here, as that leads to recursion,\n      // although this is in fact completing the event, so trigger the segmentation add\n      addContourSegmentationAnnotation(annotation);\n      annotation.autoGenerated = false;\n    }\n\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\n    const viewportData: InterpolationViewportData = {\n      viewport,\n      sliceData,\n      annotation,\n      interpolationUID: annotation.interpolationUID,\n      isInterpolationUpdate: changeType === ChangeTypes.InterpolationUpdated,\n    };\n    interpolate(viewportData);\n  };\n\n  /**\n   * Delete interpolated annotations when their endpoints are deleted.\n   */\n  static handleAnnotationDelete = (evt: AnnotationRemovedEventType) => {\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\n    if (!annotation?.metadata) {\n      return;\n    }\n    const { toolName } = annotation.metadata;\n\n    if (!this.toolNames.includes(toolName) || annotation.autoGenerated) {\n      return;\n    }\n    const viewport = getViewportForAnnotation(annotation);\n\n    if (!viewport) {\n      console.warn(\n        \"No viewport, can't delete interpolated results\",\n        annotation\n      );\n      return;\n    }\n\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\n    const viewportData: InterpolationViewportData = {\n      viewport,\n      sliceData,\n      annotation,\n      interpolationUID: annotation.interpolationUID,\n    };\n    // If any update, triggered on an annotation, then it will be treated as non-interpolated.\n    annotation.autoGenerated = false;\n    deleteRelatedAnnotations(viewportData);\n  };\n}\n\nfunction getSliceData(viewport): Types.ImageSliceData {\n  const sliceData: Types.ImageSliceData = {\n    numberOfSlices: viewport.getNumberOfSlices(),\n    imageIndex: viewport.getCurrentImageIdIndex(),\n  };\n  return sliceData;\n}\n","import InterpolationManager from '../../segmentation/InterpolationManager/InterpolationManager';\nimport type { AcceptInterpolationSelector } from '../../../types/InterpolationTypes';\nimport type AnnotationGroupSelector from '../../../types/AnnotationGroupSelector';\n\n/**\n * Accepts interpolated annotations, marking them as autoGenerated false.\n *\n * @param annotationGroupSelector - viewport or FOR to select annotations on\n * @param selector - nested selection criteria\n */\nexport default function acceptAutogeneratedInterpolations(\n  annotationGroupSelector: AnnotationGroupSelector,\n  selector: AcceptInterpolationSelector\n) {\n  InterpolationManager.acceptAutoGenerated(annotationGroupSelector, selector);\n}\n","import getInterpolationData from './getInterpolationData';\nimport type { InterpolationViewportData } from '../../../types';\nimport type { InterpolationROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport type { FilterParam } from './getInterpolationData';\n\n/**\n * getInterpolationDataCollection - Gets the array of annotations which match the\n * filter parameters, mapped by slice index.\n *\n * @param viewportData - the annotation/viewport to start the interpolation from\n * @param filterParams - A selector for annotations for interpolation\n * @param onlyAnnotationImage - boolean, if true include interpolated annotation existing images only.\n * @returns The list of interpolated locations in the stack.\n */\n\nexport default function getInterpolationDataCollection(\n  viewportData: InterpolationViewportData,\n  filterParams: FilterParam[]\n): InterpolationROIAnnotation[] {\n  const imageAnnotations = getInterpolationData(viewportData, filterParams);\n  const interpolatedDataCollection = [];\n  if (!imageAnnotations?.size) {\n    return interpolatedDataCollection;\n  }\n  for (const annotations of imageAnnotations.values()) {\n    annotations.forEach((annotation) => {\n      interpolatedDataCollection.push(annotation);\n    });\n  }\n  return interpolatedDataCollection;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nimport { ContourAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nconst { isEqual } = csUtils;\n\n/**\n * Finds the index in the polyline of the specified handle.  If the handle\n * doesn't match a polyline point, then finds the closest polyline point.\n *\n * Assumes polyline is in the same orientation as the handles.\n *\n * @param annotation - to find the polyline and handles in\n * @param handleIndex - the index of hte handle to look for.\n *     Negative values are treated relative to the end of the handle index.\n * @returns Index in polyline of the closest handle\n *     * 0 for handleIndex 0\n *     * length for `handleIndex===handles length`\n */\nexport default function findHandlePolylineIndex(\n  annotation: ContourAnnotation,\n  handleIndex: number\n): number {\n  const { polyline } = annotation.data.contour;\n  const { points } = annotation.data.handles;\n  const { length } = points;\n  if (handleIndex === length) {\n    return polyline.length;\n  }\n  if (handleIndex < 0) {\n    handleIndex = (handleIndex + length) % length;\n  }\n  if (handleIndex === 0) {\n    return 0;\n  }\n  const handle = points[handleIndex];\n  const index = polyline.findIndex((point) => isEqual(handle, point));\n  if (index !== -1) {\n    return index;\n  }\n  // Need to find nearest\n  let closestDistance = Infinity;\n  return polyline.reduce((closestIndex, point, testIndex) => {\n    const distance = vec3.squaredDistance(point, handle);\n    if (distance < closestDistance) {\n      closestDistance = distance;\n      return testIndex;\n    }\n    return closestIndex;\n  }, -1);\n}\n","/**\n * Calculates the perimeter of a polyline.\n *\n * @param polyline - The polyline represented as an array of points.\n * @param closed - Indicates whether the polyline is closed or not.\n * @returns The perimeter of the polyline.\n */\nfunction calculatePerimeter(polyline: number[][], closed: boolean): number {\n  let perimeter = 0;\n\n  for (let i = 0; i < polyline.length - 1; i++) {\n    const point1 = polyline[i];\n    const point2 = polyline[i + 1];\n    perimeter += Math.sqrt(\n      Math.pow(point2[0] - point1[0], 2) + Math.pow(point2[1] - point1[1], 2)\n    );\n  }\n\n  if (closed) {\n    const firstPoint = polyline[0];\n    const lastPoint = polyline[polyline.length - 1];\n    perimeter += Math.sqrt(\n      Math.pow(lastPoint[0] - firstPoint[0], 2) +\n        Math.pow(lastPoint[1] - firstPoint[1], 2)\n    );\n  }\n\n  return perimeter;\n}\n\nexport default calculatePerimeter;\n","/**\n * Defines the names of the strategy callbacks used for performing enhanced\n * strategy operations.\n */\nenum StrategyCallbacks {\n  /**\n   * startStrategy is called at the start of a strategy, typically on mouse down\n   * Note this is separate from preview and the endings for preview, which could\n   * be called alternatively, but this may be nested within a preview.\n   */\n  OnInteractionStart = 'onInteractionStart',\n  /**\n   * finishStrategy is called at the end of a strategy being applied, usually on\n   * mouse up.\n   */\n  OnInteractionEnd = 'onInteractionEnd',\n  /**\n   * The preview can be used for tools to show what would happen on accepting\n   * before the change is actually done.  For example, a spline tool might\n   * show a preview state, and allow that to be accepted or rejected.\n   */\n  Preview = 'preview',\n  RejectPreview = 'rejectPreview',\n  AcceptPreview = 'acceptPreview',\n\n  /**\n   * Fills the given reygion\n   */\n  Fill = 'fill',\n\n  /**\n   * The default strategy function, often synonymous with fill\n   */\n  StrategyFunction = 'strategyFunction',\n\n  /**\n   * For threshold functions, this creates the thresold test.  Mostly an internal\n   * detail, but might be useful to share between strategies.\n   */\n  CreateIsInThreshold = 'createIsInThreshold',\n\n  /**\n   *  Some strategy functions need to initialize some data before being runnable.\n   * This is mostly an internal detail, just useful to have an enum here for this.\n   */\n  Initialize = 'initialize',\n\n  // Internal Details\n  INTERNAL_setValue = 'setValue',\n\n  /** inner circle size  */\n  ComputeInnerCircleRadius = 'computeInnerCircleRadius',\n}\n\nexport default StrategyCallbacks;\n","import type { InitializedOperationData } from '../BrushStrategy';\nimport pointInShapeCallback from '../../../../utilities/pointInShapeCallback';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\n\n/**\n * This function determines whether to fill or erase based on what the user\n * initially clicks on.  The behaviour is:\n * 1. If the user clicks on an area that has no active segment index in it,\n *    then assume the user using the active segment index for filling\n * 2. Find the segment index of the pixel the user clicked on, and assume they\n *    want to fill with that segment index.  Use the given segment index for\n *    the fill colour.\n *    a. If the user clicks on the active segment index, then they will fill\n *       with the active segment\n *    b. If the user clicks on the 0 segment index, they will clear the segment\n *       index, erasing the segment.\n *    c. If the user clicks on another segment index, they will \"restore\" that\n *       segment index, so that they can push back the segment area.\n *\n */\nexport default {\n  [StrategyCallbacks.Initialize]: (operationData: InitializedOperationData) => {\n    const { strategySpecificConfiguration } = operationData;\n    if (!strategySpecificConfiguration) {\n      return;\n    }\n    const { centerSegmentIndex } = strategySpecificConfiguration;\n    if (centerSegmentIndex) {\n      operationData.segmentIndex = centerSegmentIndex.segmentIndex;\n    }\n  },\n\n  [StrategyCallbacks.OnInteractionStart]: (\n    operationData: InitializedOperationData\n  ) => {\n    const {\n      segmentIndex,\n      previewSegmentIndex,\n      segmentationVoxelManager: segmentationVoxelManager,\n      centerIJK,\n      strategySpecificConfiguration,\n      imageVoxelManager: imageVoxelManager,\n      segmentationImageData,\n      preview,\n    } = operationData;\n    if (!strategySpecificConfiguration?.useCenterSegmentIndex) {\n      return;\n    }\n    // Get rid of the previous data\n    delete strategySpecificConfiguration.centerSegmentIndex;\n\n    let hasSegmentIndex = false;\n    let hasPreviewIndex = false;\n    const callback = ({ value }) => {\n      hasSegmentIndex ||= value === segmentIndex;\n      hasPreviewIndex ||= value === previewSegmentIndex;\n    };\n\n    pointInShapeCallback(\n      segmentationImageData as unknown,\n      imageVoxelManager.isInObject,\n      callback,\n      segmentationVoxelManager.boundsIJK\n    );\n\n    if (!hasSegmentIndex && !hasPreviewIndex) {\n      return;\n    }\n\n    let existingValue = segmentationVoxelManager.getAtIJKPoint(centerIJK);\n    if (existingValue === previewSegmentIndex) {\n      if (preview) {\n        existingValue = preview.segmentIndex;\n      } else {\n        return;\n      }\n    } else if (hasPreviewIndex) {\n      // Clear the preview area\n      existingValue = null;\n    }\n    operationData.segmentIndex = existingValue;\n    strategySpecificConfiguration.centerSegmentIndex = {\n      segmentIndex: existingValue,\n    };\n  },\n};\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport type { InitializedOperationData } from '../BrushStrategy';\nimport type BoundsIJK from '../../../../types/BoundsIJK';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\n\n/**\n * Initializes the threshold values for the dynamic threshold.\n * If the threshold is undefined/null, the threshold will be set\n * by looking at the area centered on the centerIJK, with a delta radius,\n * and taking the range of those pixel values.\n * If the threshold is already set, then the range will be extended by just the\n * center voxel at centerIJK.\n */\nexport default {\n  [StrategyCallbacks.Initialize]: (operationData: InitializedOperationData) => {\n    const {\n      operationName,\n      centerIJK,\n      strategySpecificConfiguration,\n      segmentationVoxelManager: segmentationVoxelManager,\n      imageVoxelManager: imageVoxelManager,\n      segmentIndex,\n    } = operationData;\n    const { THRESHOLD } = strategySpecificConfiguration;\n\n    if (!THRESHOLD?.isDynamic || !centerIJK || !segmentIndex) {\n      return;\n    }\n    if (\n      operationName === StrategyCallbacks.RejectPreview ||\n      operationName === StrategyCallbacks.OnInteractionEnd\n    ) {\n      return;\n    }\n\n    const { boundsIJK } = segmentationVoxelManager;\n    const { threshold: oldThreshold, dynamicRadius = 0 } = THRESHOLD;\n    const useDelta = oldThreshold ? 0 : dynamicRadius;\n    const nestedBounds = boundsIJK.map((ijk, idx) => {\n      const [min, max] = ijk;\n      return [\n        Math.max(min, centerIJK[idx] - useDelta),\n        Math.min(max, centerIJK[idx] + useDelta),\n      ];\n    }) as BoundsIJK;\n\n    const threshold = oldThreshold || [Infinity, -Infinity];\n    // TODO - threshold on all three values separately\n    const callback = ({ value }) => {\n      const gray = Array.isArray(value) ? vec3.len(value as any) : value;\n      threshold[0] = Math.min(gray, threshold[0]);\n      threshold[1] = Math.max(gray, threshold[1]);\n    };\n    imageVoxelManager.forEach(callback, { boundsIJK: nestedBounds });\n\n    operationData.strategySpecificConfiguration.THRESHOLD.threshold = threshold;\n  },\n  // Setup a clear threshold value on mouse/touch down\n  [StrategyCallbacks.OnInteractionStart]: (\n    operationData: InitializedOperationData\n  ) => {\n    const { strategySpecificConfiguration, preview } = operationData;\n    if (!strategySpecificConfiguration?.THRESHOLD?.isDynamic && !preview) {\n      return;\n    }\n    strategySpecificConfiguration.THRESHOLD.threshold = null;\n  },\n  /**\n   * It computes the inner circle radius in canvas coordinates and stores it\n   * in the strategySpecificConfiguration. This is used to show the user\n   * the area that is used to compute the threshold.\n   */\n  [StrategyCallbacks.ComputeInnerCircleRadius]: (\n    operationData: InitializedOperationData\n  ) => {\n    const { configuration, viewport } = operationData;\n    const { THRESHOLD: { dynamicRadius = 0 } = {} } =\n      configuration.strategySpecificConfiguration || {};\n\n    if (dynamicRadius === 0) {\n      return;\n    }\n\n    const { spacing } = (\n      viewport as Types.IStackViewport | Types.IVolumeViewport\n    ).getImageData();\n\n    const centerCanvas = [\n      viewport.element.clientWidth / 2,\n      viewport.element.clientHeight / 2,\n    ] as Types.Point2;\n    const radiusInWorld = dynamicRadius * spacing[0];\n    const centerCursorInWorld = viewport.canvasToWorld(centerCanvas);\n\n    const offSetCenterInWorld = centerCursorInWorld.map(\n      (coord) => coord + radiusInWorld\n    ) as Types.Point3;\n\n    const offSetCenterCanvas = viewport.worldToCanvas(offSetCenterInWorld);\n    const dynamicRadiusInCanvas = Math.abs(\n      centerCanvas[0] - offSetCenterCanvas[0]\n    );\n\n    // this is a bit of a hack, since we have switched to using THRESHOLD\n    // as strategy but really strategy names are CIRCLE_THRESHOLD and SPHERE_THRESHOLD\n    // and we can't really change the name of the strategy in the configuration\n    const { strategySpecificConfiguration, activeStrategy } = configuration;\n\n    if (!strategySpecificConfiguration[activeStrategy]) {\n      strategySpecificConfiguration[activeStrategy] = {};\n    }\n\n    strategySpecificConfiguration[activeStrategy].dynamicRadiusInCanvas =\n      dynamicRadiusInCanvas;\n  },\n};\n","import type { InitializedOperationData } from '../BrushStrategy';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\n\n/**\n * Sets up a preview to erase/clear the segment values.\n */\nexport default {\n  [StrategyCallbacks.Initialize]: (operationData: InitializedOperationData) => {\n    operationData.segmentIndex = 0;\n  },\n};\n","import type {\n  FloodFillResult,\n  FloodFillGetter,\n  FloodFillOptions,\n} from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * floodFill.js - Taken from MIT OSS lib - https://github.com/tuzz/n-dimensional-flood-fill\n * Refactored to ES6.  Fixed the bounds/visits checks to use integer keys, restricting the\n * total search spacing to +/- 32k in each dimension, but resulting in about a hundred time\n * performance gain for larger regions since JavaScript does not have a hash map to allow the\n * map to work on keys.\n *\n * @param getter The getter to the elements of your data structure,\n *                          e.g. getter(x,y) for a 2D interprettation of your structure.\n * @param seed The seed for your fill. The dimensionality is infered\n *                        by the number of dimensions of the seed.\n * @param options.onFlood - An optional callback to execute when each pixel is flooded.\n *                             e.g. onFlood(x,y).\n * @param options.onBoundary - An optional callback to execute whenever a boundary is reached.\n *                                a boundary could be another segmentIndex, or the edge of your\n *                                data structure (i.e. when your getter returns undefined).\n * @param options.equals - An optional equality method for your datastructure.\n *                            Default is simply value1 = value2.\n * @param options.diagonals - Whether you allow flooding through diagonals. Defaults to false.\n *\n * @returns Flood fill results\n */\nfunction floodFill(\n  getter: FloodFillGetter,\n  seed: Types.Point2 | Types.Point3,\n  options: FloodFillOptions = {}\n): FloodFillResult {\n  const onFlood = options.onFlood;\n  const onBoundary = options.onBoundary;\n  const equals = options.equals;\n  const diagonals = options.diagonals || false;\n  const startNode = get(seed);\n  const permutations = prunedPermutations();\n  const stack = [];\n  const flooded = [];\n  const visits = new Set();\n  const bounds = new Map();\n\n  stack.push({ currentArgs: seed });\n\n  while (stack.length > 0) {\n    flood(stack.pop());\n  }\n\n  return {\n    flooded,\n    boundaries: boundaries(),\n  };\n\n  function flood(job) {\n    const getArgs = job.currentArgs;\n    const prevArgs = job.previousArgs;\n\n    if (visited(getArgs)) {\n      return;\n    }\n    markAsVisited(getArgs);\n\n    if (member(getArgs)) {\n      markAsFlooded(getArgs);\n      pushAdjacent(getArgs);\n    } else {\n      markAsBoundary(prevArgs);\n    }\n  }\n\n  /**\n   * Indicates if the key has been visited.\n   * @param key is a 2 or 3 element vector with values -32768...32767\n   */\n  function visited(key) {\n    const [x, y, z = 0] = key;\n    // Use an integer key value for checking visited, since JavaScript does not\n    // provide a generic hash key indexed hash map.\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n    return visits.has(iKey);\n  }\n\n  function markAsVisited(key) {\n    const [x, y, z = 0] = key;\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n    visits.add(iKey);\n  }\n\n  function member(getArgs) {\n    const node = get(getArgs);\n\n    return equals ? equals(node, startNode) : node === startNode;\n  }\n\n  function markAsFlooded(getArgs) {\n    flooded.push(getArgs);\n    if (onFlood) {\n      //@ts-ignore\n      onFlood(...getArgs);\n    }\n  }\n\n  function markAsBoundary(prevArgs) {\n    const [x, y, z = 0] = prevArgs;\n    // Use an integer key value for checking visited, since JavaScript does not\n    // provide a generic hash key indexed hash map.\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n    bounds.set(iKey, prevArgs);\n    if (onBoundary) {\n      //@ts-ignore\n      onBoundary(...prevArgs);\n    }\n  }\n\n  function pushAdjacent(getArgs) {\n    for (let i = 0; i < permutations.length; i += 1) {\n      const perm = permutations[i];\n      const nextArgs = getArgs.slice(0);\n\n      for (let j = 0; j < getArgs.length; j += 1) {\n        nextArgs[j] += perm[j];\n      }\n\n      stack.push({\n        currentArgs: nextArgs,\n        previousArgs: getArgs,\n      });\n    }\n  }\n\n  function get(getArgs) {\n    //@ts-ignore\n    return getter(...getArgs);\n  }\n\n  // This is a significant performance hit - should be done as a wrapper\n  // only when needed.\n  // function safely(f, args) {\n  //   try {\n  //     return f(...args);\n  //   } catch (error) {\n  //     return;\n  //   }\n  // }\n\n  function prunedPermutations() {\n    const permutations = permute(seed.length);\n\n    return permutations.filter(function (perm) {\n      const count = countNonZeroes(perm);\n\n      return count !== 0 && (count === 1 || diagonals);\n    });\n  }\n\n  function permute(length) {\n    const perms = [];\n\n    const permutation = function (string) {\n      return string.split('').map(function (c) {\n        return parseInt(c, 10) - 1;\n      });\n    };\n\n    for (let i = 0; i < Math.pow(3, length); i += 1) {\n      const string = lpad(i.toString(3), '0', length);\n\n      perms.push(permutation(string));\n    }\n\n    return perms;\n  }\n\n  function boundaries() {\n    const array = Array.from(bounds.values());\n    array.reverse();\n    return array;\n  }\n}\n\nfunction defaultEquals(a, b) {\n  return a === b;\n}\n\nfunction countNonZeroes(array) {\n  let count = 0;\n\n  for (let i = 0; i < array.length; i += 1) {\n    if (array[i] !== 0) {\n      count += 1;\n    }\n  }\n\n  return count;\n}\n\nfunction lpad(string, character, length) {\n  const array = new Array(length + 1);\n  const pad = array.join(character);\n\n  return (pad + string).slice(-length);\n}\n\nexport default floodFill;\n","import determineSegmentIndex from './determineSegmentIndex';\nimport dynamicThreshold from './dynamicThreshold';\nimport erase from './erase';\nimport islandRemoval from './islandRemoval';\nimport preview from './preview';\nimport regionFill from './regionFill';\nimport setValue from './setValue';\nimport threshold from './threshold';\n\nexport default {\n  determineSegmentIndex,\n  dynamicThreshold,\n  erase,\n  islandRemoval,\n  preview,\n  regionFill,\n  setValue,\n  threshold,\n};\n","import type { InitializedOperationData } from '../BrushStrategy';\nimport floodFill from '../../../../utilities/segmentation/floodFill';\nimport { triggerSegmentationDataModified } from '../../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\n\n/**\n * Removes external islands and fills internal islands.\n * External islands are areas of preview which are not connected via fill or\n * preview colours to the clicked/dragged over points.\n * Internal islands are areas of non-preview which are entirely surrounded by\n * colours connected to the clicked/dragged over points.\n */\nexport default {\n  [StrategyCallbacks.OnInteractionEnd]: (\n    operationData: InitializedOperationData\n  ) => {\n    const {\n      previewVoxelManager: previewVoxelManager,\n      segmentationVoxelManager: segmentationVoxelManager,\n      strategySpecificConfiguration,\n      previewSegmentIndex,\n      segmentIndex,\n    } = operationData;\n\n    if (!strategySpecificConfiguration.THRESHOLD || segmentIndex === null) {\n      return;\n    }\n\n    const clickedPoints = previewVoxelManager.getPoints();\n    if (!clickedPoints?.length) {\n      return;\n    }\n\n    if (previewSegmentIndex === undefined) {\n      return;\n    }\n\n    // Ensure the bounds includes the clicked points, otherwise the fill\n    // fails.\n    const boundsIJK = previewVoxelManager\n      .getBoundsIJK()\n      .map((bound, i) => [\n        Math.min(bound[0], ...clickedPoints.map((point) => point[i])),\n        Math.max(bound[1], ...clickedPoints.map((point) => point[i])),\n      ]);\n\n    if (boundsIJK.find((it) => it[0] < 0 || it[1] > 65535)) {\n      // Nothing done, so just skip this\n      return;\n    }\n\n    const floodedSet = new Set<number>();\n    // Returns true for new colour, and false otherwise\n    const getter = (i, j, k) => {\n      if (\n        i < boundsIJK[0][0] ||\n        i > boundsIJK[0][1] ||\n        j < boundsIJK[1][0] ||\n        j > boundsIJK[1][1] ||\n        k < boundsIJK[2][0] ||\n        k > boundsIJK[2][1]\n      ) {\n        return -1;\n      }\n      const index = segmentationVoxelManager.toIndex([i, j, k]);\n      if (floodedSet.has(index)) {\n        // Values already flooded\n        return -2;\n      }\n      const oldVal = segmentationVoxelManager.getAtIndex(index);\n      const isIn =\n        oldVal === previewSegmentIndex || oldVal === segmentIndex ? 1 : 0;\n      if (!isIn) {\n        segmentationVoxelManager.addPoint(index);\n      }\n      // 1 is values that are preview/segment index, 0 is everything else\n      return isIn;\n    };\n\n    let floodedCount = 0;\n\n    const onFlood = (i, j, k) => {\n      const index = segmentationVoxelManager.toIndex([i, j, k]);\n      if (floodedSet.has(index)) {\n        return;\n      }\n      // Fill this point with an indicator that this point is connected\n      previewVoxelManager.setAtIJK(i, j, k, previewSegmentIndex);\n      floodedSet.add(index);\n      floodedCount++;\n    };\n    clickedPoints.forEach((clickedPoint) => {\n      // @ts-ignore - need to ignore the spread appication to array params\n      if (getter(...clickedPoint) === 1) {\n        floodFill(getter, clickedPoint, {\n          onFlood,\n          diagonals: true,\n        });\n      }\n    });\n\n    let clearedCount = 0;\n    let previewCount = 0;\n\n    const callback = ({ index, pointIJK, value: trackValue }) => {\n      const value = segmentationVoxelManager.getAtIndex(index);\n      if (floodedSet.has(index)) {\n        previewCount++;\n        const newValue =\n          trackValue === segmentIndex ? segmentIndex : previewSegmentIndex;\n        previewVoxelManager.setAtIJKPoint(pointIJK, newValue);\n      } else if (value === previewSegmentIndex) {\n        clearedCount++;\n        const newValue = trackValue ?? 0;\n        previewVoxelManager.setAtIJKPoint(pointIJK, newValue);\n      }\n    };\n\n    previewVoxelManager.forEach(callback, {});\n\n    if (floodedCount - previewCount !== 0) {\n      console.warn(\n        'There were flooded=',\n        floodedCount,\n        'cleared=',\n        clearedCount,\n        'preview count=',\n        previewCount,\n        'not handled',\n        floodedCount - previewCount\n      );\n    }\n    const islandMap = new Set(segmentationVoxelManager.points || []);\n    floodedSet.clear();\n\n    for (const index of islandMap.keys()) {\n      if (floodedSet.has(index)) {\n        continue;\n      }\n      let isInternal = true;\n      const internalSet = new Set<number>();\n      const onFloodInternal = (i, j, k) => {\n        const floodIndex = previewVoxelManager.toIndex([i, j, k]);\n        floodedSet.add(floodIndex);\n        if (\n          (boundsIJK[0][0] !== boundsIJK[0][1] &&\n            (i === boundsIJK[0][0] || i === boundsIJK[0][1])) ||\n          (boundsIJK[1][0] !== boundsIJK[1][1] &&\n            (j === boundsIJK[1][0] || j === boundsIJK[1][1])) ||\n          (boundsIJK[2][0] !== boundsIJK[2][1] &&\n            (k === boundsIJK[2][0] || k === boundsIJK[2][1]))\n        ) {\n          isInternal = false;\n        }\n        if (isInternal) {\n          internalSet.add(floodIndex);\n        }\n      };\n      const pointIJK = previewVoxelManager.toIJK(index);\n      if (getter(...pointIJK) !== 0) {\n        continue;\n      }\n      floodFill(getter, pointIJK, {\n        onFlood: onFloodInternal,\n        diagonals: false,\n      });\n      if (isInternal) {\n        for (const index of internalSet) {\n          previewVoxelManager.setAtIndex(index, previewSegmentIndex);\n        }\n      }\n    }\n    triggerSegmentationDataModified(\n      operationData.segmentationId,\n      previewVoxelManager.getArrayOfSlices()\n    );\n  },\n};\n","import type { Types } from '@cornerstonejs/core';\nimport type { InitializedOperationData } from '../BrushStrategy';\nimport { triggerSegmentationDataModified } from '../../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { config as segmentationConfig } from '../../../../stateManagement/segmentation';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\n\nfunction lightenColor(r, g, b, a, factor = 0.4) {\n  return [\n    Math.round(r + (255 - r) * factor),\n    Math.round(g + (255 - g) * factor),\n    Math.round(b + (255 - b) * factor),\n    a,\n  ];\n}\n\n/**\n * Sets up a preview to use an alternate set of colors.  First fills the\n * preview segment index with the final one for all pixels, then resets\n * the preview colors.\n * This is only activated when the preview segment index is defined, either\n * from the initial state or from the global state.\n */\nexport default {\n  [StrategyCallbacks.Preview]: function (\n    operationData: InitializedOperationData\n  ) {\n    const { previewColors, strategySpecificConfiguration, enabledElement } =\n      operationData;\n    if (!previewColors || !strategySpecificConfiguration) {\n      return;\n    }\n\n    // Clean up old preview data\n    if (operationData.preview) {\n      delete operationData.preview;\n    }\n    delete strategySpecificConfiguration.centerSegmentIndex;\n\n    // Now generate a normal preview as though the user had clicked, filled, released\n    this.onInteractionStart?.(enabledElement, operationData);\n    const preview = this.fill(enabledElement, operationData);\n    if (preview) {\n      preview.isPreviewFromHover = true;\n      operationData.preview = preview;\n      this.onInteractionEnd?.(enabledElement, operationData);\n    }\n    return preview;\n  },\n\n  [StrategyCallbacks.Initialize]: (operationData: InitializedOperationData) => {\n    const {\n      toolGroupId,\n      segmentIndex,\n      segmentationRepresentationUID,\n      previewSegmentIndex,\n      previewColors,\n      preview,\n    } = operationData;\n    if (previewColors === undefined) {\n      return;\n    }\n    if (preview) {\n      preview.previewVoxelManager.sourceVoxelManager =\n        operationData.segmentationVoxelManager;\n      // And use the preview data associated with this tracking object as needed\n      operationData.previewVoxelManager = preview.previewVoxelManager;\n    }\n\n    if (segmentIndex === null || !previewSegmentIndex) {\n      // Null means to reset the value, so we don't change the preview colour\n      return;\n    }\n\n    const configColor = previewColors?.[segmentIndex];\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n    if (!configColor && !segmentColor) {\n      return;\n    }\n    const previewColor = configColor || lightenColor(...segmentColor);\n\n    segmentationConfig.color.setColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      previewSegmentIndex,\n      previewColor as Types.Color\n    );\n  },\n\n  [StrategyCallbacks.AcceptPreview]: (\n    operationData: InitializedOperationData\n  ) => {\n    const {\n      segmentationVoxelManager: segmentationVoxelManager,\n      previewVoxelManager: previewVoxelManager,\n      previewSegmentIndex,\n      preview,\n    } = operationData || {};\n    if (previewSegmentIndex === undefined) {\n      return;\n    }\n    const segmentIndex = preview?.segmentIndex ?? operationData.segmentIndex;\n    const tracking = previewVoxelManager;\n    if (!tracking || tracking.modifiedSlices.size === 0) {\n      return;\n    }\n\n    const callback = ({ index }) => {\n      const oldValue = segmentationVoxelManager.getAtIndex(index);\n      if (oldValue === previewSegmentIndex) {\n        segmentationVoxelManager.setAtIndex(index, segmentIndex);\n      }\n    };\n    tracking.forEach(callback, {});\n\n    triggerSegmentationDataModified(\n      operationData.segmentationId,\n      tracking.getArrayOfSlices()\n    );\n    tracking.clear();\n  },\n\n  [StrategyCallbacks.RejectPreview]: (\n    operationData: InitializedOperationData\n  ) => {\n    const {\n      previewVoxelManager: previewVoxelManager,\n      segmentationVoxelManager: segmentationVoxelManager,\n    } = operationData;\n    if (previewVoxelManager.modifiedSlices.size === 0) {\n      return;\n    }\n\n    const callback = ({ index, value }) => {\n      segmentationVoxelManager.setAtIndex(index, value);\n    };\n    previewVoxelManager.forEach(callback);\n\n    triggerSegmentationDataModified(\n      operationData.segmentationId,\n      previewVoxelManager.getArrayOfSlices()\n    );\n    previewVoxelManager.clear();\n  },\n};\n","import type { InitializedOperationData } from '../BrushStrategy';\nimport pointInShapeCallback from '../../../../utilities/pointInShapeCallback';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\n\n/**\n * Creates a fill strategy that uses the isWithinThreshold created by the\n * createIsInThreshold and the bounds specified in the boundsIJK to go over\n * the specified area, checking if in threshold, and if so, filling that area\n * with the new segment by calling the setValue function.\n */\nexport default {\n  [StrategyCallbacks.Fill]: (operationData: InitializedOperationData) => {\n    const {\n      segmentsLocked,\n      segmentationImageData,\n      segmentationVoxelManager: segmentationVoxelManager,\n      previewVoxelManager: previewVoxelManager,\n      imageVoxelManager: imageVoxelManager,\n      brushStrategy,\n      centerIJK,\n    } = operationData;\n    const isWithinThreshold =\n      brushStrategy.createIsInThreshold?.(operationData);\n    const { setValue } = brushStrategy;\n\n    const callback = isWithinThreshold\n      ? (data) => {\n          const { value, index } = data;\n          if (segmentsLocked.includes(value) || !isWithinThreshold(index)) {\n            return;\n          }\n          setValue(operationData, data);\n        }\n      : (data) => setValue(operationData, data);\n\n    pointInShapeCallback(\n      segmentationImageData as unknown,\n      imageVoxelManager?.isInObject || segmentationVoxelManager.isInObject,\n      callback,\n      segmentationVoxelManager.boundsIJK\n    );\n\n    previewVoxelManager.addPoint(centerIJK);\n  },\n};\n","import type { InitializedOperationData } from '../BrushStrategy';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\n\n/**\n * Creates a set value function which will apply the specified segmentIndex\n * to the given location.\n * If segmentIndex is null, it will clear the given segment index instead\n * This is all done through the previewVoxelManager so that values can be recorded\n * as changed, and the original values remembered.\n */\nexport default {\n  [StrategyCallbacks.INTERNAL_setValue]: (\n    operationData: InitializedOperationData,\n    { value, index }\n  ) => {\n    const {\n      segmentsLocked,\n      segmentIndex,\n      previewVoxelManager: previewVoxelManager,\n      previewSegmentIndex,\n      segmentationVoxelManager: segmentationVoxelManager,\n    } = operationData;\n    const existingValue = segmentationVoxelManager.getAtIndex(index);\n    if (segmentIndex === null) {\n      const oldValue = previewVoxelManager.getAtIndex(index);\n      if (oldValue !== undefined) {\n        previewVoxelManager.setAtIndex(index, oldValue);\n      }\n      return;\n    }\n\n    if (existingValue === segmentIndex || segmentsLocked.includes(value)) {\n      return;\n    }\n    // Correct for preview data getting into the image area and not accepted/rejected\n    if (existingValue === previewSegmentIndex) {\n      if (previewVoxelManager.getAtIndex(index) === undefined) {\n        // Reset the value to ensure preview gets added to the indices\n        segmentationVoxelManager.setAtIndex(index, segmentIndex);\n      } else {\n        return;\n      }\n    }\n\n    // Now, just update the displayed value\n    const useSegmentIndex = previewSegmentIndex ?? segmentIndex;\n\n    previewVoxelManager.setAtIndex(index, useSegmentIndex);\n  },\n};\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport type { InitializedOperationData } from '../BrushStrategy';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\n\n/**\n * Adds an isWithinThreshold to the operation data that checks that the\n * image value is within threshold[0]...threshold[1]\n * No-op if threshold not defined.\n */\nexport default {\n  [StrategyCallbacks.CreateIsInThreshold]: (\n    operationData: InitializedOperationData\n  ) => {\n    const { imageVoxelManager, strategySpecificConfiguration, segmentIndex } =\n      operationData;\n    if (!strategySpecificConfiguration || !segmentIndex) {\n      return;\n    }\n    return (index) => {\n      const { THRESHOLD, THRESHOLD_INSIDE_CIRCLE } =\n        strategySpecificConfiguration;\n\n      const voxelValue = imageVoxelManager.getAtIndex(index);\n      const gray = Array.isArray(voxelValue)\n        ? vec3.length(voxelValue as Types.Point3)\n        : voxelValue;\n      // Prefer the generic version of the THRESHOLD configuration, but fallback\n      // to the older THRESHOLD_INSIDE_CIRCLE version.\n      const { threshold } = THRESHOLD || THRESHOLD_INSIDE_CIRCLE || {};\n      if (!threshold?.length) {\n        return true;\n      }\n      return threshold[0] <= gray && gray <= threshold[1];\n    };\n  },\n};\n","import { cache, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { isVolumeSegmentation } from './stackVolumeCheck';\nimport { LabelmapToolOperationDataStack } from '../../../../types';\n\nconst { VoxelManager } = utilities;\n\nfunction getStrategyData({ operationData, viewport }) {\n  let segmentationImageData, segmentationScalarData, imageScalarData;\n  let imageDimensions: Types.Point3;\n  let segmentationDimensions: Types.Point3;\n  let imageVoxelManager;\n  let segmentationVoxelManager;\n\n  if (isVolumeSegmentation(operationData, viewport)) {\n    const { volumeId, referencedVolumeId } = operationData;\n\n    const segmentationVolume = cache.getVolume(volumeId);\n\n    if (!segmentationVolume) {\n      return;\n    }\n    segmentationVoxelManager = segmentationVolume.voxelManager;\n\n    // we only need the referenceVolumeId if we do thresholding\n    // but for other operations we don't need it so make it optional\n    if (referencedVolumeId) {\n      const imageVolume = cache.getVolume(referencedVolumeId);\n      imageScalarData = imageVolume.getScalarData();\n      imageDimensions = imageVolume.dimensions;\n    }\n\n    ({ imageData: segmentationImageData } = segmentationVolume);\n    segmentationScalarData = segmentationVolume.getScalarData();\n    segmentationDimensions = segmentationVolume.dimensions;\n  } else {\n    const { imageIdReferenceMap, segmentationRepresentationUID } =\n      operationData as LabelmapToolOperationDataStack;\n\n    if (!imageIdReferenceMap) {\n      return;\n    }\n\n    const currentImageId = viewport.getCurrentImageId();\n    if (!currentImageId) {\n      return;\n    }\n\n    // we know that the segmentationRepresentationUID is the name of the actor always\n    // and always circle modifies the current imageId which in fact is the imageData\n    // of that actor at that moment so we have the imageData already\n    const actor = viewport.getActor(segmentationRepresentationUID);\n    if (!actor) {\n      return;\n    }\n    segmentationImageData = actor.actor.getMapper().getInputData();\n    segmentationVoxelManager = segmentationImageData.voxelManager;\n    const currentSegmentationImageId = imageIdReferenceMap.get(currentImageId);\n\n    const segmentationImage = cache.getImage(currentSegmentationImageId);\n    if (!segmentationImage) {\n      return;\n    }\n    segmentationScalarData = segmentationImage.getPixelData?.();\n\n    const image = cache.getImage(currentImageId);\n    const imageData = image ? null : viewport.getImageData();\n\n    // VERY IMPORTANT\n    // This is the pixel data of the image that is being segmented in the cache\n    // and we need to use this to for the modification\n    imageScalarData = image?.getPixelData() || imageData.getScalarData();\n    imageDimensions = image\n      ? [image.columns, image.rows, 1]\n      : imageData.dimensions;\n    segmentationDimensions = [\n      segmentationImage.columns,\n      segmentationImage.rows,\n      1,\n    ];\n    imageVoxelManager = image?.voxelManager;\n  }\n\n  segmentationVoxelManager ||= VoxelManager.createVolumeVoxelManager(\n    segmentationDimensions,\n    segmentationScalarData\n  );\n\n  imageVoxelManager ||=\n    imageDimensions &&\n    VoxelManager.createVolumeVoxelManager(imageDimensions, imageScalarData);\n\n  return {\n    segmentationImageData,\n    segmentationScalarData,\n    segmentationVoxelManager,\n    imageScalarData,\n    imageVoxelManager,\n  };\n}\n\nexport { getStrategyData };\n","import type { Types } from '@cornerstonejs/core';\nimport { cache, utilities as csUtils } from '@cornerstonejs/core';\n\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport compositions from './compositions';\nimport { getStrategyData } from './utils/getStrategyData';\nimport { isVolumeSegmentation } from './utils/stackVolumeCheck';\nimport { StrategyCallbacks } from '../../../enums';\nimport type {\n  LabelmapToolOperationDataAny,\n  LabelmapToolOperationDataVolume,\n} from '../../../types/LabelmapToolOperationData';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\n\nconst { VoxelManager } = csUtils;\n\nexport type InitializedOperationData = LabelmapToolOperationDataAny & {\n  // Allow initialization that is operation specific by keying on the name\n  operationName?: string;\n\n  // Additional data for performing the strategy\n  enabledElement: Types.IEnabledElement;\n  centerIJK?: Types.Point3;\n  centerWorld: Types.Point3;\n  viewport: Types.IViewport;\n  imageVoxelManager:\n    | csUtils.VoxelManager<number>\n    | csUtils.VoxelManager<Types.RGB>;\n  segmentationVoxelManager: csUtils.VoxelManager<number>;\n  segmentationImageData: vtkImageData;\n  previewVoxelManager: csUtils.VoxelManager<number>;\n  // The index to use for the preview segment.  Currently always undefined or 255\n  // but define it here for future expansion of LUT tables\n  previewSegmentIndex?: number;\n\n  brushStrategy: BrushStrategy;\n  configuration?: Record<string, any>;\n};\n\nexport type StrategyFunction = (\n  operationData: InitializedOperationData,\n  ...args\n) => unknown;\n\nexport type CompositionInstance = {\n  [callback in StrategyCallbacks]?: StrategyFunction;\n};\n\nexport type CompositionFunction = () => CompositionInstance;\n\nexport type Composition = CompositionFunction | CompositionInstance;\n\n/**\n * A brush strategy is a composition of individual parts which together form\n * the strategy for a brush tool.\n *\n * Parts of a strategy:\n * 1. Fill strategy - how the fill gets done (left/right, 3d, paint fill etc)\n * 2. Set value strategy - can clear values or set them, or something else?\n * 3. In object strategy - how to tell if a point is contained in the object\n *    * Bounding box getter for the object strategy\n * 4. threshold - how to determine if a point is within a threshold value\n * 5. preview - how to display preview information\n * 6. Various strategy customizations such as erase\n *\n * These combine to form an actual brush:\n *\n * Circle - convexFill, defaultSetValue, inEllipse/boundingbox ellipse, empty threshold\n * Rectangle - - convexFill, defaultSetValue, inRectangle/boundingbox rectangle, empty threshold\n * might also get parameter values from input,  init for setup of convexFill\n *\n * The pieces are combined to generate a strategyFunction, which performs\n * the actual strategy operation, as well as various callbacks for the strategy\n * to allow more control over behaviour in the specific strategy (such as displaying\n * preview)\n */\n\nexport default class BrushStrategy {\n  /**\n   * Provide some default initializers for various situations, mostly for\n   * external use to allow defining new brushes\n   */\n  public static COMPOSITIONS = compositions;\n\n  protected static childFunctions = {\n    [StrategyCallbacks.OnInteractionStart]: addListMethod(\n      StrategyCallbacks.OnInteractionStart,\n      StrategyCallbacks.Initialize\n    ),\n    [StrategyCallbacks.OnInteractionEnd]: addListMethod(\n      StrategyCallbacks.OnInteractionEnd,\n      StrategyCallbacks.Initialize\n    ),\n    [StrategyCallbacks.Fill]: addListMethod(StrategyCallbacks.Fill),\n    [StrategyCallbacks.Initialize]: addListMethod(StrategyCallbacks.Initialize),\n    [StrategyCallbacks.CreateIsInThreshold]: addSingletonMethod(\n      StrategyCallbacks.CreateIsInThreshold\n    ),\n    [StrategyCallbacks.AcceptPreview]: addListMethod(\n      StrategyCallbacks.AcceptPreview,\n      StrategyCallbacks.Initialize\n    ),\n    [StrategyCallbacks.RejectPreview]: addListMethod(\n      StrategyCallbacks.RejectPreview,\n      StrategyCallbacks.Initialize\n    ),\n    [StrategyCallbacks.INTERNAL_setValue]: addSingletonMethod(\n      StrategyCallbacks.INTERNAL_setValue\n    ),\n    [StrategyCallbacks.Preview]: addSingletonMethod(\n      StrategyCallbacks.Preview,\n      false\n    ),\n    [StrategyCallbacks.ComputeInnerCircleRadius]: addListMethod(\n      StrategyCallbacks.ComputeInnerCircleRadius\n    ),\n    // Add other exposed fields below\n    // initializers is exposed on the function to allow extension of the composition object\n    compositions: null,\n  };\n\n  public compositions: Composition[];\n  public strategyFunction: (enabledElement, operationData) => unknown;\n\n  protected configurationName: string;\n  protected _initialize = [];\n  protected _fill = [];\n  protected _acceptPreview: [];\n  protected _onInteractionStart = [];\n\n  constructor(name, ...initializers: Composition[]) {\n    this.configurationName = name;\n    this.compositions = initializers;\n    initializers.forEach((initializer) => {\n      const result =\n        typeof initializer === 'function' ? initializer() : initializer;\n      if (!result) {\n        return;\n      }\n      for (const key in result) {\n        if (!BrushStrategy.childFunctions[key]) {\n          throw new Error(`Didn't find ${key} as a brush strategy`);\n        }\n        BrushStrategy.childFunctions[key](this, result[key]);\n      }\n    });\n    this.strategyFunction = (enabledElement, operationData) =>\n      this.fill(enabledElement, operationData);\n\n    for (const key of Object.keys(BrushStrategy.childFunctions)) {\n      this.strategyFunction[key] = this[key];\n    }\n  }\n\n  /**\n   * Performs a fill of the given region.\n   * Returns the preview data if the fill performs a preview, and otherwise\n   * returns null.\n   */\n  public fill = (\n    enabledElement: Types.IEnabledElement,\n    operationData: LabelmapToolOperationDataAny\n  ) => {\n    const initializedData = this.initialize(\n      enabledElement,\n      operationData,\n      StrategyCallbacks.Fill\n    );\n\n    if (!initializedData) {\n      // Happens when there is no label map\n      return;\n    }\n\n    const { strategySpecificConfiguration = {}, centerIJK } = initializedData;\n    // Store the center IJK location so that we can skip an immediate same-point update\n    // TODO - move this to the BrushTool\n    if (csUtils.isEqual(centerIJK, strategySpecificConfiguration.centerIJK)) {\n      return operationData.preview;\n    } else {\n      strategySpecificConfiguration.centerIJK = centerIJK;\n    }\n\n    this._fill.forEach((func) => func(initializedData));\n\n    const {\n      segmentationVoxelManager,\n      previewVoxelManager,\n      previewSegmentIndex,\n    } = initializedData;\n\n    triggerSegmentationDataModified(\n      initializedData.segmentationId,\n      segmentationVoxelManager.getArrayOfSlices()\n    );\n    // We are only previewing if there is a preview index, and there is at\n    // least one slice modified\n    if (!previewSegmentIndex || !previewVoxelManager.modifiedSlices.size) {\n      return null;\n    }\n    // Use the original initialized data set to preserve preview info\n    return initializedData.preview || initializedData;\n  };\n\n  protected initialize(\n    enabledElement: Types.IEnabledElement,\n    operationData: LabelmapToolOperationDataAny,\n    operationName?: string\n  ): InitializedOperationData {\n    const { viewport } = enabledElement;\n    const data = getStrategyData({ operationData, viewport });\n\n    if (!data) {\n      console.warn('No data found for BrushStrategy');\n      return operationData.preview;\n    }\n\n    const {\n      imageVoxelManager,\n      segmentationVoxelManager,\n      segmentationImageData,\n    } = data;\n    const previewVoxelManager =\n      operationData.preview?.previewVoxelManager ||\n      VoxelManager.createHistoryVoxelManager(segmentationVoxelManager);\n    const previewEnabled = !!operationData.previewColors;\n    const previewSegmentIndex = previewEnabled ? 255 : undefined;\n\n    const initializedData: InitializedOperationData = {\n      operationName,\n      previewSegmentIndex,\n      ...operationData,\n      enabledElement,\n      imageVoxelManager,\n      segmentationVoxelManager,\n      segmentationImageData,\n      previewVoxelManager,\n      viewport,\n\n      centerWorld: null,\n      brushStrategy: this,\n    };\n\n    this._initialize.forEach((func) => func(initializedData));\n\n    return initializedData;\n  }\n\n  /**\n   * Function called to initialize the start of the strategy.  Often this is\n   * on mouse down, so calling this initDown.\n   * Over-written by the strategy composition.\n   */\n  public onInteractionStart = (\n    enabledElement: Types.IEnabledElement,\n    operationData: LabelmapToolOperationDataAny\n  ) => {\n    const { preview } = operationData;\n    // Need to skip the init down if it has already occurred in teh preview\n    // That prevents resetting values which were used to determine the preview\n    if (preview?.isPreviewFromHover) {\n      preview.isPreviewFromHover = false;\n      return;\n    }\n    const initializedData = this.initialize(enabledElement, operationData);\n    if (!initializedData) {\n      // Happens if there isn't a labelmap to apply to\n      return;\n    }\n    this._onInteractionStart.forEach((func) =>\n      func.call(this, initializedData)\n    );\n  };\n\n  /**\n   * Function called when a strategy is complete in some way.\n   * Often called on mouse up, hence the name.\n   *\n   * Over-written by the strategy composition.\n   */\n  public onInteractionEnd: (\n    enabledElement: Types.IEnabledElement,\n    operationData: LabelmapToolOperationDataAny\n  ) => void;\n\n  /**\n   * Reject the preview.\n   * Over-written by the strategy composition.\n   */\n  public rejectPreview: (\n    enabledElement: Types.IEnabledElement,\n    operationData: LabelmapToolOperationDataAny\n  ) => void;\n\n  /**\n   * Accept the preview, making it part of the overall segmentation\n   *\n   * Over-written by the strategy composition.\n   */\n  public acceptPreview: (\n    enabledElement: Types.IEnabledElement,\n    operationData: LabelmapToolOperationDataAny\n  ) => void;\n\n  /**\n   * Display a preview at the current position.  This will typically\n   * using the onInteractionStart, fill and onInteractionEnd methods,\n   * plus optional use of a preview.\n   *\n   * Over-written by the strategy composition.\n   * @returns preview data if a preview is displayed.\n   */\n  public preview: (\n    enabledElement: Types.IEnabledElement,\n    operationData: LabelmapToolOperationDataAny\n  ) => unknown;\n\n  /**\n   * Over-written by the strategy composition.\n   */\n  public setValue: (operationData: InitializedOperationData, data) => void;\n\n  /**\n   * Over-written by the strategy composition.\n   */\n  public createIsInThreshold: (operationData: InitializedOperationData) => any;\n}\n\n/**\n * Adds a list method to the set of defined methods.\n */\nfunction addListMethod(name: string, createInitialized?: string) {\n  const listName = `_${name}`;\n  return (brushStrategy, func) => {\n    brushStrategy[listName] ||= [];\n    brushStrategy[listName].push(func);\n    brushStrategy[name] ||= createInitialized\n      ? (enabledElement, operationData) => {\n          const initializedData = brushStrategy[createInitialized](\n            enabledElement,\n            operationData,\n            name\n          );\n          brushStrategy[listName].forEach((func) =>\n            func.call(brushStrategy, initializedData)\n          );\n        }\n      : (operationData) => {\n          brushStrategy[listName].forEach((func) =>\n            func.call(brushStrategy, operationData)\n          );\n        };\n  };\n}\n\n/**\n * Adds a singleton method, throwing an exception if it is already defined\n */\nfunction addSingletonMethod(name: string, isInitialized = true) {\n  return (brushStrategy, func) => {\n    if (brushStrategy[name]) {\n      throw new Error(`The singleton method ${name} already exists`);\n    }\n    brushStrategy[name] = isInitialized\n      ? func\n      : (enabledElement, operationData) => {\n          // Store the enabled element in the operation data so we can use single\n          // argument calls\n          operationData.enabledElement = enabledElement;\n          return func.call(brushStrategy, operationData);\n        };\n  };\n}\n","import type { Types } from '@cornerstonejs/core';\n\nexport type CanvasCoordinates = [\n  Types.Point2, // bottom\n  Types.Point2, // top\n  Types.Point2, // left\n  Types.Point2 // right\n];\n\n/**\n * It takes the canvas coordinates of the ellipse corners and returns the top left and bottom right\n * corners of it\n *\n * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasEllipseCorners(\n  ellipseCanvasPoints: CanvasCoordinates\n): Array<Types.Point2> {\n  const [bottom, top, left, right] = ellipseCanvasPoints;\n\n  const topLeft = <Types.Point2>[left[0], top[1]];\n  const bottomRight = <Types.Point2>[right[0], bottom[1]];\n\n  return [topLeft, bottomRight];\n}\n","import type { Types } from '@cornerstonejs/core';\ninterface Inverts {\n  invXRadiusSq?: number;\n  invYRadiusSq?: number;\n  invZRadiusSq?: number;\n  fast?: boolean;\n  /**\n   * If you call the pointInEllipse.precalculateInverts first, then you\n   * can call precalculated directly instead of having the extra time for\n   * the if conditions.\n   */\n  precalculated?: (pointLPS: Types.Point3) => boolean;\n}\n\n/**\n * Given an ellipse and a point, return true if the point is inside the ellipse\n * @param ellipse - The ellipse object to check against.\n * @param pointLPS - The point in LPS space to test.\n * @param inverts - An object to cache the inverted radius squared values, if you\n * are testing multiple points against the same ellipse then it is recommended to\n * pass in the same object to cache the values. However, there is a simpler way\n * to do this by passing in the fast flag as true, then on the first iteration\n * the values will be cached and on subsequent iterations the cached values will\n * be used.\n *\n * @returns A boolean value.\n */\nexport default function pointInEllipse(\n  ellipse,\n  pointLPS,\n  inverts: Inverts = {}\n) {\n  if (!inverts.precalculated) {\n    precalculatePointInEllipse(ellipse, inverts);\n  }\n  return inverts.precalculated(pointLPS);\n}\n\n/**\n * This will perform some precalculations to make things faster.\n * Ideally, use the 'precalculated' function inside inverts to call the\n * test function.  This minimizes re-reading of variables and only needs the\n * LPS passed each time.\n * That is:\n *\n * ```\n *    const inverts = precalculatePointInEllipse(ellipse);\n *    if( inverts.precalculated(pointLPS) ) ...\n * ```\n */\nconst precalculatePointInEllipse = (ellipse, inverts: Inverts = {}) => {\n  const { xRadius, yRadius, zRadius } = ellipse;\n\n  // This will run only once since we are caching the values in the same\n  // object that is passed in.\n  if (\n    inverts.invXRadiusSq === undefined ||\n    inverts.invYRadiusSq === undefined ||\n    inverts.invZRadiusSq === undefined\n  ) {\n    inverts.invXRadiusSq = xRadius !== 0 ? 1 / xRadius ** 2 : 0;\n    inverts.invYRadiusSq = yRadius !== 0 ? 1 / yRadius ** 2 : 0;\n    inverts.invZRadiusSq = zRadius !== 0 ? 1 / zRadius ** 2 : 0;\n  }\n\n  const { invXRadiusSq, invYRadiusSq, invZRadiusSq } = inverts;\n  const { center } = ellipse;\n  const [centerL, centerP, centerS] = center;\n\n  inverts.precalculated = (pointLPS) => {\n    // Calculate the sum of normalized squared distances\n    const dx = pointLPS[0] - centerL;\n    let inside = dx * dx * invXRadiusSq;\n    if (inside > 1) {\n      return false;\n    }\n\n    const dy = pointLPS[1] - centerP;\n    inside += dy * dy * invYRadiusSq;\n    if (inside > 1) {\n      return false;\n    }\n\n    const dz = pointLPS[2] - centerS;\n    inside += dz * dz * invZRadiusSq;\n\n    // Check if the point is inside the ellipse\n    return inside <= 1;\n  };\n\n  return inverts;\n};\n\nexport { precalculatePointInEllipse };\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCanvasEllipseCorners,\n  precalculatePointInEllipse,\n} from '../../../utilities/math/ellipse';\nimport { getBoundingBoxAroundShapeIJK } from '../../../utilities/boundingBox';\nimport BrushStrategy from './BrushStrategy';\nimport type { Composition, InitializedOperationData } from './BrushStrategy';\nimport type { CanvasCoordinates } from '../../../types';\nimport { StrategyCallbacks } from '../../../enums';\nimport compositions from './compositions';\nimport { pointInSphere } from '../../../utilities/math/sphere';\n\nconst { transformWorldToIndex, isEqual } = csUtils;\n\nconst initializeCircle = {\n  [StrategyCallbacks.Initialize]: (operationData: InitializedOperationData) => {\n    const {\n      points, // bottom, top, left, right\n      imageVoxelManager: imageVoxelManager,\n      viewport,\n      segmentationImageData,\n      segmentationVoxelManager: segmentationVoxelManager,\n    } = operationData;\n\n    // Happens on a preview setup\n    if (!points) {\n      return;\n    }\n    // Average the points to get the center of the ellipse\n    const center = vec3.fromValues(0, 0, 0);\n    points.forEach((point) => {\n      vec3.add(center, center, point);\n    });\n    vec3.scale(center, center, 1 / points.length);\n\n    operationData.centerWorld = center as Types.Point3;\n    operationData.centerIJK = transformWorldToIndex(\n      segmentationImageData,\n      center as Types.Point3\n    );\n\n    const canvasCoordinates = points.map((p) =>\n      viewport.worldToCanvas(p)\n    ) as CanvasCoordinates;\n\n    // 1. From the drawn tool: Get the ellipse (circle) topLeft and bottomRight\n    // corners in canvas coordinates\n    const [topLeftCanvas, bottomRightCanvas] =\n      getCanvasEllipseCorners(canvasCoordinates);\n\n    // 2. Find the extent of the ellipse (circle) in IJK index space of the image\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n\n    const circleCornersIJK = points.map((world) => {\n      return transformWorldToIndex(segmentationImageData, world);\n    });\n\n    // get the bounds from the circle points since in oblique images the\n    // circle will not be axis aligned\n    const boundsIJK = getBoundingBoxAroundShapeIJK(\n      circleCornersIJK,\n      segmentationImageData.getDimensions()\n    );\n\n    segmentationVoxelManager.boundsIJK = boundsIJK;\n    imageVoxelManager.isInObject = createPointInEllipse({\n      topLeftWorld,\n      bottomRightWorld,\n      center,\n    });\n  },\n} as Composition;\n\n/**\n * Creates a function that tells the user if the provided point in LPS space\n * is inside the ellipse.\n *\n * This will return a sphere test function if the bounds are a circle or\n * sphere shape (same radius in two or three dimensions), or an elliptical shape\n * if they differ.\n */\nfunction createPointInEllipse(worldInfo: {\n  topLeftWorld: Types.Point3;\n  bottomRightWorld: Types.Point3;\n  center: Types.Point3 | vec3;\n}) {\n  const { topLeftWorld, bottomRightWorld, center } = worldInfo;\n\n  const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;\n  const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;\n  const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;\n\n  const radius = Math.max(xRadius, yRadius, zRadius);\n  if (\n    isEqual(xRadius, radius) &&\n    isEqual(yRadius, radius) &&\n    isEqual(zRadius, radius)\n  ) {\n    const sphereObj = {\n      center,\n      radius,\n      radius2: radius * radius,\n    };\n    return (pointLPS) => pointInSphere(sphereObj, pointLPS);\n  }\n  // using circle as a form of ellipse\n  const ellipseObj = {\n    center: center as Types.Point3,\n    xRadius,\n    yRadius,\n    zRadius,\n  };\n\n  const { precalculated } = precalculatePointInEllipse(ellipseObj, {});\n  return precalculated;\n}\n\nconst CIRCLE_STRATEGY = new BrushStrategy(\n  'Circle',\n  compositions.regionFill,\n  compositions.setValue,\n  initializeCircle,\n  compositions.determineSegmentIndex,\n  compositions.preview\n);\n\nconst CIRCLE_THRESHOLD_STRATEGY = new BrushStrategy(\n  'CircleThreshold',\n  compositions.regionFill,\n  compositions.setValue,\n  initializeCircle,\n  compositions.determineSegmentIndex,\n  compositions.dynamicThreshold,\n  compositions.threshold,\n  compositions.preview,\n  compositions.islandRemoval\n);\n\n/**\n * Fill inside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels inside the defined circle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nconst fillInsideCircle = CIRCLE_STRATEGY.strategyFunction;\n\n/**\n * Fill inside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels inside the defined circle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nconst thresholdInsideCircle = CIRCLE_THRESHOLD_STRATEGY.strategyFunction;\n\n/**\n * Fill outside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels outside the  defined circle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nexport function fillOutsideCircle(): void {\n  throw new Error('Not yet implemented');\n}\n\nexport {\n  CIRCLE_STRATEGY,\n  CIRCLE_THRESHOLD_STRATEGY,\n  fillInsideCircle,\n  thresholdInsideCircle,\n  createPointInEllipse as createEllipseInPoint,\n};\n","import type { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nimport BrushStrategy from './BrushStrategy';\nimport type { InitializedOperationData, Composition } from './BrushStrategy';\nimport compositions from './compositions';\nimport StrategyCallbacks from '../../../enums/StrategyCallbacks';\nimport { createEllipseInPoint } from './fillCircle';\nconst { transformWorldToIndex } = csUtils;\nimport { getSphereBoundsInfo } from '../../../utilities/getSphereBoundsInfo';\nconst sphereComposition = {\n  [StrategyCallbacks.Initialize]: (operationData: InitializedOperationData) => {\n    const {\n      points,\n      imageVoxelManager: imageVoxelManager,\n      viewport,\n      segmentationImageData,\n      segmentationVoxelManager: segmentationVoxelManager,\n    } = operationData;\n\n    // Happens on a preview setup\n    if (!points) {\n      return;\n    }\n    // Average the points to get the center of the ellipse\n    const center = vec3.fromValues(0, 0, 0);\n    points.forEach((point) => {\n      vec3.add(center, center, point);\n    });\n    vec3.scale(center, center, 1 / points.length);\n\n    operationData.centerWorld = center as Types.Point3;\n    operationData.centerIJK = transformWorldToIndex(\n      segmentationImageData,\n      center as Types.Point3\n    );\n\n    const {\n      boundsIJK: newBoundsIJK,\n      topLeftWorld,\n      bottomRightWorld,\n    } = getSphereBoundsInfo(\n      points.slice(0, 2) as [Types.Point3, Types.Point3],\n      segmentationImageData,\n      viewport\n    );\n\n    segmentationVoxelManager.boundsIJK = newBoundsIJK;\n\n    if (imageVoxelManager) {\n      imageVoxelManager.isInObject = createEllipseInPoint({\n        topLeftWorld,\n        bottomRightWorld,\n        center,\n      });\n    } else {\n      segmentationVoxelManager.isInObject = createEllipseInPoint({\n        topLeftWorld,\n        bottomRightWorld,\n        center,\n      });\n    }\n  },\n} as Composition;\n\nconst SPHERE_STRATEGY = new BrushStrategy(\n  'Sphere',\n  compositions.regionFill,\n  compositions.setValue,\n  sphereComposition,\n  compositions.determineSegmentIndex,\n  compositions.preview\n);\n\n/**\n * Fill inside a sphere with the given segment index in the given operation data. The\n * operation data contains the sphere required points.\n * @param enabledElement - The element that is enabled and selected.\n * @param operationData - OperationData\n */\nconst fillInsideSphere = SPHERE_STRATEGY.strategyFunction;\n\nconst SPHERE_THRESHOLD_STRATEGY = new BrushStrategy(\n  'SphereThreshold',\n  ...SPHERE_STRATEGY.compositions,\n  compositions.dynamicThreshold,\n  compositions.threshold,\n  compositions.islandRemoval\n);\n\n/**\n * Fill inside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels inside the defined circle.\n * @param enabledElement - The element for which the segment is being filled.\n * @param operationData - EraseOperationData\n */\n\nconst thresholdInsideSphere = SPHERE_THRESHOLD_STRATEGY.strategyFunction;\n\n/**\n * Fill outside a sphere with the given segment index in the given operation data. The\n * operation data contains the sphere required points.\n * @param enabledElement - The element that is enabled and selected.\n * @param operationData - OperationData\n */\nexport function fillOutsideSphere(): void {\n  throw new Error('fill outside sphere not implemented');\n}\n\nexport { fillInsideSphere, thresholdInsideSphere, SPHERE_STRATEGY };\n","import BrushStrategy from './BrushStrategy';\nimport { SPHERE_STRATEGY } from './fillSphere';\nimport compositions from './compositions';\n\nconst ERASE_SPHERE_STRATEGY = new BrushStrategy(\n  'EraseSphere',\n  compositions.erase,\n  ...SPHERE_STRATEGY.compositions\n);\n\nconst eraseInsideSphere = ERASE_SPHERE_STRATEGY.strategyFunction;\n\nexport { eraseInsideSphere };\n","import BrushStrategy from './BrushStrategy';\nimport { CIRCLE_STRATEGY } from './fillCircle';\nimport compositions from './compositions';\n\nconst ERASE_CIRCLE_STRATEGY = new BrushStrategy(\n  'EraseCircle',\n  compositions.erase,\n  ...CIRCLE_STRATEGY.compositions\n);\n\nconst eraseInsideCircle = ERASE_CIRCLE_STRATEGY.strategyFunction;\n\nexport { eraseInsideCircle };\n","function _getHash(\n  annotationUID: string,\n  drawingElementType: string,\n  nodeUID: string\n): string {\n  return `${annotationUID}::${drawingElementType}::${nodeUID}`;\n}\n\nexport default _getHash;\n","export function setAttributesIfNecessary(attributes, svgNode) {\n  Object.keys(attributes).forEach((key) => {\n    const currentValue = svgNode.getAttribute(key);\n    const newValue = attributes[key];\n    if (newValue === undefined || newValue === '') {\n      svgNode.removeAttribute(key);\n    } else if (currentValue !== newValue) {\n      svgNode.setAttribute(key, newValue);\n    }\n  });\n}\n\nexport default setAttributesIfNecessary;\n","export function setNewAttributesIfValid(attributes, svgNode) {\n  Object.keys(attributes).forEach((key) => {\n    const newValue = attributes[key];\n    if (newValue !== undefined && newValue !== '') {\n      svgNode.setAttribute(key, newValue);\n    }\n  });\n}\n\nexport default setNewAttributesIfValid;\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\n\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\n\nfunction drawCircle(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  circleUID: string,\n  center: Types.Point2,\n  radius: number,\n  options = {},\n  dataId = ''\n): void {\n  const {\n    color,\n    fill,\n    width,\n    lineWidth,\n    lineDash,\n    fillOpacity,\n    strokeOpacity,\n  } = Object.assign(\n    {\n      color: 'rgb(0, 255, 0)',\n      fill: 'transparent',\n      width: '2',\n      lineDash: undefined,\n      lineWidth: undefined,\n      strokeOpacity: 1,\n      fillOpacity: 1,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  // variable for the namespace\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'circle', circleUID);\n  const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const attributes = {\n    cx: `${center[0]}`,\n    cy: `${center[1]}`,\n    r: `${radius}`,\n    stroke: color,\n    fill,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n    'fill-opacity': fillOpacity, // setting fill opacity\n    'stroke-opacity': strokeOpacity, // setting stroke opacity\n  };\n\n  if (existingCircleElement) {\n    setAttributesIfNecessary(attributes, existingCircleElement);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newCircleElement = document.createElementNS(svgns, 'circle');\n\n    if (dataId !== '') {\n      newCircleElement.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, newCircleElement);\n\n    svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);\n  }\n}\n\nexport default drawCircle;\n","const DEFINED_CURSORS = Symbol('DefinedCursors');\nconst STANDARD_CURSORS = new Set([\n  'alias',\n  'all-scroll',\n  'auto',\n  'cell',\n  'col-resize',\n  'context-menu',\n  'copy',\n  'crosshair',\n  'default',\n  'e-resize',\n  'ew-resize',\n  'grab',\n  'grabbing',\n  'help',\n  'move',\n  'ne-resize',\n  'nesw-resize',\n  'no-drop',\n  'none',\n  'not-allowed',\n  'n-resize',\n  'ns-resize',\n  'nw-resize',\n  'nwse-resize',\n  'pointer',\n  'progress',\n  'row-resize',\n  'se-resize',\n  's-resize',\n  'sw-resize',\n  'text',\n  'vertical-text',\n  'wait',\n  'w-resize',\n  'zoom-in',\n  'zoom-out',\n]);\n\nexport default class MouseCursor {\n  private name: string;\n  private fallback: MouseCursor | undefined;\n\n  constructor(name: string, fallback?: MouseCursor | undefined) {\n    this.name = name + '';\n    this.fallback = fallback;\n  }\n\n  getName(): string {\n    return this.name + '';\n  }\n\n  addFallbackStyleProperty(style: string): string {\n    const { fallback } = this;\n    if (fallback instanceof MouseCursor) {\n      return `${style}, ${fallback.getStyleProperty()}`;\n    }\n    return style + '';\n  }\n\n  getStyleProperty(): string {\n    return this.addFallbackStyleProperty(this.name) + '';\n  }\n\n  static getDefinedCursor(name: string): MouseCursor | undefined {\n    const definedCursors = getDefinedCursors(\n      // @ts-ignore\n      MouseCursor as Record<symbol, Map<string, MouseCursor>>,\n      DEFINED_CURSORS\n    );\n    let mouseCursor = definedCursors.get(name);\n    if (mouseCursor instanceof MouseCursor) {\n      return mouseCursor;\n    }\n    if (STANDARD_CURSORS.has(name)) {\n      mouseCursor = new MouseCursor(name);\n      definedCursors.set(name, mouseCursor);\n      return mouseCursor;\n    }\n  }\n\n  static setDefinedCursor(name: string, cursor: MouseCursor): boolean {\n    if (cursor instanceof MouseCursor) {\n      const definedCursors = getDefinedCursors(\n        // @ts-ignore\n        MouseCursor as Record<symbol, Map<string, MouseCursor>>,\n        DEFINED_CURSORS\n      );\n      definedCursors.set(name, cursor);\n      return true;\n    }\n    return false;\n  }\n}\n\n/*\n * Helpers\n */\n\nfunction getDefinedCursors(\n  context: Record<symbol, Map<string, MouseCursor>>,\n  symbol: symbol\n): Map<string, MouseCursor> {\n  let definedCursors = context[symbol];\n  if (!(definedCursors instanceof Map)) {\n    definedCursors = new Map();\n    Object.defineProperty(context, symbol, { value: definedCursors });\n  }\n  return definedCursors;\n}\n\nconst standardCursorNames = STANDARD_CURSORS.values();\nexport { standardCursorNames };\n","import { MouseCursor } from '.';\n\nconst ELEMENT_CURSORS_MAP = Symbol('ElementCursorsMap');\n\n/*\n * Public Methods\n */\n\nfunction initElementCursor(\n  element: HTMLDivElement,\n  cursor: MouseCursor | null\n): void {\n  _getElementCursors(element)[0] = cursor;\n  _setElementCursor(element, cursor);\n}\n\nfunction _setElementCursor(\n  element: HTMLDivElement,\n  cursor: MouseCursor | null\n): void {\n  const cursors = _getElementCursors(element);\n  cursors[1] = cursors[0];\n  cursors[0] = cursor;\n  element.style.cursor = (\n    cursor instanceof MouseCursor\n      ? cursor\n      : MouseCursor.getDefinedCursor('auto')\n  ).getStyleProperty();\n}\n\nfunction resetElementCursor(element: HTMLDivElement): void {\n  _setElementCursor(element, _getElementCursors(element)[1]);\n}\n\nfunction hideElementCursor(element: HTMLDivElement): void {\n  _setElementCursor(element, MouseCursor.getDefinedCursor('none'));\n}\n\n/*\n * Helpers\n */\n\nfunction _getElementCursors(\n  element: HTMLDivElement\n): [MouseCursor | null, MouseCursor | null] {\n  let map = _getElementCursors[ELEMENT_CURSORS_MAP];\n  if (!(map instanceof WeakMap)) {\n    map = new WeakMap();\n    Object.defineProperty(_getElementCursors, ELEMENT_CURSORS_MAP, {\n      value: map,\n    });\n  }\n  let cursors = map.get(element);\n  if (!cursors) {\n    cursors = [null, null];\n    map.set(element, cursors);\n  }\n  return cursors;\n}\n\n/*\n * Exports\n */\nexport {\n  initElementCursor,\n  resetElementCursor,\n  hideElementCursor,\n  _setElementCursor as setElementCursor,\n};\n","import { ToolGroupSpecificRepresentation } from '../../types/SegmentationStateTypes';\nimport {\n  getDefaultSegmentationStateManager,\n  getSegmentation,\n} from './segmentationState';\nimport { triggerSegmentationRepresentationModified } from './triggerSegmentationEvents';\n\n/**\n * Get the active segmentation representation for the tool group with\n * the given toolGroupId.\n * @param toolGroupId - The Id of the tool group\n * @returns The active segmentation representation for the tool group.\n */\nfunction getActiveSegmentationRepresentation(\n  toolGroupId: string\n): ToolGroupSpecificRepresentation {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  const toolGroupSegmentationRepresentations =\n    segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n\n  if (!toolGroupSegmentationRepresentations) {\n    return;\n  }\n\n  const activeRepresentation = toolGroupSegmentationRepresentations.find(\n    (representation) => representation.active\n  );\n\n  return activeRepresentation;\n}\n\n/**\n * Retrieves the active segmentation for a given tool group.\n * @param toolGroupId - The ID of the tool group.\n * @returns The active segmentation Id, or undefined if no active segmentation is found.\n */\nfunction getActiveSegmentation(toolGroupId: string) {\n  const activeRepresentation = getActiveSegmentationRepresentation(toolGroupId);\n\n  if (!activeRepresentation) {\n    return;\n  }\n\n  const activeSegmentation = getSegmentation(\n    activeRepresentation.segmentationId\n  );\n\n  return activeSegmentation;\n}\n\n/**\n * Set the active segmentation for the given tool group for all its viewports\n *\n * @param toolGroupId - The Id of the tool group to set the active\n * segmentation for.\n * @param segmentationRepresentationUID - The id of the segmentation representation to set as\n * active.\n */\nfunction setActiveSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  segmentationStateManager.setActiveSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nexport {\n  // get\n  getActiveSegmentationRepresentation,\n  getActiveSegmentation,\n  // set\n  setActiveSegmentationRepresentation,\n};\n","import { getActiveSegmentationRepresentation } from './activeSegmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\n\n/**\n * Get the locked status for a segment index in a segmentation\n * @param segmentationId - The id of the segmentation that the segment\n * belongs to.\n * @param segmentIndex - The index of the segment\n * @returns A boolean value indicating whether the segment is locked or not.\n */\nfunction isSegmentIndexLocked(\n  segmentationId: string,\n  segmentIndex: number\n): boolean {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n  return segmentsLocked.has(segmentIndex);\n}\n\n/**\n * Set the locked status of a segment index in a segmentation\n * @param segmentationId - The id of the segmentation whose segment\n * index is being modified.\n * @param segmentIndex - The index of the segment to lock/unlock.\n */\nfunction setSegmentIndexLocked(\n  segmentationId: string,\n  segmentIndex: number,\n  locked = true\n): void {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n\n  if (locked) {\n    segmentsLocked.add(segmentIndex);\n  } else {\n    segmentsLocked.delete(segmentIndex);\n  }\n\n  triggerSegmentationModified(segmentationId);\n}\n\n/**\n * Get the locked segments for a segmentation\n * @param segmentationId - The id of the segmentation to get locked\n * segments for.\n * @returns An array of locked segment indices.\n */\nfunction getLockedSegments(segmentationId: string): number[] | [] {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n  return Array.from(segmentsLocked);\n}\n\nexport { isSegmentIndexLocked, setSegmentIndexLocked, getLockedSegments };\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getBrushToolInstances } from './utilities';\n\n/**\n * Invalidates the brush cursor for a specific tool group.\n * This function triggers the update of the brush being rendered.\n * It also triggers an annotation render for any viewports on the tool group.\n *\n * @param toolGroupId - The ID of the tool group.\n */\nexport function invalidateBrushCursor(toolGroupId: string): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n\n  brushBasedToolInstances.forEach((tool: BrushTool) => {\n    // Invalidate the brush being rendered so it can update.\n    tool.invalidateBrushCursor();\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  const viewportsInfoArray = Object.keys(viewportsInfo).map(\n    (key) => viewportsInfo[key]\n  );\n\n  if (!viewportsInfoArray.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfoArray[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n","import { invalidateBrushCursor } from '../../utilities/segmentation/';\nimport {\n  getSegmentation,\n  getToolGroupIdsWithSegmentation,\n} from './segmentationState';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\n\n/**\n * Set the active segment index for a segmentation Id. It fires a global state\n * modified event. Also it invalidates the brush cursor for all toolGroups that\n * has the segmentationId as active segment (since the brush cursor color\n * should change as well)\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param segmentationId - The id of the segmentation that the segment belongs to.\n * @param segmentIndex - The index of the segment to be activated.\n */\nfunction setActiveSegmentIndex(\n  segmentationId: string,\n  segmentIndex: number\n): void {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (typeof segmentIndex === 'string') {\n    console.warn('segmentIndex is a string, converting to number');\n    segmentIndex = Number(segmentIndex);\n  }\n\n  if (segmentation?.activeSegmentIndex !== segmentIndex) {\n    segmentation.activeSegmentIndex = segmentIndex;\n\n    triggerSegmentationModified(segmentationId);\n  }\n\n  // get all toolGroups that has the segmentationId as active\n  // segment and call invalidateBrushCursor on them\n  const toolGroups = getToolGroupIdsWithSegmentation(segmentationId);\n  toolGroups.forEach((toolGroupId) => {\n    invalidateBrushCursor(toolGroupId);\n  });\n}\n\n/**\n * Get the active segment index for a segmentation in the global state\n * @param segmentationId - The id of the segmentation to get the active segment index from.\n * @returns The active segment index for the given segmentation.\n */\nfunction getActiveSegmentIndex(segmentationId: string): number | undefined {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (segmentation) {\n    return segmentation.activeSegmentIndex;\n  }\n}\n\nexport { getActiveSegmentIndex, setActiveSegmentIndex };\n","import {\n  utilities as csUtils,\n  cache,\n  getEnabledElement,\n  StackViewport,\n  eventTarget,\n  Enums,\n} from '@cornerstonejs/core';\nimport { vec3, vec2 } from 'gl-matrix';\n\nimport type { Types } from '@cornerstonejs/core';\nimport type {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { BaseTool } from '../base';\nimport {\n  fillInsideSphere,\n  thresholdInsideSphere,\n} from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport {\n  thresholdInsideCircle,\n  fillInsideCircle,\n} from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport {\n  Events,\n  ToolModes,\n  SegmentationRepresentations,\n  StrategyCallbacks,\n} from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  state as segmentationState,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\nimport {\n  LabelmapSegmentationDataVolume,\n  LabelmapSegmentationDataStack,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\n/**\n * A type for preview data/information, used to setup previews on hover, or\n * maintain the preview information.\n */\nexport type PreviewData = {\n  /**\n   *  The preview data returned from the strategy\n   */\n  preview: unknown;\n  timer?: number;\n  timerStart: number;\n  startPoint: Types.Point2;\n  element: HTMLDivElement;\n  isDrag: boolean;\n};\n\n/**\n * @public\n */\nclass BrushTool extends BaseTool {\n  static toolName;\n  private _editData: {\n    segmentsLocked: number[]; //\n    segmentationRepresentationUID?: string;\n    imageIdReferenceMap?: Map<string, string>;\n    volumeId?: string;\n    referencedVolumeId?: string;\n  } | null;\n  private _hoverData?: {\n    brushCursor: any;\n    segmentationId: string;\n    segmentIndex: number;\n    segmentationRepresentationUID: string;\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    centerCanvas?: Array<number>;\n  };\n\n  private _previewData?: PreviewData = {\n    preview: null,\n    element: null,\n    timerStart: 0,\n    timer: null,\n    startPoint: [NaN, NaN],\n    isDrag: false,\n  };\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE_CIRCLE: fillInsideCircle,\n          ERASE_INSIDE_CIRCLE: eraseInsideCircle,\n          FILL_INSIDE_SPHERE: fillInsideSphere,\n          ERASE_INSIDE_SPHERE: eraseInsideSphere,\n          THRESHOLD_INSIDE_CIRCLE: thresholdInsideCircle,\n          THRESHOLD_INSIDE_SPHERE: thresholdInsideSphere,\n        },\n        strategySpecificConfiguration: {\n          THRESHOLD: {\n            threshold: [-150, -70], // E.g. CT Fat // Only used during threshold strategies.\n          },\n        },\n        defaultStrategy: 'FILL_INSIDE_CIRCLE',\n        activeStrategy: 'FILL_INSIDE_CIRCLE',\n        thresholdVolumeId: null,\n        brushSize: 25,\n        preview: {\n          // Have to enable the preview to use this\n          enabled: false,\n          previewColors: {},\n          // The time before showing a preview\n          previewTimeMs: 250,\n          // The distance to move to show a preview before preview time expired\n          previewMoveDistance: 8,\n          // The distance to drag before being considered a drag rather than click\n          dragMoveDistance: 4,\n          // The time to consider a mouse click a drag when moved less than dragMoveDistance\n          dragTimeMs: 500,\n        },\n        actions: {\n          [StrategyCallbacks.AcceptPreview]: {\n            method: StrategyCallbacks.AcceptPreview,\n            bindings: [\n              {\n                key: 'Enter',\n              },\n            ],\n          },\n          [StrategyCallbacks.RejectPreview]: {\n            method: StrategyCallbacks.RejectPreview,\n            bindings: [\n              {\n                key: 'Escape',\n              },\n            ],\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolPassive = (evt) => {\n    this.disableCursor();\n  };\n\n  onSetToolEnabled = () => {\n    this.disableCursor();\n  };\n\n  onSetToolDisabled = (evt) => {\n    this.disableCursor();\n  };\n\n  private disableCursor() {\n    this._hoverData = undefined;\n    this.rejectPreview();\n  }\n\n  createEditData(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create a segmentation representation before using the brush tool'\n      );\n    }\n\n    const { segmentationId, type, segmentationRepresentationUID } =\n      activeSegmentationRepresentation;\n\n    if (type === SegmentationRepresentations.Contour) {\n      throw new Error('Not implemented yet');\n    }\n\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const { representationData } =\n      segmentationState.getSegmentation(segmentationId);\n\n    const labelmapData =\n      representationData[SegmentationRepresentations.Labelmap];\n\n    if (isVolumeSegmentation(labelmapData, viewport)) {\n      const { volumeId } = representationData[\n        type\n      ] as LabelmapSegmentationDataVolume;\n      const actors = viewport.getActors();\n\n      const isStackViewport = viewport instanceof StackViewport;\n\n      if (isStackViewport) {\n        const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n          detail: {\n            type: 'Segmentation',\n            message: 'Cannot perform brush operation on the selected viewport',\n          },\n          cancelable: true,\n        });\n        eventTarget.dispatchEvent(event);\n        return null;\n      }\n\n      // we used to take the first actor here but we should take the one that is\n      // probably the same size as the segmentation volume\n      const volumes = actors.map((actorEntry) =>\n        cache.getVolume(actorEntry.referenceId)\n      );\n\n      const segmentationVolume = cache.getVolume(volumeId);\n\n      const referencedVolumeIdToThreshold =\n        volumes.find((volume) =>\n          csUtils.isEqual(volume.dimensions, segmentationVolume.dimensions)\n        )?.volumeId || volumes[0]?.volumeId;\n\n      return {\n        volumeId,\n        referencedVolumeId:\n          this.configuration.thresholdVolumeId ?? referencedVolumeIdToThreshold,\n        segmentsLocked,\n        segmentationRepresentationUID,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      const currentImageId = viewport.getCurrentImageId();\n\n      if (!imageIdReferenceMap.get(currentImageId)) {\n        // if there is no stack segmentation slice for the current image\n        // we should not allow the user to perform any operation\n        return;\n      }\n\n      // here we should identify if we can perform sphere manipulation\n      // for these stack of images, if the metadata is not present\n      // to create a volume or if there are inconsistencies between\n      // the image metadata we should not allow the sphere manipulation\n      // and should throw an error or maybe simply just allow circle manipulation\n      // and not sphere manipulation\n      if (this.configuration.activeStrategy.includes('SPHERE')) {\n        throw new Error(\n          'Sphere manipulation is not supported for stacks of image segmentations yet'\n        );\n        // Todo: add sphere (volumetric) manipulation support for stacks of images\n        // we should basically check if the stack constructs a valid volume\n        // meaning all the metadata is present and consistent\n        // then we use a VoxelManager mapping to map a volume like appearance\n        // for the stack data.\n        // csUtils.isValidVolume(referencedImageIds\n      }\n\n      return {\n        imageIdReferenceMap,\n        segmentsLocked,\n        segmentationRepresentationUID,\n      };\n    }\n  }\n\n  preMouseDownCallback = (\n    evt: EventTypes.MouseDownActivateEventType\n  ): boolean => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this._editData = this.createEditData(element);\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    // This might be a mouse down\n    this._previewData.isDrag = false;\n    this._previewData.timerStart = Date.now();\n\n    const hoverData = this._hoverData || this.createHoverData(element);\n\n    triggerAnnotationRenderForViewportUIDs(\n      renderingEngine,\n      hoverData.viewportIdsToRender\n    );\n\n    this.applyActiveStrategyCallback(\n      enabledElement,\n      this.getOperationData(element),\n      StrategyCallbacks.OnInteractionStart\n    );\n\n    return true;\n  };\n\n  /**\n   * This call will be made when the mouse moves and the tool is active, but\n   * not actually drawing at the moment.\n   * The behavior is:\n   *    1. Update the cursor\n   *    2. Call the active strategy event 'preview' and 'rejectPreview'\n   *       on the mouse cursor position on a periodic basis to create a preview\n   *       when configured to do so.\n   *\n   * The preview will be shown after the mouse has been stationary for 250 ms.\n   * Any preview will be cancelled (immediately) after moving outside the center\n   * distance.\n   * As well, if the mouse moves but stays inside the center area for 250 ms,\n   * then the cancel will happen with a new preview being added.\n   *\n   * See mouse up details for how the preview gets accepted.\n   *\n   * The preview also needs to be cancelled on changing tools.\n   */\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\n    if (this.mode === ToolModes.Active) {\n      this.updateCursor(evt);\n      if (!this.configuration.preview.enabled) {\n        return;\n      }\n      const { previewTimeMs, previewMoveDistance, dragMoveDistance } =\n        this.configuration.preview;\n      const { currentPoints, element } = evt.detail;\n      const { canvas } = currentPoints;\n\n      const { preview, startPoint, timer, timerStart, isDrag } =\n        this._previewData;\n      const delta = vec2.distance(canvas, startPoint);\n      const time = Date.now() - timerStart;\n      if (\n        delta > previewMoveDistance ||\n        (time > previewTimeMs && delta > dragMoveDistance)\n      ) {\n        if (timer) {\n          window.clearTimeout(timer);\n          this._previewData.timer = null;\n        }\n        if (preview && !isDrag) {\n          this.rejectPreview(element);\n        }\n      }\n      if (!this._previewData.timer) {\n        const timer = window.setTimeout(this.previewCallback, 250);\n        Object.assign(this._previewData, {\n          timerStart: Date.now(),\n          timer,\n          startPoint: canvas,\n          element,\n        });\n      }\n    }\n  };\n\n  previewCallback = () => {\n    if (this._previewData.preview) {\n      return;\n    }\n    this._previewData.timer = null;\n    this._previewData.preview = this.applyActiveStrategyCallback(\n      getEnabledElement(this._previewData.element),\n      this.getOperationData(this._previewData.element),\n      StrategyCallbacks.Preview\n    );\n  };\n\n  private createHoverData(element, centerCanvas?) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const viewportIdsToRender = [viewport.id];\n\n    const {\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      segmentColor,\n    } = this.getActiveSegmentationData() || {};\n\n    // Center of circle in canvas Coordinates\n    const brushCursor = {\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {},\n    };\n\n    return {\n      brushCursor,\n      centerCanvas,\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      segmentColor,\n      viewportIdsToRender,\n    };\n  }\n\n  private getActiveSegmentationData() {\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      console.warn(\n        'No active segmentation detected, create one before using the brush tool'\n      );\n      return;\n    }\n\n    const { segmentationRepresentationUID, segmentationId } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    return {\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      segmentColor,\n    };\n  }\n\n  /**\n   * Updates the cursor position and whether it is showing or not.\n   * Can be over-ridden to add more cursor details or a preview.\n   */\n  protected updateCursor(evt: EventTypes.InteractionEventType) {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const { currentPoints } = eventData;\n    const centerCanvas = currentPoints.canvas;\n    this._hoverData = this.createHoverData(element, centerCanvas);\n\n    this._calculateCursor(element, centerCanvas);\n\n    if (!this._hoverData) {\n      return;\n    }\n\n    triggerAnnotationRenderForViewportUIDs(\n      getEnabledElement(element).renderingEngine,\n      this._hoverData.viewportIdsToRender\n    );\n  }\n\n  private _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventData = evt.detail;\n    const { element, currentPoints } = eventData;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.updateCursor(evt);\n\n    const { viewportIdsToRender } = this._hoverData;\n\n    triggerAnnotationRenderForViewportUIDs(\n      renderingEngine,\n      viewportIdsToRender\n    );\n\n    const delta = vec2.distance(\n      currentPoints.canvas,\n      this._previewData.startPoint\n    );\n    const { dragTimeMs, dragMoveDistance } = this.configuration.preview;\n    if (\n      !this._previewData.isDrag &&\n      this._previewData.preview &&\n      Date.now() - this._previewData.timerStart < dragTimeMs &&\n      delta < dragMoveDistance\n    ) {\n      // If we are showing a preview, then don't start dragging quite immediately\n      // so that click up can accept the preview.\n      return;\n    }\n\n    this._previewData.preview = this.applyActiveStrategy(\n      enabledElement,\n      this.getOperationData(element)\n    );\n    this._previewData.element = element;\n    // Add a bit of time to the timer start so small accidental movements dont\n    // cause issues on clicking\n    this._previewData.timerStart = Date.now() + dragTimeMs;\n    this._previewData.isDrag = true;\n    this._previewData.startPoint = currentPoints.canvas;\n  };\n\n  protected getOperationData(element?) {\n    const editData = this._editData || this.createEditData(element);\n\n    const {\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      brushCursor,\n    } = this._hoverData || this.createHoverData(element);\n    const { data, metadata = {} } = brushCursor || {};\n    const { viewPlaneNormal, viewUp } = metadata;\n    const operationData = {\n      ...editData,\n      points: data?.handles?.points,\n      segmentIndex,\n      previewColors: this.configuration.preview.enabled\n        ? this.configuration.preview.previewColors\n        : null,\n      viewPlaneNormal,\n      toolGroupId: this.toolGroupId,\n      segmentationId,\n      segmentationRepresentationUID,\n      viewUp,\n      strategySpecificConfiguration:\n        this.configuration.strategySpecificConfiguration,\n      // Provide the preview information so that data can be used directly\n      preview: this._previewData?.preview,\n    };\n    return operationData;\n  }\n\n  private _calculateCursor(element, centerCanvas) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n    const camera = viewport.getCamera();\n    const { brushSize } = this.configuration;\n\n    const viewUp = vec3.fromValues(\n      camera.viewUp[0],\n      camera.viewUp[1],\n      camera.viewUp[2]\n    );\n    const viewPlaneNormal = vec3.fromValues(\n      camera.viewPlaneNormal[0],\n      camera.viewPlaneNormal[1],\n      camera.viewPlaneNormal[2]\n    );\n    const viewRight = vec3.create();\n\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n    // in the world coordinate system, the brushSize is the radius of the circle\n    // in mm\n    const centerCursorInWorld: Types.Point3 = canvasToWorld([\n      centerCanvas[0],\n      centerCanvas[1],\n    ]);\n\n    const bottomCursorInWorld = vec3.create();\n    const topCursorInWorld = vec3.create();\n    const leftCursorInWorld = vec3.create();\n    const rightCursorInWorld = vec3.create();\n\n    // Calculate the bottom and top points of the circle in world coordinates\n    for (let i = 0; i <= 2; i++) {\n      bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;\n      topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;\n      leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;\n      rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;\n    }\n\n    if (!this._hoverData) {\n      return;\n    }\n\n    const { brushCursor } = this._hoverData;\n    const { data } = brushCursor;\n\n    if (data.handles === undefined) {\n      data.handles = {};\n    }\n\n    data.handles.points = [\n      bottomCursorInWorld,\n      topCursorInWorld,\n      leftCursorInWorld,\n      rightCursorInWorld,\n    ];\n\n    const activeStrategy = this.configuration.activeStrategy;\n    const strategy = this.configuration.strategies[activeStrategy];\n\n    // Note: i don't think this is the best way to implement this\n    // but don't think we have a better way to do it for now\n    if (typeof strategy.computeInnerCircleRadius === 'function') {\n      strategy.computeInnerCircleRadius({\n        configuration: this.configuration,\n        viewport,\n      });\n    }\n\n    data.invalidated = false;\n  }\n\n  /**\n   * The end callback call is made when the mouse is released.  This will\n   * perform another active strategy render event to render the final position.\n   * As well, the finish strategy callback will be made during this time.\n   */\n  private _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const enabledElement = getEnabledElement(element);\n\n    const operationData = this.getOperationData(element);\n    // Don't re-fill when the preview is showing and the user clicks again\n    // otherwise the new area of hover may get filled, which is unexpected\n    if (!this._previewData.preview && !this._previewData.isDrag) {\n      this.applyActiveStrategy(enabledElement, operationData);\n    }\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    this.updateCursor(evt);\n\n    this._editData = null;\n\n    this.applyActiveStrategyCallback(\n      enabledElement,\n      operationData,\n      StrategyCallbacks.OnInteractionEnd\n    );\n\n    if (!this._previewData.isDrag) {\n      this.acceptPreview(element);\n    }\n  };\n\n  /**\n   * Cancels any preview view being shown, resetting any segments being shown.\n   */\n  public rejectPreview(element = this._previewData.element) {\n    if (!element || !this._previewData.preview) {\n      return;\n    }\n    const enabledElement = getEnabledElement(element);\n    this.applyActiveStrategyCallback(\n      enabledElement,\n      this.getOperationData(element),\n      StrategyCallbacks.RejectPreview\n    );\n    this._previewData.preview = null;\n    this._previewData.isDrag = false;\n  }\n\n  /**\n   * Accepts a preview, marking it as the active segment.\n   */\n  public acceptPreview(element = this._previewData.element) {\n    if (!element) {\n      return;\n    }\n    const enabledElement = getEnabledElement(element);\n\n    this.applyActiveStrategyCallback(\n      enabledElement,\n      this.getOperationData(element),\n      StrategyCallbacks.AcceptPreview\n    );\n    this._previewData.isDrag = false;\n    this._previewData.preview = null;\n  }\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  private _activateDraw = (element: HTMLDivElement): void => {\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  private _deactivateDraw = (element: HTMLDivElement): void => {\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n  };\n\n  public invalidateBrushCursor() {\n    if (this._hoverData === undefined) {\n      return;\n    }\n    const { data } = this._hoverData.brushCursor;\n\n    data.invalidated = true;\n\n    // Todo: figure out if other brush metadata (other than segment color) should get updated\n    // during the brush cursor invalidation\n    const { segmentColor } = this.getActiveSegmentationData() || {};\n    this._hoverData.brushCursor.metadata.segmentColor = segmentColor;\n  }\n\n  renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): void {\n    if (!this._hoverData) {\n      return;\n    }\n\n    const { viewport } = enabledElement;\n\n    const viewportIdsToRender = this._hoverData.viewportIdsToRender;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return;\n    }\n\n    const brushCursor = this._hoverData.brushCursor;\n\n    if (brushCursor.data.invalidated === true) {\n      const { centerCanvas } = this._hoverData;\n      const { element } = viewport;\n\n      // This can be set true when changing the brush size programmatically\n      // whilst the cursor is being rendered.\n      this._calculateCursor(element, centerCanvas);\n    }\n\n    const toolMetadata = brushCursor.metadata;\n    if (!toolMetadata) {\n      return;\n    }\n\n    const annotationUID = toolMetadata.brushCursorUID;\n\n    const data = brushCursor.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor?.slice(0, 3) || [0, 0, 0]})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n\n    const activeStrategy = this.configuration.activeStrategy;\n    const { dynamicRadiusInCanvas } = this.configuration\n      .strategySpecificConfiguration[activeStrategy] || {\n      dynamicRadiusInCanvas: 0,\n    };\n\n    if (dynamicRadiusInCanvas) {\n      const circleUID1 = '1';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID1,\n        center as Types.Point2,\n        dynamicRadiusInCanvas,\n        {\n          color,\n        }\n      );\n    }\n  }\n}\n\nBrushTool.toolName = 'Brush';\nexport default BrushTool;\n","import { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\n\nexport type ThresholdInformation = {\n  volume: Types.IImageVolume;\n  lower: number;\n  upper: number;\n};\n\nexport function getBrushToolInstances(toolGroupId: string, toolName?: string) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  if (toolName && toolInstances[toolName]) {\n    return [toolInstances[toolName]];\n  }\n\n  // For each tool that has BrushTool as base class, set the brush size.\n  const brushBasedToolInstances = Object.values(toolInstances).filter(\n    (toolInstance) => toolInstance instanceof BrushTool\n  ) as BrushTool[];\n\n  return brushBasedToolInstances;\n}\n\nconst equalsCheck = (a, b) => {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\n/**\n * Given the center of a voxel in world coordinates, calculate the voxel\n * corners in world coords to calculate the voxel overlap in another volume\n */\nexport function getVoxelOverlap(\n  imageData,\n  dimensions,\n  voxelSpacing,\n  voxelCenter\n) {\n  const voxelCornersWorld = [];\n  for (let i = 0; i < 2; i++) {\n    for (let j = 0; j < 2; j++) {\n      for (let k = 0; k < 2; k++) {\n        const point = [...voxelCenter]; // Create a new point from voxelCenter\n        point[0] = point[0] + ((i * 2 - 1) * voxelSpacing[0]) / 2;\n        point[1] = point[1] + ((j * 2 - 1) * voxelSpacing[1]) / 2;\n        point[2] = point[2] + ((k * 2 - 1) * voxelSpacing[2]) / 2;\n        voxelCornersWorld.push(point);\n      }\n    }\n  }\n  const voxelCornersIJK = voxelCornersWorld.map(\n    (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\n  );\n  const overlapBounds = getBoundingBoxAroundShapeIJK(\n    voxelCornersIJK,\n    dimensions\n  );\n\n  return overlapBounds;\n}\n\n/**\n * Prepare a list of volume information objects for callback functions\n */\nexport function processVolumes(\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[]\n) {\n  const { spacing: segmentationSpacing } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n\n  // prepare a list of volume information objects for callback functions\n  const volumeInfoList = [];\n  let baseVolumeIdx = 0;\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n    const { imageData, spacing, dimensions } =\n      thresholdVolumeInformation[i].volume;\n\n    const volumeSize =\n      thresholdVolumeInformation[i].volume.getScalarData().length;\n    // discover the index of the volume the segmentation data is based on\n    if (\n      volumeSize === scalarData.length &&\n      equalsCheck(spacing, segmentationSpacing)\n    ) {\n      baseVolumeIdx = i;\n    }\n\n    // prepare information used in callback functions\n    const referenceValues = imageData.getPointData().getScalars().getData();\n    const lower = thresholdVolumeInformation[i].lower;\n    const upper = thresholdVolumeInformation[i].upper;\n\n    volumeInfoList.push({\n      imageData,\n      referenceValues,\n      lower,\n      upper,\n      spacing,\n      dimensions,\n      volumeSize,\n    });\n  }\n\n  return {\n    volumeInfoList,\n    baseVolumeIdx,\n  };\n}\n","import { Types } from '@cornerstonejs/core';\nimport { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { BoundsIJK } from '../../types';\nimport {\n  getVoxelOverlap,\n  processVolumes,\n  ThresholdInformation,\n} from './utilities';\n\nexport type ThresholdRangeOptions = {\n  overwrite: boolean;\n  boundsIJK: BoundsIJK;\n  overlapType?: number;\n  segmentIndex?: number;\n};\n\n/**\n * It thresholds a segmentation volume based on a set of threshold values with\n * respect to a list of volumes and respective threshold ranges.\n * @param segmentationVolume - the segmentation volume to be modified\n * @param thresholdVolumeInformation - array of objects containing volume data\n * and a range (lower and upper values) to threshold\n * @param options - the options for thresholding\n * As there is a chance the volumes might have different dimensions and spacing,\n * could be the case of no 1 to 1 mapping. So we need to work with the idea of\n * voxel overlaps (1 to many mappings). We consider all intersections valid, to\n * avoid the complexity to calculate a minimum voxel intersection percentage.\n * This function, given a voxel center and spacing, calculates the overlap of\n * the voxel with another volume and range check the voxels in the overlap.\n * Three situations can occur: all voxels pass the range check, some voxels pass\n * or none voxels pass. The overlapType parameter indicates if the user requires\n * all voxels pass (overlapType = 1) or any voxel pass (overlapType = 0)\n *\n * @returns segmented volume\n */\nfunction thresholdVolumeByRange(\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[],\n  options: ThresholdRangeOptions\n): Types.IImageVolume {\n  const { imageData: segmentationImageData } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n\n  const { overwrite, boundsIJK } = options;\n  const overlapType = options?.overlapType || 0;\n\n  // set the segmentation to all zeros\n  if (overwrite) {\n    for (let i = 0; i < scalarData.length; i++) {\n      scalarData[i] = 0;\n    }\n  }\n\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\n    segmentationVolume,\n    thresholdVolumeInformation\n  );\n\n  // global variables used in callbackOverlap function\n  let overlaps, total, range;\n\n  const testOverlapRange = (volumeInfo, voxelSpacing, voxelCenter) => {\n    /**\n     * This callback function will test all overlaps between a voxel in base\n     * volume (the reference for segmentation volume creation) and voxels in other\n     * volumes.\n     */\n    const callbackOverlap = ({ value }) => {\n      total = total + 1;\n      if (value >= range.lower && value <= range.upper) {\n        overlaps = overlaps + 1;\n      }\n    };\n\n    const { imageData, dimensions, lower, upper } = volumeInfo;\n\n    const overlapBounds = getVoxelOverlap(\n      imageData,\n      dimensions,\n      voxelSpacing,\n      voxelCenter\n    );\n\n    // reset global variables and setting the range check\n    total = 0;\n    overlaps = 0;\n    range = { lower, upper };\n\n    let overlapTest = false;\n\n    // check all voxel overlaps\n    pointInShapeCallback(imageData, () => true, callbackOverlap, overlapBounds);\n\n    if (overlapType === 0) {\n      overlapTest = overlaps > 0; // any voxel overlap is accepted\n    } else if (overlapType == 1) {\n      overlapTest = overlaps === total; // require all voxel overlaps\n    }\n    return overlapTest;\n  };\n\n  // range checks a voxel in a volume with same dimension as the segmentation\n  const testRange = (volumeInfo, pointIJK) => {\n    const { imageData, referenceValues, lower, upper } = volumeInfo;\n    const offset = imageData.computeOffsetIndex(pointIJK);\n\n    const value = referenceValues[offset];\n    if (value <= lower || value >= upper) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  /**\n   * This callback function will test all overlaps between a voxel in base\n   * volume (the reference for segmentation volume creation) and voxels in other\n   * volumes.\n   */\n  const callback = ({ index, pointIJK, pointLPS }) => {\n    let insert = volumeInfoList.length > 0;\n    for (let i = 0; i < volumeInfoList.length; i++) {\n      // if volume has the same size as segmentation volume, just range check\n      if (volumeInfoList[i].volumeSize === scalarData.length) {\n        insert = testRange(volumeInfoList[i], pointIJK);\n      } else {\n        // if not, need to calculate overlaps\n        insert = testOverlapRange(\n          volumeInfoList[i],\n          volumeInfoList[baseVolumeIdx].spacing,\n          pointLPS\n        );\n      }\n      if (!insert) {\n        break;\n      }\n    }\n\n    if (insert) {\n      scalarData[index] = options.segmentIndex || 1;\n    }\n  };\n\n  pointInShapeCallback(segmentationImageData, () => true, callback, boundsIJK);\n\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n\n  return segmentationVolume;\n}\n\nexport default thresholdVolumeByRange;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\nfunction drawHandle(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  handleGroupUID: string,\n  handle: Types.Point2,\n  options = {},\n  uniqueIndex\n): void {\n  const { color, handleRadius, width, lineWidth, fill, type, opacity } =\n    Object.assign(\n      {\n        color: 'rgb(0, 255, 0)',\n        handleRadius: '6',\n        width: '2',\n        lineWidth: undefined,\n        fill: 'transparent',\n        type: 'circle',\n        opacity: 1,\n      },\n      options\n    );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  // variable for the namespace\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(\n    annotationUID,\n    'handle',\n    `hg-${handleGroupUID}-index-${uniqueIndex}`\n  );\n\n  let attributes;\n  if (type === 'circle') {\n    attributes = {\n      cx: `${handle[0]}`,\n      cy: `${handle[1]}`,\n      r: handleRadius,\n      stroke: color,\n      fill,\n      'stroke-width': strokeWidth,\n      opacity: opacity,\n    };\n  } else if (type === 'rect') {\n    const handleRadiusFloat = parseFloat(handleRadius);\n    const side = handleRadiusFloat * 1.5;\n    const x = handle[0] - side * 0.5;\n    const y = handle[1] - side * 0.5;\n\n    attributes = {\n      x: `${x}`,\n      y: `${y}`,\n      width: `${side}`,\n      height: `${side}`,\n      stroke: color,\n      fill,\n      'stroke-width': strokeWidth,\n      rx: `${side * 0.1}`,\n      opacity: opacity,\n    };\n  } else {\n    throw new Error(`Unsupported handle type: ${type}`);\n  }\n\n  const existingHandleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  if (existingHandleElement) {\n    setAttributesIfNecessary(attributes, existingHandleElement);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newHandleElement = document.createElementNS(svgns, type);\n\n    setNewAttributesIfValid(attributes, newHandleElement);\n\n    svgDrawingHelper.appendNode(newHandleElement, svgNodeHash);\n  }\n}\n\nexport default drawHandle;\n","import type { Types } from '@cornerstonejs/core';\n\nimport { SVGDrawingHelper } from '../types';\nimport drawHandle from './drawHandle';\n\nfunction drawHandles(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  handleGroupUID: string,\n  handlePoints: Array<Types.Point2>,\n  options = {}\n): void {\n  handlePoints.forEach((handle, i) => {\n    drawHandle(\n      svgDrawingHelper,\n      annotationUID,\n      handleGroupUID,\n      handle,\n      options,\n      i\n    );\n  });\n}\n\nexport default drawHandles;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport { SVGDrawingHelper } from '../types';\n\n// <rect x=\"120\" y=\"100\" width=\"100\" height=\"100\" />\nexport default function drawRect(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  rectangleUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {},\n  dataId = ''\n): void {\n  const {\n    color,\n    width: _width,\n    lineWidth,\n    lineDash,\n  } = Object.assign(\n    {\n      color: 'rgb(0, 255, 0)',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || _width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n  const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n  const width = Math.abs(start[0] - end[0]);\n  const height = Math.abs(start[1] - end[1]);\n\n  const attributes = {\n    x: `${tlhc[0]}`,\n    y: `${tlhc[1]}`,\n    width: `${width}`,\n    height: `${height}`,\n    stroke: color,\n    fill: 'transparent',\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingRect) {\n    setAttributesIfNecessary(attributes, existingRect);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgRectElement = document.createElementNS(svgns, 'rect');\n\n    if (dataId !== '') {\n      svgRectElement.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, svgRectElement);\n\n    svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n  }\n}\n","import { vec3 } from 'gl-matrix';\nimport { CONSTANTS, metaData } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { Annotations, Annotation } from '../../types';\n\nconst { EPSILON } = CONSTANTS;\n\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\n\n/**\n * given some `Annotations`, and the slice defined by the camera's normal\n * direction and the spacing in the normal, filter the `Annotations` which\n * is within the slice.\n *\n * @param annotations - Annotations\n * @param camera - The camera\n * @param spacingInNormalDirection - The spacing in the normal direction\n * @returns The filtered `Annotations`.\n */\nexport default function filterAnnotationsWithinSlice(\n  annotations: Annotations,\n  camera: Types.ICamera,\n  spacingInNormalDirection: number\n): Annotations {\n  const { viewPlaneNormal } = camera;\n\n  // The reason we use parallel normals instead of actual orientation is that\n  // flipped action is done through camera API, so we can't rely on the\n  // orientation (viewplaneNormal and viewUp) since even the same image and\n  // same slice if flipped will have different orientation, but still rendering\n  // the same slice. Instead, we choose to use the parallel normals to filter\n  // the annotations and later we fine tune it with the annotation within slice\n  // logic down below.\n  const annotationsWithParallelNormals = annotations.filter(\n    (td: Annotation) => {\n      let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n\n      if (!annotationViewPlaneNormal) {\n        // This code is run to set the annotation view plane normal\n        // for historical data which was saved without the normal.\n        const { referencedImageId } = td.metadata;\n        const { imageOrientationPatient } = metaData.get(\n          'imagePlaneModule',\n          referencedImageId\n        );\n        const rowCosineVec = vec3.fromValues(\n          imageOrientationPatient[0],\n          imageOrientationPatient[1],\n          imageOrientationPatient[2]\n        );\n\n        const colCosineVec = vec3.fromValues(\n          imageOrientationPatient[3],\n          imageOrientationPatient[4],\n          imageOrientationPatient[5]\n        );\n\n        annotationViewPlaneNormal = vec3.create() as Types.Point3;\n\n        vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n        td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n      }\n      const isParallel =\n        Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n        PARALLEL_THRESHOLD;\n\n      return annotationViewPlaneNormal && isParallel;\n    }\n  );\n\n  // No in plane annotations.\n  if (!annotationsWithParallelNormals.length) {\n    return [];\n  }\n\n  // Annotation should be within the slice, which means that it should be between\n  // camera's focalPoint +/- spacingInNormalDirection.\n\n  const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n  const { focalPoint } = camera;\n\n  const annotationsWithinSlice = [];\n\n  for (const annotation of annotationsWithParallelNormals) {\n    const data = annotation.data;\n    const point = data.handles.points[0];\n\n    if (!annotation.isVisible) {\n      continue;\n    }\n    // A = point\n    // B = focal point\n    // P = normal\n\n    // B-A dot P  => Distance in the view direction.\n    // this should be less than half the slice distance.\n\n    const dir = vec3.create();\n\n    vec3.sub(dir, focalPoint, point);\n\n    const dot = vec3.dot(dir, viewPlaneNormal);\n\n    if (Math.abs(dot) < halfSpacingInNormalDirection) {\n      annotationsWithinSlice.push(annotation);\n    }\n  }\n\n  return annotationsWithinSlice;\n}\n","import {\n  StackViewport,\n  VolumeViewport,\n  Types,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\n\nimport filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nimport type { Annotations } from '../../types';\n\n/**\n * Given the viewport and the annotations, it filters the annotations array and only\n * return those annotation that should be displayed on the viewport\n * @param annotations - Annotations\n * @returns A filtered version of the annotations.\n */\nexport default function filterAnnotationsForDisplay(\n  viewport: Types.IViewport,\n  annotations: Annotations,\n  filterOptions: Types.ReferenceCompatibleOptions = {}\n): Annotations {\n  if (viewport instanceof VolumeViewport) {\n    const camera = viewport.getCamera();\n\n    const { spacingInNormalDirection } =\n      csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n\n    // Get data with same normal and within the same slice\n    return filterAnnotationsWithinSlice(\n      annotations,\n      camera,\n      spacingInNormalDirection\n    );\n  }\n  if (viewport instanceof StackViewport) {\n    // 1. Get the currently displayed imageId from the StackViewport\n    const imageId = viewport.getCurrentImageId();\n\n    // 2. remove the dataLoader scheme since it might be an annotation that was\n    // created on the volumeViewport initially and has the volumeLoader scheme\n    // but shares the same imageId\n    const colonIndex = imageId.indexOf(':');\n\n    filterOptions.imageURI = imageId.substring(colonIndex + 1);\n  }\n  return annotations.filter((annotation) => {\n    if (!annotation.isVisible) {\n      return false;\n    }\n    if (annotation.data.isCanvasAnnotation) {\n      return true;\n    }\n    return viewport.isReferenceViewable(annotation.metadata, filterOptions);\n  });\n}\n","import {\n  StyleConfig,\n  ToolStyleConfig,\n  StyleSpecifier,\n  AnnotationStyle,\n} from '../../../types/AnnotationStyle';\n\n/**\n * This class handles the configuration of the tool style. You can use it to set\n * the style of a tool at various levels (annotation, viewport, toolGroup, global).\n *\n * The hierarchy of the configuration is as follows (each level falls back to the\n * next level if not specified):\n *\n * 1) Annotation-level styles (with annotationUID)\n *     2) Viewport-level tool styles\n *         - Per-tool: Length on the viewport with viewportId\n *         - Global: All tools on the viewport with viewportId\n *             3) ToolGroup tool styles\n *                 - Per-tool: Angle on toolGroupId in all viewports of the toolGroup\n *                 - Global: All tools in the toolGroupId for all viewports\n *                     4) Default level:\n *                         - Per-tool: Length styles\n *                         - Global: Opinionated styles by CornerstoneJS\n */\nclass ToolStyle {\n  config: StyleConfig;\n\n  constructor() {\n    const defaultConfig = {\n      color: 'rgb(255, 255, 0)',\n      colorHighlighted: 'rgb(0, 255, 0)',\n      colorSelected: 'rgb(0, 220, 0)',\n      colorLocked: 'rgb(255, 255, 0)',\n      lineWidth: '1',\n      lineDash: '',\n      shadow: true,\n      textBoxVisibility: true,\n      textBoxFontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n      textBoxFontSize: '14px',\n      textBoxColor: 'rgb(255, 255, 0)',\n      textBoxColorHighlighted: 'rgb(0, 255, 0)',\n      textBoxColorSelected: 'rgb(0, 255, 0)',\n      textBoxColorLocked: 'rgb(255, 255, 0)',\n      textBoxBackground: '',\n      textBoxLinkLineWidth: '1',\n      textBoxLinkLineDash: '2,3',\n      textBoxShadow: true,\n    };\n\n    this._initializeConfig(defaultConfig);\n  }\n\n  /**\n   * It returns the annotation-specific tool styles for the annotation with the given UID\n   * @param annotationUID - The unique identifier of the annotation.\n   * @returns The annotation tool styles for the annotation with the given UID.\n   */\n  getAnnotationToolStyles(annotationUID: string): AnnotationStyle {\n    return this.config.annotations && this.config.annotations[annotationUID];\n  }\n\n  /**\n   * It returns the styles for a given viewport. It includes tool-specific and\n   * global styles (all tools in the viewport)\n   * @param viewportId - The id of the viewport\n   * @returns The viewport tool styles for the given viewport id.\n   */\n  getViewportToolStyles(viewportId: string): ToolStyleConfig {\n    return this.config.viewports && this.config.viewports[viewportId];\n  }\n\n  /**\n   * It returns the tool style for the given toolGroup. It includes tool-specific and\n   * global styles (all tools in the toolGroup)\n   * @param toolGroupId - The id of the toolGroup.\n   * @returns The tool styles for the tool group with the given id.\n   */\n  getToolGroupToolStyles(toolGroupId: string): ToolStyleConfig {\n    return this.config.toolGroups && this.config.toolGroups[toolGroupId];\n  }\n\n  /**\n   * It returns the default tool styles from the config file. It includes tool-specific and\n   * global styles (all tools in all tooLGroups)\n   * @returns The default tool styles.\n   */\n  getDefaultToolStyles(): ToolStyleConfig {\n    return this.config.default;\n  }\n\n  /**\n   * It takes an annotationUID and a style object and sets the styles at\n   * the annotationLevel (highest priority in the hierarchy). The styles is an\n   * object with key value pairs.\n   * @param annotationUID - string - The unique identifier for the annotation.\n   * @param styles - ToolStyles\n   */\n  setAnnotationStyles(annotationUID: string, styles: AnnotationStyle) {\n    let annotationSpecificStyles = this.config.annotations;\n\n    if (!annotationSpecificStyles) {\n      this.config = {\n        ...this.config,\n        annotations: {},\n      };\n\n      annotationSpecificStyles = this.config.annotations;\n    }\n\n    annotationSpecificStyles[annotationUID] = styles;\n  }\n\n  /**\n   * It takes a viewportId and a ToolStyles object, and adds the ToolStyles object\n   * at the viewport level (second highest priority in the hierarchy after the annotation level).\n   * @param viewportId - The id of the viewport\n   * @param styles - style object including tool-specific and/or global styles (All tools in the viewport)\n   */\n  setViewportToolStyles(viewportId: string, styles: ToolStyleConfig) {\n    let viewportSpecificStyles = this.config.viewports;\n\n    if (!viewportSpecificStyles) {\n      this.config = {\n        ...this.config,\n        viewports: {},\n      };\n\n      viewportSpecificStyles = this.config.viewports;\n    }\n\n    viewportSpecificStyles[viewportId] = styles;\n  }\n\n  /**\n   * It takes a toolGroupId and a ToolStyles object, and it adds the ToolStyles object\n   * at the toolGroup level (third highest priority in the hierarchy after the viewport level).\n   * @param toolGroupId - The id of the toolGroup\n   * @param styles - style object including tool-specific (in all viewports of the toolGroup) and/or\n   * global styles (All tools in the toolGroup for all viewports)\n   */\n  setToolGroupToolStyles(toolGroupId: string, styles: ToolStyleConfig) {\n    let toolGroupSpecificStyles = this.config.toolGroups;\n\n    if (!toolGroupSpecificStyles) {\n      this.config = {\n        ...this.config,\n        toolGroups: {},\n      };\n\n      toolGroupSpecificStyles = this.config.toolGroups;\n    }\n\n    toolGroupSpecificStyles[toolGroupId] = styles;\n  }\n\n  /**\n   * Sets the default tool styles for the editor. It overrides the default styles for all tools.\n   * @param styles - style object including tool-specific (a tool in all toolGroups) and/or\n   * global styles (All tools in all tooLGroups)\n   */\n  setDefaultToolStyles(styles: ToolStyleConfig) {\n    this.config.default = styles;\n  }\n\n  /**\n   * It returns the value for a given style key, based on the provided specifications.\n   * It starts by looking at the annotation-specific styles, then at the viewport-specific styles,\n   * then at the toolGroup-specific styles, and finally at the default styles.\n   * @param styleKey - The key of the style.\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met\n   * @returns The value for the given style key.\n   */\n  getStyleProperty(toolStyle: string, specifications: StyleSpecifier) {\n    const { annotationUID, viewportId, toolGroupId, toolName } = specifications;\n\n    return this._getToolStyle(\n      toolStyle,\n      annotationUID,\n      viewportId,\n      toolGroupId,\n      toolName\n    );\n  }\n\n  private _getToolStyle(\n    property: string,\n    annotationUID: string,\n    viewportId: string,\n    toolGroupId: string,\n    toolName: string\n  ) {\n    if (annotationUID) {\n      const annotationToolStyles = this.getAnnotationToolStyles(annotationUID);\n\n      if (annotationToolStyles) {\n        // check first in the toolSpecific styles\n        if (annotationToolStyles[property] !== undefined) {\n          return annotationToolStyles[property];\n        }\n      }\n    }\n\n    if (viewportId) {\n      const viewportToolStyles = this.getViewportToolStyles(viewportId);\n\n      if (viewportToolStyles) {\n        // check if we have the viewportId specific style\n        // check first in the toolSpecific styles\n        if (\n          viewportToolStyles[toolName] &&\n          viewportToolStyles[toolName][property] !== undefined\n        ) {\n          return viewportToolStyles[toolName][property];\n        }\n\n        // check if we have the style in the viewport specific global viewportSpecificStyles\n        if (\n          viewportToolStyles.global &&\n          viewportToolStyles.global[property] !== undefined\n        ) {\n          return viewportToolStyles.global[property];\n        }\n      }\n    }\n\n    if (toolGroupId) {\n      const toolGroupToolStyles = this.getToolGroupToolStyles(toolGroupId);\n\n      if (toolGroupToolStyles) {\n        // check first in the toolSpecific styles\n        if (\n          toolGroupToolStyles[toolName] &&\n          toolGroupToolStyles[toolName][property] !== undefined\n        ) {\n          return toolGroupToolStyles[toolName][property];\n        }\n\n        // check if we have the style in the toolGroup specific global styles\n        if (\n          toolGroupToolStyles.global &&\n          toolGroupToolStyles.global[property] !== undefined\n        ) {\n          return toolGroupToolStyles.global[property];\n        }\n      }\n    }\n\n    const globalStyles = this.getDefaultToolStyles();\n\n    if (\n      globalStyles[toolName] &&\n      globalStyles[toolName][property] !== undefined\n    ) {\n      return globalStyles[toolName][property];\n    }\n\n    if (globalStyles.global && globalStyles.global[property] !== undefined) {\n      return globalStyles.global[property];\n    }\n  }\n\n  private _initializeConfig(config) {\n    const toolStyles = {};\n    for (const name in config) {\n      toolStyles[name] = config[name];\n    }\n\n    this.config = {\n      default: {\n        global: toolStyles as AnnotationStyle,\n      },\n    };\n  }\n}\n\nconst toolStyle = new ToolStyle();\n\nexport default toolStyle;\n","import { StyleSpecifier } from '../../../types/AnnotationStyle';\nimport { ToolModes, AnnotationStyleStates } from '../../../enums';\nimport toolStyle from './ToolStyle';\n\n/**\n * Build a list of hierarchal property names in ascending order of priority\n * @param property - The base property name -- e.g., 'color'\n * @param state - An optional state to determine the final property name\n * @param mode - An optional mode to determine the final property name\n * @returns A list of property names\n */\nfunction getHierarchalPropertyStyles(\n  property: string,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string[] {\n  const list = [`${property}`];\n  if (state) {\n    list.push(`${list[0]}${state}`);\n  }\n  if (mode) {\n    list.push(`${list[list.length - 1]}${mode}`);\n  }\n  return list;\n}\n\n/**\n * Get the value of a style property from the ToolStyle config\n * @param property - The name of the property to get.\n * @param styleSpecifier - An object containing the specifications such as viewportId,\n * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n * met (hierarchy is checked from most specific to least specific which is\n * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n * @param state - The state of the tool (Default, Locked etc.)\n * @param mode - The current tool mode. (Active, Passive etc.)\n * @returns The value of the property.\n */\nfunction getStyleProperty(\n  property: string,\n  styleSpecifier: StyleSpecifier,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string {\n  // Hierarchal property styles is a list of property names with priority in ascending\n  // order like: ['color', 'colorSelected', 'colorSelectedActive'], if in the toolStyle\n  // config, the `colorSelectedActive` property is defined, it will be used, otherwise\n  // the `colorSelected` property will be used, and if that is not defined, the `color`\n  // property will be used. This is done to ensure that the most specific property is used.\n  // Thus, we attempt resolving property names in reverse order\n  const alternatives = getHierarchalPropertyStyles(property, state, mode);\n  for (let i = alternatives.length - 1; i >= 0; --i) {\n    const style = toolStyle.getStyleProperty(alternatives[i], styleSpecifier);\n    if (style !== undefined) {\n      return style;\n    }\n  }\n}\n\nexport { getStyleProperty };\n","/**\n * AnnotationStyleStates - This enum defines the 4 possible states available for\n *  a Annotation instance.\n *\n * Default:\n *   The default state for the annotation instance\n * Highlighted:\n *   The annotation should be rendered in \"highlighted\" mode in response to\n *   direct user interaction;\n * Selected:\n *   The annotation has been selected by the user;\n * Locked:\n *   The annotation has been locked;\n * AutoGenerated:\n *   The annotation has been auto generated;\n */\nenum AnnotationStyleStates {\n  Default = '',\n  Highlighted = 'Highlighted',\n  Selected = 'Selected',\n  Locked = 'Locked',\n  AutoGenerated = 'AutoGenerated',\n}\n\nexport default AnnotationStyleStates;\n","import { Annotation } from '../../../types';\nimport { isAnnotationLocked } from '../annotationLocking';\nimport { isAnnotationSelected } from '../annotationSelection';\nimport { AnnotationStyleStates } from '../../../enums';\n\n/**\n * Given a Annotation object, return the annotationStyle State that it\n * should be in based on its data.\n * The ordering of states is:\n *   * Highlighted\n *   * Selected\n *   * Locked\n *   * Autogenerated\n *   * Default\n * So the first one that applies will be returned.\n * For the autogenerated state, it depends on the autoGenerated flag on the\n * annotation, so once that is gone/false, the annotation will go to default.\n *\n * @param annotation - The annotation that we want to style.\n * @returns The state of the annotation whether it is Default, Highlighted, Locked, Selected, or AutoGenerated.\n */\nfunction getState(annotation?: Annotation): AnnotationStyleStates {\n  if (annotation) {\n    if (annotation.data && annotation.highlighted) {\n      return AnnotationStyleStates.Highlighted;\n    }\n    if (isAnnotationSelected(annotation.annotationUID)) {\n      return AnnotationStyleStates.Selected;\n    }\n\n    // Todo: make annotation lock api not to rely on the annotation itself\n    if (isAnnotationLocked(annotation)) {\n      return AnnotationStyleStates.Locked;\n    }\n\n    if (annotation.data && annotation.autoGenerated) {\n      return AnnotationStyleStates.AutoGenerated;\n    }\n  }\n\n  return AnnotationStyleStates.Default;\n}\n\nexport default getState;\n","import {\n  utilities,\n  getEnabledElement,\n  StackViewport,\n  cache,\n  VideoViewport,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport BaseTool from './BaseTool';\nimport { getAnnotationManager } from '../../stateManagement/annotation/annotationState';\nimport { Annotation, Annotations, SVGDrawingHelper } from '../../types';\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\nimport filterAnnotationsForDisplay from '../../utilities/planar/filterAnnotationsForDisplay';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nimport { getState } from '../../stateManagement/annotation/config';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**\n * Abstract class for tools which create and display annotations on the\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\n * tools that require drawing an annotation before running the segmentation strategy\n * for instance threshold segmentation based on an area and a threshold.\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\n *\n * To create a new annotation tool, derive from this class and implement the\n * abstract methods.\n */\nabstract class AnnotationDisplayTool extends BaseTool {\n  static toolName;\n\n  // ===================================================================\n  // Abstract Methods - Must be implemented.\n  // ===================================================================\n\n  /**\n   * @abstract renderAnnotation it used to draw the tool's annotation in each\n   * request animation frame\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  abstract renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  );\n\n  /**\n   * @virtual Given the element and annotations which is an array of annotation, it\n   * filters the annotations array to only include the annotation based on the viewportType.\n   * If the viewport is StackViewport, it filters based on the current imageId of the viewport,\n   * if the viewport is volumeViewport, it only returns those that are within the\n   * same slice as the current rendered slice in the volume viewport.\n   * imageId as the enabledElement.\n   * @param element - The HTML element\n   * @param annotations - The annotations to filter (array of annotation)\n   * @returns The filtered annotations\n   */\n  filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations | undefined {\n    if (!annotations || !annotations.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    return filterAnnotationsForDisplay(viewport, annotations);\n  }\n\n  /**\n   * On Image Calibration, take all the annotation from the AnnotationState manager,\n   * and invalidate them to force them to be re-rendered and their stats to be recalculated.\n   * Then use the old and new imageData (non-calibrated and calibrated) to calculate the\n   * new position for the annotations in the space of the new imageData.\n   *\n   * @param evt - The calibration event\n   *\n   */\n  public onImageSpacingCalibrated = (\n    evt: Types.EventTypes.ImageSpacingCalibratedEvent\n  ) => {\n    const { element, imageId } = evt.detail;\n\n    const imageURI = utilities.imageIdToURI(imageId);\n    const annotationManager = getAnnotationManager();\n    const framesOfReference = annotationManager.getFramesOfReference();\n\n    // For each frame Of Reference\n    framesOfReference.forEach((frameOfReference) => {\n      const frameOfReferenceSpecificAnnotations =\n        annotationManager.getAnnotations(frameOfReference);\n\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[this.getToolName()];\n\n      if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {\n        return;\n      }\n\n      // for this specific tool\n      toolSpecificAnnotations.forEach((annotation) => {\n        if (!annotation.metadata?.referencedImageId) {\n          return;\n        }\n\n        // if the annotation is drawn on the same imageId\n        const referencedImageURI = utilities.imageIdToURI(\n          annotation.metadata.referencedImageId\n        );\n\n        if (referencedImageURI === imageURI) {\n          // make them invalid since the image has been calibrated so that\n          // we can update the cachedStats and also rendering\n          annotation.invalidated = true;\n          annotation.data.cachedStats = {};\n        }\n      });\n      triggerAnnotationRender(element);\n    });\n  };\n\n  protected getReferencedImageId(\n    viewport: Types.IViewport,\n    worldPos: Types.Point3,\n    viewPlaneNormal: Types.Point3,\n    viewUp: Types.Point3\n  ): string {\n    const targetId = this.getTargetId(viewport);\n\n    let referencedImageId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    } else if (viewport instanceof VideoViewport) {\n      referencedImageId = targetId.split('videoId:')[1];\n    } else {\n      const volumeId = utilities.getVolumeId(targetId);\n      const imageVolume = cache.getVolume(volumeId);\n\n      referencedImageId = utilities.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    return referencedImageId;\n  }\n\n  /**\n   * It takes the property (color, lineDash, etc.) and based on the state of the\n   * annotation (selected, highlighted etc.) it returns the appropriate value\n   * based on the central toolStyle settings for each level of specification.\n   * @param property - The name of the style property to get.\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met (hierarchy is checked from most specific to least specific which is\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n   * @param annotation - The annotation for the tool that is\n   * currently active.\n   * @returns The value of the property.\n   */\n  public getStyle(\n    property: string,\n    specifications: StyleSpecifier,\n    annotation?: Annotation\n  ): unknown {\n    return getStyleProperty(\n      property,\n      specifications,\n      getState(annotation),\n      this.mode\n    );\n  }\n}\n\nAnnotationDisplayTool.toolName = 'AnnotationDisplayTool';\nexport default AnnotationDisplayTool;\n","import {\n  BaseVolumeViewport,\n  cache,\n  getEnabledElement,\n  metaData,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec2 } from 'gl-matrix';\n\nimport AnnotationDisplayTool from './AnnotationDisplayTool';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  Annotation,\n  Annotations,\n  EventTypes,\n  ToolHandle,\n  InteractionTypes,\n  ToolProps,\n  PublicToolProps,\n} from '../../types';\nimport { addAnnotation } from '../../stateManagement/annotation/annotationState';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\n\n/**\n * Abstract class for tools which create and display annotations on the\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\n * tools that require drawing an annotation before running the segmentation strategy\n * for instance threshold segmentation based on an area and a threshold.\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\n *\n * To create a new annotation tool, derive from this class and implement the\n * abstract methods.\n */\nabstract class AnnotationTool extends AnnotationDisplayTool {\n  /**\n   * Creates a base annotation object, adding in any annotation base data provided\n   */\n  public static createAnnotation(...annotationBaseData): Annotation {\n    let annotation: Annotation = {\n      annotationUID: null as string,\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.toolName,\n      },\n      data: {\n        text: '',\n        handles: {\n          points: new Array<Types.Point3>(),\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n      },\n    } as unknown as Annotation;\n    for (const baseData of annotationBaseData) {\n      annotation = csUtils.deepMerge(annotation, baseData);\n    }\n    return annotation;\n  }\n\n  /**\n   * Creates a new annotation for the given viewport.  This just adds the\n   * viewport reference data to the metadata, and otherwise returns the\n   * static class createAnnotation data.\n   */\n  public static createAnnotationForViewport(viewport, ...annotationBaseData) {\n    return this.createAnnotation(\n      { metadata: viewport.getViewReference() },\n      ...annotationBaseData\n    );\n  }\n\n  /**\n   * Creates and adds an annotation of the given type, firing the annotation\n   * modified event on the new annotation.\n   * This implicitly uses the static class when you call it on the correct\n   * base class.  For example, you can call the KeyImageTool.createAnnotation\n   * method on KeyImageTool.toolName by calling KeyImageTool.createAndAddAnnotation\n   *\n   */\n  public static createAndAddAnnotation(viewport, ...annotationBaseData) {\n    const annotation = this.createAnnotationForViewport(\n      viewport,\n      ...annotationBaseData\n    );\n    addAnnotation(annotation, viewport.element);\n    triggerAnnotationModified(annotation, viewport.element);\n  }\n\n  static toolName;\n  // ===================================================================\n  // Abstract Methods - Must be implemented.\n  // ===================================================================\n\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    super(toolProps, defaultToolProps);\n\n    if (toolProps.configuration?.getTextLines) {\n      this.configuration.getTextLines = toolProps.configuration.getTextLines;\n    }\n\n    if (toolProps.configuration?.statsCalculator) {\n      this.configuration.statsCalculator =\n        toolProps.configuration.statsCalculator;\n    }\n  }\n\n  /**\n   * @abstract addNewAnnotation Creates a new annotation based on the clicked mouse position\n   *\n   * @param evt - The normalized mouse event\n   * @param interactionType -  The interaction type used to add the annotation.\n   */\n  abstract addNewAnnotation(\n    evt: EventTypes.InteractionEventType,\n    interactionType: InteractionTypes\n  ): Annotation;\n\n  /**\n   * @abstract cancel Used to cancel the ongoing tool drawing and manipulation\n   *\n   */\n  abstract cancel(element: HTMLDivElement);\n\n  /**\n   * handleSelectedCallback Custom callback for when a handle is selected.\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The annotation selected.\n   * @param handle - The selected handle (either Types.Point3 in space for annotations, or TextBoxHandle object for text boxes).\n   * @param interactionType - The interaction type the handle was selected with.\n   */\n  abstract handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    handle: ToolHandle,\n    interactionType: InteractionTypes\n  ): void;\n\n  /**\n   * Custom callback for when an annotation is selected\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The `Annotation` to check.\n   * @param interactionType - The interaction type used to select the tool.\n   */\n  abstract toolSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes,\n    canvasCoords?: Types.Point2\n  ): void;\n\n  /**\n   * Returns true if the provided canvas coordinate tool is near the annotation\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinate to check\n   * @param proximity - The minimum proximity to consider the point near\n   * @param interactionType - The interaction type used to select the tool.\n   *\n   * @returns boolean if the point is near.\n   */\n  abstract isPointNearTool(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number,\n    interactionType: string\n  ): boolean;\n\n  /**\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\n   *\n   *\n   * @param evt - The normalized mouse event\n   * @param filteredAnnotations - The annotations to check for hover interactions\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\n   */\n  public mouseMoveCallback = (\n    evt: EventTypes.MouseMoveEventType,\n    filteredAnnotations?: Annotations\n  ): boolean => {\n    if (!filteredAnnotations) {\n      return false;\n    }\n\n    const { element, currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n    let annotationsNeedToBeRedrawn = false;\n\n    for (const annotation of filteredAnnotations) {\n      // Do not do anything if the annotation is locked or hidden.\n      if (\n        isAnnotationLocked(annotation) ||\n        !isAnnotationVisible(annotation.annotationUID)\n      ) {\n        continue;\n      }\n\n      const { data } = annotation;\n      const activateHandleIndex = data.handles\n        ? data.handles.activeHandleIndex\n        : undefined;\n\n      // Perform tool specific imagePointNearToolOrHandle to determine if the mouse\n      // is near the tool or its handles or its textBox.\n      const near = this._imagePointNearToolOrHandle(\n        element,\n        annotation,\n        canvasCoords,\n        6 // Todo: This should come from the state\n      );\n\n      const nearToolAndNotMarkedActive = near && !annotation.highlighted;\n      const notNearToolAndMarkedActive = !near && annotation.highlighted;\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n        annotation.highlighted = !annotation.highlighted;\n        annotationsNeedToBeRedrawn = true;\n      } else if (\n        data.handles &&\n        data.handles.activeHandleIndex !== activateHandleIndex\n      ) {\n        // Active handle index has changed, re-render.\n        annotationsNeedToBeRedrawn = true;\n      }\n    }\n\n    return annotationsNeedToBeRedrawn;\n  };\n\n  /**\n   * It checks if the mouse click is near TextBoxHandle or AnnotationHandle itself, and\n   * return either it. It prioritize TextBoxHandle over AnnotationHandle. If\n   * the mouse click is not near any of the handles, it does not return anything.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { isCanvasAnnotation } = data;\n    const { points, textBox } = data.handles;\n\n    if (textBox) {\n      const { worldBoundingBox } = textBox;\n      if (worldBoundingBox) {\n        const canvasBoundingBox = {\n          topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),\n          topRight: viewport.worldToCanvas(worldBoundingBox.topRight),\n          bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),\n          bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),\n        };\n\n        if (\n          canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&\n          canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&\n          canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&\n          canvasCoords[1] <= canvasBoundingBox.bottomRight[1]\n        ) {\n          data.handles.activeHandleIndex = null;\n          return textBox as ToolHandle;\n        }\n      }\n    }\n\n    for (let i = 0; i < points?.length; i++) {\n      const point = points[i];\n      const annotationCanvasCoordinate = isCanvasAnnotation\n        ? point.slice(0, 2)\n        : viewport.worldToCanvas(point);\n\n      const near =\n        vec2.distance(\n          canvasCoords,\n          annotationCanvasCoordinate as Types.Point2\n        ) < proximity;\n\n      if (near === true) {\n        data.handles.activeHandleIndex = i;\n        return point;\n      }\n    }\n\n    data.handles.activeHandleIndex = null;\n  }\n\n  /**\n   * It returns the style for the text box\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met (hierarchy is checked from most specific to least specific which is\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n   * @param annotation - The annotation for the tool that is\n   * currently active.\n   * @returns An object of the style settings for the text box.\n   */\n  public getLinkedTextBoxStyle(\n    specifications: StyleSpecifier,\n    annotation?: Annotation\n  ): Record<string, unknown> {\n    // Todo: this function can be used to set different styles for different toolMode\n    // for the textBox.\n\n    return {\n      visibility: this.getStyle(\n        'textBoxVisibility',\n        specifications,\n        annotation\n      ),\n      fontFamily: this.getStyle(\n        'textBoxFontFamily',\n        specifications,\n        annotation\n      ),\n      fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\n      color: this.getStyle('textBoxColor', specifications, annotation),\n      shadow: this.getStyle('textBoxShadow', specifications, annotation),\n      background: this.getStyle(\n        'textBoxBackground',\n        specifications,\n        annotation\n      ),\n      lineWidth: this.getStyle(\n        'textBoxLinkLineWidth',\n        specifications,\n        annotation\n      ),\n      lineDash: this.getStyle(\n        'textBoxLinkLineDash',\n        specifications,\n        annotation\n      ),\n    };\n  }\n\n  /**\n   * Returns true if the viewport is scaled to SUV units\n   * @param viewport - The viewport\n   * @param targetId - The annotation targetId\n   * @param imageId - The annotation imageId\n   * @returns\n   */\n  isSuvScaled(\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    targetId: string,\n    imageId?: string\n  ): boolean {\n    if (viewport instanceof BaseVolumeViewport) {\n      const volumeId = csUtils.getVolumeId(targetId);\n      const volume = cache.getVolume(volumeId);\n      return volume.scaling?.PT !== undefined;\n    }\n    const scalingModule: Types.ScalingParameters | undefined =\n      imageId && metaData.get('scalingModule', imageId);\n    return typeof scalingModule?.suvbw === 'number';\n  }\n\n  /**\n   * Get the style that will be applied to all annotations such as length, cobb\n   * angle, arrow annotate, etc. when rendered on a canvas or svg layer\n   */\n  protected getAnnotationStyle(context: {\n    annotation: Annotation;\n    styleSpecifier: StyleSpecifier;\n  }) {\n    const { annotation, styleSpecifier } = context;\n    const getStyle = (property) =>\n      this.getStyle(property, styleSpecifier, annotation);\n    const { annotationUID } = annotation;\n    const visibility = isAnnotationVisible(annotationUID);\n    const locked = isAnnotationLocked(annotation);\n\n    const lineWidth = getStyle('lineWidth') as number;\n    const lineDash = getStyle('lineDash') as string;\n    const color = getStyle('color') as string;\n    const shadow = getStyle('shadow') as boolean;\n    const textboxStyle = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n\n    return {\n      visibility,\n      locked,\n      color,\n      lineWidth,\n      lineDash,\n      lineOpacity: 1,\n      fillColor: color,\n      fillOpacity: 0,\n      shadow,\n      textbox: textboxStyle,\n    };\n  }\n\n  /**\n   * Returns true if the `canvasCoords` are near a handle or selectable part of the tool\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinates to check\n   * @param proximity - The proximity to consider\n   *\n   * @returns If the point is near.\n   */\n  private _imagePointNearToolOrHandle(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean {\n    // Based on the tool instance type, check if the point is near the tool handles\n    const handleNearImagePoint = this.getHandleNearImagePoint(\n      element,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (handleNearImagePoint) {\n      return true;\n    }\n\n    // If the point is not near the handles, check if the point is near the tool\n    const toolNewImagePoint = this.isPointNearTool(\n      element,\n      annotation,\n      canvasCoords,\n      proximity,\n      'mouse'\n    );\n\n    if (toolNewImagePoint) {\n      return true;\n    }\n  }\n}\n\nAnnotationTool.toolName = 'AnnotationTool';\nexport default AnnotationTool;\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\n\n/**\n * Draws a textBox.\n *\n * @param textLines - The text to display.\n * @param position - The x/y position of the textbox\n * @param options - Options for the textBox.\n * @returns Bounding box; can be used for isPointNearTool\n */\nfunction drawTextBox(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textUID: string,\n  textLines: Array<string>,\n  position: Types.Point2,\n  options = {}\n): SVGRect {\n  const mergedOptions = Object.assign(\n    {\n      fontFamily: 'Helvetica, Arial, sans-serif',\n      fontSize: '14px',\n      color: 'rgb(255, 255, 0)',\n      background: '',\n      padding: 25,\n      centerX: false,\n      centerY: true,\n    },\n    options\n  );\n\n  // Draw each of the text lines on top of the background box\n  const textGroupBoundingBox = _drawTextGroup(\n    svgDrawingHelper,\n    annotationUID,\n    textUID,\n    textLines,\n    position,\n    mergedOptions\n  );\n\n  return textGroupBoundingBox;\n}\n\nfunction _drawTextGroup(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textUID: string,\n  textLines: Array<string> = [''],\n  position: Types.Point2,\n  options: any\n): SVGRect {\n  const { padding, color, fontFamily, fontSize, background } = options;\n\n  let textGroupBoundingBox;\n  const [x, y] = [position[0] + padding, position[1] + padding];\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'text', textUID);\n  const existingTextGroup = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  // Todo: right now textBox gets a re-render even if the textBox has not changed\n  // and evenIf the attributes are not set again since they are the same.\n  if (existingTextGroup) {\n    // TODO: Iterate each node and update color? font-size?\n    const textElement = existingTextGroup.querySelector('text');\n    const textSpans = Array.from(textElement.children) as Array<SVGElement>;\n\n    for (let i = 0; i < textSpans.length; i++) {\n      const textSpanElement = textSpans[i];\n      const text = textLines[i] || '';\n\n      textSpanElement.textContent = text;\n    }\n\n    // if the textLines have changed size, we need to create textSpans for them\n    if (textLines.length > textSpans.length) {\n      for (let i = 0; i < textLines.length - textSpans.length; i++) {\n        const textLine = textLines[i + textSpans.length];\n        const textSpan = _createTextSpan(textLine);\n\n        textElement.appendChild(textSpan);\n      }\n\n      existingTextGroup.appendChild(textElement);\n      svgDrawingHelper.appendNode(existingTextGroup, svgNodeHash);\n    }\n\n    const textAttributes = {\n      fill: color,\n      'font-size': fontSize,\n      'font-family': fontFamily,\n    };\n\n    const textGroupAttributes = {\n      transform: `translate(${x} ${y})`,\n    };\n\n    // Todo: for some reason this does not work to not re-render the textBox\n    setAttributesIfNecessary(textAttributes, textElement);\n    setAttributesIfNecessary(textGroupAttributes, existingTextGroup);\n\n    textGroupBoundingBox = _drawTextBackground(existingTextGroup, background);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const textGroup = document.createElementNS(svgns, 'g');\n\n    textGroup.setAttribute('transform', `translate(${x} ${y})`);\n\n    //\n    const textElement = _createTextElement(svgDrawingHelper, options);\n    for (let i = 0; i < textLines.length; i++) {\n      const textLine = textLines[i];\n      const textSpan = _createTextSpan(textLine);\n\n      textElement.appendChild(textSpan);\n    }\n\n    textGroup.appendChild(textElement);\n    svgDrawingHelper.appendNode(textGroup, svgNodeHash);\n    textGroupBoundingBox = _drawTextBackground(textGroup, background);\n  }\n\n  // We translate the group using `position`\n  // which means we also need to pluck those values when returning\n  // the bounding box\n  return Object.assign({}, textGroupBoundingBox, {\n    x,\n    y,\n    height: textGroupBoundingBox.height + padding,\n    width: textGroupBoundingBox.width + padding,\n  });\n}\n\nfunction _createTextElement(\n  svgDrawingHelper: SVGDrawingHelper,\n  options: any\n): SVGElement {\n  const { color, fontFamily, fontSize } = options;\n  const svgns = 'http://www.w3.org/2000/svg';\n  const textElement = document.createElementNS(svgns, 'text');\n  const noSelectStyle =\n    'user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);';\n  const dropShadowStyle = `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`;\n  const combinedStyle = `${noSelectStyle}${dropShadowStyle}`;\n\n  // font-size=\"100\"\n  textElement.setAttribute('x', '0');\n  textElement.setAttribute('y', '0');\n  textElement.setAttribute('fill', color);\n  textElement.setAttribute('font-family', fontFamily);\n  textElement.setAttribute('font-size', fontSize);\n  textElement.setAttribute('style', combinedStyle);\n\n  return textElement;\n}\n\nfunction _createTextSpan(text): SVGElement {\n  const svgns = 'http://www.w3.org/2000/svg';\n  const textSpanElement = document.createElementNS(svgns, 'tspan');\n\n  // TODO: centerX\n  // (parent width / 2) - my width\n  // TODO: centerY\n\n  textSpanElement.setAttribute('x', '0');\n  textSpanElement.setAttribute('dy', '1.2em');\n  textSpanElement.textContent = text;\n\n  return textSpanElement;\n}\n\nfunction _drawTextBackground(group: SVGGElement, color: string) {\n  let element = group.querySelector('rect.background');\n\n  // If we have no background color, remove any element that exists and return\n  // the bounding box of the text\n  if (!color) {\n    if (element) {\n      group.removeChild(element);\n    }\n\n    return group.getBBox();\n  }\n\n  // Otherwise, check if we have a <rect> element. If not, create one\n  if (!element) {\n    element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n    element.setAttribute('class', 'background');\n    group.insertBefore(element, group.firstChild);\n  }\n\n  // Get the text groups's bounding box and use it to draw the background rectangle\n  const bBox = group.getBBox();\n\n  const attributes = {\n    x: `${bBox.x}`,\n    y: `${bBox.y}`,\n    width: `${bBox.width}`,\n    height: `${bBox.height}`,\n    fill: color,\n  };\n\n  setAttributesIfNecessary(attributes, element);\n\n  return bBox;\n}\n\nexport default drawTextBox;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\nexport default function drawLine(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  lineUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {},\n  dataId = ''\n): void {\n  // if length is NaN return\n  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n    return;\n  }\n\n  const { color, width, lineWidth, lineDash, shadow } = Object.assign(\n    {\n      color: 'rgb(0, 255, 0)',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n      shadow: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'line', lineUID);\n  const existingLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n  const dropShadowStyle = shadow\n    ? `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`\n    : '';\n\n  const attributes = {\n    x1: `${start[0]}`,\n    y1: `${start[1]}`,\n    x2: `${end[0]}`,\n    y2: `${end[1]}`,\n    stroke: color,\n    style: dropShadowStyle,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingLine) {\n    // This is run to avoid re-rendering annotations that actually haven't changed\n    setAttributesIfNecessary(attributes, existingLine);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newLine = document.createElementNS(svgns, 'line');\n\n    if (dataId !== '') {\n      newLine.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, newLine);\n\n    svgDrawingHelper.appendNode(newLine, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Find the closest point to the target point\n *\n * @param sourcePoints - The potential source points.\n * @param targetPoint - The target point, used to find the closest source.\n * @returns The closest point in the array of point sources\n */\nexport default function findClosestPoint(\n  sourcePoints: Array<Types.Point2>,\n  targetPoint: Types.Point2\n): Types.Point2 {\n  let minPoint = [0, 0];\n  let minDistance = Number.MAX_SAFE_INTEGER;\n\n  sourcePoints.forEach(function (sourcePoint) {\n    const distance = _distanceBetween(targetPoint, sourcePoint);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      minPoint = [...sourcePoint];\n    }\n  });\n\n  return minPoint as Types.Point2;\n}\n\n/**\n *\n * @private\n * @param p1\n * @param p2\n */\nfunction _distanceBetween(p1: Types.Point2, p2: Types.Point2): number {\n  const [x1, y1] = p1;\n  const [x2, y2] = p2;\n\n  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport drawLine from './drawLine';\nimport findClosestPoint from '../utilities/math/vec2/findClosestPoint';\nimport { PlanarBoundingBox, SVGDrawingHelper } from '../types';\n\n/**\n * Draw a link between an annotation to a box.\n */\nfunction drawLink(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  linkUID: string,\n  // Find closest point to approx. bounding box\n  annotationAnchorPoints: Array<Types.Point2>,\n  refPoint: Types.Point2,\n  // Find bounding box point that's closest to our identified\n  // start point\n  boundingBox: PlanarBoundingBox,\n  options = {}\n): void {\n  // The closest anchor point (for the annotation) to the\n  // text box / bounding box\n  const start =\n    annotationAnchorPoints.length > 0\n      ? findClosestPoint(annotationAnchorPoints, refPoint)\n      : refPoint;\n\n  // Calculate the midpoints of the bounding box\n  const boundingBoxPoints = _boundingBoxPoints(boundingBox);\n  // Find the closest textBox midpoint to the annotation's anchor/start point\n  const end = findClosestPoint(boundingBoxPoints, start);\n\n  // Finally we draw the dashed linking line\n  const mergedOptions = Object.assign(\n    {\n      color: 'rgb(255, 255, 0)',\n      lineWidth: '1',\n      lineDash: '2,3',\n    },\n    options\n  );\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    `link-${linkUID}`,\n    start,\n    end,\n    mergedOptions\n  );\n}\n\n/**\n * Find potential anchor points for a given bounding box. For example, it may\n * look nicer to draw a line from the \"middle left\" of a bounding box to an\n * annotation (instead of from a corner). This function calculates those points\n *\n * @param boundingBox\n */\nfunction _boundingBoxPoints(\n  boundingBox: PlanarBoundingBox\n): Array<Types.Point2> {\n  const { x: left, y: top, height, width } = boundingBox;\n  const halfWidth = width / 2;\n  const halfHeight = height / 2;\n\n  const topMiddle = [left + halfWidth, top] as Types.Point2;\n  const leftMiddle = [left, top + halfHeight] as Types.Point2;\n  const bottomMiddle = [left + halfWidth, top + height] as Types.Point2;\n  const rightMiddle = [left + width, top + halfHeight] as Types.Point2;\n\n  return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];\n}\n\nexport default drawLink;\n","import type { Types } from '@cornerstonejs/core';\n\nimport drawTextBox from './drawTextBox';\nimport drawLink from './drawLink';\nimport { SVGDrawingHelper } from '../types';\n\nfunction drawLinkedTextBox(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textBoxUID: string,\n  //\n  textLines: Array<string>,\n  textBoxPosition: Types.Point2,\n  annotationAnchorPoints: Array<Types.Point2>,\n  textBox: unknown,\n  options = {}\n  // TODO: yCenter as an option\n): SVGRect {\n  const mergedOptions = Object.assign(\n    {\n      handleRadius: '6',\n      centering: {\n        x: false,\n        y: true, // yCenter,\n      },\n    },\n    options\n  );\n\n  // Draw the text box\n  const canvasBoundingBox = drawTextBox(\n    svgDrawingHelper,\n    annotationUID,\n    textBoxUID,\n    textLines,\n    textBoxPosition,\n    mergedOptions\n  );\n  // if (textBox.hasMoved) {\n  //   // Draw dashed link line between tool and text\n  drawLink(\n    svgDrawingHelper,\n    annotationUID,\n    textBoxUID,\n    annotationAnchorPoints, // annotationAnchorPoints\n    textBoxPosition, // refPoint (text)\n    canvasBoundingBox, // textBoxBoundingBox\n    mergedOptions\n  );\n  // }\n\n  // const { top, left, width, height } = canvasBoundingBox\n\n  // textBox.worldBoundingBox = {\n  //   topLeft: canvasToWorld([left, top]),\n  //   topRight: canvasToWorld([left + width, top]),\n  //   bottomLeft: canvasToWorld([left, top + height]),\n  //   bottomRight: canvasToWorld([left + width, top + height]),\n  // }\n\n  return canvasBoundingBox;\n}\n\nexport default drawLinkedTextBox;\n","import distanceToPointSquared from './distanceToPointSquared';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the distance of a point to a line\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance\n */\nexport default function distanceToPoint(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {\n    throw Error(\n      'lineStart, lineEnd, and point should have 2 elements of [x, y]'\n    );\n  }\n\n  return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as lineSegment from '../line';\n\ntype rectLineSegments = {\n  top: Types.Point2[];\n  right: Types.Point2[];\n  bottom: Types.Point2[];\n  left: Types.Point2[];\n};\n\n/**\n * Given a rectangle left, top, width and height, return an object containing the\n * line segments that make up the rectangle's four sides\n * @param left - The x-coordinate of the left edge of the rectangle.\n * @param top - The y-coordinate of the top edge of the rectangle.\n * @param width - The width of the rectangle.\n * @param height - The height of the rectangle.\n * @returns An object with four keys, each of which contains an array of two\n * points.\n */\nfunction rectToLineSegments(\n  left: number,\n  top: number,\n  width: number,\n  height: number\n): rectLineSegments {\n  const topLineStart: Types.Point2 = [left, top];\n  const topLineEnd: Types.Point2 = [left + width, top];\n\n  const rightLineStart: Types.Point2 = [left + width, top];\n  const rightLineEnd: Types.Point2 = [left + width, top + height];\n\n  const bottomLineStart: Types.Point2 = [left + width, top + height];\n  const bottomLineEnd: Types.Point2 = [left, top + height];\n\n  const leftLineStart: Types.Point2 = [left, top + height];\n  const leftLineEnd: Types.Point2 = [left, top];\n\n  const lineSegments = {\n    top: [topLineStart, topLineEnd],\n    right: [rightLineStart, rightLineEnd],\n    bottom: [bottomLineStart, bottomLineEnd],\n    left: [leftLineStart, leftLineEnd],\n  };\n\n  return lineSegments;\n}\n\n/**\n * Calculates distance of the point to the rectangle. It calculates the minimum\n * distance between the point and each line segment of the rectangle.\n *\n * @param rect - coordinates of the rectangle [left, top, width, height]\n * @param point - [x,y] coordinates of a point\n * @returns\n */\nexport default function distanceToPoint(\n  rect: number[],\n  point: Types.Point2\n): number {\n  if (rect.length !== 4 || point.length !== 2) {\n    throw Error(\n      'rectangle:[left, top, width, height] or point: [x,y] not defined correctly'\n    );\n  }\n\n  const [left, top, width, height] = rect;\n\n  let minDistance = 655535;\n  const lineSegments = rectToLineSegments(left, top, width, height);\n\n  Object.keys(lineSegments).forEach((segment) => {\n    const [lineStart, lineEnd] = lineSegments[segment];\n    const distance = lineSegment.distanceToPoint(lineStart, lineEnd, point);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n    }\n  });\n\n  return minDistance;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Determine the coordinates that will place the textbox to the right of the\n * annotation.\n *\n * @param annotationCanvasPoints - The canvas points of the annotation's handles.\n * @returns - The coordinates for default placement of the textbox.\n */\nexport default function getTextBoxCoordsCanvas(\n  annotationCanvasPoints: Array<Types.Point2>\n): Types.Point2 {\n  const corners = _determineCorners(annotationCanvasPoints);\n  const centerY = (corners.top[1] + corners.bottom[1]) / 2;\n  const textBoxCanvas = <Types.Point2>[corners.right[0], centerY];\n\n  return textBoxCanvas;\n}\n\n/**\n * Determine the handles that have the min/max x and y values.\n *\n * @param canvasPoints - The canvas points of the annotation's handles.\n * @returns - The top, left, bottom, and right handles.\n */\nfunction _determineCorners(canvasPoints: Array<Types.Point2>) {\n  const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);\n  const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);\n  const right = handlesLeftToRight[handlesLeftToRight.length - 1];\n  const top = handlesTopToBottom[0];\n  const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];\n\n  return {\n    top,\n    bottom,\n    right,\n  };\n\n  function _compareX(a, b) {\n    return a[0] < b[0] ? -1 : 1;\n  }\n  function _compareY(a, b) {\n    return a[1] < b[1] ? -1 : 1;\n  }\n}\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Given two world positions and an orthogonal view to an `imageVolume` defined\n * by a `viewPlaneNormal` and a `viewUp`, get the width and height in world coordinates\n * of the rectangle defined by the two points. The implementation works both with orthogonal\n * non-orthogonal rectangles.\n *\n * @param viewPlaneNormal - The normal of the view.\n * @param viewUp - The up direction of the view.\n * @param imageVolume - The imageVolume to use to measure.\n * @param topLeftWorld - The first world position.\n * @param bottomRightWorld - The second world position.\n *\n * @returns The `worldWidth` and `worldHeight`.\n */\nexport default function getWorldWidthAndHeightFromCorners(\n  viewPlaneNormal: Types.Point3,\n  viewUp: Types.Point3,\n  topLeftWorld: Types.Point3,\n  bottomRightWorld: Types.Point3\n): { worldWidth: number; worldHeight: number } {\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n  const pos1 = vec3.fromValues(...topLeftWorld);\n  const pos2 = vec3.fromValues(...bottomRightWorld);\n\n  const diagonal = vec3.create();\n  vec3.subtract(diagonal, pos1, pos2);\n\n  const diagonalLength = vec3.length(diagonal);\n\n  // When the two points are very close to each other return width as 0\n  // to avoid NaN the cosTheta formula calculation\n  if (diagonalLength < 0.0001) {\n    return { worldWidth: 0, worldHeight: 0 };\n  }\n\n  const cosTheta =\n    vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n\n  const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n\n  const worldWidth = sinTheta * diagonalLength;\n  const worldHeight = cosTheta * diagonalLength;\n\n  return { worldWidth, worldHeight };\n}\n","import { metaData } from '@cornerstonejs/core';\n\ntype ModalityUnitOptions = {\n  isPreScaled: boolean;\n  isSuvScaled: boolean;\n};\n\nfunction getModalityUnit(\n  modality: string,\n  imageId: string,\n  options: ModalityUnitOptions\n): string {\n  if (modality === 'CT') {\n    return 'HU';\n  } else if (modality === 'PT') {\n    return _handlePTModality(imageId, options);\n  } else {\n    return '';\n  }\n}\n\nfunction _handlePTModality(imageId: string, options: ModalityUnitOptions) {\n  if (!options.isPreScaled) {\n    return 'raw';\n  }\n\n  if (options.isSuvScaled) {\n    return 'SUV';\n  }\n\n  const generalSeriesModule = metaData.get('generalSeriesModule', imageId);\n\n  // it might be possible that the referenceImageId is not the one\n  // that is being displayed. So we need to get the modality from imageId again\n  if (generalSeriesModule?.modality === 'PT') {\n    const petSeriesModule = metaData.get('petSeriesModule', imageId);\n    return petSeriesModule?.units || 'unitless';\n  }\n}\n\nexport { getModalityUnit, ModalityUnitOptions };\n","import {\n  cache,\n  StackViewport,\n  Types,\n  BaseVolumeViewport,\n} from '@cornerstonejs/core';\n\nfunction isViewportPreScaled(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  targetId: string\n): boolean {\n  if (viewport instanceof BaseVolumeViewport) {\n    const targetIdTokens = targetId.split('volumeId:');\n    const volumeId =\n      targetIdTokens.length > 1\n        ? targetIdTokens[1].split('?')[0]\n        : targetIdTokens[0];\n    const volume = cache.getVolume(volumeId);\n    return !!volume?.scaling && Object.keys(volume.scaling).length > 0;\n  } else if (viewport instanceof StackViewport) {\n    const { preScale } = viewport.getImageData() || {};\n    return !!preScale?.scaled;\n  } else {\n    return false;\n  }\n}\n\nexport { isViewportPreScaled };\n","import { NamedStatistics } from '../../../types';\n\nabstract class Calculator {\n  static run: ({ value }) => void;\n  /**\n   * Gets the statistics as both an array of values, as well as the named values.\n   */\n  static getStatistics: () => NamedStatistics;\n}\n\nexport default Calculator;\n","import { NamedStatistics, Statistics } from '../../../types';\nimport Calculator from './Calculator';\n\nexport default class BasicStatsCalculator extends Calculator {\n  private static max = [-Infinity];\n  private static sum = [0];\n  private static sumSquares = [0];\n  private static squaredDiffSum = [0];\n  private static count = 0;\n\n  /**\n   * This callback is used when we verify if the point is in the annotion drawn so we can get every point\n   * in the shape to calculate the statistics\n   * @param value of the point in the shape of the annotation\n   */\n  static statsCallback = ({ value: newValue }): void => {\n    if (\n      Array.isArray(newValue) &&\n      newValue.length > 1 &&\n      this.max.length === 1\n    ) {\n      this.max.push(this.max[0], this.max[0]);\n      this.sum.push(this.sum[0], this.sum[0]);\n      this.sumSquares.push(this.sumSquares[0], this.sumSquares[0]);\n      this.squaredDiffSum.push(this.squaredDiffSum[0], this.squaredDiffSum[0]);\n    }\n\n    const newArray = Array.isArray(newValue) ? newValue : [newValue];\n    this.count += 1;\n\n    this.max.forEach(\n      (it, idx) => (this.max[idx] = Math.max(it, newArray[idx]))\n    );\n    this.sum.map((it, idx) => (this.sum[idx] += newArray[idx]));\n    this.sumSquares.map(\n      (it, idx) => (this.sumSquares[idx] += newArray[idx] ** 2)\n    );\n    this.squaredDiffSum.map(\n      (it, idx) =>\n        (this.squaredDiffSum[idx] += Math.pow(\n          newArray[idx] - this.sum[idx] / this.count,\n          2\n        ))\n    );\n  };\n\n  /**\n   * Basic function that calculates statictics for a given array of points.\n   * @returns An object that contains :\n   * max : The maximum value of the array\n   * mean : mean of the array\n   * stdDev : standard deviation of the array\n   * stdDevWithSumSquare : standard deviation of the array using sum²\n   * array : An array of hte above values, in order.\n   */\n\n  static getStatistics = (): NamedStatistics => {\n    const mean = this.sum.map((sum) => sum / this.count);\n    const stdDev = this.squaredDiffSum.map((squaredDiffSum) =>\n      Math.sqrt(squaredDiffSum / this.count)\n    );\n    const stdDevWithSumSquare = this.sumSquares.map((it, idx) =>\n      Math.sqrt(this.sumSquares[idx] / this.count - mean[idx] ** 2)\n    );\n\n    const named: NamedStatistics = {\n      max: {\n        name: 'max',\n        label: 'Max Pixel',\n        value: singleArrayAsNumber(this.max),\n        unit: null,\n      },\n      mean: {\n        name: 'mean',\n        label: 'Mean Pixel',\n        value: singleArrayAsNumber(mean),\n        unit: null,\n      },\n      stdDev: {\n        name: 'stdDev',\n        label: 'Standard Deviation',\n        value: singleArrayAsNumber(stdDev),\n        unit: null,\n      },\n      stdDevWithSumSquare: {\n        name: 'stdDevWithSumSquare',\n        value: singleArrayAsNumber(stdDevWithSumSquare),\n        unit: null,\n      },\n      count: {\n        name: 'count',\n        label: 'Pixel Count',\n        value: this.count,\n        unit: null,\n      },\n      array: [],\n    };\n    named.array.push(\n      named.max,\n      named.mean,\n      named.stdDev,\n      named.stdDevWithSumSquare,\n      named.count\n    );\n\n    this.max = [-Infinity];\n    this.sum = [0];\n    this.sumSquares = [0];\n    this.squaredDiffSum = [0];\n    this.count = 0;\n\n    return named;\n  };\n}\n\nfunction singleArrayAsNumber(val: number[]) {\n  return val.length === 1 ? val[0] : val;\n}\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  ToolProps,\n  PublicToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { pointInShapeCallback } from '../../utilities/';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * RectangleROIAnnotation let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of a Rectangular region of interest.\n * You can use RectangleROIAnnotation in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. RectangleROI tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(RectangleROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(RectangleROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(RectangleROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass RectangleROITool extends AnnotationTool {\n  static toolName;\n\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a RectangleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): RectangleROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: RectangleROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasPoint1 = viewport.worldToCanvas(points[0]);\n    const canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    const rect = this._getRectangleImageCoordinates([\n      canvasPoint1,\n      canvasPoint2,\n    ]);\n\n    const point = [canvasCoords[0], canvasCoords[1]];\n    const { left, top, width, height } = rect;\n\n    const distanceToPoint = rectangle.distanceToPoint(\n      [left, top, width, height],\n      point as Types.Point2\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: RectangleROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: RectangleROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const { renderingEngine } = getEnabledElement(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - Move the text boxes world position\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - Moving tool, so move all points by the world points delta\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { points } = data.handles;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Moving handle.\n      const { currentPoints } = eventDetail;\n      const enabledElement = getEnabledElement(element);\n      const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n      const worldPos = currentPoints.world;\n\n      const { points } = data.handles;\n\n      // Move this handle.\n      points[handleIndex] = [...worldPos];\n\n      let bottomLeftCanvas;\n      let bottomRightCanvas;\n      let topLeftCanvas;\n      let topRightCanvas;\n\n      let bottomLeftWorld;\n      let bottomRightWorld;\n      let topLeftWorld;\n      let topRightWorld;\n\n      switch (handleIndex) {\n        case 0:\n        case 3:\n          // Moving bottomLeft or topRight\n\n          bottomLeftCanvas = worldToCanvas(points[0]);\n          topRightCanvas = worldToCanvas(points[3]);\n\n          bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n          topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n          bottomRightWorld = canvasToWorld(bottomRightCanvas);\n          topLeftWorld = canvasToWorld(topLeftCanvas);\n\n          points[1] = bottomRightWorld;\n          points[2] = topLeftWorld;\n\n          break;\n        case 1:\n        case 2:\n          // Moving bottomRight or topLeft\n          bottomRightCanvas = worldToCanvas(points[1]);\n          topLeftCanvas = worldToCanvas(points[2]);\n\n          bottomLeftCanvas = <Types.Point2>[\n            topLeftCanvas[0],\n            bottomRightCanvas[1],\n          ];\n          topRightCanvas = <Types.Point2>[\n            bottomRightCanvas[0],\n            topLeftCanvas[1],\n          ];\n\n          bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n          topRightWorld = canvasToWorld(topRightCanvas);\n\n          points[0] = bottomLeftWorld;\n          points[3] = topRightWorld;\n\n          break;\n      }\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Remove event handlers for the modify event loop, and enable default event propagation.\n   */\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the rectangleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as RectangleROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewPlaneNormal,\n          viewUp,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewPlaneNormal,\n          viewUp,\n          renderingEngine,\n          enabledElement\n        );\n\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related stackViewports data if\n        // they are not at the referencedImageId, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-rect`;\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _getRectangleImageCoordinates = (\n    points: Array<Types.Point2>\n  ): {\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n  } => {\n    const [point0, point1] = points;\n\n    return {\n      left: Math.min(point0[0], point1[0]),\n      top: Math.min(point0[1], point1[1]),\n      width: Math.abs(point0[0] - point1[0]),\n      height: Math.abs(point0[1] - point1[1]),\n    };\n  };\n\n  /**\n   * _calculateCachedStats - For each volume in the frame of reference that a\n   * tool instance in particular viewport defines as its target volume, find the\n   * volume coordinates (i,j,k) being probed by the two corners. One of i,j or k\n   * will be constant across the two points. In the other two directions iterate\n   * over the voxels and calculate the first and second-order statistics.\n   *\n   * @param data - The annotation tool-specific data.\n   * @param viewPlaneNormal - The normal vector of the camera.\n   * @param viewUp - The viewUp vector of the camera.\n   */\n  _calculateCachedStats = (\n    annotation,\n    viewPlaneNormal,\n    viewUp,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const { data } = annotation;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[3];\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata } = image;\n\n      const pos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      pos1Index[0] = Math.floor(pos1Index[0]);\n      pos1Index[1] = Math.floor(pos1Index[1]);\n      pos1Index[2] = Math.floor(pos1Index[2]);\n\n      const pos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      pos2Index[0] = Math.floor(pos2Index[0]);\n      pos2Index[1] = Math.floor(pos2Index[1]);\n      pos2Index[2] = Math.floor(pos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n\n        // Calculate index bounds to iterate over\n\n        const iMin = Math.min(pos1Index[0], pos2Index[0]);\n        const iMax = Math.max(pos1Index[0], pos2Index[0]);\n\n        const jMin = Math.min(pos1Index[1], pos2Index[1]);\n        const jMax = Math.max(pos1Index[1], pos2Index[1]);\n\n        const kMin = Math.min(pos1Index[2], pos2Index[2]);\n        const kMax = Math.max(pos1Index[2], pos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n\n        const handles = [pos1Index, pos2Index];\n        const { scale, areaUnits } = getCalibratedLengthUnitsAndScale(\n          image,\n          handles\n        );\n\n        const area = Math.abs(worldWidth * worldHeight) / (scale * scale);\n\n        const modalityUnitOptions = {\n          isPreScaled: isViewportPreScaled(viewport, targetId),\n\n          isSuvScaled: this.isSuvScaled(\n            viewport,\n            targetId,\n            annotation.metadata.referencedImageId\n          ),\n        };\n\n        const modalityUnit = getModalityUnit(\n          metadata.Modality,\n          annotation.metadata.referencedImageId,\n          modalityUnitOptions\n        );\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          () => true,\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        const stats = this.configuration.statsCalculator.getStatistics();\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean: stats.mean?.value,\n          stdDev: stats.stdDev?.value,\n          max: stats.max?.value,\n          statsArray: stats.array,\n          pointsInShape: pointsInShape,\n          areaUnit: areaUnits,\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n}\n\n/**\n * _getTextLines - Returns the Area, mean and std deviation of the area of the\n * target volume enclosed by the rectangle.\n *\n * @param data - The annotation tool-specific data.\n * @param targetId - The volumeId of the volume to display the stats for.\n */\nfunction defaultGetTextLines(data, targetId: string): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n\n  if (mean === undefined) {\n    return;\n  }\n\n  const textLines: string[] = [];\n\n  textLines.push(`Area: ${roundNumber(area)} ${areaUnit}`);\n  textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n\n  return textLines;\n}\n\nRectangleROITool.toolName = 'RectangleROI';\nexport default RectangleROITool;\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**\n * This tool is exactly the RectangleROITool but only draws a rectangle on the image,\n * and by using utility functions such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. This tool, however, does not calculate the statistics\n * as RectangleROITool does.\n */\nclass RectangleROIThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const targetId = this.getTargetId(viewport);\n    let referencedImageId, volumeId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    } else {\n      volumeId = csUtils.getVolumeId(targetId);\n      const imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n    // Todo: how not to store enabledElement on the annotation, segmentationModule needs the element to\n    // decide on the active segmentIndex, active segmentationIndex etc.\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n      },\n      data: {\n        label: '',\n        handles: {\n          // No need a textBox\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        segmentationId: null,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * it is used to draw the RectangleROI Threshold annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as RectangleROIThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      // Todo: This is not correct way to add the event trigger,\n      // this will trigger on all mouse hover too. Problem is that we don't\n      // have a cached stats mechanism for this tool yet?\n      triggerAnnotationModified(annotation, element);\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n}\n\nRectangleROIThresholdTool.toolName = 'RectangleROIThreshold';\nexport default RectangleROIThresholdTool;\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  metaData,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport throttle from '../../utilities/throttle';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted } from '../../stateManagement/annotation/helpers/state';\n\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIStartEndThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { pointInShapeCallback } from '../../utilities/';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * This tool is similar to the RectangleROIThresholdTool which\n * only draws a rectangle on the image, and by using utility functions\n * such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. The only difference is that it only acts on the\n * acquisition plane and not the 3D volume, and accepts a start and end\n * slice, and renders a dashed rectangle on the image between the start and end\n * but a solid rectangle on start and end slice. Utility functions should be used\n * to modify the start and end slice.\n * // Todo: right now only the first slice has grabbable handles, need to make\n * // it so that the handles are grabbable on all slices.\n */\nclass RectangleROIStartEndThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        numSlicesToPropagate: 10,\n        computePointsInsideVolume: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStatsTool,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    let referencedImageId, imageVolume, volumeId;\n    if (viewport instanceof StackViewport) {\n      throw new Error('Stack Viewport Not implemented');\n    } else {\n      const targetId = this.getTargetId(viewport);\n      volumeId = csUtils.getVolumeId(targetId);\n      imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    if (!referencedImageId) {\n      throw new Error('This tool does not work on non-acquisition planes');\n    }\n\n    const startIndex = viewport.getCurrentImageIdIndex();\n    const spacingInNormal = csUtils.getSpacingInNormalDirection(\n      imageVolume,\n      viewPlaneNormal\n    );\n\n    // We cannot simply add numSlicesToPropagate to startIndex because\n    // the order of imageIds can be from top to bottom or bottom to top and\n    // we want to make sure it is always propagated in the direction of the\n    // view and also to make sure we don't go out of bounds.\n    const endIndex = this._getEndSliceIndex(\n      imageVolume,\n      worldPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n        spacingInNormal,\n      },\n      data: {\n        label: '',\n        startSlice: startIndex,\n        endSlice: endIndex,\n        cachedStats: {\n          pointsInVolume: [],\n          projectionPoints: [],\n          projectionPointsImageIds: [referencedImageId],\n        },\n        handles: {\n          // No need a textBox\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        labelmapUID: null,\n      },\n    };\n\n    // update the projection points in 3D space, since we are projecting\n    // the points to the slice plane, we need to make sure the points are\n    // computed for later export\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    const targetId = this.getTargetId(enabledElement.viewport);\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n\n    if (this.configuration.calculatePointsInsideVolume) {\n      this._computePointsInsideVolume(annotation, imageVolume, enabledElement);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      enabledElement.renderingEngine,\n      viewportIdsToRender\n    );\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  // Todo: make it work for planes other than acquisition planes\n  _computeProjectionPoints(\n    annotation: RectangleROIStartEndThresholdAnnotation,\n    imageVolume: Types.IImageVolume\n  ): void {\n    const { data, metadata } = annotation;\n    const { viewPlaneNormal, spacingInNormal } = metadata;\n    const { imageData } = imageVolume;\n    const { startSlice, endSlice } = data;\n    const { points } = data.handles;\n\n    const startIJK = transformWorldToIndex(imageData, points[0]);\n\n    if (startIJK[2] !== startSlice) {\n      throw new Error('Start slice does not match');\n    }\n\n    // substitute the end slice index 2 with startIJK index 2\n    const endIJK = vec3.fromValues(startIJK[0], startIJK[1], endSlice);\n\n    const startWorld = vec3.create();\n    imageData.indexToWorldVec3(startIJK, startWorld);\n\n    const endWorld = vec3.create();\n    imageData.indexToWorldVec3(endIJK, endWorld);\n\n    // distance between start and end slice in the world coordinate\n    const distance = vec3.distance(startWorld, endWorld);\n\n    // for each point inside points, navigate in the direction of the viewPlaneNormal\n    // with amount of spacingInNormal, and calculate the next slice until we reach the distance\n    const newProjectionPoints = [];\n    for (let dist = 0; dist < distance; dist += spacingInNormal) {\n      newProjectionPoints.push(\n        points.map((point) => {\n          const newPoint = vec3.create();\n          vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\n          return Array.from(newPoint);\n        })\n      );\n    }\n\n    data.cachedStats.projectionPoints = newProjectionPoints;\n\n    // Find the imageIds for the projection points\n    const projectionPointsImageIds = [];\n    for (const RectanglePoints of newProjectionPoints) {\n      const imageId = csUtils.getClosestImageId(\n        imageVolume,\n        RectanglePoints[0],\n        viewPlaneNormal\n      );\n      projectionPointsImageIds.push(imageId);\n    }\n\n    data.cachedStats.projectionPointsImageIds = projectionPointsImageIds;\n  }\n\n  //This function return all the points inside the ROI for every slices between startSlice and endSlice\n  _computePointsInsideVolume(annotation, imageVolume, enabledElement) {\n    const { data } = annotation;\n    const projectionPoints = data.cachedStats.projectionPoints;\n\n    const pointsInsideVolume: Types.Point3[][] = [[]];\n\n    for (let i = 0; i < projectionPoints.length; i++) {\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!imageVolume) {\n        continue;\n      }\n\n      const projectionPoint = projectionPoints[i][0];\n\n      const worldPos1 = data.handles.points[0];\n      const worldPos2 = data.handles.points[3];\n\n      const { dimensions, imageData } = imageVolume;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n      //We only need to change the Z of our bounds so we are getting the Z from the current projection point\n      const worldProjectionPointIndex = transformWorldToIndex(\n        imageData,\n        projectionPoint\n      );\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldProjectionPointIndex[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldProjectionPointIndex[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          () => true,\n          null,\n          boundsIJK\n        );\n\n        //@ts-ignore\n        pointsInsideVolume.push(pointsInShape);\n      }\n    }\n    data.cachedStats.pointsInVolume = pointsInsideVolume;\n  }\n\n  _calculateCachedStatsTool(annotation, enabledElement) {\n    const data = annotation.data;\n    const { viewport } = enabledElement;\n\n    const { cachedStats } = data;\n    const targetId = this.getTargetId(viewport);\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n\n    // Todo: this shouldn't be here, this is a performance issue\n    // Since we are extending the RectangleROI class, we need to\n    // bring the logic for handle to some cachedStats calculation\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, viewport.element);\n\n    return cachedStats;\n  }\n\n  /**\n   * it is used to draw the rectangleROIStartEnd annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const sliceIndex = viewport.getCurrentImageIdIndex();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[\n        i\n      ] as RectangleROIStartEndThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { startSlice, endSlice } = data;\n      const { points, activeHandleIndex } = data.handles;\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      // range of slices to render based on the start and end slice, like\n      // np.arange\n\n      // if indexIJK is outside the start/end slice, we don't render\n      if (\n        sliceIndex < Math.min(startSlice, endSlice) ||\n        sliceIndex > Math.max(startSlice, endSlice)\n      ) {\n        continue;\n      }\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n\n      if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(annotation, enabledElement);\n      }\n\n      // if it is inside the start/end slice, but not exactly the first or\n      // last slice, we render the line in dash, but not the handles\n      let firstOrLastSlice = false;\n      if (sliceIndex === startSlice || sliceIndex === endSlice) {\n        firstOrLastSlice = true;\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null &&\n        firstOrLastSlice\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      let lineDashToUse = lineDash;\n\n      if (!firstOrLastSlice) {\n        lineDashToUse = 2;\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash: lineDashToUse,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  _getEndSliceIndex(\n    imageVolume: Types.IImageVolume,\n    worldPos: Types.Point3,\n    spacingInNormal: number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n\n    // get end position by moving from worldPos in the direction of viewplaneNormal\n    // with amount of numSlicesToPropagate * spacingInNormal\n    const endPos = vec3.create();\n    vec3.scaleAndAdd(\n      endPos,\n      worldPos,\n      viewPlaneNormal,\n      numSlicesToPropagate * spacingInNormal\n    );\n\n    const halfSpacingInNormalDirection = spacingInNormal / 2;\n    // Loop through imageIds of the imageVolume and find the one that is closest to endPos\n    const { imageIds } = imageVolume;\n    let imageIdIndex;\n    for (let i = 0; i < imageIds.length; i++) {\n      const imageId = imageIds[i];\n\n      const { imagePositionPatient } = metaData.get(\n        'imagePlaneModule',\n        imageId\n      );\n\n      const dir = vec3.create();\n      vec3.sub(dir, endPos, imagePositionPatient);\n\n      const dot = vec3.dot(dir, viewPlaneNormal);\n\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\n        imageIdIndex = i;\n      }\n    }\n\n    return imageIdIndex;\n  }\n}\n\nRectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';\nexport default RectangleROIStartEndThresholdTool;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Uses the current bounds of the 2D rectangle and extends it in the view axis by numSlices\n * It compares min and max of each IJK to find the view axis (for axial, zMin === zMax) and\n * then calculates the extended range. It will assume the slice is relative to the\n * current slice and will add the given slices to the current max of the boundingBox.\n * @param boundsIJK - [[iMin, iMax], [jMin, jMax], [kMin, kMax]]\n * @param slices - number of slices to project before and after\n * @returns extended bounds\n */\nfunction extend2DBoundingBoxInViewAxis(\n  boundsIJK: [Types.Point2, Types.Point2, Types.Point2],\n  numSlicesToProject: number\n): [Types.Point2, Types.Point2, Types.Point2] {\n  // find which index in boundsIJK has the same first and last value\n  const sliceNormalIndex = boundsIJK.findIndex(([min, max]) => min === max);\n\n  if (sliceNormalIndex === -1) {\n    throw new Error('3D bounding boxes not supported in an oblique plane');\n  }\n\n  // get the index and subtract slices from the min and add to the max\n  boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;\n  boundsIJK[sliceNormalIndex][1] += numSlicesToProject;\n  return boundsIJK;\n}\n\nexport default extend2DBoundingBoxInViewAxis;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\nimport extend2DBoundingBoxInViewAxis from '../boundingBox/extend2DBoundingBoxInViewAxis';\n\ntype Options = {\n  numSlicesToProject?: number;\n};\n\nfunction getBoundsIJKFromRectangleAnnotations(\n  annotations,\n  referenceVolume,\n  options = {} as Options\n) {\n  const AllBoundsIJK = [];\n  annotations.forEach((annotation) => {\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const { imageData, dimensions } = referenceVolume;\n\n    let pointsToUse = points;\n    // If the tool is a 2D tool but has projection points, use them\n    if (data.cachedStats?.projectionPoints) {\n      const { projectionPoints } = data.cachedStats;\n      pointsToUse = [].concat(...projectionPoints); // cannot use flat() because of typescript compiler right now\n    }\n\n    const rectangleCornersIJK = pointsToUse.map(\n      (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\n    );\n    let boundsIJK = getBoundingBoxAroundShapeIJK(\n      rectangleCornersIJK,\n      dimensions\n    );\n\n    // If the tool is 2D but it is configured to project to X amount of slices\n    // Don't project the slices if projectionPoints have been used to define the extents\n    if (options.numSlicesToProject && !data.cachedStats?.projectionPoints) {\n      boundsIJK = extend2DBoundingBoxInViewAxis(\n        boundsIJK,\n        options.numSlicesToProject\n      );\n    }\n\n    AllBoundsIJK.push(boundsIJK);\n  });\n\n  if (AllBoundsIJK.length === 1) {\n    return AllBoundsIJK[0];\n  }\n\n  // Get the intersection of all the bounding boxes\n  // This is the bounding box that contains all the ROIs\n  const boundsIJK = AllBoundsIJK.reduce(\n    (accumulator, currentValue) => {\n      return {\n        iMin: Math.min(accumulator.iMin, currentValue.iMin),\n        jMin: Math.min(accumulator.jMin, currentValue.jMin),\n        kMin: Math.min(accumulator.kMin, currentValue.kMin),\n        iMax: Math.max(accumulator.iMax, currentValue.iMax),\n        jMax: Math.max(accumulator.jMax, currentValue.jMax),\n        kMax: Math.max(accumulator.kMax, currentValue.kMax),\n      };\n    },\n    {\n      iMin: Infinity,\n      jMin: Infinity,\n      kMin: Infinity,\n      iMax: -Infinity,\n      jMax: -Infinity,\n      kMax: -Infinity,\n    }\n  );\n\n  return boundsIJK;\n}\n\nexport default getBoundsIJKFromRectangleAnnotations;\n","import type { Types } from '@cornerstonejs/core';\nimport { state } from '../../stateManagement/annotation';\nimport {\n  RectangleROIStartEndThresholdTool,\n  RectangleROIThresholdTool,\n} from '../../tools';\n\nimport thresholdVolumeByRange from './thresholdVolumeByRange';\nimport getBoundsIJKFromRectangleAnnotations from '../rectangleROITool/getBoundsIJKFromRectangleAnnotations';\nimport { ThresholdInformation } from './utilities';\n\nexport type ThresholdOptions = {\n  numSlicesToProject?: number; // number of slices to project before and after current slice\n  overwrite: boolean;\n  overlapType?: number; // type of the voxel overlap\n  segmentIndex?: number; // segment index to threshold\n};\n\nexport type AnnotationForThresholding = {\n  data: {\n    handles: {\n      points: Types.Point3[];\n    };\n    cachedStats?: {\n      projectionPoints?: Types.Point3[][];\n    };\n  };\n};\n\n/**\n * It uses the provided rectangleROI annotations (either RectangleROIThreshold, or\n * RectangleROIStartEndThreshold) to compute an ROI that is the intersection of\n * all the annotations. Then it uses the rectangleROIThreshold utility to threshold\n * the volume.\n * @param annotationUIDs - rectangleROI annotationsUIDs to use for ROI\n * @param segmentationVolume - the segmentation volume\n * @param thresholdVolumeInformation - object array containing the volume data and range threshold values\n * @param options - options for thresholding\n * @returns\n */\nfunction rectangleROIThresholdVolumeByRange(\n  annotationUIDs: string[],\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[],\n  options: ThresholdOptions\n): Types.IImageVolume {\n  const annotations = annotationUIDs.map((annotationUID) => {\n    return state.getAnnotation(annotationUID);\n  });\n\n  _validateAnnotations(annotations);\n\n  let boundsIJK;\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n    // make sure that the boundsIJK are generated by the correct volume\n    const volumeSize =\n      thresholdVolumeInformation[i].volume.getScalarData().length;\n    if (volumeSize === segmentationVolume.getScalarData().length || i === 0) {\n      boundsIJK = getBoundsIJKFromRectangleAnnotations(\n        annotations,\n        thresholdVolumeInformation[i].volume,\n        options\n      );\n    }\n  }\n\n  const outputSegmentationVolume = thresholdVolumeByRange(\n    segmentationVolume,\n    thresholdVolumeInformation,\n    { ...options, boundsIJK }\n  );\n\n  outputSegmentationVolume.modified();\n\n  return outputSegmentationVolume;\n}\n\nfunction _validateAnnotations(annotations) {\n  const validToolNames = [\n    RectangleROIThresholdTool.toolName,\n    RectangleROIStartEndThresholdTool.toolName,\n  ];\n\n  for (const annotation of annotations) {\n    const name = annotation.metadata.toolName;\n    if (!validToolNames.includes(name)) {\n      throw new Error(\n        'rectangleROIThresholdVolumeByRange only supports RectangleROIThreshold and RectangleROIStartEndThreshold annotations'\n      );\n    }\n  }\n}\n\nexport default rectangleROIThresholdVolumeByRange;\n","import { Types } from '@cornerstonejs/core';\nimport { volumeLoader, utilities as csUtils } from '@cornerstonejs/core';\n\n/**\n * Given a list of labelmaps (with the possibility of overlapping regions), and\n * a segmentIndex it creates a new labelmap with the same dimensions as the input labelmaps,\n * but merges them into a single labelmap for the segmentIndex. It wipes out\n * all other segment Indices. This is useful for calculating statistics regarding\n * a specific segment when there are overlapping regions between labelmap (e.g. TMTV)\n *\n * @param labelmaps - Array of labelmaps\n * @param segmentIndex - The segment index to merge\n * @returns Merged labelmap\n */\nfunction createMergedLabelmapForIndex(\n  labelmaps: Array<Types.IImageVolume>,\n  segmentIndex = 1,\n  volumeId = 'mergedLabelmap'\n): Types.IImageVolume {\n  labelmaps.forEach(({ direction, dimensions, origin, spacing }) => {\n    if (\n      !csUtils.isEqual(dimensions, labelmaps[0].dimensions) ||\n      !csUtils.isEqual(direction, labelmaps[0].direction) ||\n      !csUtils.isEqual(spacing, labelmaps[0].spacing) ||\n      !csUtils.isEqual(origin, labelmaps[0].origin)\n    ) {\n      throw new Error('labelmaps must have the same size and shape');\n    }\n  });\n\n  const labelmap = labelmaps[0];\n\n  const arrayType = (labelmap.getScalarData() as any).constructor;\n  const outputData = new arrayType(labelmap.getScalarData().length);\n\n  labelmaps.forEach((labelmap) => {\n    const scalarData = labelmap.getScalarData();\n    for (let i = 0; i < scalarData.length; i++) {\n      if (scalarData[i] === segmentIndex) {\n        outputData[i] = segmentIndex;\n      }\n    }\n  });\n\n  const options = {\n    scalarData: outputData,\n    metadata: labelmap.metadata,\n    spacing: labelmap.spacing,\n    origin: labelmap.origin,\n    direction: labelmap.direction,\n    dimensions: labelmap.dimensions,\n  };\n\n  const preventCache = true;\n  // Todo: following should be async\n  const mergedVolume = volumeLoader.createLocalVolume(\n    options,\n    volumeId,\n    preventCache\n  );\n\n  return mergedVolume;\n}\n\nexport default createMergedLabelmapForIndex;\n","import { isValidLabelmapConfig } from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nimport { RepresentationConfig } from '../../types/SegmentationStateTypes';\n\n/**\n * Given a representation type and a configuration, return true if the\n * configuration is valid for that representation type\n * @param representationType - The type of segmentation representation\n * @param config - RepresentationConfig\n * @returns A boolean value.\n */\nexport default function isValidRepresentationConfig(\n  representationType: string,\n  config: RepresentationConfig\n): boolean {\n  switch (representationType) {\n    case SegmentationRepresentation.Labelmap:\n      return isValidLabelmapConfig(config);\n    default:\n      throw new Error(`Unknown representation type: ${representationType}`);\n  }\n}\n","import getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nimport { Segmentation } from '../../types/SegmentationStateTypes';\n\n/**\n * It returns a configuration object for the given representation type.\n * @param representationType - The type of segmentation representation\n * @returns A representation configuration object.\n */\nexport default function getDefaultRepresentationConfig(\n  segmentation: Segmentation\n) {\n  const { type: representationType } = segmentation;\n  switch (representationType) {\n    case SegmentationRepresentation.Labelmap:\n      return getDefaultLabelmapConfig();\n    default:\n      throw new Error(`Unknown representation type: ${representationType}`);\n  }\n}\n","import cloneDeep from 'lodash.clonedeep';\nimport {\n  getEnabledElementByIds,\n  volumeLoader,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Create a new 3D segmentation volume from the default imageData presented in\n * the first actor of the viewport. It looks at the metadata of the imageData\n * to determine the volume dimensions and spacing if particular options are not provided.\n *\n * @param viewportId - The Id of the viewport from which to derive the volume from.\n * @param renderingEngineId - The Id of the rendering engine the viewport belongs to.\n * @param [segmentationId] - The Id to name the generated segmentation. Autogenerated if not given.\n * @param [options] - LabelmapOptions\n * @returns A promise that resolves to the Id of the new labelmap volume.\n */\nexport default async function createLabelmapVolumeForViewport(input: {\n  viewportId: string;\n  renderingEngineId: string;\n  segmentationId?: string;\n  options?: {\n    volumeId: string;\n    scalarData: Float32Array | Uint8Array | Uint16Array | Int16Array;\n    targetBuffer: {\n      type: 'Float32Array' | 'Uint8Array' | 'Uint16Array' | 'Int8Array';\n    };\n    metadata: Types.Metadata;\n    dimensions: Types.Point3;\n    spacing: Types.Point3;\n    origin: Types.Point3;\n    direction: Types.Mat3;\n  };\n}): Promise<string> {\n  const { viewportId, renderingEngineId, options } = input;\n  let { segmentationId } = input;\n  const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n\n  if (!enabledElement) {\n    throw new Error('element disabled');\n  }\n\n  const { viewport } = enabledElement;\n  if (!(viewport instanceof VolumeViewport)) {\n    throw new Error('Segmentation only supports VolumeViewport');\n  }\n\n  const { uid } = viewport.getDefaultActor();\n\n  if (segmentationId === undefined) {\n    // Name the segmentation volume with the viewport Id\n    segmentationId = `${uid}-based-segmentation-${\n      options?.volumeId ?? csUtils.uuidv4().slice(0, 8)\n    }`;\n  }\n\n  if (options) {\n    // create a new labelmap with its own properties\n    // This allows creation of a higher resolution labelmap vs reference volume\n    const properties = cloneDeep(options);\n    await volumeLoader.createLocalVolume(properties, segmentationId);\n  } else {\n    // create a labelmap from a reference volume\n    const { uid: volumeId } = viewport.getDefaultActor();\n    await volumeLoader.createAndCacheDerivedSegmentationVolume(volumeId, {\n      volumeId: segmentationId,\n    });\n  }\n\n  return segmentationId;\n}\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getBrushToolInstances } from './utilities';\n\n/**\n * Sets the brush size for all brush-based tools in a given tool group.\n * @param toolGroupId - The ID of the tool group to set the brush size for.\n * @param brushSize - The new brush size to set.\n * @param toolName - The name of the specific tool to set the brush size for (optional)\n * If not provided, all brush-based tools in the tool group will be affected.\n */\nexport function setBrushSizeForToolGroup(\n  toolGroupId: string,\n  brushSize: number,\n  toolName?: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n\n  brushBasedToolInstances.forEach((tool: BrushTool) => {\n    tool.configuration.brushSize = brushSize;\n\n    // Invalidate the brush being rendered so it can update.\n    tool.invalidateBrushCursor();\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  const viewportsInfoArray = Object.keys(viewportsInfo).map(\n    (key) => viewportsInfo[key]\n  );\n\n  if (!viewportsInfoArray.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfoArray[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n\n/**\n * Gets the brush size for the first brush-based tool instance in a given tool group.\n * @param toolGroupId - The ID of the tool group to get the brush size for.\n * @param toolName - The name of the specific tool to get the brush size for (Optional)\n * If not provided, the first brush-based tool instance in the tool group will be used.\n * @returns The brush size of the selected tool instance, or undefined if no brush-based tool instance is found.\n */\nexport function getBrushSizeForToolGroup(\n  toolGroupId: string,\n  toolName?: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n\n  // one is enough as they share the same brush size\n  const brushToolInstance = brushBasedToolInstances[0];\n\n  if (!brushToolInstance) {\n    return;\n  }\n\n  // TODO -> Assumes the brush sizes are the same and set via these helpers.\n  return brushToolInstance.configuration.brushSize;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getBrushToolInstances } from './utilities';\n\nexport function setBrushThresholdForToolGroup(\n  toolGroupId: string,\n  threshold: Types.Point2,\n  otherArgs: Record<string, unknown> = { isDynamic: false }\n) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n  const configuration = {\n    ...otherArgs,\n    ...(threshold !== undefined && { threshold }),\n  };\n\n  brushBasedToolInstances.forEach((tool) => {\n    tool.configuration.strategySpecificConfiguration.THRESHOLD = {\n      ...tool.configuration.strategySpecificConfiguration.THRESHOLD,\n      ...configuration,\n    };\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  if (!viewportsInfo.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfo[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n\nexport function getBrushThresholdForToolGroup(toolGroupId: string) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n  const brushToolInstance = brushBasedToolInstances[0];\n\n  if (!brushToolInstance) {\n    return;\n  }\n\n  // TODO -> Assumes the\n  return brushToolInstance.configuration.strategySpecificConfiguration.THRESHOLD\n    .threshold;\n}\n","import { Types } from '@cornerstonejs/core';\nimport { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport {\n  getVoxelOverlap,\n  processVolumes,\n  ThresholdInformation,\n} from './utilities';\n\n/**\n * It thresholds a segmentation volume based on a set of threshold values with\n * respect to a list of volumes and respective threshold ranges.\n * @param segmentationVolume - the segmentation volume to be modified\n * @param segmentationIndex - the index of the segmentation to modify\n * @param thresholdVolumeInformation - array of objects containing volume data\n * and a range (lower and upper values) to threshold\n * @param overlapType - indicates if the user requires all voxels pass\n * (overlapType = 1) or any voxel pass (overlapType = 0)\n * @returns\n */\nfunction thresholdSegmentationByRange(\n  segmentationVolume: Types.IImageVolume,\n  segmentationIndex: number,\n  thresholdVolumeInformation: ThresholdInformation[],\n  overlapType: number\n): Types.IImageVolume {\n  const scalarData = segmentationVolume.getScalarData();\n\n  // prepare a list of volume information objects for callback functions\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\n    segmentationVolume,\n    thresholdVolumeInformation\n  );\n\n  /**\n   * This function will test all overlaps between a voxel in base volume\n   * (the reference for segmentation volume creation) and voxels in other\n   * volumes.\n   * If the segmentation volume and the image volume are the same size,\n   * checks if the scalar data at each point is within the threshold values.\n   * If the segmentation volume and the image volume are different sizes,\n   * checks the voxel overlap\n   */\n  volumeInfoList.forEach((volumeInfo) => {\n    const { volumeSize } = volumeInfo;\n\n    if (volumeSize === scalarData.length) {\n      _handleSameSizeVolume(scalarData, segmentationIndex, volumeInfo);\n    } else {\n      _handleDifferentSizeVolume(\n        scalarData,\n        segmentationIndex,\n        volumeInfo,\n        volumeInfoList,\n        baseVolumeIdx,\n        overlapType\n      );\n    }\n  });\n\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n\n  return segmentationVolume;\n}\n\nfunction _handleDifferentSizeVolume(\n  scalarData: Types.PixelDataTypedArray,\n  segmentationIndex: number,\n  volumeInfo: any,\n  volumeInfoList: any,\n  baseVolumeIdx: number,\n  overlapType: number\n) {\n  const { imageData, lower, upper, dimensions } = volumeInfo;\n\n  let total, overlaps, range;\n\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const overlapBounds = getVoxelOverlap(\n        imageData,\n        dimensions,\n        volumeInfoList[baseVolumeIdx].spacing,\n        volumeInfoList[baseVolumeIdx].imageData.getPoint(i)\n      );\n\n      const callbackOverlap = ({ value }) => {\n        total = total + 1;\n        if (value >= range.lower && value <= range.upper) {\n          overlaps = overlaps + 1;\n        }\n      };\n\n      total = 0;\n      overlaps = 0;\n      range = { lower, upper };\n      let overlapTest = false;\n\n      // check all voxel overlaps\n      pointInShapeCallback(\n        imageData,\n        () => true,\n        callbackOverlap,\n        overlapBounds\n      );\n\n      overlapTest = overlapType === 0 ? overlaps > 0 : overlaps === total;\n      scalarData[i] = overlapTest ? segmentationIndex : 0;\n    }\n  }\n  return { total, range, overlaps };\n}\n\nfunction _handleSameSizeVolume(\n  scalarData: Types.PixelDataTypedArray,\n  segmentationIndex: number,\n  volumeInfo: any\n) {\n  const { referenceValues, lower, upper } = volumeInfo;\n\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const value = referenceValues[i];\n      scalarData[i] = value >= lower && value <= upper ? segmentationIndex : 0;\n    }\n  }\n}\n\nexport default thresholdSegmentationByRange;\n","import type { Types } from '@cornerstonejs/core';\nimport { cache } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\n/**\n * Determines if there is a point between point1 and point2 which is not\n * contained in the segmentation\n */\nexport default function isLineInSegment(\n  point1: Types.Point3,\n  point2: Types.Point3,\n  isInSegment\n) {\n  const ijk1 = isInSegment.toIJK(point1);\n  const ijk2 = isInSegment.toIJK(point2);\n  const testPoint = vec3.create();\n  const { testIJK } = isInSegment;\n  const delta = vec3.sub(vec3.create(), ijk1, ijk2);\n\n  // Test once for index value between the two points, so the max of the\n  // difference in IJK values\n  const testSize = Math.round(Math.max(...delta.map(Math.abs)));\n  if (testSize < 2) {\n    // No need to test when there are only two points\n    return true;\n  }\n  const unitDelta = vec3.scale(vec3.create(), delta, 1 / testSize);\n\n  for (let i = 1; i < testSize; i++) {\n    vec3.scaleAndAdd(testPoint, ijk2, unitDelta, i);\n    if (!testIJK(testPoint)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Creates a function that tests to see if the provided line segment, specified\n * in LPS space (as endpoints) is contained in the segment\n */\nfunction createIsInSegment(\n  segVolumeId: string,\n  segmentIndex: number,\n  containedSegmentIndices?: Set<number>\n) {\n  // Get segmentation volume\n  const vol = cache.getVolume(segVolumeId);\n  if (!vol) {\n    console.warn(`No volume found for ${segVolumeId}`);\n    return;\n  }\n\n  const segData = vol.imageData.getPointData().getScalars().getData();\n  const width = vol.dimensions[0];\n  const pixelsPerSlice = width * vol.dimensions[1];\n\n  return {\n    /**\n     * Find the center point between point1 and point2, convert it to IJK space\n     * and test if the value at that location is in the segment\n     */\n    testCenter: (point1, point2) => {\n      const point = vec3.add(vec3.create(), point1, point2).map((it) => it / 2);\n      const ijk = vol.imageData.worldToIndex(point as vec3).map(Math.round);\n      const [i, j, k] = ijk;\n      const index = i + j * width + k * pixelsPerSlice;\n      const value = segData[index];\n      return value === segmentIndex || containedSegmentIndices?.has(value);\n    },\n\n    toIJK: (point) => vol.imageData.worldToIndex(point as vec3),\n\n    testIJK: (ijk) => {\n      const [i, j, k] = ijk;\n      const index =\n        Math.round(i) + Math.round(j) * width + Math.round(k) * pixelsPerSlice;\n      const value = segData[index];\n      return value === segmentIndex || containedSegmentIndices?.has(value);\n    },\n  };\n}\n\nexport { createIsInSegment, isLineInSegment };\n","import { vec3 } from 'gl-matrix';\n\nimport { createIsInSegment, isLineInSegment } from './isLineInSegment';\nimport type { BidirectionalData } from './createBidirectionalToolData';\n\nconst EPSILON = 1e-2;\n\n/**\n * Search in the contours for the given segment to find the largest bidirectional\n * that will fit entirely within the slice contours inside the contours object.\n * Assumptions/implementation details:\n *\n *   1. The major and minor bidirectional lines must not cross the contour\n *   2. The center point for both major and minor bidirectional lines must be\n *      within the segment, or the contained segment index.\n *   3. The major/minor axis must be orthogonal\n *\n * Note this does NOT test that the major/minor axis intersect.  Normally they will, but\n * it isn't a hard requirement.\n *\n * The way that islands within the contours are handled is to allow the island to be\n * coloured with something that is contained - that way both open and closed islands\n * can be handled correctly for finding the bidirectional  (an open island is a section\n * inside the segment that is open to the outside - this can happen at bone endpoints or when\n * one region flows into another)\n */\nexport default function findLargestBidirectional(\n  contours,\n  segVolumeId: string,\n  segment\n) {\n  const { sliceContours } = contours;\n  const { segmentIndex, containedSegmentIndices } = segment;\n  let maxBidirectional;\n  const isInSegment = createIsInSegment(\n    segVolumeId,\n    segmentIndex,\n    containedSegmentIndices\n  );\n  for (const sliceContour of sliceContours) {\n    const bidirectional = createBidirectionalForSlice(\n      sliceContour,\n      isInSegment,\n      maxBidirectional\n    );\n    if (!bidirectional) {\n      continue;\n    }\n    maxBidirectional = bidirectional;\n  }\n  if (maxBidirectional) {\n    Object.assign(maxBidirectional, segment);\n  }\n  return maxBidirectional;\n}\n\n/**\n * This function creates a bidirectional data object for the given slice and\n * slice contour, only when the major distance is larger than currentMax, or\n * equal to current max and the minor is larger than currentMax's minor.\n * It does this by looking at every pair of distances in sliceCountour to find\n * those larger than the currentMax, and then finds the minor distance for those\n * major distances.\n *\n */\nfunction createBidirectionalForSlice(\n  sliceContour,\n  isInSegment,\n  currentMax = { maxMajor: 0, maxMinor: 0 }\n) {\n  const { points } = sliceContour.polyData;\n  const { maxMinor: currentMaxMinor, maxMajor: currentMaxMajor } = currentMax;\n  let maxMajor = currentMaxMajor * currentMaxMajor;\n  let maxMinor = currentMaxMinor * currentMaxMinor;\n  let maxMajorPoints;\n  for (let index1 = 0; index1 < points.length; index1++) {\n    for (let index2 = index1 + 1; index2 < points.length; index2++) {\n      const point1 = points[index1];\n      const point2 = points[index2];\n      const distance2 = vec3.sqrDist(point1, point2);\n      if (distance2 < maxMajor) {\n        continue;\n      }\n      if (distance2 - EPSILON < maxMajor + EPSILON && maxMajorPoints) {\n        // Consider adding to the set of points rather than continuing here\n        // so that all minor axis can be tested\n        continue;\n      }\n      if (!isInSegment.testCenter(point1, point2)) {\n        // Center between the two points has to be in the segment, otherwise\n        // this is out of bounds.\n        continue;\n      }\n      if (!isLineInSegment(point1, point2, isInSegment)) {\n        // If the line intersects the segment boundary, then skip it\n        continue;\n      }\n      maxMajor = distance2 - EPSILON;\n      maxMajorPoints = [index1, index2];\n      maxMinor = 0;\n    }\n  }\n  if (!maxMajorPoints) {\n    return;\n  }\n\n  maxMajor = Math.sqrt(maxMajor + EPSILON);\n  const handle0 = points[maxMajorPoints[0]];\n  const handle1 = points[maxMajorPoints[1]];\n  const unitMajor = vec3.sub(vec3.create(), handle0, handle1);\n  vec3.scale(unitMajor, unitMajor, 1 / maxMajor);\n\n  let maxMinorPoints;\n\n  for (let index1 = 0; index1 < points.length; index1++) {\n    for (let index2 = index1 + 1; index2 < points.length; index2++) {\n      const point1 = points[index1];\n      const point2 = points[index2];\n      const distance2 = vec3.sqrDist(point1, point2);\n      if (distance2 <= maxMinor) {\n        continue;\n      }\n      const delta = vec3.sub(vec3.create(), point1, point2);\n\n      const dot = Math.abs(vec3.dot(delta, unitMajor)) / Math.sqrt(distance2);\n      if (dot > EPSILON) {\n        continue;\n      }\n\n      if (!isInSegment.testCenter(point1, point2)) {\n        // Center between the two points has to be in the segment, otherwise\n        // this is out of bounds.\n        continue;\n      }\n      if (!isLineInSegment(point1, point2, isInSegment)) {\n        continue;\n      }\n      maxMinor = distance2;\n      maxMinorPoints = [index1, index2];\n    }\n  }\n\n  if (!maxMinorPoints) {\n    // Didn't find a larger minor distance\n    return;\n  }\n  maxMinor = Math.sqrt(maxMinor);\n  const handle2 = points[maxMinorPoints[0]];\n  const handle3 = points[maxMinorPoints[1]];\n\n  const bidirectional = {\n    majorAxis: [handle0, handle1],\n    minorAxis: [handle2, handle3],\n    maxMajor,\n    maxMinor,\n    ...sliceContour,\n  } as BidirectionalData;\n  return bidirectional;\n}\n","import { generateContourSetsFromLabelmap } from '../contours';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport findLargestBidirectional from './findLargestBidirectional';\n\nconst { Labelmap } = SegmentationRepresentations;\n\n/**\n * Generates a contour object over the segment, and then uses the contouring to\n * find the largest bidirectional object that can be applied within the acquisition\n * plane that is within the segment index, or the contained segment indices.\n *\n * @param segmentation.segments - a list of segments to apply the contour to.\n * @param segmentation.segments.containedSegmentIndices - a set of segment indexes equivalent to the primary segment\n * @param segmentation.segments.label - the label for the segment\n * @param segmentation.segments.color - the color to use for the segment label\n */\nexport default function contourAndFindLargestBidirectional(segmentation) {\n  const contours = generateContourSetsFromLabelmap({\n    segmentations: segmentation,\n  });\n\n  if (!contours?.length || !contours[0].sliceContours.length) {\n    return;\n  }\n\n  const {\n    representationData,\n    segments = [\n      null,\n      { label: 'Unspecified', color: null, containedSegmentIndices: null },\n    ],\n  } = segmentation;\n  const { volumeId: segVolumeId } = representationData[Labelmap];\n\n  const segmentIndex = segments.findIndex((it) => !!it);\n  if (segmentIndex === -1) {\n    return;\n  }\n  segments[segmentIndex].segmentIndex = segmentIndex;\n  return findLargestBidirectional(\n    contours[0],\n    segVolumeId,\n    segments[segmentIndex]\n  );\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { Annotation } from '../../types/AnnotationTypes';\n\nexport type BidirectionalData = {\n  majorAxis: [Types.Point3, Types.Point3];\n  minorAxis: [Types.Point3, Types.Point3];\n  maxMajor: number;\n  maxMinor: number;\n  segmentIndex: number;\n  label?: string;\n  color?: string | number[];\n  referencedImageId: string;\n  sliceIndex: number;\n};\n\n/**\n * Creates data suitable for the BidirectionalTool from the basic bidirectional\n * data object.\n */\nexport default function createBidirectionalToolData(\n  bidirectionalData: BidirectionalData,\n  viewport\n): Annotation {\n  const { majorAxis, minorAxis, label = '', sliceIndex } = bidirectionalData;\n  const [major0, major1] = majorAxis;\n  const [minor0, minor1] = minorAxis;\n\n  const points = [major0, major1, minor0, minor1];\n  const bidirectionalToolData = {\n    highlighted: true,\n    invalidated: true,\n    metadata: {\n      toolName: 'Bidirectional',\n      // Get a view reference for the slice this applies to, not the currently\n      // displayed slice.  This will fill in the remaining data for that slice\n      ...viewport.getViewReference({ sliceIndex }),\n    },\n    data: {\n      handles: {\n        points,\n        textBox: {\n          hasMoved: false,\n          worldPosition: [0, 0, 0] as Types.Point3,\n          worldBoundingBox: {\n            topLeft: [0, 0, 0] as Types.Point3,\n            topRight: [0, 0, 0] as Types.Point3,\n            bottomLeft: [0, 0, 0] as Types.Point3,\n            bottomRight: [0, 0, 0] as Types.Point3,\n          },\n        },\n        activeHandleIndex: null,\n      },\n      label,\n      cachedStats: {},\n    },\n    isLocked: false,\n    isVisible: true,\n  };\n  return bidirectionalToolData;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n// Returns sign of number\nfunction sign(x: any) {\n  return typeof x === 'number'\n    ? x\n      ? x < 0\n        ? -1\n        : 1\n      : x === x\n      ? 0\n      : NaN\n    : NaN;\n}\n\n/**\n * Calculates the intersection point between two lines in the 2D plane\n *\n * @param line1Start - x,y coordinates of the start of the first line\n * @param line1End - x,y coordinates of the end of the first line\n * @param line2Start - x,y coordinates of the start of the second line\n * @param line2End - x,y coordinates of the end of the second line\n * @returns [x,y] - point x,y of the point\n */\n\nexport default function intersectLine(\n  line1Start: Types.Point2,\n  line1End: Types.Point2,\n  line2Start: Types.Point2,\n  line2End: Types.Point2\n): number[] {\n  const [x1, y1] = line1Start;\n  const [x2, y2] = line1End;\n  const [x3, y3] = line2Start;\n  const [x4, y4] = line2End;\n\n  // Compute a1, b1, c1, where line joining points 1 and 2 is \"a1 x  +  b1 y  +  c1  =  0\"\n  const a1 = y2 - y1;\n  const b1 = x1 - x2;\n  const c1 = x2 * y1 - x1 * y2;\n\n  // Compute r3 and r4\n  const r3 = a1 * x3 + b1 * y3 + c1;\n  const r4 = a1 * x4 + b1 * y4 + c1;\n\n  /* Check signs of r3 and r4.  If both point 3 and point 4 lie on\n   * same side of line 1, the line segments do not intersect.\n   */\n\n  if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\n    return;\n  }\n\n  // Compute a2, b2, c2\n  const a2 = y4 - y3;\n  const b2 = x3 - x4;\n  const c2 = x4 * y3 - x3 * y4;\n\n  // Compute r1 and r2\n  const r1 = a2 * x1 + b2 * y1 + c2;\n  const r2 = a2 * x2 + b2 * y2 + c2;\n\n  /* Check signs of r1 and r2.  If both point 1 and point 2 lie\n   * on same side of second line segment, the line segments do\n   * not intersect.\n   */\n\n  if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\n    return;\n  }\n\n  /* Line segments intersect: compute intersection point.\n   */\n\n  const denom = a1 * b2 - a2 * b1;\n  let num;\n\n  /* The denom/2 is to get rounding instead of truncating.  It\n   * is added or subtracted to the numerator, depending upon the\n   * sign of the numerator.\n   */\n\n  num = b1 * c2 - b2 * c1;\n  const x = num / denom;\n\n  num = a2 * c1 - a1 * c2;\n  const y = num / denom;\n\n  const intersectionPoint = [x, y];\n\n  return intersectionPoint;\n}\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport {\n  drawLine as drawLineSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as lineSegment from '../../utilities/math/line';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { BidirectionalAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * BidirectionalTool let you draw annotations that measures the length and\n * width at the same time in `mm` unit. It is consisted of two perpendicular lines and\n * a text box. You can use the BidirectionalTool in all planes even in oblique\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(BidirectionalTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(BidirectionalTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(BidirectionalTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass BidirectionalTool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n  preventHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Bidirectional Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation(\n    evt: EventTypes.InteractionEventType\n  ): BidirectionalAnnotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: BidirectionalAnnotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [\n            // long\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            // short\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          activeHandleIndex: null,\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  }\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: BidirectionalAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // Check long axis\n    let canvasPoint1 = viewport.worldToCanvas(points[0]);\n    let canvasPoint2 = viewport.worldToCanvas(points[1]);\n\n    let line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    let distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    // Check short axis\n    canvasPoint1 = viewport.worldToCanvas(points[2]);\n    canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Handles the toolSelected callback for bidirectional tool\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Executes the callback for when mouse has selected a handle (anchor point) of\n   * the bidirectional tool or when the text box has been selected.\n   *\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param handle - Handle index or selected textBox information\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const data = annotation.data;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    hideElementCursor(element);\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Handles the mouse up action for the bidirectional tool. It can be at the end\n   * of the annotation drawing (MouseUpEventType) or when the user clicks and release\n   * the mouse button instantly which let to the annotation to draw without holding\n   * the mouse button (MouseClickEventType).\n   *\n   * @param evt - mouse up or mouse click event types\n   */\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const { renderingEngine } = getEnabledElement(element);\n\n    if (this.editData.handleIndex !== undefined) {\n      const { points } = data.handles;\n      const firstLineSegmentLength = vec3.distance(points[0], points[1]);\n      const secondLineSegmentLength = vec3.distance(points[2], points[3]);\n\n      if (secondLineSegmentLength > firstLineSegmentLength) {\n        // Switch points so [0,1] is the long axis and [2,3] is the short axis.\n\n        const longAxis = [[...points[2]], [...points[3]]];\n\n        const shortAxisPoint0 = [...points[0]];\n        const shortAxisPoint1 = [...points[1]];\n\n        // shortAxis[0->1] should be perpendicular (counter-clockwise) to longAxis[0->1]\n        const longAxisVector = vec2.create();\n\n        vec2.set(\n          longAxisVector,\n          longAxis[1][0] - longAxis[0][0],\n          longAxis[1][1] - longAxis[1][0]\n        );\n\n        const counterClockWisePerpendicularToLongAxis = vec2.create();\n\n        vec2.set(\n          counterClockWisePerpendicularToLongAxis,\n          -longAxisVector[1],\n          longAxisVector[0]\n        );\n\n        const currentShortAxisVector = vec2.create();\n\n        vec2.set(\n          currentShortAxisVector,\n          shortAxisPoint1[0] - shortAxisPoint0[0],\n          shortAxisPoint1[1] - shortAxisPoint0[0]\n        );\n\n        let shortAxis;\n\n        if (\n          vec2.dot(\n            currentShortAxisVector,\n            counterClockWisePerpendicularToLongAxis\n          ) > 0\n        ) {\n          shortAxis = [shortAxisPoint0, shortAxisPoint1];\n        } else {\n          shortAxis = [shortAxisPoint1, shortAxisPoint0];\n        }\n\n        data.handles.points = [\n          longAxis[0],\n          longAxis[1],\n          shortAxis[0],\n          shortAxis[1],\n        ];\n      }\n    }\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  /**\n   * @param evt - mouse move event type or mouse drag\n   */\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    const worldPos = currentPoints.world;\n\n    // Update first move handle\n    data.handles.points[handleIndex] = [...worldPos];\n\n    const canvasCoordPoints = data.handles.points.map(worldToCanvas);\n\n    const canvasCoords = {\n      longLineSegment: {\n        start: {\n          x: canvasCoordPoints[0][0],\n          y: canvasCoordPoints[0][1],\n        },\n        end: {\n          x: canvasCoordPoints[1][0],\n          y: canvasCoordPoints[1][1],\n        },\n      },\n      shortLineSegment: {\n        start: {\n          x: canvasCoordPoints[2][0],\n          y: canvasCoordPoints[2][1],\n        },\n        end: {\n          x: canvasCoordPoints[3][0],\n          y: canvasCoordPoints[3][1],\n        },\n      },\n    };\n\n    // ~~ calculate worldPos of our short axis handles\n    // short axis is perpendicular to long axis, and we set its length to be 2/3 of long axis\n    // (meaning each)\n    const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\n\n    const shortAxisDistFromCenter = dist / 3;\n    // Calculate long line's incline\n    const dx =\n      canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\n    const dy =\n      canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    const vectorX = dx / length;\n    const vectorY = dy / length;\n    // middle point between long line segment's points\n    const xMid =\n      (canvasCoords.longLineSegment.start.x +\n        canvasCoords.longLineSegment.end.x) /\n      2;\n    const yMid =\n      (canvasCoords.longLineSegment.start.y +\n        canvasCoords.longLineSegment.end.y) /\n      2;\n    // short points 1/3 distance from center of long points\n    const startX = xMid + shortAxisDistFromCenter * vectorY;\n    const startY = yMid - shortAxisDistFromCenter * vectorX;\n    const endX = xMid - shortAxisDistFromCenter * vectorY;\n    const endY = yMid + shortAxisDistFromCenter * vectorX;\n\n    // Update perpendicular line segment's points\n    data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\n    data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\n\n    annotation.invalidated = true;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData.hasMoved = true;\n  };\n\n  /**\n   * Mouse drag to edit annotation callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragModifyHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  /**\n   * Mouse dragging a handle callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, handleIndex: movingHandleIndex } = this.editData;\n    const { data } = annotation;\n\n    // Moving handle\n    const worldPos = currentPoints.world;\n    const canvasCoordHandlesCurrent = [\n      viewport.worldToCanvas(data.handles.points[0]),\n      viewport.worldToCanvas(data.handles.points[1]),\n      viewport.worldToCanvas(data.handles.points[2]),\n      viewport.worldToCanvas(data.handles.points[3]),\n    ];\n\n    const firstLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[0][0],\n        y: canvasCoordHandlesCurrent[0][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[1][0],\n        y: canvasCoordHandlesCurrent[1][1],\n      },\n    };\n    const secondLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[2][0],\n        y: canvasCoordHandlesCurrent[2][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[3][0],\n        y: canvasCoordHandlesCurrent[3][1],\n      },\n    };\n\n    // Handle we've selected's proposed point\n    const proposedPoint = <Types.Point3>[...worldPos];\n    const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\n\n    if (movingHandleIndex === 0 || movingHandleIndex === 1) {\n      const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\n\n      const fixedHandleCanvasCoord =\n        canvasCoordHandlesCurrent[fixedHandleIndex];\n\n      const fixedHandleToProposedCoordVec = vec2.set(\n        vec2.create(),\n        proposedCanvasCoord[0] - fixedHandleCanvasCoord[0],\n        proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]\n      );\n\n      const fixedHandleToOldCoordVec = vec2.set(\n        vec2.create(),\n        canvasCoordHandlesCurrent[movingHandleIndex][0] -\n          fixedHandleCanvasCoord[0],\n        canvasCoordHandlesCurrent[movingHandleIndex][1] -\n          fixedHandleCanvasCoord[1]\n      );\n\n      // normalize vector\n      vec2.normalize(\n        fixedHandleToProposedCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n      vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\n\n      // Check whether this\n      const proposedFirstLineSegment = {\n        start: {\n          x: fixedHandleCanvasCoord[0],\n          y: fixedHandleCanvasCoord[1],\n        },\n        end: {\n          x: proposedCanvasCoord[0],\n          y: proposedCanvasCoord[1],\n        },\n      };\n\n      // Note: this is the case when we are modifying the long axis line segment\n      // and we make it shorter and shorter until its second half size becomes zero\n      // which basically means that any more modification would make the long axis\n      // second half disappear. In this case, we just bail out and do not update\n      // since we don't want to disrupt the bidirectional shape.\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          proposedFirstLineSegment,\n          secondLineSegment\n        )\n      ) {\n        return;\n      }\n\n      const centerOfRotation = fixedHandleCanvasCoord;\n\n      const angle = this._getSignedAngle(\n        fixedHandleToOldCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n\n      // rotate handles around the center of rotation, first translate to origin,\n      // then rotate, then translate back\n      let firstPointX = canvasCoordHandlesCurrent[2][0];\n      let firstPointY = canvasCoordHandlesCurrent[2][1];\n\n      let secondPointX = canvasCoordHandlesCurrent[3][0];\n      let secondPointY = canvasCoordHandlesCurrent[3][1];\n\n      // translate to origin\n      firstPointX -= centerOfRotation[0];\n      firstPointY -= centerOfRotation[1];\n\n      secondPointX -= centerOfRotation[0];\n      secondPointY -= centerOfRotation[1];\n\n      // rotate\n      const rotatedFirstPoint =\n        firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\n      const rotatedFirstPointY =\n        firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\n\n      const rotatedSecondPoint =\n        secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\n      const rotatedSecondPointY =\n        secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\n\n      // translate back\n      firstPointX = rotatedFirstPoint + centerOfRotation[0];\n      firstPointY = rotatedFirstPointY + centerOfRotation[1];\n\n      secondPointX = rotatedSecondPoint + centerOfRotation[0];\n      secondPointY = rotatedSecondPointY + centerOfRotation[1];\n\n      // update handles\n      const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\n      const newSecondPoint = viewport.canvasToWorld([\n        secondPointX,\n        secondPointY,\n      ]);\n\n      // the fixed handle is the one that is not being moved so we\n      // don't need to update it\n      data.handles.points[movingHandleIndex] = proposedPoint;\n      data.handles.points[2] = newFirstPoint;\n      data.handles.points[3] = newSecondPoint;\n    } else {\n      // Translation manipulator\n      const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\n\n      const canvasCoordsCurrent = {\n        longLineSegment: {\n          start: firstLineSegment.start,\n          end: firstLineSegment.end,\n        },\n        shortLineSegment: {\n          start: secondLineSegment.start,\n          end: secondLineSegment.end,\n        },\n      };\n\n      const longLineSegmentVec = vec2.subtract(\n        vec2.create(),\n        [\n          canvasCoordsCurrent.longLineSegment.end.x,\n          canvasCoordsCurrent.longLineSegment.end.y,\n        ],\n        [\n          canvasCoordsCurrent.longLineSegment.start.x,\n          canvasCoordsCurrent.longLineSegment.start.y,\n        ]\n      );\n\n      const longLineSegmentVecNormalized = vec2.normalize(\n        vec2.create(),\n        longLineSegmentVec\n      );\n\n      const proposedToCurrentVec = vec2.subtract(\n        vec2.create(),\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [\n          canvasCoordHandlesCurrent[movingHandleIndex][0],\n          canvasCoordHandlesCurrent[movingHandleIndex][1],\n        ]\n      );\n\n      const movementLength = vec2.length(proposedToCurrentVec);\n\n      const angle = this._getSignedAngle(\n        longLineSegmentVecNormalized,\n        proposedToCurrentVec\n      );\n\n      const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\n\n      const newTranslatedPoint = vec2.scaleAndAdd(\n        vec2.create(),\n        [\n          canvasCoordHandlesCurrent[translateHandleIndex][0],\n          canvasCoordHandlesCurrent[translateHandleIndex][1],\n        ],\n        longLineSegmentVecNormalized,\n        movementAlongLineSegmentLength\n      );\n\n      // don't update if it passes through the other line segment\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          {\n            start: {\n              x: proposedCanvasCoord[0],\n              y: proposedCanvasCoord[1],\n            },\n            end: {\n              x: newTranslatedPoint[0],\n              y: newTranslatedPoint[1],\n            },\n          },\n          {\n            start: {\n              x: canvasCoordsCurrent.longLineSegment.start.x,\n              y: canvasCoordsCurrent.longLineSegment.start.y,\n            },\n            end: {\n              x: canvasCoordsCurrent.longLineSegment.end.x,\n              y: canvasCoordsCurrent.longLineSegment.end.y,\n            },\n          }\n        )\n      ) {\n        return;\n      }\n\n      const intersectionPoint = lineSegment.intersectLine(\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [newTranslatedPoint[0], newTranslatedPoint[1]],\n        [firstLineSegment.start.x, firstLineSegment.start.y],\n        [firstLineSegment.end.x, firstLineSegment.end.y]\n      );\n\n      // don't update if it doesn't intersect\n      if (!intersectionPoint) {\n        return;\n      }\n\n      data.handles.points[translateHandleIndex] = viewport.canvasToWorld(\n        newTranslatedPoint as Types.Point2\n      );\n      data.handles.points[movingHandleIndex] = proposedPoint;\n    }\n  };\n\n  /**\n   * Cancels an ongoing drawing of a bidirectional annotation\n   * @param element - HTML Element\n   */\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the bidirectional annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = true;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as BidirectionalAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].unit == null\n      ) {\n        data.cachedStats[targetId] = {\n          length: null,\n          width: null,\n          unit: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId1 = `${annotationUID}-line-1`;\n      const dataId2 = `${annotationUID}-line-2`;\n\n      const lineUID = '0';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId1\n      );\n\n      const secondLineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        secondLineUID,\n        canvasCoordinates[2],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId2\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _movingLongAxisWouldPutItThroughShortAxis = (\n    firstLineSegment,\n    secondLineSegment\n  ) => {\n    const vectorInSecondLineDirection = vec2.create();\n\n    vec2.set(\n      vectorInSecondLineDirection,\n      secondLineSegment.end.x - secondLineSegment.start.x,\n      secondLineSegment.end.y - secondLineSegment.start.y\n    );\n\n    vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\n\n    const extendedSecondLineSegment = {\n      start: {\n        x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\n      },\n      end: {\n        x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\n      },\n    };\n\n    // Add some buffer in the secondLineSegment when finding the proposedIntersectionPoint\n    // Of points to stop us getting stack when rotating quickly.\n\n    const proposedIntersectionPoint = lineSegment.intersectLine(\n      [extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y],\n      [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y],\n      [firstLineSegment.start.x, firstLineSegment.start.y],\n      [firstLineSegment.end.x, firstLineSegment.end.y]\n    );\n\n    const wouldPutThroughShortAxis = !proposedIntersectionPoint;\n\n    return wouldPutThroughShortAxis;\n  };\n\n  _calculateLength(pos1, pos2) {\n    const dx = pos1[0] - pos2[0];\n    const dy = pos1[1] - pos2[1];\n    const dz = pos1[2] - pos2[2];\n\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  _calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\n    const { data } = annotation;\n    const { element } = enabledElement.viewport;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const worldPos3 = data.handles.points[2];\n    const worldPos4 = data.handles.points[3];\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, dimensions } = image;\n      const index1 = transformWorldToIndex(imageData, worldPos1);\n      const index2 = transformWorldToIndex(imageData, worldPos2);\n      const index3 = transformWorldToIndex(imageData, worldPos3);\n      const index4 = transformWorldToIndex(imageData, worldPos4);\n\n      const handles1 = [index1, index2];\n      const handles2 = [index3, index4];\n\n      const { scale: scale1, units: units1 } = getCalibratedLengthUnitsAndScale(\n        image,\n        handles1\n      );\n\n      const { scale: scale2, units: units2 } = getCalibratedLengthUnitsAndScale(\n        image,\n        handles2\n      );\n\n      const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;\n      const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;\n      const length = dist1 > dist2 ? dist1 : dist2;\n      const width = dist1 > dist2 ? dist2 : dist1;\n\n      const lengthUnit = dist1 > dist2 ? units1 : units2;\n      const widthUnit = dist1 > dist2 ? units2 : units1;\n\n      this._isInsideVolume(index1, index2, index3, index4, dimensions)\n        ? (this.isHandleOutsideImage = false)\n        : (this.isHandleOutsideImage = true);\n\n      cachedStats[targetId] = {\n        length,\n        width,\n        unit: units1,\n        lengthUnit,\n        widthUnit,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, index3, index4, dimensions): boolean => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions) &&\n      csUtils.indexWithinDimensions(index3, dimensions) &&\n      csUtils.indexWithinDimensions(index4, dimensions)\n    );\n  };\n\n  _getSignedAngle = (vector1, vector2) => {\n    return Math.atan2(\n      vector1[0] * vector2[1] - vector1[1] * vector2[0],\n      vector1[0] * vector2[0] + vector1[1] * vector2[1]\n    );\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const { cachedStats, label } = data;\n  const { length, width, unit, lengthUnit, widthUnit } = cachedStats[targetId];\n\n  const textLines = [];\n  if (label) {\n    textLines.push(label);\n  }\n  if (length === undefined) {\n    return textLines;\n  }\n\n  // spaceBetweenSlices & pixelSpacing &\n  // magnitude in each direction? Otherwise, this is \"px\"?\n  textLines.push(\n    `L: ${roundNumber(length)} ${lengthUnit || unit}`,\n    `W: ${roundNumber(width)} ${widthUnit || unit}`\n  );\n\n  return textLines;\n}\n\nBidirectionalTool.toolName = 'Bidirectional';\nexport default BidirectionalTool;\n","import { getEnabledElement, type Types } from '@cornerstonejs/core';\n\nimport type { Annotation } from '../../types/AnnotationTypes';\nimport * as segmentation from '../../stateManagement/segmentation';\nimport {\n  state as annotationState,\n  config as annotationConfig,\n} from '../../stateManagement/annotation';\nimport { jumpToSlice } from '../viewport';\nimport contourAndFindLargestBidirectional from './contourAndFindLargestBidirectional';\nimport createBidirectionalToolData from './createBidirectionalToolData';\nimport BidirectionalTool from '../../tools/annotation/BidirectionalTool';\n\nexport type Segment = {\n  segmentationId: string;\n  segmentIndex: number;\n  label: string;\n\n  style?: any;\n  containedSegmentIndices?: (number) => boolean;\n};\n\nexport type SegmentContourActionConfiguration = {\n  getSegment?: (\n    enabledElement: Types.IEnabledElement,\n    configuration: SegmentContourActionConfiguration\n  ) => Segment;\n\n  /**\n   * Optional map for data about each segment\n   */\n  segmentationId?: string;\n  segmentIndex?: number;\n  segmentData?: Map<number, Segment>;\n  toolGroupId?: string;\n};\n\nexport default function segmentContourAction(\n  element: HTMLDivElement,\n  configuration\n) {\n  const { data: configurationData } = configuration;\n  const enabledElement = getEnabledElement(element);\n  const segment = (configurationData.getSegment || defaultGetSegment)(\n    enabledElement,\n    configurationData\n  );\n  if (!segment) {\n    return;\n  }\n  const FrameOfReferenceUID = enabledElement.viewport.getFrameOfReferenceUID();\n  const segmentationsList = segmentation.state.getSegmentations();\n  const { segmentIndex, segmentationId } = segment;\n  const bidirectionals = annotationState.getAnnotations(\n    this.toolName || BidirectionalTool.toolName,\n    FrameOfReferenceUID\n  );\n  let hasExistingActiveSegment = false;\n  const existingLargestBidirectionals = bidirectionals.filter(\n    (existingBidirectionalItem) => {\n      const { segment } = existingBidirectionalItem.data;\n      if (!segment) {\n        return;\n      }\n      if (\n        segment.segmentationId === segmentationId &&\n        segment.segmentIndex === segmentIndex\n      ) {\n        hasExistingActiveSegment = true;\n        existingBidirectionalItem.data.segment = segment;\n      }\n      return !!segment;\n    }\n  );\n  if (!hasExistingActiveSegment) {\n    // Just create a dummy annotation object containing just enough information\n    // to create a real one.\n    existingLargestBidirectionals.push({\n      data: { segment },\n    } as unknown as Annotation);\n  }\n\n  let newBidirectional;\n  existingLargestBidirectionals.forEach((existingLargestBidirectional) => {\n    const segments = [];\n    const { segment: updateSegment } = existingLargestBidirectional.data;\n    const { segmentIndex, segmentationId } = updateSegment;\n    segments[segmentIndex] = updateSegment;\n    annotationState.removeAnnotation(\n      existingLargestBidirectional.annotationUID\n    );\n    const bidirectionalData = contourAndFindLargestBidirectional({\n      ...segmentationsList.find(\n        (segmentation) => segmentation.segmentationId === segmentationId\n      ),\n      segments,\n    });\n\n    if (!bidirectionalData) {\n      return;\n    }\n    const bidirectionalToolData = createBidirectionalToolData(\n      bidirectionalData,\n      enabledElement.viewport\n    );\n    bidirectionalToolData.annotationUID =\n      existingLargestBidirectional.annotationUID;\n    bidirectionalToolData.data.segment = updateSegment;\n\n    const annotationUID = annotationState.addAnnotation(\n      bidirectionalToolData,\n      FrameOfReferenceUID\n    );\n\n    if (\n      updateSegment.segmentIndex === segment.segmentIndex &&\n      updateSegment.segmentationId === segment.segmentationId\n    ) {\n      newBidirectional = bidirectionalData;\n      const { style } = segment;\n      if (style) {\n        annotationConfig.style.setAnnotationStyles(annotationUID, style);\n      }\n    }\n  });\n\n  if (newBidirectional) {\n    const { sliceIndex } = newBidirectional;\n    const imageIds = enabledElement.viewport.getImageIds();\n\n    // TODO - figure out why this is reversed\n    jumpToSlice(element, {\n      imageIndex: imageIds.length - 1 - sliceIndex,\n    });\n    enabledElement.viewport.render();\n  } else {\n    console.warn('No bidirectional found');\n  }\n\n  return newBidirectional;\n}\n\nexport function defaultGetSegment(\n  enabledElement: Types.IEnabledElement,\n  configuration: SegmentContourActionConfiguration\n): Segment {\n  const segmentationsList = segmentation.state.getSegmentations();\n  if (!segmentationsList.length) {\n    return;\n  }\n  const segmentationId =\n    configuration.segmentationId || segmentationsList[0].segmentationId;\n  const segmentIndex =\n    configuration.segmentIndex ??\n    segmentation.segmentIndex.getActiveSegmentIndex(segmentationId);\n  if (!segmentIndex) {\n    return;\n  }\n  const segmentData = configuration.segmentData?.get(segmentIndex);\n  return {\n    label: `Segment ${segmentIndex}`,\n    segmentIndex,\n    segmentationId,\n    ...segmentData,\n  };\n}\n","import { utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nconst epsilon = 1e-6;\n\n/**\n * Projects a polyline from 3D to 2D by reducing one dimension.\n *\n * @param polyline - The polyline to be projected.\n * @returns An object containing the shared dimension index and the projected polyline in 2D.\n * @throws Error if a shared dimension index cannot be found for the polyline.\n */\nexport function projectTo2D(polyline: Types.Point3[]) {\n  // We need to reduce one dimension to 2D, so basically\n  // we need to find the dimension index that is shared by all points\n  // Use the first three points, two is enough but three is more robust\n  let sharedDimensionIndex;\n\n  const testPoints = utilities.getRandomSampleFromArray(polyline, 50);\n\n  for (let i = 0; i < 3; i++) {\n    if (\n      testPoints.every(\n        (point, index, array) => Math.abs(point[i] - array[0][i]) < epsilon\n      )\n    ) {\n      sharedDimensionIndex = i;\n      break;\n    }\n  }\n\n  if (sharedDimensionIndex === undefined) {\n    throw new Error(\n      'Cannot find a shared dimension index for polyline, probably oblique plane'\n    );\n  }\n\n  // convert polyline list and point to 2D\n  const points2D = [] as Types.Point2[];\n\n  const firstDim = (sharedDimensionIndex + 1) % 3;\n  const secondDim = (sharedDimensionIndex + 2) % 3;\n\n  for (let i = 0; i < polyline.length; i++) {\n    points2D.push([polyline[i][firstDim], polyline[i][secondDim]]);\n  }\n\n  return {\n    sharedDimensionIndex,\n    projectedPolyline: points2D,\n  };\n}\n","import type { Types } from '@cornerstonejs/core';\nimport containsPoint from './containsPoint';\nimport { projectTo2D } from './projectTo2D';\n\n/**\n * Determines whether a 3D point is inside a polyline in 3D space.\n *\n * The algorithm works by reducing the polyline and point to 2D space, and then\n * using the 2D algorithm to determine whether the point is inside the polyline.\n *\n * @param point - The 3D point to test.\n * @param polyline - The polyline represented as an array of 3D points.\n * @param options.holesPolyline - An array of polylines representing each hole, so it\n * is an array of arrays of 3D points.\n * @returns A boolean indicating whether the point is inside the polyline.\n * @throws An error if a shared dimension index cannot be found for the polyline points.\n */\nexport function isPointInsidePolyline3D(\n  point: Types.Point3,\n  polyline: Types.Point3[],\n  options: { holes?: Types.Point3[][] } = {}\n) {\n  const { sharedDimensionIndex, projectedPolyline } = projectTo2D(polyline);\n\n  const { holes } = options;\n  const projectedHoles = [] as Types.Point2[][];\n\n  if (holes) {\n    for (let i = 0; i < holes.length; i++) {\n      const hole = holes[i];\n      const hole2D = [] as Types.Point2[];\n\n      for (let j = 0; j < hole.length; j++) {\n        hole2D.push([\n          hole[j][(sharedDimensionIndex + 1) % 3],\n          hole[j][(sharedDimensionIndex + 2) % 3],\n        ]);\n      }\n\n      projectedHoles.push(hole2D);\n    }\n  }\n\n  const point2D = [\n    point[(sharedDimensionIndex + 1) % 3],\n    point[(sharedDimensionIndex + 2) % 3],\n  ] as Types.Point2;\n\n  return containsPoint(projectedPolyline, point2D, { holes: projectedHoles });\n}\n","import { cache, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport {\n  getSegmentation,\n  getSegmentationIdRepresentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\nimport { ContourSegmentationAnnotation, Segmentation } from '../../types';\nimport { getAnnotation } from '../../stateManagement';\nimport { isPointInsidePolyline3D } from '../math/polyline';\n\ntype Options = {\n  representationType?: SegmentationRepresentations;\n  viewport?: Types.IViewport;\n};\n\n/**\n * Get the segment at the specified world point in the viewport.\n * @param segmentationId - The ID of the segmentation to get the segment for.\n * @param worldPoint - The world point to get the segment for.\n *\n * @returns The index of the segment at the world point, or undefined if not found.\n */\nexport function getSegmentAtWorldPoint(\n  segmentationId: string,\n  worldPoint: Types.Point3,\n  options = {} as Options\n): number {\n  const segmentation = getSegmentation(segmentationId);\n\n  const representationData = segmentation.representationData;\n\n  // if representationType is not provided, we will use the first representation\n  const desiredRepresentation =\n    options?.representationType ?? Object.keys(representationData)[0];\n\n  if (!desiredRepresentation) {\n    throw new Error(\n      `Segmentation ${segmentationId} does not have any representations`\n    );\n  }\n\n  switch (desiredRepresentation) {\n    case SegmentationRepresentations.Labelmap:\n      return getSegmentAtWorldForLabelmap(segmentation, worldPoint, options);\n    case SegmentationRepresentations.Contour:\n      return getSegmentAtWorldForContour(segmentation, worldPoint, options);\n    default:\n      return;\n  }\n}\n\n/**\n * Retrieves the segment index at a given world point for a labelmap.\n *\n * @param labelmapData - The labelmap segmentation data.\n * @param worldPoint - The world point to retrieve the segment at.\n *\n * @returns The segment index at the given world point, or undefined if not found.\n */\nexport function getSegmentAtWorldForLabelmap(\n  segmentation: Segmentation,\n  worldPoint: Types.Point3,\n  { viewport }: Options\n): number | undefined {\n  const labelmapData = segmentation.representationData.LABELMAP;\n\n  if (isVolumeSegmentation(labelmapData)) {\n    const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n    const segmentationVolume = cache.getVolume(volumeId);\n\n    if (!segmentationVolume) {\n      return;\n    }\n\n    const segmentIndex =\n      segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);\n\n    return segmentIndex;\n  }\n\n  // stack segmentation case\n  const { imageIdReferenceMap } = labelmapData as LabelmapSegmentationDataStack;\n\n  const currentImageId = (viewport as Types.IStackViewport).getCurrentImageId();\n\n  const segmentationImageId = imageIdReferenceMap.get(currentImageId);\n  const image = cache.getImage(segmentationImageId);\n\n  if (!image) {\n    return;\n  }\n\n  // find the first segmentationRepresentationUID for the segmentationId, since\n  // that is what we use as actorUID in the viewport\n\n  const segmentationRepresentations = getSegmentationIdRepresentations(\n    segmentation.segmentationId\n  );\n\n  const { segmentationRepresentationUID } = segmentationRepresentations[0];\n\n  const segmentationActor = viewport.getActor(segmentationRepresentationUID);\n  const imageData = segmentationActor?.actor.getMapper().getInputData();\n  const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n\n  const dimensions = imageData.getDimensions();\n  const voxelManager = (imageData.voxelManager ||\n    utilities.VoxelManager.createVolumeVoxelManager(\n      dimensions,\n      imageData.getPointData().getScalars().getData()\n    )) as utilities.VoxelManager<number>;\n\n  const segmentIndex = voxelManager.getAtIJKPoint(indexIJK as Types.Point3);\n\n  return segmentIndex;\n}\n\n/**\n * Retrieves the segment index at a given world point for contour segmentation.\n *\n * @param segmentation - The segmentation data.\n * @param worldPoint - The world point to check.\n * @param options - The options for segmentation.\n * @returns The segment index at the given world point, or undefined if not found.\n */\nexport function getSegmentAtWorldForContour(\n  segmentation: Segmentation,\n  worldPoint: Types.Point3,\n  { viewport }: Options\n): number {\n  const contourData = segmentation.representationData.CONTOUR;\n\n  const segmentIndices = Array.from(contourData.annotationUIDsMap.keys());\n  const { viewPlaneNormal } = viewport.getCamera();\n\n  for (const segmentIndex of segmentIndices) {\n    const annotationsSet = contourData.annotationUIDsMap.get(segmentIndex);\n\n    if (!annotationsSet) {\n      continue;\n    }\n\n    for (const annotationUID of annotationsSet) {\n      const annotation = getAnnotation(\n        annotationUID\n      ) as ContourSegmentationAnnotation;\n\n      if (!annotation) {\n        continue;\n      }\n\n      const { polyline } = annotation.data.contour;\n\n      if (\n        !utilities.isEqual(viewPlaneNormal, annotation.metadata.viewPlaneNormal)\n      ) {\n        continue;\n      }\n\n      // This function checks whether we are inside the contour. It does not\n      // check if we are exactly on the contour, which is highly unlikely given\n      // the canvas pixel resolution of 1 decimal place we have by design.\n      if (isPointInsidePolyline3D(worldPoint, polyline)) {\n        return Number(segmentIndex);\n      }\n    }\n  }\n}\n","import { cache, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  getSegmentation,\n  getSegmentationIdRepresentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\n\ntype Options = {\n  viewport?: Types.IViewport;\n  searchRadius?: number;\n};\n\n/**\n * Retrieves the segment index at the border of a labelmap in a segmentation.\n *\n * @param segmentationId - The ID of the segmentation.\n * @param worldPoint - The world coordinates of the point.\n * @param options - Additional options.\n * @param options.viewport - The viewport to use.\n * @param options.searchRadius - The search radius to use.\n * @returns The segment index at the labelmap border, or undefined if not found.\n */\nexport function getSegmentAtLabelmapBorder(\n  segmentationId: string,\n  worldPoint: Types.Point3,\n  { viewport, searchRadius }: Options\n): number {\n  const segmentation = getSegmentation(segmentationId);\n\n  const labelmapData = segmentation.representationData.LABELMAP;\n\n  if (isVolumeSegmentation(labelmapData)) {\n    const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n    const segmentationVolume = cache.getVolume(volumeId);\n\n    if (!segmentationVolume) {\n      return;\n    }\n\n    const imageData = segmentationVolume.imageData;\n\n    const segmentIndex = imageData.getScalarValueFromWorld(worldPoint);\n\n    const canvasPoint = viewport.worldToCanvas(worldPoint);\n\n    const onEdge = isSegmentOnEdgeCanvas(\n      canvasPoint as Types.Point2,\n      segmentIndex,\n      viewport,\n      imageData,\n      searchRadius\n    );\n\n    return onEdge ? segmentIndex : undefined;\n  }\n\n  // stack segmentation case\n  const { imageIdReferenceMap } = labelmapData as LabelmapSegmentationDataStack;\n\n  const currentImageId = (viewport as Types.IStackViewport).getCurrentImageId();\n\n  const segmentationImageId = imageIdReferenceMap.get(currentImageId);\n  const image = cache.getImage(segmentationImageId);\n\n  if (!image) {\n    return;\n  }\n\n  // find the first segmentationRepresentationUID for the segmentationId, since\n  // that is what we use as actorUID in the viewport\n\n  const segmentationRepresentations = getSegmentationIdRepresentations(\n    segmentation.segmentationId\n  );\n\n  const { segmentationRepresentationUID } = segmentationRepresentations[0];\n  const segmentationActor = viewport.getActor(segmentationRepresentationUID);\n  const imageData = segmentationActor?.actor.getMapper().getInputData();\n  const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n\n  const dimensions = imageData.getDimensions();\n  const voxelManager = (imageData.voxelManager ||\n    utilities.VoxelManager.createVolumeVoxelManager(\n      dimensions,\n      imageData.getPointData().getScalars().getData()\n    )) as utilities.VoxelManager<number>;\n\n  const segmentIndex = voxelManager.getAtIJKPoint(indexIJK as Types.Point3);\n\n  const onEdge = isSegmentOnEdgeIJK(\n    indexIJK as Types.Point3,\n    dimensions,\n    voxelManager,\n    segmentIndex\n  );\n\n  return onEdge ? segmentIndex : undefined;\n}\n\n/**\n * Checks if a segment is on the edge of a labelmap.\n * @param getNeighborIndex - A function that returns the neighbor index given the delta values.\n * @param segmentIndex - The index of the segment to check.\n * @param searchRadius - The radius within which to search for neighboring segments. Default is 1.\n * @returns A boolean indicating whether the segment is on the edge.\n */\nfunction isSegmentOnEdge(\n  getNeighborIndex: (\n    deltaI: number,\n    deltaJ: number,\n    deltaK: number\n  ) => number | undefined,\n  segmentIndex: number,\n  searchRadius = 1 // Default search radius\n): boolean {\n  const neighborRange = Array.from(\n    { length: 2 * searchRadius + 1 },\n    (_, i) => i - searchRadius\n  );\n\n  for (const deltaI of neighborRange) {\n    for (const deltaJ of neighborRange) {\n      for (const deltaK of neighborRange) {\n        if (deltaI === 0 && deltaJ === 0 && deltaK === 0) {\n          continue; // Skipping the central point\n        }\n\n        const neighborIndex = getNeighborIndex(deltaI, deltaJ, deltaK);\n\n        if (neighborIndex !== undefined && segmentIndex !== neighborIndex) {\n          return true; // On the edge\n        }\n      }\n    }\n  }\n\n  return false; // No edge neighbors found\n}\n\nfunction isSegmentOnEdgeIJK(\n  indexIJK: Types.Point3,\n  dimensions: Types.Point3,\n  voxelManager: any,\n  segmentIndex: number,\n  searchRadius?: number\n): boolean {\n  const getNeighborIndex = (deltaI: number, deltaJ: number, deltaK: number) => {\n    const neighborIJK = [\n      indexIJK[0] + deltaI,\n      indexIJK[1] + deltaJ,\n      indexIJK[2] + deltaK,\n    ];\n\n    return voxelManager.getAtIJK(...neighborIJK);\n  };\n\n  return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\n\nfunction isSegmentOnEdgeCanvas(\n  canvasPoint: Types.Point2,\n  segmentIndex: number,\n  viewport: Types.IViewport,\n  imageData: any,\n  searchRadius?: number\n): boolean {\n  const getNeighborIndex = (deltaI: number, deltaJ: number) => {\n    const neighborCanvas = [canvasPoint[0] + deltaI, canvasPoint[1] + deltaJ];\n\n    const worldPoint = viewport.canvasToWorld(neighborCanvas as Types.Point2);\n    return imageData.getScalarValueFromWorld(worldPoint);\n  };\n\n  return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\n","import { getAnnotation } from '../../stateManagement';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\n\n/**\n * Retrieves the index of the hovered contour segmentation annotation for a given segmentation ID.\n *\n * @param segmentationId - The ID of the segmentation.\n * @returns The index of the hovered contour segmentation annotation, or undefined if none is found.\n */\nexport function getHoveredContourSegmentationAnnotation(segmentationId) {\n  const segmentation = getSegmentation(segmentationId);\n  const { annotationUIDsMap } = segmentation.representationData.CONTOUR;\n\n  for (const [segmentIndex, annotationUIDs] of annotationUIDsMap.entries()) {\n    const highlightedAnnotationUID = Array.from(annotationUIDs).find(\n      (annotationUID) => getAnnotation(annotationUID).highlighted\n    );\n\n    if (highlightedAnnotationUID) {\n      return segmentIndex;\n    }\n  }\n\n  return undefined;\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the distance of a point to an AABB using 2D Box SDF (Signed Distance Field)\n *\n * The SDF of a Box\n * https://www.youtube.com/watch?v=62-pRVZuS5c\n *\n * @param aabb - Axis-aligned bound box\n * @param point - 2D point\n * @returns The closest distance between the 2D point and the AABB\n */\nexport default function distanceToPointSquared(\n  aabb: Types.AABB2,\n  point: Types.Point2\n): number {\n  const aabbWidth = aabb.maxX - aabb.minX;\n  const aabbHeight = aabb.maxY - aabb.minY;\n  const aabbSize = [aabbWidth, aabbHeight];\n  const aabbCenter: Types.Point2 = [\n    aabb.minX + aabbWidth / 2,\n    aabb.minY + aabbHeight / 2,\n  ];\n\n  // Translates the point as the center of the AABB is the new origin.\n  // THe point is also mirroed to the first quadrant to simplify the math.\n  const translatedPoint = [\n    Math.abs(point[0] - aabbCenter[0]),\n    Math.abs(point[1] - aabbCenter[1]),\n  ];\n\n  // Calculate the distance from the point to the vertical and horizontal AABB borders\n  const dx = translatedPoint[0] - aabbSize[0] * 0.5;\n  const dy = translatedPoint[1] - aabbSize[1] * 0.5;\n\n  // dx >  0 && dy >  0: diagonal line connecting the point to AABB's corner\n  // dx >  0 && dy <= 0: a line parallel to x-axis connecting the point to AABB's right side\n  // dx <= 0 && dy >  0: a line parallel to y-axis connecting the point to AABB's top side\n  // dx <= 0 && dy <= 0: the point is inside the AABB\n  if (dx > 0 && dy > 0) {\n    return dx * dx + dy * dy;\n  }\n\n  const dist = Math.max(dx, 0) + Math.max(dy, 0);\n\n  return dist * dist;\n}\n","import { Types } from '@cornerstonejs/core';\nimport distanceToPointSquared from './distanceToPointSquared';\n\n/**\n * Calculates the squared distance of a point to an AABB using\n * 2D Box SDF (Signed Distance Field)\n *\n * The SDF of a Box\n * https://www.youtube.com/watch?v=62-pRVZuS5c\n *\n * @param aabb - Axis-aligned bound box (minX, minY, maxX and maxY)\n * @param point - 2D point\n * @returns The squared distance between the 2D point and the AABB\n */\nexport default function distanceToPoint(\n  aabb: Types.AABB2,\n  point: Types.Point2\n): number {\n  return Math.sqrt(distanceToPointSquared(aabb, point));\n}\n","import type { Types } from '@cornerstonejs/core';\nimport distanceToPointSquared from './distanceToPointSquared';\n\ntype Point = Types.Point2 | Types.Point3;\n\n/**\n * Calculates the distance of a point to another point\n *\n * @param p1 - x,y or x,y,z of the point\n * @param p2 - x,y or x,y,z of the point\n * @returns distance\n */\nexport default function distanceToPoint(p1: Point, p2: Point): number {\n  return Math.sqrt(distanceToPointSquared(p1, p2));\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Get a mirrored point along the line created by two points where one of them\n * is the static (\"anchor\") point and the other one is the point to be mirroed.\n * @param mirrorPoint - 2D Point to be mirroed\n * @param staticPoint - Static 2D point\n * @returns Mirroed 2D point\n */\nexport default function mirror(\n  mirrorPoint: Types.Point2,\n  staticPoint: Types.Point2\n): Types.Point2 {\n  const [x1, y1] = mirrorPoint;\n  const [x2, y2] = staticPoint;\n\n  const newX = 2 * x2 - x1;\n  const newY = 2 * y2 - y1;\n\n  return [newX, newY];\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the area of an array of `Point2` points using the shoelace algorithm.\n *\n * The units of the area are in the same units as the points are in. E.g. if\n * the points are in canvas, then the result is in canvas pixels ^2; If they are\n * in mm, then the result is in mm^2; etc.\n */\nexport default function getArea(points: Types.Point2[]): number {\n  // Shoelace algorithm.\n  const n = points.length;\n  let area = 0.0;\n  let j = n - 1;\n\n  for (let i = 0; i < n; i++) {\n    area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\n    j = i; // j is previous vertex to i\n  }\n\n  // Return absolute value of half the sum (half as summing up traingles).\n  return Math.abs(area / 2.0);\n}\n","import { vec3 } from 'gl-matrix';\nimport { Types } from '@cornerstonejs/core';\n\nfunction _getAreaVector(polyline: Types.Point3[]): Types.Point3 {\n  const vecArea = vec3.create();\n\n  // Reference point can be any point on the same plane\n  const refPoint = polyline[0];\n\n  // Takes three points, reference point and two other points from each line\n  // segment, and calculate the area with cross product. The magnitude of the\n  // vector returned by a cross product is equal to the area of the parallelogram\n  // that the vectors span which is two times the area of the triangle.\n  //\n  // Not calling vec3 mathods makes the function run much faster since polylines\n  // may have thousands of points when using freehand ROI tool and that would\n  // increase considerably the number of function calls.\n  for (let i = 0, len = polyline.length; i < len; i++) {\n    const p1 = polyline[i];\n    // Using ternary instead of % (mod) operator to make it faster\n    const p2Index = i === len - 1 ? 0 : i + 1;\n    const p2 = polyline[p2Index];\n\n    const aX = p1[0] - refPoint[0];\n    const aY = p1[1] - refPoint[1];\n    const aZ = p1[2] - refPoint[2];\n    const bX = p2[0] - refPoint[0];\n    const bY = p2[1] - refPoint[1];\n    const bZ = p2[2] - refPoint[2];\n\n    // Cross product without calling vec3.cross() for better performance\n    vecArea[0] += aY * bZ - aZ * bY;\n    vecArea[1] += aZ * bX - aX * bZ;\n    vecArea[2] += aX * bY - aY * bX;\n  }\n\n  // Divide by two because cross product returns two times the area for each triangle\n  vec3.scale(vecArea, vecArea, 0.5);\n\n  // The magnitude of the vector is the area of the polyline\n  return <Types.Point3>vecArea;\n}\n\n/**\n * Calculate the normal of a 3D planar polyline\n * @param polyline - Planar polyline in 3D space\n * @returns Normal of the 3D planar polyline\n */\nexport default function getNormal3(polyline: Types.Point3[]): Types.Point3 {\n  const vecArea = _getAreaVector(polyline);\n\n  return vec3.normalize(vecArea, vecArea) as Types.Point3;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\nimport getLinesIntersection from './getLinesIntersection';\n\n/**\n * Returns all intersections points between a line segment and a polyline\n */\nexport default function getLineSegmentIntersectionsCoordinates(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2[] {\n  const result = [];\n  const polylineIndexes = getLineSegmentIntersectionsIndexes(\n    points,\n    p1,\n    q1,\n    closed\n  );\n\n  for (let i = 0; i < polylineIndexes.length; i++) {\n    const p2 = points[polylineIndexes[i][0]];\n    const q2 = points[polylineIndexes[i][1]];\n    const intersection = getLinesIntersection(p1, q1, p2, q2);\n    result.push(intersection);\n  }\n\n  return result;\n}\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the closest value.\n * @param points - Polyline points\n * @param p1 - Start point of the line segment\n * @param q1 - End point of the line segment\n * @param closed - Test the intersection against the line that connects the first to the last when closed\n * @returns The closest line segment from polyline that intersects the line segment [p1, q1]\n */\nexport default function getClosestLineSegmentIntersection(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): { segment: Types.Point2; distance: number } | undefined {\n  let initialQ2Index;\n  let p2Index;\n\n  if (closed) {\n    p2Index = points.length - 1;\n    initialQ2Index = 0;\n  } else {\n    p2Index = 0;\n    initialQ2Index = 1;\n  }\n\n  const intersections = [];\n\n  for (let q2Index = initialQ2Index; q2Index < points.length; q2Index++) {\n    const p2 = points[p2Index];\n    const q2 = points[q2Index];\n\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n      intersections.push([p2Index, q2Index]);\n    }\n\n    p2Index = q2Index;\n  }\n\n  if (intersections.length === 0) {\n    return;\n  }\n\n  // Find intersection closest to the start point\n  const distances = [];\n\n  intersections.forEach((intersection) => {\n    const intersectionPoints = [\n      points[intersection[0]],\n      points[intersection[1]],\n    ];\n\n    const midpoint = [\n      (intersectionPoints[0][0] + intersectionPoints[1][0]) / 2,\n      (intersectionPoints[0][1] + intersectionPoints[1][1]) / 2,\n    ];\n\n    distances.push(vec2.distance(<vec2>midpoint, p1));\n  });\n\n  const minDistance = Math.min(...distances);\n  const indexOfMinDistance = distances.indexOf(minDistance);\n\n  return {\n    segment: intersections[indexOfMinDistance],\n    distance: minDistance,\n  };\n}\n","import { StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nconst EPSILON = 1e-3;\n\n/**\n * Gets the desired spacing for points in the polyline for the\n * `PlanarFreehandROITool` in the x and y canvas directions, as well as\n * returning these canvas directions in world space.\n *\n * @param viewport - The Cornerstone3D `StackViewport` or `VolumeViewport`.\n * @param subPixelResolution - The number to divide the image pixel spacing by\n * to get the sub pixel spacing. E.g. `10` will return spacings 10x smaller than\n * the native image spacing.\n * @returns The spacings of the X and Y directions, and the 3D directions of the\n * x and y directions.\n */\nconst getSubPixelSpacingAndXYDirections = (\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  subPixelResolution: number\n): { spacing: Types.Point2; xDir: Types.Point3; yDir: Types.Point3 } => {\n  let spacing;\n  let xDir;\n  let yDir;\n\n  if (viewport instanceof StackViewport) {\n    // Check XY directions\n    const imageData = viewport.getImageData();\n\n    xDir = imageData.direction.slice(0, 3);\n    yDir = imageData.direction.slice(3, 6);\n\n    spacing = imageData.spacing;\n  } else {\n    // Check volume directions\n    const imageData = viewport.getImageData();\n    const { direction, spacing: volumeSpacing } = imageData;\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    // Calculate size of spacing vector in normal direction\n    const iVector = direction.slice(0, 3) as Types.Point3;\n    const jVector = direction.slice(3, 6) as Types.Point3;\n    const kVector = direction.slice(6, 9) as Types.Point3;\n\n    const viewRight = vec3.create(); // Get the X direction of the viewport\n\n    vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n    const absViewRightDotI = Math.abs(vec3.dot(viewRight, iVector));\n    const absViewRightDotJ = Math.abs(vec3.dot(viewRight, jVector));\n    const absViewRightDotK = Math.abs(vec3.dot(viewRight, kVector));\n\n    // Get X spacing\n    let xSpacing;\n    if (Math.abs(1 - absViewRightDotI) < EPSILON) {\n      xSpacing = volumeSpacing[0];\n      xDir = iVector;\n    } else if (Math.abs(1 - absViewRightDotJ) < EPSILON) {\n      xSpacing = volumeSpacing[1];\n      xDir = jVector;\n    } else if (Math.abs(1 - absViewRightDotK) < EPSILON) {\n      xSpacing = volumeSpacing[2];\n      xDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    const absViewUpDotI = Math.abs(vec3.dot(viewUp, iVector));\n    const absViewUpDotJ = Math.abs(vec3.dot(viewUp, jVector));\n    const absViewUpDotK = Math.abs(vec3.dot(viewUp, kVector));\n\n    // Get Y spacing\n    let ySpacing;\n    if (Math.abs(1 - absViewUpDotI) < EPSILON) {\n      ySpacing = volumeSpacing[0];\n      yDir = iVector;\n    } else if (Math.abs(1 - absViewUpDotJ) < EPSILON) {\n      ySpacing = volumeSpacing[1];\n      yDir = jVector;\n    } else if (Math.abs(1 - absViewUpDotK) < EPSILON) {\n      ySpacing = volumeSpacing[2];\n      yDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    spacing = [xSpacing, ySpacing];\n  }\n\n  const subPixelSpacing: Types.Point2 = [\n    spacing[0] / subPixelResolution,\n    spacing[1] / subPixelResolution,\n  ];\n\n  return { spacing: subPixelSpacing, xDir, yDir };\n};\n\nexport default getSubPixelSpacingAndXYDirections;\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Returns true if points `p1` and `p2` are within `closeContourProximity`.\n */\nconst pointsAreWithinCloseContourProximity = (\n  p1: Types.Point2,\n  p2: Types.Point2,\n  closeContourProximity: number\n): boolean => {\n  return vec2.dist(p1, p2) < closeContourProximity;\n};\n\nexport default pointsAreWithinCloseContourProximity;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec2, vec3 } from 'gl-matrix';\nimport { PlanarFreehandROICommonData } from './planarFreehandROIInternalTypes';\n\n/**\n * Adds one or more points to the array at a resolution defined by the underlying image.\n */\nconst addCanvasPointsToArray = (\n  element: HTMLDivElement,\n  canvasPoints: Types.Point2[],\n  newCanvasPoint: Types.Point2,\n  commonData: PlanarFreehandROICommonData\n): number => {\n  const { xDir, yDir, spacing } = commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  if (!canvasPoints.length) {\n    canvasPoints.push(newCanvasPoint);\n    console.log('>>>>> !canvasPoints. :: RETURN');\n    return 1;\n  }\n\n  const lastWorldPos = viewport.canvasToWorld(\n    canvasPoints[canvasPoints.length - 1]\n  );\n  const newWorldPos = viewport.canvasToWorld(newCanvasPoint);\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, newWorldPos, lastWorldPos);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  const numPointsToAdd = Math.max(\n    Math.floor(xDist / spacing[0]),\n    Math.floor(yDist / spacing[0])\n  );\n\n  if (numPointsToAdd > 1) {\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n\n    const canvasDist = vec2.dist(lastCanvasPoint, newCanvasPoint);\n\n    const canvasDir = vec2.create();\n\n    vec2.subtract(canvasDir, newCanvasPoint, lastCanvasPoint);\n\n    vec2.set(canvasDir, canvasDir[0] / canvasDist, canvasDir[1] / canvasDist);\n\n    const distPerPoint = canvasDist / numPointsToAdd;\n\n    for (let i = 1; i <= numPointsToAdd; i++) {\n      canvasPoints.push([\n        lastCanvasPoint[0] + distPerPoint * canvasDir[0] * i,\n        lastCanvasPoint[1] + distPerPoint * canvasDir[1] * i,\n      ]);\n    }\n  } else {\n    canvasPoints.push(newCanvasPoint);\n  }\n\n  return numPointsToAdd;\n};\n\nexport default addCanvasPointsToArray;\n","import type { Types } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\n\n/**\n * Returns `true` if the point `p` can project onto point (`p1`, `p2`), and if\n * this projected point is less than `proximity` units away.\n */\nconst pointCanProjectOnLine = (\n  p: Types.Point2,\n  p1: Types.Point2,\n  p2: Types.Point2,\n  proximity: number\n): boolean => {\n  // Perfom checks in order of computational complexity.\n  const p1p = [p[0] - p1[0], p[1] - p1[1]];\n  const p1p2 = [p2[0] - p1[0], p2[1] - p1[1]];\n\n  const dot = p1p[0] * p1p2[0] + p1p[1] * p1p2[1];\n\n  // Dot product needs to be positive to be a candidate for projection onto line segment.\n  if (dot < 0) {\n    return false;\n  }\n\n  const p1p2Mag = Math.sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1]);\n\n  if (p1p2Mag === 0) {\n    return false;\n  }\n\n  const projectionVectorMag = dot / p1p2Mag;\n  const p1p2UnitVector = [p1p2[0] / p1p2Mag, p1p2[1] / p1p2Mag];\n  const projectionVector = [\n    p1p2UnitVector[0] * projectionVectorMag,\n    p1p2UnitVector[1] * projectionVectorMag,\n  ];\n  const projectionPoint = <Types.Point2>[\n    p1[0] + projectionVector[0],\n    p1[1] + projectionVector[1],\n  ];\n\n  const distance = vec2.distance(p, projectionPoint);\n\n  if (distance > proximity) {\n    // point is too far away.\n    return false;\n  }\n\n  // Check projects onto line segment.\n  if (vec2.distance(p1, projectionPoint) > vec2.distance(p1, p2)) {\n    return false;\n  }\n\n  return true;\n};\n\nexport default pointCanProjectOnLine;\n","// Pulled from source: https://github.com/w8r/liang-barsky\n// MIT Licensed.\n\n/**\n * Fast, destructive implementation of Liang-Barsky line clipping algorithm.\n * It clips a 2D segment by a rectangle.\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n */\n\nconst EPSILON = 1e-6;\nconst INSIDE = 1;\nconst OUTSIDE = 0;\n\nfunction clipT(num, denom, c) {\n  const [tE, tL] = c;\n  if (Math.abs(denom) < EPSILON) {\n    return num < 0;\n  }\n  const t = num / denom;\n\n  if (denom > 0) {\n    if (t > tL) {\n      return 0;\n    }\n    if (t > tE) {\n      c[0] = t;\n    }\n  } else {\n    if (t < tE) {\n      return 0;\n    }\n    if (t < tL) {\n      c[1] = t;\n    }\n  }\n  return 1;\n}\n\n/**\n * @param  {Point} a\n * @param  {Point} b\n * @param  {BoundingBox} box [xmin, ymin, xmax, ymax]\n * @param  {Point?} [da]\n * @param  {Point?} [db]\n * @return {number}\n */\nexport default function clip(a, b, box, da?, db?) {\n  const [x1, y1] = a;\n  const [x2, y2] = b;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n\n  if (da === undefined || db === undefined) {\n    da = a;\n    db = b;\n  } else {\n    da[0] = a[0];\n    da[1] = a[1];\n    db[0] = b[0];\n    db[1] = b[1];\n  }\n\n  if (\n    Math.abs(dx) < EPSILON &&\n    Math.abs(dy) < EPSILON &&\n    x1 >= box[0] &&\n    x1 <= box[2] &&\n    y1 >= box[1] &&\n    y1 <= box[3]\n  ) {\n    return INSIDE;\n  }\n\n  const c = [0, 1];\n  if (\n    clipT(box[0] - x1, dx, c) &&\n    clipT(x1 - box[2], -dx, c) &&\n    clipT(box[1] - y1, dy, c) &&\n    clipT(y1 - box[3], -dy, c)\n  ) {\n    const [tE, tL] = c;\n    if (tL < 1) {\n      db[0] = x1 + tL * dx;\n      db[1] = y1 + tL * dy;\n    }\n    if (tE > 0) {\n      da[0] += tE * dx;\n      da[1] += tE * dy;\n    }\n    return INSIDE;\n  }\n  return OUTSIDE;\n}\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n/**\n * Returns a point based on some criteria (e.g., minimum or maximum intensity) in\n * the line of sight (on the line between the passed worldPosition and camera position).\n * It iterated over the points with a step size on the line.\n *\n * @param viewport - Volume viewport\n * @param worldPos - World coordinates of the clicked location\n * @param targetVolumeId - target Volume ID in the viewport\n * @param criteriaFunction - A function that returns the point if it passes a certain\n * written logic, for instance, it can be a maxValue function that keeps the\n * records of all intensity values, and only return the point if its intensity\n * is greater than the maximum intensity of the points passed before.\n * @param stepsSize - Percentage of the spacing in the normal direction, default value\n * is 0.25 which means steps = 1/4 of the spacing in the normal direction.\n * @returns the World pos of the point that passes the criteriaFunction\n */\nexport default function getPointInLineOfSightWithCriteria(\n  viewport: Types.IVolumeViewport,\n  worldPos: Types.Point3,\n  targetVolumeId: string,\n  criteriaFunction: (intensity: number, point: Types.Point3) => Types.Point3,\n  stepSize = 0.25\n): Types.Point3 {\n  // 1. Getting the camera from the event details\n  const camera = viewport.getCamera();\n  const { position: cameraPosition } = camera;\n\n  // 2. Calculating the spacing in the normal direction, this will get\n  // used as the step size for iterating over the points in the line of sight\n  const { spacingInNormalDirection } =\n    csUtils.getTargetVolumeAndSpacingInNormalDir(\n      viewport,\n      camera,\n      targetVolumeId\n    );\n  // 2.1 Making sure, we are not missing any point\n  const step = spacingInNormalDirection * stepSize;\n\n  // 3. Getting the bounds of the viewports. Search for brightest point is\n  // limited to the visible bound\n  // Todo: this might be a problem since bounds will change to spatial bounds.\n  const bounds = viewport.getBounds();\n  const xMin = bounds[0];\n  const xMax = bounds[1];\n\n  // 5. Calculating the line, we use a parametric line definition\n  const vector = <Types.Point3>[0, 0, 0];\n\n  // 5.1 Point coordinate on the line\n  let point = <Types.Point3>[0, 0, 0];\n\n  // 5.2 Calculating the line direction, and storing in vector\n  vtkMath.subtract(worldPos, cameraPosition, vector);\n\n  let pickedPoint;\n\n  // 6. Iterating over the line from the lower bound to the upper bound, with the\n  // specified step size\n  for (let pointT = xMin; pointT <= xMax; pointT = pointT + step) {\n    // 6.1 Calculating the point x location\n    point = [pointT, 0, 0];\n    // 6.2 Calculating the point y,z location based on the line equation\n    const t = (pointT - cameraPosition[0]) / vector[0];\n    point[1] = t * vector[1] + cameraPosition[1];\n    point[2] = t * vector[2] + cameraPosition[2];\n\n    // 6.3 Checking if the points is inside the bounds\n    if (_inBounds(point, bounds)) {\n      // 6.4 Getting the intensity of the point\n      const intensity = viewport.getIntensityFromWorld(point);\n      // 6.5 Passing the intensity to the maximum value functions which decides\n      // whether the current point is of interest based on some criteria\n      const pointToPick = criteriaFunction(intensity, point);\n      if (pointToPick) {\n        pickedPoint = pointToPick;\n      }\n    }\n  }\n\n  return pickedPoint;\n}\n\n/**\n * Returns whether the point in the world is inside the bounds of the viewport\n * @param point - coordinates in the world\n * @returns boolean\n */\nconst _inBounds = function (\n  point: Types.Point3,\n  bounds: Array<number>\n): boolean {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  return (\n    point[0] > xMin &&\n    point[0] < xMax &&\n    point[1] > yMin &&\n    point[1] < yMax &&\n    point[2] > zMin &&\n    point[2] < zMax\n  );\n};\n","import { vec3 } from 'gl-matrix';\n\n/**\n * Checks if a plane intersects with an Axis-Aligned Bounding Box (AABB).\n *\n * @param origin - The origin point of the plane.\n * @param normal - The normal vector of the plane.\n * @param minX - The minimum x-coordinate of the AABB.\n * @param minY - The minimum y-coordinate of the AABB.\n * @param minZ - The minimum z-coordinate of the AABB.\n * @param maxX - The maximum x-coordinate of the AABB.\n * @param maxY - The maximum y-coordinate of the AABB.\n * @param maxZ - The maximum z-coordinate of the AABB.\n * @returns A boolean indicating whether the plane intersects with the AABB.\n */\nexport const isPlaneIntersectingAABB = (\n  origin,\n  normal,\n  minX,\n  minY,\n  minZ,\n  maxX,\n  maxY,\n  maxZ\n) => {\n  const vertices = [\n    vec3.fromValues(minX, minY, minZ),\n    vec3.fromValues(maxX, minY, minZ),\n    vec3.fromValues(minX, maxY, minZ),\n    vec3.fromValues(maxX, maxY, minZ),\n    vec3.fromValues(minX, minY, maxZ),\n    vec3.fromValues(maxX, minY, maxZ),\n    vec3.fromValues(minX, maxY, maxZ),\n    vec3.fromValues(maxX, maxY, maxZ),\n  ];\n\n  const normalVec = vec3.fromValues(normal[0], normal[1], normal[2]);\n  const originVec = vec3.fromValues(origin[0], origin[1], origin[2]);\n\n  // Compute the distance from the plane to the origin using vec3.dot\n  const planeDistance = -vec3.dot(normalVec, originVec);\n\n  // Check if all vertices are on the same side of the plane\n  let initialSign = null;\n  for (const vertex of vertices) {\n    // Calculate distance using vec3.dot to simplify the equation\n    const distance = vec3.dot(normalVec, vertex) + planeDistance;\n    if (initialSign === null) {\n      initialSign = Math.sign(distance);\n    } else if (Math.sign(distance) !== initialSign) {\n      return true; // Found a vertex on the other side, so it intersects\n    }\n  }\n\n  return false;\n};\n","import filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nimport getWorldWidthAndHeightFromCorners from './getWorldWidthAndHeightFromCorners';\nimport filterAnnotationsForDisplay from './filterAnnotationsForDisplay';\nimport getPointInLineOfSightWithCriteria from './getPointInLineOfSightWithCriteria';\nimport { isPlaneIntersectingAABB } from './isPlaneIntersectingAABB';\n\nexport default {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n  isPlaneIntersectingAABB,\n};\n\nexport {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n  isPlaneIntersectingAABB,\n};\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the orientation of the vector in the patient coordinate system.\n * @public\n *\n * @param vector - Input array\n * @returns The orientation in the patient coordinate system.\n */\nexport default function getOrientationStringLPS(vector: Types.Point3): string {\n  // Thanks to David Clunie\n  // https://sites.google.com/site/dicomnotes/\n\n  let orientation = '';\n  const orientationX = vector[0] < 0 ? 'R' : 'L';\n  const orientationY = vector[1] < 0 ? 'A' : 'P';\n  const orientationZ = vector[2] < 0 ? 'F' : 'H';\n\n  // Should probably make this a function vector3.abs\n  const abs = [Math.abs(vector[0]), Math.abs(vector[1]), Math.abs(vector[2])];\n\n  const MIN = 0.0001;\n\n  for (let i = 0; i < 3; i++) {\n    if (abs[0] > MIN && abs[0] > abs[1] && abs[0] > abs[2]) {\n      orientation += orientationX;\n      abs[0] = 0;\n    } else if (abs[1] > MIN && abs[1] > abs[0] && abs[1] > abs[2]) {\n      orientation += orientationY;\n      abs[1] = 0;\n    } else if (abs[2] > MIN && abs[2] > abs[0] && abs[2] > abs[1]) {\n      orientation += orientationZ;\n      abs[2] = 0;\n    } else if (abs[0] > MIN && abs[1] > MIN && abs[0] === abs[1]) {\n      orientation += orientationX + orientationY;\n      abs[0] = 0;\n      abs[1] = 0;\n    } else if (abs[0] > MIN && abs[2] > MIN && abs[0] === abs[2]) {\n      orientation += orientationX + orientationZ;\n      abs[0] = 0;\n      abs[2] = 0;\n    } else if (abs[1] > MIN && abs[2] > MIN && abs[1] === abs[2]) {\n      orientation += orientationY + orientationZ;\n      abs[1] = 0;\n      abs[2] = 0;\n    } else {\n      break;\n    }\n  }\n\n  return orientation;\n}\n","/**\n * Inverts an orientation string.\n * @public\n *\n * @param orientationString - The orientation.\n * @returns The inverted orientationString.\n */\nexport default function invertOrientationStringLPS(\n  orientationString: string\n): string {\n  let inverted = orientationString.replace('H', 'f');\n\n  inverted = inverted.replace('F', 'h');\n  inverted = inverted.replace('R', 'l');\n  inverted = inverted.replace('L', 'r');\n  inverted = inverted.replace('A', 'p');\n  inverted = inverted.replace('P', 'a');\n  inverted = inverted.toUpperCase();\n\n  return inverted;\n}\n","/**\n * CINE Tool Events\n */\nenum Events {\n  CLIP_STOPPED = 'CORNERSTONE_CINE_TOOL_STOPPED',\n  CLIP_STARTED = 'CORNERSTONE_CINE_TOOL_STARTED',\n}\n\nexport default Events;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { CINETypes } from '../../types';\n\nconst state: Record<string, CINETypes.ToolData> = {};\n\nfunction addToolState(element: HTMLDivElement, data: CINETypes.ToolData): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  state[viewportId] = data;\n}\n\nfunction getToolState(element: HTMLDivElement): CINETypes.ToolData | undefined {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  return state[viewportId];\n}\n\nfunction getToolStateByViewportId(\n  viewportId: string\n): CINETypes.ToolData | undefined {\n  return state[viewportId];\n}\n\nexport { addToolState, getToolState, getToolStateByViewportId };\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport {\n  utilities as csUtils,\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  cache,\n  BaseVolumeViewport,\n  Enums,\n} from '@cornerstonejs/core';\n\nimport { Types } from '@cornerstonejs/core';\nimport CINE_EVENTS from './events';\nimport { addToolState, getToolState, getToolStateByViewportId } from './state';\nimport { CINETypes } from '../../types';\nimport scroll from '../scroll';\n\nconst { ViewportStatus } = Enums;\nconst { triggerEvent } = csUtils;\n\nconst debounced = true;\nconst dynamicVolumesPlayingMap = new Map();\n\n/**\n * Starts playing a clip or adjusts the frame rate of an already playing clip.  framesPerSecond is\n * optional and defaults to 30 if not specified.  A negative framesPerSecond will play the clip in reverse.\n * The element must be a stack of images\n * @param element - HTML Element\n * @param framesPerSecond - Number of frames per second\n */\nfunction playClip(\n  element: HTMLDivElement,\n  playClipOptions: CINETypes.PlayClipOptions\n): void {\n  let playClipTimeouts;\n  let playClipIsTimeVarying;\n\n  if (element === undefined) {\n    throw new Error('playClip: element must not be undefined');\n  }\n\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error(\n      'playClip: element must be a valid Cornerstone enabled element'\n    );\n  }\n\n  if (!playClipOptions) {\n    playClipOptions = {};\n  }\n\n  // 4D Cine is enabled by default\n  playClipOptions.dynamicCineEnabled =\n    playClipOptions.dynamicCineEnabled ?? true;\n\n  const { viewport } = enabledElement;\n  const volume = _getVolumeFromViewport(viewport);\n  const playClipContext = _createCinePlayContext(viewport, playClipOptions);\n  let playClipData = getToolState(element);\n\n  const isDynamicCinePlaying =\n    playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume();\n\n  // If user is trying to play CINE for a 4D volume it first needs\n  // to stop CINE that has may be playing for any other viewport.\n  if (isDynamicCinePlaying) {\n    _stopDynamicVolumeCine(element);\n  }\n\n  if (!playClipData) {\n    playClipData = {\n      intervalId: undefined,\n      framesPerSecond: 30,\n      lastFrameTimeStamp: undefined,\n      ignoreFrameTimeVector: false,\n      usingFrameTimeVector: false,\n      frameTimeVector: playClipOptions.frameTimeVector ?? undefined,\n      speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,\n      reverse: playClipOptions.reverse ?? false,\n      loop: playClipOptions.loop ?? true,\n    };\n    addToolState(element, playClipData);\n  } else {\n    // Make sure the specified clip is not running before any property update.\n    // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n    // prevent stopping a 4D CINE in case it is playing on another viewport.\n    _stopClip(element, {\n      stopDynamicCine: !isDynamicCinePlaying,\n      viewportId: viewport.id,\n    });\n  }\n\n  playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;\n\n  // If a framesPerSecond is specified and is valid, update the playClipData now\n  if (\n    playClipOptions.framesPerSecond < 0 ||\n    playClipOptions.framesPerSecond > 0\n  ) {\n    playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);\n    playClipData.reverse = playClipData.framesPerSecond < 0;\n    // If framesPerSecond is given, frameTimeVector will be ignored...\n    playClipData.ignoreFrameTimeVector = true;\n  }\n\n  // Determine if frame time vector should be used instead of a fixed frame rate...\n  if (\n    playClipData.ignoreFrameTimeVector !== true &&\n    playClipData.frameTimeVector &&\n    playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&\n    playClipContext.frameTimeVectorEnabled\n  ) {\n    const { timeouts, isTimeVarying } = _getPlayClipTimeouts(\n      playClipData.frameTimeVector,\n      playClipData.speed\n    );\n\n    playClipTimeouts = timeouts;\n    playClipIsTimeVarying = isTimeVarying;\n  }\n\n  // This function encapsulates the frame rendering logic...\n  const playClipAction = () => {\n    const { numScrollSteps, currentStepIndex } = playClipContext;\n    let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n    const newStepIndexOutOfRange =\n      newStepIndex < 0 || newStepIndex >= numScrollSteps;\n\n    if (!playClipData.loop && newStepIndexOutOfRange) {\n      // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n      // prevent stopping a 4D CINE in case it is playing on another viewport.\n      _stopClip(element, {\n        stopDynamicCine: !isDynamicCinePlaying,\n        viewportId: viewport.id,\n      });\n\n      const eventDetail = { element };\n\n      triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, eventDetail);\n      return;\n    }\n\n    // Loop around if newStepIndex is out of range\n    if (newStepIndex >= numScrollSteps) {\n      newStepIndex = 0;\n    } else if (newStepIndex < 0) {\n      newStepIndex = numScrollSteps - 1;\n    }\n\n    const delta = newStepIndex - currentStepIndex;\n\n    if (delta) {\n      playClipContext.scroll(delta);\n    }\n  };\n\n  if (isDynamicCinePlaying) {\n    dynamicVolumesPlayingMap.set(volume.volumeId, element);\n  }\n\n  // If playClipTimeouts array is available, not empty and its elements are NOT uniform ...\n  // ... (at least one timeout is different from the others), use alternate setTimeout implementation\n  if (\n    playClipTimeouts &&\n    playClipTimeouts.length > 0 &&\n    playClipIsTimeVarying\n  ) {\n    playClipData.usingFrameTimeVector = true;\n    playClipData.intervalId = window.setTimeout(\n      function playClipTimeoutHandler() {\n        playClipData.intervalId = window.setTimeout(\n          playClipTimeoutHandler,\n          playClipTimeouts[playClipContext.currentStepIndex]\n        );\n        playClipAction();\n      },\n      0\n    );\n  } else {\n    // ... otherwise user setInterval implementation which is much more efficient.\n    playClipData.usingFrameTimeVector = false;\n    playClipData.intervalId = window.setInterval(\n      playClipAction,\n      1000 / Math.abs(playClipData.framesPerSecond)\n    );\n  }\n\n  const eventDetail = {\n    element,\n  };\n\n  triggerEvent(element, CINE_EVENTS.CLIP_STARTED, eventDetail);\n}\n\n/**\n * Stops an already playing clip.\n * @param element - HTML Element\n */\nfunction stopClip(element: HTMLDivElement, options = {} as any): void {\n  _stopClip(element, {\n    stopDynamicCine: true,\n    ...options,\n  });\n}\n\nfunction _stopClip(\n  element: HTMLDivElement,\n  options = { stopDynamicCine: true, viewportId: undefined }\n) {\n  const { stopDynamicCine, viewportId } = options;\n  const enabledElement = getEnabledElement(element);\n\n  let toolState;\n  if (!enabledElement) {\n    if (viewportId) {\n      toolState = getToolStateByViewportId(viewportId);\n    } else {\n      return;\n    }\n  } else {\n    const { viewport } = enabledElement;\n    toolState = getToolState(viewport.element);\n  }\n\n  if (toolState) {\n    _stopClipWithData(toolState);\n  }\n\n  if (\n    stopDynamicCine &&\n    enabledElement?.viewport instanceof BaseVolumeViewport\n  ) {\n    _stopDynamicVolumeCine(element);\n  }\n}\n\n/**\n * [private] Stops any CINE playing for the dynamic volume loaded on this viewport\n * @param element - HTML Element\n */\nfunction _stopDynamicVolumeCine(element) {\n  const { viewport } = getEnabledElement(element);\n  const volume = _getVolumeFromViewport(viewport);\n\n  // If the current viewport has a 4D volume loaded it may be playing\n  // if it is also loaded on another viewport and user has started CINE\n  // for that one. This guarantees the other viewport will also be stopped.\n  if (volume?.isDynamicVolume()) {\n    const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);\n\n    dynamicVolumesPlayingMap.delete(volume.volumeId);\n\n    if (dynamicCineElement && dynamicCineElement !== element) {\n      stopClip(<HTMLDivElement>dynamicCineElement);\n    }\n  }\n}\n\n/**\n * [private] Turns a Frame Time Vector (0018,1065) array into a normalized array of timeouts. Each element\n * ... of the resulting array represents the amount of time each frame will remain on the screen.\n * @param vector - A Frame Time Vector (0018,1065) as specified in section C.7.6.5.1.2 of DICOM standard.\n * @param speed - A speed factor which will be applied to each element of the resulting array.\n * @returns An array with timeouts for each animation frame.\n */\nfunction _getPlayClipTimeouts(vector: number[], speed: number) {\n  let i;\n  let sample;\n  let delay;\n  let sum = 0;\n  const limit = vector.length;\n  const timeouts = [];\n\n  // Initialize time varying to false\n  let isTimeVarying = false;\n\n  if (typeof speed !== 'number' || speed <= 0) {\n    speed = 1;\n  }\n\n  // First element of a frame time vector must be discarded\n  for (i = 1; i < limit; i++) {\n    // eslint-disable-next-line no-bitwise\n    delay = (Number(vector[i]) / speed) | 0; // Integral part only\n    timeouts.push(delay);\n    if (i === 1) {\n      // Use first item as a sample for comparison\n      sample = delay;\n    } else if (delay !== sample) {\n      isTimeVarying = true;\n    }\n\n    sum += delay;\n  }\n\n  if (timeouts.length > 0) {\n    if (isTimeVarying) {\n      // If it's a time varying vector, make the last item an average...\n      // eslint-disable-next-line no-bitwise\n      delay = (sum / timeouts.length) | 0;\n    } else {\n      delay = timeouts[0];\n    }\n\n    timeouts.push(delay);\n  }\n\n  return { timeouts, isTimeVarying };\n}\n\n/**\n * [private] Performs the heavy lifting of stopping an ongoing animation.\n * @param element - HTML Element\n * @param playClipData - The data from playClip that needs to be stopped.\n */\nfunction _stopClipWithData(playClipData) {\n  const id = playClipData.intervalId;\n\n  if (typeof id !== 'undefined') {\n    playClipData.intervalId = undefined;\n    if (playClipData.usingFrameTimeVector) {\n      clearTimeout(id);\n    } else {\n      clearInterval(id);\n    }\n  }\n}\n\nfunction _getVolumesFromViewport(viewport): Types.IImageVolume[] {\n  return viewport\n    .getActors()\n    .map((actor) => cache.getVolume(actor.uid))\n    .filter((volume) => !!volume);\n}\n\nfunction _getVolumeFromViewport(viewport): Types.IImageVolume {\n  const volumes = _getVolumesFromViewport(viewport);\n  const dynamicVolume = volumes.find((volume) => volume.isDynamicVolume());\n\n  return dynamicVolume ?? volumes[0];\n}\n\nfunction _createStackViewportCinePlayContext(\n  viewport: StackViewport,\n  waitForRendered: number\n): CINETypes.CinePlayContext {\n  const imageIds = viewport.getImageIds();\n\n  return {\n    get numScrollSteps(): number {\n      return imageIds.length;\n    },\n    get currentStepIndex(): number {\n      return viewport.getTargetImageIdIndex();\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // It is always in acquired orientation\n      return true;\n    },\n    waitForRenderedCount: 0,\n    scroll(delta: number): void {\n      if (\n        this.waitForRenderedCount <= waitForRendered &&\n        viewport.viewportStatus !== ViewportStatus.RENDERED\n      ) {\n        this.waitForRenderedCount++;\n        return;\n      }\n      this.waitForRenderedCount = 0;\n      scroll(viewport, { delta, debounceLoading: debounced });\n    },\n  };\n}\n\nfunction _createVolumeViewportCinePlayContext(\n  viewport: VolumeViewport,\n  volume: Types.IImageVolume\n): CINETypes.CinePlayContext {\n  const { volumeId } = volume;\n  const cachedScrollInfo = {\n    viewPlaneNormal: vec3.create(),\n    scrollInfo: null,\n  };\n\n  const getScrollInfo = () => {\n    const camera = viewport.getCamera();\n    const updateCache =\n      !cachedScrollInfo.scrollInfo ||\n      !vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);\n\n    // Number of steps would change only after rotating the volume so it\n    // caches the result and recomputes only when necessary. Until it is\n    // rotated the current frame is updated locally\n    if (updateCache) {\n      const scrollInfo = csUtils.getVolumeViewportScrollInfo(\n        viewport,\n        volumeId\n      );\n\n      cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;\n      cachedScrollInfo.scrollInfo = scrollInfo;\n    }\n\n    return cachedScrollInfo.scrollInfo;\n  };\n\n  return {\n    get numScrollSteps(): number {\n      return getScrollInfo().numScrollSteps;\n    },\n    get currentStepIndex(): number {\n      return getScrollInfo().currentStepIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      const camera = viewport.getCamera();\n      const volumeViewPlaneNormal = volume.direction\n        .slice(6, 9)\n        .map((x) => -x) as Types.Point3;\n      const dot = vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);\n\n      // Check if the volume is in acquired orientation\n      // it may be flipped or rotated in plane\n      return glMatrix.equals(dot, 1);\n    },\n    scroll(delta: number): void {\n      getScrollInfo().currentStepIndex += delta;\n      scroll(viewport, { delta });\n    },\n  };\n}\n\nfunction _createDynamicVolumeViewportCinePlayContext(\n  volume: Types.IDynamicImageVolume\n): CINETypes.CinePlayContext {\n  return {\n    get numScrollSteps(): number {\n      return volume.numTimePoints;\n    },\n    get currentStepIndex(): number {\n      return volume.timePointIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // Looping throught time does not uses frameTimeVector\n      return false;\n    },\n    scroll(delta: number): void {\n      // Updating this property (setter) makes it move to the desired time point\n      volume.timePointIndex += delta;\n    },\n  };\n}\n\nfunction _createCinePlayContext(\n  viewport,\n  playClipOptions: CINETypes.PlayClipOptions\n): CINETypes.CinePlayContext {\n  if (viewport instanceof StackViewport) {\n    return _createStackViewportCinePlayContext(\n      viewport,\n      playClipOptions.waitForRendered ?? 30\n    );\n  }\n\n  if (viewport instanceof VolumeViewport) {\n    const volume = _getVolumeFromViewport(viewport);\n\n    if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {\n      return _createDynamicVolumeViewportCinePlayContext(\n        <Types.IDynamicImageVolume>volume\n      );\n    }\n\n    return _createVolumeViewportCinePlayContext(viewport, volume);\n  }\n\n  throw new Error('Unknown viewport type');\n}\n\nexport { playClip, stopClip };\n","export function basis(t1, v0, v1, v2, v3) {\n  var t2 = t1 * t1, t3 = t2 * t1;\n  return ((1 - 3 * t1 + 3 * t2 - t3) * v0\n      + (4 - 6 * t2 + 3 * t3) * v1\n      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2\n      + t3 * v3) / 6;\n}\n\nexport default function(values) {\n  var n = values.length - 1;\n  return function(t) {\n    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),\n        v1 = values[i],\n        v2 = values[i + 1],\n        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,\n        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;\n    return basis((t - i / n) * n, v0, v1, v2, v3);\n  };\n}\n","export default function(interpolator, n) {\n  var samples = new Array(n);\n  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));\n  return samples;\n}\n","import min from \"./min.js\";\n\nexport default function transpose(matrix) {\n  if (!(n = matrix.length)) return [];\n  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {\n    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n      row[j] = matrix[j][i];\n    }\n  }\n  return transpose;\n}\n\nfunction length(d) {\n  return d.length;\n}\n","import transpose from \"./transpose.js\";\n\nexport default function zip() {\n  return transpose(arguments);\n}\n","export default function min(values, valueof) {\n  let min;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value;\n      }\n    }\n  }\n  return min;\n}\n","import { Types } from '@cornerstonejs/core';\nimport { interpolatePoints } from './algorithms/bspline';\n\n/**\n * Returns a list of uniform distributed values. This list contains the max amount of values which has at least a minimum distance between two consecutive values.\n * minDistributionDistance means the min distance between two consecutive distributed values.\n * Closed interval contains the min/max values.\n *\n * Formula for reference\n * For given {x ∈ R | x ≥ 0} and {minDis ∈ R | minDis ≥ 0}, ∃ D(x) where D(x) ≥ a and D(x) ≤ b  =>\n *         |\n * D(x)  = |                  (b - a)\n *         |  round( ------------------------ * x  )   + a\n *         |                (b - a + 1)\n *         |        round( -----------  )\n *         |                 minDis\n */\nfunction getContinuousUniformDistributionValues(\n  minDistributionDistance: number,\n  closedInterval: [number, number]\n): number[] {\n  const result = [];\n  const [intervalIni, intervalEnd] = closedInterval;\n\n  const intervalSize = intervalEnd - intervalIni + 1;\n  const intensity = Math.floor(intervalSize / minDistributionDistance);\n\n  let x = 0;\n  let continuosDistributionValue =\n    Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n\n  while (continuosDistributionValue <= intervalEnd) {\n    result.push(continuosDistributionValue);\n    x++;\n    continuosDistributionValue =\n      Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n  }\n\n  return result;\n}\n\n/**\n * Interpolates a segment of points from iniIndex until endIndex.\n * The process of interpolation considers the param knotsRatioPercentage as being the percentage of points from Segment that are likely to be considered.\n * By default it uses b-spline algorithm.\n * The result total of points is equal to original points.\n */\nexport default function interpolateSegmentPoints(\n  points: (Types.Point2 | Types.Point3)[],\n  iniIndex: number,\n  endIndex: number,\n  knotsRatioPercentage: number\n): (Types.Point2 | Types.Point3)[] {\n  const segmentSize = endIndex - iniIndex + 1;\n\n  const amountOfKnots =\n    Math.floor((knotsRatioPercentage / 100) * segmentSize) ?? 1;\n  const minKnotDistance = Math.floor(segmentSize / amountOfKnots) ?? 1;\n\n  if (isNaN(segmentSize) || !segmentSize || !minKnotDistance) {\n    return points;\n  }\n\n  // segment should be at least the double of desired minKnot distance. This will ensure at there will enough knots to interpolate.\n  if (segmentSize / minKnotDistance < 2) {\n    return points;\n  }\n\n  const interpolationIniIndex = Math.max(0, iniIndex);\n  const interpolationEndIndex = Math.min(points.length - 1, endIndex);\n  const segmentPointsUnchangedBeg = points.slice(0, interpolationIniIndex);\n\n  const segmentPointsUnchangedEnd = points.slice(\n    interpolationEndIndex + 1,\n    points.length\n  );\n\n  const knotsIndexes = getContinuousUniformDistributionValues(minKnotDistance, [\n    interpolationIniIndex,\n    interpolationEndIndex,\n  ]);\n\n  const interpolatedPoints = interpolatePoints(points, knotsIndexes);\n\n  return [\n    ...segmentPointsUnchangedBeg,\n    ...interpolatedPoints,\n    ...segmentPointsUnchangedEnd,\n  ];\n}\n","import {\n  interpolateBasis as d3InterpolateBasis,\n  quantize as d3Quantize,\n} from 'd3-interpolate';\nimport { zip as d3Zip } from 'd3-array';\nimport { Types } from '@cornerstonejs/core';\n\nfunction isPoints3D(\n  points: (Types.Point2 | Types.Point3)[]\n): points is Types.Point3[] {\n  return (points as Types.Point3[])[0]?.length === 3;\n}\n\n/**\n * Returns an array of the originalPoints length containing the interpolated data.\n * It interpolates a set of points indexed by knotsIndexes.\n * That is, it DISCARDS all points except those in knotsIndexes. Then, a new set of points is created by using a b-spline on the remaining points, in order to re-create a new set of points.\n */\nexport function interpolatePoints(\n  originalPoints: (Types.Point2 | Types.Point3)[],\n  knotsIndexes: number[]\n): (Types.Point2 | Types.Point3)[] {\n  if (\n    !knotsIndexes ||\n    knotsIndexes.length === 0 ||\n    knotsIndexes.length === originalPoints.length\n  ) {\n    return originalPoints;\n  }\n\n  const n = knotsIndexes[knotsIndexes.length - 1] - knotsIndexes[0] + 1;\n  const xInterpolator = d3InterpolateBasis(\n    knotsIndexes.map((k) => originalPoints[k][0])\n  );\n  const yInterpolator = d3InterpolateBasis(\n    knotsIndexes.map((k) => originalPoints[k][1])\n  );\n\n  if (isPoints3D(originalPoints)) {\n    const zInterpolator = d3InterpolateBasis(\n      knotsIndexes.map((k) => originalPoints[k][2])\n    );\n    return <Types.Point3[]>(\n      d3Zip(\n        d3Quantize(xInterpolator, n),\n        d3Quantize(yInterpolator, n),\n        d3Quantize(zInterpolator, n)\n      )\n    );\n  } else {\n    return <Types.Point2[]>(\n      d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n))\n    );\n  }\n}\n","import { Types } from '@cornerstonejs/core';\nimport { PlanarFreehandROITool } from '../../tools';\nimport { ToolGroupManager } from '../../store';\nimport { PlanarFreehandROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\n\nfunction shouldPreventInterpolation(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation,\n  knotsRatioPercentage: number\n): boolean {\n  if (!annotation?.data?.polyline || knotsRatioPercentage <= 0) {\n    return true;\n  }\n\n  if (!enabledElement.viewport) {\n    return true;\n  }\n\n  const { renderingEngineId, viewportId, FrameOfReferenceUID } = enabledElement;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (annotation.metadata.FrameOfReferenceUID !== FrameOfReferenceUID) {\n    return true;\n  }\n\n  if (!toolGroup) {\n    return true;\n  }\n\n  const toolInstance = toolGroup.getToolInstance(annotation.metadata.toolName);\n\n  // strategy to prevent non PlanarFreehandTool\n  if (!(toolInstance instanceof PlanarFreehandROITool)) {\n    return true;\n  }\n\n  return (\n    toolInstance.isDrawing ||\n    toolInstance.isEditingOpen ||\n    toolInstance.isEditingClosed\n  );\n}\n/**\n * Interpolates a given annotation from a given enabledElement.\n * It mutates annotation param.\n * The param knotsRatioPercentage defines the percentage of points to be considered as knots on the interpolation process.\n * Interpolation will be skipped in case: annotation is not present in enabledElement (or there is no toolGroup associated with it), related tool is being modified.\n */\nexport default function smoothAnnotation(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation,\n  knotsRatioPercentage: number\n): boolean {\n  // prevent running while there is any tool annotation being modified\n  if (\n    shouldPreventInterpolation(enabledElement, annotation, knotsRatioPercentage)\n  ) {\n    return false;\n  }\n\n  const { viewport } = enabledElement;\n  // use only 2 dimensions on interpolation (what visually matters),\n  // otherwise a 3d interpolation might have a totally different output as it consider one more dimension.\n  const canvasPoints = annotation.data.contour.polyline.map(\n    viewport.worldToCanvas\n  );\n  const interpolatedCanvasPoints = <Types.Point2[]>(\n    interpolateSegmentPoints(\n      canvasPoints,\n      0,\n      canvasPoints.length,\n      knotsRatioPercentage\n    )\n  );\n\n  if (interpolatedCanvasPoints === canvasPoints) {\n    return false;\n  }\n\n  annotation.data.contour.polyline = interpolatedCanvasPoints.map(\n    viewport.canvasToWorld\n  );\n\n  return true;\n}\n","import smoothAnnotation from './smoothAnnotation';\n\nexport default {\n  smoothAnnotation,\n};\n\nexport { smoothAnnotation };\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\n\nconst { isEqual } = csUtils;\n\nconst iAxis = vec3.fromValues(1, 0, 0);\nconst jAxis = vec3.fromValues(0, 1, 0);\nconst kAxis = vec3.fromValues(0, 0, 1);\n\nconst axisList = [iAxis, jAxis, kAxis];\n\n/**\n * Determines whether a given rectangle in a 3D space (defined by its corner\n * points in IJK coordinates) is aligned with the IJK axes.\n * @param rectangleCornersIJK - The corner points of the rectangle in IJK coordinates\n * @returns True if the rectangle is aligned with the IJK axes, false otherwise\n */\nfunction isAxisAlignedRectangle(rectangleCornersIJK) {\n  const rectangleVec1 = vec3.subtract(\n    vec3.create(),\n    rectangleCornersIJK[0],\n    rectangleCornersIJK[1]\n  );\n\n  const rectangleVec2 = vec3.subtract(\n    vec3.create(),\n    rectangleCornersIJK[0],\n    rectangleCornersIJK[2]\n  );\n\n  // Calculate the angles with IJK axes for both vectors\n  const anglesVec1 = calculateAnglesWithAxes(rectangleVec1, axisList);\n  const anglesVec2 = calculateAnglesWithAxes(rectangleVec2, axisList);\n\n  // Check if all angles are aligned (0, 90, 180, or 270 degrees)\n  // we could do csUtils.isEqual(angle % 90, 0) but this is more explicit for reading\n  const isAligned = [...anglesVec1, ...anglesVec2].every(\n    (angle) =>\n      isEqual(angle, 0) ||\n      isEqual(angle, 90) ||\n      isEqual(angle, 180) ||\n      isEqual(angle, 270)\n  );\n\n  return isAligned;\n}\n\n// Function to calculate angle with IJK axes\nfunction calculateAnglesWithAxes(vec, axes) {\n  return axes.map((axis) => (vec3.angle(vec, axis) * 180) / Math.PI);\n}\n\nexport { isAxisAlignedRectangle };\n","import { getEnabledElement } from '@cornerstonejs/core';\n\nconst state: Record<number, any> = {};\n\nfunction addToolState(element: HTMLDivElement, data): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  state[viewportId] = data;\n}\n\nfunction getToolState(element: HTMLDivElement): any {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  return state[viewportId];\n}\n\nexport { addToolState, getToolState };\n","import { getEnabledElement, StackViewport, Enums } from '@cornerstonejs/core';\nimport { getToolState } from './state';\n\nexport const requestType = Enums.RequestType.Prefetch;\nexport const priority = 0;\n\nexport function range(lowEnd, highEnd) {\n  // Javascript version of Python's range function\n  // http://stackoverflow.com/questions/3895478/does-javascript-have-a-method-like-range-to-generate-an-array-based-on-suppl\n  lowEnd = Math.round(lowEnd) || 0;\n  highEnd = Math.round(highEnd) || 0;\n\n  const arr = [];\n  let c = highEnd - lowEnd + 1;\n\n  if (c <= 0) {\n    return arr;\n  }\n\n  while (c--) {\n    arr[c] = highEnd--;\n  }\n\n  return arr;\n}\n\nexport function nearestIndex(arr, x) {\n  // Return index of nearest values in array\n  // http://stackoverflow.com/questions/25854212/return-index-of-nearest-values-in-an-array\n  let low = 0;\n  let high = arr.length - 1;\n\n  arr.forEach((v, idx) => {\n    if (v < x) {\n      low = Math.max(idx, low);\n    } else if (v > x) {\n      high = Math.min(idx, high);\n    }\n  });\n\n  return { low, high };\n}\n\nexport function getStackData(element) {\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    // Can be not valid if the data is changed part way through prefetch\n    return null;\n  }\n\n  const { viewport } = enabledElement;\n\n  if (!(viewport instanceof StackViewport)) {\n    // we shouldn't throw error here, since the viewport might have\n    // changed from stack to volume during prefetch\n    console.warn(\n      'stackPrefetch: element must be a StackViewport, VolumeViewport stackPrefetch not yet implemented'\n    );\n\n    return null;\n  }\n\n  return {\n    currentImageIdIndex: viewport.getCurrentImageIdIndex(),\n    imageIds: viewport.getImageIds(),\n  };\n}\n\nexport function getPromiseRemovedHandler(element) {\n  return function (e) {\n    const eventData = e.detail;\n\n    // When an imagePromise has been pushed out of the cache, re-add its index\n    // It to the indicesToRequest list so that it will be retrieved later if the\n    // CurrentImageIdIndex is changed to an image nearby\n    let stackData;\n\n    try {\n      // It will throw an exception in some cases (eg: thumbnails)\n      stackData = getStackData(element);\n    } catch (error) {\n      return;\n    }\n\n    if (!stackData || !stackData.imageIds || stackData.imageIds.length === 0) {\n      return;\n    }\n\n    const stack = stackData;\n    const imageIdIndex = stack.imageIds.indexOf(eventData.imageId);\n\n    // Make sure the image that was removed is actually in this stack\n    // Before adding it to the indicesToRequest array\n    if (imageIdIndex < 0) {\n      return;\n    }\n\n    const stackPrefetchData = getToolState(element);\n\n    if (\n      !stackPrefetchData ||\n      !stackPrefetchData.data ||\n      !stackPrefetchData.data.length\n    ) {\n      return;\n    }\n\n    stackPrefetchData.indicesToRequest.push(imageIdIndex);\n  };\n}\n\nexport const clearFromImageIds = (stack) => {\n  const imageIdSet = new Set<string>(stack.imageIds);\n  return (requestDetails) =>\n    requestDetails.type !== requestType ||\n    !imageIdSet.has(requestDetails.additionalDetails.imageId);\n};\n","import {\n  imageLoader,\n  Enums,\n  eventTarget,\n  imageLoadPoolManager,\n  cache,\n  getConfiguration as getCoreConfiguration,\n} from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport {\n  getStackData,\n  requestType,\n  priority,\n  getPromiseRemovedHandler,\n  nearestIndex,\n  range,\n} from './stackPrefetchUtils';\n\nlet configuration = {\n  maxImagesToPrefetch: Infinity,\n  // Preserving the existing pool should be the default behaviour, as there might\n  // be a volume of the same series already being loaded in the pool, and we don't want\n  // to cancel it middle of the way when the other stack viewport mounts. Worst case scenario\n  // there will be a few extra images in the pool but by the time that their turn comes\n  // we will have already loaded the volume and it will get read from the CACHE,\n  // so who cares\n  preserveExistingPool: true,\n};\n\nlet resetPrefetchTimeout;\nconst resetPrefetchDelay = 10;\n\nfunction prefetch(element) {\n  // Get the stackPrefetch tool data\n  const stackPrefetchData = getToolState(element);\n\n  if (!stackPrefetchData) {\n    return;\n  }\n\n  const stackPrefetch = stackPrefetchData || {};\n  const stack = getStackData(element);\n\n  if (!stack?.imageIds?.length) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  const { currentImageIdIndex } = stack;\n\n  // If all the requests are complete, disable the stackPrefetch tool\n  stackPrefetch.enabled &&= stackPrefetch.indicesToRequest?.length;\n\n  // Make sure the tool is still enabled\n  if (stackPrefetch.enabled === false) {\n    return;\n  }\n\n  // Remove an imageIdIndex from the list of indices to request\n  // This fires when the individual image loading deferred is resolved\n  function removeFromList(imageIdIndex) {\n    const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n\n    if (index > -1) {\n      // Don't remove last element if imageIdIndex not found\n      stackPrefetch.indicesToRequest.splice(index, 1);\n    }\n  }\n\n  // Remove all already cached images from the\n  // IndicesToRequest array\n  stackPrefetchData.indicesToRequest.sort((a, b) => a - b);\n  const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n\n  indicesToRequestCopy.forEach(function (imageIdIndex) {\n    const imageId = stack.imageIds[imageIdIndex];\n\n    if (!imageId) {\n      return;\n    }\n\n    const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n    // For nearby objects, ensure the last accessed time is updated\n    // by using getImageLoadObject.\n    // For more distant objects, just check if available, but dont\n    // change the access time.\n    // This allows throwing data that hasn't been accessed and is not\n    // nearby.\n    const imageCached =\n      distance < 6\n        ? cache.getImageLoadObject(imageId)\n        : cache.isLoaded(imageId);\n\n    if (imageCached) {\n      // Already in cache\n      removeFromList(imageIdIndex);\n    }\n  });\n\n  // Stop here if there are no images left to request\n  // After those in the cache have been removed\n  if (!stackPrefetch.indicesToRequest.length) {\n    return;\n  }\n\n  // Clear the requestPool of prefetch requests, if needed.\n  if (!configuration.preserveExistingPool) {\n    imageLoadPoolManager.clearRequestStack(requestType);\n  }\n\n  // Identify the nearest imageIdIndex to the currentImageIdIndex\n  const nearest = nearestIndex(\n    stackPrefetch.indicesToRequest,\n    stack.currentImageIdIndex\n  );\n\n  let imageId;\n  let nextImageIdIndex;\n  const preventCache = false;\n\n  function doneCallback(image) {\n    console.log('prefetch done: %s', image.imageId);\n    const imageIdIndex = stack.imageIds.indexOf(image.imageId);\n\n    removeFromList(imageIdIndex);\n  }\n\n  // Prefetch images around the current image (before and after)\n  let lowerIndex = nearest.low;\n  let higherIndex = nearest.high;\n  const imageIdsToPrefetch = [];\n\n  while (\n    lowerIndex >= 0 ||\n    higherIndex < stackPrefetch.indicesToRequest.length\n  ) {\n    const currentIndex = stack.currentImageIdIndex;\n    const shouldSkipLower =\n      currentIndex - stackPrefetch.indicesToRequest[lowerIndex] >\n      configuration.maxImagesToPrefetch;\n    const shouldSkipHigher =\n      stackPrefetch.indicesToRequest[higherIndex] - currentIndex >\n      configuration.maxImagesToPrefetch;\n\n    const shouldLoadLower = !shouldSkipLower && lowerIndex >= 0;\n    const shouldLoadHigher =\n      !shouldSkipHigher && higherIndex < stackPrefetch.indicesToRequest.length;\n\n    if (!shouldLoadHigher && !shouldLoadLower) {\n      break;\n    }\n\n    if (shouldLoadLower) {\n      nextImageIdIndex = stackPrefetch.indicesToRequest[lowerIndex--];\n      imageId = stack.imageIds[nextImageIdIndex];\n      imageIdsToPrefetch.push(imageId);\n    }\n\n    if (shouldLoadHigher) {\n      nextImageIdIndex = stackPrefetch.indicesToRequest[higherIndex++];\n      imageId = stack.imageIds[nextImageIdIndex];\n      imageIdsToPrefetch.push(imageId);\n    }\n  }\n\n  const requestFn = (imageId, options) =>\n    imageLoader.loadAndCacheImage(imageId, options);\n\n  const { useNorm16Texture, preferSizeOverAccuracy } =\n    getCoreConfiguration().rendering;\n\n  const useNativeDataType = useNorm16Texture || preferSizeOverAccuracy;\n\n  imageIdsToPrefetch.forEach((imageId) => {\n    // IMPORTANT: Request type should be passed if not the 'interaction'\n    // highest priority will be used for the request type in the imageRetrievalPool\n    const options = {\n      targetBuffer: {\n        type: useNativeDataType ? undefined : 'Float32Array',\n      },\n      preScale: {\n        enabled: true,\n      },\n      useNativeDataType,\n      requestType,\n    };\n\n    imageLoadPoolManager.addRequest(\n      requestFn.bind(null, imageId, options),\n      requestType,\n      // Additional details\n      {\n        imageId,\n      },\n      priority\n      // addToBeginning\n    );\n  });\n}\n\nfunction onImageUpdated(e) {\n  // Start prefetching again (after a delay)\n  // When the user has scrolled to a new image\n  clearTimeout(resetPrefetchTimeout);\n  resetPrefetchTimeout = setTimeout(function () {\n    const element = e.target;\n\n    // If playClip is enabled and the user loads a different series in the viewport\n    // An exception will be thrown because the element will not be enabled anymore\n    try {\n      prefetch(element);\n    } catch (error) {\n      return;\n    }\n  }, resetPrefetchDelay);\n}\n\nfunction enable(element) {\n  const stack = getStackData(element);\n\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  // Use the currentImageIdIndex from the stack as the initialImageIdIndex\n  const stackPrefetchData = {\n    indicesToRequest: range(0, stack.imageIds.length - 1),\n    enabled: true,\n    direction: 1,\n  };\n\n  // Remove the currentImageIdIndex from the list to request\n  const indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(\n    stack.currentImageIdIndex\n  );\n\n  stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);\n\n  addToolState(element, stackPrefetchData);\n\n  prefetch(element);\n\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n  element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n  eventTarget.addEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n}\n\nfunction disable(element) {\n  clearTimeout(resetPrefetchTimeout);\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n\n  const stackPrefetchData = getToolState(element);\n  // If there is actually something to disable, disable it\n\n  if (stackPrefetchData && stackPrefetchData.indicesToRequest.length) {\n    stackPrefetchData.enabled = false;\n\n    // Clear current prefetch requests from the requestPool\n    imageLoadPoolManager.clearRequestStack(requestType);\n  }\n}\n\nfunction getConfiguration() {\n  return configuration;\n}\n\nfunction setConfiguration(config) {\n  configuration = config;\n}\n\nconst stackPrefetch = { enable, disable, getConfiguration, setConfiguration };\n\nexport default stackPrefetch;\n","import {\n  imageLoader,\n  Enums,\n  eventTarget,\n  imageLoadPoolManager,\n  cache,\n  getConfiguration as getCoreConfiguration,\n} from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport {\n  getStackData,\n  requestType,\n  priority,\n  clearFromImageIds,\n  getPromiseRemovedHandler,\n} from './stackPrefetchUtils';\nimport { roundNumber } from '../../utilities';\n\nlet configuration = {\n  maxImagesToPrefetch: Infinity,\n  // Fetch up to 2 image before and after\n  minBefore: 2,\n  maxAfter: 2,\n  // Increment the cache size by 10 images\n  directionExtraImages: 10,\n  preserveExistingPool: false,\n};\n\nlet resetPrefetchTimeout;\n// Starting the prefetch quickly isn't an issue as the main image is already being\n// loaded, so a 5 ms prefetch delay is fine\nconst resetPrefetchDelay = 5;\n\n/**\n * Call this to enable stack context sensitive prefetch.  Should be called\n * before stack data is set in order to start prefetch after load first image.\n * This will add a STACK_NEW_IMAGE to detect when a new image is displayed, and then\n * update the prefetch stack.  The context sensitive prefetch reacts to the\n * initial display, or significant moves, the already loaded images, the\n * cache size and the direction of navigation.  The behaviour is:\n *\n * 1. On navigating to a new image initially, or one that is at a different position:\n *  * Fetch the next/previous 2 images\n * 2. If the user is navigating forward/backward by less than 5 images, then\n *  * Prefetch additional images in the direction of navigation, up to 100\n * 3. If all the images in a given prefetch have completed, then:\n *  * Use the last prefetched image size as an image size for the stack\n *  * Fetch up to 1/4 of the cache size images near the current image\n *\n * This is designed to:\n *   * Get nearby images immediately so that they are available for navigation\n *     * Under the assumption that users might click and view an image, then\n *       navigate to next/previous image to see the exact image they want\n *   * Not interfere with loading other viewports if they are still loading\n *     * Load priority is prefetch, and minimal images are requested initially\n *   * Load an entire series if it will fit in memory\n *     * Allows navigating to other parts of the series and display images immediately\n *   * Have images available for CINE/navigation in one direction even when\n *     there is more image data than will fit in memory.\n *     * Up to 100 images in the direction of travel will be prefetched\n *\n * @param element - to prefetch on\n */\nconst enable = (element): void => {\n  const stack = getStackData(element);\n\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  updateToolState(element);\n\n  prefetch(element);\n\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n  element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n  eventTarget.addEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n};\n\nfunction prefetch(element) {\n  const stack = getStackData(element);\n  if (!stack?.imageIds?.length) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  // Get the stackPrefetch tool data\n  const stackPrefetchData = getToolState(element);\n\n  if (!stackPrefetchData) {\n    return;\n  }\n\n  const stackPrefetch = stackPrefetchData || {};\n\n  // If all the requests are complete, disable the stackPrefetch tool\n  stackPrefetch.enabled &&= stackPrefetch.indicesToRequest?.length;\n\n  // Make sure the tool is still enabled\n  if (stackPrefetch.enabled === false) {\n    return;\n  }\n\n  // Remove an imageIdIndex from the list of indices to request\n  // This fires when the individual image loading deferred is resolved\n  function removeFromList(imageIdIndex) {\n    const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n\n    if (index > -1) {\n      // Don't remove last element if imageIdIndex not found\n      stackPrefetch.indicesToRequest.splice(index, 1);\n    }\n  }\n\n  // Remove all already cached images from the\n  // IndicesToRequest array.\n  const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n  const { currentImageIdIndex } = stack;\n\n  indicesToRequestCopy.forEach((imageIdIndex) => {\n    const imageId = stack.imageIds[imageIdIndex];\n\n    if (!imageId) {\n      return;\n    }\n\n    const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n    // For nearby objects, ensure the last accessed time is updated\n    // by using getImageLoadObject.\n    // For more distant objects, just check if available, but dont\n    // change the access time.\n    // This allows throwing data that hasn't been accessed and is not\n    // nearby.\n    const imageCached =\n      distance < 6\n        ? cache.getImageLoadObject(imageId)\n        : cache.isLoaded(imageId);\n\n    if (imageCached) {\n      // Already in cache\n      removeFromList(imageIdIndex);\n    }\n  });\n\n  // Stop here if there are no images left to request\n  // After those in the cache have been removed\n  if (!stackPrefetch.indicesToRequest.length) {\n    return;\n  }\n\n  // Clear the requestPool of prefetch requests, if needed.\n  if (!configuration.preserveExistingPool) {\n    imageLoadPoolManager.filterRequests(clearFromImageIds(stack));\n  }\n\n  function doneCallback(imageId) {\n    const imageIdIndex = stack.imageIds.indexOf(imageId);\n\n    removeFromList(imageIdIndex);\n    const image = cache.getCachedImageBasedOnImageURI(imageId);\n    const { stats } = stackPrefetch;\n    const decodeTimeInMS = image?.image?.decodeTimeInMS || 0;\n    if (decodeTimeInMS) {\n      stats.imageIds.set(imageId, decodeTimeInMS);\n      stats.decodeTimeInMS += decodeTimeInMS;\n      const loadTimeInMS = image?.image?.loadTimeInMS || 0;\n      stats.loadTimeInMS += loadTimeInMS;\n    }\n\n    if (!stackPrefetch.indicesToRequest.length) {\n      if (image?.sizeInBytes) {\n        const { sizeInBytes } = image;\n        const usage = cache.getMaxCacheSize() / 4 / sizeInBytes;\n        if (!stackPrefetch.cacheFill) {\n          stats.initialTime = Date.now() - stats.start;\n          stats.initialSize = stats.imageIds.size;\n          updateToolState(element, usage);\n          prefetch(element);\n        } else if (stats.imageIds.size) {\n          stats.fillTime = Date.now() - stats.start;\n          const { size } = stats.imageIds;\n          stats.fillSize = size;\n          console.log(\n            'Done cache fill',\n            stats.fillTime,\n            'ms',\n            size,\n            'items',\n            'average total time',\n            roundNumber(stats.fillTime / size),\n            'ms',\n            'average load',\n            roundNumber(stats.loadTimeInMS / size),\n            'ms',\n            'average decode',\n            roundNumber(stats.decodeTimeInMS / size),\n            'ms'\n          );\n        }\n      }\n    }\n  }\n\n  const requestFn = (imageId, options) =>\n    imageLoader\n      .loadAndCacheImage(imageId, options)\n      .then(() => doneCallback(imageId));\n\n  const { useNorm16Texture, preferSizeOverAccuracy } =\n    getCoreConfiguration().rendering;\n\n  const useNativeDataType = useNorm16Texture || preferSizeOverAccuracy;\n\n  indicesToRequestCopy.forEach((imageIdIndex) => {\n    const imageId = stack.imageIds[imageIdIndex];\n    // IMPORTANT: Request type should be passed if not the 'interaction'\n    // highest priority will be used for the request type in the imageRetrievalPool\n    const options = {\n      targetBuffer: {\n        type: useNativeDataType ? undefined : 'Float32Array',\n      },\n      preScale: {\n        enabled: true,\n      },\n      useNativeDataType,\n      requestType,\n    };\n\n    imageLoadPoolManager.addRequest(\n      requestFn.bind(null, imageId, options),\n      requestType,\n      // Additional details\n      {\n        imageId,\n      },\n      priority\n      // addToBeginning\n    );\n  });\n}\n\nfunction onImageUpdated(e) {\n  // Start prefetching again (after a delay)\n  // When the user has scrolled to a new image\n  clearTimeout(resetPrefetchTimeout);\n  resetPrefetchTimeout = setTimeout(function () {\n    const element = e.target;\n\n    // If playClip is enabled and the user loads a different series in the viewport\n    // An exception will be thrown because the element will not be enabled anymore\n    try {\n      updateToolState(element);\n      prefetch(element);\n    } catch (error) {\n      return;\n    }\n  }, resetPrefetchDelay);\n}\n\n// Not a full signum, but good enough for direction.\nconst signum = (x) => (x < 0 ? -1 : 1);\n\nconst updateToolState = (element, usage?: number) => {\n  const stack = getStackData(element);\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  const { currentImageIdIndex } = stack;\n  let { maxAfter = 2, minBefore = 2 } = configuration;\n  const { directionExtraImages = 10 } = configuration;\n  // Use the currentImageIdIndex from the stack as the initialImageIdIndex\n  const stackPrefetchData = getToolState(element) || {\n    indicesToRequest: [],\n    currentImageIdIndex,\n    stackCount: 0,\n    enabled: true,\n    direction: 1,\n    stats: {\n      start: Date.now(),\n      imageIds: new Map(),\n      decodeTimeInMS: 0,\n      loadTimeInMS: 0,\n      totalBytes: 0,\n    },\n  };\n  const delta = currentImageIdIndex - stackPrefetchData.currentImageIdIndex;\n  stackPrefetchData.direction = signum(delta);\n  stackPrefetchData.currentImageIdIndex = currentImageIdIndex;\n  stackPrefetchData.enabled = true;\n\n  if (stackPrefetchData.stackCount < 100) {\n    stackPrefetchData.stackCount += directionExtraImages;\n  }\n\n  if (Math.abs(delta) > maxAfter || !delta) {\n    // Not incrementing by 1, so stop increasing the data size\n    // TODO - consider reversing the CINE playback\n    stackPrefetchData.stackCount = 0;\n    if (usage) {\n      // The usage of the cache that this stack can use\n      const positionFraction = currentImageIdIndex / stack.imageIds.length;\n      minBefore = Math.ceil(usage * positionFraction);\n      maxAfter = Math.ceil(usage * (1 - positionFraction));\n      stackPrefetchData.cacheFill = true;\n    } else {\n      stackPrefetchData.cacheFill = false;\n    }\n  } else if (delta < 0) {\n    minBefore += stackPrefetchData.stackCount;\n    maxAfter = 0;\n  } else {\n    maxAfter += stackPrefetchData.stackCount;\n    minBefore = 0;\n  }\n\n  const minIndex = Math.max(0, currentImageIdIndex - minBefore);\n\n  const maxIndex = Math.min(\n    stack.imageIds.length - 1,\n    currentImageIdIndex + maxAfter\n  );\n\n  // Order these correctly initially\n  const indicesToRequest = [];\n  for (let i = currentImageIdIndex + 1; i <= maxIndex; i++) {\n    indicesToRequest.push(i);\n  }\n  for (let i = currentImageIdIndex - 1; i >= minIndex; i--) {\n    indicesToRequest.push(i);\n  }\n  stackPrefetchData.indicesToRequest = indicesToRequest;\n\n  addToolState(element, stackPrefetchData);\n};\n\nfunction disable(element) {\n  clearTimeout(resetPrefetchTimeout);\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n\n  const stackPrefetchData = getToolState(element);\n  // If there is actually something to disable, disable it\n\n  if (stackPrefetchData && stackPrefetchData.data.length) {\n    stackPrefetchData.enabled = false;\n    // Don't worry about clearing the requests - there aren't that many too be bothersome\n  }\n}\n\nfunction getConfiguration() {\n  return configuration;\n}\n\nfunction setConfiguration(config) {\n  configuration = config;\n}\n\nconst stackContextPrefetch = {\n  enable,\n  disable,\n  getConfiguration,\n  setConfiguration,\n};\n\nexport default stackContextPrefetch;\n","import { VolumeViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\n\n// Todo: merge this utility functionality with Crosshair _jump\n/**\n * Uses the viewport's current camera to jump to a specific world coordinate\n * @param enabledElement - enabled element\n * @param jumpWorld - location in the world to jump to\n * @returns True if successful\n */\nexport default function jumpToWorld(\n  viewport: Types.IVolumeViewport,\n  jumpWorld: Types.Point3\n): true | undefined {\n  // if not instance of volumeViewport, return\n  if (!(viewport instanceof VolumeViewport)) {\n    return;\n  }\n\n  const { focalPoint } = viewport.getCamera();\n\n  const delta: Types.Point3 = [0, 0, 0];\n  vec3.sub(delta, jumpWorld, focalPoint);\n\n  _applyShift(viewport, delta);\n\n  return true;\n}\n\nfunction _applyShift(viewport, delta) {\n  const camera = viewport.getCamera();\n  const normal = camera.viewPlaneNormal;\n\n  const dotProd = vec3.dot(delta, normal);\n  const projectedDelta = vec3.fromValues(normal[0], normal[1], normal[2]);\n\n  vec3.scale(projectedDelta, projectedDelta, dotProd);\n\n  if (\n    Math.abs(projectedDelta[0]) > 1e-3 ||\n    Math.abs(projectedDelta[1]) > 1e-3 ||\n    Math.abs(projectedDelta[2]) > 1e-3\n  ) {\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newPosition: Types.Point3 = [0, 0, 0];\n\n    vec3.add(newFocalPoint, camera.focalPoint, projectedDelta);\n    vec3.add(newPosition, camera.position, projectedDelta);\n\n    viewport.setCamera({\n      focalPoint: newFocalPoint,\n      position: newPosition,\n    });\n    viewport.render();\n  }\n}\n","import { utilities, cache, Types } from '@cornerstonejs/core';\nimport { getVoxelOverlap } from '../segmentation/utilities';\nimport pointInShapeCallback from '../pointInShapeCallback';\n\n/**\n * Gets the scalar data for a series of time points for either a single\n * coordinate or a segmentation mask, it will return the an array of scalar\n * data for a single coordinate or an array of arrays for a segmentation.\n *\n * @param dynamicVolume - 4D volume to compute time point data from\n * @param options - frameNumbers: which frames to use as timepoints, if left\n * blank, gets data timepoints over all frames\n * maskVolumeId: segmentationId to get timepoint data of\n * imageCoordinate: world coordinate to get timepoint data of\n * @returns\n */\nfunction getDataInTime(\n  dynamicVolume: Types.IDynamicImageVolume,\n  options: {\n    frameNumbers?;\n    maskVolumeId?;\n    imageCoordinate?;\n  }\n): number[] | number[][] {\n  let dataInTime;\n\n  // if frameNumbers is not provided, all frames are selected\n  const frames = options.frameNumbers || [\n    ...Array(dynamicVolume.numTimePoints).keys(),\n  ];\n\n  // You only need to provide either maskVolumeId OR imageCoordinate.\n  // Throws error if neither maskVolumeId or imageCoordinate is given,\n  // throws error if BOTH maskVolumeId and imageCoordinate is given\n  if (!options.maskVolumeId && !options.imageCoordinate) {\n    throw new Error(\n      'You should provide either maskVolumeId or imageCoordinate'\n    );\n  }\n\n  if (options.maskVolumeId && options.imageCoordinate) {\n    throw new Error('You can only use one of maskVolumeId or imageCoordinate');\n  }\n\n  if (options.maskVolumeId) {\n    const segmentationVolume = cache.getVolume(options.maskVolumeId);\n\n    const [dataInTime, ijkCoords] = _getTimePointDataMask(\n      frames,\n      dynamicVolume,\n      segmentationVolume\n    );\n\n    return [dataInTime, ijkCoords];\n  }\n\n  if (options.imageCoordinate) {\n    const dataInTime = _getTimePointDataCoordinate(\n      frames,\n      options.imageCoordinate,\n      dynamicVolume\n    );\n\n    return dataInTime;\n  }\n\n  return dataInTime;\n}\n\nfunction _getTimePointDataCoordinate(frames, coordinate, volume) {\n  const { dimensions, imageData } = volume;\n  const index = imageData.worldToIndex(coordinate);\n\n  index[0] = Math.floor(index[0]);\n  index[1] = Math.floor(index[1]);\n  index[2] = Math.floor(index[2]);\n\n  if (!utilities.indexWithinDimensions(index, dimensions)) {\n    throw new Error('outside bounds');\n  }\n\n  // calculate offset for index\n  const yMultiple = dimensions[0];\n  const zMultiple = dimensions[0] * dimensions[1];\n  const allScalarData = volume.getScalarDataArrays();\n  const value = [];\n\n  frames.forEach((frame) => {\n    const activeScalarData = allScalarData[frame];\n    const scalarIndex = index[2] * zMultiple + index[1] * yMultiple + index[0];\n    value.push(activeScalarData[scalarIndex]);\n  });\n\n  return value;\n}\n\nfunction _getTimePointDataMask(frames, dynamicVolume, segmentationVolume) {\n  const { imageData: maskImageData } = segmentationVolume;\n  const segScalarData = segmentationVolume.getScalarData();\n\n  const len = segScalarData.length;\n\n  // Pre-allocate memory for array\n  const nonZeroVoxelIndices = [];\n  nonZeroVoxelIndices.length = len;\n  const ijkCoords = [];\n\n  const dimensions = segmentationVolume.dimensions;\n\n  // Get the index of every non-zero voxel in mask\n  let actualLen = 0;\n  for (let i = 0, len = segScalarData.length; i < len; i++) {\n    if (segScalarData[i] !== 0) {\n      ijkCoords.push([\n        i % dimensions[0],\n        Math.floor((i / dimensions[0]) % dimensions[1]),\n        Math.floor(i / (dimensions[0] * dimensions[1])),\n      ]);\n      nonZeroVoxelIndices[actualLen++] = i;\n    }\n  }\n\n  // Trim the array to actual size\n  nonZeroVoxelIndices.length = actualLen;\n\n  const dynamicVolumeScalarDataArray = dynamicVolume.getScalarDataArrays();\n  const values = [];\n  const isSameVolume =\n    dynamicVolumeScalarDataArray[0].length === len &&\n    JSON.stringify(dynamicVolume.spacing) ===\n      JSON.stringify(segmentationVolume.spacing);\n\n  // if the segmentation mask is the same size as the dynamic volume (one frame)\n  // means we can just return the scalar data for the non-zero voxels\n  if (isSameVolume) {\n    for (let i = 0; i < nonZeroVoxelIndices.length; i++) {\n      const indexValues = [];\n      frames.forEach((frame) => {\n        const activeScalarData = dynamicVolumeScalarDataArray[frame];\n        indexValues.push(activeScalarData[nonZeroVoxelIndices[i]]);\n      });\n      values.push(indexValues);\n    }\n\n    return [values, ijkCoords];\n  }\n\n  // In case that the segmentation mask is not the same size as the dynamic volume (one frame)\n  // then we need to consider each voxel in the segmentation mask and check if it\n  // overlaps with the other volume, and if so we need to average the values of the\n  // overlapping voxels.\n  const callback = ({\n    pointLPS: segPointLPS,\n    value: segValue,\n    pointIJK: segPointIJK,\n  }) => {\n    // see if the value is non-zero\n    if (segValue === 0) {\n      // not interested\n      return;\n    }\n\n    // Then for each non-zero voxel in the segmentation mask, we should\n    // again perform the pointInShapeCallback to run the averaging callback\n    // function to get the average value of the overlapping voxels.\n    const overlapIJKMinMax = getVoxelOverlap(\n      dynamicVolume.imageData,\n      dynamicVolume.dimensions,\n      dynamicVolume.spacing,\n      segPointLPS\n    );\n\n    // count represents the number of voxels of the dynamic volume that represents\n    // one voxel of the segmentation mask\n    let count = 0;\n    const perFrameSum = new Map();\n\n    // Pre-initialize the Map\n    frames.forEach((frame) => perFrameSum.set(frame, 0));\n\n    const averageCallback = ({ index }) => {\n      for (let i = 0; i < frames.length; i++) {\n        const value = dynamicVolumeScalarDataArray[i][index];\n        const frame = frames[i];\n        perFrameSum.set(frame, perFrameSum.get(frame) + value);\n      }\n      count++;\n    };\n\n    pointInShapeCallback(\n      dynamicVolume.imageData,\n      () => true,\n      averageCallback,\n      overlapIJKMinMax\n    );\n\n    // average the values\n    const averageValues = [];\n    perFrameSum.forEach((sum) => {\n      averageValues.push(sum / count);\n    });\n\n    ijkCoords.push(segPointIJK);\n    values.push(averageValues);\n  };\n\n  // Since we have the non-zero voxel indices of the segmentation mask,\n  // we theoretically can use them, however, we kind of need to compute the\n  // pointLPS for each of the non-zero voxel indices, which is a bit of a pain.\n  // Todo: consider using the nonZeroVoxelIndices to compute the pointLPS\n  pointInShapeCallback(maskImageData, () => true, callback);\n\n  return [values, ijkCoords];\n}\n\nexport default getDataInTime;\n","import { Enums, Types } from '@cornerstonejs/core';\n\n/**\n * Gets the scalar data for a series of time frames from a 4D volume, returns an\n * array of scalar data after performing AVERAGE, SUM or SUBTRACT to be used to\n * create a 3D volume\n *\n * @param dynamicVolume4D - volume to compute time frame data from\n * @param operation - operation to perform on time frame data, operations include\n * SUM, AVERAGE, and SUBTRACT (can only be used with 2 time frames provided)\n * @param frameNumbers - an array of frame indices to perform the operation on, if\n * left empty, all frames will be used\n * @returns\n */\nfunction generateImageFromTimeData(\n  dynamicVolume: Types.IDynamicImageVolume,\n  operation: string,\n  frameNumbers?: number[]\n) {\n  // If no time frames provided, use all time frames\n  const frames = frameNumbers || [...Array(dynamicVolume.numTimePoints).keys()];\n  const numFrames = frames.length;\n\n  if (frames.length <= 1) {\n    throw new Error('Please provide two or more time points');\n  }\n\n  // Gets scalar data for all time frames\n  const typedArrays = dynamicVolume.getScalarDataArrays();\n\n  const arrayLength = typedArrays[0].length;\n  const finalArray = new Float32Array(arrayLength);\n\n  if (operation === Enums.DynamicOperatorType.SUM) {\n    for (let i = 0; i < numFrames; i++) {\n      const currentArray = typedArrays[frames[i]];\n      for (let j = 0; j < arrayLength; j++) {\n        finalArray[j] += currentArray[j];\n      }\n    }\n    return finalArray;\n  }\n\n  if (operation === Enums.DynamicOperatorType.SUBTRACT) {\n    if (frames.length > 2) {\n      throw new Error('Please provide only 2 time points for subtraction.');\n    }\n    for (let j = 0; j < arrayLength; j++) {\n      finalArray[j] += typedArrays[frames[0]][j] - typedArrays[frames[1]][j];\n    }\n    return finalArray;\n  }\n\n  if (operation === Enums.DynamicOperatorType.AVERAGE) {\n    for (let i = 0; i < numFrames; i++) {\n      const currentArray = typedArrays[frames[i]];\n      for (let j = 0; j < arrayLength; j++) {\n        finalArray[j] += currentArray[j];\n      }\n    }\n    for (let k = 0; k < arrayLength; k++) {\n      finalArray[k] = finalArray[k] / numFrames;\n    }\n    return finalArray;\n  }\n}\n\nexport default generateImageFromTimeData;\n","import vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\n/**\n * Gets a point from an array of numbers given its index\n * @param points - array of number, each point defined by three consecutive numbers\n * @param idx - index of the point to retrieve\n * @returns\n */\nexport function getPoint(points, idx): Types.Point3 {\n  const idx3 = idx * 3;\n  if (idx3 < points.length) {\n    return vec3.fromValues(\n      points[idx3],\n      points[idx3 + 1],\n      points[idx3 + 2]\n    ) as Types.Point3;\n  }\n}\n\n/**\n * Extract contour point sets from the outline of a poly data actor\n * @param polyData - vtk polyData\n * @returns\n */\nexport function getPolyDataPointIndexes(polyData: vtkPolyData) {\n  const linesData = polyData.getLines().getData();\n  let idx = 0;\n  const lineSegments = new Map<number, number[]>();\n\n  // Populate lineSegments map\n  while (idx < linesData.length) {\n    const segmentSize = linesData[idx++];\n    const segment = [];\n    for (let i = 0; i < segmentSize; i++) {\n      segment.push(linesData[idx + i]);\n    }\n    lineSegments.set(segment[0], segment);\n    idx += segmentSize;\n  }\n\n  const contours = [];\n\n  // Function to find an available starting point\n  const findStartingPoint = (map) => {\n    for (const [key, value] of map.entries()) {\n      if (value !== undefined) {\n        return key;\n      }\n    }\n    return -1;\n  };\n\n  // Build contours\n  let startPoint = findStartingPoint(lineSegments);\n  while (startPoint !== -1) {\n    const contour = [startPoint];\n    while (lineSegments.has(startPoint)) {\n      const nextPoint = lineSegments.get(startPoint)[1];\n      if (lineSegments.has(nextPoint)) {\n        contour.push(nextPoint);\n      }\n      lineSegments.delete(startPoint);\n      startPoint = nextPoint;\n    }\n    contours.push(contour);\n    startPoint = findStartingPoint(lineSegments);\n  }\n\n  return contours.length ? contours : undefined;\n}\n\n/**\n * Extract contour points from a poly data object\n * @param polyData - vtk polyData\n * @returns\n */\nexport function getPolyDataPoints(polyData: vtkPolyData) {\n  const contoursIndexes = getPolyDataPointIndexes(polyData);\n  if (!contoursIndexes) {\n    return;\n  }\n\n  const rawPointsData = polyData.getPoints().getData();\n  return contoursIndexes.map((contourIndexes) =>\n    contourIndexes.map((index) => getPoint(rawPointsData, index))\n  );\n}\n","/**\n * Specify the position of the text/ticks.\n * Left/Right are the valid options for a vertical colorbars and Top/Bottom\n * for the horizontal ones.\n */\nexport enum ColorbarRangeTextPosition {\n  Top = 'top',\n  Left = 'left',\n  Bottom = 'bottom',\n  Right = 'right',\n}\n","import type { ColorbarImageRange } from '../types/ColorbarImageRange';\n\nconst isRangeValid = (range: ColorbarImageRange) => {\n  return range && range.upper > range.lower;\n};\n\nexport { isRangeValid as default, isRangeValid };\n","import type { ColorbarImageRange } from '../types/ColorbarImageRange';\n\nconst areColorbarRangesEqual = (\n  a: ColorbarImageRange,\n  b: ColorbarImageRange\n) => {\n  return !!a && !!b && a.lower === b.lower && a.upper === b.upper;\n};\n\nexport { areColorbarRangesEqual as default, areColorbarRangesEqual };\n","import type { ColorbarSize } from '../types/ColorbarSize';\n\nconst isColorbarSizeValid = (size: ColorbarSize) => {\n  return !!size && size.width > 0 && size.height > 0;\n};\n\nexport { isColorbarSizeValid as default, isColorbarSizeValid };\n","import type { ColorbarSize } from '../types/ColorbarSize';\n\nconst areColorbarSizesEqual = (a: ColorbarSize, b: ColorbarSize) => {\n  return !!a && !!b && a.width === b.width && a.height === b.height;\n};\n\nexport { areColorbarSizesEqual as default, areColorbarSizesEqual };\n","import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\nimport { utilities } from '@cornerstonejs/core';\nimport interpolateVec3 from '../../math/vec3/interpolateVec3';\nimport { ColorbarCanvasProps } from './types/ColorbarCanvasProps';\nimport type { ColorbarImageRange, ColorbarVOIRange } from './types';\nimport type { ColorbarSize } from './types/ColorbarSize';\nimport {\n  isRangeValid,\n  areColorbarRangesEqual,\n  isColorbarSizeValid,\n  areColorbarSizesEqual,\n} from './common';\n\nconst { clamp } = utilities;\n\n/**\n * Canvas referenced by the color bar where the colormap is rendered. It may\n * show the full image range or only the VOI range.\n */\nclass ColorbarCanvas {\n  private _canvas: HTMLCanvasElement;\n  private _imageRange: ColorbarImageRange;\n  private _voiRange: ColorbarVOIRange;\n  private _colormap: IColorMapPreset;\n  private _showFullImageRange: boolean;\n\n  constructor(props: ColorbarCanvasProps) {\n    ColorbarCanvas.validateProps(props);\n\n    const {\n      colormap,\n      size = { width: 20, height: 100 },\n      imageRange = { lower: 0, upper: 1 },\n      voiRange = { lower: 0, upper: 1 },\n      container,\n      showFullPixelValueRange = false,\n    } = props;\n\n    this._colormap = colormap;\n    this._imageRange = imageRange;\n    this._voiRange = voiRange;\n    this._showFullImageRange = showFullPixelValueRange;\n    this._canvas = this._createRootElement(size);\n\n    if (container) {\n      this.appendTo(container);\n    }\n  }\n\n  public get colormap(): IColorMapPreset {\n    return this._colormap;\n  }\n\n  public set colormap(colormap: IColorMapPreset) {\n    this._colormap = colormap;\n    this.render();\n  }\n\n  public get size(): ColorbarSize {\n    const { width, height } = this._canvas;\n    return { width, height };\n  }\n\n  public set size(size: ColorbarSize) {\n    const { _canvas: canvas } = this;\n\n    if (!isColorbarSizeValid(size) || areColorbarSizesEqual(canvas, size)) {\n      return;\n    }\n\n    this._setCanvasSize(canvas, size);\n    this.render();\n  }\n\n  public get imageRange(): ColorbarImageRange {\n    return { ...this._imageRange };\n  }\n\n  public set imageRange(imageRange: ColorbarImageRange) {\n    if (\n      !isRangeValid(imageRange) ||\n      areColorbarRangesEqual(imageRange, this._imageRange)\n    ) {\n      return;\n    }\n\n    this._imageRange = imageRange;\n    this.render();\n  }\n\n  public get voiRange(): ColorbarVOIRange {\n    return { ...this._voiRange };\n  }\n\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, this._voiRange)\n    ) {\n      return;\n    }\n\n    this._voiRange = voiRange;\n    this.render();\n  }\n\n  public get showFullImageRange(): boolean {\n    return this._showFullImageRange;\n  }\n\n  public set showFullImageRange(showFullImageRange: boolean) {\n    if (showFullImageRange === this._showFullImageRange) {\n      return;\n    }\n\n    this._showFullImageRange = showFullImageRange;\n    this.render();\n  }\n\n  public appendTo(container: HTMLElement) {\n    container.appendChild(this._canvas);\n    this.render();\n  }\n\n  public dispose() {\n    const { _canvas: canvas } = this;\n    const { parentElement } = canvas;\n\n    parentElement?.removeChild(canvas);\n  }\n\n  private static validateProps(props: ColorbarCanvasProps) {\n    const { size, imageRange, voiRange } = props;\n\n    if (size && !isColorbarSizeValid(size)) {\n      throw new Error('Invalid \"size\"');\n    }\n\n    if (imageRange && !isRangeValid(imageRange)) {\n      throw new Error('Invalid \"imageRange\"');\n    }\n\n    if (voiRange && !isRangeValid(voiRange)) {\n      throw new Error('Invalid \"voiRange\"');\n    }\n  }\n\n  private _setCanvasSize(canvas: HTMLCanvasElement, size: ColorbarSize) {\n    const { width, height } = size;\n\n    canvas.width = width;\n    canvas.height = height;\n\n    Object.assign(canvas.style, {\n      width: `${width}px`,\n      height: `${height}px`,\n    });\n  }\n\n  private _createRootElement(size: ColorbarSize) {\n    const canvas = document.createElement('canvas');\n\n    Object.assign(canvas.style, {\n      position: 'absolute',\n      top: '0',\n      left: '0',\n      pointerEvents: 'none',\n      boxSizing: 'border-box',\n    });\n\n    this._setCanvasSize(canvas, size);\n\n    return canvas;\n  }\n\n  private render(): void {\n    if (!this._canvas.isConnected) {\n      return;\n    }\n\n    const { _colormap: colormap } = this;\n    const { RGBPoints: rgbPoints } = colormap;\n    const colorsCount = rgbPoints.length / 4;\n\n    // Returns a color point from rgbPoints. Each point has position, red,\n    // green and blue components which means each point has an offset equal\n    // to `4 * index`\n    const getColorPoint = (index) => {\n      const offset = 4 * index;\n\n      // It can get out of bounds when `voiRange.upper` is smaller than\n      // `imageRange.upper`. It's also checking if is smaller than zero\n      // for safety only because that should never happens.\n      if (index < 0 || index >= colorsCount) {\n        return;\n      }\n\n      return {\n        index,\n        position: rgbPoints[offset],\n        color: [\n          rgbPoints[offset + 1],\n          rgbPoints[offset + 2],\n          rgbPoints[offset + 3],\n        ],\n      };\n    };\n\n    const { width, height } = this._canvas;\n    const canvasContext = this._canvas.getContext('2d');\n    const isHorizontal = width > height;\n    const maxValue = isHorizontal ? width : height;\n    const { _voiRange: voiRange } = this;\n    const range = this._showFullImageRange ? this._imageRange : { ...voiRange };\n\n    const { windowWidth } = utilities.windowLevel.toWindowLevel(\n      voiRange.lower,\n      voiRange.upper\n    );\n\n    let previousColorPoint = undefined;\n    let currentColorPoint = getColorPoint(0);\n\n    // Starts from `range.lower` incrementing by incRawPixelValue on each iteration\n    const incRawPixelValue = (range.upper - range.lower) / (maxValue - 1);\n    let rawPixelValue = range.lower;\n\n    for (let i = 0; i < maxValue; i++) {\n      const tVoiRange = (rawPixelValue - voiRange.lower) / windowWidth;\n\n      // Find the color in a linear way (O(n) complexity).\n      // currentColorPoint shall move to the next color until tVoiRange is smaller\n      // than or equal to next color position.\n      if (currentColorPoint) {\n        for (let i = currentColorPoint.index; i < colorsCount; i++) {\n          if (tVoiRange <= currentColorPoint.position) {\n            break;\n          }\n\n          previousColorPoint = currentColorPoint;\n          currentColorPoint = getColorPoint(i + 1);\n        }\n      }\n\n      let normColor;\n\n      // For:\n      //   - firstColorPoint = getColorPoint(0)\n      //   - secondColorPoint = getColorPoint(1)\n      //   - lastColorPoint = getColorPoint(colorsCount - 1)\n      // Then\n      //   - previousColorPoint shall be undefined when tVoiRange < firstColorPoint.position\n      //   - currentColorPoint shall be undefined when tVoiRange > lastColorPoint.position\n      //   - previousColorPoint and currentColorPoint will be defined when\n      //     currentColorPoint.position is between secondColorPoint.position and\n      //     lastColorPoint.position.\n      if (!previousColorPoint) {\n        normColor = [...currentColorPoint.color];\n      } else if (!currentColorPoint) {\n        normColor = [...previousColorPoint.color];\n      } else {\n        const tColorRange =\n          (tVoiRange - previousColorPoint.position) /\n          (currentColorPoint.position - previousColorPoint.position);\n\n        normColor = interpolateVec3(\n          previousColorPoint.color,\n          currentColorPoint.color,\n          tColorRange\n        );\n      }\n\n      const color = normColor.map((color) =>\n        clamp(Math.round(color * 255), 0, 255)\n      );\n\n      canvasContext.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;\n\n      if (isHorizontal) {\n        canvasContext.fillRect(i, 0, 1, height);\n      } else {\n        canvasContext.fillRect(0, height - i - 1, width, 1);\n      }\n\n      rawPixelValue += incRawPixelValue;\n    }\n  }\n}\n\nexport { ColorbarCanvas as default, ColorbarCanvas };\n","/**\n * Linear interpolation between two vec3.\n * Can be used, for example, to interpolate between two RGB colors.\n * @param a - First vec3\n * @param b - Second vec3\n * @param t - Time \"t\".\n *   - Vector A is returned for values smaller than or equel to 0.\n *   - Vector B is returned for values greater than or equal to 1.\n *   - An interpolation between vectors A and B is returned otherwise.\n * @returns\n */\nconst interpolateVec3 = (a, b, t) => {\n  return [\n    a[0] * (1 - t) + b[0] * t,\n    a[1] * (1 - t) + b[1] * t,\n    a[2] * (1 - t) + b[2] * t,\n  ];\n};\n\nexport { interpolateVec3 as default, interpolateVec3 };\n","import type {\n  ColorbarImageRange,\n  ColorbarVOIRange,\n  ColorbarSize,\n  ColorbarTicksProps,\n} from './types';\nimport {\n  isColorbarSizeValid,\n  isRangeValid,\n  areColorbarRangesEqual,\n  areColorbarSizesEqual,\n} from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\n\nconst DEFAULTS = {\n  FONT: '10px Arial',\n  COLOR: 'white',\n  TICK_SIZE: 5,\n  TICK_WIDTH: 1,\n  TICK_LABEL_MARGIN: 3,\n  MAX_NUM_TICKS: 8,\n\n  // Must start with 1 and end with 10\n  TICKS_STEPS: [1, 2.5, 5, 10],\n};\n\nclass ColorbarTicks {\n  private _canvas: HTMLCanvasElement;\n  private _imageRange: ColorbarImageRange;\n  private _voiRange: ColorbarVOIRange;\n  private _color: string;\n  private _tickSize: number;\n  private _tickWidth: number;\n  private _labelMargin: number;\n  private _maxNumTicks: number;\n  private _rangeTextPosition: ColorbarRangeTextPosition;\n  private _showFullPixelValueRange: boolean;\n  private _font: string;\n\n  constructor(props: ColorbarTicksProps) {\n    ColorbarTicks.validateProps(props);\n\n    const {\n      top = 0,\n      left = 0,\n      size = { width: 20, height: 100 },\n      imageRange = { lower: 0, upper: 1 },\n      voiRange = { lower: 0, upper: 1 },\n      ticks: ticksProps,\n      container,\n      showFullPixelValueRange = false,\n    } = props;\n\n    const { style: ticksStyle, position: rangeTextPosition } = ticksProps ?? {};\n\n    this._imageRange = imageRange;\n    this._voiRange = voiRange;\n    this._font = ticksStyle?.font ?? DEFAULTS.FONT;\n    this._color = ticksStyle?.color ?? DEFAULTS.COLOR;\n    this._tickSize = ticksStyle?.tickSize ?? DEFAULTS.TICK_SIZE;\n    this._tickWidth = ticksStyle?.tickWidth ?? DEFAULTS.TICK_WIDTH;\n    this._labelMargin = ticksStyle?.labelMargin ?? DEFAULTS.TICK_LABEL_MARGIN;\n    this._maxNumTicks = ticksStyle?.maxNumTicks ?? DEFAULTS.MAX_NUM_TICKS;\n    this._rangeTextPosition =\n      rangeTextPosition ?? ColorbarRangeTextPosition.Right;\n    this._showFullPixelValueRange = showFullPixelValueRange;\n    this._canvas = this._createCanvasElement(size, top, left);\n\n    if (container) {\n      this.appendTo(container);\n    }\n  }\n\n  public get size(): ColorbarSize {\n    const { width, height } = this._canvas;\n    return { width, height };\n  }\n\n  public set size(size: ColorbarSize) {\n    const { _canvas: canvas } = this;\n\n    if (!isColorbarSizeValid(size) || areColorbarSizesEqual(canvas, size)) {\n      return;\n    }\n\n    this._setCanvasSize(canvas, size);\n    this.render();\n  }\n\n  /**\n   * Canvas top position (pixels)\n   */\n  public get top(): number {\n    return Number.parseInt(this._canvas.style.top);\n  }\n\n  /**\n   * Change the canvas top position (pixels)\n   */\n  public set top(top: number) {\n    const { _canvas: canvas } = this;\n    const currentTop = this.top;\n\n    if (top === currentTop) {\n      return;\n    }\n\n    canvas.style.top = `${top}px`;\n    this.render();\n  }\n\n  /**\n   * Canvas left position (pixels)\n   */\n  public get left(): number {\n    return Number.parseInt(this._canvas.style.left);\n  }\n\n  /**\n   * Change the canvas left position (pixels)\n   */\n  public set left(left: number) {\n    const { _canvas: canvas } = this;\n    const currentLeft = this.left;\n\n    if (left === currentLeft) {\n      return;\n    }\n\n    canvas.style.left = `${left}px`;\n    this.render();\n  }\n\n  /**\n   * Image range\n   */\n  public get imageRange() {\n    return { ...this._imageRange };\n  }\n\n  /**\n   * Set the image range that should goes from minPixelValue to maxPixelValue\n   */\n  public set imageRange(imageRange: ColorbarVOIRange) {\n    if (\n      !isRangeValid(imageRange) ||\n      areColorbarRangesEqual(imageRange, this._imageRange)\n    ) {\n      return;\n    }\n\n    this._imageRange = imageRange;\n    this.render();\n  }\n\n  /**\n   * VOI range\n   * (lower: wc - ww / 2, upper: wc + ww / 2)\n   */\n  public get voiRange() {\n    return { ...this._voiRange };\n  }\n\n  /**\n   * Set the VOI Range\n   * (lower: wc - ww / 2, upper: wc + ww / 2)\n   */\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, this._voiRange)\n    ) {\n      return;\n    }\n\n    this._voiRange = voiRange;\n    this.render();\n  }\n\n  /**\n   * Tick size (pixels)\n   */\n  public get tickSize(): number {\n    return this._tickSize;\n  }\n\n  /**\n   * Set the tick size\n   */\n  public set tickSize(tickSize: number) {\n    if (tickSize === this._tickSize) {\n      return;\n    }\n\n    this._tickSize = tickSize;\n    this.render();\n  }\n\n  /**\n   * Tick width (pixels)\n   */\n  public get tickWidth(): number {\n    return this._tickWidth;\n  }\n\n  /**\n   * Set the tick width. This width is used as `lineWidth` by CanvasRenderingContext2D.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineWidth\n   */\n  public set tickWidth(tickWidth: number) {\n    if (tickWidth === this._tickWidth) {\n      return;\n    }\n\n    this._tickWidth = tickWidth;\n    this.render();\n  }\n\n  /**\n   * Color used for ticks and labels.\n   */\n  public get color(): string {\n    return this._color;\n  }\n\n  /**\n   * Set the color used for ticks and labels. This color is used as `strokeStyle`\n   * and `fillStyle` by CanvasRenderingContext2D.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle\n   */\n  public set color(color: string) {\n    if (color === this._color) {\n      return;\n    }\n\n    this._color = color;\n    this.render();\n  }\n\n  /**\n   * Return `true` when the ticks displayed are in the range from `imageRange.lower`\n   * to `imageRange.upper` or `false` when they are in the range from `voiRange.lower`\n   * to `voiRange.upper`\n   */\n  public get showFullPixelValueRange(): boolean {\n    return this._showFullPixelValueRange;\n  }\n\n  /**\n   * Change which range should be used when rendering the ticks. Set it to `true`\n   * to show from `imageRange.lower` to `imageRange.upper` or `false` show from\n   * `voiRange.lower` to `voiRange.upper`.\n   */\n  public set showFullPixelValueRange(showFullRange: boolean) {\n    if (showFullRange === this._showFullPixelValueRange) {\n      return;\n    }\n\n    this._showFullPixelValueRange = showFullRange;\n    this.render();\n  }\n\n  /**\n   * Ticks visibility\n   */\n  public get visible() {\n    return this._canvas.style.display === 'block';\n  }\n\n  /**\n   * Show/Hide the ticks\n   */\n  public set visible(visible) {\n    if (visible === this.visible) {\n      return;\n    }\n\n    this._canvas.style.display = visible ? 'block' : 'none';\n\n    if (visible) {\n      this.render();\n    }\n  }\n\n  /**\n   * Append the canvas to its parent element\n   * @param container - HTML element where the canvas should be added to\n   */\n  public appendTo(container: HTMLElement) {\n    container.appendChild(this._canvas);\n    this.render();\n  }\n\n  private static validateProps(props: ColorbarTicksProps) {\n    const { size, imageRange, voiRange } = props;\n\n    if (size && !isColorbarSizeValid(size)) {\n      throw new Error('Invalid \"size\"');\n    }\n\n    if (imageRange && !isRangeValid(imageRange)) {\n      throw new Error('Invalid \"imageRange\"');\n    }\n\n    if (voiRange && !isRangeValid(voiRange)) {\n      throw new Error('Invalid \"voiRange\"');\n    }\n  }\n\n  private _setCanvasSize(canvas: HTMLCanvasElement, size: ColorbarSize) {\n    const { width, height } = size;\n\n    canvas.width = width;\n    canvas.height = height;\n\n    Object.assign(canvas.style, {\n      width: `${width}px`,\n      height: `${height}px`,\n    });\n  }\n\n  private _createCanvasElement(\n    size: ColorbarSize,\n    top: number,\n    left: number\n  ): HTMLCanvasElement {\n    const canvas = document.createElement('canvas');\n\n    Object.assign(canvas.style, {\n      display: 'none',\n      position: 'absolute',\n      boxSizing: 'border-box',\n      top: `${top}px`,\n      left: `${left}px`,\n    });\n\n    this._setCanvasSize(canvas, size);\n\n    return canvas;\n  }\n\n  /**\n   * Calculate how many ticks can be displayed on the screen based on the\n   * pre-defined steps (`TICKS_STEPS`) as follow:\n   *   1. Calculate what should be the step (`roughStep`) based on the range and\n   *   the number of desired steps (`maxNumTicks`).\n   *   2. Find a number power of 10 (eg: 0.1, 1, 10, 100, etc.) that can be used\n   *   to multiply `roughStep` and return a number between 1 and 10 which is\n   *   called `roughtStepNormalized`.\n   *   3. Find in the TICKS_STEPS array a number that is bigger than or equal to\n   *   the `roughtStepNormalized` value (`normalizedStep`).\n   *   4. Multiply the `normalizedStep` to move it to the real range.\n   *\n   * @param range - Range with \"lower\" and \"upper\" values\n   */\n  private _getTicks(range) {\n    const { lower, upper } = range;\n    const rangeValue = upper - lower;\n\n    // First approximation based on the max number of ticks\n    const roughStep = rangeValue / (this._maxNumTicks - 1);\n\n    // Normalize rough step to find the normalized one that fits best\n    const stepPower = Math.pow(\n      10,\n      -Math.floor(Math.log10(Math.abs(roughStep)))\n    );\n\n    // Get a number between 1 and 10\n    const roughtStepNormalized = roughStep * stepPower;\n\n    // Find a normalize step that is greater than or equal to `roughtStepNormalized`\n    const normalizedStep = DEFAULTS.TICKS_STEPS.find(\n      (n) => n >= roughtStepNormalized\n    );\n\n    // Move `normalizedStep` to the real range\n    const step = normalizedStep / stepPower;\n\n    // Determine the scale limits based on the chosen step.\n    const scaleMax = Math.ceil(upper / step) * step;\n    const scaleMin = Math.floor(lower / step) * step;\n\n    // Find a possible tick values for the `step` computed\n    const ticksCount = Math.round((scaleMax - scaleMin) / step) + 1;\n    const ticks = [];\n\n    for (let i = 0; i < ticksCount; i++) {\n      ticks.push(scaleMin + i * step);\n    }\n\n    return { scaleMin, scaleMax, step, ticks };\n  }\n\n  private _getLeftTickInfo({ position, labelMeasure }) {\n    const { width } = this._canvas;\n    const labelX =\n      width - this.tickSize - labelMeasure.width - this._labelMargin;\n    const labelPoint = [labelX, position];\n    const tickPoints = {\n      start: [width - this._tickSize, position],\n      end: [width, position],\n    };\n\n    return { labelPoint, tickPoints };\n  }\n\n  private _getRightTickInfo({ position }) {\n    const labelPoint = [this._tickSize + this._labelMargin, position];\n    const tickPoints = {\n      start: [0, position],\n      end: [this._tickSize, position],\n    };\n\n    return { labelPoint, tickPoints };\n  }\n\n  private _getTopTickInfo({ position, labelMeasure }) {\n    throw new Error('Not implemented');\n  }\n\n  private _getBottomTickInfo({ position, labelMeasure }) {\n    throw new Error('Not implemented');\n  }\n\n  private render() {\n    const { _canvas: canvas } = this;\n\n    if (!canvas.isConnected || !this.visible) {\n      return;\n    }\n\n    const { width, height } = canvas;\n    const isHorizontal = width >= height;\n    const maxCanvasPixelValue = isHorizontal ? width : height;\n    const canvasContext = canvas.getContext('2d');\n    const { _voiRange: voiRange } = this;\n    const range = this._showFullPixelValueRange\n      ? this._imageRange\n      : { ...voiRange };\n    const rangeWidth = range.upper - range.lower;\n    const { ticks } = this._getTicks(range);\n\n    canvasContext.clearRect(0, 0, width, height);\n    canvasContext.font = this._font;\n    canvasContext.textBaseline = 'middle';\n    canvasContext.fillStyle = this._color;\n    canvasContext.strokeStyle = this._color;\n    canvasContext.lineWidth = this.tickWidth;\n\n    ticks.forEach((tick) => {\n      let position = Math.round(\n        maxCanvasPixelValue * ((tick - range.lower) / rangeWidth)\n      );\n\n      // Zero at the bottom and max at the top on vertical colorbars\n      if (!isHorizontal) {\n        position = height - position;\n      }\n\n      if (position < 0 || position > maxCanvasPixelValue) {\n        return;\n      }\n\n      const label = tick.toString();\n      const labelMeasure = canvasContext.measureText(label);\n      let tickInfo;\n\n      if (isHorizontal) {\n        if (this._rangeTextPosition === ColorbarRangeTextPosition.Top) {\n          tickInfo = this._getTopTickInfo({ position, labelMeasure });\n        } else {\n          tickInfo = this._getBottomTickInfo({ position, labelMeasure });\n        }\n      } else {\n        if (this._rangeTextPosition === ColorbarRangeTextPosition.Left) {\n          tickInfo = this._getLeftTickInfo({ position, labelMeasure });\n        } else {\n          tickInfo = this._getRightTickInfo({ position });\n        }\n      }\n\n      const { labelPoint, tickPoints } = tickInfo;\n      const { start: tickStart, end: tickEnd } = tickPoints;\n\n      canvasContext.beginPath();\n      canvasContext.moveTo(tickStart[0], tickStart[1]);\n      canvasContext.lineTo(tickEnd[0], tickEnd[1]);\n      canvasContext.fillText(label, labelPoint[0], labelPoint[1]);\n      canvasContext.stroke();\n\n      return position;\n    });\n  }\n}\n\nexport { ColorbarTicks as default, ColorbarTicks };\n","import type { WidgetProps, WidgetSize } from './types';\n\n/**\n * Base class for any widget that can be added to cornerstone. Currently it is\n * responsible only for holding the `rootElement`, contains a method that allows\n * adding it to the DOM and it also listens to container's size changes when the\n * widget is already added to the DOM. `dispose` must be called to destroy the\n * widget because it removes the widget from the DOM and stop listening to\n * container changes.\n *\n * You can apply some styles to widgets using the widget id or the `widget` class.\n *\n * Example:\n *   type ColorPickerProps = WidgetProps & {\n *     selectedColor: string;\n *   }\n *\n *   class ColorPicker extends Widget {\n *     constructor(props: ColorPickerProps) {\n *       super(props);\n *       // [code]\n *     }\n *\n *     public show() {\n *       console.log('Show color picker');\n *     }\n *\n *     protected containerResized() {\n *       console.log('New container size: ', this.containerSize);\n *     }\n *   }\n *\n *   const colorPicker = new ColorPicker({\n *     container: document.body,\n *     selectedColor: '#000';\n *   });\n *\n *   // another way to add the color picker to the DOM\n *   colorPicker.appendTo(document.body)\n *\n *   // Show color picker\n *   colorPicker.show();\n */\nabstract class Widget {\n  private _id: string;\n  private _rootElement: HTMLElement;\n  private _containerSize: WidgetSize;\n  private _containerResizeObserver: ResizeObserver;\n\n  constructor({ id, container }: WidgetProps) {\n    this._id = id;\n    this._containerSize = { width: 0, height: 0 };\n    this._rootElement = this.createRootElement(id);\n    this._containerResizeObserver = new ResizeObserver(\n      this._containerResizeCallback\n    );\n\n    if (container) {\n      this.appendTo(container);\n    }\n  }\n\n  /**\n   * Widget id\n   */\n  public get id() {\n    return this._id;\n  }\n\n  /**\n   * Widget's root element\n   */\n  public get rootElement(): HTMLElement {\n    return this._rootElement;\n  }\n\n  /**\n   * Append the widget to a parent element\n   * @param container - HTML element where the widget should be added to\n   */\n  public appendTo(container: HTMLElement) {\n    const {\n      _rootElement: rootElement,\n      _containerResizeObserver: resizeObserver,\n    } = this;\n    const { parentElement: currentContainer } = rootElement;\n\n    if (!container || container === currentContainer) {\n      return;\n    }\n\n    if (currentContainer) {\n      resizeObserver.unobserve(currentContainer);\n    }\n\n    container.appendChild(rootElement);\n    resizeObserver.observe(container);\n  }\n\n  /**\n   * Removes the widget from the DOM and stop listening to DOM events\n   */\n  public destroy() {\n    const {\n      _rootElement: rootElement,\n      _containerResizeObserver: resizeObserver,\n    } = this;\n    const { parentElement } = rootElement;\n\n    parentElement?.removeChild(rootElement);\n    resizeObserver.disconnect();\n  }\n\n  protected get containerSize(): WidgetSize {\n    // Returns a copy to prevent any external change\n    return { ...this._containerSize };\n  }\n\n  /**\n   * Creates the root element which is a div by default\n   * @param id - Root element id\n   * @returns A new HTML element where all other elements should be added to\n   */\n  protected createRootElement(id: string): HTMLElement {\n    const rootElement = document.createElement('div');\n\n    rootElement.id = id;\n    rootElement.classList.add('widget');\n\n    Object.assign(rootElement.style, {\n      width: '100%',\n      height: '100%',\n    });\n\n    return rootElement;\n  }\n\n  /**\n   * Method called every time widget's container is resize giving the\n   * opportunity to children classes to act when that happens.\n   */\n  protected onContainerResize() {\n    // no-op\n  }\n\n  private _containerResizeCallback = (entries: ResizeObserverEntry[]): void => {\n    let width;\n    let height;\n\n    const { contentRect, contentBoxSize } = entries[0];\n\n    // `contentRect` is better supported than `borderBoxSize` or `contentBoxSize`,\n    // but it is left over from an earlier implementation of the Resize Observer API\n    // and may be deprecated in future versions.\n    // https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry/contentRect\n    if (contentRect) {\n      width = contentRect.width;\n      height = contentRect.height;\n    } else if (contentBoxSize?.length) {\n      width = contentBoxSize[0].inlineSize;\n      height = contentBoxSize[0].blockSize;\n    }\n\n    this._containerSize = { width, height };\n    this.onContainerResize();\n  };\n}\n\nexport { Widget as default, Widget };\n","import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\nimport { vec2 } from 'gl-matrix';\nimport { utilities as csUtils, Types } from '@cornerstonejs/core';\nimport type { ColorbarProps, ColorbarVOIRange } from './types';\nimport { isRangeValid, areColorbarRangesEqual } from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\nimport { ColorbarCanvas } from './ColorbarCanvas';\nimport { ColorbarTicks } from './ColorbarTicks';\nimport isRangeTextPositionValid from './common/isRangeTextPositionValid';\nimport Widget from '../../../widgets/Widget';\n\nconst DEFAULTS = {\n  MULTIPLIER: 1,\n  RANGE_TEXT_POSITION: ColorbarRangeTextPosition.Right,\n  TICKS_BAR_SIZE: 50,\n};\n\ntype ColorbarPoints = {\n  page: Types.Point2;\n  client: Types.Point2;\n  local: Types.Point2;\n};\n\n/**\n * A base colorbar class that is not associated with any viewport. It is\n * possible to click and drag to change the VOI range, shows the ticks during\n * interaction and it can show full image range or VOI range.\n */\nclass Colorbar extends Widget {\n  private _colormaps: Map<string, IColorMapPreset>;\n  private _activeColormapName: string;\n  private _eventListenersManager: csUtils.eventListener.MultiTargetEventListenerManager;\n  private _canvas: ColorbarCanvas;\n  private _ticksBar: ColorbarTicks;\n  private _rangeTextPosition: ColorbarRangeTextPosition;\n\n  private _isMouseOver = false;\n  private _isInteracting = false;\n\n  constructor(props: ColorbarProps) {\n    super(props);\n\n    this._eventListenersManager =\n      new csUtils.eventListener.MultiTargetEventListenerManager();\n    this._colormaps = Colorbar.getColormapsMap(props);\n    this._activeColormapName = Colorbar.getInitialColormapName(props);\n    this._canvas = this._createCanvas(props);\n    this._ticksBar = this._createTicksBar(props);\n    this._rangeTextPosition =\n      props.ticks?.position ?? DEFAULTS.RANGE_TEXT_POSITION;\n\n    this._canvas.appendTo(this.rootElement);\n    this._ticksBar.appendTo(this.rootElement);\n\n    this._addRootElementEventListeners();\n  }\n\n  /**\n   * Returns the active LUT name\n   */\n  public get activeColormapName() {\n    return this._activeColormapName;\n  }\n\n  /**\n   * Set the current active LUT name and re-renders the color bar\n   */\n  public set activeColormapName(colormapName: string) {\n    if (colormapName === this._activeColormapName) {\n      return;\n    }\n\n    const colormap = this._colormaps.get(colormapName);\n\n    if (!colormap) {\n      console.warn(`Invalid colormap name (${colormapName})`);\n      return;\n    }\n\n    this._activeColormapName = colormapName;\n    this._canvas.colormap = colormap;\n  }\n\n  public get imageRange() {\n    return this._canvas.imageRange;\n  }\n\n  public set imageRange(imageRange: ColorbarVOIRange) {\n    this._canvas.imageRange = imageRange;\n    this._ticksBar.imageRange = imageRange;\n  }\n\n  public get voiRange() {\n    return this._canvas.voiRange;\n  }\n\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    const { voiRange: currentVoiRange } = this._canvas;\n\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, currentVoiRange)\n    ) {\n      return;\n    }\n\n    this._canvas.voiRange = voiRange;\n    this._ticksBar.voiRange = voiRange;\n    this.onVoiChange(voiRange);\n  }\n\n  public get showFullImageRange() {\n    return this._canvas.showFullImageRange;\n  }\n\n  public set showFullImageRange(value: boolean) {\n    this._canvas.showFullImageRange = value;\n    this._ticksBar.showFullPixelValueRange = value;\n  }\n\n  public destroy() {\n    super.destroy();\n    this._eventListenersManager.reset();\n  }\n\n  protected createRootElement(): HTMLElement {\n    const rootElement = document.createElement('div');\n\n    Object.assign(rootElement.style, {\n      position: 'relative',\n      fontSize: '0',\n      width: '100%',\n      height: '100%',\n    });\n\n    return rootElement;\n  }\n\n  protected onContainerResize() {\n    super.onContainerResize();\n    this.updateTicksBar();\n    this._canvas.size = this.containerSize;\n  }\n\n  protected getVOIMultipliers(): [number, number] {\n    return [DEFAULTS.MULTIPLIER, DEFAULTS.MULTIPLIER];\n  }\n\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\n    // no-op\n  }\n\n  protected showTicks() {\n    this.updateTicksBar();\n    this._ticksBar.visible = true;\n  }\n\n  protected hideTicks() {\n    if (this._isInteracting || this._isMouseOver) {\n      return;\n    }\n\n    this._ticksBar.visible = false;\n  }\n\n  private static getColormapsMap(props: ColorbarProps) {\n    const { colormaps } = props;\n\n    return colormaps.reduce(\n      (items, item) => items.set(item.Name, item),\n      new Map<string, IColorMapPreset>()\n    );\n  }\n\n  private static getInitialColormapName(props: ColorbarProps) {\n    const { activeColormapName, colormaps } = props;\n    const colormapExists =\n      !!activeColormapName &&\n      colormaps.some((cm) => cm.Name === activeColormapName);\n\n    return colormapExists ? activeColormapName : colormaps[0].Name;\n  }\n\n  private _createCanvas(props: ColorbarProps) {\n    const { imageRange, voiRange, showFullPixelValueRange } = props;\n    const colormap = this._colormaps.get(this._activeColormapName);\n\n    return new ColorbarCanvas({\n      colormap,\n      imageRange,\n      voiRange: voiRange,\n      showFullPixelValueRange,\n    });\n  }\n\n  public _createTicksBar(props: ColorbarProps): ColorbarTicks {\n    const ticksProps = props.ticks;\n\n    return new ColorbarTicks({\n      imageRange: props.imageRange,\n      voiRange: props.voiRange,\n      ticks: ticksProps,\n      showFullPixelValueRange: props.showFullPixelValueRange,\n    });\n  }\n\n  private _getPointsFromMouseEvent(evt: MouseEvent): ColorbarPoints {\n    const { rootElement: element } = this;\n    const clientPoint: Types.Point2 = [evt.clientX, evt.clientY];\n    const pagePoint: Types.Point2 = [evt.pageX, evt.pageY];\n    const rect = element.getBoundingClientRect();\n    const localPoints: Types.Point2 = [\n      pagePoint[0] - rect.left - window.pageXOffset,\n      pagePoint[1] - rect.top - window.pageYOffset,\n    ];\n\n    return { client: clientPoint, page: pagePoint, local: localPoints };\n  }\n\n  private updateTicksBar() {\n    const { width: containerWidth, height: containerHeight } =\n      this.containerSize;\n\n    // ResizeObserver have not triggered any event when this happen\n    if (containerWidth === 0 && containerHeight === 0) {\n      return;\n    }\n\n    const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;\n    const isHorizontal = containerWidth >= containerHeight;\n    const width = isHorizontal ? containerWidth : DEFAULTS.TICKS_BAR_SIZE;\n    const height = isHorizontal ? DEFAULTS.TICKS_BAR_SIZE : containerHeight;\n\n    if (\n      !isRangeTextPositionValid(\n        containerWidth,\n        containerHeight,\n        rangeTextPosition\n      )\n    ) {\n      throw new Error(\n        'Invalid rangeTextPosition value for the current colobar orientation'\n      );\n    }\n\n    let ticksBarTop;\n    let ticksBarLeft;\n\n    ticksBar.size = { width, height };\n\n    if (isHorizontal) {\n      ticksBarLeft = 0;\n      ticksBarTop =\n        rangeTextPosition === ColorbarRangeTextPosition.Top\n          ? -height\n          : containerHeight;\n    } else {\n      ticksBarTop = 0;\n      ticksBarLeft =\n        rangeTextPosition === ColorbarRangeTextPosition.Left\n          ? -width\n          : containerWidth;\n    }\n\n    ticksBar.top = ticksBarTop;\n    ticksBar.left = ticksBarLeft;\n  }\n\n  private _mouseOverCallback = (evt) => {\n    this._isMouseOver = true;\n    this.showTicks();\n    evt.stopPropagation();\n  };\n\n  private _mouseOutCallback = (evt) => {\n    this._isMouseOver = false;\n    this.hideTicks();\n    evt.stopPropagation();\n  };\n\n  private _mouseDownCallback = (evt: MouseEvent) => {\n    this._isInteracting = true;\n    this.showTicks();\n    this._addVOIEventListeners(evt);\n    evt.stopPropagation();\n  };\n\n  private _mouseDragCallback = (evt, initialState) => {\n    const multipliers = this.getVOIMultipliers();\n    const currentPoints = this._getPointsFromMouseEvent(evt);\n    const { points: startPoints, voiRange: startVOIRange } = initialState;\n    const canvasDelta = vec2.sub(\n      vec2.create(),\n      currentPoints.local,\n      startPoints.local\n    );\n\n    const wwDelta = canvasDelta[0] * multipliers[0];\n    const wcDelta = canvasDelta[1] * multipliers[1];\n\n    if (!wwDelta && !wcDelta) {\n      return;\n    }\n\n    const { lower: voiLower, upper: voiUpper } = startVOIRange;\n    let { windowWidth, windowCenter } = csUtils.windowLevel.toWindowLevel(\n      voiLower,\n      voiUpper\n    );\n\n    windowWidth = Math.max(windowWidth + wwDelta, 1);\n    windowCenter += wcDelta;\n\n    const newVoiRange = csUtils.windowLevel.toLowHighRange(\n      windowWidth,\n      windowCenter\n    );\n\n    this.voiRange = newVoiRange;\n    evt.stopPropagation();\n    evt.preventDefault();\n  };\n\n  private _mouseUpCallback = (evt) => {\n    this._isInteracting = false;\n    this.hideTicks();\n    this._removeVOIEventListeners();\n    evt.stopPropagation();\n  };\n\n  private _addRootElementEventListeners() {\n    const { _eventListenersManager: manager } = this;\n    const { rootElement: element } = this;\n\n    manager.addEventListener(element, 'mouseover', this._mouseOverCallback);\n    manager.addEventListener(element, 'mouseout', this._mouseOutCallback);\n    manager.addEventListener(\n      element,\n      'mousedown',\n      this._mouseDownCallback as EventListener\n    );\n  }\n\n  private _addVOIEventListeners(evt: MouseEvent) {\n    const { _eventListenersManager: manager } = this;\n    const points = this._getPointsFromMouseEvent(evt);\n    const voiRange = { ...this._canvas.voiRange };\n    const initialDragState = { points, voiRange };\n\n    this._removeVOIEventListeners();\n\n    manager.addEventListener(document, 'voi.mouseup', this._mouseUpCallback);\n    manager.addEventListener(document, 'voi.mousemove', (evt) =>\n      this._mouseDragCallback(evt, initialDragState)\n    );\n  }\n\n  private _removeVOIEventListeners() {\n    const { _eventListenersManager: manager } = this;\n\n    manager.removeEventListener(document, 'voi.mouseup');\n    manager.removeEventListener(document, 'voi.mousemove');\n  }\n}\n\nexport { Colorbar as default, Colorbar };\n","import { ColorbarRangeTextPosition } from '../enums';\n\nfunction isRangeTextPositionValid(\n  colorbarWidth: number,\n  colorbarHeight: number,\n  rangeTextPosition: ColorbarRangeTextPosition\n) {\n  const isHorizontal = colorbarWidth >= colorbarHeight;\n  const validRangeTextPositions = isHorizontal\n    ? [ColorbarRangeTextPosition.Top, ColorbarRangeTextPosition.Bottom]\n    : [ColorbarRangeTextPosition.Left, ColorbarRangeTextPosition.Right];\n\n  return validRangeTextPositions.includes(rangeTextPosition);\n}\n\nexport { isRangeTextPositionValid as default, isRangeTextPositionValid };\n","import {\n  eventTarget,\n  VolumeViewport,\n  StackViewport,\n  Types,\n  Enums,\n  utilities,\n  getEnabledElement,\n} from '@cornerstonejs/core';\nimport { Colorbar } from './Colorbar';\nimport type { ViewportColorbarProps, ColorbarVOIRange } from './types';\nimport { getVOIMultipliers } from '../../getVOIMultipliers';\n\nconst { Events } = Enums;\nconst defaultImageRange = { lower: -1000, upper: 1000 };\n/**\n * A colorbar associated with a viewport that updates automatically when the\n * viewport VOI changes or when the stack/volume are updated..\n */\nclass ViewportColorbar extends Colorbar {\n  private _element: HTMLDivElement;\n  private _volumeId: string;\n\n  private _hideTicksTime: number;\n  private _hideTicksTimeoutId: number;\n\n  constructor(props: ViewportColorbarProps) {\n    const { element, volumeId } = props;\n    const imageRange = ViewportColorbar._getImageRange(element, volumeId);\n    const voiRange = ViewportColorbar._getVOIRange(element, volumeId);\n\n    super({ ...props, imageRange, voiRange });\n\n    this._element = element;\n    this._volumeId = volumeId;\n\n    this._addCornerstoneEventListener();\n  }\n\n  public get element() {\n    return this._element;\n  }\n\n  public get enabledElement() {\n    return getEnabledElement(this._element);\n  }\n\n  protected getVOIMultipliers(): [number, number] {\n    const { viewport } = this.enabledElement;\n    return getVOIMultipliers(viewport, this._volumeId);\n  }\n\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\n    super.onVoiChange(voiRange);\n\n    const { viewport } = this.enabledElement;\n\n    if (viewport instanceof StackViewport) {\n      viewport.setProperties({\n        voiRange: voiRange,\n      });\n      viewport.render();\n    } else if (viewport instanceof VolumeViewport) {\n      const { _volumeId: volumeId } = this;\n      const viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(\n        volumeId,\n        viewport.renderingEngineId\n      );\n\n      viewport.setProperties({ voiRange }, volumeId);\n      viewportsContainingVolumeUID.forEach((vp) => vp.render());\n    }\n  }\n\n  private static _getImageRange(element, volumeId?) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const actor = volumeId\n      ? viewport.getActor(volumeId)\n      : viewport.getDefaultActor();\n\n    if (!actor) {\n      return defaultImageRange;\n    }\n\n    const imageData = actor.actor.getMapper().getInputData();\n    const imageRange = imageData.getPointData().getScalars().getRange();\n\n    return imageRange[0] === 0 && imageRange[1] === 0\n      ? defaultImageRange\n      : { lower: imageRange[0], upper: imageRange[1] };\n  }\n\n  private static _getVOIRange(element, volumeId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const volumeActor = volumeId\n      ? viewport.getActor(volumeId)\n      : viewport.getDefaultActor();\n\n    if (!volumeActor || !utilities.isImageActor(volumeActor)) {\n      return defaultImageRange;\n    }\n\n    const voiRange = (volumeActor.actor as Types.ImageActor)\n      .getProperty()\n      .getRGBTransferFunction(0)\n      .getRange();\n\n    return voiRange[0] === 0 && voiRange[1] === 0\n      ? defaultImageRange\n      : { lower: voiRange[0], upper: voiRange[1] };\n  }\n\n  private autoHideTicks = () => {\n    // Avoiding calling setTimeout multiple times when manipulating the VOI\n    // via WindowLevel tool for better performance\n    if (this._hideTicksTimeoutId) {\n      return;\n    }\n\n    const timeLeft = this._hideTicksTime - Date.now();\n\n    if (timeLeft <= 0) {\n      this.hideTicks();\n    } else {\n      this._hideTicksTimeoutId = window.setTimeout(() => {\n        // Recursive call until there is no more time left\n        this._hideTicksTimeoutId = 0;\n        this.autoHideTicks();\n      }, timeLeft);\n    }\n  };\n\n  private showAndAutoHideTicks(interval = 1000) {\n    this._hideTicksTime = Date.now() + interval;\n    this.showTicks();\n    this.autoHideTicks();\n  }\n\n  private _stackNewImageCallback = () => {\n    this.imageRange = ViewportColorbar._getImageRange(this._element);\n  };\n\n  private _imageVolumeModifiedCallback = (\n    evt: Types.EventTypes.ImageVolumeModifiedEvent\n  ) => {\n    const { volumeId } = evt.detail.imageVolume;\n\n    if (volumeId !== this._volumeId) {\n      return;\n    }\n\n    const { _element: element } = this;\n    this.imageRange = ViewportColorbar._getImageRange(element, volumeId);\n  };\n\n  private _viewportVOIModifiedCallback = (\n    evt: Types.EventTypes.VoiModifiedEvent\n  ) => {\n    const { viewportId, volumeId, range: voiRange } = evt.detail;\n    const { viewport } = this.enabledElement;\n\n    if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n      return;\n    }\n\n    this.voiRange = voiRange;\n    this.showAndAutoHideTicks();\n  };\n\n  private _viewportColormapModifiedCallback = (\n    evt: Types.EventTypes.ColormapModifiedEvent\n  ) => {\n    const { viewportId, colormap, volumeId  } = evt.detail;\n    const { viewport } = this.enabledElement;\n\n    if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n      return;\n    }\n\n    this.activeColormapName = colormap.name;\n  };\n\n  private _addCornerstoneEventListener() {\n    const { _element: element } = this;\n\n    eventTarget.addEventListener(\n      Events.IMAGE_VOLUME_MODIFIED,\n      this._imageVolumeModifiedCallback\n    );\n\n    element.addEventListener(\n      Events.STACK_NEW_IMAGE,\n      this._stackNewImageCallback\n    );\n\n    element.addEventListener(\n      Events.VOI_MODIFIED,\n      this._viewportVOIModifiedCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.COLORMAP_MODIFIED,\n      this._viewportColormapModifiedCallback as EventListener\n    );\n  }\n}\n\nexport { ViewportColorbar as default, ViewportColorbar };\n","import { Types, utilities as csUtils } from '@cornerstonejs/core';\nimport { isViewportPreScaled } from './viewport';\n\nconst DEFAULT_MULTIPLIER = 4;\n\nfunction getVOIMultipliers(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  volumeId?: string,\n  options?: {\n    fixedPTWindowWidth?: boolean;\n  }\n): [number, number] {\n  const modality = csUtils.getViewportModality(viewport, volumeId);\n\n  if (modality === 'PT') {\n    const { clientWidth, clientHeight } = viewport.element;\n    const ptMultiplier = 5 / Math.max(clientWidth, clientHeight);\n    const isPreScaled = isViewportPreScaled(viewport, volumeId);\n    const { fixedPTWindowWidth = true } = options ?? {};\n\n    // Set the \"X\" multiplier equal to zero in order to do not allow\n    // any change to the window width (0 * cursorDeltaX = 0)\n    const xMultiplier = fixedPTWindowWidth ? 0 : ptMultiplier;\n\n    return isPreScaled\n      ? [xMultiplier, ptMultiplier]\n      : [xMultiplier, DEFAULT_MULTIPLIER];\n  }\n\n  return [DEFAULT_MULTIPLIER, DEFAULT_MULTIPLIER];\n}\n\nexport { getVOIMultipliers as default, getVOIMultipliers };\n","import { utilities } from '@cornerstonejs/core';\n\nimport {\n  getAnnotationNearPoint,\n  getAnnotationNearPointOnEnabledElement,\n} from './getAnnotationNearPoint';\n\n// Lodash/common JS functionality\nimport debounce from './debounce';\nimport throttle from './throttle';\nimport isObject from './isObject';\nimport clip from './clip';\nimport calibrateImageSpacing from './calibrateImageSpacing';\nimport {\n  getCalibratedLengthUnitsAndScale,\n  getCalibratedProbeUnitsAndValue,\n  getCalibratedAspect,\n} from './getCalibratedUnits';\nimport triggerAnnotationRenderForViewportIds from './triggerAnnotationRenderForViewportIds';\nimport triggerAnnotationRenderForToolGroupIds from './triggerAnnotationRenderForToolGroupIds';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport jumpToSlice from './viewport/jumpToSlice';\n\nimport pointInShapeCallback from './pointInShapeCallback';\nimport { getSphereBoundsInfo } from './getSphereBoundsInfo';\nimport scroll from './scroll';\nimport { pointToString } from './pointToString';\nimport annotationFrameRange from './annotationFrameRange';\nimport pointInSurroundingSphereCallback from './pointInSurroundingSphereCallback';\nimport getViewportForAnnotation from './getViewportForAnnotation';\n\n// name spaces\nimport * as contours from './contours';\nimport * as segmentation from './segmentation';\nimport * as drawing from './drawing';\nimport * as math from './math';\nimport * as planar from './planar';\nimport * as viewportFilters from './viewportFilters';\nimport * as orientation from './orientation';\nimport * as cine from './cine';\nimport * as boundingBox from './boundingBox';\nimport * as planarFreehandROITool from './planarFreehandROITool';\nimport * as rectangleROITool from './rectangleROITool';\nimport { stackPrefetch, stackContextPrefetch } from './stackPrefetch';\nimport * as viewport from './viewport';\nimport * as touch from './touch';\nimport * as dynamicVolume from './dynamicVolume';\nimport * as polyDataUtils from './polyData/utils';\nimport * as voi from './voi';\nimport * as contourSegmentation from './contourSegmentation';\n\nconst roundNumber = utilities.roundNumber;\n\n// Events\nimport { triggerEvent } from '@cornerstonejs/core';\n\nexport {\n  math,\n  planar,\n  viewportFilters,\n  drawing,\n  debounce,\n  dynamicVolume,\n  throttle,\n  orientation,\n  isObject,\n  touch,\n  triggerEvent,\n  calibrateImageSpacing,\n  getCalibratedLengthUnitsAndScale,\n  getCalibratedProbeUnitsAndValue,\n  getCalibratedAspect,\n  segmentation,\n  contours,\n  triggerAnnotationRenderForViewportIds,\n  triggerAnnotationRenderForToolGroupIds,\n  triggerAnnotationRender,\n  pointInShapeCallback,\n  getSphereBoundsInfo,\n  getAnnotationNearPoint,\n  getViewportForAnnotation,\n  getAnnotationNearPointOnEnabledElement,\n  jumpToSlice,\n  pointInSurroundingSphereCallback,\n  viewport,\n  cine,\n  clip,\n  boundingBox,\n  rectangleROITool,\n  planarFreehandROITool,\n  stackPrefetch,\n  stackContextPrefetch,\n  scroll,\n  roundNumber,\n  pointToString,\n  polyDataUtils,\n  voi,\n  annotationFrameRange,\n  contourSegmentation,\n};\n","import { Types } from '@cornerstonejs/core';\nimport { point } from '../math';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\n\nexport function shouldSmooth(\n  configuration: Record<any, any>,\n  annotation?\n): boolean {\n  if (annotation?.autoGenerated) {\n    return false;\n  }\n  const shouldSmooth =\n    configuration?.smoothing?.smoothOnAdd === true ||\n    configuration?.smoothing?.smoothOnEdit === true;\n\n  return shouldSmooth;\n}\n\n/**\n * Tells whether two points are equal by proximity or not as far as interpolation goes.\n */\nfunction isEqualByProximity(pointA, pointB) {\n  return point.distanceToPoint(pointA, pointB) < 0.001;\n}\n\n/**\n * Tells whether two points are strictly equal or not as far as interpolation goes.\n */\nfunction isEqual(pointA, pointB) {\n  return point.distanceToPoint(pointA, pointB) === 0;\n}\n\n/**\n * Finds the indexes of points list and otherPoints list that points are identical.\n */\nfunction findMatchIndexes(\n  points: Types.Point2[],\n  otherPoints: Types.Point2[]\n): [number, number] | undefined {\n  for (let i = 0; i < points.length; i++) {\n    for (let j = 0; j < otherPoints.length; j++) {\n      if (isEqual(points[i], otherPoints[j])) {\n        return [i, j];\n      }\n    }\n  }\n}\n/**\n * Returns the following index value (on circular basis) of index param on the given direction.\n */\nfunction followingIndex(\n  index: number,\n  size: number,\n  direction: number\n): number {\n  return (index + size + direction) % size;\n}\n/**\n * Array of params to be used on circular find next index.\n * The values respresent start index, indexDelimiter, list of points\n */\ntype ListParamsType = [number, number, Types.Point2[]];\n\n/**\n * Circular finding that returns the next index for two list where the criteria is met.\n *\n * It can compare two lists out of sync considering it does a circular iteration over them.\n *\n * @example\n *\n * ```\n * const pointsA = [[0, 1], [1, 3], [1, 5], [1,2]];\n * const pointsB = [[1, 2], [1, 5], [1, 3], [0,0]];\n * let firstParam = [0, 0, pointsA]\n * let secondParam = [1, 1, pointsB]\n * const criteria = (pointA, pointB) => areSamePosition(pointA, pointB)\n * const direction = 1;\n * let result = circularFindNextIndexBy(firstParam, secondParam, criteria,direction);\n * console.log(result);\n * // prints [1, 2]\n * // use this result and find again\n * firstParam = [result[0]+1, result[0], pointsA]\n * secondParam = [result[1]+1, result[1], pointsB]\n * result = circularFindNextIndexBy(firstParam, secondParam, criteria,direction);\n * * // prints [3, 0]\n *\n */\nfunction circularFindNextIndexBy(\n  listParams: ListParamsType,\n  otherListParams: ListParamsType,\n  criteria: (pointA: Types.Point2, pointB: Types.Point2) => boolean,\n  direction: number\n): [number | undefined, number | undefined] {\n  const [, indexDelimiter, points] = listParams;\n  const [, otherIndexDelimiter, otherPoints] = otherListParams;\n\n  const pointsLength = points.length;\n  const otherPointsLength = otherPoints.length;\n\n  let startIndex = listParams[0];\n  let otherStartIndex = otherListParams[0];\n\n  if (\n    !points[startIndex] ||\n    !otherPoints[otherStartIndex] ||\n    !points[indexDelimiter] ||\n    !otherPoints[otherIndexDelimiter]\n  ) {\n    return [undefined, undefined];\n  }\n\n  while (\n    startIndex !== indexDelimiter &&\n    otherStartIndex !== otherIndexDelimiter\n  ) {\n    if (criteria(otherPoints[otherStartIndex], points[startIndex])) {\n      return [startIndex, otherStartIndex];\n    }\n\n    startIndex = followingIndex(startIndex, pointsLength, direction);\n    otherStartIndex = followingIndex(\n      otherStartIndex,\n      otherPointsLength,\n      direction\n    );\n  }\n\n  return [undefined, undefined];\n}\n\n/**\n * Given two list it will find the first and last index of segment from points that diverges from previousPoints\n */\nfunction findChangedSegment(\n  points: Types.Point2[],\n  previousPoints: Types.Point2[]\n): [number, number] {\n  const [firstMatchIndex, previousFirstMatchIndex] =\n    findMatchIndexes(points, previousPoints) || [];\n\n  const toBeNotEqualCriteria = (pointA, pointB) =>\n    isEqualByProximity(pointA, pointB) === false;\n\n  const [lowDiffIndex, lowOtherDiffIndex] = circularFindNextIndexBy(\n    [\n      followingIndex(firstMatchIndex, points.length, 1),\n      firstMatchIndex,\n      points,\n    ],\n    [\n      followingIndex(previousFirstMatchIndex, previousPoints.length, 1),\n      previousFirstMatchIndex,\n      previousPoints,\n    ],\n    toBeNotEqualCriteria,\n    1\n  );\n\n  const [highIndex] = circularFindNextIndexBy(\n    [followingIndex(lowDiffIndex, points.length, -1), lowDiffIndex, points],\n    [\n      followingIndex(lowOtherDiffIndex, previousPoints.length, -1),\n      lowOtherDiffIndex,\n      previousPoints,\n    ],\n    toBeNotEqualCriteria,\n    -1\n  );\n\n  return [lowDiffIndex, highIndex];\n}\n\n/**\n * Interpolates the given list of points. In case there is a pointsOfReference the interpolation will occur only on segment disjoint of two list. I.e list of points from param points that are not on list of points from param pointsOfReference.\n */\nexport function getInterpolatedPoints(\n  configuration: Record<any, any>,\n  points: Types.Point2[],\n  pointsOfReference?: Types.Point2[]\n): Types.Point2[] {\n  const { interpolation, smoothing } = configuration;\n\n  const result = points;\n\n  if (interpolation) {\n    const {\n      knotsRatioPercentageOnAdd,\n      knotsRatioPercentageOnEdit,\n      smoothOnAdd = false,\n      smoothOnEdit = false,\n    } = smoothing;\n\n    const knotsRatioPercentage = pointsOfReference\n      ? knotsRatioPercentageOnEdit\n      : knotsRatioPercentageOnAdd;\n    const isEnabled = pointsOfReference ? smoothOnEdit : smoothOnAdd;\n\n    if (isEnabled) {\n      // partial or total interpolation\n      const [changedIniIndex, changedEndIndex] = pointsOfReference\n        ? findChangedSegment(points, pointsOfReference)\n        : [0, points.length - 1];\n\n      // do not interpolate if there is no valid segment\n      if (!points[changedIniIndex] || !points[changedEndIndex]) {\n        return points;\n      }\n\n      return <Types.Point2[]>(\n        interpolateSegmentPoints(\n          points,\n          changedIniIndex,\n          changedEndIndex,\n          knotsRatioPercentage\n        )\n      );\n    }\n  }\n\n  return result;\n}\n","/**\n * Mouse This enum enumerates the different buttons returned by `.buttons` on the mouse event.\n * These values are used when setting a tool active in a tool group.\n *\n * See also: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n */\nenum MouseBindings {\n  /** usually the left button */\n  Primary = 1,\n  /** usually the right button */\n  Secondary = 2,\n  Primary_And_Secondary = 3,\n  /** usually mouse wheel button */\n  Auxiliary = 4,\n  Primary_And_Auxiliary = 5,\n  Secondary_And_Auxiliary = 6,\n  Primary_And_Secondary_And_Auxiliary = 7,\n  /** usually \"Browser Back\" button */\n  Fourth_Button = 8,\n  /** usually \"Browser Forward\" button */\n  Fifth_Button = 16,\n}\n\nenum KeyboardBindings {\n  Shift = 16,\n  Ctrl = 17,\n  Alt = 18,\n  Meta = 91,\n  ShiftCtrl = 1617,\n  ShiftAlt = 1618,\n  ShiftMeta = 1691,\n  CtrlAlt = 1718,\n  CtrlMeta = 1791,\n  AltMeta = 1891,\n}\n\nexport { MouseBindings, KeyboardBindings };\n","import { KeyboardBindings as kb } from '../../enums';\n\n/**\n * Gets the mouse modifier key from a mouse event.\n * Supports Shift, Ctrl, Alt, in singly and in combinations of 2\n * Supports Meta singly.\n */\nconst getMouseModifierKey = (evt) => {\n  // The logic is a hard coded key mapping\n  if (evt.shiftKey) {\n    if (evt.ctrlKey) {\n      return kb.ShiftCtrl;\n    }\n    if (evt.altKey) {\n      return kb.ShiftAlt;\n    }\n    if (evt.metaKey) {\n      return kb.ShiftMeta;\n    }\n    return kb.Shift;\n  }\n  if (evt.ctrlKey) {\n    if (evt.altKey) {\n      return kb.CtrlAlt;\n    }\n    if (evt.metaKey) {\n      return kb.CtrlMeta;\n    }\n    return kb.Ctrl;\n  }\n  if (evt.altKey) {\n    return (evt.metaKey && kb.AltMeta) || kb.Alt;\n  }\n  if (evt.metaKey) {\n    return kb.Meta;\n  }\n  return undefined;\n};\n\nexport default getMouseModifierKey;\n","import type { Types } from '@cornerstonejs/core';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport { vec2 } from 'gl-matrix';\n\n/**\n * Finds the length of the longest line from the midpoint of the line\n * that joins the start and end of the open contour, to the surface of the\n * open contour.\n */\nexport default function findOpenUShapedContourVectorToPeak(\n  canvasPoints: Types.Point2[],\n  viewport: Types.IStackViewport | Types.IVolumeViewport\n): Types.Point3[] {\n  // Find chord from first to last point.\n  const first = canvasPoints[0];\n  const last = canvasPoints[canvasPoints.length - 1];\n\n  const firstToLastUnitVector = vec2.create();\n\n  vec2.set(firstToLastUnitVector, last[0] - first[0], last[1] - first[1]);\n  vec2.normalize(firstToLastUnitVector, firstToLastUnitVector);\n\n  // Get the two possible normal vector to this vector\n  // Note: Use the identity that the perpendicular line must have a gradient of\n  // 1 / gradient of the line.\n\n  const normalVector1 = vec2.create();\n  const normalVector2 = vec2.create();\n\n  vec2.set(normalVector1, -firstToLastUnitVector[1], firstToLastUnitVector[0]);\n  vec2.set(normalVector2, firstToLastUnitVector[1], -firstToLastUnitVector[0]);\n\n  // Find the center of the chord.\n  const centerOfFirstToLast: Types.Point2 = [\n    (first[0] + last[0]) / 2,\n    (first[1] + last[1]) / 2,\n  ];\n\n  // Get furthest point.\n\n  const furthest = {\n    dist: 0,\n    index: null,\n  };\n\n  for (let i = 0; i < canvasPoints.length; i++) {\n    const canvasPoint = canvasPoints[i];\n\n    const distance = vec2.dist(canvasPoint, <vec2>centerOfFirstToLast);\n\n    if (distance > furthest.dist) {\n      furthest.dist = distance;\n      furthest.index = i;\n    }\n  }\n\n  const toFurthest: [Types.Point2, Types.Point2] = [\n    canvasPoints[furthest.index],\n    centerOfFirstToLast,\n  ];\n  const toFurthestWorld = toFurthest.map(viewport.canvasToWorld);\n\n  return toFurthestWorld;\n}\n\nexport function findOpenUShapedContourVectorToPeakOnRender(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation\n): Types.Point3[] {\n  const { viewport } = enabledElement;\n  const canvasPoints = annotation.data.contour.polyline.map(\n    viewport.worldToCanvas\n  );\n\n  return findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n}\n","import { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../../cursors/elementCursor';\nimport { Events } from '../../../enums';\nimport { EventTypes } from '../../../types';\nimport { state } from '../../../store';\nimport { vec3 } from 'gl-matrix';\nimport {\n  shouldSmooth,\n  getInterpolatedPoints,\n} from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport getMouseModifierKey from '../../../eventDispatchers/shared/getMouseModifier';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerContourAnnotationCompleted } from '../../../stateManagement/annotation/helpers/state';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { polyline } from '../../../utilities/math';\nimport { removeAnnotation } from '../../../stateManagement/annotation/annotationState';\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\n\nconst {\n  addCanvasPointsToArray,\n  pointsAreWithinCloseContourProximity,\n  getFirstLineSegmentIntersectionIndexes,\n  getSubPixelSpacingAndXYDirections,\n} = polyline;\n\n/**\n * Activates the contour drawing event loop.\n */\nfunction activateDraw(\n  evt: EventTypes.InteractionEventType,\n  annotation: PlanarFreehandROIAnnotation,\n  viewportIdsToRender: string[]\n): void {\n  this.isDrawing = true;\n\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n  const contourHoleProcessingEnabled =\n    getMouseModifierKey(evt.detail.event) ===\n    this.configuration.contourHoleAdditionModifierKey;\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  this.drawData = {\n    canvasPoints: [canvasPos],\n    polylineIndex: 0,\n    contourHoleProcessingEnabled,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n    movingTextBox: false,\n  };\n\n  state.isInteractingWithTool = true;\n\n  element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n  element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n\n  hideElementCursor(element);\n}\n/**\n * Dectivates and cleans up the contour drawing event loop.\n */\nfunction deactivateDraw(element: HTMLDivElement): void {\n  state.isInteractingWithTool = false;\n\n  element.removeEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n  element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n  element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n  element.removeEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n  element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n  element.removeEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n\n  resetElementCursor(element);\n}\n\n/**\n * Adds points to a set of preview canvas points of the contour being created.\n * Checks if crossing of lines means early completion and editing needs to be started.\n */\nfunction mouseDragDrawCallback(evt: EventTypes.InteractionEventType): void {\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const worldPos = currentPoints.world;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n\n  const {\n    annotation,\n    viewportIdsToRender,\n    xDir,\n    yDir,\n    spacing,\n    movingTextBox,\n  } = this.commonData;\n  const { polylineIndex, canvasPoints } = this.drawData;\n\n  const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n  const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  // Check that we have moved at least one voxel in each direction.\n  if (xDist <= spacing[0] && yDist <= spacing[1]) {\n    // Haven't changed world point enough, don't render\n    return;\n  }\n\n  if (movingTextBox) {\n    this.isDrawing = false;\n\n    // Drag mode - Move the text boxes world position\n    const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n    const worldPosDelta = deltaPoints.world;\n\n    const { textBox } = annotation.data.handles;\n    const { worldPosition } = textBox;\n\n    worldPosition[0] += worldPosDelta[0];\n    worldPosition[1] += worldPosDelta[1];\n    worldPosition[2] += worldPosDelta[2];\n\n    textBox.hasMoved = true;\n  } else {\n    const crossingIndex = this.findCrossingIndexDuringCreate(evt);\n\n    if (crossingIndex !== undefined) {\n      // If we have crossed our drawing line, create a closed contour and then\n      // start an edit.\n      this.applyCreateOnCross(evt, crossingIndex);\n    } else {\n      const numPointsAdded = addCanvasPointsToArray(\n        element,\n        canvasPoints,\n        canvasPos,\n        this.commonData\n      );\n\n      this.drawData.polylineIndex = polylineIndex + numPointsAdded;\n    }\n  }\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Completes the contour on mouse up. If the `allowOpenContours` configuration\n * option is `true`, checks if we should create an open or closed contour.\n * If the `allowOpenContours` configuration option is `false`, always creates a\n * closed contour.\n */\nfunction mouseUpDrawCallback(evt: EventTypes.InteractionEventType): void {\n  const { allowOpenContours } = this.configuration;\n  const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n  const firstPoint = canvasPoints[0];\n  const lastPoint = canvasPoints[canvasPoints.length - 1];\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  if (\n    allowOpenContours &&\n    !pointsAreWithinCloseContourProximity(\n      firstPoint,\n      lastPoint,\n      this.configuration.closeContourProximity\n    )\n  ) {\n    this.completeDrawOpenContour(element, { contourHoleProcessingEnabled });\n  } else {\n    this.completeDrawClosedContour(element, { contourHoleProcessingEnabled });\n  }\n}\n\n/**\n * Completes the contour being drawn, creating a closed contour annotation. It will return true if contour is completed or false in case contour drawing is halted.\n */\nfunction completeDrawClosedContour(\n  element: HTMLDivElement,\n  options: {\n    contourHoleProcessingEnabled: boolean;\n    minPointsToSave: number;\n  }\n): boolean {\n  this.removeCrossedLinesOnCompleteDraw();\n\n  const { canvasPoints } = this.drawData;\n  const { contourHoleProcessingEnabled, minPointsToSave } = options ?? {};\n\n  if (minPointsToSave && canvasPoints.length < minPointsToSave) {\n    return false;\n  }\n\n  // check and halt if necessary the drawing process, last chance to complete drawing and fire events.\n  if (this.haltDrawing(element, canvasPoints)) {\n    return false;\n  }\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  // Convert annotation to world coordinates\n  addCanvasPointsToArray(\n    element,\n    canvasPoints,\n    canvasPoints[0],\n    this.commonData\n  );\n  // Remove last point which will be a duplicate now.\n  canvasPoints.pop();\n\n  const updatedPoints = shouldSmooth(this.configuration, annotation)\n    ? getInterpolatedPoints(this.configuration, canvasPoints)\n    : canvasPoints;\n\n  this.updateContourPolyline(\n    annotation,\n    {\n      points: updatedPoints,\n      closed: true,\n      targetWindingDirection: ContourWindingDirection.Clockwise,\n    },\n    viewport\n  );\n\n  const { textBox } = annotation.data.handles;\n\n  if (!textBox?.hasMoved) {\n    triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n  }\n\n  this.isDrawing = false;\n  this.drawData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateDraw(element);\n\n  return true;\n}\n\n/**\n * If lines are crossed during the draw loop, remove the points drawn over the\n * crossing.\n */\nfunction removeCrossedLinesOnCompleteDraw(): void {\n  const { canvasPoints } = this.drawData;\n  const numPoints = canvasPoints.length;\n\n  const endToStart = [canvasPoints[0], canvasPoints[numPoints - 1]];\n  const canvasPointsMinusEnds = canvasPoints.slice(0, -1).slice(1);\n\n  const lineSegment = getFirstLineSegmentIntersectionIndexes(\n    canvasPointsMinusEnds,\n    endToStart[0],\n    endToStart[1],\n    false\n  );\n\n  if (lineSegment) {\n    const indexToRemoveUpTo = lineSegment[1];\n\n    // It is better to remove the last point when the user just moved the mouse\n    // cursor back than deleting the entire contour\n    if (indexToRemoveUpTo === 1) {\n      this.drawData.canvasPoints = canvasPoints.splice(1);\n    } else {\n      this.drawData.canvasPoints = canvasPoints.splice(0, indexToRemoveUpTo);\n    }\n  }\n}\n\n/**\n * Completes the contour being drawn, creating an open contour annotation. It will return true if contour is completed or false in case contour drawing is halted.\n */\nfunction completeDrawOpenContour(\n  element: HTMLDivElement,\n  options: {\n    contourHoleProcessingEnabled: boolean;\n  }\n): boolean {\n  const { canvasPoints } = this.drawData;\n  const { contourHoleProcessingEnabled } = options ?? {};\n\n  // check and halt if necessary the drawing process, last chance to complete drawing and fire events.\n  if (this.haltDrawing(element, canvasPoints)) {\n    return false;\n  }\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const updatedPoints = shouldSmooth(this.configuration, annotation)\n    ? getInterpolatedPoints(this.configuration, canvasPoints)\n    : canvasPoints;\n\n  // Note: -> This is pretty expensive and may not scale well with hundreds of\n  // contours. A future optimisation if we use this for segmentation is to re-do\n  // this rendering with the GPU rather than SVG.\n\n  this.updateContourPolyline(\n    annotation,\n    {\n      points: updatedPoints,\n      closed: false,\n    },\n    viewport\n  );\n\n  const { textBox } = annotation.data.handles;\n  const worldPoints = annotation.data.contour.polyline;\n\n  // Add the first and last points to the list of handles. These means they\n  // will render handles on mouse hover.\n  annotation.data.handles.points = [\n    worldPoints[0],\n    worldPoints[worldPoints.length - 1],\n  ];\n\n  // If the annotation is an open U-shaped annotation, find the annotation vector.\n  if (annotation.data.isOpenUShapeContour) {\n    annotation.data.openUShapeContourVectorToPeak =\n      findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n  }\n\n  if (!textBox.hasMoved) {\n    triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n  }\n\n  this.isDrawing = false;\n  this.drawData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateDraw(element);\n\n  return true;\n}\n\n/**\n * Searches for a crossing of the contour during create. If found, returns the\n * index of the point just before the lines cross.\n */\nfunction findCrossingIndexDuringCreate(\n  evt: EventTypes.InteractionEventType\n): number | undefined {\n  // Note as we super sample the added points, we need to check the whole last mouse move, not the points\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n\n  const { canvasPoints } = this.drawData;\n  const pointsLessLastOne = canvasPoints.slice(0, -1);\n\n  const lineSegment = getFirstLineSegmentIntersectionIndexes(\n    pointsLessLastOne,\n    canvasPos,\n    lastCanvasPoint,\n    false\n  );\n\n  if (lineSegment === undefined) {\n    return;\n  }\n\n  const crossingIndex = lineSegment[0];\n\n  return crossingIndex;\n}\n\n/**\n * On crossing of the draw line, create a closed contour, and then start an edit\n * since this occurs during a mouse drag.\n */\nfunction applyCreateOnCross(\n  evt: EventTypes.InteractionEventType,\n  crossingIndex: number\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n  const { annotation, viewportIdsToRender } = this.commonData;\n\n  // Add points between the end point and crossing point\n  addCanvasPointsToArray(\n    element,\n    canvasPoints,\n    canvasPoints[crossingIndex],\n    this.commonData\n  );\n  // Remove last point which will be a duplicate now.\n  canvasPoints.pop();\n\n  const remainingPoints = canvasPoints.slice(crossingIndex);\n  const newArea = polyline.getArea(remainingPoints);\n\n  // User just moved the mouse back and the last points must be removed\n  // otherwise the entire contour drawn would be lost.\n  if (utilities.isEqual(newArea, 0)) {\n    canvasPoints.splice(crossingIndex + 1);\n    return;\n  }\n\n  canvasPoints.splice(0, crossingIndex);\n\n  // There is no contour with less than 3 points.\n  // It's possible to have a contour with very few points after removing\n  // crossed lines which is not enough to save as a contour.\n  const options = { contourHoleProcessingEnabled, minPointsToSave: 3 };\n\n  if (this.completeDrawClosedContour(element, options)) {\n    // pos complete operation\n    this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n  }\n}\n\n/**\n * Completes the contour on a cancel method call during the draw loop.\n */\nfunction cancelDrawing(element: HTMLElement) {\n  const { allowOpenContours } = this.configuration;\n  const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n  const firstPoint = canvasPoints[0];\n  const lastPoint = canvasPoints[canvasPoints.length - 1];\n\n  if (\n    allowOpenContours &&\n    !pointsAreWithinCloseContourProximity(\n      firstPoint,\n      lastPoint,\n      this.configuration.closeContourProximity\n    )\n  ) {\n    this.completeDrawOpenContour(element, { contourHoleProcessingEnabled });\n  } else {\n    this.completeDrawClosedContour(element, { contourHoleProcessingEnabled });\n  }\n}\n\n/**\n * Tell whether a drawing should be halted or not. It will be true when canvas points is less than the minimum required.\n */\nfunction shouldHaltDrawing(\n  canvasPoints: any,\n  subPixelResolution: number\n): boolean {\n  const minPoints = Math.max(\n    /**\n     * The number of points to span 3 voxels in length, this is a realistically\n     * smallest open contour one could reasonably define (2 voxels should probably be a line).\n     */\n    subPixelResolution * 3,\n    /**\n     * Minimum 3 points, there are other annotations for one point (probe)\n     * or 2 points (line), so this comes only from a mistake in practice.\n     */\n    3\n  );\n  return canvasPoints.length < minPoints;\n}\n\n/**\n * Check and halt a drawing for a given event. It returns true in case drawing is halted, otherswise false.\n */\nfunction haltDrawing(element: HTMLDivElement, canvasPoints: any): boolean {\n  const { subPixelResolution } = this.configuration;\n\n  if (shouldHaltDrawing(canvasPoints, subPixelResolution)) {\n    // Remove annotation instead of completing it.\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    removeAnnotation(annotation.annotationUID);\n\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.deactivateDraw(element);\n\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Registers the contour drawing loop to the tool instance.\n */\nfunction registerDrawLoop(toolInstance): void {\n  toolInstance.activateDraw = activateDraw.bind(toolInstance);\n  toolInstance.deactivateDraw = deactivateDraw.bind(toolInstance);\n\n  toolInstance.applyCreateOnCross = applyCreateOnCross.bind(toolInstance);\n  toolInstance.findCrossingIndexDuringCreate =\n    findCrossingIndexDuringCreate.bind(toolInstance);\n  toolInstance.completeDrawOpenContour =\n    completeDrawOpenContour.bind(toolInstance);\n  toolInstance.removeCrossedLinesOnCompleteDraw =\n    removeCrossedLinesOnCompleteDraw.bind(toolInstance);\n  toolInstance.mouseDragDrawCallback = mouseDragDrawCallback.bind(toolInstance);\n  toolInstance.mouseUpDrawCallback = mouseUpDrawCallback.bind(toolInstance);\n  toolInstance.completeDrawClosedContour =\n    completeDrawClosedContour.bind(toolInstance);\n  toolInstance.cancelDrawing = cancelDrawing.bind(toolInstance);\n  toolInstance.haltDrawing = haltDrawing.bind(toolInstance);\n}\n\nexport default registerDrawLoop;\n","import { Types } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\nimport { polyline } from '../../../utilities/math';\nimport { EventTypes } from '../../../types';\n\nconst { addCanvasPointsToArray, getFirstLineSegmentIntersectionIndexes } =\n  polyline;\n\n/**\n * Check if the `editCanvasPoints` have crossed the `prevCanvasPoints` during\n * an edit.\n *\n * @privateRemarks The following tricks are required to make the UX smooth and\n * the editing not very picky on exactly where you click:\n * - If we don't cross after 2 points, but projecting the line backwards the\n * proximity distance means we cross, extend the line back.\n * - If we travel the full proximity in canvas points but don't cross a line, we\n * are likely drawing along the line, which is intuitive to the user. At this point\n * snap the start of the edit to the closest place on the `prevCanvasPoints`,\n * so that the edit can be executed in-line.\n */\nfunction checkForFirstCrossing(\n  evt: EventTypes.InteractionEventType,\n  isClosedContour: boolean\n): void {\n  const eventDetail = evt.detail;\n  const { element, currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n  const { editCanvasPoints, prevCanvasPoints } = this.editData;\n\n  const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(\n    prevCanvasPoints,\n    canvasPos,\n    lastCanvasPoint,\n    isClosedContour\n  );\n\n  if (crossedLineSegment) {\n    this.editData.startCrossingIndex = crossedLineSegment[0];\n\n    // On the first crossing, remove the first lines prior to the crossing\n    this.removePointsUpUntilFirstCrossing(isClosedContour);\n    // prevent continue if there are not the minimum of points for this op.\n  } else if (prevCanvasPoints.length >= 2) {\n    if (\n      editCanvasPoints.length >\n      this.configuration.checkCanvasEditFallbackProximity\n    ) {\n      // At this point, likely we are drawing along the line, we are past the proximity for grabbing.\n      // Search for nearest line segment to the start of the edit.\n      // Set the crossing index to the lower index of the segment.\n\n      const firstEditCanvasPoint = editCanvasPoints[0];\n\n      const distanceIndexPairs = [];\n\n      for (let i = 0; i < prevCanvasPoints.length; i++) {\n        const prevCanvasPoint = prevCanvasPoints[i];\n        const distance = vec2.distance(prevCanvasPoint, firstEditCanvasPoint);\n\n        distanceIndexPairs.push({ distance, index: i });\n      }\n\n      distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n\n      const twoClosestDistanceIndexPairs = [\n        distanceIndexPairs[0],\n        distanceIndexPairs[1],\n      ];\n\n      const lowestIndex = Math.min(\n        twoClosestDistanceIndexPairs[0].index,\n        twoClosestDistanceIndexPairs[1].index\n      );\n\n      this.editData.startCrossingIndex = lowestIndex;\n    } else {\n      // Check if extending a line back 6 (Proximity) canvas pixels would cross a line.\n\n      // Extend point back 6 canvas pixels from first point.\n      const dir = vec2.create();\n\n      vec2.subtract(dir, editCanvasPoints[1], editCanvasPoints[0]);\n      vec2.normalize(dir, dir);\n\n      const proximity = 6;\n\n      const extendedPoint: Types.Point2 = [\n        editCanvasPoints[0][0] - dir[0] * proximity,\n        editCanvasPoints[0][1] - dir[1] * proximity,\n      ];\n\n      const crossedLineSegmentFromExtendedPoint =\n        getFirstLineSegmentIntersectionIndexes(\n          prevCanvasPoints,\n          extendedPoint,\n          editCanvasPoints[0],\n          isClosedContour\n        );\n\n      if (crossedLineSegmentFromExtendedPoint) {\n        // Add points.\n        const pointsToPrepend = [extendedPoint];\n\n        addCanvasPointsToArray(\n          element,\n          pointsToPrepend,\n          editCanvasPoints[0],\n          this.commonData\n        );\n\n        editCanvasPoints.unshift(...pointsToPrepend);\n\n        this.removePointsUpUntilFirstCrossing(isClosedContour);\n\n        this.editData.editIndex = editCanvasPoints.length - 1;\n        this.editData.startCrossingIndex =\n          crossedLineSegmentFromExtendedPoint[0];\n      }\n    }\n  }\n}\n\n/**\n * Removes the points from the `editCanvasPoints` up until the first crossing of\n * the `prevCanvasPoints`. This is so we can just insert this line segment\n * into the contour.\n */\nfunction removePointsUpUntilFirstCrossing(isClosedContour: boolean): void {\n  const { editCanvasPoints, prevCanvasPoints } = this.editData;\n  let numPointsToRemove = 0;\n\n  for (let i = 0; i < editCanvasPoints.length - 1; i++) {\n    const firstLine = [editCanvasPoints[i], editCanvasPoints[i + 1]];\n\n    const didCrossLine = !!getFirstLineSegmentIntersectionIndexes(\n      prevCanvasPoints,\n      firstLine[0],\n      firstLine[1],\n      isClosedContour\n    );\n\n    // Remove last element\n    numPointsToRemove++;\n\n    if (didCrossLine) {\n      break;\n    }\n  }\n\n  // Remove the points\n  editCanvasPoints.splice(0, numPointsToRemove);\n\n  this.editData.editIndex = editCanvasPoints.length - 1;\n}\n\n/**\n * Returns `true` if the `editCanvasPoints` crosses the `prevCanvasPoints` a\n * second time.\n */\nfunction checkForSecondCrossing(\n  evt: EventTypes.InteractionEventType,\n  isClosedContour: boolean\n): boolean {\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n  const { prevCanvasPoints } = this.editData;\n\n  // Note this method is looking for the first corssing found of\n  // *the lines given* to it. The parameters given to it are specified to search\n  // for the second crossing of the prevCanvasPoints, by checking if the last\n  // mouse drag crossed these. This class method is only called if the edit loop\n  // has already has a crossing earlier in the edit.\n  const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(\n    prevCanvasPoints,\n    canvasPos,\n    lastCanvasPoint,\n    isClosedContour\n  );\n\n  if (!crossedLineSegment) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Removes the points from the `editCanvasPoints` after the second crossing of\n * the `prevCanvasPoints`. This is so we can just insert this line segment\n * into the contour.\n */\nfunction removePointsAfterSecondCrossing(isClosedContour: boolean): void {\n  const { prevCanvasPoints, editCanvasPoints } = this.editData;\n\n  // Remove points after the crossing\n  for (let i = editCanvasPoints.length - 1; i > 0; i--) {\n    const lastLine = [editCanvasPoints[i], editCanvasPoints[i - 1]];\n\n    const didCrossLine = !!getFirstLineSegmentIntersectionIndexes(\n      prevCanvasPoints,\n      lastLine[0],\n      lastLine[1],\n      isClosedContour\n    );\n\n    // Remove last element\n    editCanvasPoints.pop();\n\n    if (didCrossLine) {\n      break;\n    }\n  }\n}\n\n/**\n * During an edit, finds the index on the `prevCanvasPoints` that the\n * `editCanvasPoints` should snap to to create one continuous contour.\n *\n * Returns the index, but returns -1 if there is no index on the\n * `prevCanvasPoints` that can be snapped to with causing a crossing of the\n * `editCanvasPoints`.\n */\nfunction findSnapIndex(): number {\n  const { editCanvasPoints, prevCanvasPoints, startCrossingIndex } =\n    this.editData;\n\n  if (\n    startCrossingIndex === undefined // Haven't crossed line yet\n  ) {\n    return;\n  }\n\n  const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n\n  const distanceIndexPairs = [];\n\n  for (let i = 0; i < prevCanvasPoints.length; i++) {\n    const prevCanvasPoint = prevCanvasPoints[i];\n    const distance = vec2.distance(prevCanvasPoint, lastEditCanvasPoint);\n\n    distanceIndexPairs.push({ distance, index: i });\n  }\n\n  distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n\n  // Search through from shortest distance and check which snap line doesn't\n  // Cross the edit line, in most cases the snap index will just be the first one.\n  const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -1);\n\n  for (let i = 0; i < distanceIndexPairs.length; i++) {\n    const { index } = distanceIndexPairs[i];\n    const snapCanvasPosition = prevCanvasPoints[index];\n    const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n\n    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(\n      editCanvasPointsLessLastOne,\n      snapCanvasPosition,\n      lastEditCanvasPoint,\n      false // The edit line is not a closed contour\n    );\n\n    if (!crossedLineSegment) {\n      return index;\n    }\n  }\n\n  // If all of the lines caused a crossing, this means we should start a new edit.\n  // Use -1 to signify this.\n  return -1;\n}\n\n/**\n * Checks if the `editCanvasPoints` cross themselves. If they do, remove the\n * region after the cross index, these removes isolated \"island\" loops that the\n * user can draw which make closed contours no longer simple polygons, or open\n * contours twisted.\n */\nfunction checkAndRemoveCrossesOnEditLine(\n  evt: EventTypes.InteractionEventType\n): number | undefined {\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n\n  const { editCanvasPoints } = this.editData;\n\n  const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -2);\n\n  const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(\n    editCanvasPointsLessLastOne,\n    canvasPos,\n    lastCanvasPoint,\n    false\n  );\n\n  if (!crossedLineSegment) {\n    return;\n  }\n\n  // We have found a crossing, remove points after the crossing, cutting off\n  // the \"island\" loop drawn.\n\n  const editIndexCrossed = crossedLineSegment[0];\n  const numPointsToRemove = editCanvasPoints.length - editIndexCrossed;\n\n  for (let i = 0; i < numPointsToRemove; i++) {\n    editCanvasPoints.pop();\n  }\n}\n\n/**\n * Registers the contour drawing loop to the tool instance.\n */\nfunction registerEditLoopCommon(toolInstance) {\n  toolInstance.checkForFirstCrossing = checkForFirstCrossing.bind(toolInstance);\n  toolInstance.removePointsUpUntilFirstCrossing =\n    removePointsUpUntilFirstCrossing.bind(toolInstance);\n  toolInstance.checkForSecondCrossing =\n    checkForSecondCrossing.bind(toolInstance);\n  toolInstance.findSnapIndex = findSnapIndex.bind(toolInstance);\n  toolInstance.removePointsAfterSecondCrossing =\n    removePointsAfterSecondCrossing.bind(toolInstance);\n  toolInstance.checkAndRemoveCrossesOnEditLine =\n    checkAndRemoveCrossesOnEditLine.bind(toolInstance);\n}\n\nexport default registerEditLoopCommon;\n","import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../../cursors/elementCursor';\nimport type { EventTypes } from '../../../types';\nimport { polyline } from '../../../utilities/math';\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\nimport type { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport {\n  getInterpolatedPoints,\n  shouldSmooth,\n} from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport updateContourPolyline from '../../../utilities/contours/updateContourPolyline';\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\n\nconst { getSubPixelSpacingAndXYDirections, addCanvasPointsToArray, getArea } =\n  polyline;\n\n/**\n * Activates the closed contour edit event loop.\n */\nfunction activateClosedContourEdit(\n  evt: EventTypes.InteractionEventType,\n  annotation: PlanarFreehandROIAnnotation,\n  viewportIdsToRender: string[]\n): void {\n  this.isEditingClosed = true;\n\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  if (!enabledElement) {\n    // Occurs on shutdown\n    return;\n  }\n  const { viewport } = enabledElement;\n\n  const prevCanvasPoints = annotation.data.contour.polyline.map(\n    viewport.worldToCanvas\n  );\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  this.editData = {\n    prevCanvasPoints,\n    editCanvasPoints: [canvasPos],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n    movingTextBox: false,\n  };\n\n  state.isInteractingWithTool = true;\n\n  element.addEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  element.addEventListener(\n    Events.TOUCH_END,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  hideElementCursor(element);\n}\n\n/**\n * Dectivates and cleans up the closed contour edit event loop.\n */\nfunction deactivateClosedContourEdit(element: HTMLDivElement): void {\n  state.isInteractingWithTool = false;\n\n  element.removeEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  element.removeEventListener(\n    Events.TOUCH_END,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  resetElementCursor(element);\n}\n\n/**\n * Adds points to the edit line and calculates the preview of the edit to render.\n * Checks if an edit needs to be completed by crossing of lines, or by editing in\n * a way that requires a new edit to keep the contour a simple polygon.\n */\nfunction mouseDragClosedContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): Types.Point2[] {\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const worldPos = currentPoints.world;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n\n  const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n  const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n\n  const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n  const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  // Check that we have moved at least one voxel in each direction.\n  if (xDist <= spacing[0] && yDist <= spacing[1]) {\n    // Haven't changed world point enough, don't render\n    return;\n  }\n\n  if (startCrossingIndex !== undefined) {\n    // Edge case: If the edit line itself crosses, remove part of that edit line so we don't\n    // Get isolated regions.\n    this.checkAndRemoveCrossesOnEditLine(evt);\n  }\n\n  const numPointsAdded = addCanvasPointsToArray(\n    element,\n    editCanvasPoints,\n    canvasPos,\n    this.commonData\n  );\n\n  const currentEditIndex = editIndex + numPointsAdded;\n\n  this.editData.editIndex = currentEditIndex;\n\n  if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n    // If we haven't found the index of the first crossing yet,\n    // see if we can find it.\n    this.checkForFirstCrossing(evt, true);\n  }\n\n  this.editData.snapIndex = this.findSnapIndex();\n\n  if (this.editData.snapIndex === -1) {\n    // No point on the prevCanvasPoints for the editCanvasPoints line to\n    // snap to. Apply edit, and start a new edit as we've gone back on ourselves.\n    this.finishEditAndStartNewEdit(evt);\n    return;\n  }\n\n  this.editData.fusedCanvasPoints = this.fuseEditPointsWithClosedContour(evt);\n\n  if (\n    startCrossingIndex !== undefined &&\n    this.checkForSecondCrossing(evt, true)\n  ) {\n    // Crossed a second time, apply edit, and start a new edit from the crossing.\n    this.removePointsAfterSecondCrossing(true);\n    this.finishEditAndStartNewEdit(evt);\n  }\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Finish the current edit, and start a new one.\n */\nfunction finishEditAndStartNewEdit(evt: EventTypes.InteractionEventType): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n\n  updateContourPolyline(\n    annotation,\n    {\n      points: fusedCanvasPoints,\n      closed: true,\n      targetWindingDirection: ContourWindingDirection.Clockwise,\n    },\n    viewport\n  );\n\n  // If any manual update, triggered on an annotation, then it will be treated as non-autogenerated.\n  if (annotation.autoGenerated) {\n    annotation.autoGenerated = false;\n  }\n\n  triggerAnnotationModified(annotation, element);\n\n  const lastEditCanvasPoint = editCanvasPoints.pop();\n\n  this.editData = {\n    prevCanvasPoints: fusedCanvasPoints,\n    editCanvasPoints: [lastEditCanvasPoint],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n    snapIndex: undefined,\n  };\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * This method combines the contour before editing (prevCanvasPoints) with\n * the current edit (editCanvasPoints), to produce a renderable preview of the\n * edit. Upon finishing the contour, the preview generated here is written back\n * into the contour state.\n *\n * @privateRemarks In this method we combine a few tricks to find the optimal\n * contour:\n * - As the contour is closed, our edit might stradle the boundary between the\n * last and 0th point of the contour, e.g. a small edit might go from e.g. index\n * 960 to index 4. We therefore calculate two possible contours, and find the\n * one with the biggest area, which will define the actual edit the user desired.\n * - As the contour and the edit can be drawn with different chiralities, we find if\n * the edit line aligns better with the intended cross points in its current order\n * or reversed. We do this by minimising the distance between its ends and the\n * intended crossing points.\n */\nfunction fuseEditPointsWithClosedContour(\n  evt: EventTypes.InteractionEventType\n): Types.Point2[] {\n  const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } =\n    this.editData;\n\n  if (startCrossingIndex === undefined || snapIndex === undefined) {\n    return;\n  }\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Augment the editCanvasPoints array, between the end of edit and the snap index.\n  const augmentedEditCanvasPoints = [...editCanvasPoints];\n\n  addCanvasPointsToArray(\n    element,\n    augmentedEditCanvasPoints,\n    prevCanvasPoints[snapIndex],\n    this.commonData\n  );\n\n  if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n    // If any points added, remove the last point, which will be a clone of the snapIndex\n    augmentedEditCanvasPoints.pop();\n  }\n\n  // Calculate the distances between the first and last edit points and the origin of the\n  // Contour with the snap point. These will be used to see which way around the edit array should be\n  // Placed within the preview.\n  let lowIndex;\n  let highIndex;\n\n  if (startCrossingIndex > snapIndex) {\n    lowIndex = snapIndex;\n    highIndex = startCrossingIndex;\n  } else {\n    lowIndex = startCrossingIndex;\n    highIndex = snapIndex;\n  }\n\n  const distanceBetweenLowAndFirstPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenLowAndLastPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  const distanceBetweenHighAndFirstPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenHighAndLastPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  // Generate two possible contours that could be intepreted from the edit:\n  //\n  // pointSet1 => 0 -> low -> edit -> high - max.\n  // pointSet2 => low -> high -> edit\n  //\n  // Depending on the placement of the edit and the origin, either of these could be the intended edit.\n  // We'll choose the one with the largest area, as edits are considered to be changes to the original area with\n  // A relative change of much less than unity.\n\n  // Point Set 1\n  const pointSet1 = [];\n\n  // Add points from the orignal contour origin up to the low index.\n  for (let i = 0; i < lowIndex; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  // Check which orientation of the edit line minimizes the distance between the\n  // origial contour low/high points and the start/end nodes of the edit line.\n\n  let inPlaceDistance =\n    distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n\n  let reverseDistance =\n    distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n\n  if (inPlaceDistance < reverseDistance) {\n    for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  // Add points from the orignal contour's high index up to to its end point.\n  for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  // Point Set 2\n  const pointSet2 = [];\n\n  for (let i = lowIndex; i < highIndex; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  inPlaceDistance =\n    distanceBetweenHighAndFirstPoint + distanceBetweenLowAndLastPoint;\n\n  reverseDistance =\n    distanceBetweenHighAndLastPoint + distanceBetweenLowAndFirstPoint;\n\n  if (inPlaceDistance < reverseDistance) {\n    for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  const areaPointSet1 = getArea(pointSet1);\n  const areaPointSet2 = getArea(pointSet2);\n\n  const pointsToRender: Types.Point2[] =\n    areaPointSet1 > areaPointSet2 ? pointSet1 : pointSet2;\n\n  return pointsToRender;\n}\n\n/**\n * Completes the edit of the closed contour when the mouse button is released.\n */\nfunction mouseUpClosedContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  this.completeClosedContourEdit(element);\n}\n\n/**\n * Completes the edit of the closed contour when the mouse button is released.\n */\nfunction completeClosedContourEdit(element: HTMLDivElement) {\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints) {\n    const updatedPoints = shouldSmooth(this.configuration, annotation)\n      ? getInterpolatedPoints(\n          this.configuration,\n          fusedCanvasPoints,\n          prevCanvasPoints\n        )\n      : fusedCanvasPoints;\n\n    updateContourPolyline(\n      annotation,\n      {\n        points: updatedPoints,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n      },\n      viewport\n    );\n\n    // If any manual update, triggered on an annotation, then it will be treated as non-autogenerated.\n    if (annotation.autoGenerated) {\n      annotation.autoGenerated = false;\n    }\n\n    triggerAnnotationModified(annotation, element);\n  }\n\n  this.isEditingClosed = false;\n  this.editData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateClosedContourEdit(element);\n}\n\n/**\n * Completes the edit on a cancel method call during the closed\n * contour edit loop.\n */\nfunction cancelClosedContourEdit(element: HTMLDivElement) {\n  this.completeClosedContourEdit(element);\n}\n\n/**\n * Registers the closed contour edit loop to the tool instance.\n */\nfunction registerClosedContourEditLoop(toolInstance): void {\n  toolInstance.activateClosedContourEdit =\n    activateClosedContourEdit.bind(toolInstance);\n  toolInstance.deactivateClosedContourEdit =\n    deactivateClosedContourEdit.bind(toolInstance);\n  toolInstance.mouseDragClosedContourEditCallback =\n    mouseDragClosedContourEditCallback.bind(toolInstance);\n  toolInstance.mouseUpClosedContourEditCallback =\n    mouseUpClosedContourEditCallback.bind(toolInstance);\n  toolInstance.finishEditAndStartNewEdit =\n    finishEditAndStartNewEdit.bind(toolInstance);\n  toolInstance.fuseEditPointsWithClosedContour =\n    fuseEditPointsWithClosedContour.bind(toolInstance);\n  toolInstance.cancelClosedContourEdit =\n    cancelClosedContourEdit.bind(toolInstance);\n  toolInstance.completeClosedContourEdit =\n    completeClosedContourEdit.bind(toolInstance);\n}\n\nexport default registerClosedContourEditLoop;\n","import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../../cursors/elementCursor';\nimport type { EventTypes } from '../../../types';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport { polyline } from '../../../utilities/math';\nimport {\n  shouldSmooth,\n  getInterpolatedPoints,\n} from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport { updateContourPolyline } from '../../../utilities/contours';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\n\nconst { addCanvasPointsToArray, getSubPixelSpacingAndXYDirections } = polyline;\n\n/**\n * Activates the open contour edit event loop.\n */\nfunction activateOpenContourEdit(\n  evt: EventTypes.InteractionEventType,\n  annotation: PlanarFreehandROIAnnotation,\n  viewportIdsToRender: string[]\n): void {\n  this.isEditingOpen = true;\n\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const prevCanvasPoints = annotation.data.contour.polyline.map(\n    viewport.worldToCanvas\n  );\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  this.editData = {\n    prevCanvasPoints,\n    editCanvasPoints: [canvasPos],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n    movingTextBox: false,\n  };\n\n  state.isInteractingWithTool = true;\n\n  element.addEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpOpenContourEditCallback\n  );\n\n  element.addEventListener(\n    Events.TOUCH_END,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpOpenContourEditCallback\n  );\n  hideElementCursor(element);\n}\n\n/**\n * Deactivates and cleans up the closed contour edit event loop.\n */\nfunction deactivateOpenContourEdit(element: HTMLDivElement) {\n  state.isInteractingWithTool = false;\n\n  element.removeEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpOpenContourEditCallback\n  );\n\n  element.removeEventListener(\n    Events.TOUCH_END,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpOpenContourEditCallback\n  );\n  resetElementCursor(element);\n}\n\n/**\n * Adds points to the edit line and calculates the preview of the edit to render.\n * Checks if an edit needs to be completed by crossing of lines, or by dragging\n * the edit line past the end of the open contour.\n */\nfunction mouseDragOpenContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): boolean {\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const worldPos = currentPoints.world;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n\n  const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n  const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n\n  const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n  const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  // Get pixel spacing in the direction.\n  // Check that we have moved at least one voxel in each direction.\n\n  if (xDist <= spacing[0] && yDist <= spacing[1]) {\n    // Haven't changed world point enough, don't render\n    return;\n  }\n\n  if (startCrossingIndex !== undefined) {\n    // Edge case: If the edit line itself crosses, remove part of that edit line so we don't\n    // Get isolated regions.\n    this.checkAndRemoveCrossesOnEditLine(evt);\n  }\n\n  const numPointsAdded = addCanvasPointsToArray(\n    element,\n    editCanvasPoints,\n    canvasPos,\n    this.commonData\n  );\n\n  const currentEditIndex = editIndex + numPointsAdded;\n\n  this.editData.editIndex = currentEditIndex;\n\n  if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n    this.checkForFirstCrossing(evt, false);\n  }\n\n  this.editData.snapIndex = this.findSnapIndex();\n\n  this.editData.fusedCanvasPoints = this.fuseEditPointsWithOpenContour(evt);\n\n  if (\n    startCrossingIndex !== undefined &&\n    this.checkForSecondCrossing(evt, false)\n  ) {\n    this.removePointsAfterSecondCrossing(false);\n    this.finishEditOpenOnSecondCrossing(evt);\n  } else if (this.checkIfShouldOverwriteAnEnd(evt)) {\n    this.openContourEditOverwriteEnd(evt);\n  }\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Overwrite the end of the contour with the edit, and then switch to the\n * open contour end edit loop.\n */\nfunction openContourEditOverwriteEnd(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const fusedCanvasPoints = this.fuseEditPointsForOpenContourEndEdit();\n\n  updateContourPolyline(\n    annotation,\n    {\n      points: fusedCanvasPoints,\n      closed: false,\n    },\n    viewport\n  );\n\n  const worldPoints = annotation.data.contour.polyline;\n\n  // Note: Contours generate from fusedCanvasPoints will be in the direction\n  // with the last point being the current mouse position\n  annotation.data.handles.points = [\n    worldPoints[0],\n    worldPoints[worldPoints.length - 1],\n  ];\n  annotation.data.handles.activeHandleIndex = 1;\n\n  triggerAnnotationModified(annotation, element);\n\n  this.isEditingOpen = false;\n  this.editData = undefined;\n  this.commonData = undefined;\n\n  // Jump to a normal line edit now.\n  this.deactivateOpenContourEdit(element);\n  this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, null);\n}\n\n/**\n * Checks if we are moving the `editCanvasPoints` past the end of one of the\n * open contour's `prevCanvasPoint`s.\n */\nfunction checkIfShouldOverwriteAnEnd(\n  evt: EventTypes.InteractionEventType\n): boolean {\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPos = lastPoints.canvas;\n\n  const { snapIndex, prevCanvasPoints, startCrossingIndex } = this.editData;\n\n  if (startCrossingIndex === undefined || snapIndex === undefined) {\n    // Edit not started\n    return false;\n  }\n\n  // No snap index can be found, so contour is being edited away from line.\n  if (snapIndex === -1) {\n    return true;\n  }\n\n  if (snapIndex !== 0 && snapIndex !== prevCanvasPoints.length - 1) {\n    // Not snapping to final index\n    return false;\n  }\n\n  // Work out the angle between the last mouse move and\n  // And the current point to the snapped point.\n  const p1 = canvasPos;\n  const p2 = lastCanvasPos;\n  const p3 = prevCanvasPoints[snapIndex];\n\n  const a = vec2.create();\n  const b = vec2.create();\n\n  vec2.set(a, p1[0] - p2[0], p1[1] - p2[1]);\n  vec2.set(b, p1[0] - p3[0], p1[1] - p3[1]);\n\n  const aDotb = vec2.dot(a, b);\n  const magA = Math.sqrt(a[0] * a[0] + a[1] * a[1]);\n  const magB = Math.sqrt(b[0] * b[0] + b[1] * b[1]);\n\n  const theta = Math.acos(aDotb / (magA * magB));\n\n  if (theta < Math.PI / 2) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * This method combines the contour before editing (prevCanvasPoints) with\n * the current edit (editCanvasPoints), to produce a single contour ready for\n * end editing.\n *\n * @privateRemarks In this method we use the following trick to find the\n * optimal contour:\n * - As the contour and the edit can be drawn with different chiralities, we find if\n * the edit line aligns better with the intended cross points in its current order\n * or reversed. We do this by minimising the distance between its ends and the\n * intended crossing points.\n */\nfunction fuseEditPointsForOpenContourEndEdit(): Types.Point2[] {\n  const { snapIndex, prevCanvasPoints, editCanvasPoints, startCrossingIndex } =\n    this.editData;\n\n  const newCanvasPoints = [];\n\n  // Note: Generated contours will both be in the direction with the\n  // last point being the current mouse position\n\n  if (snapIndex === 0) {\n    // end -> crossingpoint -> edit\n    // Add points from the end of the previous contour, to the crossing point.\n    for (let i = prevCanvasPoints.length - 1; i >= startCrossingIndex; i--) {\n      const canvasPoint = prevCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    // start -> crossingpoint -> edit\n    // Add points from the orignal contour origin up to the low index.\n    for (let i = 0; i < startCrossingIndex; i++) {\n      const canvasPoint = prevCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  const distanceBetweenCrossingIndexAndFirstPoint = vec2.distance(\n    prevCanvasPoints[startCrossingIndex],\n    editCanvasPoints[0]\n  );\n\n  const distanceBetweenCrossingIndexAndLastPoint = vec2.distance(\n    prevCanvasPoints[startCrossingIndex],\n    editCanvasPoints[editCanvasPoints.length - 1]\n  );\n\n  if (\n    distanceBetweenCrossingIndexAndFirstPoint <\n    distanceBetweenCrossingIndexAndLastPoint\n  ) {\n    // In order\n    for (let i = 0; i < editCanvasPoints.length; i++) {\n      const canvasPoint = editCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    // reverse\n    for (let i = editCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = editCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  return newCanvasPoints;\n}\n\n/**\n * This method combines the contour before editing (prevCanvasPoints) with\n * the current edit (editCanvasPoints), to produce a renderable preview of the\n * edit. Upon finishing the contour, the preview generated here is written back\n * into the contour state.\n *\n * @privateRemarks In this method we use the following trick to find the\n * optimal contour:\n * - As the contour and the edit can be drawn with different chiralities, we find if\n * the edit line aligns better with the intended cross points in its current order\n * or reversed. We do this by minimising the distance between its ends and the\n * intended crossing points.\n */\nfunction fuseEditPointsWithOpenContour(\n  evt: EventTypes.InteractionEventType\n): Types.Point2[] {\n  const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } =\n    this.editData;\n\n  if (startCrossingIndex === undefined || snapIndex === undefined) {\n    return undefined;\n  }\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Augment the editCanvasPoints array, between the end of edit and the snap index.\n  const augmentedEditCanvasPoints = [...editCanvasPoints];\n\n  addCanvasPointsToArray(\n    element,\n    augmentedEditCanvasPoints,\n    prevCanvasPoints[snapIndex],\n    this.commonData\n  );\n\n  if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n    // If any points added, remove the last point, which will be a clone of the snapIndex\n    augmentedEditCanvasPoints.pop();\n  }\n\n  // Calculate the distances between the first and last edit points and the origin of the\n  // Contour with the snap point. These will be used to see which way around the edit array should be\n  // Placed within the preview.\n\n  let lowIndex;\n  let highIndex;\n\n  if (startCrossingIndex > snapIndex) {\n    lowIndex = snapIndex;\n    highIndex = startCrossingIndex;\n  } else {\n    lowIndex = startCrossingIndex;\n    highIndex = snapIndex;\n  }\n\n  const distanceBetweenLowAndFirstPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenLowAndLastPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  const distanceBetweenHighAndFirstPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenHighAndLastPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  const pointsToRender = [];\n\n  // Add points from the orignal contour origin up to the low index.\n  for (let i = 0; i < lowIndex; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  // Check which orientation of the edit line minimizes the distance between the\n  // origial contour low/high points and the start/end nodes of the edit line.\n\n  const inPlaceDistance =\n    distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n\n  const reverseDistance =\n    distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n\n  if (inPlaceDistance < reverseDistance) {\n    for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  // Add points from the original contour's high index up to to its end point.\n  for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  return pointsToRender;\n}\n\n/**\n * On a second crossing, apply edit, and start a new edit from the crossing.\n */\nfunction finishEditOpenOnSecondCrossing(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n\n  updateContourPolyline(\n    annotation,\n    {\n      points: fusedCanvasPoints,\n      closed: false,\n    },\n    viewport\n  );\n\n  const worldPoints = annotation.data.contour.polyline;\n\n  annotation.data.handles.points = [\n    worldPoints[0],\n    worldPoints[worldPoints.length - 1],\n  ];\n\n  triggerAnnotationModified(annotation, element);\n\n  const lastEditCanvasPoint = editCanvasPoints.pop();\n\n  this.editData = {\n    prevCanvasPoints: fusedCanvasPoints,\n    editCanvasPoints: [lastEditCanvasPoint],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n  };\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Completes the edit of the open contour when the mouse button is released.\n */\nfunction mouseUpOpenContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  this.completeOpenContourEdit(element);\n}\n\n/**\n * Completes the edit of the open contour.\n */\nfunction completeOpenContourEdit(element: HTMLDivElement) {\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints) {\n    const updatedPoints = shouldSmooth(this.configuration)\n      ? getInterpolatedPoints(\n          this.configuration,\n          fusedCanvasPoints,\n          prevCanvasPoints\n        )\n      : fusedCanvasPoints;\n\n    updateContourPolyline(\n      annotation,\n      {\n        points: updatedPoints,\n        closed: false,\n      },\n      viewport\n    );\n\n    const worldPoints = annotation.data.contour.polyline;\n\n    annotation.data.handles.points = [\n      worldPoints[0],\n      worldPoints[worldPoints.length - 1],\n    ];\n\n    // If the annotation is an open U-shaped annotation, find the annotation vector.\n    if (annotation.data.isOpenUShapeContour) {\n      annotation.data.openUShapeContourVectorToPeak =\n        findOpenUShapedContourVectorToPeak(fusedCanvasPoints, viewport);\n    }\n\n    triggerAnnotationModified(annotation, element);\n  }\n\n  this.isEditingOpen = false;\n  this.editData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateOpenContourEdit(element);\n}\n\n/**\n * Completes the edit on a cancel method call during the open\n * contour edit loop.\n */\nfunction cancelOpenContourEdit(element: HTMLDivElement) {\n  this.completeOpenContourEdit(element);\n}\n\n/**\n * Registers the open contour edit loop to the tool instance.\n */\nfunction registerOpenContourEditLoop(toolInstance) {\n  toolInstance.activateOpenContourEdit =\n    activateOpenContourEdit.bind(toolInstance);\n  toolInstance.deactivateOpenContourEdit =\n    deactivateOpenContourEdit.bind(toolInstance);\n  toolInstance.mouseDragOpenContourEditCallback =\n    mouseDragOpenContourEditCallback.bind(toolInstance);\n  toolInstance.mouseUpOpenContourEditCallback =\n    mouseUpOpenContourEditCallback.bind(toolInstance);\n  toolInstance.fuseEditPointsWithOpenContour =\n    fuseEditPointsWithOpenContour.bind(toolInstance);\n  toolInstance.finishEditOpenOnSecondCrossing =\n    finishEditOpenOnSecondCrossing.bind(toolInstance);\n  toolInstance.checkIfShouldOverwriteAnEnd =\n    checkIfShouldOverwriteAnEnd.bind(toolInstance);\n  toolInstance.fuseEditPointsForOpenContourEndEdit =\n    fuseEditPointsForOpenContourEndEdit.bind(toolInstance);\n  toolInstance.openContourEditOverwriteEnd =\n    openContourEditOverwriteEnd.bind(toolInstance);\n  toolInstance.cancelOpenContourEdit = cancelOpenContourEdit.bind(toolInstance);\n  toolInstance.completeOpenContourEdit =\n    completeOpenContourEdit.bind(toolInstance);\n}\n\nexport default registerOpenContourEditLoop;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport { hideElementCursor } from '../../../cursors/elementCursor';\nimport type {\n  EventTypes,\n  Annotation,\n  ToolHandle,\n  TextBoxHandle,\n} from '../../../types';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport { polyline } from '../../../utilities/math';\n\nconst { getSubPixelSpacingAndXYDirections } = polyline;\n\n/**\n * Activates the open contour end edit. This actually just sets up the state so\n * that the tool thinks we are mid draw, and then jumps into the drawing loop.\n */\nfunction activateOpenContourEndEdit(\n  evt: EventTypes.InteractionEventType,\n  annotation: PlanarFreehandROIAnnotation,\n  viewportIdsToRender: string[],\n  handle: ToolHandle | null\n): void {\n  this.isDrawing = true;\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  const canvasPoints = annotation.data.contour.polyline.map(\n    viewport.worldToCanvas\n  );\n  const handleIndexGrabbed = annotation.data.handles.activeHandleIndex;\n\n  // If 0, invert point direction, if 1, keep point direction the same.\n  // This is so we can just jump as into the state as if the annotation was just being drawn.\n  if (handleIndexGrabbed === 0) {\n    canvasPoints.reverse();\n  }\n\n  let movingTextBox = false;\n  if ((handle as TextBoxHandle)?.worldPosition) {\n    movingTextBox = true;\n  }\n\n  this.drawData = {\n    canvasPoints: canvasPoints,\n    polylineIndex: canvasPoints.length - 1,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n    movingTextBox,\n  };\n\n  state.isInteractingWithTool = true;\n\n  // Jump into drawing loop.\n  element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n  element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n\n  hideElementCursor(element);\n}\n\n/**\n * Registers the open contour end edit loop to the tool instance.\n */\nfunction registerOpenContourEndEditLoop(toolInstance): void {\n  toolInstance.activateOpenContourEndEdit =\n    activateOpenContourEndEdit.bind(toolInstance);\n}\n\nexport default registerOpenContourEndEditLoop;\n","import type { Types } from '@cornerstonejs/core';\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\n/**\n * Draws an SVG path with the given points.\n *\n * The `closePath` option, if true, draws a closed path (last point\n * connected to the first).\n */\nexport default function drawPath(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  pathUID: string,\n  points: Types.Point2[] | Types.Point2[][],\n  options: {\n    color?: string;\n    fillColor?: string;\n    fillOpacity?: number;\n    width?: number;\n    lineWidth?: number;\n    lineDash?: string;\n    closePath?: boolean;\n  }\n): void {\n  // It may be a polyline with holes that will be an array with multiple\n  // 'points' arrays\n  const hasSubArrays =\n    points.length && points[0].length && Array.isArray(points[0][0]);\n\n  const pointsArrays = hasSubArrays ? points : [points];\n  const {\n    color = 'rgb(0, 255, 0)',\n    width = 10,\n    fillColor = 'none',\n    fillOpacity = 0,\n    lineWidth,\n    lineDash,\n    closePath = false,\n  } = options;\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'path', pathUID);\n  const existingNode = svgDrawingHelper.getSvgNode(svgNodeHash);\n  let pointsAttribute = '';\n\n  for (let i = 0, numArrays = pointsArrays.length; i < numArrays; i++) {\n    const points = pointsArrays[i];\n    const numPoints = points.length;\n\n    if (numPoints < 2) {\n      continue;\n    }\n\n    for (let j = 0; j < numPoints; j++) {\n      const point = points[j];\n      const cmd = j ? 'L' : 'M';\n\n      pointsAttribute += `${cmd} ${point[0].toFixed(1)}, ${point[1].toFixed(\n        1\n      )} `;\n    }\n\n    if (closePath) {\n      pointsAttribute += 'Z ';\n    }\n  }\n\n  if (!pointsAttribute) {\n    return;\n  }\n\n  const attributes = {\n    d: pointsAttribute,\n    stroke: color,\n    fill: fillColor,\n    'fill-opacity': fillOpacity,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingNode) {\n    // This is run to avoid re-rendering annotations that actually haven't changed\n    setAttributesIfNecessary(attributes, existingNode);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newNode = document.createElementNS(svgns, 'path');\n\n    setNewAttributesIfValid(attributes, newNode);\n    svgDrawingHelper.appendNode(newNode, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\n/**\n * Draws an SVG polyline with the given points.\n *\n * The `closePath` option, if true, draws a closed polyline, with the\n * last point connected to the first.\n */\nexport default function drawPolyline(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  polylineUID: string,\n  points: Types.Point2[],\n  options: {\n    color?: string;\n    fillColor?: string;\n    fillOpacity?: number;\n    width?: number;\n    lineWidth?: number;\n    lineDash?: string;\n    closePath?: boolean;\n  }\n): void {\n  if (points.length < 2) {\n    return;\n  }\n\n  const {\n    color = 'rgb(0, 255, 0)',\n    width = 10,\n    fillColor = 'none',\n    fillOpacity = 0,\n    lineWidth,\n    lineDash,\n    closePath = false,\n  } = options;\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'polyline', polylineUID);\n  const existingPolyLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  let pointsAttribute = '';\n\n  for (const point of points) {\n    pointsAttribute += `${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;\n  }\n\n  if (closePath) {\n    const firstPoint = points[0];\n\n    pointsAttribute += `${firstPoint[0]}, ${firstPoint[1]}`;\n  }\n\n  const attributes = {\n    points: pointsAttribute,\n    stroke: color,\n    fill: fillColor,\n    'fill-opacity': fillOpacity,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingPolyLine) {\n    // This is run to avoid re-rendering annotations that actually haven't changed\n    setAttributesIfNecessary(attributes, existingPolyLine);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newPolyLine = document.createElementNS(svgns, 'polyline');\n\n    setNewAttributesIfValid(attributes, newPolyLine);\n\n    svgDrawingHelper.appendNode(newPolyLine, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawPolyline as drawPolylineSvg,\n  drawPath as drawPathSvg,\n} from '../../../drawingSvg';\nimport { polyline } from '../../../utilities/math';\nimport { findOpenUShapedContourVectorToPeakOnRender } from './findOpenUShapedContourVectorToPeak';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../../types/AnnotationStyle';\nimport { SVGDrawingHelper } from '../../../types';\nimport { getContourHolesDataCanvas } from '../../../utilities/contours';\n\nconst { pointsAreWithinCloseContourProximity } = polyline;\n\ntype PlanarFreehandROIRenderOptions = {\n  color?: string;\n  width?: number;\n  connectFirstToLast?: boolean;\n};\n\nfunction _getRenderingOptions(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation\n): PlanarFreehandROIRenderOptions {\n  const styleSpecifier: StyleSpecifier = {\n    toolGroupId: this.toolGroupId,\n    toolName: this.getToolName(),\n    viewportId: enabledElement.viewport.id,\n    annotationUID: annotation.annotationUID,\n  };\n\n  const { lineWidth, lineDash, color, fillColor, fillOpacity } =\n    this.getAnnotationStyle({\n      annotation,\n      styleSpecifier,\n    });\n\n  const { closed: isClosedContour } = annotation.data.contour;\n\n  const options = {\n    color,\n    width: lineWidth,\n    lineDash,\n    fillColor,\n    fillOpacity,\n    closePath: isClosedContour,\n  };\n\n  return options;\n}\n\n/**\n * Renders a `PlanarFreehandROIAnnotation` that is not currently being drawn or edited.\n */\nfunction renderContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  // prevent drawing or further calculation in case viewport data is not ready yet\n  if (!enabledElement?.viewport?.getImageData()) {\n    return;\n  }\n  // Check if the contour is an open contour\n  if (annotation.data.contour.closed) {\n    this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n  } else {\n    // If its an open contour, check i its a U-shaped contour\n    if (annotation.data.isOpenUShapeContour) {\n      calculateUShapeContourVectorToPeakIfNotPresent(\n        enabledElement,\n        annotation\n      );\n\n      this.renderOpenUShapedContour(\n        enabledElement,\n        svgDrawingHelper,\n        annotation\n      );\n    } else {\n      // If not a U-shaped contour, render standard open contour.\n      this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n    }\n  }\n}\n\n/**\n * If the open U-shaped contour does not have a peak.\n */\nfunction calculateUShapeContourVectorToPeakIfNotPresent(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  if (!annotation.data.openUShapeContourVectorToPeak) {\n    // Annotation just been set to be an open U-shaped contour.\n    // calculate its peak vector here.\n    annotation.data.openUShapeContourVectorToPeak =\n      findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation);\n  }\n}\n\n/**\n * Renders an closed `PlanarFreehandROIAnnotation` annotation.\n */\nfunction renderClosedContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  if (annotation.parentAnnotationUID) {\n    return;\n  }\n\n  const { viewport } = enabledElement;\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  // Its unfortunate that we have to do this for each annotation,\n  // Even if its unchanged. In the future we could cache the canvas points per\n  // element on the tool? That feels very weird also as we'd need to manage\n  // it/clean them up. Its a pre-optimisation for now and we can tackle it if it\n  // becomes a problem.\n  const canvasPolyline = annotation.data.contour.polyline.map((worldPos) =>\n    viewport.worldToCanvas(worldPos)\n  );\n\n  const childContours = getContourHolesDataCanvas(annotation, viewport);\n  const allContours = [canvasPolyline, ...childContours];\n  const polylineUID = '1';\n\n  drawPathSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUID,\n    allContours,\n    options\n  );\n}\n\n/**\n * Renders an open `PlanarFreehandROIAnnotation` annotation.\n */\nfunction renderOpenContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const { viewport } = enabledElement;\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  const canvasPoints = annotation.data.contour.polyline.map((worldPos) =>\n    viewport.worldToCanvas(worldPos)\n  );\n\n  const polylineUID = '1';\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUID,\n    canvasPoints,\n    options\n  );\n\n  const activeHandleIndex = annotation.data.handles.activeHandleIndex;\n\n  if (this.configuration.alwaysRenderOpenContourHandles?.enabled === true) {\n    const radius = this.configuration.alwaysRenderOpenContourHandles.radius;\n\n    // Draw highlighted points\n    const handleGroupUID = '0';\n\n    // We already mapped all the points, so don't do the mapping again.\n    // The activeHandleIndex can only be one of two points.\n    const handlePoints = [\n      canvasPoints[0],\n      canvasPoints[canvasPoints.length - 1],\n    ];\n\n    // Don't render a hovered handle, as this will be rendered larger in\n    // the next block.\n    if (activeHandleIndex === 0) {\n      handlePoints.shift();\n    } else if (activeHandleIndex === 1) {\n      handlePoints.pop();\n    }\n\n    drawHandlesSvg(\n      svgDrawingHelper,\n      annotation.annotationUID,\n      handleGroupUID,\n      handlePoints,\n      {\n        color: options.color,\n        handleRadius: radius,\n      }\n    );\n  }\n\n  if (activeHandleIndex !== null) {\n    // Draw highlighted points\n    const handleGroupUID = '1';\n\n    // We already mapped all the points, so don't do the mapping again.\n    // The activeHandleIndex can only be one of two points.\n    const indexOfCanvasPoints =\n      activeHandleIndex === 0 ? 0 : canvasPoints.length - 1;\n\n    const handlePoint = canvasPoints[indexOfCanvasPoints];\n\n    drawHandlesSvg(\n      svgDrawingHelper,\n      annotation.annotationUID,\n      handleGroupUID,\n      [handlePoint],\n      { color: options.color }\n    );\n  }\n}\n\nfunction renderOpenUShapedContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const { viewport } = enabledElement;\n  const { openUShapeContourVectorToPeak } = annotation.data;\n  const { polyline } = annotation.data.contour;\n\n  this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n\n  // prevent rendering u shape in case openUShapeContourVectorToPeak is not set yet\n  if (!openUShapeContourVectorToPeak) {\n    return;\n  }\n\n  const firstCanvasPoint = viewport.worldToCanvas(polyline[0]);\n  const lastCanvasPoint = viewport.worldToCanvas(polyline[polyline.length - 1]);\n\n  const openUShapeContourVectorToPeakCanvas = [\n    viewport.worldToCanvas(openUShapeContourVectorToPeak[0]),\n    viewport.worldToCanvas(openUShapeContourVectorToPeak[1]),\n  ];\n\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  // Join first and last points\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    'first-to-last',\n    [firstCanvasPoint, lastCanvasPoint],\n    {\n      color: options.color,\n      width: options.width,\n      closePath: false,\n      lineDash: '2,2',\n    }\n  );\n\n  // Render midpoint to open contour surface line\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    'midpoint-to-open-contour',\n    [\n      openUShapeContourVectorToPeakCanvas[0],\n      openUShapeContourVectorToPeakCanvas[1],\n    ],\n    {\n      color: options.color,\n      width: options.width,\n      closePath: false,\n      lineDash: '2,2',\n    }\n  );\n}\n\n/**\n * Renders a new `PlanarFreehandROIAnnotation` annotation during\n * creation/drawing.\n */\nfunction renderContourBeingDrawn(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  const { allowOpenContours } = this.configuration;\n  const { canvasPoints } = this.drawData;\n\n  // Override rendering whilst drawing the contour, we don't know if its open\n  // or closed yet\n  options.closePath = false;\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    '1',\n    canvasPoints,\n    options\n  );\n\n  if (allowOpenContours) {\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n\n    // Check if start and end are within close proximity\n    if (\n      pointsAreWithinCloseContourProximity(\n        firstPoint,\n        lastPoint,\n        this.configuration.closeContourProximity\n      )\n    ) {\n      // Preview join last points\n      drawPolylineSvg(\n        svgDrawingHelper,\n        annotation.annotationUID,\n        '2',\n        [lastPoint, firstPoint],\n        options\n      );\n    } else {\n      // Draw start point\n      const handleGroupUID = '0';\n\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotation.annotationUID,\n        handleGroupUID,\n        [firstPoint],\n        { color: options.color, handleRadius: 2 }\n      );\n    }\n  }\n}\n\n/**\n * Renders a closed `PlanarFreehandROIAnnotation` being edited.\n */\nfunction renderClosedContourBeingEdited(\n  enabledElement,\n  svgDrawingHelper,\n  annotation\n): void {\n  const { viewport } = enabledElement;\n  const { fusedCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints === undefined) {\n    // No edit to render yet, render closed contour.\n    this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n\n    return;\n  }\n\n  // Get the polylines from child annotations (holes)\n  const childContours = getContourHolesDataCanvas(annotation, viewport);\n\n  const allContours = [fusedCanvasPoints, ...childContours];\n  const options = this._getRenderingOptions(enabledElement, annotation);\n  const polylineUIDToRender = 'preview-1';\n\n  // Set `fillOpacity` to zero if it is a child annotation (hole) otherwise\n  // it would \"close\" the hole when editing it\n  if (annotation.parentAnnotationUID && options.fillOpacity) {\n    options.fillOpacity = 0;\n  }\n\n  drawPathSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUIDToRender,\n    allContours,\n    options\n  );\n}\n\n/**\n * Renders an open `PlanarFreehandROIAnnotation` being edited.\n */\nfunction renderOpenContourBeingEdited(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const { fusedCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints === undefined) {\n    // No edit to render yet, render closed contour.\n    this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n\n    return;\n  }\n\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  const polylineUIDToRender = 'preview-1';\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUIDToRender,\n    fusedCanvasPoints,\n    options\n  );\n}\n\n/**\n * Registers the render methods of various contour states to the tool instance.\n */\nfunction registerRenderMethods(toolInstance) {\n  toolInstance.renderContour = renderContour.bind(toolInstance);\n  toolInstance.renderClosedContour = renderClosedContour.bind(toolInstance);\n  toolInstance.renderOpenContour = renderOpenContour.bind(toolInstance);\n  toolInstance.renderOpenUShapedContour =\n    renderOpenUShapedContour.bind(toolInstance);\n\n  toolInstance.renderContourBeingDrawn =\n    renderContourBeingDrawn.bind(toolInstance);\n\n  toolInstance.renderClosedContourBeingEdited =\n    renderClosedContourBeingEdited.bind(toolInstance);\n  toolInstance.renderOpenContourBeingEdited =\n    renderOpenContourBeingEdited.bind(toolInstance);\n  toolInstance._getRenderingOptions = _getRenderingOptions.bind(toolInstance);\n}\n\nexport default registerRenderMethods;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  addAnnotation,\n  getAnnotations,\n  getChildAnnotations,\n} from '../../stateManagement/annotation/annotationState';\nimport type {\n  Annotation,\n  ContourAnnotation,\n  EventTypes,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  AnnotationRenderContext,\n} from '../../types';\nimport { drawPath as drawPathSvg } from '../../drawingSvg';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport AnnotationTool from './AnnotationTool';\nimport { updateContourPolyline } from '../../utilities/contours/';\nimport { getContourHolesDataCanvas } from '../../utilities/contours';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\n\n/**\n * A contour base class responsible for rendering contour instances such as\n * spline, freehand and livewire.\n */\nabstract class ContourBaseTool extends AnnotationTool {\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * it is used to draw the annotation in each request animation frame. It\n   * calculates the updated cached statistics if data is invalidated and cache it.\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  public renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as Annotation;\n\n      styleSpecifier.annotationUID = annotation.annotationUID;\n\n      const annotationStyle = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      if (!annotationStyle.visibility) {\n        continue;\n      }\n\n      const annotationRendered = this.renderAnnotationInstance({\n        enabledElement,\n        targetId,\n        annotation,\n        annotationStyle,\n        svgDrawingHelper,\n      });\n\n      renderStatus ||= annotationRendered;\n      annotation.invalidated = false;\n    }\n\n    return renderStatus;\n  }\n\n  protected createAnnotation(evt: EventTypes.InteractionEventType): Annotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const { world: worldPos } = currentPoints;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp, position: cameraPosition } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const viewReference = viewport.getViewReference({ points: [worldPos] });\n\n    return <ContourAnnotation>{\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        ...viewReference,\n        referencedImageId,\n        viewUp,\n        cameraPosition,\n      },\n      data: {\n        handles: {\n          points: [],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        contour: {\n          polyline: [],\n          closed: false,\n        },\n      },\n      interpolationUID: '',\n      autoGenerated: false,\n    };\n  }\n\n  /**\n   * Add the annotation to the annotation manager.\n   * @param annotation - Contour annotation that is being added\n   * @param element - HTMLDivElement\n   */\n  protected addAnnotation(\n    annotation: Annotation,\n    element: HTMLDivElement\n  ): string {\n    // Just to give a chance for child classes to override it\n    return addAnnotation(annotation, element);\n  }\n\n  /**\n   * Cancel an annotation when drawing.\n   * @param annotation - Contour annotation that is being added\n   * @param element - HTMLDivElement\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected cancelAnnotation(annotation: Annotation): void {\n    // noop method just to give a chance for child classes to override it\n  }\n\n  /**\n   * Move an annotation and all its child annotations in a recursive way.\n   *\n   * That is useful when clicking on a spline contour to completely translate\n   * it to a different place. In that case all holes (child annotations) must\n   * also be translated too.\n   *\n   * @param annotation - Annotation\n   * @param worldPosDelta - Delta in world space\n   */\n  protected moveAnnotation(\n    annotation: Annotation,\n    worldPosDelta: Types.Point3\n  ): void {\n    const { points } = annotation.data.handles;\n\n    for (let i = 0, numPoints = points.length; i < numPoints; i++) {\n      const point = points[i];\n\n      point[0] += worldPosDelta[0];\n      point[1] += worldPosDelta[1];\n      point[2] += worldPosDelta[2];\n    }\n\n    annotation.invalidated = true;\n\n    getChildAnnotations(annotation).forEach((childAnnotation) =>\n      this.moveAnnotation(childAnnotation, worldPosDelta)\n    );\n  }\n\n  protected updateContourPolyline(\n    annotation: ContourAnnotation,\n    polylineData: {\n      points: Types.Point2[];\n      closed?: boolean;\n      targetWindingDirection?: ContourWindingDirection;\n    },\n    transforms: {\n      canvasToWorld: (point: Types.Point2) => Types.Point3;\n    }\n  ) {\n    const decimateConfig = this.configuration?.decimate || {};\n\n    updateContourPolyline(annotation, polylineData, transforms, {\n      decimate: {\n        enabled: !!decimateConfig.enabled,\n        epsilon: decimateConfig.epsilon,\n      },\n    });\n  }\n\n  /**\n   * Get polyline points in world space.\n   * Just to give a chance for child classes to override it.\n   * @param annotation - Contour annotation\n   * @returns Polyline points in world space\n   */\n  protected getPolylinePoints(annotation: ContourAnnotation): Types.Point3[] {\n    // Attention: `contour.polyline` is the new way to store a polyline but it\n    // may be undefined because it was `data.polyline` before (fallback)\n    return annotation.data.contour?.polyline ?? annotation.data.polyline;\n  }\n\n  /**\n   * Render a contour segmentation instance\n   */\n  protected renderAnnotationInstance(\n    renderContext: AnnotationRenderContext\n  ): boolean {\n    const { enabledElement, annotationStyle, svgDrawingHelper } = renderContext;\n    const annotation = renderContext.annotation as ContourAnnotation;\n\n    // Do not render the contour because it must be rendered by the parent annotation\n    if (annotation.parentAnnotationUID) {\n      return;\n    }\n\n    const { annotationUID } = annotation;\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const polylineCanvasPoints = this.getPolylinePoints(annotation).map(\n      (point) => worldToCanvas(point)\n    );\n    const { lineWidth, lineDash, color, fillColor, fillOpacity } =\n      annotationStyle;\n\n    const childContours = getContourHolesDataCanvas(annotation, viewport);\n    const allContours = [polylineCanvasPoints, ...childContours];\n\n    drawPathSvg(\n      svgDrawingHelper,\n      annotationUID,\n      'contourPolyline',\n      allContours,\n      {\n        color,\n        lineDash,\n        lineWidth: Math.max(0.1, lineWidth),\n        fillColor: fillColor,\n        fillOpacity,\n      }\n    );\n\n    return true;\n  }\n}\n\nexport { ContourBaseTool as default, ContourBaseTool };\n","import { utilities } from '@cornerstonejs/core';\nimport type {\n  Annotation,\n  EventTypes,\n  PublicToolProps,\n  ToolProps,\n  AnnotationRenderContext,\n} from '../../types';\nimport {\n  config as segmentationConfig,\n  state as segmentationState,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\nimport type { ContourSegmentationAnnotation } from '../../types/ContourSegmentationAnnotation';\nimport type { SplineContourSegmentationAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport type { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { SegmentationRepresentations } from '../../enums';\nimport ContourBaseTool from './ContourBaseTool';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { InterpolationManager } from '../../utilities/contours/interpolation';\nimport {\n  addContourSegmentationAnnotation,\n  removeContourSegmentationAnnotation,\n} from '../../utilities/contourSegmentation';\nimport { getToolGroupIdsWithSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { triggerAnnotationRenderForToolGroupIds } from '../../utilities';\n\n/**\n * A base contour segmentation class responsible for rendering, registering\n * and unregister contour segmentation annotations.\n */\nabstract class ContourSegmentationBaseTool extends ContourBaseTool {\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    super(toolProps, defaultToolProps);\n    if (this.configuration.interpolation?.enabled) {\n      InterpolationManager.addTool(this.getToolName());\n    }\n  }\n\n  /**\n   * Allow children classes inherit from this one and disable contour segmentation\n   * behavior and children classes shall work like a normal contour instance which\n   * is useful for \"hybrid\" classes such as splineROI/splineSeg, livewire/livewireSeg,\n   * freehandROI/freehandSeg. When this method returns false:\n   *   - contour segmentation data is not added to new annotations\n   *   - annotations are not registered/unregistered as segmentations\n   *   - annotation style shall not contain any segmentation style\n   * @returns True if it is a contour segmentation class or false otherwise\n   */\n  protected isContourSegmentationTool(): boolean {\n    return true;\n  }\n\n  protected createAnnotation(evt: EventTypes.InteractionEventType): Annotation {\n    const { toolGroupId } = this;\n    const contourAnnotation = super.createAnnotation(evt);\n\n    if (!this.isContourSegmentationTool()) {\n      return contourAnnotation;\n    }\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { type: segmentationType } = activeSegmentationRepresentation;\n\n    if (segmentationType !== SegmentationRepresentations.Contour) {\n      throw new Error(`A contour segmentation must be active`);\n    }\n\n    const { segmentationId } = activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n\n    return <ContourSegmentationAnnotation>utilities.deepMerge(\n      contourAnnotation,\n      {\n        data: {\n          segmentation: {\n            segmentationId,\n            segmentIndex,\n          },\n        },\n      }\n    );\n  }\n\n  protected addAnnotation(\n    annotation: Annotation,\n    element: HTMLDivElement\n  ): string {\n    const annotationUID = super.addAnnotation(annotation, element);\n    if (this.isContourSegmentationTool()) {\n      const contourSegAnnotation = annotation as ContourSegmentationAnnotation;\n\n      addContourSegmentationAnnotation(contourSegAnnotation);\n    }\n\n    return annotationUID;\n  }\n\n  /**\n   * Unregister the segmentation when the annotation is canceled\n   * @param annotation - Contour segmentation annotation\n   */\n  protected cancelAnnotation(annotation: Annotation): void {\n    if (this.isContourSegmentationTool()) {\n      removeContourSegmentationAnnotation(\n        annotation as ContourSegmentationAnnotation\n      );\n    }\n\n    super.cancelAnnotation(annotation);\n  }\n\n  /**\n   * Get the annotation style that may or may not be merged with segmentation\n   * style so that it can be used by ROI and contour segmentation annotations\n   * when rendered on a canvas or svg layer.\n   *\n   * Segmentation style shall be a combination of four different configurations\n   * from different levels (global, toolGroup, segmentation and segment) and it\n   * shall not be used when isContourSegmentationTool() is overwritten and changed\n   * by a child class to return `false` when that class should work only as an ROI.\n   */\n  protected getAnnotationStyle(context: {\n    annotation: Annotation;\n    styleSpecifier: StyleSpecifier;\n  }) {\n    const annotationStyle = super.getAnnotationStyle(context);\n\n    if (!this.isContourSegmentationTool()) {\n      return annotationStyle;\n    }\n\n    const contourSegmentationStyle = this._getContourSegmentationStyle(context);\n\n    return utilities.deepMerge(annotationStyle, contourSegmentationStyle);\n  }\n\n  protected renderAnnotationInstance(\n    renderContext: AnnotationRenderContext\n  ): boolean {\n    const { annotation } = renderContext;\n    const { invalidated } = annotation;\n    // Render the annotation before triggering events\n    const renderResult = super.renderAnnotationInstance(renderContext);\n    if (invalidated && this.isContourSegmentationTool()) {\n      const { segmentationId } = (<SplineContourSegmentationAnnotation>(\n        annotation\n      )).data.segmentation;\n      triggerSegmentationDataModified(segmentationId);\n\n      // check which other viewport is rendering the same segmentationId\n      // and trigger the event for them to be able to render the segmentation\n      // annotation as well\n\n      const toolGroupIds = getToolGroupIdsWithSegmentation(segmentationId);\n\n      triggerAnnotationRenderForToolGroupIds(toolGroupIds);\n    }\n\n    return renderResult;\n  }\n\n  /**\n   * Return the annotation style based on global, toolGroup, segmentation\n   * and segment segmentation configurations.\n   */\n  private _getContourSegmentationStyle(context: {\n    annotation: Annotation;\n    styleSpecifier: StyleSpecifier;\n  }): Record<string, any> {\n    const { toolGroupId } = this;\n    const annotation = context.annotation as ContourSegmentationAnnotation;\n    const { segmentationId, segmentIndex } = annotation.data.segmentation;\n    const segmentation = segmentationState.getSegmentation(segmentationId);\n    const segmentationRepresentation =\n      this._getSegmentationRepresentation(segmentationId);\n\n    if (!segmentationRepresentation) {\n      // return defaults if no segmentation representation is found\n      return {};\n    }\n    const { segmentationRepresentationUID } = segmentationRepresentation;\n    const { active } = segmentationRepresentation;\n    const { autoGenerated } = annotation;\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n    const annotationLocked = segmentsLocked.includes(segmentIndex as never);\n\n    // Todo: we should really get styles every time we render, since it is getting\n    // the style for the visibility and that goes through the segment indices\n    // calculation which is expensive. We should cache the styles and only update\n    // them if the segmentation representation modified event is triggered.\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const segmentationVisible =\n      segmentationConfig.visibility.getSegmentationVisibility(\n        toolGroupId,\n        segmentationRepresentationUID\n      );\n\n    const globalConfig = segmentationConfig.getGlobalConfig();\n\n    const toolGroupConfig =\n      segmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n\n    const segmentationRepresentationConfig =\n      segmentationConfig.getSegmentationRepresentationSpecificConfig(\n        toolGroupId,\n        segmentationRepresentationUID\n      );\n\n    const segmentConfig = segmentationConfig.getSegmentSpecificConfig(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const segmentVisible = segmentationConfig.visibility.getSegmentVisibility(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    // Merge the configurations from different levels based on its precedence\n    const mergedConfig = Object.assign(\n      {},\n      globalConfig?.representations?.CONTOUR ?? {},\n      toolGroupConfig?.representations?.CONTOUR ?? {},\n      segmentationRepresentationConfig?.CONTOUR ?? {},\n      segmentConfig?.CONTOUR ?? {}\n    );\n\n    let lineWidth = 1;\n    let lineDash = undefined;\n    let lineOpacity = 1;\n    let fillOpacity = 0;\n\n    if (autoGenerated) {\n      lineWidth = mergedConfig.outlineWidthAutoGenerated ?? lineWidth;\n      lineDash = mergedConfig.outlineDashAutoGenerated ?? lineDash;\n      lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;\n      fillOpacity = mergedConfig.fillAlphaAutoGenerated ?? fillOpacity;\n    } else if (active) {\n      lineWidth = mergedConfig.outlineWidthActive ?? lineWidth;\n      lineDash = mergedConfig.outlineDashActive ?? lineDash;\n      lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;\n      fillOpacity = mergedConfig.fillAlpha ?? fillOpacity;\n    } else {\n      lineWidth = mergedConfig.outlineWidthInactive ?? lineWidth;\n      lineDash = mergedConfig.outlineDashInactive ?? lineDash;\n      lineOpacity = mergedConfig.outlineOpacityInactive ?? lineOpacity;\n      fillOpacity = mergedConfig.fillAlphaInactive ?? fillOpacity;\n    }\n\n    // Change the line thickness when the mouse is over the contour segment\n    if (segmentation.activeSegmentIndex === segmentIndex) {\n      lineWidth += mergedConfig.activeSegmentOutlineWidthDelta;\n    }\n\n    lineWidth = mergedConfig.renderOutline ? lineWidth : 0;\n    fillOpacity = mergedConfig.renderFill ? fillOpacity : 0;\n\n    const color = `rgba(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]}, ${lineOpacity})`;\n    const fillColor = `rgb(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]})`;\n\n    return {\n      color,\n      fillColor,\n      lineWidth,\n      fillOpacity,\n      lineDash,\n      textbox: {\n        color,\n      },\n      visibility: segmentationVisible && segmentVisible,\n      locked: annotationLocked,\n    };\n  }\n\n  private _getSegmentationRepresentation(segmentationId) {\n    const segmentationRepresentations =\n      segmentationState.getSegmentationRepresentations(this.toolGroupId);\n\n    const validSegmentationRepresentations = segmentationRepresentations.filter(\n      (representation) => representation.segmentationId === segmentationId\n    );\n\n    if (!validSegmentationRepresentations) {\n      console.warn(\n        `No segmentation representation found for toolGroupId: ${this.toolGroupId}`\n      );\n      return;\n    }\n\n    if (\n      segmentationState.getSegmentationRepresentations(this.toolGroupId)\n        .length > 1\n    ) {\n      console.warn(\n        'Multiple segmentation representations detected for this tool group. The first one will be used.'\n      );\n    }\n\n    return validSegmentationRepresentations[0];\n  }\n}\n\nexport { ContourSegmentationBaseTool as default, ContourSegmentationBaseTool };\n","import {\n  CONSTANTS,\n  getEnabledElement,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { math, roundNumber } from '../../utilities';\nimport { polyline } from '../../utilities/math';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport registerDrawLoop from './planarFreehandROITool/drawLoop';\nimport registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';\nimport registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';\nimport registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';\nimport registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';\nimport registerRenderMethods from './planarFreehandROITool/renderMethods';\nimport type {\n  EventTypes,\n  ToolHandle,\n  Annotation,\n  Annotations,\n  AnnotationStyle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  AnnotationRenderContext,\n} from '../../types';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { drawLinkedTextBox } from '../../drawingSvg';\nimport { PlanarFreehandROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { PlanarFreehandROICommonData } from '../../utilities/math/polyline/planarFreehandROIInternalTypes';\n\nimport { getLineSegmentIntersectionsCoordinates } from '../../utilities/math/polyline';\nimport pointInShapeCallback from '../../utilities/pointInShapeCallback';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport calculatePerimeter from '../../utilities/contours/calculatePerimeter';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { KeyboardBindings, ChangeTypes } from '../../enums';\n\nconst { pointCanProjectOnLine } = polyline;\nconst { EPSILON } = CONSTANTS;\n\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\n\n/**\n * PlanarFreehandROITool lets you draw annotations that define an arbitrarily drawn region.\n * You can use the PlanarFreehandROITool in all perpendicular views (axial, sagittal, coronal),\n * support for oblique views is possible, but not yet supported, due to the implementation of\n * `getSubPixelSpacingAndXYDirections`.\n *\n * The resulting annotation's data and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * PlanarFreehandROITool annotation can be smoothed on drawing completion. This is a configured based approach.\n * The smoothing process uses b-spline algorithm and consider 4 configurations properties:\n * - smoothing.smoothOnAdd: to tell whether it should be smoothed or not (for editing it is considered the property smoothOnEdit) (default: false)\n * - smoothing.smoothOnEdit: to tell whether it should be smoothed or not when editing (default: false)\n * - smoothing.knotsRatioPercentageOnAdd: percentage of points from Segment that are likely to be considered knots during smoothing (for editing it is considered the property knotsRatioPercentageOnEdit) ( default: 40)\n * - smoothing.knotsRatioPercentageOnEdit: same as knotsRatioPercentageOnAdd but applicable only when editing the tool (default: 40)\n *\n * So, with that said the smoothing might occur when:\n * - drawing is done (i.e mouse is released) and smoothing.smoothOnAdd is true. smoothing algorithm uses knotsRatioPercentageOnAdd\n * - edit drawing is done (i.e mouse is released) and smoothing.smoothOnEdit is true. smoothing algorithm uses knotsRatioPercentageOnEdit and its only applied to changed segment\n * smoothing does not occur when:\n * - smoothing.smoothOnAdd is false and drawing is completed\n * - smoothing.smoothOnEdit is false and edit is completed\n * - drawing still happening (editing or not)\n *\n * The result of smoothing will be removal of some of the outliers\n * Changing tool configuration (see below) you can fine-tune the smoothing process by changing knotsRatioPercentageOnAdd and knotsRatioPercentageOnEdit value, which smaller values produces a more agressive smoothing.\n * A smaller value of knotsRatioPercentageOnAdd/knotsRatioPercentageOnEdit produces a more aggressive smoothing.\n *\n * ```js\n * cornerstoneTools.addTool(PlanarFreehandROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(PlanarFreehandROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(PlanarFreehandROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // set smoothing aggressiveness while adding new annotation (ps: this does not change if smoothing is ON or OFF)\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\n *   smoothing: { knotsRatioPercentageOnAdd: 30 },\n * });\n *\n * // set smoothing to be ON while editing only\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\n *   smoothing: { smoothOnAdd: false, smoothOnEdit: true  },\n * });\n * ```\n *\n *\n * Read more in the Docs section of the website.\n */\n\nclass PlanarFreehandROITool extends ContourSegmentationBaseTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  private commonData?: PlanarFreehandROICommonData;\n  isDrawing = false;\n  isEditingClosed = false;\n  isEditingOpen = false;\n\n  protected activateDraw: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateClosedContourEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateOpenContourEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateOpenContourEndEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[],\n    handle: ToolHandle | null\n  ) => void;\n  private cancelDrawing: (element: HTMLDivElement) => void;\n  private cancelClosedContourEdit: (element: HTMLDivElement) => void;\n  private cancelOpenContourEdit: (element: HTMLDivElement) => void;\n\n  private renderContour: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderContourBeingDrawn: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderClosedContourBeingEdited: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderOpenContourBeingEdited: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        /**\n         * Specify which modifier key is used to add a hole to a contour. The\n         * modifier must be pressed when the first point of a new contour is added.\n         */\n        contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n        alwaysRenderOpenContourHandles: {\n          // When true, always render end points when you have an open contour, rather\n          // than just rendering a line.\n          enabled: false,\n          // When enabled, use this radius to draw the endpoints whilst not hovering.\n          radius: 2,\n        },\n        allowOpenContours: true,\n        // Proximity in canvas coordinates used to join contours.\n        closeContourProximity: 10,\n        // The proximity at which we fallback to the simplest grabbing logic for\n        // determining what index of the contour to start editing.\n        checkCanvasEditFallbackProximity: 6,\n        // For closed contours, make them clockwise\n        // This can be useful if contours are compared between slices, eg for\n        // interpolation, and does not cause problems otherwise so defaulting to true.\n        makeClockWise: true,\n        // The relative distance that points should be dropped along the polyline\n        // in units of the image pixel spacing. A value of 1 means that nodes must\n        // be placed no closed than the image spacing apart. A value of 4 means that 4\n        // nodes should be placed within the space of one image pixel size. A higher\n        // value gives more finesse to the tool/smoother lines, but the value cannot\n        // be infinite as the lines become very computationally expensive to draw.\n        subPixelResolution: 4,\n        /**\n         * Smoothing is used to remove jagged irregularities in the polyline,\n         * as opposed to interpolation, which is used to create new polylines\n         * between existing polylines.\n         */\n        smoothing: {\n          smoothOnAdd: false,\n          smoothOnEdit: false, // used for edit only\n          knotsRatioPercentageOnAdd: 40,\n          knotsRatioPercentageOnEdit: 40,\n        },\n        /**\n         * Interpolation is the creation of new segmentations in between the\n         * existing segmentations/indices.  Note that this does not apply to\n         * ROI values, since those annotations are individual annotations, not\n         * connected in any way to each other, whereas segmentations are intended\n         * to be connected 2d + 1 dimension (time or space or other) volumes.\n         */\n        interpolation: {\n          enabled: false,\n          // Callback to update the annotation or perform other action when the\n          // interpolation is complete.\n          onInterpolationComplete: null,\n        },\n        /**\n         * The polyline may get processed in order to reduce the number of points\n         * for better performance and storage.\n         */\n        decimate: {\n          enabled: false,\n          /** A maximum given distance 'epsilon' to decide if a point should or\n           * shouldn't be added the resulting polyline which will have a lower\n           * number of points for higher `epsilon` values.\n           */\n          epsilon: 0.1,\n        },\n        calculateStats: true,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    // Register event loops and rendering logic, which are stored in different\n    // Files due to their complexity/size.\n    registerDrawLoop(this);\n    registerEditLoopCommon(this);\n    registerClosedContourEditLoop(this);\n    registerOpenContourEditLoop(this);\n    registerOpenContourEndEditLoop(this);\n    registerRenderMethods(this);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current image, creates\n   * a `PlanarFreehandROIAnnotation` and stores it in the annotationManager.\n   *\n   * @param evt - `EventTypes.NormalizedMouseEventType`\n   * @returns The `PlanarFreehandROIAnnotation` object.\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): PlanarFreehandROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const annotation = this.createAnnotation(\n      evt\n    ) as PlanarFreehandROIAnnotation;\n\n    this.addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.activateDraw(evt, annotation, viewportIdsToRender);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * Begins an edit of an open contour, when the mouse has selected a handle\n   * (end) of the open contour.\n   *\n   * @param evt - `EventTypes.MouseDownEventType`\n   * @param annotation - `PlanarFreehandROIAnnotation` annotation.\n   * @param handle - The handle index, 0 for the start and 1 for the end.\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.activateOpenContourEndEdit(\n      evt,\n      annotation,\n      viewportIdsToRender,\n      handle\n    );\n  };\n\n  /**\n   * Edits the open or closed contour when the line is grabbed and dragged.\n   */\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    if (annotation.data.contour.closed) {\n      this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n    } else {\n      this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);\n    }\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Returns if the canvas point is near the line of the given annotation in the\n   * provided element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - The `PlanarFreehandROIAnnotation`.\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: PlanarFreehandROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { polyline: points } = annotation.data.contour;\n\n    // NOTE: It is implemented this way so that we do not double calculate\n    // points when number crunching adjacent line segments.\n    let previousPoint = viewport.worldToCanvas(points[0]);\n\n    for (let i = 1; i < points.length; i++) {\n      const p1 = previousPoint;\n      const p2 = viewport.worldToCanvas(points[i]);\n      const canProject = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);\n\n      if (canProject) {\n        return true;\n      }\n\n      previousPoint = p2;\n    }\n\n    if (!annotation.data.contour.closed) {\n      // Contour is open, don't check last point to first point.\n      return false;\n    }\n\n    // check last point to first point\n    const pStart = viewport.worldToCanvas(points[0]);\n    const pEnd = viewport.worldToCanvas(points[points.length - 1]);\n\n    return pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);\n  };\n\n  public cancel = (element: HTMLDivElement): void => {\n    const isDrawing = this.isDrawing;\n    const isEditingOpen = this.isEditingOpen;\n    const isEditingClosed = this.isEditingClosed;\n\n    if (isDrawing) {\n      this.cancelDrawing(element);\n    } else if (isEditingOpen) {\n      this.cancelOpenContourEdit(element);\n    } else if (isEditingClosed) {\n      this.cancelClosedContourEdit(element);\n    }\n  };\n\n  /**\n   * @override We need to override this method as the tool doesn't always have\n   * `handles`, which means `filterAnnotationsForDisplay` fails inside\n   * `filterAnnotationsWithinSlice`.\n   */\n  public filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations | undefined {\n    if (!annotations || !annotations.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    let annotationsToDisplay;\n\n    if (viewport instanceof VolumeViewport) {\n      const camera = viewport.getCamera();\n\n      const { spacingInNormalDirection } =\n        csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n\n      // Get data with same normal and within the same slice\n      annotationsToDisplay = this.filterAnnotationsWithinSlice(\n        annotations,\n        camera,\n        spacingInNormalDirection\n      );\n    } else {\n      // Use the default `filterAnnotationsForDisplay` utility, as the stack\n      // path doesn't require handles.\n      annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);\n    }\n\n    return annotationsToDisplay;\n  }\n\n  /**\n   * Altered version of the `utilities.planar.filterAnnotationsWithinSlice`,\n   * which uses the polyline position rather than the handle. As the polyline is\n   * always present.\n   */\n  private filterAnnotationsWithinSlice(\n    annotations: Annotations,\n    camera: Types.ICamera,\n    spacingInNormalDirection: number\n  ): Annotations {\n    const { viewPlaneNormal } = camera;\n\n    const annotationsWithParallelNormals = annotations.filter(\n      (td: Annotation) => {\n        const annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n\n        const isParallel =\n          Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n          PARALLEL_THRESHOLD;\n\n        return annotationViewPlaneNormal && isParallel;\n      }\n    ) as PlanarFreehandROIAnnotation[];\n\n    // No in plane annotations.\n    if (!annotationsWithParallelNormals.length) {\n      return [];\n    }\n\n    // Annotation should be within the slice, which means that it should be between\n    // camera's focalPoint +/- spacingInNormalDirection.\n\n    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n    const { focalPoint } = camera;\n\n    const annotationsWithinSlice = [];\n\n    for (const annotation of annotationsWithParallelNormals) {\n      const data = annotation.data;\n      const point = data.contour.polyline[0];\n\n      if (!annotation.isVisible) {\n        continue;\n      }\n\n      // A = point\n      // B = focal point\n      // P = normal\n\n      // B-A dot P  => Distance in the view direction.\n      // this should be less than half the slice distance.\n\n      const dir = vec3.create();\n\n      vec3.sub(dir, focalPoint, point);\n\n      const dot = vec3.dot(dir, viewPlaneNormal);\n\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\n        annotationsWithinSlice.push(annotation);\n      }\n    }\n\n    return annotationsWithinSlice;\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Disable contour segmentation behavior because it shall be activated only\n    // for PlanarFreehandContourSegmentationTool\n    return false;\n  }\n\n  protected createAnnotation(evt: EventTypes.InteractionEventType): Annotation {\n    const worldPos = evt.detail.currentPoints.world;\n    const contourAnnotation = super.createAnnotation(evt);\n\n    const onInterpolationComplete = (annotation) => {\n      // Clear out the handles because they aren't used for straight freeform\n      annotation.data.handles.points.length = 0;\n    };\n\n    const annotation = <PlanarFreehandROIAnnotation>csUtils.deepMerge(\n      contourAnnotation,\n      {\n        data: {\n          contour: {\n            polyline: [<Types.Point3>[...worldPos]],\n          },\n          label: '',\n          cachedStats: {},\n        },\n        onInterpolationComplete,\n      }\n    );\n\n    return annotation;\n  }\n\n  protected getAnnotationStyle(context) {\n    // This method exists only because `super` cannot be called from\n    // _getRenderingOptions() which is in an external file.\n    return super.getAnnotationStyle(context);\n  }\n\n  protected renderAnnotationInstance(\n    renderContext: AnnotationRenderContext\n  ): boolean {\n    const { enabledElement, targetId, svgDrawingHelper } = renderContext;\n    const annotation = renderContext.annotation as PlanarFreehandROIAnnotation;\n\n    let renderStatus = false;\n    const { viewport, renderingEngine } = enabledElement;\n\n    const isDrawing = this.isDrawing;\n    const isEditingOpen = this.isEditingOpen;\n    const isEditingClosed = this.isEditingClosed;\n\n    if (!(isDrawing || isEditingOpen || isEditingClosed)) {\n      // No annotations are currently being modified, so we can just use the\n      // render contour method to render all of them\n      this.renderContour(enabledElement, svgDrawingHelper, annotation);\n    } else {\n      // The active annotation will need special rendering treatment. Render all\n      // other annotations not being interacted with using the standard renderContour\n      // rendering path.\n      const activeAnnotationUID = this.commonData.annotation.annotationUID;\n\n      if (annotation.annotationUID === activeAnnotationUID) {\n        if (isDrawing) {\n          this.renderContourBeingDrawn(\n            enabledElement,\n            svgDrawingHelper,\n            annotation\n          );\n        } else if (isEditingClosed) {\n          this.renderClosedContourBeingEdited(\n            enabledElement,\n            svgDrawingHelper,\n            annotation\n          );\n        } else if (isEditingOpen) {\n          this.renderOpenContourBeingEdited(\n            enabledElement,\n            svgDrawingHelper,\n            annotation\n          );\n        } else {\n          throw new Error(\n            `Unknown ${this.getToolName()} annotation rendering state`\n          );\n        }\n      } else {\n        this.renderContour(enabledElement, svgDrawingHelper, annotation);\n      }\n\n      // Todo: return boolean flag for each rendering route in the planar tool.\n      renderStatus = true;\n    }\n\n    if (!this.configuration.calculateStats) {\n      return;\n    }\n\n    this._calculateStatsIfActive(\n      annotation,\n      targetId,\n      viewport,\n      renderingEngine,\n      enabledElement\n    );\n\n    this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);\n\n    return renderStatus;\n  }\n\n  _calculateStatsIfActive(\n    annotation: PlanarFreehandROIAnnotation,\n    targetId: string,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) {\n    const activeAnnotationUID = this.commonData?.annotation.annotationUID;\n\n    if (\n      annotation.annotationUID === activeAnnotationUID &&\n      !this.commonData?.movingTextBox\n    ) {\n      return;\n    }\n\n    if (!this.commonData?.movingTextBox) {\n      const { data } = annotation;\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      }\n    }\n  }\n\n  private _calculateCachedStats = (\n    annotation,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const { data } = annotation;\n    const { cachedStats } = data;\n    const { polyline: points, closed } = data.contour;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, metadata } = image;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // Using an arbitrary start point (canvasPoint), calculate the\n      // mm spacing for the canvas in the X and Y directions.\n      const canvasPoint = canvasCoordinates[0];\n      const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n      const deltaXPoint = viewport.canvasToWorld([\n        canvasPoint[0] + 1,\n        canvasPoint[1],\n      ]);\n      const deltaYPoint = viewport.canvasToWorld([\n        canvasPoint[0],\n        canvasPoint[1] + 1,\n      ]);\n\n      const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n      const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n\n      const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[0]);\n      worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n      worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n      worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n\n      let iMin = worldPosIndex[0];\n      let iMax = worldPosIndex[0];\n\n      let jMin = worldPosIndex[1];\n      let jMax = worldPosIndex[1];\n\n      let kMin = worldPosIndex[2];\n      let kMax = worldPosIndex[2];\n\n      for (let j = 1; j < points.length; j++) {\n        const worldPosIndex = csUtils.transformWorldToIndex(\n          imageData,\n          points[j]\n        );\n        worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n        worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n        worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n        iMin = Math.min(iMin, worldPosIndex[0]);\n        iMax = Math.max(iMax, worldPosIndex[0]);\n\n        jMin = Math.min(jMin, worldPosIndex[1]);\n        jMax = Math.max(jMax, worldPosIndex[1]);\n\n        kMin = Math.min(kMin, worldPosIndex[2]);\n        kMax = Math.max(kMax, worldPosIndex[2]);\n      }\n\n      const worldPosIndex2 = csUtils.transformWorldToIndex(\n        imageData,\n        points[1]\n      );\n      worldPosIndex2[0] = Math.floor(worldPosIndex2[0]);\n      worldPosIndex2[1] = Math.floor(worldPosIndex2[1]);\n      worldPosIndex2[2] = Math.floor(worldPosIndex2[2]);\n\n      const { scale, areaUnits } = getCalibratedLengthUnitsAndScale(\n        image,\n        () => {\n          const polyline = data.contour.polyline;\n          const numPoints = polyline.length;\n          const projectedPolyline = new Array(numPoints);\n\n          for (let i = 0; i < numPoints; i++) {\n            projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n          }\n\n          const {\n            maxX: canvasMaxX,\n            maxY: canvasMaxY,\n            minX: canvasMinX,\n            minY: canvasMinY,\n          } = math.polyline.getAABB(projectedPolyline);\n\n          const topLeftBBWorld = viewport.canvasToWorld([\n            canvasMinX,\n            canvasMinY,\n          ]);\n\n          const topLeftBBIndex = csUtils.transformWorldToIndex(\n            imageData,\n            topLeftBBWorld\n          );\n\n          const bottomRightBBWorld = viewport.canvasToWorld([\n            canvasMaxX,\n            canvasMaxY,\n          ]);\n\n          const bottomRightBBIndex = csUtils.transformWorldToIndex(\n            imageData,\n            bottomRightBBWorld\n          );\n\n          return [topLeftBBIndex, bottomRightBBIndex];\n        }\n      );\n      let area = polyline.getArea(canvasCoordinates) / scale / scale;\n      // Convert from canvas_pixels ^2 to mm^2\n      area *= deltaInX * deltaInY;\n\n      // Expand bounding box\n      const iDelta = 0.01 * (iMax - iMin);\n      const jDelta = 0.01 * (jMax - jMin);\n      const kDelta = 0.01 * (kMax - kMin);\n\n      iMin = Math.floor(iMin - iDelta);\n      iMax = Math.ceil(iMax + iDelta);\n      jMin = Math.floor(jMin - jDelta);\n      jMax = Math.ceil(jMax + jDelta);\n      kMin = Math.floor(kMin - kDelta);\n      kMax = Math.ceil(kMax + kDelta);\n\n      const boundsIJK = [\n        [iMin, iMax],\n        [jMin, jMax],\n        [kMin, kMax],\n      ] as [Types.Point2, Types.Point2, Types.Point2];\n\n      const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);\n      const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);\n\n      let curRow = 0;\n      let intersections = [];\n      let intersectionCounter = 0;\n      const pointsInShape = pointInShapeCallback(\n        imageData,\n        (pointLPS, pointIJK) => {\n          let result = true;\n          const point = viewport.worldToCanvas(pointLPS);\n          if (point[1] != curRow) {\n            intersectionCounter = 0;\n            curRow = point[1];\n            intersections = getLineSegmentIntersectionsCoordinates(\n              canvasCoordinates,\n              point,\n              [canvasPosEnd[0], point[1]]\n            );\n            intersections.sort(\n              (function (index) {\n                return function (a, b) {\n                  return a[index] === b[index]\n                    ? 0\n                    : a[index] < b[index]\n                    ? -1\n                    : 1;\n                };\n              })(0)\n            );\n          }\n          if (intersections.length && point[0] > intersections[0][0]) {\n            intersections.shift();\n            intersectionCounter++;\n          }\n          if (intersectionCounter % 2 === 0) {\n            result = false;\n          }\n          return result;\n        },\n        this.configuration.statsCalculator.statsCallback,\n        boundsIJK\n      );\n\n      const modalityUnitOptions = {\n        isPreScaled: isViewportPreScaled(viewport, targetId),\n        isSuvScaled: this.isSuvScaled(\n          viewport,\n          targetId,\n          annotation.metadata.referencedImageId\n        ),\n      };\n\n      const modalityUnit = getModalityUnit(\n        metadata.Modality,\n        annotation.metadata.referencedImageId,\n        modalityUnitOptions\n      );\n\n      const stats = this.configuration.statsCalculator.getStatistics();\n\n      cachedStats[targetId] = {\n        Modality: metadata.Modality,\n        area,\n        perimeter: calculatePerimeter(canvasCoordinates, closed),\n        mean: stats.mean?.value,\n        max: stats.max?.value,\n        stdDev: stats.stdDev?.value,\n        statsArray: stats.array,\n        pointsInShape: pointsInShape,\n        areaUnit: areaUnits,\n        modalityUnit,\n      };\n    }\n\n    triggerAnnotationModified(\n      annotation,\n      enabledElement.viewport.element,\n      ChangeTypes.StatsUpdated\n    );\n\n    annotation.invalidated = false;\n\n    return cachedStats;\n  };\n\n  private _renderStats = (\n    annotation,\n    viewport,\n    enabledElement,\n    svgDrawingHelper\n  ) => {\n    const { data } = <PlanarFreehandROIAnnotation>annotation;\n    const targetId = this.getTargetId(viewport);\n\n    const styleSpecifier: AnnotationStyle.StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n    if (!options.visibility) {\n      return;\n    }\n\n    const textLines = this.configuration.getTextLines(data, targetId);\n    if (!textLines || textLines.length === 0) {\n      return;\n    }\n\n    const canvasCoordinates = data.contour.polyline.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n    if (!data.handles.textBox.hasMoved) {\n      const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n      data.handles.textBox.worldPosition =\n        viewport.canvasToWorld(canvasTextBoxCoords);\n    }\n\n    const textBoxPosition = viewport.worldToCanvas(\n      data.handles.textBox.worldPosition\n    );\n\n    const textBoxUID = '1';\n    const boundingBox = drawLinkedTextBox(\n      svgDrawingHelper,\n      annotation.annotationUID ?? '',\n      textBoxUID,\n      textLines,\n      textBoxPosition,\n      canvasCoordinates,\n      {},\n      options\n    );\n\n    const { x: left, y: top, width, height } = boundingBox;\n\n    data.handles.textBox.worldBoundingBox = {\n      topLeft: viewport.canvasToWorld([left, top]),\n      topRight: viewport.canvasToWorld([left + width, top]),\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\n    };\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const {\n    area,\n    mean,\n    stdDev,\n    perimeter,\n    max,\n    isEmptyArea,\n    areaUnit,\n    modalityUnit,\n  } = cachedVolumeStats || {};\n\n  const textLines: string[] = [];\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n    textLines.push(areaLine);\n  }\n\n  if (mean) {\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  }\n\n  if (max) {\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  }\n\n  if (stdDev) {\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n  }\n\n  if (perimeter) {\n    textLines.push(`Perimeter: ${roundNumber(perimeter)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nPlanarFreehandROITool.toolName = 'PlanarFreehandROI';\nexport default PlanarFreehandROITool;\n","import { utilities } from '@cornerstonejs/core';\nimport type { PublicToolProps } from '../../types';\nimport type { AnnotationRenderContext } from '../../types';\nimport { PlanarFreehandContourSegmentationAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport PlanarFreehandROITool from './PlanarFreehandROITool';\n\nclass PlanarFreehandContourSegmentationTool extends PlanarFreehandROITool {\n  static toolName;\n\n  constructor(toolProps: PublicToolProps) {\n    const initialProps = utilities.deepMerge(\n      {\n        configuration: {\n          calculateStats: false,\n          /**\n           * Allow open contours false means to not allow a final/complete\n           * annotation to be done as an open contour.  This does not mean\n           * that the contour won't be open during creation.\n           */\n          allowOpenContours: false,\n        },\n      },\n      toolProps\n    );\n\n    super(initialProps);\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Re-enable contour segmentation behavior disabled by PlanarFreehandROITool\n    return true;\n  }\n\n  protected renderAnnotationInstance(\n    renderContext: AnnotationRenderContext\n  ): boolean {\n    const annotation =\n      renderContext.annotation as PlanarFreehandContourSegmentationAnnotation;\n    const { invalidated } = annotation;\n\n    // Render the annotation before triggering events\n    const renderResult = super.renderAnnotationInstance(renderContext);\n\n    if (invalidated) {\n      const { segmentationId } = annotation.data.segmentation;\n\n      // This event is trigged by ContourSegmentationBaseTool but PlanarFreehandROITool\n      // is the only contour class that does not call `renderAnnotationInstace` from\n      // its base class.\n      triggerSegmentationDataModified(segmentationId);\n    }\n\n    return renderResult;\n  }\n}\n\nPlanarFreehandContourSegmentationTool.toolName =\n  'PlanarFreehandContourSegmentationTool';\n\nexport default PlanarFreehandContourSegmentationTool;\n","import { PlanarFreehandContourSegmentationTool } from '../../../../../tools';\nimport { addAnnotation } from '../../../../annotation/annotationState';\nimport { RawContourData } from '../contourComputationStrategies';\nimport { utilities, type Types } from '@cornerstonejs/core';\n\n/**\n * Creates and adds contour segmentations from a clipped surface.\n *\n * @param rawContourData - The raw contour data.\n * @param viewport - The viewport.\n * @param segmentationId - The segmentation ID.\n */\nexport function createAndAddContourSegmentationsFromClippedSurfaces(\n  rawContourData: RawContourData,\n  viewport: Types.IViewport,\n  segmentationId: string\n) {\n  const annotationUIDsMap = new Map<number, Set<string>>();\n\n  for (const [segmentIndex, contoursData] of rawContourData) {\n    for (const contourData of contoursData) {\n      const { points } = contourData;\n\n      const { lineSegments, linesNumberOfPoints } =\n        _extractLineSegments(contourData);\n\n      // There may be a few lines as the surface might not be closed and could have holes in it.\n      // Currently, we simply render the generated contour as empty fill to indicate\n      // the presence of holes. However, filling the proper area with\n      //  fillAlpha requires further work.\n      for (let i = 0; i < lineSegments.length; i++) {\n        const line = lineSegments[i];\n        const polyline = [];\n\n        for (let j = 0; j < linesNumberOfPoints[i]; j++) {\n          const pointIndex = line[j];\n          polyline.push([\n            points[3 * pointIndex],\n            points[3 * pointIndex + 1],\n            points[3 * pointIndex + 2],\n          ]);\n        }\n\n        if (polyline.length < 3) {\n          continue;\n        }\n\n        const contourSegmentationAnnotation = {\n          annotationUID: utilities.uuidv4(),\n          data: {\n            contour: {\n              closed: true,\n              polyline,\n            },\n            segmentation: {\n              segmentationId,\n              segmentIndex,\n            },\n            handles: {},\n          },\n          handles: {},\n          highlighted: false,\n          autoGenerated: false,\n          invalidated: false,\n          isLocked: false,\n          isVisible: true,\n          metadata: {\n            toolName: PlanarFreehandContourSegmentationTool.toolName,\n            ...viewport.getViewReference(),\n          },\n        };\n\n        addAnnotation(contourSegmentationAnnotation, viewport.element);\n\n        const currentSet = annotationUIDsMap.get(segmentIndex) || new Set();\n        currentSet.add(contourSegmentationAnnotation.annotationUID);\n        annotationUIDsMap.set(segmentIndex, currentSet);\n      }\n    }\n  }\n\n  return annotationUIDsMap;\n}\n\nconst _extractLineSegments = (contourData) => {\n  const { numberOfCells, lines } = contourData;\n\n  const lineSegments = [];\n  const linesNumberOfPoints = [];\n\n  for (let i = 0; i < lines.length; ) {\n    const pointsInLine = lines[i];\n    linesNumberOfPoints.push(pointsInLine);\n    lineSegments.push(lines.slice(i + 1, i + pointsInLine + 1));\n    i += pointsInLine + 1;\n\n    if (lineSegments.length === numberOfCells) {\n      break;\n    }\n  }\n\n  return { lineSegments, linesNumberOfPoints };\n};\n","import { SegmentationRepresentations } from '../../../../enums';\nimport { PolySegConversionOptions } from '../../../../types';\nimport { computeAndAddRepresentation } from '../computeAndAddRepresentation';\nimport { computeContourData } from './contourComputationStrategies';\n/**\n * Computes and adds the contour representation for a given segmentation.\n *\n * @param segmentationId - The ID of the segmentation.\n * @param options - Optional parameters for computing the labelmap representation.\n * @param options.segmentIndices - An array of segment indices to include in the labelmap representation.\n * @param options.segmentationRepresentationUID - The UID of the segmentation representation.\n * @returns A promise that resolves when the labelmap representation is computed and added.\n */\nexport function computeAndAddContourRepresentation(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n) {\n  return computeAndAddRepresentation(\n    segmentationId,\n    SegmentationRepresentations.Contour,\n    () => computeContourData(segmentationId, options),\n    () => undefined\n  );\n}\n","import { cache } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { getUniqueSegmentIndices } from '../../../../utilities/segmentation';\nimport {\n  getSegmentation,\n  setSegmentationRepresentationSpecificConfig,\n} from '../../segmentationState';\nimport { PolySegConversionOptions } from '../../../../types';\nimport { computeSurfaceFromLabelmapSegmentation } from '../Surface/surfaceComputationStrategies';\nimport {\n  SurfaceClipResult,\n  clipAndCacheSurfacesForViewport,\n} from '../../helpers/clipAndCacheSurfacesForViewport';\nimport { extractContourData } from './utils/extractContourData';\nimport { createAndAddContourSegmentationsFromClippedSurfaces } from './utils/createAndAddContourSegmentationsFromClippedSurfaces';\nimport { getToolGroupForViewport } from '../../../../store/ToolGroupManager';\n\n// the map between segment index and the intersection points and lines\nexport type RawContourData = Map<number, SurfaceClipResult[]>;\n\n/**\n * Computes contour data for a given segmentation.\n * @param segmentationId - The ID of the segmentation.\n * @param options - Optional parameters for the computation.\n * @returns An object containing the annotation UIDs map.\n * @throws Error if there is not enough data to convert to contour.\n */\nexport async function computeContourData(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n) {\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : getUniqueSegmentIndices(segmentationId);\n\n  let rawContourData: RawContourData;\n  const segmentation = getSegmentation(segmentationId);\n  const representationData = segmentation.representationData;\n\n  try {\n    if (representationData.SURFACE) {\n      rawContourData = await computeContourFromSurfaceSegmentation(\n        segmentationId,\n        {\n          segmentIndices,\n          ...options,\n        }\n      );\n    } else if (representationData.LABELMAP) {\n      rawContourData = await computeContourFromLabelmapSegmentation(\n        segmentationId,\n        {\n          segmentIndices,\n          ...options,\n        }\n      );\n    }\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n\n  if (!rawContourData) {\n    throw new Error(\n      'Not enough data to convert to contour, currently only support converting volume labelmap to contour if available'\n    );\n  }\n\n  const { viewport, segmentationRepresentationUID } = options;\n\n  // create the new annotations and add them to the segmentation state representation\n  // data for the contour representation\n  const annotationUIDsMap = createAndAddContourSegmentationsFromClippedSurfaces(\n    rawContourData,\n    viewport,\n    segmentationId\n  );\n\n  // make the segmentation configuration fillAlpha 0 since\n  // we don't have proper hole support right now\n  // Todo: add hole support\n  const toolGroupId = getToolGroupForViewport(viewport.id)?.id;\n\n  setSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    {\n      CONTOUR: {\n        fillAlpha: 0,\n      },\n    }\n  );\n\n  return {\n    annotationUIDsMap,\n  };\n}\n\n/**\n * Computes the contour from a labelmap segmentation.\n * @param segmentationId - The ID of the segmentation.\n * @param options - The options for the contour computation.\n * @returns The raw contour data.\n */\nasync function computeContourFromLabelmapSegmentation(\n  segmentationId,\n  options: PolySegConversionOptions = {}\n) {\n  if (!options.viewport) {\n    throw new Error('Viewport is required to compute contour from labelmap');\n  }\n\n  const results = await computeSurfaceFromLabelmapSegmentation(\n    segmentationId,\n    options\n  );\n\n  if (!results?.length) {\n    console.error('Failed to convert labelmap to surface or labelmap is empty');\n    return;\n  }\n\n  const { viewport, segmentationRepresentationUID } = options;\n\n  const pointsAndPolys = results.map((surface) => {\n    return {\n      id: surface.segmentIndex.toString(),\n      points: surface.data.points,\n      polys: surface.data.polys,\n      segmentIndex: surface.segmentIndex,\n    };\n  });\n\n  const polyDataCache = await clipAndCacheSurfacesForViewport(\n    pointsAndPolys,\n    viewport as Types.IVolumeViewport,\n    segmentationRepresentationUID\n  );\n\n  const rawResults = extractContourData(polyDataCache);\n\n  return rawResults;\n}\n\n/**\n * Computes the contour from a surface segmentation.\n * @param segmentationId - The ID of the segmentation.\n * @param options - The options for the contour computation.\n * @returns A promise that resolves to the raw contour data.\n * @throws An error if the viewport is not provided.\n */\nasync function computeContourFromSurfaceSegmentation(\n  segmentationId,\n  options: PolySegConversionOptions = {}\n): Promise<RawContourData> {\n  if (!options.viewport) {\n    throw new Error('Viewport is required to compute contour from surface');\n  }\n  const { viewport, segmentationRepresentationUID } = options;\n\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : getUniqueSegmentIndices(segmentationId);\n\n  const segmentIndexToSurfaceId = new Map() as Map<number, string>;\n  const surfaceIdToSegmentIndex = new Map() as Map<string, number>;\n\n  const segmentation = getSegmentation(segmentationId);\n  const representationData = segmentation.representationData.SURFACE;\n\n  const surfacesInfo = [];\n  representationData.geometryIds.forEach((geometryId, segmentIndex) => {\n    if (segmentIndices.includes(segmentIndex)) {\n      segmentIndexToSurfaceId.set(segmentIndex, geometryId);\n      const surface = cache.getGeometry(geometryId)?.data as Types.ISurface;\n      if (surface) {\n        surfacesInfo.push({\n          id: geometryId,\n          points: surface.getPoints(),\n          polys: surface.getPolys(),\n        });\n      }\n    }\n  });\n\n  segmentIndexToSurfaceId.forEach((surfaceId, segmentIndex) => {\n    surfaceIdToSegmentIndex.set(surfaceId, segmentIndex);\n  });\n\n  const polyDataCache = await clipAndCacheSurfacesForViewport(\n    surfacesInfo,\n    viewport as Types.IVolumeViewport,\n    segmentationRepresentationUID\n  );\n\n  const rawResults = extractContourData(polyDataCache, surfaceIdToSegmentIndex);\n\n  return rawResults;\n}\n\nexport { computeContourFromLabelmapSegmentation };\n","import {\n  getEnabledElementByIds,\n  Types,\n  BaseVolumeViewport,\n} from '@cornerstonejs/core';\n\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../../types/SegmentationStateTypes';\nimport { addOrUpdateVTKContourSets } from './vtkContour/addOrUpdateVTKContourSets';\nimport removeContourFromElement from './removeContourFromElement';\nimport { deleteConfigCache } from './vtkContour/contourConfigCache';\nimport { polySeg } from '../../../stateManagement/segmentation';\n\nlet polySegConversionInProgress = false;\n\n/**\n * It removes a segmentation representation from the tool group's viewports and\n * from the segmentation state\n * @param toolGroupId - The toolGroupId of the toolGroup that the\n * segmentationRepresentation belongs to.\n * @param segmentationRepresentationUID - This is the unique identifier\n * for the segmentation representation.\n * @param renderImmediate - If true, the viewport will be rendered\n * immediately after the segmentation representation is removed.\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  renderImmediate = false\n): void {\n  _removeContourFromToolGroupViewports(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n  SegmentationState.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  deleteConfigCache(segmentationRepresentationUID);\n\n  if (renderImmediate) {\n    const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      enabledElement.viewport.render();\n    });\n  }\n}\n\n/**\n * It renders the contour sets for the given segmentation\n * @param viewport - The viewport object\n * @param representation - ToolGroupSpecificRepresentation\n * @param toolGroupConfig - This is the configuration object for the tool group\n */\nasync function render(\n  viewport: Types.IVolumeViewport,\n  representationConfig: ToolGroupSpecificRepresentation,\n  toolGroupConfig: SegmentationRepresentationConfig\n): Promise<void> {\n  const { segmentationId } = representationConfig;\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    return;\n  }\n\n  let contourData = segmentation.representationData[Representations.Contour];\n\n  if (\n    !contourData &&\n    polySeg.canComputeRequestedRepresentation(\n      representationConfig.segmentationRepresentationUID\n    ) &&\n    !polySegConversionInProgress\n  ) {\n    polySegConversionInProgress = true;\n\n    contourData = await polySeg.computeAndAddContourRepresentation(\n      segmentationId,\n      {\n        segmentationRepresentationUID:\n          representationConfig.segmentationRepresentationUID,\n        viewport,\n      }\n    );\n  }\n\n  // From here to below it is basically the legacy geometryId based\n  // contour rendering via vtkActors that has some bugs for display,\n  // as it sometimes appear and sometimes not, and it is not clear.\n  // We have moved to the new SVG based contours via our annotation tools\n  // check out annotationUIDsMap in the ContourSegmentationData type\n  const { geometryIds } = contourData;\n\n  if (!geometryIds?.length || !(viewport instanceof BaseVolumeViewport)) {\n    return;\n  }\n\n  // add the contour sets to the viewport\n  addOrUpdateVTKContourSets(\n    viewport,\n    geometryIds,\n    representationConfig,\n    toolGroupConfig\n  );\n\n  /**\n   * The following logic could be added if we want to support the use case\n   * where the contour representation data is initiated using annotations\n   * in the state from the get-go , and not when the user draws a contour.\n   */\n  // if (contourData?.points?.length) {\n  //   // contourData = createAnnotationsFromPoints(contourData.points);\n  //   const contourSegmentationAnnotation = {\n  //     annotationUID: csUtils.uuidv4(),\n  //     data: {\n  //       contour: {\n  //         closed: true,\n  //         polyline: contourData.points,\n  //       },\n  //       segmentation: {\n  //         segmentationId,\n  //         segmentIndex: 1, // Todo\n  //         segmentationRepresentationUID:\n  //           representationConfig.segmentationRepresentationUID,\n  //       },\n  //     },\n  //     highlighted: false,\n  //     invalidated: false,\n  //     isLocked: false,\n  //     isVisible: true,\n  //     metadata: {\n  //       toolName: 'PlanarFreehandContourSegmentationTool',\n  //       FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n  //       viewPlaneNormal: viewport.getCamera().viewPlaneNormal,\n  //     },\n  //   };\n\n  //   addAnnotation(contourSegmentationAnnotation, viewport.element);\n  // } else if (\n  //   !contourData &&\n  //   polySeg.canComputeRequestedRepresentation(\n  //     representationConfig.segmentationRepresentationUID\n  //   )\n  // ) {\n  // contourData = await polySeg.computeAndAddContourRepresentation(\n  //   segmentationId,\n  //   {\n  //     segmentationRepresentationUID:\n  //       representationConfig.segmentationRepresentationUID,\n  //     viewport,\n  //   }\n  // );\n  // }\n\n  // if (contourData?.geometryIds?.length) {\n  //   handleVTKContour({\n  //     viewport,\n  //     representationConfig,\n  //     toolGroupConfig,\n  //     geometryIds: contourData.geometryIds,\n  //   });\n  // } else if (contourData.annotationUIDsMap?.size) {\n  //   handleContourAnnotationSegmentation({\n  //     viewport,\n  //     representationConfig,\n  //     toolGroupConfig,\n  //     annotationUIDsMap: contourData.annotationUIDsMap,\n  //   });\n  // }\n}\n\nfunction _removeContourFromToolGroupViewports(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);\n  }\n\n  const { viewportsInfo } = toolGroup;\n\n  for (const viewportInfo of viewportsInfo) {\n    const { viewportId, renderingEngineId } = viewportInfo;\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    removeContourFromElement(\n      enabledElement.viewport.element,\n      segmentationRepresentationUID\n    );\n  }\n}\n\nexport default {\n  render,\n  removeSegmentationRepresentation,\n};\n","import { Types } from '@cornerstonejs/core';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificContourRepresentation,\n} from '../../../../types';\nimport { addContourSetsToElement } from './addContourSetsToElement';\nimport { updateVTKContourSets } from './updateVTKContourSets';\n\nexport function addOrUpdateVTKContourSets(\n  viewport: Types.IVolumeViewport,\n  geometryIds: string[],\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  contourRepresentationConfig: SegmentationRepresentationConfig\n) {\n  const { segmentationRepresentationUID } = contourRepresentation;\n  const actorUID = `CONTOUR_${segmentationRepresentationUID}`;\n  const actor = viewport.getActor(actorUID);\n\n  const addOrUpdateFn = actor ? updateVTKContourSets : addContourSetsToElement;\n  addOrUpdateFn(\n    viewport,\n    geometryIds,\n    contourRepresentation,\n    contourRepresentationConfig,\n    actorUID\n  );\n}\n","import {\n  getEnabledElementByIds,\n  Types,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport { config as segmentationConfig } from '../../stateManagement/segmentation';\nimport { setSegmentationVisibility } from '../../stateManagement/segmentation/config/segmentationVisibility';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport { PublicToolProps, ToolProps } from '../../types';\nimport { BaseTool } from '../base';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../types/SegmentationStateTypes';\nimport { surfaceDisplay } from './Surface';\nimport { contourDisplay } from './Contour';\nimport { labelmapDisplay } from './Labelmap';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { addTool, state } from '../../store';\nimport PlanarFreehandContourSegmentationTool from '../annotation/PlanarFreehandContourSegmentationTool';\n\nconst planarContourToolName = PlanarFreehandContourSegmentationTool.toolName;\n/**\n * In Cornerstone3DTools, displaying of segmentations are handled by the SegmentationDisplayTool.\n * Generally, any Segmentation can be viewed in various representations such as\n * labelmap (3d), contours, surface etc. As of now, Cornerstone3DTools only implements\n * Labelmap representation.\n *\n * SegmentationDisplayTool works at ToolGroup level, and is responsible for displaying the\n * segmentation representation for ALL viewports of a toolGroup, this way we can support complex\n * scenarios for displaying segmentations.\n *\n * Current Limitations:\n * - Only supports rendering of the volumetric segmentations in 3D space. (StackViewport segmentations are not supported yet)\n * - Labelmap representation is the only supported representation for now.\n *\n * Similar to other tools in Cornerstone3DTools, the SegmentationDisplayTool should\n * be added to the CornerstoneTools by calling cornerstoneTools.addTool(SegmentationDisplayTool)\n * and a toolGroup should be created for it using the ToolGroupManager API, finally\n * viewports information such as viewportId and renderingEngineId should be provided\n * to the toolGroup and the SegmentationDisplayTool should be set to be activated.\n *\n *\n */\nclass SegmentationDisplayTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {},\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolEnabled(): void {\n    const toolGroupId = this.toolGroupId;\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // for each segmentationData, make the visibility true\n    toolGroupSegmentationRepresentations.forEach(\n      (segmentationRepresentation) => {\n        setSegmentationVisibility(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          true\n        );\n      }\n    );\n  }\n\n  onSetToolDisabled(): void {\n    const toolGroupId = this.toolGroupId;\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // for each segmentationData, make the visibility false\n    toolGroupSegmentationRepresentations.forEach(\n      (segmentationRepresentation) => {\n        setSegmentationVisibility(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          false\n        );\n      }\n    );\n  }\n\n  /**\n   * It is used to trigger the render for each segmentations in the toolGroup.\n   * Based on the segmentation representation type, it will call the corresponding\n   * render function.\n   *\n   * @param toolGroupId - the toolGroupId\n   */\n  renderSegmentation = (toolGroupId: string): void => {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      return;\n    }\n\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // toolGroup Viewports\n    const toolGroupViewports = toolGroup.viewportsInfo.map(\n      ({ renderingEngineId, viewportId }) => {\n        const enabledElement = getEnabledElementByIds(\n          viewportId,\n          renderingEngineId\n        );\n\n        if (enabledElement) {\n          return enabledElement.viewport;\n        }\n      }\n    );\n\n    // Render each segmentationData, in each viewport in the toolGroup\n    const segmentationRenderList = toolGroupSegmentationRepresentations.map(\n      (representation: ToolGroupSpecificRepresentation) => {\n        const config = this._getMergedRepresentationsConfig(toolGroupId);\n\n        const viewportsRenderList = [];\n\n        const renderers = {\n          [Representations.Labelmap]: labelmapDisplay,\n          [Representations.Contour]: contourDisplay,\n          [Representations.Surface]: surfaceDisplay,\n        };\n\n        if (representation.type === SegmentationRepresentations.Contour) {\n          // if the representation is contour we need to make sure\n          // that the planarFreeHandTool is added to the toolGroup\n          this.addPlanarFreeHandToolIfAbsent(toolGroupId);\n        }\n\n        const display = renderers[representation.type];\n\n        for (const viewport of toolGroupViewports) {\n          const renderedViewport = display.render(\n            viewport as Types.IVolumeViewport,\n            representation,\n            config\n          );\n\n          viewportsRenderList.push(renderedViewport);\n        }\n        return viewportsRenderList;\n      }\n    );\n\n    Promise.allSettled(segmentationRenderList).then(() => {\n      // for all viewports in the toolGroup trigger a re-render\n      toolGroupViewports.forEach((viewport) => {\n        viewport.render();\n      });\n    });\n  };\n\n  addPlanarFreeHandToolIfAbsent(toolGroupId) {\n    // if it is contour we should check if the toolGroup and more importantly\n    // the cornerstoneTools have the planarFreeHandTool added\n    if (!(planarContourToolName in state.tools)) {\n      addTool(PlanarFreehandContourSegmentationTool);\n    }\n\n    const toolGroup = getToolGroup(toolGroupId);\n\n    // check if toolGroup has this tool\n    if (!toolGroup.hasTool(planarContourToolName)) {\n      toolGroup.addTool(planarContourToolName);\n      toolGroup.setToolPassive(planarContourToolName);\n    }\n  }\n\n  /**\n   * Merge the toolGroup specific configuration with the default global configuration\n   * @param toolGroupId\n   * @returns\n   */\n  _getMergedRepresentationsConfig(\n    toolGroupId: string\n  ): SegmentationRepresentationConfig {\n    const toolGroupConfig =\n      segmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n    const globalConfig = segmentationConfig.getGlobalConfig();\n\n    // merge two configurations and override the global config\n    const mergedConfig = csUtils.deepMerge(globalConfig, toolGroupConfig);\n\n    return mergedConfig;\n  }\n}\n\nSegmentationDisplayTool.toolName = 'SegmentationDisplay';\nexport default SegmentationDisplayTool;\n","import {\n  triggerEvent,\n  eventTarget,\n  getRenderingEngine,\n  Enums,\n  Types,\n} from '@cornerstonejs/core';\nimport { Events as csToolsEvents } from '../../enums';\nimport {\n  getToolGroup,\n  getToolGroupForViewport,\n} from '../../store/ToolGroupManager';\n\nimport { SegmentationDisplayTool } from '../../tools';\nimport { SegmentationRenderedEventDetail } from '../../types/EventTypes';\n\n/**\n * SegmentationRenderingEngine is a class that is responsible for rendering\n * segmentations for a toolGroup. It will call SegmentationDisplayTool to render the segmentation\n * based on the segmentation data and their configurations. Note: This is a Singleton class\n * and should not be instantiated directly. To trigger a render for all the\n * segmentations of a tool group you can use.\n *\n * ```\n * triggerSegmentationRender(toolGroupId)\n * ```\n */\nclass SegmentationRenderingEngine {\n  private _needsRender: Set<string> = new Set();\n  private _animationFrameSet = false;\n  private _animationFrameHandle: number | null = null;\n  public hasBeenDestroyed: boolean;\n\n  public removeToolGroup(toolGroupId) {\n    this._needsRender.delete(toolGroupId);\n\n    if (this._needsRender.size === 0) {\n      this._reset();\n    }\n  }\n\n  public renderToolGroupSegmentations(toolGroupId): void {\n    this._setToolGroupSegmentationToBeRenderedNextFrame([toolGroupId]);\n  }\n\n  /**\n   *  _throwIfDestroyed Throws an error if trying to interact with the `RenderingEngine`\n   * instance after its `destroy` method has been called.\n   */\n  private _throwIfDestroyed() {\n    if (this.hasBeenDestroyed) {\n      throw new Error(\n        'this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.'\n      );\n    }\n  }\n\n  private _setToolGroupSegmentationToBeRenderedNextFrame(\n    toolGroupIds: string[]\n  ) {\n    // Add the viewports to the set of flagged viewports\n    toolGroupIds.forEach((toolGroupId) => {\n      this._needsRender.add(toolGroupId);\n    });\n\n    // Render any flagged viewports\n    this._render();\n  }\n\n  /**\n   *  _render Sets up animation frame if necessary\n   */\n  private _render() {\n    // If we have viewports that need rendering and we have not already\n    // set the RAF callback to run on the next frame.\n    if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n      this._animationFrameHandle = window.requestAnimationFrame(\n        this._renderFlaggedToolGroups\n      );\n\n      // Set the flag that we have already set up the next RAF call.\n      this._animationFrameSet = true;\n    }\n  }\n\n  private _renderFlaggedToolGroups = () => {\n    this._throwIfDestroyed();\n\n    // for each toolGroupId insides the _needsRender set, render the segmentation\n    const toolGroupIds = Array.from(this._needsRender.values());\n\n    for (const toolGroupId of toolGroupIds) {\n      this._triggerRender(toolGroupId);\n\n      // This viewport has been rendered, we can remove it from the set\n      this._needsRender.delete(toolGroupId);\n\n      // If there is nothing left that is flagged for rendering, stop here\n      // and allow RAF to be called again\n      if (this._needsRender.size === 0) {\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        return;\n      }\n    }\n  };\n  _triggerRender(toolGroupId) {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      console.warn(`No tool group found with toolGroupId: ${toolGroupId}`);\n      return;\n    }\n\n    const { viewportsInfo } = toolGroup;\n\n    const viewports = viewportsInfo\n      .map(({ viewportId, renderingEngineId }) => {\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n\n        if (!renderingEngine) {\n          console.warn('rendering Engine has been destroyed');\n          return;\n        }\n\n        const viewport = renderingEngine.getViewport(viewportId);\n\n        if (viewport) {\n          return viewport;\n        }\n      })\n      .filter(Boolean);\n\n    const segmentationDisplayToolInstance = toolGroup.getToolInstance(\n      SegmentationDisplayTool.toolName\n    ) as SegmentationDisplayTool;\n    if (!segmentationDisplayToolInstance) {\n      console.warn('No segmentation tool found inside', toolGroupId);\n      return;\n    }\n\n    function onSegmentationRender(evt: Types.EventTypes.ImageRenderedEvent) {\n      const { element, viewportId, renderingEngineId } = evt.detail;\n\n      element.removeEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        onSegmentationRender as EventListener\n      );\n\n      const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n\n      if (!toolGroup) {\n        console.warn('toolGroup has been destroyed');\n        return;\n      }\n\n      const eventDetail: SegmentationRenderedEventDetail = {\n        toolGroupId: toolGroup.id,\n        viewportId,\n      };\n\n      triggerEvent(eventTarget, csToolsEvents.SEGMENTATION_RENDERED, {\n        ...eventDetail,\n      });\n    }\n\n    // Todo: for other representations we probably need the drawSVG, but right now we are not using it\n    // drawSvg(element, (svgDrawingHelper) => {\n    //   const handleDrawSvg = (tool) => {\n    //     if (tool instanceof SegmentationDisplayTool && tool.renderAnnotation) {\n    //       tool.renderAnnotation({ detail: eventDetail })\n    //       triggerEvent(element, csToolsEvents.SEGMENTATION_RENDERED, { ...eventDetail })\n    //     }\n    //   }\n    //   enabledTools.forEach(handleDrawSvg)\n    // })\n\n    viewports.forEach(({ element }) => {\n      element.addEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        onSegmentationRender as EventListener\n      );\n    });\n\n    segmentationDisplayToolInstance.renderSegmentation(toolGroupId);\n  }\n\n  /**\n   *  _reset Resets the `RenderingEngine`\n   */\n  private _reset() {\n    window.cancelAnimationFrame(this._animationFrameHandle);\n\n    this._needsRender.clear();\n    this._animationFrameSet = false;\n    this._animationFrameHandle = null;\n  }\n}\n\nconst segmentationRenderingEngine = new SegmentationRenderingEngine();\n\n/**\n * It triggers a render for all the segmentations of the tool group with the given Id.\n * @param toolGroupId - The Id of the tool group to render.\n */\nfunction triggerSegmentationRender(toolGroupId: string): void {\n  segmentationRenderingEngine.renderToolGroupSegmentations(toolGroupId);\n}\n\nexport { segmentationRenderingEngine, triggerSegmentationRender };\nexport default triggerSegmentationRender;\n","import vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport {\n  BaseVolumeViewport,\n  getEnabledElement,\n  Enums,\n  getEnabledElementByIds,\n  cache,\n  utilities,\n  Types,\n} from '@cornerstonejs/core';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../stateManagement/segmentation/segmentationState';\nimport { LabelmapSegmentationDataStack } from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\nimport triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\n\nconst enable = function (element: HTMLDivElement): void {\n  const { viewport } = getEnabledElement(element);\n\n  if (viewport instanceof BaseVolumeViewport) {\n    return;\n  }\n\n  element.addEventListener(\n    Enums.Events.STACK_NEW_IMAGE,\n    _imageChangeEventListener as EventListener\n  );\n  // this listener handles the segmentation modifications\n  element.addEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    _imageChangeEventListener as EventListener\n  );\n};\n\nconst disable = function (element: HTMLDivElement): void {\n  element.removeEventListener(\n    Enums.Events.STACK_NEW_IMAGE,\n    _imageChangeEventListener as EventListener\n  );\n  element.removeEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    _imageChangeEventListener as EventListener\n  );\n};\n\nconst perToolGroupManualTriggers = new Map();\n\n/**\n *  When the image is rendered, check what tools can be rendered for this element.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `renderAnnotation` method, then we render them.\n * - Note that these tools don't necessarily have to be instances of  `AnnotationTool`,\n *   Any tool may register a `renderAnnotation` method (e.g. a tool that displays an overlay).\n *\n * @param evt - The normalized IMAGE_RENDERED event.\n */\nfunction _imageChangeEventListener(evt) {\n  const eventData = evt.detail;\n  const { viewportId, renderingEngineId } = eventData;\n  const { viewport } = getEnabledElementByIds(\n    viewportId,\n    renderingEngineId\n  ) as { viewport: Types.IStackViewport };\n\n  const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n\n  if (!toolGroup) {\n    return;\n  }\n\n  let toolGroupSegmentationRepresentations =\n    SegmentationState.getSegmentationRepresentations(toolGroup.id) || [];\n\n  toolGroupSegmentationRepresentations =\n    toolGroupSegmentationRepresentations.filter(\n      (representation) => representation.type === Representations.Labelmap\n    );\n\n  if (!toolGroupSegmentationRepresentations?.length) {\n    return;\n  }\n\n  const segmentationRepresentations = {};\n  toolGroupSegmentationRepresentations.forEach((representation) => {\n    const segmentation = SegmentationState.getSegmentation(\n      representation.segmentationId\n    );\n\n    if (!segmentation || !segmentation.representationData?.LABELMAP) {\n      return;\n    }\n\n    const labelmapData = segmentation.representationData.LABELMAP;\n\n    if (isVolumeSegmentation(labelmapData, viewport)) {\n      return;\n    }\n\n    const { imageIdReferenceMap } =\n      labelmapData as LabelmapSegmentationDataStack;\n\n    segmentationRepresentations[representation.segmentationRepresentationUID] =\n      {\n        imageIdReferenceMap,\n      };\n  });\n\n  const representationList = Object.keys(segmentationRepresentations);\n  const currentImageId = viewport.getCurrentImageId();\n  const actors = viewport.getActors();\n\n  const segmentationFound = actors.find((actor) => {\n    if (!representationList.includes(actor.uid)) {\n      return false;\n    }\n\n    return true;\n  });\n\n  if (!segmentationFound) {\n    // If the segmentation is not found, it could be because of some special cases\n    // where we are in the process of updating the volume conversion to a stack while\n    // the data is still coming in. In such situations, we should trigger the render\n    // to ensure that the segmentation actors are created, even if the data arrives late.\n\n    if (!perToolGroupManualTriggers.has(toolGroup.id)) {\n      perToolGroupManualTriggers.set(toolGroup.id, true);\n      triggerSegmentationRender(toolGroup.id);\n    }\n\n    // we should return here, since there is no segmentation actor to update\n    // we will hit this function later on after the actor is created\n    return;\n  }\n\n  actors.forEach((actor) => {\n    if (!representationList.includes(actor.uid)) {\n      return;\n    }\n    const segmentationActor = actor.actor;\n\n    const { imageIdReferenceMap } = segmentationRepresentations[actor.uid];\n\n    const derivedImageId = imageIdReferenceMap.get(currentImageId);\n\n    const segmentationImageData = segmentationActor.getMapper().getInputData();\n\n    if (!derivedImageId) {\n      // this means that this slice doesn't have a segmentation for this representation\n      // this can be a case where the segmentation was added to certain slices only\n      // so we can keep the actor but empty out the imageData\n      if (segmentationImageData.setDerivedImage) {\n        // If the image data has a set derived image, then it should be called\n        // to update any vtk or actor data associated with it.  In this case, null\n        // is used to clear the data.  THis allows intercepting/alternative\n        // to vtk calls.  Eventually the vtk version should also use this.\n        segmentationImageData.setDerivedImage(null);\n        return;\n      }\n      // This is the vtk version of the clearing out the image data, and fails\n      // to work for non scalar image data.\n      const scalarArray = vtkDataArray.newInstance({\n        name: 'Pixels',\n        numberOfComponents: 1,\n        values: new Uint8Array(segmentationImageData.getNumberOfPoints()),\n      });\n\n      const imageData = vtkImageData.newInstance();\n      imageData.getPointData().setScalars(scalarArray);\n      segmentationActor.getMapper().setInputData(imageData);\n      return;\n    }\n\n    const derivedImage = cache.getImage(derivedImageId);\n\n    const { dimensions, spacing, direction } =\n      viewport.getImageDataMetadata(derivedImage);\n\n    const currentImage =\n      cache.getImage(currentImageId) ||\n      ({\n        imageId: currentImageId,\n      } as Types.IImage);\n    const { origin: currentOrigin } =\n      viewport.getImageDataMetadata(currentImage);\n\n    // IMPORTANT: We need to make sure that the origin of the segmentation\n    // is the same as the current image origin. This is because due to some\n    // floating point precision issues, when coming from volume to stack\n    // the origin of the segmentation can be slightly different from the\n    // current image origin. This can cause the segmentation to be rendered\n    // in the wrong location.\n    // Todo: This will not work for segmentations that are not in the same frame\n    // of reference or derived from the same image. This can happen when we have\n    // a segmentation that happens to exist in the same space as the image but is\n    // not derived from it. We need to find a way to handle this case, but don't think\n    // it makes sense to do it for the stack viewport, as the volume viewport is designed to handle this case.\n    const originToUse = currentOrigin;\n\n    segmentationImageData.setOrigin(originToUse);\n    segmentationImageData.modified();\n\n    if (\n      segmentationImageData.getDimensions()[0] !== dimensions[0] ||\n      segmentationImageData.getDimensions()[1] !== dimensions[1]\n    ) {\n      // IMPORTANT: Not sure why we can't just update the dimensions\n      // and the orientation of the image data and then call modified\n      // I tried calling modified on everything, but seems like we should remove\n      // and add the actor again below\n      viewport.removeActors([actor.uid]);\n      viewport.addImages(\n        [\n          {\n            imageId: derivedImageId,\n            actorUID: actor.uid,\n            callback: ({ imageActor }) => {\n              const scalarArray = vtkDataArray.newInstance({\n                name: 'Pixels',\n                numberOfComponents: 1,\n                values: [...derivedImage.getPixelData()],\n              });\n\n              const imageData = vtkImageData.newInstance();\n\n              imageData.setDimensions(dimensions[0], dimensions[1], 1);\n              imageData.setSpacing(spacing);\n              imageData.setDirection(direction);\n              imageData.setOrigin(originToUse);\n              imageData.getPointData().setScalars(scalarArray);\n\n              imageActor.getMapper().setInputData(imageData);\n            },\n          },\n        ],\n        true,\n        false\n      );\n\n      triggerSegmentationRender(toolGroup.id);\n      return;\n    }\n\n    if (segmentationImageData.setDerivedImage) {\n      // Update the derived image data, whether vtk or other as appropriate\n      // to the actor(s) displaying the data.\n      segmentationImageData.setDerivedImage(derivedImage);\n    } else {\n      // TODO - use setDerivedImage for this functionality\n      utilities.updateVTKImageDataWithCornerstoneImage(\n        segmentationImageData,\n        derivedImage\n      );\n    }\n    viewport.render();\n\n    // This is put here to make sure that the segmentation is rendered\n    // for the initial image as well after that we don't need it since\n    // stack new image is called when changing slices\n    if (evt.type === Enums.Events.IMAGE_RENDERED) {\n      // unsubscribe after the initial render\n      viewport.element.removeEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        _imageChangeEventListener as EventListener\n      );\n    }\n  });\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import { Enums, Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from '../utilities/triggerAnnotationRender';\n\n/**\n *  When the image is rendered, check what tools can be rendered for this element.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `renderAnnotation` method, then we render them.\n * - Note that these tools don't necessarily have to be instances of  `AnnotationTool`,\n *   Any tool may register a `renderAnnotation` method (e.g. a tool that displays an overlay).\n *\n * @param evt - The normalized IMAGE_RENDERED event.\n */\nconst onImageRendered = function (evt: Types.EventTypes.ImageRenderedEvent) {\n  // TODO: should we do this on camera modified instead of image rendered?\n  // e.g. no need to re-render annotations if only the VOI has changed\n  triggerAnnotationRender(evt.detail.element);\n};\n\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    onImageRendered as EventListener\n  );\n};\n\nconst disable = function (element: HTMLDivElement): void {\n  element.removeEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    onImageRendered as EventListener\n  );\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\n\ntype ModesFilter = Array<ToolModes>;\n\n/**\n * Given the normalized mouse event and a filter of modes,\n * find all the tools on the element that are in one of the specified modes.\n * If the evtButton is specified, only tools with a matching binding will be returned.\n * @param evt - The normalized mouseDown event.\n * @param modesFilter - An array of entries from the `ToolModes` enum.\n */\nexport default function getToolsWithModesForMouseEvent(\n  evt: EventTypes.MouseMoveEventType,\n  modesFilter: ModesFilter,\n  evtButton?: any\n) {\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return [];\n  }\n\n  const enabledTools = [];\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.toolOptions[toolName];\n\n    // tool has binding that matches the mouse button - we match those with\n    // any modifier keys too since they can be passively interacted with\n    const correctBinding =\n      evtButton != null && // not null or undefined\n      tool.bindings.length &&\n      tool.bindings.some((binding) => binding.mouseButton === evtButton);\n\n    if (\n      modesFilter.includes(tool.mode) &&\n      // Should not filter by event's button\n      // or should, and the tool binding includes the event's button\n      (!evtButton || correctBinding)\n    ) {\n      const toolInstance = toolGroup.getToolInstance(toolName);\n      enabledTools.push(toolInstance);\n    }\n  }\n\n  return enabledTools;\n}\n","import { Enums, Types } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * When the camera is modified, check what tools need to react to this.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `onCameraModified` method, we call it.\n *\n * @param evt - The normalized camera modified event.\n */\nconst onCameraModified = function (evt: Types.EventTypes.CameraModifiedEvent) {\n  // @ts-ignore\n  const enabledTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n    Enabled,\n  ]);\n\n  enabledTools.forEach((tool) => {\n    if (tool.onCameraModified) {\n      tool.onCameraModified(evt);\n    }\n  });\n};\n\nconst enable = function (element) {\n  element.addEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\n\nconst disable = function (element) {\n  element.removeEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import { Enums, Types } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * When image spacing is calibrated modify the annotations for all of its tools\n * to consider the new calibration info.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `onImageSpacingCalibrated` method, we call it.\n *\n * @param evt - The normalized image calibration event.\n */\nconst onImageSpacingCalibrated = function (\n  evt: Types.EventTypes.ImageSpacingCalibratedEvent\n) {\n  // @ts-ignore\n  const enabledTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n    Enabled,\n  ]);\n\n  enabledTools.forEach((tool) => {\n    if (tool.onImageSpacingCalibrated) {\n      tool.onImageSpacingCalibrated(evt);\n    }\n  });\n};\n\nconst enable = function (element: HTMLDivElement) {\n  element.addEventListener(\n    Enums.Events.IMAGE_SPACING_CALIBRATED,\n    onImageSpacingCalibrated as EventListener\n  );\n};\n\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(\n    Enums.Events.IMAGE_SPACING_CALIBRATED,\n    onImageSpacingCalibrated as EventListener\n  );\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import { state, ToolGroupManager } from '../../store';\nimport ToolModes from '../../enums/ToolModes';\n\nconst { Active } = ToolModes;\n\n/**\n * @function customCallbackHandler This is used as a generic event handler for tool events\n * on viewports. It:\n *\n * - Finds an \"active\" tool with:\n *    - A matching `handlerType`\n *    - A matching `customFunction` on its tool instance\n *\n * Then calls that custom function with raised event.\n *\n * @param handlerType - 'Mouse' | 'Touch' | 'MouseWheel'\n * @param customFunction - Function name that's expected to live on implementing\n *   (and event handling) active tool ex. 'doubleClickCallback'\n * @param evt\n */\nexport default function customCallbackHandler(\n  handlerType: string,\n  customFunction: string,\n  evt\n) {\n  if (state.isInteractingWithTool) {\n    return false;\n  }\n\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return false;\n  }\n\n  // TODO: Filter tools by interaction type?\n  /**\n   * Iterate tool group tools until we find a tool that is:\n   * - active\n   * - has the custom callback function\n   *\n   */\n  let activeTool;\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.toolOptions[toolName];\n    // TODO: Should be getter\n    const toolInstance = toolGroup.getToolInstance(toolName);\n\n    if (\n      // TODO: Should be enum?\n      tool.mode === Active &&\n      // TODO: Should be implements interface?\n      // Weird that we need concrete instance. Other options to filter / get callback?\n      typeof toolInstance[customFunction] === 'function'\n    ) {\n      activeTool = toolGroup.getToolInstance(toolName);\n      break;\n    }\n  }\n\n  if (!activeTool) {\n    return;\n  }\n\n  activeTool[customFunction](evt);\n}\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * mouseClick - Event handler for mouse click events. Uses `customCallbackHandler` to fire\n * the `mouseClickCallback` function on active tools.\n */\nconst mouseClick = customCallbackHandler.bind(\n  null,\n  'Mouse',\n  'mouseClickCallback'\n);\n\nexport default mouseClick;\n","import type { Types } from '@cornerstonejs/core';\n\nimport {\n  ToolAnnotationsPair,\n  ToolsWithMoveableHandles,\n} from '../types/InternalToolTypes';\n\n/**\n * Filters an array of tools, returning only tools with moveable handles at the mouse location that are not locked\n *\n * @param element - The element\n * @param ToolAndAnnotations - The input tool array.\n * @param canvasCoords - The coordinates of the mouse position.\n * @param interactionType - The type of interaction (e.g. 'mouse' or 'touch')\n * @returns The filtered array.\n */\nexport default function filterToolsWithMoveableHandles(\n  element: HTMLDivElement,\n  ToolAndAnnotations: ToolAnnotationsPair[],\n  canvasCoords: Types.Point2,\n  interactionType = 'mouse'\n): ToolsWithMoveableHandles[] {\n  const proximity = interactionType === 'touch' ? 36 : 6;\n  const toolsWithMoveableHandles = [];\n\n  ToolAndAnnotations.forEach(({ tool, annotations }) => {\n    for (const annotation of annotations) {\n      if (annotation.isLocked || !annotation.isVisible) {\n        continue;\n      }\n\n      const handle = tool.getHandleNearImagePoint(\n        element,\n        annotation,\n        canvasCoords,\n        proximity\n      );\n\n      if (handle) {\n        toolsWithMoveableHandles.push({\n          tool,\n          annotation,\n          handle,\n        });\n        break;\n      }\n    }\n  });\n\n  return toolsWithMoveableHandles;\n}\n","import { getAnnotations } from '../stateManagement/annotation/annotationState';\nimport { ToolAnnotationsPair } from '../types/InternalToolTypes';\nimport type AnnotationTool from '../tools/base/AnnotationTool';\nimport BaseTool from '../tools/base/BaseTool';\n\n/**\n * Filters an array of tools, returning only tools which have annotation.\n *\n * @param element - The cornerstone3D enabled element.\n * @param tools - The array of tools to check.\n *\n * @returns The array of tools with their found annotations.\n */\nexport default function filterToolsWithAnnotationsForElement(\n  element: HTMLDivElement,\n  tools: AnnotationTool[]\n): ToolAnnotationsPair[] {\n  const result = [];\n  for (let i = 0; i < tools.length; i++) {\n    const tool = tools[i];\n\n    if (!tool) {\n      console.warn('undefined tool in filterToolsWithAnnotationsForElement');\n      continue;\n    }\n\n    let annotations = getAnnotations(\n      (tool.constructor as typeof BaseTool).toolName,\n      element\n    );\n\n    if (!annotations?.length) {\n      continue;\n    }\n\n    if (typeof tool.filterInteractableAnnotationsForElement === 'function') {\n      // If the tool has a annotations filter (e.g. with in-plane-annotations-only filtering), use it.\n      annotations = tool.filterInteractableAnnotationsForElement(\n        element,\n        annotations\n      );\n    }\n\n    if (annotations.length > 0) {\n      result.push({ tool, annotations });\n    }\n  }\n\n  return result;\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport {\n  ToolAnnotationPair,\n  ToolAnnotationsPair,\n} from '../types/InternalToolTypes';\n\n/**\n * Filters an array of tools with annotations, returning the first annotation\n * for each tool that is moveable and at the mouse location. It results in\n * one annotation per tool.\n *\n *\n * @param element - The HTML element\n * @param ToolAndAnnotations - The input tool array.\n * @param canvasCoords - The coordinates of the mouse position.\n * @param interactionType - The type of interaction that is taking place.\n * @returns The filtered array containing ToolAndAnnotation\n */\nexport default function filterMoveableAnnotationTools(\n  element: HTMLDivElement,\n  ToolAndAnnotations: ToolAnnotationsPair[],\n  canvasCoords: Types.Point2,\n  interactionType = 'mouse'\n): ToolAnnotationPair[] {\n  const proximity = interactionType === 'touch' ? 36 : 6;\n\n  // TODO - This could get pretty expensive pretty quickly. We don't want to fetch the camera\n  // And do world to canvas on each coord.\n\n  // We want to produce a matrix from canvas to world for the viewport and just do a matrix operation on each handle.\n  // This could still be expensive for ROIs, but we probably shouldn't have \"handles\" for them anyway.\n\n  const moveableAnnotationTools = [];\n\n  ToolAndAnnotations.forEach(({ tool, annotations }) => {\n    for (const annotation of annotations) {\n      if (annotation.isLocked || !annotation.isVisible) {\n        continue;\n      }\n\n      const near = tool.isPointNearTool(\n        element,\n        annotation,\n        canvasCoords,\n        proximity,\n        interactionType\n      );\n\n      if (near) {\n        moveableAnnotationTools.push({\n          tool,\n          annotation,\n        });\n        break;\n      }\n    }\n  });\n\n  return moveableAnnotationTools;\n}\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { keyEventListener } from '../../eventListeners';\nimport { EventTypes } from '../../types';\nimport getMouseModifier from './getMouseModifier';\n\nconst { Active } = ToolModes;\n\n/**\n * Iterate tool group tools until we find a tool that has a \"ToolBinding\"\n * that matches our MouseEvent's `buttons`. It's possible there will be no match\n * (no active tool for that mouse button combination).\n *\n * @param evt - The event dispatcher mouse event.\n *\n * @returns tool\n */\nexport default function getActiveToolForMouseEvent(\n  evt: EventTypes.NormalizedMouseEventType\n) {\n  // Todo: we should refactor this to use getToolsWithModesForMouseEvent instead\n  const { renderingEngineId, viewportId } = evt.detail;\n  const mouseEvent = evt.detail.event;\n\n  // If any keyboard modifier key is also pressed - get the mouse version\n  // first since it handles combinations, while the key event handles non-modifier\n  // keys.\n  const modifierKey =\n    getMouseModifier(mouseEvent) || keyEventListener.getModifierKey();\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    // tool has binding that matches the mouse button, if mouseEvent is undefined\n    // it uses the primary button\n    const correctBinding =\n      toolOptions.bindings.length &&\n      toolOptions.bindings.some((binding) => {\n        return (\n          binding.mouseButton ===\n            (mouseEvent ? mouseEvent.buttons : defaultMousePrimary) &&\n          binding.modifierKey === modifierKey\n        );\n      });\n\n    if (toolOptions.mode === Active && correctBinding) {\n      return toolGroup.getToolInstance(toolName);\n    }\n  }\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\n\n// Util\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport filterMoveableAnnotationTools from '../../store/filterMoveableAnnotationTools';\nimport getToolsWithActionsForMouseEvent from '../shared/getToolsWithActionsForMouseEvent';\n\nconst { Active, Passive } = ToolModes;\n\n/**\n * Look for active or passive annotations with an action that could handle the\n * event based on the bindings and invoke the first one found.\n *\n * @param evt - The normalized mouseDown event.\n * @returns True if an action has executed or false otherwise\n */\nexport default function mouseDownAnnotationAction(\n  evt: EventTypes.MouseDownEventType\n): boolean {\n  // If a tool has locked the current state it is dealing with an interaction within its own eventLoop.\n  if (state.isInteractingWithTool) {\n    return false;\n  }\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { canvas: canvasCoords } = eventDetail.currentPoints;\n\n  if (!enabledElement) {\n    return false;\n  }\n\n  // Find all tools that might respond to this mouse down\n  const toolsWithActions = getToolsWithActionsForMouseEvent(evt, [\n    Active,\n    Passive,\n  ]);\n\n  const tools = Array.from(toolsWithActions.keys());\n\n  // Filter tools with annotations for this element\n  const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(\n    element,\n    tools\n  );\n\n  // Only moveable annotations (unlocked, visible and close to the canvas coordinates) may trigger actions\n  const moveableAnnotationTools = filterMoveableAnnotationTools(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords\n  );\n\n  // If there are annotation tools that are interactable, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (moveableAnnotationTools.length > 0) {\n    const { tool, annotation } = moveableAnnotationTools[0];\n    const action = toolsWithActions.get(tool);\n    const method =\n      typeof action.method === 'string' ? tool[action.method] : action.method;\n\n    method.call(tool, evt, annotation);\n\n    return true;\n  }\n\n  return false;\n}\n","import { state } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\nimport {\n  ToolAnnotationPair,\n  ToolsWithMoveableHandles,\n} from '../../types/InternalToolTypes';\n\nimport {\n  setAnnotationSelected,\n  isAnnotationSelected,\n} from '../../stateManagement/annotation/annotationSelection';\n\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\n\n// Util\nimport filterToolsWithMoveableHandles from '../../store/filterToolsWithMoveableHandles';\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport filterMoveableAnnotationTools from '../../store/filterMoveableAnnotationTools';\nimport getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport getToolsWithModesForMouseEvent from '../shared/getToolsWithModesForMouseEvent';\nimport mouseDownAnnotationAction from './mouseDownAnnotationAction';\n\nconst { Active, Passive } = ToolModes;\n\n/**\n * When the mouse is depressed we check which entities can process these events in the following manner:\n *\n * - First we get the `activeTool` for the mouse button pressed.\n * - If the `activeTool` has a `preMouseDownCallback`, this is called. If the callback returns `true`,\n *   the event does not propagate further.\n * - Next we get all tools which are active or passive (`activeAndPassiveTools`), as annotation. for these tools could\n *   possibly catch and handle these events. We then filter the `activeAndPassiveTools` using `filterToolsWithAnnotationsForElement`, which filters tools with annotations\n *   for this frame of reference. Optionally a tool can employ a further filtering (via a\n *   `filterInteractableAnnotationsForElement` callback) for tools interactable within the current camera view\n *   (e.g. tools that only render when viewed from a certain direction).\n * - Next we check if any handles are interactable for each tool (`filterToolsWithMoveableHandles`). If interactable\n *   handles are found, the first tool/handle found consumes the event and the event does not propagate further.\n * - Next we check any tools are interactable (e.g. moving an entire length annotation rather than one of its handles:\n *   `filterMoveableAnnotationTools`). If interactable tools are found, the first tool found consumes the event and the\n *   event does not propagate further.\n * - If the `activeTool` has `postMouseDownCallback`, this is called.  If the callback returns `true`,\n *   the event does not propagate further.\n * - Finally, look for annotations actions that could handle the event such as showing a dropdown to allow the user\n *   change the magnifying glass zoom factor.\n *\n * If the event is not consumed the event will bubble to the `mouseDownActivate` handler.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseDown(evt: EventTypes.MouseDownEventType) {\n  // If a tool has locked the current state it is dealing with an interaction within its own eventLoop.\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForMouseEvent(evt);\n\n  // Check for preMouseDownCallbacks,\n  // If the tool claims it consumed the event, prevent further checks.\n  if (activeTool && typeof activeTool.preMouseDownCallback === 'function') {\n    const consumedEvent = activeTool.preMouseDownCallback(evt);\n\n    if (consumedEvent) {\n      return;\n    }\n  }\n\n  // Find all tools that might respond to this mouse down\n  const isPrimaryClick = evt.detail.event.buttons === 1;\n  const activeToolsWithEventBinding = getToolsWithModesForMouseEvent(\n    evt,\n    [Active],\n    evt.detail.event.buttons\n  );\n  const passiveToolsIfEventWasPrimaryMouseButton = isPrimaryClick\n    ? getToolsWithModesForMouseEvent(evt, [Passive])\n    : undefined;\n  const applicableTools = [\n    ...(activeToolsWithEventBinding || []),\n    ...(passiveToolsIfEventWasPrimaryMouseButton || []),\n  ];\n\n  // Actions need to run before tool/handle selected callbacks otherwise actions\n  // like the one from SplineTool to remove/add control points would not work.\n  const actionExecuted = mouseDownAnnotationAction(evt);\n\n  if (actionExecuted) {\n    return;\n  }\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Filter tools with annotations for this element\n  const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(\n    element,\n    applicableTools\n  );\n\n  const canvasCoords = eventDetail.currentPoints.canvas;\n\n  // For the canvas coordinates, find all tools that might respond to this mouse down\n  // on their handles. This filter will call getHandleNearImagePoint for each tool\n  // instance (each annotation)\n  const annotationToolsWithMoveableHandles = filterToolsWithMoveableHandles(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'mouse'\n  );\n\n  // Preserve existing selections when shift key is pressed\n  const isMultiSelect = !!evt.detail.event.shiftKey;\n\n  // If there are annotation tools whose handle is near the mouse, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (annotationToolsWithMoveableHandles.length > 0) {\n    const { tool, annotation, handle } = getAnnotationForSelection(\n      annotationToolsWithMoveableHandles\n    ) as ToolsWithMoveableHandles;\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.handleSelectedCallback(evt, annotation, handle, 'Mouse');\n\n    return;\n  }\n\n  // If there were no annotation tools whose handle was near the mouse, try to check\n  // if any of the annotation tools are interactable (e.g. moving an entire length annotation)\n  const moveableAnnotationTools = filterMoveableAnnotationTools(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'mouse'\n  );\n\n  // If there are annotation tools that are interactable, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (moveableAnnotationTools.length > 0) {\n    const { tool, annotation } = getAnnotationForSelection(\n      moveableAnnotationTools\n    );\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.toolSelectedCallback(evt, annotation, 'Mouse', canvasCoords);\n\n    return;\n  }\n\n  // Run the postMouseDownCallback for the active tool if it exists\n  if (activeTool && typeof activeTool.postMouseDownCallback === 'function') {\n    const consumedEvent = activeTool.postMouseDownCallback(evt);\n\n    if (consumedEvent) {\n      // If the tool claims it consumed the event, prevent further checks.\n      return;\n    }\n  }\n\n  // Don't stop propagation so that mouseDownActivate can handle the event\n}\n\n/**\n * If there are multiple annotation tools, return the first one that isn't locked neither hidden.\n * If there's only one annotation tool, return it\n * @param annotationTools - An array of tools and annotation.\n * @returns The candidate for selection\n */\nfunction getAnnotationForSelection(\n  toolsWithMovableHandles: ToolAnnotationPair[]\n): ToolAnnotationPair {\n  return (\n    (toolsWithMovableHandles.length > 1 &&\n      toolsWithMovableHandles.find(\n        (item) =>\n          !isAnnotationLocked(item.annotation) &&\n          isAnnotationVisible(item.annotation.annotationUID)\n      )) ||\n    toolsWithMovableHandles[0]\n  );\n}\n\n/**\n * If the annotation is selected, deselect it. If it's not selected, select it\n * @param annotationUID - The AnnotationUID that we\n * want to toggle the selection of.\n * @param isMultiSelect - If true, the annotation. will be deselected if it is\n * already selected, or deselected if it is selected.\n */\nfunction toggleAnnotationSelection(\n  annotationUID: string,\n  isMultiSelect = false\n): void {\n  if (isMultiSelect) {\n    if (isAnnotationSelected(annotationUID)) {\n      setAnnotationSelected(annotationUID, false);\n    } else {\n      const preserveSelected = true;\n      setAnnotationSelected(annotationUID, true, preserveSelected);\n    }\n  } else {\n    const preserveSelected = false;\n    setAnnotationSelected(annotationUID, true, preserveSelected);\n  }\n}\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { ToolAction, EventTypes } from '../../types';\n\nimport { keyEventListener } from '../../eventListeners';\nimport getMouseModifier from './getMouseModifier';\n\n/**\n * Given the mouse event and a list of tool modes, find all tool instances\n * with actions that were added to the tool group associated with the viewport\n * that triggered the event.\n *\n * @param evt - mouseDown event triggered by a cornerstone viewport\n * @param toolModes - List of tool modes used to filter the tools registered\n *                    in the viewport's tool group\n */\nexport default function getToolsWithActionsForMouseEvent(\n  evt: EventTypes.MouseMoveEventType,\n  toolModes: ToolModes[]\n): Map<any, ToolAction> {\n  const toolsWithActions = new Map();\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return toolsWithActions;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n  const mouseEvent = evt.detail.event;\n  const mouseButton = mouseEvent?.buttons ?? defaultMousePrimary;\n  const modifierKey =\n    getMouseModifier(mouseEvent) || keyEventListener.getModifierKey();\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.getToolInstance(toolName);\n    const actionsConfig = tool.configuration?.actions ?? {};\n    const actions = Object.values(actionsConfig);\n\n    if (!actions?.length || !toolModes.includes(tool.mode)) {\n      continue;\n    }\n\n    const action = actions.find(\n      (action: any) =>\n        action.bindings.length &&\n        action.bindings.some(\n          (binding) =>\n            binding.mouseButton === mouseButton &&\n            binding.modifierKey === modifierKey\n        )\n    );\n\n    if (action) {\n      toolsWithActions.set(tool, action);\n    }\n  }\n\n  return toolsWithActions;\n}\n","import { state } from '../../store';\nimport getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\nimport { EventTypes } from '../../types';\n\n/**\n * If the `mouseDown` handler does not consume an event,\n * activate the creation loop of the active tool, if one is found for the\n * mouse button pressed.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseDownActivate(\n  evt: EventTypes.MouseDownActivateEventType\n) {\n  // If a tool has locked the current state it is dealing with an interaction within its own eventLoop.\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForMouseEvent(evt);\n\n  if (!activeTool) {\n    return;\n  }\n\n  if (state.isMultiPartToolActive) {\n    return;\n  }\n\n  if (activeTool.addNewAnnotation) {\n    const annotation = activeTool.addNewAnnotation(evt, 'mouse');\n    setAnnotationSelected(annotation.annotationUID);\n  }\n}\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * @function mouseDoubleClick - Event handler for mouse double click events. Uses `customCallbackHandler` to fire\n * the `doubleClickCallback` function on active tools.\n */\nconst mouseDoubleClick = customCallbackHandler.bind(\n  null,\n  'Mouse',\n  'doubleClickCallback'\n);\n\nexport default mouseDoubleClick;\n","import getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport { state } from '../../store';\nimport { MouseDragEventType } from '../../types/EventTypes';\n\n/**\n * mouseDrag - Event handler for mouse drag events. Fires the `mouseDragCallback`\n * function on active tools.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseDrag(evt: MouseDragEventType) {\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForMouseEvent(evt);\n\n  const noFoundToolOrDoesNotHaveMouseDragCallback =\n    !activeTool || typeof activeTool.mouseDragCallback !== 'function';\n  if (noFoundToolOrDoesNotHaveMouseDragCallback) {\n    return;\n  }\n\n  activeTool.mouseDragCallback(evt);\n}\n","// // State\nimport { state } from '../../store';\nimport { ToolModes } from '../../enums';\n\n// // Util\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport getToolsWithModesForMouseEvent from '../shared/getToolsWithModesForMouseEvent';\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\nimport { MouseMoveEventType } from '../../types/EventTypes';\n\nconst { Active, Passive } = ToolModes;\n\n/**\n * mouseMove - On mouse move when not dragging, fire tools `mouseMoveCallback`s.\n * This is mostly used to update the [un]hover state\n * of a tool.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseMove(evt: MouseMoveEventType) {\n  // Tool interactions when mouse moved are handled inside each tool.\n  // This function is mostly used to update the [un]hover state\n  if (state.isInteractingWithTool || state.isMultiPartToolActive) {\n    return;\n  }\n\n  const activeAndPassiveTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n  ]);\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Annotation tool specific\n  const toolsWithAnnotations = filterToolsWithAnnotationsForElement(\n    element,\n    activeAndPassiveTools\n  );\n\n  const toolsWithoutAnnotations = activeAndPassiveTools.filter((tool) => {\n    const doesNotHaveAnnotations = !toolsWithAnnotations.some(\n      (toolAndAnnotation) =>\n        toolAndAnnotation.tool.getToolName() === tool.getToolName()\n    );\n\n    return doesNotHaveAnnotations;\n  });\n\n  let annotationsNeedToBeRedrawn = false;\n\n  for (const { tool, annotations } of toolsWithAnnotations) {\n    if (typeof tool.mouseMoveCallback === 'function') {\n      annotationsNeedToBeRedrawn =\n        tool.mouseMoveCallback(evt, annotations) || annotationsNeedToBeRedrawn;\n    }\n  }\n\n  // Run mouse move handlers for non-annotation tools\n  toolsWithoutAnnotations.forEach((tool) => {\n    if (typeof tool.mouseMoveCallback === 'function') {\n      tool.mouseMoveCallback(evt);\n    }\n  });\n\n  // Annotation activation status changed, redraw the annotations\n  if (annotationsNeedToBeRedrawn === true) {\n    triggerAnnotationRender(element);\n  }\n}\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * mouseClick - Event handler for mouse up events. Uses `customCallbackHandler` to fire\n * the `mouseUpCallback` function on active tools.\n */\nconst mouseUp = customCallbackHandler.bind(null, 'Mouse', 'mouseUpCallback');\n\nexport default mouseUp;\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * Event handler for mouse wheel events. Uses `customCallbackHandler` to fire\n * the `mouseWheelCallback` function on active tools.\n */\nconst mouseWheel = customCallbackHandler.bind(\n  null,\n  'MouseWheel',\n  'mouseWheelCallback'\n);\n\nexport default mouseWheel;\n","import Events from '../enums/Events';\n\nimport {\n  mouseClick,\n  mouseDown,\n  mouseDownActivate,\n  mouseDoubleClick,\n  mouseDrag,\n  mouseMove,\n  mouseUp,\n  mouseWheel,\n} from './mouseEventHandlers';\n\n/**\n * Enable these listeners are emitted in order, and can be cancelled/prevented from bubbling\n * by any previous event.\n *\n * @param element - The element to add the event listeners to.\n */\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(Events.MOUSE_CLICK, mouseClick as EventListener);\n  element.addEventListener(Events.MOUSE_DOWN, mouseDown as EventListener);\n  element.addEventListener(\n    Events.MOUSE_DOWN_ACTIVATE,\n    mouseDownActivate as EventListener\n  );\n  element.addEventListener(\n    Events.MOUSE_DOUBLE_CLICK,\n    mouseDoubleClick as EventListener\n  );\n  element.addEventListener(Events.MOUSE_DRAG, mouseDrag as EventListener);\n  element.addEventListener(Events.MOUSE_MOVE, mouseMove as EventListener);\n  element.addEventListener(Events.MOUSE_UP, mouseUp as EventListener);\n  element.addEventListener(Events.MOUSE_WHEEL, mouseWheel as EventListener);\n};\n\n/**\n * Disable and Remove the MouseToolEventDispatcher handlers from the element.\n *\n * @param element - HTMLDivElement\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.MOUSE_CLICK, mouseClick as EventListener);\n  element.removeEventListener(Events.MOUSE_DOWN, mouseDown as EventListener);\n  element.removeEventListener(\n    Events.MOUSE_DOWN_ACTIVATE,\n    mouseDownActivate as EventListener\n  );\n  element.removeEventListener(\n    Events.MOUSE_DOUBLE_CLICK,\n    mouseDoubleClick as EventListener\n  );\n  element.removeEventListener(Events.MOUSE_DRAG, mouseDrag as EventListener);\n  element.removeEventListener(Events.MOUSE_MOVE, mouseMove as EventListener);\n  element.removeEventListener(Events.MOUSE_UP, mouseUp as EventListener);\n  element.removeEventListener(Events.MOUSE_WHEEL, mouseWheel as EventListener);\n};\n\nconst mouseToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default mouseToolEventDispatcher;\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { keyEventListener } from '../../eventListeners';\nimport { EventTypes } from '../../types';\nimport { getMouseButton } from '../../eventListeners/mouse/mouseDownListener';\n\nconst { Active } = ToolModes;\n\n/**\n * Iterate tool group tools until we find a tool that has a \"ToolBinding\"\n * that matches our Keyboard pressed keys. It's possible there will be no match\n * (no active tool for that mouse button combination).\n *\n * @param evt - The normalized keyboard event.\n *\n * @returns tool\n */\nexport default function getActiveToolForKeyboardEvent(\n  evt: EventTypes.KeyDownEventType\n) {\n  const { renderingEngineId, viewportId } = evt.detail;\n\n  // Get the current mouse button clicked\n  const mouseButton = getMouseButton();\n\n  // If any keyboard modifier key is also pressed\n  // TODO - get the real modifier key\n  const modifierKey = keyEventListener.getModifierKey();\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    if (toolOptions.mode !== Active) {\n      continue;\n    }\n    // tool has binding that matches the mouse button, if mouseEvent is undefined\n    // it uses the primary button\n    const correctBinding =\n      toolOptions.bindings.length &&\n      toolOptions.bindings.some(\n        (binding) =>\n          binding.mouseButton === (mouseButton ?? defaultMousePrimary) &&\n          binding.modifierKey === modifierKey\n      );\n\n    if (correctBinding) {\n      return toolGroup.getToolInstance(toolName);\n    }\n  }\n}\n","import { ToolGroupManager } from '../../store';\nimport getActiveToolForKeyboardEvent from '../shared/getActiveToolForKeyboardEvent';\nimport getToolsWithActionsForKeyboardEvent from '../shared/getToolsWithActionsForKeyboardEvents';\nimport { KeyDownEventType } from '../../types/EventTypes';\nimport ToolModes from '../../enums/ToolModes';\n\n/**\n * KeyDown event listener to handle viewport cursor icon changes\n *\n * @param evt - The KeyboardEvent\n */\nexport default function keyDown(evt: KeyDownEventType): void {\n  // get the active tool given the key and mouse button\n  const activeTool = getActiveToolForKeyboardEvent(evt);\n\n  if (activeTool) {\n    const { renderingEngineId, viewportId } = evt.detail;\n\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n      viewportId,\n      renderingEngineId\n    );\n\n    const toolName = activeTool.getToolName();\n    if (Object.keys(toolGroup.toolOptions).includes(toolName)) {\n      toolGroup.setViewportsCursorByToolName(toolName);\n    }\n  }\n\n  const activeToolsWithEventBinding = getToolsWithActionsForKeyboardEvent(evt, [\n    ToolModes.Active,\n  ]);\n\n  if (activeToolsWithEventBinding?.size) {\n    const { element } = evt.detail;\n    for (const [key, value] of [...activeToolsWithEventBinding.entries()]) {\n      // Calls the method that implements the action, which can be a string\n      // in which case it belongs to the tool instance, or a function\n      // Call it on the tool instance, with the element and configuration value\n      // so that the method can depend on the specific configuration in use.\n      const method =\n        typeof value.method === 'function' ? value.method : key[value.method];\n      method.call(key, element, value, evt);\n    }\n  }\n}\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\n\n/**\n * Given the normalized mouse event and a filter of modes,\n * find all the tools on the element that are in one of the specified modes.\n * If the evtButton is specified, only tools with a matching binding will be returned.\n * @param evt - The normalized mouseDown event.\n * @param modesFilter - An array of entries from the `ToolModes` enum.\n */\nexport default function getToolsWithModesForKeyboardEvent(\n  evt: EventTypes.KeyDownEventType,\n  toolModes: ToolModes[]\n) {\n  const toolsWithActions = new Map();\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return toolsWithActions;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n  const key = evt.detail.key;\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.getToolInstance(toolName);\n    const actionsConfig = tool.configuration?.actions;\n    if (!actionsConfig) {\n      continue;\n    }\n    const actions = Object.values(actionsConfig);\n\n    if (!actions?.length || !toolModes.includes(tool.mode)) {\n      continue;\n    }\n\n    const action = actions.find((action: any) =>\n      action.bindings.some((binding) => binding.key === key)\n    );\n\n    if (action) {\n      toolsWithActions.set(tool, action);\n    }\n  }\n\n  return toolsWithActions;\n}\n","import { resetModifierKey } from '../../eventListeners/keyboard/keyDownListener';\nimport { ToolGroupManager } from '../../store';\nimport getActiveToolForKeyboardEvent from '../shared/getActiveToolForKeyboardEvent';\nimport { KeyDownEventType } from '../../types/EventTypes';\n\n/**\n * KeyDown event listener to handle viewport cursor icon changes\n *\n * @param evt - The KeyboardEvent\n */\nexport default function keyUp(evt: KeyDownEventType): void {\n  // get the active tool for the primary mouse button\n  const activeTool = getActiveToolForKeyboardEvent(evt);\n\n  if (!activeTool) {\n    return;\n  }\n\n  const { renderingEngineId, viewportId } = evt.detail;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  // Reset the modifier key\n  resetModifierKey();\n\n  const toolName = activeTool.getToolName();\n  if (Object.keys(toolGroup.toolOptions).includes(toolName)) {\n    toolGroup.setViewportsCursorByToolName(toolName);\n  }\n}\n","import Events from '../enums/Events';\nimport { keyDown, keyUp } from './keyboardEventHandlers';\n\n/**\n * Enable Key down and key up listeners\n *\n * @param element - The HTML element to attach the event listeners to.\n */\nconst enable = function (element: HTMLDivElement) {\n  element.addEventListener(Events.KEY_DOWN, keyDown as EventListener);\n  element.addEventListener(Events.KEY_UP, keyUp as EventListener);\n};\n\n/**\n * Disable Key down and key up listeners\n * @param element - The HTML element to attach the event listeners to.\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.KEY_DOWN, keyDown as EventListener);\n  element.removeEventListener(Events.KEY_UP, keyUp as EventListener);\n};\n\nconst keyboardToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default keyboardToolEventDispatcher;\n","import { ToolGroupManager } from '../../store';\nimport { MouseBindings, ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\nimport getMouseModifier from './getMouseModifier';\nimport { keyEventListener } from '../../eventListeners';\n\nconst { Active } = ToolModes;\n\n/**\n * Iterate tool group tools until we find a tool that has a \"ToolBinding\"\n * that matches our TouchEvent's `buttons`. It's possible there will be no match\n * (no active tool for that touch button combination).\n *\n * @param evt - The event dispatcher touch event.\n *\n * @returns tool\n */\nexport default function getActiveToolForTouchEvent(\n  evt: EventTypes.NormalizedTouchEventType\n) {\n  // Todo: we should refactor this to use getToolsWithModesForTouchEvent instead\n  const { renderingEngineId, viewportId } = evt.detail;\n  const touchEvent = evt.detail.event;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  const numTouchPoints = Object.keys(touchEvent.touches).length;\n\n  // If any keyboard modifier key is also pressed\n  const modifierKey =\n    getMouseModifier(touchEvent) || keyEventListener.getModifierKey();\n  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    const correctBinding =\n      toolOptions.bindings.length &&\n      /**\n       * TODO: setActiveTool treats MouseBindings.Primary in a special way\n       * which is analgous to numTouchPoints === 1 as the primary interaction\n       * for touch based applications. The ToolGroup set active and get active\n       * logic should be updated to account for numTouchPoints === 1\n       */\n      toolOptions.bindings.some(\n        (binding) =>\n          (binding.numTouchPoints === numTouchPoints ||\n            (numTouchPoints === 1 &&\n              binding.mouseButton === defaultMousePrimary)) &&\n          binding.modifierKey === modifierKey\n      );\n\n    if (toolOptions.mode === Active && correctBinding) {\n      return toolGroup.getToolInstance(toolName);\n    }\n  }\n}\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\n\ntype ModesFilter = Array<ToolModes>;\n\n/**\n * Given the normalized touch event and a filter of modes,\n * find all the tools on the element that are in one of the specified modes.\n * If the evtButton is specified, only tools with a matching binding will be returned.\n * @param evt - The normalized touchStart event.\n * @param modesFilter - An array of entries from the `ToolModes` enum.\n */\nexport default function getToolsWithModesForTouchEvent(\n  evt: EventTypes.NormalizedTouchEventType,\n  modesFilter: ModesFilter,\n  numTouchPoints?: number\n) {\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return [];\n  }\n\n  const enabledTools = [];\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.toolOptions[toolName];\n\n    const correctBinding =\n      numTouchPoints != null &&\n      tool.bindings.length &&\n      tool.bindings.some(\n        (binding) => binding.numTouchPoints === numTouchPoints\n      );\n\n    if (\n      modesFilter.includes(tool.mode) &&\n      (!numTouchPoints || correctBinding)\n    ) {\n      const toolInstance = toolGroup.getToolInstance(toolName);\n      enabledTools.push(toolInstance);\n    }\n  }\n\n  return enabledTools;\n}\n","import { state } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\nimport {\n  ToolAnnotationPair,\n  ToolsWithMoveableHandles,\n} from '../../types/InternalToolTypes';\n\nimport {\n  setAnnotationSelected,\n  isAnnotationSelected,\n} from '../../stateManagement/annotation/annotationSelection';\n\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\n\n// Util\nimport filterToolsWithMoveableHandles from '../../store/filterToolsWithMoveableHandles';\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport filterMoveableAnnotationTools from '../../store/filterMoveableAnnotationTools';\nimport getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\nimport getToolsWithModesForTouchEvent from '../shared/getToolsWithModesForTouchEvent';\n\nconst { Active, Passive } = ToolModes;\n\n/**\n * touchStart - Event handler for touchStart events. Uses `customCallbackHandler` to fire\n * the `touchStartCallback` function on active tools.\n */\nexport default function touchStart(evt: EventTypes.TouchStartEventType) {\n  if (state.isInteractingWithTool) {\n    return;\n  }\n  const activeTool = getActiveToolForTouchEvent(evt);\n\n  // Check for preTouchStartCallbacks,\n  // If the tool claims it consumed the event, prevent further checks.\n  if (activeTool && typeof activeTool.preTouchStartCallback === 'function') {\n    const consumedEvent = activeTool.preTouchStartCallback(evt);\n\n    if (consumedEvent) {\n      return;\n    }\n  }\n\n  const isPrimaryClick = Object.keys(evt.detail.event.touches).length === 1;\n  const activeToolsWithEventBinding = getToolsWithModesForTouchEvent(\n    evt,\n    [Active],\n    Object.keys(evt.detail.event.touches).length\n  );\n  const passiveToolsIfEventWasPrimaryTouchButton = isPrimaryClick\n    ? getToolsWithModesForTouchEvent(evt, [Passive])\n    : undefined;\n  const applicableTools = [\n    ...(activeToolsWithEventBinding || []),\n    ...(passiveToolsIfEventWasPrimaryTouchButton || []),\n    activeTool,\n  ];\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Filter tools with annotations for this element\n  const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(\n    element,\n    applicableTools\n  );\n\n  const canvasCoords = eventDetail.currentPoints.canvas;\n\n  // For the canvas coordinates, find all tools that might respond to this touch start\n  // on their handles. This filter will call getHandleNearImagePoint for each tool\n  // instance (each annotation)\n  const annotationToolsWithMoveableHandles = filterToolsWithMoveableHandles(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'touch'\n  );\n\n  const isMultiSelect = false;\n\n  // If there are annotation tools whose handle is near the touch, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (annotationToolsWithMoveableHandles.length > 0) {\n    const { tool, annotation, handle } = getAnnotationForSelection(\n      annotationToolsWithMoveableHandles\n    ) as ToolsWithMoveableHandles;\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.handleSelectedCallback(evt, annotation, handle, 'Touch');\n\n    return;\n  }\n\n  // If there were no annotation tools whose handle was near the touch, try to check\n  // if any of the annotation tools are interactable (e.g. moving an entire length annotation)\n  const moveableAnnotationTools = filterMoveableAnnotationTools(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'touch'\n  );\n\n  // If there are annotation tools that are interactable, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (moveableAnnotationTools.length > 0) {\n    const { tool, annotation } = getAnnotationForSelection(\n      moveableAnnotationTools\n    );\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.toolSelectedCallback(evt, annotation, 'Touch');\n\n    return;\n  }\n\n  // Run the postTouchStartCallback for the active tool if it exists\n  if (activeTool && typeof activeTool.postTouchStartCallback === 'function') {\n    const consumedEvent = activeTool.postTouchStartCallback(evt);\n\n    if (consumedEvent) {\n      // If the tool claims it consumed the event, prevent further checks.\n      return;\n    }\n  }\n\n  // Don't stop propagation so that touchStartActivate can handle the event\n}\n\n/**\n * If there are multiple annotation tools, return the first one that isn't locked neither hidden.\n * If there's only one annotation tool, return it\n * @param annotationTools - An array of tools and annotation.\n * @returns The candidate for selection\n */\nfunction getAnnotationForSelection(\n  toolsWithMovableHandles: ToolAnnotationPair[]\n): ToolAnnotationPair {\n  return (\n    (toolsWithMovableHandles.length > 1 &&\n      toolsWithMovableHandles.find(\n        (item) =>\n          !isAnnotationLocked(item.annotation) &&\n          isAnnotationVisible(item.annotation.annotationUID)\n      )) ||\n    toolsWithMovableHandles[0]\n  );\n}\n\n/**\n * If the annotation is selected, deselect it. If it's not selected, select it\n * @param annotationUID - The AnnotationUID that we\n * want to toggle the selection of.\n * @param isMultiSelect - If true, the annotation. will be deselected if it is\n * already selected, or deselected if it is selected.\n */\nfunction toggleAnnotationSelection(\n  annotationUID: string,\n  isMultiSelect = false\n): void {\n  if (isMultiSelect) {\n    if (isAnnotationSelected(annotationUID)) {\n      setAnnotationSelected(annotationUID, false);\n    } else {\n      const preserveSelected = true;\n      setAnnotationSelected(annotationUID, true, preserveSelected);\n    }\n  } else {\n    const preserveSelected = false;\n    setAnnotationSelected(annotationUID, true, preserveSelected);\n  }\n}\n","import { state } from '../../store';\nimport { EventTypes } from '../../types';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\n\nimport getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\n\n/**\n * If the `touchStart` handler does not consume an event,\n * activate the creation loop of the active tool, if one is found for the\n * touch button pressed.\n *\n * @param evt - The normalized touchStart event.\n */\nexport default function touchStartActivate(\n  evt: EventTypes.TouchStartActivateEventType\n) {\n  // If a tool has locked the current state it is dealing with an interaction within its own eventLoop.\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForTouchEvent(evt);\n\n  if (!activeTool) {\n    return;\n  }\n\n  if (state.isMultiPartToolActive) {\n    return;\n  }\n\n  if (activeTool.addNewAnnotation) {\n    const annotation = activeTool.addNewAnnotation(evt, 'touch');\n    setAnnotationSelected(annotation.annotationUID);\n  }\n}\n","import getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\nimport { state } from '../../store';\nimport { TouchDragEventType } from '../../types/EventTypes';\n\n/**\n * touchDrag - Event handler for touchDrag events. Uses `customCallbackHandler` to fire\n * the `touchDragCallback` function on active tools.\n */\nexport default function touchDrag(evt: TouchDragEventType) {\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForTouchEvent(evt);\n\n  const noFoundToolOrDoesNotHaveTouchDragCallback =\n    !activeTool || typeof activeTool.touchDragCallback !== 'function';\n  if (noFoundToolOrDoesNotHaveTouchDragCallback) {\n    return;\n  }\n\n  activeTool.touchDragCallback(evt);\n}\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * touchEnd - Event handler for touchEnd events. Uses `customCallbackHandler` to fire\n * the `touchEndCallback` function on active tools.\n */\nconst touchEnd = customCallbackHandler.bind(null, 'Touch', 'touchEndCallback');\n\nexport default touchEnd;\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * touchTap - Event handler for touch tap events. Uses `customCallbackHandler` to fire\n * the `touchTapCallback` function on active tools.\n */\nconst touchTap = customCallbackHandler.bind(null, 'Touch', 'touchTapCallback');\n\nexport default touchTap;\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * touchPress - Event handler for touch press events. Uses `customCallbackHandler` to fire\n * the `touchPressCallback` function on active tools.\n */\nconst touchPress = customCallbackHandler.bind(\n  null,\n  'Touch',\n  'touchPressCallback'\n);\n\nexport default touchPress;\n","import Events from '../enums/Events';\n\nimport {\n  touchStart,\n  touchStartActivate,\n  touchDrag,\n  touchEnd,\n  touchTap,\n  touchPress,\n} from './touchEventHandlers';\n\n/**\n * Enable these listeners are emitted in order, and can be cancelled/prevented from bubbling\n * by any previous event.\n *\n * @param element - The element to add the event listeners to.\n */\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(Events.TOUCH_START, touchStart as EventListener);\n  element.addEventListener(\n    Events.TOUCH_START_ACTIVATE,\n    touchStartActivate as EventListener\n  );\n  element.addEventListener(Events.TOUCH_DRAG, touchDrag as EventListener);\n  element.addEventListener(Events.TOUCH_END, touchEnd as EventListener);\n  element.addEventListener(Events.TOUCH_TAP, touchTap as EventListener);\n  element.addEventListener(Events.TOUCH_PRESS, touchPress as EventListener);\n};\n\n/**\n * Disable and Remove the MouseToolEventDispatcher handlers from the element.\n *\n * @param element - HTMLDivElement\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.TOUCH_START, touchStart as EventListener);\n  element.removeEventListener(\n    Events.TOUCH_START_ACTIVATE,\n    touchStartActivate as EventListener\n  );\n  element.removeEventListener(Events.TOUCH_DRAG, touchDrag as EventListener);\n  element.removeEventListener(Events.TOUCH_END, touchEnd as EventListener);\n  element.removeEventListener(Events.TOUCH_PRESS, touchPress as EventListener);\n};\n\nconst touchToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default touchToolEventDispatcher;\n","import { Types } from '@cornerstonejs/core';\nimport {\n  mouseEventListeners,\n  wheelEventListener,\n  touchEventListeners,\n  keyEventListener,\n  imageChangeEventListener,\n} from '../eventListeners';\nimport {\n  imageRenderedEventDispatcher,\n  cameraModifiedEventDispatcher,\n  mouseToolEventDispatcher,\n  touchToolEventDispatcher,\n  keyboardToolEventDispatcher,\n  imageSpacingCalibratedEventDispatcher,\n} from '../eventDispatchers';\nimport { state } from './state';\n\nimport { annotationRenderingEngine } from '../utilities/triggerAnnotationRender';\n\n/**\n * When an element is \"enabled\", add event listeners and dispatchers to it\n * so we can use interactions to affect tool behaviors\n *\n * @param evt - The ELEMENT_ENABLED event\n */\nexport default function addEnabledElement(\n  evt: Types.EventTypes.ElementEnabledEvent\n): void {\n  const { element, viewportId } = evt.detail;\n  const svgLayer = _createSvgAnnotationLayer(viewportId);\n\n  // Reset/Create svgNodeCache for element\n  _setSvgNodeCache(element);\n  _appendChild(svgLayer, element);\n\n  // Add this element to the annotation rendering engine\n  annotationRenderingEngine.addViewportElement(viewportId, element);\n\n  // Listeners\n  mouseEventListeners.enable(element);\n  wheelEventListener.enable(element);\n  touchEventListeners.enable(element);\n  keyEventListener.enable(element);\n  imageChangeEventListener.enable(element);\n\n  // Dispatchers: renderer\n  imageRenderedEventDispatcher.enable(element);\n  cameraModifiedEventDispatcher.enable(element);\n  imageSpacingCalibratedEventDispatcher.enable(element);\n  // Dispatchers: interaction\n  mouseToolEventDispatcher.enable(element);\n  keyboardToolEventDispatcher.enable(element);\n  touchToolEventDispatcher.enable(element);\n\n  // labelmap\n  // State\n  state.enabledElements.push(element);\n}\n\n/**\n *\n */\nfunction _createSvgAnnotationLayer(viewportId: string): SVGElement {\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgLayer = document.createElementNS(svgns, 'svg');\n\n  const svgLayerId = `svg-layer-${viewportId}`;\n  svgLayer.classList.add('svg-layer');\n  svgLayer.setAttribute('id', svgLayerId);\n  svgLayer.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n  svgLayer.style.width = '100%';\n  svgLayer.style.height = '100%';\n  svgLayer.style.pointerEvents = 'none';\n  svgLayer.style.position = 'absolute';\n  // TODO: we should test this on high-res monitors\n  //svgLayer.style.textRendering = 'optimizeSpeed'\n\n  // Single dropshadow config for now\n  const defs = document.createElementNS(svgns, 'defs');\n  const filter = document.createElementNS(svgns, 'filter');\n  const feOffset = document.createElementNS(svgns, 'feOffset');\n  const feColorMatrix = document.createElementNS(svgns, 'feColorMatrix');\n  const feBlend = document.createElementNS(svgns, 'feBlend');\n\n  //\n  filter.setAttribute('id', `shadow-${svgLayerId}`);\n  filter.setAttribute('filterUnits', 'userSpaceOnUse');\n\n  //\n  feOffset.setAttribute('result', 'offOut');\n  feOffset.setAttribute('in', 'SourceGraphic');\n  feOffset.setAttribute('dx', '0.5');\n  feOffset.setAttribute('dy', '0.5');\n\n  //\n  feColorMatrix.setAttribute('result', 'matrixOut');\n  feColorMatrix.setAttribute('in', 'offOut');\n  feColorMatrix.setAttribute('in2', 'matrix');\n  feColorMatrix.setAttribute(\n    'values',\n    '0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0'\n  );\n\n  //\n  feBlend.setAttribute('in', 'SourceGraphic');\n  feBlend.setAttribute('in2', 'matrixOut');\n  feBlend.setAttribute('mode', 'normal');\n\n  filter.appendChild(feOffset);\n  filter.appendChild(feColorMatrix);\n  filter.appendChild(feBlend);\n  defs.appendChild(filter);\n  svgLayer.appendChild(defs);\n\n  return svgLayer;\n}\n\nfunction _setSvgNodeCache(element) {\n  const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } =\n    element.dataset;\n  const elementHash = `${viewportId}:${renderingEngineId}`;\n\n  // Create or reset\n  // TODO: If... Reset, we should blow out any nodes in DOM\n  state.svgNodeCache[elementHash] = {};\n}\n\n/**\n *\n * @param newNode\n * @param referenceNode\n */\nfunction _appendChild(\n  newNode: SVGElement,\n  referenceNode: HTMLDivElement\n): void {\n  referenceNode.querySelector('div.viewport-element').appendChild(newNode);\n}\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * It returns all synchronizers that are not disabled and have a source viewport\n * with the given rendering engine Id and viewport Id\n * @param renderingEngineId - The Id of the rendering engine\n * @param viewportId - The Id of the viewport\n * @returns An array of synchronizers\n */\nfunction getSynchronizersForViewport(\n  viewportId: string,\n  renderingEngineId: string\n): Array<Synchronizer> {\n  const synchronizersFilteredByIds = [];\n\n  if (!renderingEngineId && !viewportId) {\n    throw new Error(\n      'At least one of renderingEngineId or viewportId should be given'\n    );\n  }\n\n  for (let i = 0; i < state.synchronizers.length; i++) {\n    const synchronizer = state.synchronizers[i];\n    const notDisabled = !synchronizer.isDisabled();\n    const hasSourceViewport = synchronizer.hasSourceViewport(\n      renderingEngineId,\n      viewportId\n    );\n\n    const hasTargetViewport = synchronizer.hasTargetViewport(\n      renderingEngineId,\n      viewportId\n    );\n\n    if (notDisabled && (hasSourceViewport || hasTargetViewport)) {\n      synchronizersFilteredByIds.push(synchronizer);\n    }\n  }\n\n  return synchronizersFilteredByIds;\n}\n\nexport default getSynchronizersForViewport;\n","import { getEnabledElement, Types } from '@cornerstonejs/core';\nimport {\n  mouseEventListeners,\n  wheelEventListener,\n  touchEventListeners,\n  keyEventListener,\n  imageChangeEventListener,\n} from '../eventListeners';\nimport {\n  imageRenderedEventDispatcher,\n  cameraModifiedEventDispatcher,\n  mouseToolEventDispatcher,\n  keyboardToolEventDispatcher,\n  imageSpacingCalibratedEventDispatcher,\n  touchToolEventDispatcher,\n} from '../eventDispatchers';\n// ~~\n\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\nimport { state } from './state';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport { ToolModes } from '../enums';\nimport { removeAnnotation } from '../stateManagement';\nimport getSynchronizersForViewport from './SynchronizerManager/getSynchronizersForViewport';\nimport getToolGroupForViewport from './ToolGroupManager/getToolGroupForViewport';\nimport { annotationRenderingEngine } from '../utilities/triggerAnnotationRender';\n\nconst VIEWPORT_ELEMENT = 'viewport-element';\n\nfunction removeEnabledElement(\n  elementDisabledEvt: Types.EventTypes.ElementDisabledEvent\n): void {\n  // Is DOM element\n  const { element, viewportId } = elementDisabledEvt.detail;\n\n  _resetSvgNodeCache(element);\n  _removeSvgNode(element);\n\n  // Remove this element from the annotation rendering engine\n  annotationRenderingEngine.removeViewportElement(viewportId, element);\n\n  // Listeners\n  mouseEventListeners.disable(element);\n  wheelEventListener.disable(element);\n  touchEventListeners.disable(element);\n  keyEventListener.disable(element);\n\n  // labelmap\n  imageChangeEventListener.disable(element);\n\n  // Dispatchers: renderer\n  imageRenderedEventDispatcher.disable(element);\n  cameraModifiedEventDispatcher.disable(element);\n  imageSpacingCalibratedEventDispatcher.disable(element);\n\n  // Dispatchers: interaction\n  mouseToolEventDispatcher.disable(element);\n  keyboardToolEventDispatcher.disable(element);\n  touchToolEventDispatcher.disable(element);\n\n  // State\n  // @TODO: We used to \"disable\" the tool before removal. Should we preserve the hook that would call on tools?\n  _removeViewportFromSynchronizers(element);\n  _removeViewportFromToolGroup(element);\n\n  // _removeAllToolsForElement(canvas)\n  _removeEnabledElement(element);\n}\n\nconst _removeViewportFromSynchronizers = (element: HTMLDivElement) => {\n  const enabledElement = getEnabledElement(element);\n\n  const synchronizers = getSynchronizersForViewport(\n    enabledElement.viewportId,\n    enabledElement.renderingEngineId\n  );\n  synchronizers.forEach((sync) => {\n    sync.remove(enabledElement);\n  });\n};\n\nconst _removeViewportFromToolGroup = (element: HTMLDivElement) => {\n  const { renderingEngineId, viewportId } = getEnabledElement(element);\n\n  const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n\n  if (toolGroup) {\n    toolGroup.removeViewports(renderingEngineId, viewportId);\n  }\n};\n\nconst _removeAllToolsForElement = function (element) {\n  const tools = getToolsWithModesForElement(element, [\n    ToolModes.Active,\n    ToolModes.Passive,\n  ]);\n\n  const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n  toolsWithData.forEach(({ annotations }) => {\n    annotations.forEach((annotation) => {\n      removeAnnotation(annotation.annotationUID);\n    });\n  });\n};\n\nfunction _resetSvgNodeCache(element: HTMLDivElement) {\n  const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } =\n    element.dataset;\n  const elementHash = `${viewportId}:${renderingEngineId}`;\n\n  delete state.svgNodeCache[elementHash];\n}\n\nfunction _removeSvgNode(element: HTMLDivElement) {\n  const internalViewportNode = element.querySelector(`div.${VIEWPORT_ELEMENT}`);\n  const svgLayer = internalViewportNode.querySelector('svg');\n  if (svgLayer) {\n    internalViewportNode.removeChild(svgLayer);\n  }\n}\n\n/**\n * @private\n * @param enabledElement\n */\nconst _removeEnabledElement = function (element: HTMLDivElement) {\n  const foundElementIndex = state.enabledElements.findIndex(\n    (el) => el === element\n  );\n\n  if (foundElementIndex > -1) {\n    state.enabledElements.splice(foundElementIndex, 1);\n  }\n};\n\nexport default removeEnabledElement;\n","import { AnnotationCompletedEventType } from '../../types/EventTypes';\nimport * as contourSegUtils from '../../utilities/contourSegmentation';\nimport { contourSegmentationCompleted } from './contourSegmentation';\n\nexport default function annotationCompletedListener(\n  evt: AnnotationCompletedEventType\n) {\n  const annotation = evt.detail.annotation;\n\n  if (contourSegUtils.isContourSegmentationAnnotation(annotation)) {\n    contourSegmentationCompleted(evt);\n  }\n}\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\n/**\n * This is a callback function that is called when an annotation is modified.\n * Since we are throttling the cachedStats calculation for annotation tools,\n * we need to trigger a final render for the annotation. so that the annotation\n * textBox is updated.\n * Todo: This will trigger all the annotation tools to re-render, although DOM\n * will update those that have changed, but more efficient would be to only\n * update the changed annotation.\n * Todo: A better way is to extract the textBox render logic from the renderAnnotation\n * of all tools and just trigger a render for that (instead of the entire annotation., even if\n * no svg update happens since the attributes for handles are the same)\n */\nfunction annotationModifiedListener(evt): void {\n  const { viewportId, renderingEngineId } = evt.detail;\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n  triggerAnnotationRenderForViewportIds(renderingEngine, [viewportId]);\n}\n\nexport default annotationModifiedListener;\n","import { getRenderingEngines } from '@cornerstonejs/core';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\n\n/**\n * When an annotation is deselected, trigger an annotation render for all viewports.\n * The reason for this is that, drawing an annotation in a different viewport\n * should deselect all other annotations in other viewports. In order to achieve\n * this, we need to trigger an annotation render for all viewports.\n * Todo: Although this is inefficient, but since annotations are only rendered if necessary,\n * it's probably not going to have a noticeable impact on performance.\n * @param evt - The event object.\n */\nfunction annotationSelectionListener(evt): void {\n  const deselectedAnnotation = evt.detail.removed;\n\n  if (!deselectedAnnotation.length) {\n    return;\n  }\n\n  const renderingEngines = getRenderingEngines();\n\n  renderingEngines.forEach((renderingEngine) => {\n    const viewports = renderingEngine.getViewports();\n    const viewportIds = viewports.map((vp) => vp.id);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n  });\n}\n\nexport default annotationSelectionListener;\n","import { AnnotationRemovedEventType } from '../../types/EventTypes';\nimport * as contourSegUtils from '../../utilities/contourSegmentation';\nimport { contourSegmentationRemoved } from './contourSegmentation';\n\nexport default function annotationRemovedListener(\n  evt: AnnotationRemovedEventType\n) {\n  const annotation = evt.detail.annotation;\n\n  if (contourSegUtils.isContourSegmentationAnnotation(annotation)) {\n    contourSegmentationRemoved(evt);\n  }\n}\n","import type { AnnotationRemovedEventType } from '../../../types/EventTypes';\nimport type { ContourSegmentationAnnotation } from '../../../types/ContourSegmentationAnnotation';\nimport { removeContourSegmentationAnnotation } from '../../../utilities/contourSegmentation';\n\nexport default function contourSegmentationRemovedListener(\n  evt: AnnotationRemovedEventType\n) {\n  const annotation = evt.detail.annotation as ContourSegmentationAnnotation;\n\n  removeContourSegmentationAnnotation(annotation);\n}\n","import { SegmentationModifiedEventType } from '../../types/EventTypes';\nimport {\n  getToolGroupIdsWithSegmentation,\n  getSegmentationRepresentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationRepresentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\n\n/** A function that listens to the `segmentationModified` event and triggers\n * the triggerSegmentationRepresentationModified on each toolGroup that\n * has a representation of the given segmentationId.\n */\nconst segmentationModifiedListener = function (\n  evt: SegmentationModifiedEventType\n): void {\n  const { segmentationId } = evt.detail;\n\n  const toolGroupIds = getToolGroupIdsWithSegmentation(segmentationId);\n\n  toolGroupIds.forEach((toolGroupId) => {\n    const segRepresentations = getSegmentationRepresentations(toolGroupId);\n    segRepresentations.forEach((representation) => {\n      if (representation.segmentationId === segmentationId) {\n        triggerSegmentationRepresentationModified(\n          toolGroupId,\n          representation.segmentationRepresentationUID\n        );\n      }\n    });\n  });\n};\n\nexport default segmentationModifiedListener;\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../stateManagement/segmentation/segmentationState';\nimport { SegmentationDataModifiedEventType } from '../../types/EventTypes';\nimport onLabelmapSegmentationDataModified from './labelmap/onLabelmapSegmentationDataModified';\n\n/** A callback function that is called when the segmentation data is modified which\n *  often is as a result of tool interactions e.g., scissors, eraser, etc.\n */\nconst onSegmentationDataModified = function (\n  evt: SegmentationDataModifiedEventType\n): void {\n  const { segmentationId } = evt.detail;\n  const { type } = SegmentationState.getSegmentation(segmentationId);\n\n  const toolGroupIds =\n    SegmentationState.getToolGroupIdsWithSegmentation(segmentationId);\n\n  if (type === SegmentationRepresentations.Labelmap) {\n    onLabelmapSegmentationDataModified(evt);\n  }\n\n  toolGroupIds.forEach((toolGroupId) => {\n    triggerSegmentationRender(toolGroupId);\n  });\n};\n\nexport default onSegmentationDataModified;\n","import {\n  cache,\n  getEnabledElementByIds,\n  utilities as csUtils,\n  VolumeViewport,\n} from '@cornerstonejs/core';\n\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { SegmentationDataModifiedEventType } from '../../../types/EventTypes';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../../types/LabelmapTypes';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\n\n/** A callback function that is called when the segmentation data is modified which\n *  often is as a result of tool interactions e.g., scissors, eraser, etc.\n */\nconst onLabelmapSegmentationDataModified = function (\n  evt: SegmentationDataModifiedEventType\n): void {\n  const { segmentationId, modifiedSlicesToUse } = evt.detail;\n\n  const { representationData, type } =\n    SegmentationState.getSegmentation(segmentationId);\n\n  const toolGroupIds =\n    SegmentationState.getToolGroupIdsWithSegmentation(segmentationId);\n\n  const labelmapRepresentationData = representationData[type];\n\n  if ('volumeId' in labelmapRepresentationData) {\n    // get the volume from cache, we need the openGLTexture to be updated to GPU\n    performVolumeLabelmapUpdate({\n      modifiedSlicesToUse,\n      representationData,\n      type,\n    });\n  }\n\n  if ('imageIdReferenceMap' in labelmapRepresentationData) {\n    // get the stack from cache, we need the imageData to be updated to GPU\n    performStackLabelmapUpdate({\n      toolGroupIds,\n      segmentationId,\n      representationData,\n      type,\n    });\n  }\n};\n\nfunction performVolumeLabelmapUpdate({\n  modifiedSlicesToUse,\n  representationData,\n  type,\n}) {\n  const segmentationVolume = cache.getVolume(\n    (representationData[type] as LabelmapSegmentationDataVolume).volumeId\n  );\n\n  if (!segmentationVolume) {\n    console.warn('segmentation not found in cache');\n    return;\n  }\n\n  const { imageData, vtkOpenGLTexture } = segmentationVolume;\n\n  // Update the texture for the volume in the GPU\n  let slicesToUpdate;\n  if (modifiedSlicesToUse && Array.isArray(modifiedSlicesToUse)) {\n    slicesToUpdate = modifiedSlicesToUse;\n  } else {\n    const numSlices = imageData.getDimensions()[2];\n    slicesToUpdate = [...Array(numSlices).keys()];\n  }\n\n  slicesToUpdate.forEach((i) => {\n    vtkOpenGLTexture.setUpdatedFrame(i);\n  });\n\n  // Trigger modified on the imageData to update the image\n  imageData.modified();\n}\n\nfunction performStackLabelmapUpdate({\n  toolGroupIds,\n  segmentationId,\n  representationData,\n  type,\n}) {\n  toolGroupIds.forEach((toolGroupId) => {\n    const toolGroupSegmentationRepresentations =\n      SegmentationState.getSegmentationRepresentations(toolGroupId);\n\n    const toolGroup = getToolGroup(toolGroupId);\n    const viewportsInfo = toolGroup.getViewportsInfo();\n\n    toolGroupSegmentationRepresentations.forEach((representation) => {\n      if (representation.segmentationId !== segmentationId) {\n        return;\n      }\n\n      viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n        const viewport = getEnabledElementByIds(\n          viewportId,\n          renderingEngineId\n        ).viewport;\n\n        if (viewport instanceof VolumeViewport) {\n          return;\n        }\n\n        const actorEntry = viewport.getActor(\n          representation.segmentationRepresentationUID\n        );\n\n        if (!actorEntry) {\n          return;\n        }\n\n        const currentImageId = viewport.getCurrentImageId();\n\n        const segImageData = actorEntry.actor.getMapper().getInputData();\n\n        const { imageIdReferenceMap } = representationData[\n          type\n        ] as LabelmapSegmentationDataStack;\n\n        const currentSegmentationImageId =\n          imageIdReferenceMap.get(currentImageId);\n\n        const segmentationImage = cache.getImage(currentSegmentationImageId);\n        segImageData.modified();\n\n        // update the cache with the new image data\n        csUtils.updateVTKImageDataWithCornerstoneImage(\n          segImageData,\n          segmentationImage\n        );\n      });\n    });\n  });\n}\n\nexport default onLabelmapSegmentationDataModified;\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport { SegmentationRepresentationModifiedEventType } from '../../types/EventTypes';\n\n/** A function that listens to the `segmentationStateModified` event and triggers\n * the `triggerSegmentationRender` function. This function is called when the\n * segmentation state or config is modified.\n */\nconst segmentationRepresentationModifiedListener = function (\n  evt: SegmentationRepresentationModifiedEventType\n): void {\n  const { toolGroupId } = evt.detail;\n  triggerSegmentationRender(toolGroupId);\n};\n\nexport default segmentationRepresentationModifiedListener;\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport { SegmentationRepresentationRemovedEventType } from '../../types/EventTypes';\n\n/** A function that listens to the `segmentationRepresentationRemoved` event and triggers\n * the `triggerSegmentationRender` function. This function is called when the\n * segmentation state or config is modified.\n */\nconst segmentationRepresentationRemovedEventListener = function (\n  evt: SegmentationRepresentationRemovedEventType\n): void {\n  const { toolGroupId, segmentationRepresentationUID } = evt.detail;\n\n  triggerSegmentationRender(toolGroupId);\n};\n\nexport default segmentationRepresentationRemovedEventListener;\n","import { eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport InterpolationManager from '../utilities/segmentation/InterpolationManager/InterpolationManager';\n\n/**\n * The enable and disable add/remove the event listeners that dispatch the\n * required events to the interpolation manager.\n */\nconst enable = function () {\n  eventTarget.addEventListener(\n    Events.ANNOTATION_COMPLETED,\n    InterpolationManager.handleAnnotationCompleted as EventListener\n  );\n  eventTarget.addEventListener(\n    Events.ANNOTATION_MODIFIED,\n    InterpolationManager.handleAnnotationUpdate as EventListener\n  );\n  eventTarget.addEventListener(\n    Events.ANNOTATION_REMOVED,\n    InterpolationManager.handleAnnotationDelete as EventListener\n  );\n};\n\nconst disable = function () {\n  eventTarget.removeEventListener(\n    Events.ANNOTATION_COMPLETED,\n    InterpolationManager.handleAnnotationCompleted as EventListener\n  );\n  eventTarget.removeEventListener(\n    Events.ANNOTATION_MODIFIED,\n    InterpolationManager.handleAnnotationUpdate as EventListener\n  );\n  eventTarget.removeEventListener(\n    Events.ANNOTATION_REMOVED,\n    InterpolationManager.handleAnnotationDelete as EventListener\n  );\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { labelmapDisplay } from '../../tools/displayTools/Labelmap';\nimport { contourDisplay } from '../../tools/displayTools/Contour';\n\nimport {\n  getSegmentationRepresentations,\n  getSegmentationRepresentationByUID,\n} from './segmentationState';\n\n/**\n * Remove the segmentation representation (representation) from the viewports of the toolGroup.\n * @param toolGroupId - The Id of the toolGroup to remove the segmentation from.\n * @param segmentationRepresentationUIDs - The UIDs of the segmentation representations to remove.\n * @param immediate - if True the viewport will be re-rendered immediately.\n */\nfunction removeSegmentationsFromToolGroup(\n  toolGroupId: string,\n  segmentationRepresentationUIDs?: string[] | undefined,\n  immediate?: boolean\n): void {\n  const toolGroupSegRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  if (\n    !toolGroupSegRepresentations ||\n    toolGroupSegRepresentations.length === 0\n  ) {\n    return;\n  }\n\n  const toolGroupSegRepresentationUIDs = toolGroupSegRepresentations.map(\n    (representation) => representation.segmentationRepresentationUID\n  );\n\n  let segRepresentationUIDsToRemove = segmentationRepresentationUIDs;\n  if (segRepresentationUIDsToRemove) {\n    // make sure the segmentationDataUIDs that are going to be removed belong\n    // to the toolGroup\n    const invalidSegRepresentationUIDs = segmentationRepresentationUIDs.filter(\n      (segRepresentationUID) =>\n        !toolGroupSegRepresentationUIDs.includes(segRepresentationUID)\n    );\n\n    if (invalidSegRepresentationUIDs.length > 0) {\n      throw new Error(\n        `The following segmentationRepresentationUIDs are not part of the toolGroup: ${JSON.stringify(\n          invalidSegRepresentationUIDs\n        )}`\n      );\n    }\n  } else {\n    // remove all segmentation representations\n    segRepresentationUIDsToRemove = toolGroupSegRepresentationUIDs;\n  }\n\n  segRepresentationUIDsToRemove.forEach((segmentationDataUID) => {\n    _removeSegmentation(toolGroupId, segmentationDataUID, immediate);\n  });\n}\n\nfunction _removeSegmentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  immediate?: boolean\n): void {\n  const segmentationRepresentation = getSegmentationRepresentationByUID(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  const { type } = segmentationRepresentation;\n\n  if (type === SegmentationRepresentations.Labelmap) {\n    labelmapDisplay.removeSegmentationRepresentation(\n      toolGroupId,\n      segmentationRepresentationUID,\n      immediate\n    );\n  } else if (type === SegmentationRepresentations.Contour) {\n    contourDisplay.removeSegmentationRepresentation(\n      toolGroupId,\n      segmentationRepresentationUID,\n      immediate\n    );\n  } else {\n    throw new Error(`The representation ${type} is not supported yet`);\n  }\n}\n\nexport default removeSegmentationsFromToolGroup;\n","import { state } from '../index';\nimport { removeSegmentationsFromToolGroup } from '../../stateManagement/segmentation';\nimport { segmentationRenderingEngine } from '../../utilities/segmentation/triggerSegmentationRender';\n// ToolGroups function entirely by their \"state\" being queried and leveraged\n// removing a ToolGroup from state is equivalent to killing it\n\n/**\n * Given a tool group Id, destroy the toolGroup. It will also cleanup all segmentations\n * associated with that tool group too\n *\n * @param toolGroupId - The Id of the tool group to be destroyed.\n */\nfunction destroyToolGroup(toolGroupId: string): void {\n  const toolGroupIndex = state.toolGroups.findIndex(\n    (tg) => tg.id === toolGroupId\n  );\n\n  if (toolGroupIndex > -1) {\n    segmentationRenderingEngine.removeToolGroup(toolGroupId);\n    // Todo: this should not happen here)\n    removeSegmentationsFromToolGroup(toolGroupId);\n    state.toolGroups.splice(toolGroupIndex, 1);\n  }\n}\n\nexport default destroyToolGroup;\n","// `BaseManager` or IManager interface for duplicate API between ToolGroup/Synchronizer?\nimport { state as csToolsState } from '../index';\nimport destroyToolGroup from './destroyToolGroup';\n\n// ToolGroups function entirely by their \"state\" being queried and leveraged\n// removing a ToolGroup from state is equivalent to killing it. Calling\n// destroyToolGroup() to make sure the SegmentationDisplayTools\n// have been removed from the toolGroup Viewports. //Todo: this makes more sense\n// to be based on events, but we don't have any toolGroup created/removed events\n\n/**\n * Destroy all tool groups\n */\nfunction destroy(): void {\n  const toolGroups = [...csToolsState.toolGroups];\n\n  for (const toolGroup of toolGroups) {\n    destroyToolGroup(toolGroup.id);\n  }\n\n  csToolsState.toolGroups = [];\n}\n\nexport default destroy;\n","import { eventTarget, Enums } from '@cornerstonejs/core';\nimport { getAnnotationManager } from './stateManagement/annotation/annotationState';\nimport { getDefaultSegmentationStateManager } from './stateManagement/segmentation/segmentationState';\nimport { Events as TOOLS_EVENTS } from './enums';\nimport { addEnabledElement, removeEnabledElement } from './store';\nimport { resetCornerstoneToolsState } from './store/state';\nimport {\n  annotationCompletedListener,\n  annotationRemovedListener,\n  annotationSelectionListener,\n  annotationModifiedListener,\n  segmentationDataModifiedEventListener,\n  segmentationRepresentationModifiedEventListener,\n  segmentationRepresentationRemovedEventListener,\n  segmentationModifiedListener,\n} from './eventListeners';\nimport { annotationInterpolationEventDispatcher } from './eventDispatchers';\n\nimport * as ToolGroupManager from './store/ToolGroupManager';\n\nlet csToolsInitialized = false;\n\n/**\n * Initialize the cornerstoneTools package. It will add event listeners for mouse\n * and keyboard events.\n * @param defaultConfiguration - A configuration object that will be used to\n * initialize the tool.\n */\nexport function init(defaultConfiguration = {}): void {\n  if (csToolsInitialized) {\n    return;\n  }\n\n  _addCornerstoneEventListeners();\n  _addCornerstoneToolsEventListeners();\n\n  csToolsInitialized = true;\n}\n\n/**\n * It destroys and cleanup state for cornerstone3DTools. It removes all the tools\n * that were added to the tool groups and restore states. It also removes all\n * event listeners.\n */\nexport function destroy(): void {\n  _removeCornerstoneEventListeners();\n  _removeCornerstoneToolsEventListeners();\n\n  // Important: destroy ToolGroups first, in order for cleanup to work correctly for the\n  // added tools.\n  ToolGroupManager.destroy();\n\n  // Remove all tools\n  resetCornerstoneToolsState();\n\n  // remove all annotation.\n  const annotationManager = getAnnotationManager();\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  annotationManager.restoreAnnotations({});\n  segmentationStateManager.resetState();\n  csToolsInitialized = false;\n}\n\n/**\n * Wires up event listeners for the Cornerstone#ElementDisabled and\n * Cornerstone#ElementEnabled events.\n *\n * @internal\n */\nfunction _addCornerstoneEventListeners(): void {\n  // Clear any listeners that may already be set\n  _removeCornerstoneEventListeners();\n\n  const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n  const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n\n  eventTarget.addEventListener(elementEnabledEvent, addEnabledElement);\n  eventTarget.addEventListener(elementDisabledEvent, removeEnabledElement);\n  annotationInterpolationEventDispatcher.enable();\n}\n\n/**\n * Removes event listeners for the Cornerstone#ElementDisabled and\n * Cornerstone#ElementEnabled events.\n *\n */\nfunction _removeCornerstoneEventListeners(): void {\n  const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n  const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n\n  eventTarget.removeEventListener(elementEnabledEvent, addEnabledElement);\n  eventTarget.removeEventListener(elementDisabledEvent, removeEnabledElement);\n  annotationInterpolationEventDispatcher.disable();\n}\n\n/**\n * It adds an event listener to the event target (the cornerstoneTools object) for\n * the annotation selected and annotation modified events.\n */\nfunction _addCornerstoneToolsEventListeners() {\n  // Clear any listeners that may already be set\n  _removeCornerstoneToolsEventListeners();\n\n  /**\n   * Annotation\n   */\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_COMPLETED,\n    annotationCompletedListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_MODIFIED,\n    annotationModifiedListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_REMOVED,\n    annotationRemovedListener\n  );\n\n  /**\n   * Segmentation\n   */\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_MODIFIED,\n    segmentationModifiedListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED,\n    segmentationDataModifiedEventListener\n  );\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED,\n    segmentationRepresentationModifiedEventListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_REMOVED,\n    segmentationRepresentationRemovedEventListener\n  );\n}\n\n/**\n * Remove the event listener for the the annotation selected and annotation modified events.\n */\nfunction _removeCornerstoneToolsEventListeners() {\n  /**\n   * Annotation\n   */\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_COMPLETED,\n    annotationCompletedListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_MODIFIED,\n    annotationModifiedListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  /**\n   * Segmentation\n   */\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_MODIFIED,\n    segmentationModifiedListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED,\n    segmentationDataModifiedEventListener\n  );\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED,\n    segmentationRepresentationModifiedEventListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_REMOVED,\n    segmentationRepresentationRemovedEventListener\n  );\n}\n\nexport default init;\n","import { ToolModes } from '../enums';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\n\n/**\n * Cancel the current active manipulation that is being performed on the provided\n * element. It filters all the active and passive tools for the enabledElement\n * and calls cancel() method for all of them, and returns the tool that has executed its\n * cancellation (returned its annotationUID), since tools that are not being manipulated will\n * short circuit early. Note: not all tools currently implement a cancel method.\n *\n * @param element - canvas element\n * @returns annotationUID that is cancelled\n */\nexport default function cancelActiveManipulations(\n  element: HTMLDivElement\n): string | undefined {\n  const tools = getToolsWithModesForElement(element, [\n    ToolModes.Active,\n    ToolModes.Passive,\n  ]);\n\n  const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n  for (const { tool } of toolsWithData) {\n    const annotationUID = tool.cancel(element);\n    if (annotationUID) {\n      return annotationUID;\n    }\n  }\n}\n","import {\n  getRenderingEngine,\n  getEnabledElement,\n  Enums,\n  Types,\n} from '@cornerstonejs/core';\n\nimport { ISynchronizerEventHandler } from '../../types';\n\n/**\n * Synchronizer is a class that listens to a specific event on a specific source\n * targets and fires a specific event on a specific target elements. Use cases\n * include: synchronizing a camera between two viewports, synchronizing a\n * windowLevel between various viewports.\n */\nclass Synchronizer {\n  //\n  private _enabled: boolean;\n  private _eventName: string;\n  private _auxiliaryEventNames: string[];\n  private _eventHandler: ISynchronizerEventHandler;\n  private _ignoreFiredEvents: boolean;\n  private _sourceViewports: Array<Types.IViewportId>;\n  private _targetViewports: Array<Types.IViewportId>;\n  private _viewportOptions: Record<string, Record<string, unknown>> = {};\n  private _options: any;\n  public id: string;\n\n  constructor(\n    synchronizerId: string,\n    eventName: string,\n    eventHandler: ISynchronizerEventHandler,\n    options?: any\n  ) {\n    this._enabled = true;\n    this._eventName = eventName;\n    this._eventHandler = eventHandler;\n    this._ignoreFiredEvents = false;\n    this._sourceViewports = [];\n    this._targetViewports = [];\n    this._options = options || {};\n    this._auxiliaryEventNames = this._options.auxiliaryEventNames || [];\n\n    //\n    this.id = synchronizerId;\n  }\n\n  /**\n   * \"Returns true if the synchronizer is disabled.\"\n   * @returns A boolean value.\n   */\n  public isDisabled(): boolean {\n    return !this._enabled || !this._hasSourceElements();\n  }\n\n  /**\n   * Sets the options for the viewport id.  This can be used to\n   * provide configuration on a viewport basis for things like offsets\n   * to the general synchronization, or turn on/off synchronization of certain\n   * attributes.\n   */\n  public setOptions(\n    viewportId: string,\n    options: Record<string, unknown> = {}\n  ): void {\n    this._viewportOptions[viewportId] = options;\n  }\n\n  /**\n   * Sets a synchronizer enabled\n   */\n  public setEnabled(enabled: boolean) {\n    this._enabled = enabled;\n  }\n\n  /** Gets the options for the given viewport id */\n  public getOptions(viewportId: string): Record<string, unknown> | undefined {\n    return this._viewportOptions[viewportId];\n  }\n\n  /**\n   * Add a viewport to the list of targets and sources both.\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public add(viewportInfo: Types.IViewportId): void {\n    this.addTarget(viewportInfo);\n    this.addSource(viewportInfo);\n  }\n\n  /**\n   * Add a viewport to the list of sources (source ONLY)\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public addSource(viewportInfo: Types.IViewportId): void {\n    if (_containsViewport(this._sourceViewports, viewportInfo)) {\n      return;\n    }\n\n    const { renderingEngineId, viewportId } = viewportInfo;\n\n    const viewport =\n      getRenderingEngine(renderingEngineId).getViewport(viewportId);\n\n    if (!viewport) {\n      console.warn(\n        `Synchronizer.addSource: No viewport for ${renderingEngineId} ${viewportId}`\n      );\n      return;\n    }\n\n    const element = viewport.element;\n\n    element.addEventListener(this._eventName, this._onEvent.bind(this));\n\n    if (this._auxiliaryEventNames.length) {\n      this._auxiliaryEventNames.forEach((eventName) => {\n        element.addEventListener(eventName, this._onEvent.bind(this));\n      });\n    }\n\n    this._updateDisableHandlers();\n\n    this._sourceViewports.push(viewportInfo);\n  }\n\n  /**\n   * Add a viewport to the list of viewports that will get the eventHandler\n   * executed when the event is fired on the source viewport.\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public addTarget(viewportInfo: Types.IViewportId): void {\n    if (_containsViewport(this._targetViewports, viewportInfo)) {\n      return;\n    }\n\n    this._targetViewports.push(viewportInfo);\n    this._updateDisableHandlers();\n  }\n\n  /**\n   * Get the list of source viewports (as {viewportId, renderingEngineId} objects)\n   * @returns An array of {viewportId, renderingEngineId} objects.\n   */\n  public getSourceViewports(): Array<Types.IViewportId> {\n    return this._sourceViewports;\n  }\n\n  /**\n   * Get the list of target viewports (as {viewportId, renderingEngineId} objects)\n   * @returns An array of {viewportId, renderingEngineId} objects.\n   */\n  public getTargetViewports(): Array<Types.IViewportId> {\n    return this._targetViewports;\n  }\n\n  public destroy(): void {\n    this._sourceViewports.forEach((s) => this.removeSource(s));\n    this._targetViewports.forEach((t) => this.removeTarget(t));\n  }\n\n  /**\n   * Remove the viewport from the list of targets and sources\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   */\n  public remove(viewportInfo: Types.IViewportId): void {\n    this.removeTarget(viewportInfo);\n    this.removeSource(viewportInfo);\n  }\n\n  /**\n   * Remove the viewport from the list of source viewports\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   */\n  public removeSource(viewportInfo: Types.IViewportId): void {\n    const index = _getViewportIndex(this._sourceViewports, viewportInfo);\n\n    if (index === -1) {\n      return;\n    }\n\n    const element = _getViewportElement(viewportInfo);\n\n    this._sourceViewports.splice(index, 1);\n\n    //@ts-ignore\n    element.removeEventListener(this._eventName, this._eventHandler);\n\n    if (this._auxiliaryEventNames) {\n      this._auxiliaryEventNames.forEach((eventName) => {\n        //@ts-ignore\n        element.removeEventListener(eventName, this._eventHandler);\n      });\n    }\n    this._updateDisableHandlers();\n  }\n\n  /**\n   * Remove the viewport from the list of viewports that are currently targeted by\n   * this handler\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   *\n   */\n  public removeTarget(viewportInfo: Types.IViewportId): void {\n    const index = _getViewportIndex(this._targetViewports, viewportInfo);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._targetViewports.splice(index, 1);\n    this._updateDisableHandlers();\n  }\n\n  public hasSourceViewport(\n    renderingEngineId: string,\n    viewportId: string\n  ): boolean {\n    return _containsViewport(this._sourceViewports, {\n      renderingEngineId,\n      viewportId,\n    });\n  }\n\n  public hasTargetViewport(\n    renderingEngineId: string,\n    viewportId: string\n  ): boolean {\n    return _containsViewport(this._targetViewports, {\n      renderingEngineId,\n      viewportId,\n    });\n  }\n\n  private fireEvent(sourceViewport: Types.IViewportId, sourceEvent: any): void {\n    if (this.isDisabled() || this._ignoreFiredEvents) {\n      return;\n    }\n\n    this._ignoreFiredEvents = true;\n    const promises = [];\n    try {\n      for (let i = 0; i < this._targetViewports.length; i++) {\n        const targetViewport = this._targetViewports[i];\n        const targetIsSource =\n          sourceViewport.viewportId === targetViewport.viewportId;\n\n        if (targetIsSource) {\n          continue;\n        }\n        const result = this._eventHandler(\n          this,\n          sourceViewport,\n          targetViewport,\n          sourceEvent,\n          this._options\n        );\n\n        // if the result is a promise, then add it to the list of promises\n        // to wait for before setting _ignoreFiredEvents to false\n        if (result instanceof Promise) {\n          promises.push(result);\n        }\n      }\n    } catch (ex) {\n      console.warn(`Synchronizer, for: ${this._eventName}`, ex);\n    } finally {\n      if (promises.length) {\n        Promise.allSettled(promises).then(() => {\n          this._ignoreFiredEvents = false;\n        });\n      } else {\n        this._ignoreFiredEvents = false;\n      }\n    }\n  }\n\n  private _onEvent = (evt: any): void => {\n    if (this._ignoreFiredEvents === true) {\n      return;\n    }\n\n    // If no target viewports, then return immediately, this is useful\n    // when switching between layouts, when previous layout has disabled\n    // its viewports, and the new layout has not yet enabled them.\n    // Right now we don't \"delete\" the synchronizer if all source and targets\n    // are removed, but we may want to do that in the future.\n    if (!this._targetViewports.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(evt.currentTarget);\n\n    if (!enabledElement) {\n      return;\n    }\n\n    const { renderingEngineId, viewportId } = enabledElement;\n\n    // If the viewport has been removed from the synchronizer before the event is\n    // fired, then return immediately.\n    if (!this._sourceViewports.find((s) => s.viewportId === viewportId)) {\n      return;\n    }\n\n    this.fireEvent(\n      {\n        renderingEngineId,\n        viewportId,\n      },\n      evt\n    );\n  };\n\n  private _hasSourceElements(): boolean {\n    return this._sourceViewports.length !== 0;\n  }\n\n  private _updateDisableHandlers(): void {\n    const viewports = _getUniqueViewports(\n      this._sourceViewports,\n      this._targetViewports\n    );\n    const _remove = this.remove;\n    const disableHandler = (elementDisabledEvent) => {\n      _remove(elementDisabledEvent.detail.element);\n    };\n\n    viewports.forEach(function (vUid) {\n      const renderingEngine = getRenderingEngine(vUid.renderingEngineId);\n\n      if (!renderingEngine) {\n        return;\n      }\n\n      const viewport = renderingEngine.getViewport(vUid.viewportId);\n      const { element } = viewport;\n\n      element.removeEventListener(\n        Enums.Events.ELEMENT_DISABLED,\n        disableHandler\n      );\n      element.addEventListener(Enums.Events.ELEMENT_DISABLED, disableHandler);\n    });\n  }\n}\n\nfunction _getUniqueViewports(\n  vp1: Array<Types.IViewportId>,\n  vp2: Array<Types.IViewportId>\n): Array<Types.IViewportId> {\n  const unique = [];\n\n  const vps = vp1.concat(vp2);\n\n  for (let i = 0; i < vps.length; i++) {\n    const vp = vps[i];\n    if (\n      !unique.some(\n        (u) =>\n          vp.renderingEngineId === u.renderingEngineId &&\n          vp.viewportId === u.viewportId\n      )\n    ) {\n      unique.push(vp);\n    }\n  }\n\n  return unique;\n}\n\nfunction _getViewportIndex(\n  arr: Array<Types.IViewportId>,\n  vp: Types.IViewportId\n): number {\n  return arr.findIndex(\n    (ar) =>\n      vp.renderingEngineId === ar.renderingEngineId &&\n      vp.viewportId === ar.viewportId\n  );\n}\n\nfunction _containsViewport(\n  arr: Array<Types.IViewportId>,\n  vp: Types.IViewportId\n) {\n  return arr.some(\n    (ar) =>\n      ar.renderingEngineId === vp.renderingEngineId &&\n      ar.viewportId === vp.viewportId\n  );\n}\n\nfunction _getViewportElement(vp: Types.IViewportId): HTMLDivElement {\n  const renderingEngine = getRenderingEngine(vp.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(`No RenderingEngine for Id: ${vp.renderingEngineId}`);\n  }\n\n  return renderingEngine.getViewport(vp.viewportId).element;\n}\n\nexport default Synchronizer;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\nimport { ISynchronizerEventHandler } from '../../types';\n\n/**\n * Create a new synchronizer instance from Synchronizer class\n * @param synchronizerId - The id of the synchronizer.\n * @param eventName - The name of the event that will be emitted by the\n * synchronizer.\n * @param eventHandler - The event handler that will be\n * called when the event is emitted.\n * @param options - Options for the synchronizer.\n * @returns A reference to the synchronizer.\n */\nfunction createSynchronizer(\n  synchronizerId: string,\n  eventName: string,\n  eventHandler: ISynchronizerEventHandler,\n  options?: any\n): Synchronizer {\n  const synchronizerWithSameIdExists = state.synchronizers.some(\n    (sync) => sync.id === synchronizerId\n  );\n\n  if (synchronizerWithSameIdExists) {\n    throw new Error(`Synchronizer with id '${synchronizerId}' already exists.`);\n  }\n\n  // Create\n  const synchronizer = new Synchronizer(\n    synchronizerId,\n    eventName,\n    eventHandler,\n    options\n  );\n\n  // Update state\n  state.synchronizers.push(synchronizer);\n\n  // Return reference\n  return synchronizer;\n}\n\nexport default createSynchronizer;\n","import { state } from '../index';\n\n/**\n * \"Destroy all synchronizers.\"\n */\nfunction destroy(): void {\n  while (state.synchronizers.length > 0) {\n    const synchronizer = state.synchronizers.pop();\n\n    synchronizer.destroy();\n  }\n}\n\nexport default destroy;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * Get the synchronizer with the given id from the state.\n * @param synchronizerId - The id of the synchronizer to be retrieved.\n * @returns A synchronizer object.\n */\nfunction getSynchronizer(synchronizerId: string): Synchronizer | void {\n  return state.synchronizers.find((s) => s.id === synchronizerId);\n}\n\nexport default getSynchronizer;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * Return the array of synchronizers\n * @returns An array of synchronizers.\n */\nfunction getAllSynchronizers(): Array<Synchronizer> {\n  return state.synchronizers;\n}\n\nexport default getAllSynchronizers;\n","import { state } from '../index';\n\n// Synchronizers are a bit more tenacious. We need to make sure we remove\n// any attached events\n// We should probably just have a destroySynchronizer call\n// then use getByX to allow versatility in how we can call destroy\n\n/**\n * Destroy a synchronizer by its ID.\n * @param synchronizerId - The id of the synchronizer to destroy.\n */\nfunction destroySynchronizer(synchronizerId: string): void {\n  const synchronizerIndex = state.synchronizers.findIndex(\n    (sync) => sync.id === synchronizerId\n  );\n\n  if (synchronizerIndex > -1) {\n    const synchronizer = state.synchronizers[synchronizerIndex];\n\n    synchronizer.destroy();\n    state.synchronizers.splice(synchronizerIndex, 1);\n  }\n}\n\nexport default destroySynchronizer;\n","import { utilities } from '@cornerstonejs/core';\nimport MouseCursor from './MouseCursor';\n\nconst DEFAULT_NAME = 'image-cursor';\n\nexport default class ImageMouseCursor extends MouseCursor {\n  private url: string;\n  private x: number;\n  private y: number;\n\n  constructor(\n    url: string,\n    x?: number,\n    y?: number,\n    name?: string | undefined,\n    fallback?: MouseCursor | undefined\n  ) {\n    super(\n      name || ImageMouseCursor.getUniqueInstanceName(DEFAULT_NAME),\n      fallback\n    );\n    this.url = url;\n    this.x = Number(x) || 0;\n    this.y = Number(y) || 0;\n  }\n\n  getStyleProperty(): string {\n    const { url, x, y } = this;\n    let style = `url('${url}')`;\n    if (x >= 0 && y >= 0 && (x > 0 || y > 0)) {\n      style += ` ${x} ${y}`;\n    }\n    return this.addFallbackStyleProperty(style);\n  }\n\n  static getUniqueInstanceName(prefix: string): string {\n    return `${prefix}-${utilities.getRuntimeId(ImageMouseCursor)}`;\n  }\n}\n","import { SVGCursorDescriptor } from '../types';\n\n/*\n * Definitions\n */\n\nconst BASE: SVGCursorDescriptor = {\n  iconContent: '',\n  iconSize: 16,\n  viewBox: {\n    x: 16,\n    y: 16,\n  },\n  mousePoint: {\n    x: 8,\n    y: 8,\n  },\n  mousePointerGroupString: `\n    <path stroke=\"{{color}}\" d=\"M8 16L8 0\"></path>\n    <path stroke=\"{{color}}\" d=\"M16 8L0 8\"></path>\n  `,\n};\n\nconst SEGMENTATION_CURSOR_BOUNDARIES = {\n  x: 127,\n  y: 60,\n};\n\nconst MINUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n`;\n\nconst PLUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n<rect fill=\"{{color}}\" x=\"95.84\" y=\"9.38\" width=\"15.85\" height=\"47.14\"/>\n`;\n\nconst SCISSOR_ICON = `<path fill=\"{{color}}\" d=\"M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z\" transform=\"translate(-1.17 -0.96)\"/>`;\nconst RECTANGLE_ICON = `<path fill=\"{{color}}\" d=\"M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z\" transform=\"translate(-8.86 -2.25)\"/>`;\nconst CIRCLE_ICON = `<path fill=\"{{color}}\" d=\"M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z\" transform=\"translate(-8.86 -2.25)\"/>`;\n\nconst CursorSVG: Record<string, SVGCursorDescriptor> = {\n  Angle: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50\n    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23\n    10l50 50q10 10 10 23z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  ArrowAnnotate: extend(BASE, {\n    iconContent: `<g id=\"arrowAnnotate-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"arrowAnnotate-arrow\" d=\"M23,7 l-15,15 M7,17 l0,6 6,0\" stroke-width=\"2\" />\n  </g>`,\n    viewBox: {\n      x: 24,\n      y: 24,\n    },\n  }),\n  Bidirectional: extend(BASE, {\n    iconContent: `<g fill=\"{{color}}\" stroke-width=\"3\" stroke=\"{{color}}\">\n    <path d=\"M27.63 3.21L3.12 28.81\"></path>\n    <path d=\"M27.63 15.75L15.27 4.43\"></path>\n    <path d=\"M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z\" ></path>\n    <path d=\"M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z\"></path>\n    <path d=\"M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z\"></path>\n    <path d=\"M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z\"></path>\n  </g>`,\n    viewBox: {\n      x: 48,\n      y: 48,\n    },\n  }),\n  CobbAngle: extend(BASE, {\n    iconContent: `<g stroke=\"{{color}}\" stroke-width=\"3\">\n    <path d=\"M28.59 2.34L3.82 12.32\"></path>\n    <path d=\"M28.59 29.66L3.82 19.68\"></path>\n    <path stroke-dasharray=\"2\" fill-opacity=\"0\" d=\"M12.37\n      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15\n      9.33C13.11 9.24 13.02 9 12.88 8.63\">\n    </path>\n  </g>`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  CircleROI: extend(BASE, {\n    iconContent: `<circle stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" cx=\"16\" cy=\"16\" r=\"14\" />`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  EllipticalROI: extend(BASE, {\n    iconContent: `<path stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" d=\"M30.74 15.76C30.74 20.99 24.14 25.23 16\n    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14\n    6.3 30.74 10.54 30.74 15.76Z\" />`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  FreehandROI: extend(BASE, {\n    iconContent: `<g fill=\"{{color}}\" stroke=\"{{color}}\" stroke-width=\"2\">\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_3\" cy=\"4.240343\" cx=\"14.306499\"/>\n    <line id=\"svg_4\" y2=\"3.58462\" x2=\"12.242186\" y1=\"3.997482\" x1=\"13.432202\"/>\n    <line id=\"svg_5\" y2=\"3.268901\" x2=\"10.857882\" y1=\"3.608906\" x1=\"12.387902\"/>\n    <line id=\"svg_6\" y2=\"3.147471\" x2=\"9.740724\" y1=\"3.293187\" x1=\"10.955026\"/>\n    <line id=\"svg_7\" y2=\"3.147471\" x2=\"8.089274\" y1=\"3.196043\" x1=\"9.983585\"/>\n    <line id=\"svg_8\" y2=\"3.268901\" x2=\"6.874972\" y1=\"3.123185\" x1=\"8.307848\"/>\n    <line id=\"svg_9\" y2=\"3.657478\" x2=\"5.587812\" y1=\"3.220329\" x1=\"7.020688\"/>\n    <line id=\"svg_10\" y2=\"4.046054\" x2=\"4.737801\" y1=\"3.560334\" x1=\"5.854959\"/>\n    <line id=\"svg_11\" y2=\"4.337487\" x2=\"4.300652\" y1=\"3.997482\" x1=\"4.834945\"/>\n    <line id=\"svg_12\" y2=\"4.726063\" x2=\"3.88779\" y1=\"4.191771\" x1=\"4.470655\"/>\n    <line id=\"svg_15\" y2=\"5.3575\" x2=\"3.377783\" y1=\"4.604633\" x1=\"3.960648\"/>\n    <line id=\"svg_16\" y2=\"6.183226\" x2=\"2.916348\" y1=\"5.138926\" x1=\"3.547785\"/>\n    <line id=\"svg_17\" y2=\"6.960379\" x2=\"2.770632\" y1=\"5.867507\" x1=\"3.037779\"/>\n    <line id=\"svg_18\" y2=\"7.713246\" x2=\"2.673488\" y1=\"6.741804\" x1=\"2.819204\"/>\n    <line id=\"svg_19\" y2=\"8.684687\" x2=\"2.697774\" y1=\"7.616102\" x1=\"2.673488\"/>\n    <line id=\"svg_20\" y2=\"9.753273\" x2=\"2.892062\" y1=\"8.611829\" x1=\"2.697774\"/>\n    <line id=\"svg_21\" y2=\"10.724714\" x2=\"3.134923\" y1=\"9.534698\" x1=\"2.84349\"/>\n    <line id=\"svg_23\" y2=\"11.647583\" x2=\"3.596357\" y1=\"10.578998\" x1=\"3.086351\"/>\n    <line id=\"svg_25\" y2=\"12.521881\" x2=\"4.276366\" y1=\"11.501867\" x1=\"3.499213\"/>\n    <line id=\"svg_26\" y2=\"13.930471\" x2=\"5.830673\" y1=\"12.376165\" x1=\"4.13065\"/>\n    <line id=\"svg_28\" y2=\"14.707624\" x2=\"7.263549\" y1=\"13.881899\" x1=\"5.733528\"/>\n    <line id=\"svg_29\" y2=\"15.339061\" x2=\"8.963571\" y1=\"14.61048\" x1=\"7.06926\"/>\n    <line id=\"svg_30\" y2=\"15.581921\" x2=\"10.882168\" y1=\"15.314775\" x1=\"8.817855\"/>\n    <line id=\"svg_31\" y2=\"15.460491\" x2=\"12.023612\" y1=\"15.581921\" x1=\"10.785024\"/>\n    <line id=\"svg_33\" y2=\"15.120487\" x2=\"13.092197\" y1=\"15.484777\" x1=\"11.877895\"/>\n    <line id=\"svg_34\" y2=\"14.586194\" x2=\"13.86935\" y1=\"15.217631\" x1=\"12.897909\"/>\n    <line id=\"svg_35\" y2=\"13.833327\" x2=\"14.597931\" y1=\"14.756196\" x1=\"13.699348\"/>\n    <line id=\"svg_37\" y2=\"12.716169\" x2=\"15.180796\" y1=\"13.881899\" x1=\"14.549359\"/>\n    <line id=\"svg_39\" y2=\"11.429009\" x2=\"15.520801\" y1=\"12.813313\" x1=\"15.15651\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_40\" cy=\"10.967574\" cx=\"15.520801\"/>\n  </g>`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  FreehandROISculptor: extend(BASE, {\n    iconContent: `<g id=\"icon-freehand-sculpt\" fill=\"none\" stroke-width=\"1.5\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <line id=\"svg_1\" y2=\"2.559367\" x2=\"10.184807\" y1=\"4.467781\" x1=\"8.81711\"/>\n    <line id=\"svg_4\" y2=\"1.493836\" x2=\"11.727442\" y1=\"2.766112\" x1=\"10.089386\"/>\n    <line id=\"svg_7\" y2=\"1.080346\" x2=\"13.047428\" y1=\"1.748291\" x1=\"11.345759\"/>\n    <line id=\"svg_8\" y2=\"1.000829\" x2=\"14.351511\" y1=\"1.112153\" x1=\"12.77707\"/>\n    <line id=\"svg_9\" y2=\"1.350705\" x2=\"15.242104\" y1=\"0.905408\" x1=\"13.969828\"/>\n    <line id=\"svg_10\" y2=\"2.098167\" x2=\"15.862339\" y1=\"1.14396\" x1=\"14.955842\"/>\n    <line id=\"svg_11\" y2=\"3.195505\" x2=\"16.41896\" y1=\"1.939133\" x1=\"15.766918\"/>\n    <line id=\"svg_12\" y2=\"4.292843\" x2=\"16.530284\" y1=\"2.925147\" x1=\"16.387153\"/>\n    <line id=\"svg_16\" y2=\"5.644637\" x2=\"16.196311\" y1=\"3.831643\" x1=\"16.593898\"/>\n    <line id=\"svg_18\" y2=\"7.266789\" x2=\"15.623787\" y1=\"5.19934\" x1=\"16.275829\"/>\n    <line id=\"svg_19\" y2=\"10.813258\" x2=\"14.526449\" y1=\"6.726071\" x1=\"15.766918\"/>\n    <line id=\"svg_20\" y2=\"5.056209\" x2=\"8.085552\" y1=\"4.181519\" x1=\"8.976145\"/>\n    <line id=\"svg_23\" y2=\"5.326568\" x2=\"7.481221\" y1=\"4.78585\" x1=\"8.403621\"/>\n    <line id=\"svg_24\" y2=\"5.565119\" x2=\"6.749662\" y1=\"5.294761\" x1=\"7.624352\"/>\n    <line id=\"svg_25\" y2=\"5.994512\" x2=\"5.429675\" y1=\"5.533312\" x1=\"6.956407\"/>\n    <line id=\"svg_27\" y2=\"6.551133\" x2=\"4.284627\" y1=\"5.962706\" x1=\"5.572807\"/>\n    <line id=\"svg_28\" y2=\"7.584858\" x2=\"3.044158\" y1=\"6.392099\" x1=\"4.427758\"/>\n    <line id=\"svg_29\" y2=\"8.84123\" x2=\"2.185372\" y1=\"7.489437\" x1=\"3.219096\"/>\n    <line id=\"svg_31\" y2=\"10.606513\" x2=\"1.644654\" y1=\"8.602678\" x1=\"2.280792\"/>\n    <line id=\"svg_32\" y2=\"13.214679\" x2=\"1.48562\" y1=\"10.352058\" x1=\"1.724171\"/>\n    <line id=\"svg_33\" y2=\"14.375631\" x2=\"1.676461\" y1=\"12.992031\" x1=\"1.453813\"/>\n    <line id=\"svg_34\" y2=\"15.298031\" x2=\"2.264889\" y1=\"14.152983\" x1=\"1.517427\"/>\n    <line id=\"svg_35\" y2=\"16.172721\" x2=\"3.521261\" y1=\"14.948155\" x1=\"1.915013\"/>\n    <line id=\"svg_36\" y2=\"16.824762\" x2=\"5.207027\" y1=\"15.997783\" x1=\"3.28271\"/>\n    <line id=\"svg_38\" y2=\"17.063314\" x2=\"7.035924\" y1=\"16.745245\" x1=\"4.968475\"/>\n    <line id=\"svg_39\" y2=\"16.888376\" x2=\"9.278311\" y1=\"17.047411\" x1=\"6.733758\"/>\n    <line id=\"svg_40\" y2=\"16.284045\" x2=\"10.661911\" y1=\"16.983797\" x1=\"8.992048\"/>\n    <line id=\"svg_41\" y2=\"15.313934\" x2=\"11.647925\" y1=\"16.395369\" x1=\"10.455166\"/>\n    <line id=\"svg_44\" y2=\"13.898527\" x2=\"12.82478\" y1=\"15.425259\" x1=\"11.504794\"/>\n    <line id=\"svg_45\" y2=\"12.037824\" x2=\"14.144766\" y1=\"14.312017\" x1=\"12.522614\"/>\n    <line id=\"svg_47\" y2=\"10.59061\" x2=\"14.605966\" y1=\"12.228665\" x1=\"13.953925\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_48\" cy=\"3.982726\" cx=\"13.460918\"/>\n  </g>`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  Length: extend(BASE, {\n    iconContent: `<g id=\"length-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"length-dashes\" d=\"m22.5,6 -16.5,16.5\" stroke-width=\"3\" stroke-dasharray=\"0.6666,5\" />\n  </g>`,\n    viewBox: {\n      x: 24,\n      y: 24,\n    },\n  }),\n  Probe: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75\n    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73\n    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5\n    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5\n    385.5-103 385.5 103 279.5 279.5 103 385.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  RectangleROI: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47\n    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0\n    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119\n    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  TextMarker: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M789 559l-170 450q33 0 136.5 2t160.5 2q19 0\n    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29\n    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15\n    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5\n    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0\n    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11\n    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0\n    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58\n    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Crosshairs: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26\n    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45\n    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26\n    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5\n    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32\n    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5\n    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26\n    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26\n    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161\n    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161\n    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Eraser: extend(BASE, {\n    iconContent: `<path transform=\"translate(0,1792) scale(1,-1)\" fill=\"{{color}}\" d=\"M960 1408l336-384h-768l-336 384h768zm1013-1077q15\n    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38\n    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38\n    0 69.5 20.5t47.5 54.5z\" />`,\n    viewBox: {\n      x: 2048,\n      y: 1792,\n    },\n  }),\n  Magnify: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />`,\n    viewBox: {\n      x: 512,\n      y: 512,\n    },\n  }),\n  Pan: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17\n    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355\n    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59\n    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12\n    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144\n    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19\n    45v448q0 42-39 59-13 5-25 5-26 0-45-19z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Rotate: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39\n    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5\n    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0\n    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109\n    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298\n    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14\n    39 17 39 59z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  StackScroll: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0\n    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547\n    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z\" />`,\n    viewBox: {\n      x: 24,\n      y: 28,\n    },\n  }),\n  WindowLevelRegion: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119\n    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5\n    84.5t84.5 203.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  WindowLevel: extend(BASE, {\n    iconContent: `\n    <path fill=\"{{color}}\" d=\"M14.5,3.5 a1 1 0 0 1 -11,11 Z\" stroke=\"none\" opacity=\"0.8\" />\n    <circle cx=\"9\" cy=\"9\" r=\"8\" fill=\"none\" stroke-width=\"2\" stroke=\"{{color}}\" />`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  Zoom: extend(BASE, {\n    iconContent: `\n  <path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />\n  <path fill=\"{{color}}\" transform=\"scale(0.22,0.22) translate(1400,0)\" d=\"M1216\n    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19\n    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26\n    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z\" />`,\n    viewBox: {\n      x: 640,\n      y: 512,\n    },\n  }),\n\n  /*\n   * Segmentation Cursors\n   */\n\n  SegmentationFreeHandEraseInside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandFillInside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandEraseOutside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandFillOutside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationRectangleEraseInside: extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  // Default Rectangle Scissors\n  RectangleScissor: extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.FILL_INSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.FILL_OUTSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.ERASE_INSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  CircleScissor: extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.FILL_INSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.ERASE_OUTSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.FILL_OUTSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n};\n\n/*\n * Utils\n */\n\nfunction extend(\n  base: SVGCursorDescriptor,\n  values: Record<string, unknown>\n): SVGCursorDescriptor {\n  return Object.assign(Object.create(base), values);\n}\n\n/**\n * Registers a cursor to the list, so that it will be used for the given `toolName`.\n * Overwrites the given cursor if it is already set.\n *\n * @param toolName - The name of the tool to assign a cursor to.\n * @param iconContent - The SVG icon content of the cursor.\n * @param viewBox - The viewBox of the cursor object.\n */\nfunction registerCursor(\n  toolName: string,\n  iconContent: string,\n  viewBox: { x: number; y: number }\n) {\n  CursorSVG[toolName] = extend(BASE, {\n    iconContent,\n    viewBox,\n  });\n}\n\nfunction getDefinedSVGCursorDescriptor(\n  name: string\n): SVGCursorDescriptor | undefined {\n  return CursorSVG[name];\n}\n\n/*\n * Exports\n */\nconst svgCursorNames = Object.keys(CursorSVG);\n\nexport {\n  getDefinedSVGCursorDescriptor,\n  registerCursor,\n  svgCursorNames,\n  CursorSVG,\n};\n","import { ToolModes, AnnotationStyleStates } from '../enums';\nimport MouseCursor from './MouseCursor';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport { getDefinedSVGCursorDescriptor } from './SVGCursorDescriptor';\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\n\nimport type { StyleSpecifier } from '../types/AnnotationStyle';\nimport type { SVGCursorDescriptor } from '../types';\n\nconst PROPERTY = 'color';\nconst STATE = AnnotationStyleStates.Highlighted;\nconst MODE = ToolModes.Active;\n\nexport default class SVGMouseCursor extends ImageMouseCursor {\n  constructor(\n    url: string,\n    x?: number,\n    y?: number,\n    name?: string | undefined,\n    fallback?: MouseCursor | undefined\n  ) {\n    super(url, x, y, name, fallback);\n  }\n\n  /**\n   * Get a shared instance of the SVGMouseCursor class satisfying the given parameters.\n   *\n   * @param name - The name of the cursor (defined in SVGCursorDescriptor.ts);\n   * @param pointer - Should be true to use the version of the cursor containing\n   * a mouse pointer. Defaults to false (which does not add a pointer to the cursor);\n   * @param color - The color of the cursor. Defaults to tool.style.colorHighlightedActive;\n   * @returns a SVGMouseCursor instance or\n   * undefined if no SVG cursor descriptor was found with the given name;\n   */\n  static getDefinedCursor(\n    name: string,\n    pointer = false,\n    color?: string\n  ): MouseCursor {\n    if (!color) {\n      color = getStyleProperty(PROPERTY, {} as StyleSpecifier, STATE, MODE);\n    }\n    const urn = getCursorURN(name, pointer, color);\n    let cursor = super.getDefinedCursor(urn);\n    if (!cursor) {\n      const descriptor = getDefinedSVGCursorDescriptor(name);\n      if (descriptor) {\n        cursor = createSVGMouseCursor(\n          descriptor,\n          urn,\n          pointer,\n          color,\n          super.getDefinedCursor('default')\n        );\n        super.setDefinedCursor(urn, cursor);\n      }\n    }\n    return cursor;\n  }\n}\n\n/*\n * Helpers\n */\n\nfunction format(template: string, dictionary: Record<string, unknown>): string {\n  const dict = Object(dictionary);\n  const defined = Object.prototype.hasOwnProperty.bind(dict);\n  return (template + '').replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => {\n    return defined(key) ? dict[key] + '' : '';\n  });\n}\n\nfunction getCursorURN(name: string, pointer: boolean, color: string) {\n  const type = pointer ? 'pointer' : 'cursor';\n  return `${type}:${name}/${color}`;\n}\n\nfunction createSVGMouseCursor(\n  descriptor: SVGCursorDescriptor,\n  name: string,\n  pointer: boolean,\n  color: string,\n  fallback: MouseCursor\n): SVGMouseCursor {\n  const { x, y } = descriptor.mousePoint;\n  return new SVGMouseCursor(\n    createSVGIconUrl(descriptor, pointer, { color }),\n    x,\n    y,\n    name,\n    fallback\n  );\n}\n\nfunction createSVGIconUrl(\n  descriptor: SVGCursorDescriptor,\n  pointer: boolean,\n  options: Record<string, unknown>\n): string {\n  return URL.createObjectURL(createSVGIconBlob(descriptor, pointer, options));\n}\n\nfunction createSVGIconBlob(\n  descriptor: SVGCursorDescriptor,\n  pointer: boolean,\n  options: Record<string, unknown>\n): Blob {\n  const svgString = (pointer ? createSVGIconWithPointer : createSVGIcon)(\n    descriptor,\n    options\n  );\n  return new Blob([svgString], { type: 'image/svg+xml' });\n}\n\nfunction createSVGIcon(\n  descriptor: SVGCursorDescriptor,\n  options: Record<string, unknown>\n): string {\n  const { iconContent, iconSize, viewBox } = descriptor;\n  const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${iconSize}\" height=\"${iconSize}\" viewBox=\"0 0\n      ${viewBox.x} ${viewBox.y}\">\n      ${iconContent}\n    </svg>`;\n  return format(svgString, options);\n}\n\nfunction createSVGIconWithPointer(\n  descriptor: SVGCursorDescriptor,\n  options: Record<string, unknown>\n) {\n  const { iconContent, iconSize, viewBox, mousePointerGroupString } =\n    descriptor;\n  const scale = iconSize / Math.max(viewBox.x, viewBox.y, 1);\n  const svgSize = 16 + iconSize;\n  const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${svgSize}\" height=\"${svgSize}\" viewBox=\"0 0 ${svgSize} ${svgSize}\">\n      <g>${mousePointerGroupString}</g>\n      <g transform=\"translate(16, 16) scale(${scale})\">${iconContent}</g>\n    </svg>`;\n  return format(svgString, options);\n}\n","import { MouseBindings, ToolModes } from '../../enums';\nimport get from 'lodash.get';\nimport cloneDeep from 'lodash.clonedeep';\nimport {\n  triggerEvent,\n  eventTarget,\n  getRenderingEngine,\n  getRenderingEngines,\n  getEnabledElementByIds,\n  Settings,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport {\n  ToolActivatedEventDetail,\n  ToolModeChangedEventDetail,\n} from '../../types/EventTypes';\nimport { ToolGroupManager, state } from '../index';\nimport {\n  IToolBinding,\n  IToolClassReference,\n  IToolGroup,\n  SetToolBindingsType,\n  ToolOptionsType,\n  ToolConfiguration,\n} from '../../types';\n\nimport { MouseCursor, SVGMouseCursor } from '../../cursors';\nimport { initElementCursor } from '../../cursors/elementCursor';\n\nconst { Active, Passive, Enabled, Disabled } = ToolModes;\n\nconst PRIMARY_BINDINGS = [{ mouseButton: MouseBindings.Primary }];\n\n/**\n * ToolGroup class which is a container for tools and their modes and states.\n * In Cornerstone3DTools, you need to create a tool group in order to use the\n * tools. ToolGroup is a way to share tool configuration, state (enabled, disabled, etc.)\n * across a set of viewports. Tools can set to be activated, enabled or disabled\n * in a toolGroup. You should not directly instantiate a ToolGroup. You need to use\n * ToolGroupManager helpers to create a new toolGroup or get a reference to an existing toolGroup.\n *\n * ```js\n * const toolGroup = csTools.ToolGroupManager.createToolGroup('toolGroupId')\n * ```\n */\nexport default class ToolGroup implements IToolGroup {\n  id: string;\n  viewportsInfo = [];\n  toolOptions = {};\n  currentActivePrimaryToolName: string | null = null;\n  prevActivePrimaryToolName: string | null = null;\n  /**\n   * Options used for restoring a tool\n   */\n  restoreToolOptions = {};\n  _toolInstances = {};\n\n  constructor(id: string) {\n    this.id = id;\n  }\n\n  /**\n   * Get the viewport IDs of all the viewports in the current viewport\n   * @returns An array of viewport IDs.\n   */\n  getViewportIds(): string[] {\n    return this.viewportsInfo.map(({ viewportId }) => viewportId);\n  }\n\n  /**\n   * Returns the toolGroup viewports info which is an array of {viewportId, renderingEngineId}\n   */\n  getViewportsInfo(): Array<Types.IViewportId> {\n    return this.viewportsInfo.slice();\n  }\n\n  /**\n   * Get the tool instance for a given tool name in the toolGroup\n   * @param toolName - The name of the tool.\n   * @returns A tool instance.\n   */\n  public getToolInstance(toolInstanceName: string) {\n    const toolInstance = this._toolInstances[toolInstanceName];\n    if (!toolInstance) {\n      console.warn(\n        `'${toolInstanceName}' is not registered with this toolGroup (${this.id}).`\n      );\n      return;\n    }\n\n    return toolInstance;\n  }\n\n  /**\n   * Retrieves the tool instances associated with this tool group.\n   *\n   * @returns A record containing the tool instances, where the keys are the tool names and the values are the tool instances.\n   */\n  public getToolInstances(): Record<string, any> {\n    return this._toolInstances;\n  }\n\n  /**\n   * Check if a tool is already added to the tool group\n   * @param toolName - Tool name\n   * @returns True if the tool is already added or false otherwise\n   */\n  hasTool(toolName: string): boolean {\n    return !!this._toolInstances[toolName];\n  }\n\n  /**\n   * Add a tool to the tool group with the given tool name and tool configuration.\n   * Note that adding a tool to a tool group will not automatically set the tool\n   * to be active. You must call setToolActive or setToolPassive and other methods\n   * to set the tool to be active or passive or in other states.\n   *\n   * @param toolName - string\n   * @param configuration - Tool configuration objects and a custom statistics calculator if needed\n   */\n  addTool(toolName: string, configuration: ToolConfiguration = {}): void {\n    const toolDefinition = state.tools[toolName];\n    const hasToolName = typeof toolName !== 'undefined' && toolName !== '';\n    const localToolInstance = this.toolOptions[toolName];\n\n    if (!hasToolName) {\n      console.warn(\n        'Tool with configuration did not produce a toolName: ',\n        configuration\n      );\n      return;\n    }\n\n    if (!toolDefinition) {\n      console.warn(\n        `'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`\n      );\n      return;\n    }\n\n    if (localToolInstance) {\n      console.warn(\n        `'${toolName}' is already registered for ToolGroup ${this.id}.`\n      );\n      return;\n    }\n\n    // Should these be renamed higher up, so we don't have to alias?\n    // Wrap in try-catch so 3rd party tools don't explode?\n    const { toolClass: ToolClass } = toolDefinition;\n\n    const toolProps = {\n      name: toolName,\n      toolGroupId: this.id,\n      configuration,\n    };\n\n    const instantiatedTool = new ToolClass(toolProps);\n\n    // API instead of directly exposing schema?\n    // Maybe not here, but feels like a \"must\" for any method outside of the ToolGroup itself\n    this._toolInstances[toolName] = instantiatedTool;\n  }\n\n  public addToolInstance(\n    toolName: string,\n    parentClassName: string,\n    configuration = {}\n  ): void {\n    let ToolClassToUse = state.tools[toolName]\n      ?.toolClass as IToolClassReference;\n\n    if (!ToolClassToUse) {\n      // get parent class constructor\n      const ParentClass = state.tools[parentClassName]\n        .toolClass as IToolClassReference;\n\n      // Todo: could not find a way to make this work with typescript\n      // @ts-ignore\n      class ToolInstance extends ParentClass {}\n      // @ts-ignore\n      ToolInstance.toolName = toolName;\n      // @ts-ignore\n      ToolClassToUse = ToolInstance;\n\n      state.tools[toolName] = {\n        toolClass: ToolInstance as IToolClassReference,\n      };\n    }\n\n    // add the tool to the toolGroup\n    // @ts-ignore\n    this.addTool(ToolClassToUse.toolName, configuration);\n  }\n\n  //   class InstanceTool extends parentClass;\n  // InstanceTool.constructor.toolName = name;\n  // addTool(InstanceTool,configuration)\n  /**\n   * Add a viewport to the ToolGroup. It accepts viewportId and optional\n   * renderingEngineId parameter. If renderingEngineId is not provided,\n   * it checks if cornerstone-core has more than one renderingEngine; If so,\n   * it will throw an error. If cornerstone-core has only one renderingEngine,\n   * it will use that renderingEngine.\n   *\n   * @param viewportId - The unique identifier for the viewport.\n   * @param renderingEngineId - The rendering engine to use.\n   */\n  public addViewport(viewportId: string, renderingEngineId?: string): void {\n    if (typeof viewportId !== 'string') {\n      throw new Error('viewportId must be defined and be a string');\n    }\n\n    const renderingEngines = getRenderingEngines();\n\n    if (!renderingEngineId && renderingEngines.length > 1) {\n      throw new Error(\n        'You must specify a renderingEngineId when there are multiple rendering engines.'\n      );\n    }\n\n    const renderingEngineUIDToUse = renderingEngineId || renderingEngines[0].id;\n\n    // Don't overwrite if it already exists\n    if (\n      !this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)\n    ) {\n      this.viewportsInfo.push({\n        viewportId,\n        renderingEngineId: renderingEngineUIDToUse,\n      });\n    }\n\n    // Handle the newly added viewport's mouse cursor\n    const toolName = this.getActivePrimaryMouseButtonTool();\n\n    const runtimeSettings = Settings.getRuntimeSettings();\n    if (runtimeSettings.get('useCursors')) {\n      this.setViewportsCursorByToolName(toolName);\n    }\n\n    const eventDetail = {\n      toolGroupId: this.id,\n      viewportId,\n      renderingEngineId: renderingEngineUIDToUse,\n    };\n\n    triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_ADDED, eventDetail);\n  }\n\n  /**\n   * Removes viewport from the toolGroup. If only renderingEngineId is defined\n   * it removes all the viewports with the same renderingEngineId, if viewportId\n   * is also provided, it will remove that specific viewport from the ToolGroup.\n   *\n   * @param renderingEngineId - renderingEngine id\n   * @param viewportId - viewport id\n   */\n  public removeViewports(renderingEngineId: string, viewportId?: string): void {\n    const indices = [];\n\n    this.viewportsInfo.forEach((vpInfo, index) => {\n      let match = false;\n      if (vpInfo.renderingEngineId === renderingEngineId) {\n        match = true;\n\n        if (viewportId && vpInfo.viewportId !== viewportId) {\n          match = false;\n        }\n      }\n      if (match) {\n        indices.push(index);\n      }\n    });\n\n    if (indices.length) {\n      // Note: Traverse the array backwards, such that when we remove items we\n      // do not immediately mess up our loop indicies.\n      for (let i = indices.length - 1; i >= 0; i--) {\n        this.viewportsInfo.splice(indices[i], 1);\n      }\n    }\n\n    const eventDetail = {\n      toolGroupId: this.id,\n      viewportId,\n      renderingEngineId,\n    };\n\n    triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_REMOVED, eventDetail);\n  }\n\n  public setActiveStrategy(toolName: string, strategyName: string) {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool configuration.`\n      );\n\n      return;\n    }\n\n    toolInstance.setActiveStrategy(strategyName);\n  }\n\n  setToolMode(\n    toolName: string,\n    mode: ToolModes,\n    options = {} as SetToolBindingsType\n  ): void {\n    if (!toolName) {\n      console.warn('setToolMode: toolName must be defined');\n      return;\n    }\n\n    if (mode === ToolModes.Active) {\n      this.setToolActive(\n        toolName,\n        options || this.restoreToolOptions[toolName]\n      );\n      return;\n    }\n\n    if (mode === ToolModes.Passive) {\n      this.setToolPassive(toolName);\n      return;\n    }\n\n    if (mode === ToolModes.Enabled) {\n      this.setToolEnabled(toolName);\n      return;\n    }\n\n    if (mode === ToolModes.Disabled) {\n      this.setToolDisabled(toolName);\n      return;\n    }\n\n    console.warn('setToolMode: mode must be defined');\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Active. This means the tool\n   * can be actively used by the defined bindings (e.g., Mouse primary click)\n   *\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\n   * - Can add data if an annotation tool.\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   *\n   * @param toolName - tool name\n   * @param toolBindingsOptions - tool bindings\n   */\n  public setToolActive(\n    toolName: string,\n    toolBindingsOptions = {} as SetToolBindingsType\n  ): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    if (!toolInstance) {\n      console.warn(\n        `'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`\n      );\n      return;\n    }\n\n    const prevBindings: IToolBinding[] = this.toolOptions[toolName]\n      ? this.toolOptions[toolName].bindings\n      : [];\n\n    const newBindings = toolBindingsOptions.bindings\n      ? toolBindingsOptions.bindings\n      : [];\n\n    // combine the new bindings with the previous bindings to avoid duplicates\n    // it allows duplicated mouse buttons as long as they don't have same\n    // modifier keys.\n    const bindingsToUse = [...prevBindings, ...newBindings].reduce(\n      (unique, binding) => {\n        const TouchBinding = binding.numTouchPoints !== undefined;\n        const MouseBinding = binding.mouseButton !== undefined;\n\n        if (\n          !unique.some((obj) => hasSameBinding(obj, binding)) &&\n          (TouchBinding || MouseBinding)\n        ) {\n          unique.push(binding);\n        }\n        return unique;\n      },\n      []\n    );\n\n    // We should not override the bindings if they are already set\n    const toolOptions: ToolOptionsType = {\n      bindings: bindingsToUse,\n      mode: Active,\n    };\n\n    this.toolOptions[toolName] = toolOptions;\n    this._toolInstances[toolName].mode = Active;\n\n    // reset the mouse cursor if tool has left click binding\n    const runtimeSettings = Settings.getRuntimeSettings();\n    const useCursor = runtimeSettings.get('useCursors');\n\n    if (this._hasMousePrimaryButtonBinding(toolBindingsOptions) && useCursor) {\n      this.setViewportsCursorByToolName(toolName);\n    } else {\n      // reset to default cursor only if there is no other tool with primary binding\n      const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();\n      if (!activeToolIdentifier && useCursor) {\n        const cursor = MouseCursor.getDefinedCursor('default');\n        this._setCursorForViewports(cursor);\n      }\n    }\n\n    // if it is a primary tool binding, we should store it as the previous primary tool\n    // so that we can restore it when the tool is disabled if desired\n    if (this._hasMousePrimaryButtonBinding(toolBindingsOptions)) {\n      if (this.prevActivePrimaryToolName === null) {\n        this.prevActivePrimaryToolName = toolName;\n      } else {\n        this.prevActivePrimaryToolName = this.currentActivePrimaryToolName;\n      }\n\n      this.currentActivePrimaryToolName = toolName;\n    }\n\n    if (typeof toolInstance.onSetToolActive === 'function') {\n      toolInstance.onSetToolActive();\n    }\n    this._renderViewports();\n\n    const eventDetail: ToolActivatedEventDetail = {\n      toolGroupId: this.id,\n      toolName,\n      toolBindingsOptions,\n    };\n\n    triggerEvent(eventTarget, Events.TOOL_ACTIVATED, eventDetail);\n    this._triggerToolModeChangedEvent(toolName, Active, toolBindingsOptions);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Passive.\n   *\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   *\n   * @param toolName - tool name\n   * @param options - Options used when setting the tool as passive\n   *  - removeAllBindings: only the primary button bindings are removed but\n   *  if this parameter is set to true all bindings are removed.\n   */\n  public setToolPassive(\n    toolName: string,\n    options?: { removeAllBindings?: boolean | IToolBinding[] }\n  ): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    // We should only remove the primary button bindings and keep\n    // the other ones (Zoom on right click)\n    const prevToolOptions = this.getToolOptions(toolName);\n    const toolOptions = Object.assign(\n      {\n        bindings: prevToolOptions ? prevToolOptions.bindings : [],\n      },\n      prevToolOptions,\n      {\n        mode: Passive,\n      }\n    );\n\n    const matchBindings = Array.isArray(options?.removeAllBindings)\n      ? options.removeAllBindings\n      : this.getDefaultPrimaryBindings();\n\n    // Remove the primary button bindings without modifiers, if they exist\n    toolOptions.bindings = toolOptions.bindings.filter(\n      (binding) =>\n        options?.removeAllBindings !== true &&\n        !matchBindings.some((matchBinding) =>\n          hasSameBinding(binding, matchBinding)\n        )\n      //(binding.mouseButton !== defaultMousePrimary || binding.modifierKey)\n    );\n    // If there are other bindings, set the tool to be active\n    let mode = Passive;\n    if (toolOptions.bindings.length !== 0) {\n      mode = Active;\n      toolOptions.mode = mode;\n    }\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = mode;\n\n    if (typeof toolInstance.onSetToolPassive === 'function') {\n      toolInstance.onSetToolPassive();\n    }\n    this._renderViewports();\n\n    // It would make sense to use `toolInstance.mode` as mode when setting a tool\n    // as passive because it can still be actived in the end but `Passive` must\n    // be used when synchronizing ToolGroups so that other ToolGroups can take the\n    // same action (update tool bindings). Should the event have two different modes\n    // to handle this special case?\n    this._triggerToolModeChangedEvent(toolName, Passive);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Enabled.\n   *\n   * - Renders data if the tool has a `renderAnnotation` method..\n   *\n   * @param toolName - tool name\n   */\n  public setToolEnabled(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    const toolOptions = {\n      bindings: [],\n      mode: Enabled,\n    };\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = Enabled;\n\n    if (typeof toolInstance.onSetToolEnabled === 'function') {\n      toolInstance.onSetToolEnabled();\n    }\n\n    this._renderViewports();\n    this._triggerToolModeChangedEvent(toolName, Enabled);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Disabled.\n   *\n   * - Annotation does not render.\n   *\n   * @param toolName - tool name\n   */\n  public setToolDisabled(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    const toolOptions = {\n      bindings: [],\n      mode: Disabled,\n    };\n\n    this.restoreToolOptions[toolName] = this.toolOptions[toolName];\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = Disabled;\n\n    if (typeof toolInstance.onSetToolDisabled === 'function') {\n      toolInstance.onSetToolDisabled();\n    }\n    this._renderViewports();\n    this._triggerToolModeChangedEvent(toolName, Disabled);\n  }\n\n  /**\n   * Get the options for a given tool\n   * @param toolName - The name of the tool.\n   * @returns the tool options\n   */\n  public getToolOptions(toolName: string): ToolOptionsType {\n    const toolOptionsForTool = this.toolOptions[toolName];\n\n    if (toolOptionsForTool === undefined) {\n      return;\n    }\n\n    return toolOptionsForTool;\n  }\n\n  /**\n   * Find the name of the tool that is Active and has a primary button binding\n   * (Mouse primary click)\n   *\n   * @returns The name of the tool\n   */\n  public getActivePrimaryMouseButtonTool(): string {\n    return Object.keys(this.toolOptions).find((toolName) => {\n      const toolOptions = this.toolOptions[toolName];\n      return (\n        toolOptions.mode === Active &&\n        this._hasMousePrimaryButtonBinding(toolOptions)\n      );\n    });\n  }\n\n  public setViewportsCursorByToolName(\n    toolName: string,\n    strategyName?: string\n  ): void {\n    const cursor = this._getCursor(toolName, strategyName);\n\n    this._setCursorForViewports(cursor);\n  }\n\n  private _getCursor(toolName: string, strategyName?: string): MouseCursor {\n    let cursorName;\n    let cursor;\n\n    if (strategyName) {\n      // Try combinations with strategyName first:\n      // Try with toolName and toolInstanceName first.\n      cursorName = `${toolName}.${strategyName}`;\n\n      cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n      if (cursor) {\n        return cursor;\n      }\n    }\n\n    // Try with toolName and toolInstanceName first.\n    cursorName = `${toolName}`;\n\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n    if (cursor) {\n      return cursor;\n    }\n\n    // Try with just toolName.\n    cursorName = toolName;\n\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n    if (cursor) {\n      return cursor;\n    }\n\n    return MouseCursor.getDefinedCursor('default');\n  }\n\n  _setCursorForViewports(cursor: MouseCursor): void {\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n      initElementCursor(viewport.element, cursor);\n    });\n  }\n\n  /**\n   * Set a configuration of a tool by the given toolName.\n   * Use overwrite as true in case you want to overwrite any existing configuration (be careful, depending on config change it might break the annotation flow).\n   */\n  public setToolConfiguration(\n    toolName: string,\n    configuration: ToolConfiguration,\n    overwrite?: boolean\n  ): boolean {\n    const toolInstance = this._toolInstances[toolName];\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not present, can't set tool configuration.`\n      );\n      return false;\n    }\n\n    let _configuration;\n\n    if (overwrite) {\n      _configuration = configuration;\n    } else {\n      // We should not deep copy here, it is the job of the application to\n      // deep copy the configuration before passing it to the toolGroup, otherwise\n      // some strange appending behaviour happens for the arrays\n      _configuration = Object.assign(toolInstance.configuration, configuration);\n    }\n\n    toolInstance.configuration = _configuration;\n\n    if (typeof toolInstance.onSetToolConfiguration === 'function') {\n      toolInstance.onSetToolConfiguration();\n    }\n\n    this._renderViewports();\n\n    return true;\n  }\n\n  /**\n   * Returns the default mouse primary button.\n   */\n  public getDefaultMousePrimary(): MouseBindings {\n    return MouseBindings.Primary;\n  }\n\n  /**\n   * Gets an array of bindings that is the full primary binding.\n   * Currently this is just the primary mouse button, but may be extended in the\n   * future to include touch or other binding types.\n   */\n  public getDefaultPrimaryBindings(): IToolBinding[] {\n    return PRIMARY_BINDINGS;\n  }\n\n  /**\n   * Get the configuration of tool. It returns only the config for the given path (in case exists).\n   * ConfigurationPath is the the path of the property to get separated by '.'.\n   *\n   * @example\n   * getToolConfiguration('LengthTool', 'firstLevel.secondLevel')\n   * // get from LengthTool instance the configuration value as being LengthToolInstance[configuration][firstLevel][secondLevel]\n   */\n  getToolConfiguration(toolName: string, configurationPath?: string): any {\n    if (this._toolInstances[toolName] === undefined) {\n      console.warn(\n        `Tool ${toolName} not present, can't set tool configuration.`\n      );\n      return;\n    }\n\n    const _configuration =\n      get(this._toolInstances[toolName].configuration, configurationPath) ||\n      this._toolInstances[toolName].configuration;\n\n    return cloneDeep(_configuration);\n  }\n\n  /**\n   * Gets the name of the previously active tool.\n   * @returns The name of the previously active tool.\n   */\n  public getPrevActivePrimaryToolName(): string {\n    return this.prevActivePrimaryToolName;\n  }\n\n  /**\n   *\n   * @param newToolGroupId - Id of the new (clone) tool group\n   * @param fnToolFilter - Function to filter which tools from this tool group\n   * should be added to the new (clone) one. Example: only annotations tools\n   * can be filtered and added to the new tool group.\n   * @returns A new tool group that is a clone of this one\n   */\n  public clone(\n    newToolGroupId,\n    fnToolFilter: (toolName: string) => void = null\n  ): IToolGroup {\n    let toolGroup = ToolGroupManager.getToolGroup(newToolGroupId);\n\n    if (toolGroup) {\n      console.warn(`ToolGroup ${newToolGroupId} already exists`);\n      return toolGroup;\n    }\n\n    toolGroup = ToolGroupManager.createToolGroup(newToolGroupId);\n    fnToolFilter = fnToolFilter ?? (() => true);\n\n    Object.keys(this._toolInstances)\n      .filter(fnToolFilter)\n      .forEach((toolName) => {\n        const sourceToolInstance = this._toolInstances[toolName];\n        const sourceToolOptions = this.toolOptions[toolName];\n        const sourceToolMode = sourceToolInstance.mode;\n\n        toolGroup.addTool(toolName);\n\n        (toolGroup as unknown as ToolGroup).setToolMode(\n          toolName,\n          sourceToolMode,\n          {\n            bindings: sourceToolOptions.bindings ?? [],\n          }\n        );\n      });\n\n    return toolGroup;\n  }\n\n  /**\n   * Check if the tool binding is set to be primary mouse button.\n   * @param toolOptions - The options for the tool mode.\n   * @returns A boolean value.\n   */\n  private _hasMousePrimaryButtonBinding(toolOptions) {\n    const primaryBindings = this.getDefaultPrimaryBindings();\n    return toolOptions?.bindings?.some((binding) =>\n      primaryBindings.some((primary) => hasSameBinding(binding, primary))\n    );\n  }\n\n  /**\n   * It re-renders the viewports in the toolGroup\n   */\n  private _renderViewports(): void {\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      getRenderingEngine(renderingEngineId).renderViewport(viewportId);\n    });\n  }\n\n  /**\n   * Trigger ToolModeChangedEvent when changing the tool mode\n   * @param toolName - Tool name\n   * @param mode - Tool mode\n   * @param toolBindingsOptions - Binding options used when a tool is activated\n   */\n  private _triggerToolModeChangedEvent(\n    toolName: string,\n    mode: ToolModes,\n    toolBindingsOptions?: SetToolBindingsType\n  ): void {\n    const eventDetail: ToolModeChangedEventDetail = {\n      toolGroupId: this.id,\n      toolName,\n      mode,\n      toolBindingsOptions,\n    };\n\n    triggerEvent(eventTarget, Events.TOOL_MODE_CHANGED, eventDetail);\n  }\n}\n\n/**\n * Figure out if the two bindings are the same\n */\nfunction hasSameBinding(\n  binding1: IToolBinding,\n  binding2: IToolBinding\n): boolean {\n  if (binding1.mouseButton !== binding2.mouseButton) {\n    return false;\n  }\n  if (binding1.numTouchPoints !== binding2.numTouchPoints) {\n    return false;\n  }\n\n  return binding1.modifierKey === binding2.modifierKey;\n}\n","import { state } from '../index';\nimport ToolGroup from './ToolGroup';\nimport { IToolGroup } from '../../types';\n\n/**\n * Create a new tool group with the given name. ToolGroups are the new way\n * in Cornerstone3DTools to share tool configuration, state (enabled, disabled, etc.)\n * across a set of viewports.\n *\n * @param toolGroupId - The unique ID of the tool group.\n * @returns A reference to the tool group that was created.\n */\nfunction createToolGroup(toolGroupId: string): IToolGroup | undefined {\n  // Exit early if ID conflict\n  const toolGroupWithIdExists = state.toolGroups.some(\n    (tg) => tg.id === toolGroupId\n  );\n\n  if (toolGroupWithIdExists) {\n    console.warn(`'${toolGroupId}' already exists.`);\n    return;\n  }\n\n  const toolGroup = new ToolGroup(toolGroupId);\n\n  // Update state\n  state.toolGroups.push(toolGroup);\n\n  // Return reference\n  return toolGroup;\n}\n\nexport default createToolGroup;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Return the array of tool groups\n * @returns An array of tool groups.\n */\nfunction getAllToolGroups(): Array<IToolGroup> {\n  return state.toolGroups;\n}\n\nexport default getAllToolGroups;\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\n\n/**\n * Synchronizer callback to synchronize the camera by updating all camera\n * values.  See also zoomPanSyncCallback\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, never\n *   the same as sourceViewport.\n * @param cameraModifiedEvent - The CAMERA_MODIFIED event.\n */\nexport default function cameraSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId,\n  cameraModifiedEvent: CustomEvent\n): void {\n  const { camera } = cameraModifiedEvent.detail;\n\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n\n  tViewport.setCamera(camera);\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport cameraSyncCallback from '../callbacks/cameraSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createCameraPositionSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const cameraPositionSynchronizer = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    cameraSyncCallback\n  );\n\n  return cameraPositionSynchronizer;\n}\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\n\n/**\n * Synchronizer callback to synchronize the camera. Synchronization\n *\n * targetViewport.options.syncZoom set to false to not sync the zoom\n * targetViewport.options.syncPan set to false to not sync the pan\n\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, different\n *   from sourceViewport\n */\nexport default function presentationViewSyncCallback(\n  _synchronizerInstance,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId,\n  _sourceEvent,\n  options?: Types.ViewPresentationSelector\n): void {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n\n  const presentationView = sViewport.getViewPresentation(options);\n\n  tViewport.setView(null, presentationView);\n\n  tViewport.render();\n}\n","import { Enums } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { createSynchronizer } from '../../store/SynchronizerManager';\nimport presentationViewSyncCallback from '../callbacks/presentationViewSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback` based on presentation view\n * values and not based on absolute camera positions.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createPresentationViewSynchronizer(\n  synchronizerName: string,\n  options?: Types.ViewPresentation\n): Synchronizer {\n  const presentationView = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    presentationViewSyncCallback,\n    options\n  );\n\n  return presentationView;\n}\n","import {\n  BaseVolumeViewport,\n  getRenderingEngine,\n  StackViewport,\n  Types,\n} from '@cornerstonejs/core';\n\n/**\n * Synchronizer callback to synchronize the voi of volumeActors of identical volumes\n * in different viewports.\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport.\n * @param modifiedEvent - The COLORMAP_MODIFIED or VOI_MODIFIED event.\n * @param options - Options for the synchronizer.\n */\nexport default function voiSyncCallback(\n  synchronizerInstance,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId,\n  modifiedEvent: any,\n  options?: any\n): void {\n  const eventDetail = modifiedEvent.detail;\n  const { volumeId, range, invertStateChanged, invert, colormap } = eventDetail;\n\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `Rendering Engine does not exist: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n  const tProperties:\n    | Types.VolumeViewportProperties\n    | Types.StackViewportProperties = {\n    voiRange: range,\n  };\n\n  if (options?.syncInvertState && invertStateChanged) {\n    tProperties.invert = invert;\n  }\n  if (options?.syncColormap && colormap) {\n    tProperties.colormap = colormap;\n  }\n\n  if (tViewport instanceof BaseVolumeViewport) {\n    const isFusion = tViewport._actors && tViewport._actors.size > 1;\n    if (isFusion) {\n      tViewport.setProperties(tProperties, volumeId);\n    } else {\n      tViewport.setProperties(tProperties);\n    }\n  } else if (tViewport instanceof StackViewport) {\n    tViewport.setProperties(tProperties);\n  } else {\n    throw new Error('Viewport type not supported.');\n  }\n\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport voiSyncCallback from '../callbacks/voiSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\ntype VOISynchronizerOptions = {\n  syncInvertState: boolean;\n  syncColormap :boolean;\n};\n\n/**\n * A helper that creates a new `Synchronizer`\n * which listens to the `VOI_MODIFIED` rendering event and calls the `voiSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @param options - The options for the synchronizer. By default the voi\n * synchronizer will also sync the invert state of the volume, but this can be\n * disabled by setting `syncInvertState` to false.\n *\n * @returns A new `Synchronizer` instance.\n */\nexport default function createVOISynchronizer(\n  synchronizerName: string,\n  options: VOISynchronizerOptions\n): Synchronizer {\n  //  = { syncInvertState: true } if options is not provided or undefined or {}\n  options = Object.assign({ syncInvertState: true, syncColormap:true }, options);\n\n  const VOISynchronizer = createSynchronizer(\n    synchronizerName,\n    Enums.Events.VOI_MODIFIED,\n    voiSyncCallback,\n    {\n      auxiliaryEventNames: [Enums.Events.COLORMAP_MODIFIED],\n      ...options,\n    }\n  );\n\n  return VOISynchronizer;\n}\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\n\n/**\n * Synchronizer callback to synchronize the camera. Synchronization\n *\n * targetViewport.options.syncZoom set to false to not sync the zoom\n * targetViewport.options.syncPan set to false to not sync the pan\n\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, different\n *   from sourceViewport\n */\nexport default function zoomPanSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId\n): void {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n\n  if (options?.syncZoom !== false) {\n    const srcZoom = sViewport.getZoom();\n    // Do the zoom first, as the pan is relative to the zoom level\n    tViewport.setZoom(srcZoom);\n  }\n  if (options?.syncPan !== false) {\n    const srcPan = sViewport.getPan();\n    tViewport.setPan(srcPan);\n  }\n\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport zoomPanSyncCallback from '../callbacks/zoomPanSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createZoomPanSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const zoomPanSynchronizer = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    zoomPanSyncCallback\n  );\n\n  return zoomPanSynchronizer;\n}\n","import { vec3, mat4 } from 'gl-matrix';\nimport {\n  getRenderingEngine,\n  Types,\n  metaData,\n  utilities,\n  VolumeViewport,\n} from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\nimport { jumpToSlice } from '../../utilities';\nimport areViewportsCoplanar from './areViewportsCoplanar ';\n\nconst getSpatialRegistration = (targetId, sourceId) =>\n  utilities.spatialRegistrationMetadataProvider.get(\n    'spatialRegistrationModule',\n    targetId,\n    sourceId\n  );\n\n/**\n * Synchronizer callback to synchronize the source viewport image to the\n * target viewports closest image in its stack.\n *\n * This synchronizer does a setup (which can already be predefined as required)\n * to register the target and soruce viewports.  The registration will default\n * to the identity registration if the same FOR is present in both viewports,\n * unless the option `useInitialPosition` is set in the target viewport.\n *\n * The consuming apps using Cornerstone3D (OHIF, etc) MAY provide such data in\n * the registrationMetadataProvider to override the data here. This can be done\n * by various methods 1) Using spatialRegistrationModule inside dicom 2) assuming\n * the user has actually manually scrolled the target viewport to the correct\n * slice before initiating the synchronization 3) using some other method\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, never\n *   the same as sourceViewport.\n * @param cameraModifiedEvent - The CAMERA_MODIFIED event.\n */\nexport default async function imageSliceSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId\n): Promise<void> {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId) as\n    | Types.IVolumeViewport\n    | Types.IStackViewport;\n\n  const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n\n  if (options?.disabled) {\n    return;\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId) as\n    | Types.IVolumeViewport\n    | Types.IStackViewport;\n\n  const imageId1 = sViewport.getCurrentImageId();\n  const imagePlaneModule1 = metaData.get('imagePlaneModule', imageId1);\n  const sourceImagePositionPatient = imagePlaneModule1.imagePositionPatient;\n\n  const targetImageIds = tViewport.getImageIds();\n\n  if (!areViewportsCoplanar(sViewport, tViewport)) {\n    return;\n  }\n\n  // if the frame of reference is different we need to use the registrationMetadataProvider\n  // and add that to the imagePositionPatient of the source viewport to get the\n  // imagePositionPatient of the target viewport's closest image in its stack\n  let registrationMatrixMat4 = getSpatialRegistration(\n    targetViewport.viewportId,\n    sourceViewport.viewportId\n  );\n\n  if (!registrationMatrixMat4) {\n    const frameOfReferenceUID1 = sViewport.getFrameOfReferenceUID();\n    const frameOfReferenceUID2 = tViewport.getFrameOfReferenceUID();\n    if (\n      frameOfReferenceUID1 === frameOfReferenceUID2 &&\n      options?.useInitialPosition !== false\n    ) {\n      registrationMatrixMat4 = mat4.identity(mat4.create());\n    } else {\n      utilities.calculateViewportsSpatialRegistration(sViewport, tViewport);\n      registrationMatrixMat4 = getSpatialRegistration(\n        targetViewport.viewportId,\n        sourceViewport.viewportId\n      );\n    }\n    if (!registrationMatrixMat4) {\n      return;\n    }\n  }\n\n  // apply the registration matrix to the source viewport's imagePositionPatient\n  // to get the target viewport's imagePositionPatient\n  const targetImagePositionPatientWithRegistrationMatrix = vec3.transformMat4(\n    vec3.create(),\n    sourceImagePositionPatient,\n    registrationMatrixMat4\n  );\n\n  // find the closest image in the target viewport's stack to the\n  // targetImagePositionPatientWithRegistrationMatrix\n  const closestImageIdIndex2 = _getClosestImageIdIndex(\n    targetImagePositionPatientWithRegistrationMatrix,\n    targetImageIds\n  );\n\n  let imageIndexToSet = closestImageIdIndex2.index;\n  if (tViewport instanceof VolumeViewport) {\n    // since in case of volume viewport our stack is reversed, we should\n    // reverse the index as well\n    imageIndexToSet = targetImageIds.length - closestImageIdIndex2.index - 1;\n  }\n\n  if (\n    closestImageIdIndex2.index !== -1 &&\n    tViewport.getCurrentImageIdIndex() !== closestImageIdIndex2.index\n  ) {\n    await jumpToSlice(tViewport.element, {\n      imageIndex: imageIndexToSet,\n    });\n  }\n}\n\nfunction _getClosestImageIdIndex(targetPoint, imageIds) {\n  // todo: this does not assume orientation yet, but that can be added later\n  // todo: handle multiframe images\n  return imageIds.reduce(\n    (closestImageIdIndex, imageId, index) => {\n      const { imagePositionPatient } = metaData.get(\n        'imagePlaneModule',\n        imageId\n      );\n      const distance = vec3.distance(imagePositionPatient, targetPoint);\n\n      if (distance < closestImageIdIndex.distance) {\n        return {\n          distance,\n          index,\n        };\n      }\n      return closestImageIdIndex;\n    },\n    {\n      distance: Infinity,\n      index: -1,\n    }\n  );\n}\n","import { vec3 } from 'gl-matrix';\nimport { Types } from '@cornerstonejs/core';\n\nexport default function areViewportsCoplanar(\n  viewport1: Types.IStackViewport | Types.IVolumeViewport,\n  viewport2: Types.IStackViewport | Types.IVolumeViewport\n): boolean {\n  const { viewPlaneNormal: viewPlaneNormal1 } = viewport1.getCamera();\n  const { viewPlaneNormal: viewPlaneNormal2 } = viewport2.getCamera();\n  const dotProducts = vec3.dot(viewPlaneNormal1, viewPlaneNormal2);\n  return Math.abs(dotProducts) > 0.9;\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport imageSliceSyncCallback from '../callbacks/imageSliceSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { STACK_NEW_IMAGE, VOLUME_NEW_IMAGE } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `STACK_NEW_IMAGE`\n * rendering event and calls the `ImageSliceSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createImageSliceSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const stackImageSynchronizer = createSynchronizer(\n    synchronizerName,\n    STACK_NEW_IMAGE,\n    imageSliceSyncCallback,\n    {\n      auxiliaryEventNames: [VOLUME_NEW_IMAGE],\n    }\n  );\n\n  return stackImageSynchronizer;\n}\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\n\n/**\n * Synchronizer callback to synchronize the slab thickness.\n */\nexport default function slabThicknessSyncCallback(\n  _synchronizerInstance,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId\n): void {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n\n  const slabThickness = (\n    sViewport as Types.IVolumeViewport\n  ).getSlabThickness?.();\n  if (!slabThickness) {\n    return;\n  }\n  (tViewport as Types.IVolumeViewport).setSlabThickness?.(slabThickness);\n  tViewport.render();\n}\n","import { Enums } from '@cornerstonejs/core';\nimport { createSynchronizer } from '../../store/SynchronizerManager';\nimport slabThicknessSyncCallback from '../callbacks/slabThicknessSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback` based on presentation view\n * values and not based on absolute camera positions.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createPresentationViewSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const presentationView = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    slabThicknessSyncCallback\n  );\n\n  return presentationView;\n}\n","import createCameraPositionSynchronizer from './synchronizers/createCameraPositionSynchronizer';\nimport createPresentationViewSynchronizer from './synchronizers/createPresentationViewSynchronizer';\nimport createVOISynchronizer from './synchronizers/createVOISynchronizer';\nimport createZoomPanSynchronizer from './synchronizers/createZoomPanSynchronizer';\nimport createImageSliceSynchronizer from './synchronizers/createImageSliceSynchronizer';\nimport createSlabThicknessSynchronizer from './synchronizers/createSlabThicknessSynchronizer';\n\n// for backward compatibility\nconst createStackImageSynchronizer = createImageSliceSynchronizer;\n\nexport {\n  createCameraPositionSynchronizer,\n  createPresentationViewSynchronizer,\n  createVOISynchronizer,\n  createZoomPanSynchronizer,\n  createImageSliceSynchronizer,\n  createStackImageSynchronizer,\n  createSlabThicknessSynchronizer,\n};\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\n\nfunction drawEllipseByCoordinates(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  ellipseUID: string,\n  canvasCoordinates: [Types.Point2, Types.Point2, Types.Point2, Types.Point2],\n  options = {},\n  dataId = ''\n): void {\n  const { color, width, lineWidth, lineDash } = Object.assign(\n    {\n      color: 'rgb(0, 255, 0)',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'ellipse', ellipseUID);\n  const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const [bottom, top, left, right] = canvasCoordinates;\n\n  const w = Math.hypot(left[0] - right[0], left[1] - right[1]);\n  const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);\n  const angle =\n    (Math.atan2(left[1] - right[1], left[0] - right[0]) * 180) / Math.PI;\n\n  const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];\n  const radiusX = w / 2;\n  const radiusY = h / 2;\n\n  const attributes = {\n    cx: `${center[0]}`,\n    cy: `${center[1]}`,\n    rx: `${radiusX}`,\n    ry: `${radiusY}`,\n    stroke: color,\n    fill: 'transparent',\n    transform: `rotate(${angle} ${center[0]} ${center[1]})`,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingEllipse) {\n    setAttributesIfNecessary(attributes, existingEllipse);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgEllipseElement = document.createElementNS(svgns, 'ellipse');\n\n    if (dataId !== '') {\n      svgEllipseElement.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, svgEllipseElement);\n\n    svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);\n  }\n}\n\nexport default drawEllipseByCoordinates;\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\nimport drawEllipseByCoordinates from './drawEllipseByCoordinates';\n\nfunction drawEllipse(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  ellipseUID: string,\n  corner1: Types.Point2,\n  corner2: Types.Point2,\n  options = {},\n  dataId = ''\n) {\n  const top: Types.Point2 = [(corner1[0] + corner2[0]) / 2, corner1[1]];\n  const bottom: Types.Point2 = [(corner1[0] + corner2[0]) / 2, corner2[1]];\n  const left: Types.Point2 = [corner1[0], (corner1[1] + corner2[1]) / 2];\n  const right: Types.Point2 = [corner2[0], (corner1[1] + corner2[1]) / 2];\n\n  drawEllipseByCoordinates(\n    svgDrawingHelper,\n    annotationUID,\n    ellipseUID,\n    [bottom, top, left, right],\n    (options = {}),\n    (dataId = '')\n  );\n}\n\nexport default drawEllipse;\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\nimport drawLine from './drawLine';\n\nexport default function drawArrow(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  arrowUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {}\n): void {\n  // if length is NaN return\n  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n    return;\n  }\n\n  const { color, width, lineWidth, lineDash } = Object.assign(\n    {\n      color: 'rgb(0, 255, 0)',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // The line itself\n  drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, {\n    color,\n    width,\n    lineWidth,\n    lineDash,\n  });\n\n  // Drawing the head arrow with two lines\n  // Variables to be used when creating the arrow\n  const headLength = 10;\n  const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);\n\n  const firstLine = {\n    start: [\n      end[0] - headLength * Math.cos(angle - Math.PI / 7),\n      end[1] - headLength * Math.sin(angle - Math.PI / 7),\n    ] as Types.Point2,\n    end: end,\n  };\n\n  const secondLine = {\n    start: [\n      end[0] - headLength * Math.cos(angle + Math.PI / 7),\n      end[1] - headLength * Math.sin(angle + Math.PI / 7),\n    ] as Types.Point2,\n    end: end,\n  };\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    '2',\n    firstLine.start,\n    firstLine.end,\n    {\n      color,\n      width,\n      lineWidth,\n    }\n  );\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    '3',\n    secondLine.start,\n    secondLine.end,\n    {\n      color,\n      width,\n      lineWidth,\n    }\n  );\n}\n","import _getHash from './_getHash';\nimport _setAttributesIfNecessary from './setAttributesIfNecessary';\nimport _setNewAttributesIfValid from './setNewAttributesIfValid';\n\n// <rect x=\"120\" y=\"100\" width=\"100\" height=\"100\" />\nexport default function drawRedactionRect(\n  svgDrawingHelper: any,\n  annotationUID: string,\n  rectangleUID: string,\n  start: any,\n  end: any,\n  options = {}\n): void {\n  const {\n    color,\n    width: _width,\n    lineWidth,\n    lineDash,\n  } = Object.assign(\n    {\n      color: 'rgb(0, 255, 0)',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || _width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n  const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n  const width = Math.abs(start[0] - end[0]);\n  const height = Math.abs(start[1] - end[1]);\n\n  const attributes = {\n    x: `${tlhc[0]}`,\n    y: `${tlhc[1]}`,\n    width: `${width}`,\n    height: `${height}`,\n    stroke: color,\n    fill: 'black',\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingRect) {\n    _setAttributesIfNecessary(attributes, existingRect);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgRectElement = document.createElementNS(svgns, 'rect');\n\n    _setNewAttributesIfValid(attributes, svgRectElement);\n\n    svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n  }\n}\n","import { setElementCursor } from './elementCursor';\nimport MouseCursor from './MouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\n\n/**\n * Set the cursor for an HTML element. cursorNames can be either\n * cornerstone3DTools cursors or standard cursors.\n *\n * @param element - The element to set the cursor on.\n * @param cursorName - The name of the cursor to set. This can be\n * any cursor name either Cornerstone-specific cursor names or the standard\n * CSS cursor names.\n */\nfunction setCursorForElement(\n  element: HTMLDivElement,\n  cursorName: string\n): void {\n  let cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n  if (!cursor) {\n    cursor = MouseCursor.getDefinedCursor(cursorName);\n  }\n\n  if (!cursor) {\n    console.log(\n      `Cursor ${cursorName} is not defined either as SVG or as a standard cursor.`\n    );\n    cursor = MouseCursor.getDefinedCursor(cursorName);\n  }\n\n  setElementCursor(element, cursor);\n}\n\nexport default setCursorForElement;\n","import MouseCursor, { standardCursorNames } from './MouseCursor';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\nimport * as elementCursor from './elementCursor';\nimport setCursorForElement from './setCursorForElement';\nimport {\n  registerCursor,\n  svgCursorNames,\n  CursorSVG,\n} from './SVGCursorDescriptor';\n\n// Todo: this should be enum\nconst CursorNames = [...svgCursorNames, ...standardCursorNames];\n\nexport {\n  MouseCursor,\n  ImageMouseCursor,\n  SVGMouseCursor,\n  elementCursor,\n  registerCursor,\n  CursorNames,\n  CursorSVG,\n  setCursorForElement,\n};\n","import { ToolModes, AnnotationStyleStates } from '../../../enums';\nimport { getStyleProperty } from './helpers';\nimport { StyleSpecifier } from '../../../types/AnnotationStyle';\n\n/**\n * getFont - Returns a font string of the form \"{fontSize}px fontName\" used by `canvas`.\n * @param styleSpecifier - An object containing the specifications such as viewportId,\n * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n * met (hierarchy is checked from most specific to least specific which is\n * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n * @param state - An optional state to determine the final property name\n * @param mode - An optional mode to determine the final property name\n * @returns The font string.\n */\nfunction getFont(\n  styleSpecifier: StyleSpecifier,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string {\n  const fontSize = getStyleProperty(\n    'textBoxFontSize',\n    styleSpecifier,\n    state,\n    mode\n  );\n  const fontFamily = getStyleProperty(\n    'textBoxFontFamily',\n    styleSpecifier,\n    state,\n    mode\n  );\n\n  return `${fontSize}px ${fontFamily}`;\n}\n\nexport default getFont;\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport { getAnnotation } from './annotationState';\n\nexport type BaseEventDetail = {\n  viewportId: string;\n  renderingEngineId: string;\n};\n\n/**\n * An annotation group\n */\n\nexport default class AnnotationGroup {\n  private annotationUIDs = new Set<string>();\n  private _isVisible = true;\n\n  public visibleFilter: (uid: string) => boolean;\n\n  constructor() {\n    this.visibleFilter = this.unboundVisibleFilter.bind(this);\n  }\n\n  /**\n   * Returns true if other groups are free to hide this annotation.\n   * That is, if the annotation is not a member or is hidden.\n   */\n  protected unboundVisibleFilter(uid: string): boolean {\n    return !this._isVisible || !this.annotationUIDs.has(uid);\n  }\n\n  public has(uid: string): boolean {\n    return this.annotationUIDs.has(uid);\n  }\n  /**\n   * Sets whether annotations belonging to this group are visible or not.\n   * If there are multiple groups, then the set visible false should be called\n   * before before re-enabling the other groups with setVisible true.\n   */\n  public setVisible(\n    isVisible = true,\n    baseEvent: BaseEventDetail,\n    filter?: (annotationUID: string) => boolean\n  ) {\n    if (this._isVisible === isVisible) {\n      return;\n    }\n    this._isVisible = isVisible;\n    this.annotationUIDs.forEach((uid) => {\n      const annotation = getAnnotation(uid);\n      if (!annotation) {\n        this.annotationUIDs.delete(uid);\n        return;\n      }\n      if (annotation.isVisible === isVisible) {\n        return;\n      }\n      if (!isVisible && filter?.(uid) === false) {\n        return;\n      }\n      annotation.isVisible = isVisible;\n      const eventDetail = {\n        ...baseEvent,\n        annotation,\n      };\n      triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\n    });\n  }\n\n  public get isVisible() {\n    return this._isVisible;\n  }\n\n  /** Finds the nearby/next annotation in the given direction */\n  public findNearby(uid: string, direction: 1) {\n    const uids = [...this.annotationUIDs];\n    if (uids.length === 0) {\n      return null;\n    }\n    if (!uid) {\n      return uids[direction === 1 ? 0 : uids.length - 1];\n    }\n    const index = uids.indexOf(uid);\n    if (\n      index === -1 ||\n      index + direction < 0 ||\n      index + direction >= uids.length\n    ) {\n      return null;\n    }\n    return uids[index + direction];\n  }\n\n  /**\n   * Adds the annotation to the group\n   * Does NOT change the visibility status of the annotation.\n   */\n  public add(...annotationUIDs: string[]) {\n    annotationUIDs.forEach((annotationUID) =>\n      this.annotationUIDs.add(annotationUID)\n    );\n  }\n\n  /**\n   * Removes the annotation from the group.\n   * Does not affect the visibility status of the annotation.\n   */\n  public remove(...annotationUIDs: string[]) {\n    annotationUIDs.forEach((annotationUID) =>\n      this.annotationUIDs.delete(annotationUID)\n    );\n  }\n\n  /**\n   * Removes everything from the group.\n   */\n  public clear() {\n    this.annotationUIDs.clear();\n  }\n}\n","import * as Enums from '../../../enums';\nimport { SegmentationPublicInput } from '../../../types/SegmentationStateTypes';\nimport { validatePublic as validatePublicLabelmap } from '../../../tools/displayTools/Labelmap/validateLabelmap';\n\n/**\n * Validates the given segmentationInputArray to ensure it contains\n * appropriate representationProps for the representation type being used.\n *\n * @param segmentationInputArray - Array of segmentation inputs\n * @throws If the segmentationInputArray is undefined or empty\n * @throws If the segmentationInput.segmentationId is undefined\n * @throws If the segmentationInput.representation is undefined\n * @internal\n */\nfunction validateSegmentationInput(\n  segmentationInputArray: SegmentationPublicInput[]\n): void {\n  if (!segmentationInputArray || segmentationInputArray.length === 0) {\n    throw new Error(\n      'The segmentationInputArray is undefined or an empty array'\n    );\n  }\n\n  segmentationInputArray.forEach((segmentationInput) => {\n    if (segmentationInput.segmentationId === undefined) {\n      throw new Error(\n        'Undefined segmentationInput.segmentationId. Please provide a valid segmentationId'\n      );\n    }\n\n    if (segmentationInput.representation === undefined) {\n      throw new Error(\n        'Undefined segmentationInput.representation. Please provide a valid representation'\n      );\n    }\n\n    if (\n      segmentationInput.representation.type ===\n      Enums.SegmentationRepresentations.Labelmap\n    ) {\n      validatePublicLabelmap(segmentationInput);\n    }\n  });\n}\n\nexport default validateSegmentationInput;\n","import cloneDeep from 'lodash.clonedeep';\nimport { SegmentationPublicInput } from '../../types/SegmentationStateTypes';\nimport { validateSegmentationInput } from './helpers';\nimport { addSegmentation as addSegmentationToState } from './segmentationState';\n/**\n * Adds the segmentation to the cornerstone3D segmentation state. It should be\n * noted that segmentations are not added to any toolGroup's viewports. In order to\n * do so, you should add a \"representation\" of the segmentation to the toolGroup\n * using addSegmentationRepresentations helper. The reason for this is that there\n * can be multiple representations of the same segmentation (e.g. Labelmap and\n * Contour, etc. - Currently only Labelmap representations is supported).\n * @param segmentationInputArray - The array of segmentation input, each of which\n * defining the segmentationId and the main representation data for the segmentation.\n */\nfunction addSegmentations(\n  segmentationInputArray: SegmentationPublicInput[]\n): void {\n  validateSegmentationInput(segmentationInputArray);\n\n  segmentationInputArray.map((segInput) => {\n    const segmentationInput = cloneDeep(segInput);\n\n    addSegmentationToState(segmentationInput);\n  });\n}\n\nexport default addSegmentations;\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\n\n/**\n * Tool that pans the camera in the plane defined by the viewPlaneNormal and the viewUp.\n */\nclass PanTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n\n    const deltaPointsWorld = deltaPoints.world;\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    enabledElement.viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n    enabledElement.viewport.render();\n  }\n}\n\nPanTool.toolName = 'Pan';\nexport default PanTool;\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { Events } from '../enums';\n\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\nimport { BaseTool } from './base';\n\n/**\n * Tool that rotates the camera in the plane defined by the viewPlaneNormal and the viewUp.\n */\nclass TrackballRotateTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  mouseDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  cleanUp: () => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        rotateIncrementDegrees: 2,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this.touchDragCallback = this._dragCallback.bind(this);\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const actorEntry = viewport.getDefaultActor();\n    const actor = actorEntry.actor as Types.VolumeActor;\n    const mapper = actor.getMapper();\n    const originalSampleDistance = mapper.getSampleDistance();\n\n    mapper.setSampleDistance(originalSampleDistance * 2);\n\n    if (this.cleanUp !== null) {\n      // Clean up previous event listener\n      document.removeEventListener('mouseup', this.cleanUp);\n    }\n\n    this.cleanUp = () => {\n      mapper.setSampleDistance(originalSampleDistance);\n      viewport.render();\n    };\n\n    document.addEventListener('mouseup', this.cleanUp, { once: true });\n    return true;\n  };\n\n  rotateCamera = (viewport, centerWorld, axis, angle) => {\n    const vtkCamera = viewport.getVtkActiveCamera();\n    const viewUp = vtkCamera.getViewUp();\n    const focalPoint = vtkCamera.getFocalPoint();\n    const position = vtkCamera.getPosition();\n\n    const newPosition: Types.Point3 = [0, 0, 0];\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newViewUp: Types.Point3 = [0, 0, 0];\n\n    const transform = mat4.identity(new Float32Array(16));\n    mat4.translate(transform, transform, centerWorld);\n    mat4.rotate(transform, transform, angle, axis);\n    mat4.translate(transform, transform, [\n      -centerWorld[0],\n      -centerWorld[1],\n      -centerWorld[2],\n    ]);\n    vec3.transformMat4(newPosition, position, transform);\n    vec3.transformMat4(newFocalPoint, focalPoint, transform);\n\n    mat4.identity(transform);\n    mat4.rotate(transform, transform, angle, axis);\n    vec3.transformMat4(newViewUp, viewUp, transform);\n\n    viewport.setCamera({\n      position: newPosition,\n      viewUp: newViewUp,\n      focalPoint: newFocalPoint,\n    });\n  };\n\n  // pseudocode inspired from\n  // https://github.com/kitware/vtk-js/blob/HEAD/Sources/Interaction/Manipulators/MouseCameraUnicamRotateManipulator/index.js\n  _dragCallback(evt: EventTypes.InteractionEventType): void {\n    const { element, currentPoints, lastPoints } = evt.detail;\n    const currentPointsCanvas = currentPoints.canvas;\n    const lastPointsCanvas = lastPoints.canvas;\n    const { rotateIncrementDegrees } = this.configuration;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const width = element.clientWidth;\n    const height = element.clientHeight;\n\n    const normalizedPosition = [\n      currentPointsCanvas[0] / width,\n      currentPointsCanvas[1] / height,\n    ];\n\n    const normalizedPreviousPosition = [\n      lastPointsCanvas[0] / width,\n      lastPointsCanvas[1] / height,\n    ];\n\n    const center: Types.Point2 = [width * 0.5, height * 0.5];\n    // NOTE: centerWorld corresponds to the focal point in cornerstone3D\n    const centerWorld = viewport.canvasToWorld(center);\n    const normalizedCenter = [0.5, 0.5];\n\n    const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\n    const op = [normalizedPreviousPosition[0], 0, 0];\n    const oe = [normalizedPosition[0], 0, 0];\n\n    const opsq = op[0] ** 2;\n    const oesq = oe[0] ** 2;\n\n    const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\n    const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\n\n    const nop: Types.Point3 = [op[0], 0, lop];\n    vtkMath.normalize(nop);\n    const noe: Types.Point3 = [oe[0], 0, loe];\n    vtkMath.normalize(noe);\n\n    const dot = vtkMath.dot(nop, noe);\n    if (Math.abs(dot) > 0.0001) {\n      const angleX =\n        -2 *\n        Math.acos(vtkMath.clampValue(dot, -1.0, 1.0)) *\n        Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *\n        rotateIncrementDegrees;\n\n      const upVec = camera.viewUp;\n      const atV = camera.viewPlaneNormal;\n      const rightV: Types.Point3 = [0, 0, 0];\n      const forwardV: Types.Point3 = [0, 0, 0];\n\n      vtkMath.cross(upVec, atV, rightV);\n      vtkMath.normalize(rightV);\n\n      vtkMath.cross(atV, rightV, forwardV);\n      vtkMath.normalize(forwardV);\n      vtkMath.normalize(upVec);\n\n      this.rotateCamera(viewport, centerWorld, forwardV, angleX);\n\n      const angleY =\n        (normalizedPreviousPosition[1] - normalizedPosition[1]) *\n        rotateIncrementDegrees;\n\n      this.rotateCamera(viewport, centerWorld, rightV, angleY);\n\n      viewport.render();\n    }\n  }\n}\n\nTrackballRotateTool.toolName = 'TrackballRotate';\nexport default TrackballRotateTool;\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport { vec2 } from 'gl-matrix';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { roundNumber } from '../../utilities';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { ProbeAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport {\n  ModalityUnitOptions,\n  getModalityUnit,\n} from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * ProbeTool let you get the underlying voxel value by putting a probe in that\n * location. It will give index of the location and value of the voxel.\n * You can use ProbeTool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Probe tool's text box are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * To use the ProbeTool, you first need to add it to cornerstoneTools, then create\n * a toolGroup and add the ProbeTool to it. Finally, setToolActive on the toolGroup\n *\n * ```js\n * cornerstoneTools.addTool(ProbeTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(ProbeTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(ProbeTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n *\n */\n\nclass ProbeTool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    newAnnotation?: boolean;\n  } | null;\n  eventDispatchDetail: {\n    viewportId: string;\n    renderingEngineId: string;\n  };\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  // Not necessary for this tool but needs to be defined since it's an abstract\n  // method from the parent class.\n  isPointNearTool(): boolean {\n    return false;\n  }\n\n  toolSelectedCallback() {}\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Probe Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: { points: [<Types.Point3>[...worldPos]] },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      newAnnotation: true,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It checks if the mouse click is near ProveTool, it overwrites the baseAnnotationTool\n   * getHandleNearImagePoint method.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: ProbeAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const point = data.handles.points[0];\n    const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n\n    const near =\n      vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n\n    if (near === true) {\n      return point;\n    }\n  }\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: ProbeAnnotation\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    // Find viewports to render on drag.\n\n    this.editData = {\n      //handle, // This would be useful for other tools with more than one handle\n      annotation,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n    const { viewportId, renderingEngine } = getEnabledElement(element);\n    this.eventDispatchDetail = {\n      viewportId,\n      renderingEngineId: renderingEngine.id,\n    };\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  _dragCallback = (evt) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n\n    data.handles.points[0] = [...worldPos];\n    annotation.invalidated = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the probe annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ProbeAnnotation;\n      const annotationUID = annotation.annotationUID;\n      const data = annotation.data;\n      const point = data.handles.points[0];\n      const canvasCoordinates = viewport.worldToCanvas(point);\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color } = this.getAnnotationStyle({ annotation, styleSpecifier });\n\n      if (!data.cachedStats) {\n        data.cachedStats = {};\n      }\n\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].value == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          index: null,\n          value: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related stackViewports data if\n        // they are not at the referencedImageId, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      const handleGroupUID = '0';\n\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        [canvasCoordinates],\n        { color }\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (textLines) {\n        const textCanvasCoordinates = [\n          canvasCoordinates[0] + 6,\n          canvasCoordinates[1] - 6,\n        ];\n\n        const textUID = '0';\n        drawTextBoxSvg(\n          svgDrawingHelper,\n          annotationUID,\n          textUID,\n          textLines,\n          [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n          options\n        );\n      }\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { renderingEngineId, viewport } = enabledElement;\n    const { element } = viewport;\n\n    const worldPos = data.handles.points[0];\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const modalityUnitOptions = {\n        isPreScaled: isViewportPreScaled(viewport, targetId),\n        isSuvScaled: this.isSuvScaled(\n          viewport,\n          targetId,\n          annotation.metadata.referencedImageId\n        ),\n      };\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata } = image;\n      const scalarData =\n        'getScalarData' in image ? image.getScalarData() : image.scalarData;\n\n      const modality = metadata.Modality;\n      const index = transformWorldToIndex(imageData, worldPos);\n\n      index[0] = Math.round(index[0]);\n      index[1] = Math.round(index[1]);\n      index[2] = Math.round(index[2]);\n\n      const samplesPerPixel =\n        scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\n\n      if (csUtils.indexWithinDimensions(index, dimensions)) {\n        this.isHandleOutsideImage = false;\n        const yMultiple = dimensions[0] * samplesPerPixel;\n        const zMultiple = dimensions[0] * dimensions[1] * samplesPerPixel;\n\n        const baseIndex =\n          index[2] * zMultiple +\n          index[1] * yMultiple +\n          index[0] * samplesPerPixel;\n        let value =\n          samplesPerPixel > 2\n            ? [\n                scalarData[baseIndex],\n                scalarData[baseIndex + 1],\n                scalarData[baseIndex + 2],\n              ]\n            : scalarData[baseIndex];\n\n        // Index[2] for stackViewport is always 0, but for visualization\n        // we reset it to be imageId index\n        if (targetId.startsWith('imageId:')) {\n          const imageId = targetId.split('imageId:')[1];\n          const imageURI = csUtils.imageIdToURI(imageId);\n          const viewports = csUtils.getViewportsWithImageURI(\n            imageURI,\n            renderingEngineId\n          );\n\n          const viewport = viewports[0];\n\n          index[2] = viewport.getCurrentImageIdIndex();\n        }\n\n        let modalityUnit;\n\n        if (modality === 'US') {\n          const calibratedResults = getCalibratedProbeUnitsAndValue(image, [\n            index,\n          ]);\n\n          const hasEnhancedRegionValues = calibratedResults.values.every(\n            (value) => value !== null\n          );\n\n          value = hasEnhancedRegionValues ? calibratedResults.values : value;\n          modalityUnit = hasEnhancedRegionValues\n            ? calibratedResults.units\n            : 'raw';\n        } else {\n          modalityUnit = getModalityUnit(\n            modality,\n            annotation.metadata.referencedImageId,\n            modalityUnitOptions\n          );\n        }\n\n        cachedStats[targetId] = {\n          index,\n          value,\n          Modality: modality,\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetId] = {\n          index,\n          Modality: modality,\n        };\n      }\n\n      annotation.invalidated = false;\n\n      // Dispatching annotation modified\n      triggerAnnotationModified(annotation, element);\n    }\n\n    return cachedStats;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { index, value, modalityUnit } = cachedVolumeStats;\n\n  if (value === undefined) {\n    return;\n  }\n\n  const textLines = [];\n\n  textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n\n  if (value instanceof Array && modalityUnit instanceof Array) {\n    for (let i = 0; i < value.length; i++) {\n      textLines.push(`${roundNumber(value[i])} ${modalityUnit[i]}`);\n    }\n  } else {\n    textLines.push(`${roundNumber(value)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nProbeTool.toolName = 'Probe';\nexport default ProbeTool;\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  PublicToolProps,\n  SVGDrawingHelper,\n  ToolProps,\n} from '../../types';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport ProbeTool from './ProbeTool';\nimport { ProbeAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\n\nclass DragProbeTool extends ProbeTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    newAnnotation?: boolean;\n  } | null;\n  eventDispatchDetail: {\n    viewportId: string;\n    renderingEngineId: string;\n  };\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  postMouseDownCallback = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotation: ProbeAnnotation = {\n      invalidated: true,\n      highlighted: true,\n      isVisible: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: { points: [<Types.Point3>[...worldPos]] },\n        cachedStats: {},\n      },\n    };\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      newAnnotation: true,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  postTouchStartCallback = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    return this.postMouseDownCallback(evt);\n  };\n\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const annotations = this.filterInteractableAnnotationsForElement(\n      viewport.element,\n      [this.editData.annotation]\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const annotation = this.editData.annotation;\n    const annotationUID = annotation.annotationUID;\n    const data = annotation.data;\n    const point = data.handles.points[0];\n    const canvasCoordinates = viewport.worldToCanvas(point);\n\n    styleSpecifier.annotationUID = annotationUID;\n\n    const { color } = this.getAnnotationStyle({\n      annotation,\n      styleSpecifier,\n    });\n\n    const modalityUnitOptions = {\n      isPreScaled: isViewportPreScaled(viewport, targetId),\n\n      isSuvScaled: this.isSuvScaled(\n        viewport,\n        targetId,\n        annotation.metadata.referencedImageId\n      ),\n    };\n\n    if (\n      !data.cachedStats[targetId] ||\n      data.cachedStats[targetId].value == null\n    ) {\n      data.cachedStats[targetId] = {\n        Modality: null,\n        index: null,\n        value: null,\n      };\n\n      this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n    } else if (annotation.invalidated) {\n      this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n    }\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const handleGroupUID = '0';\n\n    drawHandlesSvg(\n      svgDrawingHelper,\n      annotationUID,\n      handleGroupUID,\n      [canvasCoordinates],\n      { color }\n    );\n\n    renderStatus = true;\n\n    const textLines = this.configuration.getTextLines(data, targetId);\n    if (textLines) {\n      const textCanvasCoordinates = [\n        canvasCoordinates[0] + 6,\n        canvasCoordinates[1] - 6,\n      ];\n\n      const textUID = '0';\n      drawTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textUID,\n        textLines,\n        [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n        this.getLinkedTextBoxStyle(styleSpecifier, annotation)\n      );\n    }\n\n    return renderStatus;\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { index, value, modalityUnit } = cachedVolumeStats;\n\n  if (value === undefined) {\n    return;\n  }\n\n  const textLines = [];\n\n  textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n\n  textLines.push(`${value.toFixed(2)} ${modalityUnit}`);\n\n  return textLines;\n}\n\nDragProbeTool.toolName = 'DragProbe';\nexport default DragProbeTool;\n","import { BaseTool } from './base';\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  cache,\n  Types,\n  utilities,\n} from '@cornerstonejs/core';\nimport { EventTypes } from '../types';\n\n// Todo: should move to configuration\nconst DEFAULT_MULTIPLIER = 4;\nconst DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;\nconst PT = 'PT';\n\n/**\n * WindowLevel tool manipulates the windowLevel applied to a viewport. It\n * provides a way to set the windowCenter and windowWidth of a viewport\n * by dragging mouse over the image.\n *\n */\nclass WindowLevelTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this.mouseDragCallback(evt);\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n\n    let volumeId,\n      lower,\n      upper,\n      modality,\n      newRange,\n      viewportsContainingVolumeUID;\n    let isPreScaled = false;\n\n    const properties = viewport.getProperties();\n    if (viewport instanceof VolumeViewport) {\n      const targetId = this.getTargetId(viewport as Types.IVolumeViewport);\n      volumeId = utilities.getVolumeId(targetId);\n      viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(\n        volumeId,\n        renderingEngine.id\n      );\n      ({ lower, upper } = properties.voiRange);\n      const volume = cache.getVolume(volumeId);\n      if (!volume) {\n        throw new Error('Volume not found ' + volumeId);\n      }\n      modality = volume.metadata.Modality;\n      isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;\n    } else if (properties.voiRange) {\n      modality = (viewport as any).modality;\n      ({ lower, upper } = properties.voiRange);\n      const { preScale = { scaled: false } } = viewport.getImageData?.() || {};\n      isPreScaled =\n        preScale.scaled && preScale.scalingParameters?.suvbw !== undefined;\n    } else {\n      throw new Error('Viewport is not a valid type');\n    }\n\n    // If modality is PT an the viewport is pre-scaled (SUV),\n    // treat it special to not include the canvas delta in\n    // the x direction. For other modalities, use the canvas delta in both\n    // directions, and if the viewport is a volumeViewport, the multiplier\n    // is calculate using the volume min and max.\n    if (modality === PT && isPreScaled) {\n      newRange = this.getPTScaledNewRange({\n        deltaPointsCanvas: deltaPoints.canvas,\n        lower,\n        upper,\n        clientHeight: element.clientHeight,\n        isPreScaled,\n        viewport,\n        volumeId,\n      });\n    } else {\n      newRange = this.getNewRange({\n        viewport,\n        deltaPointsCanvas: deltaPoints.canvas,\n        volumeId,\n        lower,\n        upper,\n      });\n    }\n\n    // If the range is not valid. Do nothing\n    if (newRange.lower >= newRange.upper) {\n      return;\n    }\n\n    viewport.setProperties({\n      voiRange: newRange,\n    });\n\n    viewport.render();\n\n    if (viewport instanceof VolumeViewport) {\n      viewportsContainingVolumeUID.forEach((vp) => {\n        if (viewport !== vp) {\n          vp.render();\n        }\n      });\n      return;\n    }\n  }\n\n  getPTScaledNewRange({\n    deltaPointsCanvas,\n    lower,\n    upper,\n    clientHeight,\n    viewport,\n    volumeId,\n    isPreScaled,\n  }) {\n    let multiplier = DEFAULT_MULTIPLIER;\n\n    if (isPreScaled) {\n      multiplier = 5 / clientHeight;\n    } else {\n      multiplier =\n        this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n        DEFAULT_MULTIPLIER;\n    }\n\n    const deltaY = deltaPointsCanvas[1];\n    const wcDelta = deltaY * multiplier;\n\n    upper -= wcDelta;\n    upper = isPreScaled ? Math.max(upper, 0.1) : upper;\n\n    return { lower, upper };\n  }\n\n  getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {\n    const multiplier =\n      this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n      DEFAULT_MULTIPLIER;\n\n    const wwDelta = deltaPointsCanvas[0] * multiplier;\n    const wcDelta = deltaPointsCanvas[1] * multiplier;\n\n    let { windowWidth, windowCenter } = utilities.windowLevel.toWindowLevel(\n      lower,\n      upper\n    );\n\n    windowWidth += wwDelta;\n    windowCenter += wcDelta;\n\n    windowWidth = Math.max(windowWidth, 1);\n\n    // Convert back to range\n    return utilities.windowLevel.toLowHighRange(windowWidth, windowCenter);\n  }\n\n  _getMultiplierFromDynamicRange(viewport, volumeId) {\n    let imageDynamicRange;\n\n    if (volumeId) {\n      const imageVolume = cache.getVolume(volumeId);\n      const { dimensions } = imageVolume;\n      const scalarData = imageVolume.getScalarData();\n      const calculatedDynamicRange = this._getImageDynamicRangeFromMiddleSlice(\n        scalarData,\n        dimensions\n      );\n      const BitsStored = imageVolume?.metadata?.BitsStored;\n      const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;\n      // Burned in Pixels often use pixel values above the BitsStored.\n      // This results in a multiplier which is way higher than what you would\n      // want in practice. Thus we take the min between the metadata dynamic\n      // range and actual middel slice dynamic range.\n      imageDynamicRange = Math.min(\n        calculatedDynamicRange,\n        metadataDynamicRange\n      );\n    } else {\n      imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);\n    }\n\n    const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;\n\n    return ratio > 1 ? Math.round(ratio) : ratio;\n  }\n\n  _getImageDynamicRangeFromViewport(viewport) {\n    const { imageData } = viewport.getImageData();\n    const dimensions = imageData.getDimensions();\n\n    if (imageData.getRange) {\n      const imageDataRange = imageData.getRange();\n      return imageDataRange[1] - imageDataRange[0];\n    }\n    let scalarData;\n    // if getScalarData is a method on imageData\n    if (imageData.getScalarData) {\n      scalarData = imageData.getScalarData();\n    } else {\n      scalarData = imageData.getPointData().getScalars();\n    }\n\n    if (dimensions[2] !== 1) {\n      return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);\n    }\n\n    let range;\n    if (scalarData.getRange) {\n      range = scalarData.getRange();\n    } else {\n      const { min, max } = this._getMinMax(scalarData, scalarData.length);\n      range = [min, max];\n    }\n\n    return range[1] - range[0];\n  }\n\n  _getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {\n    const middleSliceIndex = Math.floor(dimensions[2] / 2);\n\n    const frameLength = dimensions[0] * dimensions[1];\n    let bytesPerVoxel;\n    let TypedArrayConstructor;\n\n    if (scalarData instanceof Float32Array) {\n      bytesPerVoxel = 4;\n      TypedArrayConstructor = Float32Array;\n    } else if (scalarData instanceof Uint8Array) {\n      bytesPerVoxel = 1;\n      TypedArrayConstructor = Uint8Array;\n    } else if (scalarData instanceof Uint16Array) {\n      bytesPerVoxel = 2;\n      TypedArrayConstructor = Uint16Array;\n    } else if (scalarData instanceof Int16Array) {\n      bytesPerVoxel = 2;\n      TypedArrayConstructor = Int16Array;\n    }\n\n    const buffer = scalarData.buffer;\n    const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;\n    const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);\n\n    const { max, min } = this._getMinMax(frame, frameLength);\n\n    return max - min;\n  };\n\n  private _getMinMax(frame: Uint8Array | Float32Array, frameLength: number) {\n    let min = Infinity;\n    let max = -Infinity;\n\n    for (let i = 0; i < frameLength; i++) {\n      const voxel = frame[i];\n\n      if (voxel < min) {\n        min = voxel;\n      }\n\n      if (voxel > max) {\n        max = voxel;\n      }\n    }\n    return { max, min };\n  }\n}\n\nWindowLevelTool.toolName = 'WindowLevel';\nexport default WindowLevelTool;\n","import { vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { getEnabledElement, Types } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\n\n/**\n * ZoomTool tool manipulates the camera zoom applied to a viewport. It\n * provides a way to set the zoom of a viewport by dragging mouse over the image.\n *\n */\nclass ZoomTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  mouseDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  initialMousePosWorld: Types.Point3;\n  dirVec: Types.Point3;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        // whether zoom to the center of the image OR zoom to the mouse position\n        zoomToCenter: false,\n        minZoomScale: 0.1,\n        maxZoomScale: 30,\n        pinchToZoom: true,\n        pan: true,\n        invert: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.initialMousePosWorld = [0, 0, 0];\n    this.dirVec = [0, 0, 0];\n    if (this.configuration.pinchToZoom) {\n      this.touchDragCallback = this._pinchCallback.bind(this);\n    } else {\n      this.touchDragCallback = this._dragCallback.bind(this);\n    }\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventData = evt.detail;\n    const { element, currentPoints } = eventData;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint } = camera;\n\n    this.initialMousePosWorld = worldPos;\n\n    // The direction vector from the clicked location to the focal point\n    // which would act as the vector to translate the image (if zoomToCenter is false)\n    let dirVec = vec3.fromValues(\n      focalPoint[0] - worldPos[0],\n      focalPoint[1] - worldPos[1],\n      focalPoint[2] - worldPos[2]\n    );\n\n    dirVec = vec3.normalize(vec3.create(), dirVec);\n\n    this.dirVec = dirVec as Types.Point3;\n\n    // we should not return true here, returning true in the preMouseDownCallback\n    // means that the event is handled by the tool and no other methods\n    // can claim the event, which will result in a bug where having Zoom on primary\n    // and clicking on an annotation will not manipulate the annotation, but will\n    // instead zoom the image (which is not what we want), so we return false here\n    return false;\n  };\n\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    if (!this.configuration.pinchToZoom) {\n      return this.preMouseDownCallback(evt);\n    }\n  };\n\n  _pinchCallback(evt: EventTypes.InteractionEventType) {\n    const pointsList = (evt as EventTypes.TouchStartEventType).detail\n      .currentPointsList;\n\n    if (pointsList.length > 1) {\n      const { element, currentPoints } = evt.detail;\n      const enabledElement = getEnabledElement(element);\n      const { viewport } = enabledElement;\n      const camera = viewport.getCamera();\n      const worldPos = currentPoints.world;\n      const { focalPoint } = camera;\n      this.initialMousePosWorld = worldPos;\n      // The direction vector from the clicked location to the focal point\n      // which would act as the vector to translate the image (if zoomToCenter is false)\n      let dirVec = vec3.fromValues(\n        focalPoint[0] - worldPos[0],\n        focalPoint[1] - worldPos[1],\n        focalPoint[2] - worldPos[2]\n      );\n      dirVec = vec3.normalize(vec3.create(), dirVec);\n\n      this.dirVec = dirVec as Types.Point3;\n      if (camera.parallelProjection) {\n        this._dragParallelProjection(evt, viewport, camera, true);\n      } else {\n        this._dragPerspectiveProjection(evt, viewport, camera, true);\n      }\n      viewport.render();\n    }\n\n    if (this.configuration.pan) {\n      this._panCallback(evt);\n    }\n  }\n\n  // Takes ICornerstoneEvent, Mouse or Touch\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { element } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n\n    if (camera.parallelProjection) {\n      this._dragParallelProjection(evt, viewport, camera);\n    } else {\n      this._dragPerspectiveProjection(evt, viewport, camera);\n    }\n\n    viewport.render();\n  }\n\n  _dragParallelProjection = (\n    evt: EventTypes.InteractionEventType,\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    camera: Types.ICamera,\n    pinch = false\n  ): void => {\n    const { element, deltaPoints } = evt.detail;\n    const deltaY = pinch\n      ? (evt as EventTypes.TouchDragEventType).detail.deltaDistance.canvas\n      : deltaPoints.canvas[1];\n\n    const size = [element.clientWidth, element.clientHeight];\n    const { parallelScale, focalPoint, position } = camera;\n\n    const zoomScale = 5 / size[1];\n    const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);\n\n    const parallelScaleToSet = (1.0 - k) * parallelScale;\n\n    let focalPointToSet = focalPoint;\n    let positionToSet = position;\n\n    // if we're not zooming to the center, we need to adjust the focal point\n    // and position to set the focal point and position to the value that\n    // would simulate the zoom to the mouse position\n    if (!this.configuration.zoomToCenter) {\n      // Distance of the initial mouse position (world) to the focal point\n      // which is always the center of the canvas.\n      const distanceToCanvasCenter = vec3.distance(\n        focalPoint,\n        this.initialMousePosWorld\n      );\n\n      positionToSet = vec3.scaleAndAdd(\n        vec3.create(),\n        position,\n        this.dirVec,\n        -distanceToCanvasCenter * k\n      ) as Types.Point3;\n\n      focalPointToSet = vec3.scaleAndAdd(\n        vec3.create(),\n        focalPoint,\n        this.dirVec,\n        -distanceToCanvasCenter * k\n      ) as Types.Point3;\n    }\n\n    // If it is a regular GPU accelerated viewport, then parallel scale\n    // has a physical meaning and we can use that to determine the threshold\n    // Added spacing preset in case there is no imageData on viewport\n    const imageData = viewport.getImageData();\n    let spacing = [1, 1, 1];\n    if (imageData) {\n      spacing = imageData.spacing;\n    }\n\n    const { minZoomScale, maxZoomScale } = this.configuration;\n\n    const t = element.clientHeight * spacing[1] * 0.5;\n    const scale = t / parallelScaleToSet;\n\n    let cappedParallelScale = parallelScaleToSet;\n    let thresholdExceeded = false;\n\n    if (imageData) {\n      if (scale < minZoomScale) {\n        cappedParallelScale = t / minZoomScale;\n        thresholdExceeded = true;\n      } else if (scale >= maxZoomScale) {\n        cappedParallelScale = t / maxZoomScale;\n        thresholdExceeded = true;\n      }\n    }\n\n    viewport.setCamera({\n      parallelScale: cappedParallelScale,\n      focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,\n      position: thresholdExceeded ? position : positionToSet,\n    });\n  };\n\n  _dragPerspectiveProjection = (\n    evt: EventTypes.InteractionEventType,\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    camera: Types.ICamera,\n    pinch = false\n  ): void => {\n    const { element, deltaPoints } = evt.detail;\n    const deltaY = pinch\n      ? (evt as EventTypes.TouchDragEventType).detail.deltaDistance.canvas\n      : deltaPoints.canvas[1];\n\n    const size = [element.clientWidth, element.clientHeight];\n    const { position, focalPoint, viewPlaneNormal } = camera;\n\n    const distance = vtkMath.distance2BetweenPoints(position, focalPoint);\n    const zoomScale = Math.sqrt(distance) / size[1];\n\n    const directionOfProjection = [\n      -viewPlaneNormal[0],\n      -viewPlaneNormal[1],\n      -viewPlaneNormal[2],\n    ];\n\n    const k = this.configuration.invert\n      ? deltaY / zoomScale\n      : deltaY * zoomScale;\n\n    let tmp = k * directionOfProjection[0];\n    position[0] += tmp;\n    focalPoint[0] += tmp;\n\n    tmp = k * directionOfProjection[1];\n    position[1] += tmp;\n    focalPoint[1] += tmp;\n\n    tmp = k * directionOfProjection[2];\n    position[2] += tmp;\n    focalPoint[2] += tmp;\n\n    viewport.setCamera({ position, focalPoint });\n  };\n\n  _panCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n\n    const deltaPointsWorld = deltaPoints.world;\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    enabledElement.viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n    enabledElement.viewport.render();\n  }\n}\n\nZoomTool.toolName = 'Zoom';\nexport default ZoomTool;\n","import { getEnabledElementByIds, VolumeViewport } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { scroll } from '../utilities';\nimport { PublicToolProps, ToolProps, EventTypes } from '../types';\n\n/**\n * The StackScrollTool is a tool that allows the user to scroll through a\n * stack of images by pressing the mouse click and dragging\n */\nclass StackScrollTool extends BaseTool {\n  static toolName;\n  deltaY: number;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        invert: false,\n        debounceIfNotLoaded: true,\n        loop: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.deltaY = 1;\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { deltaPoints, viewportId, renderingEngineId } = evt.detail;\n    const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n\n    const targetId = this.getTargetId(viewport);\n    const { debounceIfNotLoaded, invert, loop } = this.configuration;\n\n    const deltaPointY = deltaPoints.canvas[1];\n    let volumeId;\n    if (viewport instanceof VolumeViewport) {\n      volumeId = targetId.split(/volumeId:|\\?/)[1];\n    }\n\n    const pixelsPerImage = this._getPixelPerImage(viewport);\n    const deltaY = deltaPointY + this.deltaY;\n\n    if (!pixelsPerImage) {\n      return;\n    }\n\n    if (Math.abs(deltaY) >= pixelsPerImage) {\n      const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);\n\n      scroll(viewport, {\n        delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,\n        volumeId,\n        debounceLoading: debounceIfNotLoaded,\n        loop: loop,\n      });\n\n      this.deltaY = deltaY % pixelsPerImage;\n    } else {\n      this.deltaY = deltaY;\n    }\n  }\n\n  _getPixelPerImage(viewport) {\n    const { element } = viewport;\n    const numberOfSlices = viewport.getNumberOfSlices();\n\n    // The Math.max here makes it easier to mouseDrag-scroll small or really large image stacks\n    return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));\n  }\n}\n\nStackScrollTool.toolName = 'StackScroll';\nexport default StackScrollTool;\n","import type { Types } from '@cornerstonejs/core';\nimport { vec2, vec3 } from 'gl-matrix';\n\ntype Line2D = [Types.Point2, Types.Point2];\ntype Line3D = [Types.Point3, Types.Point3];\ntype Line = Line2D | Line3D;\n\n/**\n * Calculates the angle between two 3D lines.\n */\nfunction angleBetween3DLines(line1: Line3D, line2: Line3D): number {\n  const [p1, p2] = line1;\n  const [p3, p4] = line2;\n\n  const v1 = vec3.sub(vec3.create(), p2, p1);\n  const v2 = vec3.sub(vec3.create(), p3, p4);\n\n  const dot = vec3.dot(v1, v2);\n\n  const v1Length = vec3.length(v1);\n  const v2Length = vec3.length(v2);\n\n  const cos = dot / (v1Length * v2Length);\n\n  const radian = Math.acos(cos);\n\n  return (radian * 180) / Math.PI;\n}\n\n/**\n * Calculates the angle between two 2D lines.\n */\nfunction angleBetween2DLines(line1: Line2D, line2: Line2D): number {\n  const [p1, p2] = line1;\n  const [p3, p4] = line2;\n\n  const v1 = vec2.sub(vec2.create(), p2, p1);\n  const v2 = vec2.sub(vec2.create(), p3, p4);\n\n  const dot = vec2.dot(v1, v2);\n  const v1Length = vec2.length(v1);\n  const v2Length = vec2.length(v2);\n\n  const cos = dot / (v1Length * v2Length);\n  return Math.acos(cos) * (180 / Math.PI);\n}\n\n/**\n * Returns the angle between two lines in degrees.\n * The angle measured is that between the vectors\n * line1[1]->line1[0] AND line2[0]->line2[1].\n * @param line1 - Line = [p1, p2]\n * @param line2 - Line = [p3, p4]\n * @returns The angle between two lines in degrees.\n */\nexport default function angleBetweenLines(line1: Line, line2: Line): number {\n  const is3D = line1[0].length === 3;\n  return is3D\n    ? angleBetween3DLines(line1 as Line3D, line2 as Line3D)\n    : angleBetween2DLines(line1 as Line2D, line2 as Line2D);\n}\n","import {\n  BaseVolumeViewport,\n  getEnabledElement,\n  Types,\n} from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport angleBetweenLines from '../utilities/math/angle/angleBetweenLines';\nimport { PublicToolProps, ToolProps, EventTypes } from '../types';\n\n/**\n * The PlanarRotateTool is a tool that allows the user to rotate\n * the image by pressing the mouse click and dragging\n */\nclass PlanarRotateTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.MouseDragEventType) => void;\n  mouseDragCallback: (evt: EventTypes.MouseDragEventType) => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this.touchDragCallback = this._dragCallback.bind(this);\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  _dragCallback(evt: EventTypes.MouseDragEventType) {\n    const { element, currentPoints, startPoints } = evt.detail;\n    const currentPointWorld = currentPoints.world;\n    const startPointWorld = startPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const camera = viewport.getCamera();\n    const width = element.clientWidth;\n    const height = element.clientHeight;\n\n    const centerCanvas: Types.Point2 = [width * 0.5, height * 0.5];\n    const centerWorld = viewport.canvasToWorld(centerCanvas);\n\n    let angle = angleBetweenLines(\n      [startPointWorld, centerWorld],\n      [centerWorld, currentPointWorld]\n    );\n\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const v1 = vec3.sub(vec3.create(), centerWorld, startPointWorld);\n    const v2 = vec3.sub(vec3.create(), centerWorld, currentPointWorld);\n    const cross = vec3.cross(vec3.create(), v1, v2);\n    if (vec3.dot(viewPlaneNormal, cross) > 0) {\n      angle = -angle;\n    }\n\n    if (Number.isNaN(angle)) {\n      return;\n    }\n\n    if (viewport instanceof BaseVolumeViewport) {\n      const rotAngle = (angle * Math.PI) / 180;\n      const rotMat = mat4.identity(new Float32Array(16));\n      mat4.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);\n      const rotatedViewUp = vec3.transformMat4(vec3.create(), viewUp, rotMat);\n      viewport.setCamera({ viewUp: rotatedViewUp as Types.Point3 });\n    } else {\n      const { rotation } = (viewport as Types.IStackViewport).getProperties();\n      viewport.setProperties({ rotation: rotation + angle });\n    }\n\n    viewport.render();\n  }\n}\n\nPlanarRotateTool.toolName = 'PlanarRotate';\nexport default PlanarRotateTool;\n","import { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { MouseWheelEventType } from '../types/EventTypes';\nimport scroll from '../utilities/scroll';\n\n/**\n * The StackScrollMouseWheelTool is a tool that allows the user to scroll through a\n * stack of images using the mouse wheel\n */\nclass StackScrollMouseWheelTool extends BaseTool {\n  static toolName;\n\n  _configuration: any;\n\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        invert: false,\n        debounceIfNotLoaded: true,\n        loop: false,\n        scrollSlabs: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  mouseWheelCallback(evt: MouseWheelEventType): void {\n    const { wheel, element } = evt.detail;\n    const { direction } = wheel;\n    const { invert } = this.configuration;\n    const { viewport } = getEnabledElement(element);\n    const delta = direction * (invert ? -1 : 1);\n\n    const targetId = this.getTargetId(viewport);\n    const volumeId = utilities.getVolumeId(targetId);\n\n    scroll(viewport, {\n      delta,\n      debounceLoading: this.configuration.debounceIfNotLoaded,\n      loop: this.configuration.loop,\n      volumeId,\n      scrollSlabs: this.configuration.scrollSlabs,\n    });\n  }\n}\n\nStackScrollMouseWheelTool.toolName = 'StackScrollMouseWheel';\nexport default StackScrollMouseWheelTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { mat4, vec3 } from 'gl-matrix';\nimport { PublicToolProps, ToolProps } from '../types';\nimport { MouseWheelEventType } from '../types/EventTypes';\n\nconst DIRECTIONS = {\n  X: [1, 0, 0],\n  Y: [0, 1, 0],\n  Z: [0, 0, 1],\n  CUSTOM: [],\n};\n\n/**\n * Tool that rotates the camera on mouse wheel.\n * It rotates the camera around the focal point, and around a defined axis. Default\n * axis is set to be Z axis, but it can be configured to any custom normalized axis.\n *\n */\nclass VolumeRotateMouseWheelTool extends BaseTool {\n  static toolName;\n  _configuration: any;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        direction: DIRECTIONS.Z,\n        rotateIncrementDegrees: 30,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  mouseWheelCallback(evt: MouseWheelEventType) {\n    // https://github.com/kitware/vtk-js/blob/HEAD/Sources/Interaction/Manipulators/MouseCameraUnicamRotateManipulator/index.js#L73\n    const { element, wheel } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { direction, rotateIncrementDegrees } = this.configuration;\n\n    const camera = viewport.getCamera();\n    const { viewUp, position, focalPoint } = camera;\n\n    const { direction: deltaY } = wheel;\n\n    const [cx, cy, cz] = focalPoint;\n    const [ax, ay, az] = direction;\n\n    //Calculate angle in radian as glmatrix rotate is in radian\n    const angle = (deltaY * (rotateIncrementDegrees * Math.PI)) / 180;\n\n    // position[3] = 1.0\n    // focalPoint[3] = 1.0\n    // viewUp[3] = 0.0\n\n    const newPosition: Types.Point3 = [0, 0, 0];\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newViewUp: Types.Point3 = [0, 0, 0];\n\n    const transform = mat4.identity(new Float32Array(16));\n    mat4.translate(transform, transform, [cx, cy, cz]);\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\n    mat4.translate(transform, transform, [-cx, -cy, -cz]);\n    vec3.transformMat4(newPosition, position, transform);\n    vec3.transformMat4(newFocalPoint, focalPoint, transform);\n\n    mat4.identity(transform);\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\n    vec3.transformMat4(<Types.Point3>newViewUp, viewUp, transform);\n\n    viewport.setCamera({\n      position: newPosition,\n      viewUp: newViewUp,\n      focalPoint: newFocalPoint,\n    });\n\n    viewport.render();\n  }\n}\n\nVolumeRotateMouseWheelTool.toolName = 'VolumeRotateMouseWheel';\nexport default VolumeRotateMouseWheelTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport } from '@cornerstonejs/core';\nimport { type Types, utilities } from '@cornerstonejs/core';\nimport { getPointInLineOfSightWithCriteria } from '../utilities/planar';\nimport jumpToWorld from '../utilities/viewport/jumpToWorld';\nimport { PublicToolProps, ToolProps } from '../types';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\n\n/**\n * On a Maximum Intensity Projection (MIP) viewport, MIPJumpToClickTool allows the\n * user to click on a point in the MIP and the targetViewportIdS (provided in the\n * tool configuration) will be scrolled (jumped) to the location of the point with\n * the highest intensity value in the MIP.\n */\nclass MIPJumpToClickTool extends BaseTool {\n  static toolName;\n\n  _bounds: any;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        targetViewportIds: [],\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Handles the click event, and move the camera's focal point the brightest\n   * point that is in the line of sight of camera. This function 1) search for the\n   * brightest point in the line of sight, 2) move the camera to that point,\n   * this triggers a cameraModified event which then 4) moves all other synced\n   * viewports and their crosshairs.\n   *\n   * @param evt - click event\n   */\n  mouseClickCallback(evt): void {\n    const { element, currentPoints } = evt.detail;\n\n    // 1. Getting the enabled element\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    // 2. Getting the target volume that is clicked on\n    const targetId = this.getTargetId(viewport as Types.IVolumeViewport);\n\n    if (!targetId.startsWith('volumeId')) {\n      throw new Error(\n        `MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`\n      );\n    }\n\n    const volumeId = utilities.getVolumeId(targetId);\n\n    // 3. Criteria function to search for the point (maximum intensity)\n    let maxIntensity = -Infinity;\n    const maxFn = (intensity, point) => {\n      if (intensity > maxIntensity) {\n        maxIntensity = intensity;\n        return point;\n      }\n    };\n\n    // 4. Search for the brightest point location in the line of sight\n    const brightestPoint = getPointInLineOfSightWithCriteria(\n      viewport as Types.IVolumeViewport,\n      currentPoints.world,\n      volumeId,\n      maxFn\n    );\n\n    if (!brightestPoint || !brightestPoint.length) {\n      return;\n    }\n\n    const { targetViewportIds, toolGroupId } = this.configuration;\n    // TODO - consider making this a utility\n    const viewports = renderingEngine.getViewports().filter((vp) => {\n      if (targetViewportIds?.indexOf(vp.id) >= 0) {\n        return true;\n      }\n      const foundToolGroup = getToolGroupForViewport(vp.id, renderingEngine.id);\n      if (toolGroupId && toolGroupId === foundToolGroup?.id) {\n        return true;\n      }\n      return false;\n    });\n\n    // 6. Update all the targetedViewports to jump\n    viewports.forEach((viewport) => {\n      // Todo: current limitation is that we cannot jump in viewports\n      // that don't belong to the renderingEngine of the source clicked viewport\n      if (viewport instanceof VolumeViewport) {\n        jumpToWorld(viewport, brightestPoint);\n      } else {\n        console.warn(\n          'Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport'\n        );\n      }\n    });\n  }\n}\n\nMIPJumpToClickTool.toolName = 'MIPJumpToClickTool';\nexport default MIPJumpToClickTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { LengthAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * LengthTool let you draw annotations that measures the length of two drawing\n * points on a slice. You can use the LengthTool in all imaging planes even in oblique\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(LengthTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(LengthTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(LengthTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n\n */\n\nclass LengthTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): LengthAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const {\n      viewPlaneNormal,\n      viewUp,\n      position: cameraPosition,\n    } = viewport.getCamera();\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        ...viewport.getViewReference({ points: [worldPos] }),\n        toolName: this.getToolName(),\n        referencedImageId,\n        viewUp,\n        cameraPosition,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: LengthAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: LengthAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: LengthAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as LengthAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      let activeHandleCanvasCoords;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].unit == null\n      ) {\n        data.cachedStats[targetId] = {\n          length: null,\n          unit: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-line`;\n      const lineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        dataId\n      );\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n\n      // Need to update to sync with annotation while unlinked/not moved\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateLength(pos1, pos2) {\n    const dx = pos1[0] - pos2[0];\n    const dy = pos1[1] - pos2[1];\n    const dz = pos1[2] - pos2[2];\n\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { element } = enabledElement.viewport;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    // TODO clean up, this doesn't need a length per volume, it has no stats derived from volumes.\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, dimensions } = image;\n\n      const index1 = transformWorldToIndex(imageData, worldPos1);\n      const index2 = transformWorldToIndex(imageData, worldPos2);\n      const handles = [index1, index2];\n      const { scale, units } = getCalibratedLengthUnitsAndScale(image, handles);\n\n      const length = this._calculateLength(worldPos1, worldPos2) / scale;\n\n      this._isInsideVolume(index1, index2, dimensions)\n        ? (this.isHandleOutsideImage = false)\n        : (this.isHandleOutsideImage = true);\n\n      // TODO -> Do we instead want to clip to the bounds of the volume and only include that portion?\n      // Seems like a lot of work for an unrealistic case. At the moment bail out of stat calculation if either\n      // corner is off the canvas.\n\n      // todo: add insideVolume calculation, for removing tool if outside\n      cachedStats[targetId] = {\n        length,\n        unit: units,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  }\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { length, unit } = cachedVolumeStats;\n\n  // Can be null on load\n  if (length === undefined || length === null || isNaN(length)) {\n    return;\n  }\n\n  const textLines = [`${roundNumber(length)} ${unit}`];\n\n  return textLines;\n}\n\nLengthTool.toolName = 'Length';\nexport default LengthTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport vtkMatrixBuilder from '@kitware/vtk.js/Common/Core/MatrixBuilder';\n\nimport { AnnotationTool } from './base';\n\nimport {\n  getEnabledElementByIds,\n  getEnabledElement,\n  utilities as csUtils,\n  Enums,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getToolGroup,\n  getToolGroupForViewport,\n} from '../store/ToolGroupManager';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../stateManagement/annotation/annotationState';\n\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n} from '../drawingSvg';\nimport { state } from '../store';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../cursors/elementCursor';\nimport liangBarksyClip from '../utilities/math/vec2/liangBarksyClip';\n\nimport * as lineSegment from '../utilities/math/line';\nimport {\n  Annotation,\n  Annotations,\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../types';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { CONSTANTS } from '@cornerstonejs/core';\n\nconst { RENDERING_DEFAULTS } = CONSTANTS;\n\n// TODO: nested config is weird\ninterface ToolConfiguration {\n  configuration?: {\n    getReferenceLineColor?: (viewportId: string) => string;\n    getReferenceLineControllable?: (viewportId: string) => boolean;\n    getReferenceLineDraggableRotatable?: (viewportId: string) => boolean;\n    getReferenceLineSlabThicknessControlsOn?: (viewportId: string) => boolean;\n    referenceLinesCenterGapRadius?: number;\n    shadow?: boolean;\n    autopan?: {\n      enabled: boolean;\n      panSize: number;\n    };\n    mobile?: {\n      enabled: boolean;\n      opacity: number;\n      handleRadius: number;\n    };\n  };\n}\n\ninterface CrosshairsAnnotation extends Annotation {\n  data: {\n    handles: {\n      rotationPoints: any[]; // rotation handles, used for rotation interactions\n      slabThicknessPoints: any[]; // slab thickness handles, used for setting the slab thickness\n      activeOperation: number | null; // 0 translation, 1 rotation handles, 2 slab thickness handles\n      toolCenter: Types.Point3;\n    };\n    activeViewportIds: string[]; // a list of the viewport ids connected to the reference lines being translated\n    viewportId: string;\n  };\n}\n\nfunction defaultReferenceLineColor() {\n  return 'rgb(0, 200, 0)';\n}\n\nfunction defaultReferenceLineControllable() {\n  return true;\n}\n\nfunction defaultReferenceLineDraggableRotatable() {\n  return true;\n}\n\nfunction defaultReferenceLineSlabThicknessControlsOn() {\n  return true;\n}\n\nconst OPERATION = {\n  DRAG: 1,\n  ROTATE: 2,\n  SLAB: 3,\n};\n\nconst EPSILON = 1e-3;\n\n/**\n * CrosshairsTool is a tool that provides reference lines between different viewports\n * of a toolGroup. Using crosshairs, you can jump to a specific location in one\n * viewport and the rest of the viewports in the toolGroup will be aligned to that location.\n * Crosshairs have grababble handles that can be used to rotate and translate the\n * reference lines. They can also be used to set the slab thickness of the viewports\n * by modifying the slab thickness handles.\n *\n */\nclass CrosshairsTool extends AnnotationTool {\n  static toolName;\n\n  toolCenter: Types.Point3 = [0, 0, 0]; // NOTE: it is assumed that all the active/linked viewports share the same crosshair center.\n  // This because the rotation operation rotates also all the other active/intersecting reference lines of the same angle\n  _getReferenceLineColor?: (viewportId: string) => string;\n  _getReferenceLineControllable?: (viewportId: string) => boolean;\n  _getReferenceLineDraggableRotatable?: (viewportId: string) => boolean;\n  _getReferenceLineSlabThicknessControlsOn?: (viewportId: string) => boolean;\n  editData: {\n    annotation: any;\n  } | null;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse'],\n      configuration: {\n        shadow: true,\n        // renders a colored circle on top right of the viewports whose color\n        // matches the color of the reference line\n        viewportIndicators: true,\n        // Auto pan is a configuration which will update pan\n        // other viewports in the toolGroup if the center of the crosshairs\n        // is outside of the viewport. This might be useful for the case\n        // when the user is scrolling through an image (usually in the zoomed view)\n        // and the crosshairs will eventually get outside of the viewport for\n        // the other viewports.\n        autoPan: {\n          enabled: false,\n          panSize: 10,\n        },\n        // radius of the area around the intersection of the planes, in which\n        // the reference lines will not be rendered. This is only used when\n        // having 3 viewports in the toolGroup.\n        referenceLinesCenterGapRadius: 20,\n        // actorUIDs for slabThickness application, if not defined, the slab thickness\n        // will be applied to all actors of the viewport\n        filterActorUIDsToSetSlabThickness: [],\n        // blend mode for slabThickness modifications\n        slabThicknessBlendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n        mobile: {\n          enabled: false,\n          opacity: 0.8,\n          handleRadius: 9,\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._getReferenceLineColor =\n      toolProps.configuration?.getReferenceLineColor ||\n      defaultReferenceLineColor;\n    this._getReferenceLineControllable =\n      toolProps.configuration?.getReferenceLineControllable ||\n      defaultReferenceLineControllable;\n    this._getReferenceLineDraggableRotatable =\n      toolProps.configuration?.getReferenceLineDraggableRotatable ||\n      defaultReferenceLineDraggableRotatable;\n    this._getReferenceLineSlabThicknessControlsOn =\n      toolProps.configuration?.getReferenceLineSlabThicknessControlsOn ||\n      defaultReferenceLineSlabThicknessControlsOn;\n  }\n\n  /**\n   * Gets the camera from the viewport, and adds crosshairs annotation for the viewport\n   * to the annotationManager. If any annotation is found in the annotationManager, it\n   * overwrites it.\n   * @param viewportInfo - The viewportInfo for the viewport to add the crosshairs\n   * @returns viewPlaneNormal and center of viewport canvas in world space\n   */\n  initializeViewport = ({\n    renderingEngineId,\n    viewportId,\n  }: Types.IViewportId): {\n    normal: Types.Point3;\n    point: Types.Point3;\n  } => {\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    const { FrameOfReferenceUID, viewport } = enabledElement;\n    const { element } = viewport;\n    const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();\n\n    // Check if there is already annotation for this viewport\n    let annotations = this._getAnnotations(enabledElement);\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (annotations.length) {\n      // If found, it will override it by removing the annotation and adding it later\n      removeAnnotation(annotations[0].annotationUID);\n    }\n\n    const annotation = {\n      highlighted: false,\n      metadata: {\n        cameraPosition: <Types.Point3>[...position],\n        cameraFocalPoint: <Types.Point3>[...focalPoint],\n        FrameOfReferenceUID,\n        toolName: this.getToolName(),\n      },\n      data: {\n        handles: {\n          rotationPoints: [], // rotation handles, used for rotation interactions\n          slabThicknessPoints: [], // slab thickness handles, used for setting the slab thickness\n          toolCenter: this.toolCenter,\n        },\n        activeOperation: null, // 0 translation, 1 rotation handles, 2 slab thickness handles\n        activeViewportIds: [], // a list of the viewport ids connected to the reference lines being translated\n        viewportId,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    return {\n      normal: viewPlaneNormal,\n      point: viewport.canvasToWorld([\n        viewport.canvas.clientWidth / 2,\n        viewport.canvas.clientHeight / 2,\n      ]),\n    };\n  };\n\n  _getViewportsInfo = () => {\n    const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    return viewports;\n  };\n\n  onSetToolActive() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    // Upon new setVolumes on viewports we need to update the crosshairs\n    // reference points in the new space, so we subscribe to the event\n    // and update the reference points accordingly.\n    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n    this._subscribeToViewportNewVolumeSet(viewportsInfo);\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolPassive() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolEnabled() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolDisabled() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n\n    // Crosshairs annotations in the state\n    // has no value when the tool is disabled\n    // since viewports can change (zoom, pan, scroll)\n    // between disabled and enabled/active states.\n    // so we just remove the annotations from the state\n    viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const annotations = this._getAnnotations(enabledElement);\n\n      if (annotations?.length) {\n        annotations.forEach((annotation) => {\n          removeAnnotation(annotation.annotationUID);\n        });\n      }\n    });\n  }\n\n  resetCrosshairs = () => {\n    const viewportsInfo = this._getViewportsInfo();\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      const { viewport } = enabledElement;\n      const { element } = viewport;\n      let annotations = this._getAnnotations(enabledElement);\n      annotations = this.filterInteractableAnnotationsForElement(\n        element,\n        annotations\n      );\n      if (annotations.length) {\n        removeAnnotation(annotations[0].annotationUID);\n      }\n    });\n\n    this.computeToolCenter(viewportsInfo);\n  };\n\n  /**\n   * When activated, it initializes the crosshairs. It begins by computing\n   * the intersection of viewports associated with the crosshairs instance.\n   * When all three views are accessible, the intersection (e.g., crosshairs tool centre)\n   * will be an exact point in space; however, with two viewports, because the\n   * intersection of two planes is a line, it assumes the last view is between the centre\n   * of the two rendering viewports.\n   * @param viewportsInfo Array of viewportInputs which each item containing {viewportId, renderingEngineId}\n   */\n  computeToolCenter = (viewportsInfo): void => {\n    if (!viewportsInfo.length || viewportsInfo.length === 1) {\n      console.warn(\n        'For crosshairs to operate, at least two viewports must be given.'\n      );\n      return;\n    }\n\n    // Todo: handle two same view viewport, or more than 3 viewports\n    const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;\n\n    // Initialize first viewport\n    const { normal: normal1, point: point1 } =\n      this.initializeViewport(firstViewport);\n\n    // Initialize second viewport\n    const { normal: normal2, point: point2 } =\n      this.initializeViewport(secondViewport);\n\n    let normal3 = <Types.Point3>[0, 0, 0];\n    let point3 = vec3.create();\n\n    // If there are three viewports\n    if (thirdViewport) {\n      ({ normal: normal3, point: point3 } =\n        this.initializeViewport(thirdViewport));\n    } else {\n      // If there are only two views (viewport) associated with the crosshairs:\n      // In this situation, we don't have a third information to find the\n      // exact intersection, and we \"assume\" the third view is looking at\n      // a location in between the first and second view centers\n      vec3.add(point3, point1, point2);\n      vec3.scale(point3, point3, 0.5);\n      vec3.cross(normal3, normal1, normal2);\n    }\n\n    // Planes of each viewport\n    const firstPlane = csUtils.planar.planeEquation(normal1, point1);\n    const secondPlane = csUtils.planar.planeEquation(normal2, point2);\n    const thirdPlane = csUtils.planar.planeEquation(normal3, point3);\n\n    // Calculating the intersection of 3 planes\n    // prettier-ignore\n    this.toolCenter = csUtils.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane)\n\n    // assuming all viewports are in the same rendering engine\n    const { renderingEngine } = getEnabledElementByIds(\n      viewportsInfo[0].viewportId,\n      viewportsInfo[0].renderingEngineId\n    );\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportsInfo.map(({ viewportId }) => viewportId)\n    );\n  };\n\n  /**\n   * addNewAnnotation acts as jump for the crosshairs tool. It is called when\n   * the user clicks on the image. It does not store the annotation in the stateManager though.\n   *\n   * @param evt - The mouse event\n   * @param interactionType - The type of interaction (e.g., mouse, touch, etc.)\n   * @returns Crosshairs annotation\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): CrosshairsAnnotation => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { currentPoints } = eventDetail;\n    const jumpWorld = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    this._jump(enabledElement, jumpWorld);\n\n    const annotations = this._getAnnotations(enabledElement);\n    const filteredAnnotations = this.filterInteractableAnnotationsForElement(\n      viewport.element,\n      annotations\n    );\n\n    // viewport Annotation\n    const { data } = filteredAnnotations[0];\n\n    const { rotationPoints } = data.handles;\n    const viewportIdArray = [];\n    // put all the draggable reference lines in the viewportIdArray\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      if (!viewportControllable || !viewportDraggableRotatable) {\n        continue;\n      }\n      viewportIdArray.push(otherViewport.id);\n      // rotation handles are two per viewport\n      i++;\n    }\n\n    data.activeViewportIds = [...viewportIdArray];\n    // set translation operation\n    data.handles.activeOperation = OPERATION.DRAG;\n\n    evt.preventDefault();\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n    return filteredAnnotations[0];\n  };\n\n  cancel = () => {\n    console.log('Not implemented yet');\n  };\n\n  /**\n   * It checks if the mouse click is near crosshairs handles, if yes\n   * it returns the handle location. If the mouse click is not near any\n   * of the handles, it does not return anything.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    let point = this._getRotationHandleNearImagePoint(\n      viewport,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (point !== null) {\n      return point;\n    }\n\n    point = this._getSlabThicknessHandleNearImagePoint(\n      viewport,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (point !== null) {\n      return point;\n    }\n  }\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    annotation.highlighted = true;\n\n    // NOTE: handle index or coordinates are not used when dragging.\n    // This because the handle points are actually generated in the renderTool and they are a derivative\n    // from the camera variables of the viewports and of the slab thickness variable.\n    // Remember that the translation and rotation operations operate on the camera\n    // variables and not really on the handles. Similar for the slab thickness.\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * It returns if the canvas point is near the provided crosshairs annotation in the\n   * provided element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CrosshairsAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    if (this._pointNearTool(element, annotation, canvasCoords, 6)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    annotation.highlighted = true;\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  onCameraModified = (evt) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const viewport = enabledElement.viewport as Types.IVolumeViewport;\n\n    const annotations = this._getAnnotations(enabledElement);\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport that the camera modified is originating from\n    const viewportAnnotation =\n      filteredToolAnnotations[0] as CrosshairsAnnotation;\n\n    if (!viewportAnnotation) {\n      return;\n    }\n\n    // -- Update the camera of other linked viewports containing the same volumeId that\n    //    have the same camera in case of translation\n    // -- Update the crosshair center in world coordinates in annotation.\n    // This is necessary because other tools can modify the position of the slices,\n    // e.g. stackScroll tool at wheel scroll. So we update the coordinates of the center always here.\n    // NOTE: rotation and slab thickness handles are created/updated in renderTool.\n    const currentCamera = viewport.getCamera();\n    const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;\n    const deltaCameraPosition: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(\n      currentCamera.position,\n      oldCameraPosition,\n      deltaCameraPosition\n    );\n\n    const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;\n    const deltaCameraFocalPoint: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(\n      currentCamera.focalPoint,\n      oldCameraFocalPoint,\n      deltaCameraFocalPoint\n    );\n\n    // updated cached \"previous\" camera position and focal point\n    viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];\n    viewportAnnotation.metadata.cameraFocalPoint = [\n      ...currentCamera.focalPoint,\n    ];\n\n    const viewportControllable = this._getReferenceLineControllable(\n      viewport.id\n    );\n    const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(\n      viewport.id\n    );\n    if (\n      !csUtils.isEqual(currentCamera.position, oldCameraPosition, 1e-3) &&\n      viewportControllable &&\n      viewportDraggableRotatable\n    ) {\n      // Is camera Modified a TRANSLATION or ROTATION?\n      let isRotation = false;\n\n      // This is guaranteed to be the same diff for both position and focal point\n      // if the camera is modified by pan, zoom, or scroll BUT for rotation of\n      // crosshairs handles it will be different.\n      const cameraModifiedSameForPosAndFocalPoint = csUtils.isEqual(\n        deltaCameraPosition,\n        deltaCameraFocalPoint,\n        1e-3\n      );\n\n      // NOTE: it is a translation if the the focal point and camera position shifts are the same\n      if (!cameraModifiedSameForPosAndFocalPoint) {\n        isRotation = true;\n      }\n\n      const cameraModifiedInPlane =\n        Math.abs(\n          vtkMath.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)\n        ) < 1e-2;\n\n      // TRANSLATION\n      // NOTE1: if the camera modified is a result of a pan or zoom don't update the crosshair center\n      // NOTE2: rotation handles are updates in renderTool\n      if (!isRotation && !cameraModifiedInPlane) {\n        this.toolCenter[0] += deltaCameraPosition[0];\n        this.toolCenter[1] += deltaCameraPosition[1];\n        this.toolCenter[2] += deltaCameraPosition[2];\n      }\n    }\n\n    // AutoPan modification\n    if (this.configuration.autoPan?.enabled) {\n      const toolGroup = getToolGroupForViewport(\n        viewport.id,\n        renderingEngine.id\n      );\n\n      const otherViewportIds = toolGroup\n        .getViewportIds()\n        .filter((id) => id !== viewport.id);\n\n      otherViewportIds.forEach((viewportId) => {\n        this._autoPanViewportIfNecessary(viewportId, renderingEngine);\n      });\n    }\n\n    const requireSameOrientation = false;\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      requireSameOrientation\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  mouseMoveCallback = (\n    evt: EventTypes.MouseMoveEventType,\n    filteredToolAnnotations: Annotations\n  ): boolean => {\n    const { element, currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n    let imageNeedsUpdate = false;\n\n    for (let i = 0; i < filteredToolAnnotations.length; i++) {\n      const annotation = filteredToolAnnotations[i] as CrosshairsAnnotation;\n\n      if (isAnnotationLocked(annotation)) {\n        continue;\n      }\n\n      const { data, highlighted } = annotation;\n      if (!data.handles) {\n        continue;\n      }\n\n      const previousActiveOperation = data.handles.activeOperation;\n      const previousActiveViewportIds =\n        data.activeViewportIds && data.activeViewportIds.length > 0\n          ? [...data.activeViewportIds]\n          : [];\n\n      // This init are necessary, because when we move the mouse they are not cleaned by _endCallback\n      data.activeViewportIds = [];\n      data.handles.activeOperation = null;\n\n      const handleNearImagePoint = this.getHandleNearImagePoint(\n        element,\n        annotation,\n        canvasCoords,\n        6\n      );\n\n      let near = false;\n      if (handleNearImagePoint) {\n        near = true;\n      } else {\n        near = this._pointNearTool(element, annotation, canvasCoords, 6);\n      }\n\n      const nearToolAndNotMarkedActive = near && !highlighted;\n      const notNearToolAndMarkedActive = !near && highlighted;\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n        annotation.highlighted = !highlighted;\n        imageNeedsUpdate = true;\n      } else if (\n        data.handles.activeOperation !== previousActiveOperation ||\n        !this._areViewportIdArraysEqual(\n          data.activeViewportIds,\n          previousActiveViewportIds\n        )\n      ) {\n        imageNeedsUpdate = true;\n      }\n    }\n\n    return imageNeedsUpdate;\n  };\n\n  filterInteractableAnnotationsForElement = (element, annotations) => {\n    if (!annotations || !annotations.length) {\n      return [];\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewportId } = enabledElement;\n\n    const viewportUIDSpecificCrosshairs = annotations.filter(\n      (annotation) => annotation.data.viewportId === viewportId\n    );\n\n    return viewportUIDSpecificCrosshairs;\n  };\n\n  /**\n   * renders the crosshairs lines and handles in the requestAnimationFrame callback\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, renderingEngine } = enabledElement;\n    const { element } = viewport;\n    const annotations = this._getAnnotations(enabledElement);\n    const camera = viewport.getCamera();\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport Annotation\n    const viewportAnnotation = filteredToolAnnotations[0];\n    if (!annotations?.length || !viewportAnnotation?.data) {\n      // No annotations yet, and didn't just create it as we likely don't have a FrameOfReference/any data loaded yet.\n      return renderStatus;\n    }\n\n    const annotationUID = viewportAnnotation.annotationUID;\n\n    // Get cameras/canvases for each of these.\n    // -- Get two world positions for this canvas in this line (e.g. the diagonal)\n    // -- Convert these world positions to this canvas.\n    // -- Extend/confine this line to fit in this canvas.\n    // -- Render this line.\n    const { clientWidth, clientHeight } = viewport.canvas;\n    const canvasDiagonalLength = Math.sqrt(\n      clientWidth * clientWidth + clientHeight * clientHeight\n    );\n    const canvasMinDimensionLength = Math.min(clientWidth, clientHeight);\n\n    const data = viewportAnnotation.data;\n    const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n\n    const otherViewportAnnotations =\n      this._filterAnnotationsByUniqueViewportOrientations(\n        enabledElement,\n        annotations\n      );\n\n    const referenceLines = [];\n\n    // get canvas information for points and lines (canvas box, canvas horizontal distances)\n    const canvasBox = [0, 0, clientWidth, clientHeight];\n\n    otherViewportAnnotations.forEach((annotation) => {\n      const { data } = annotation;\n\n      data.handles.toolCenter = this.toolCenter;\n\n      const otherViewport = renderingEngine.getViewport(\n        data.viewportId\n      ) as Types.IVolumeViewport;\n\n      const otherCamera = otherViewport.getCamera();\n\n      const otherViewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const otherViewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      const otherViewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n      // get coordinates for the reference line\n      const { clientWidth, clientHeight } = otherViewport.canvas;\n      const otherCanvasDiagonalLength = Math.sqrt(\n        clientWidth * clientWidth + clientHeight * clientHeight\n      );\n      const otherCanvasCenter: Types.Point2 = [\n        clientWidth * 0.5,\n        clientHeight * 0.5,\n      ];\n      const otherViewportCenterWorld =\n        otherViewport.canvasToWorld(otherCanvasCenter);\n\n      const direction: Types.Point3 = [0, 0, 0];\n      vtkMath.cross(\n        camera.viewPlaneNormal,\n        otherCamera.viewPlaneNormal,\n        direction\n      );\n      vtkMath.normalize(direction);\n      vtkMath.multiplyScalar(\n        <Types.Point3>direction,\n        otherCanvasDiagonalLength\n      );\n\n      const pointWorld0: Types.Point3 = [0, 0, 0];\n      vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);\n\n      const pointWorld1: Types.Point3 = [0, 0, 0];\n      vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);\n\n      const pointCanvas0 = viewport.worldToCanvas(pointWorld0);\n\n      const otherViewportCenterCanvas = viewport.worldToCanvas(\n        otherViewportCenterWorld\n      );\n\n      const canvasUnitVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasUnitVectorFromCenter,\n        pointCanvas0,\n        otherViewportCenterCanvas\n      );\n      vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n\n      // Graphic:\n      // Mid -> SlabThickness handle\n      // Short -> Rotation handle\n      //                           Long\n      //                            |\n      //                            |\n      //                            |\n      //                           Mid\n      //                            |\n      //                            |\n      //                            |\n      //                          Short\n      //                            |\n      //                            |\n      //                            |\n      // Long --- Mid--- Short--- Center --- Short --- Mid --- Long\n      //                            |\n      //                            |\n      //                            |\n      //                          Short\n      //                            |\n      //                            |\n      //                            |\n      //                           Mid\n      //                            |\n      //                            |\n      //                            |\n      //                           Long\n      const canvasVectorFromCenterLong = vec2.create();\n\n      vec2.scale(\n        canvasVectorFromCenterLong,\n        canvasUnitVectorFromCenter,\n        canvasDiagonalLength * 100\n      );\n      const canvasVectorFromCenterMid = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterMid,\n        canvasUnitVectorFromCenter,\n        // to maximize the visibility of the controls, they need to be\n        // placed at most at half the length of the shortest side of the canvas.\n        // Chosen 0.4 to have some margin to the edge.\n        canvasMinDimensionLength * 0.4\n      );\n      const canvasVectorFromCenterShort = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterShort,\n        canvasUnitVectorFromCenter,\n        // Chosen 0.2 because is half of 0.4.\n        canvasMinDimensionLength * 0.2\n      );\n      const canvasVectorFromCenterStart = vec2.create();\n      const centerGap = this.configuration.referenceLinesCenterGapRadius;\n      vec2.scale(\n        canvasVectorFromCenterStart,\n        canvasUnitVectorFromCenter,\n        // Don't put a gap if the the third view is missing\n        otherViewportAnnotations.length === 2 ? centerGap : 0\n      );\n\n      // Computing Reference start and end (4 lines per viewport in case of 3 view MPR)\n      const refLinePointOne = vec2.create();\n      const refLinePointTwo = vec2.create();\n      const refLinePointThree = vec2.create();\n      const refLinePointFour = vec2.create();\n\n      let refLinesCenter = vec2.clone(crosshairCenterCanvas);\n      if (!otherViewportDraggableRotatable || !otherViewportControllable) {\n        refLinesCenter = vec2.clone(otherViewportCenterCanvas);\n      }\n\n      vec2.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);\n      vec2.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);\n      vec2.subtract(\n        refLinePointThree,\n        refLinesCenter,\n        canvasVectorFromCenterStart\n      );\n      vec2.subtract(\n        refLinePointFour,\n        refLinesCenter,\n        canvasVectorFromCenterLong\n      );\n\n      // Clipping lines to be only included in a box (canvas), we don't want\n      // the lines goes beyond canvas\n      liangBarksyClip(refLinePointOne, refLinePointTwo, canvasBox);\n      liangBarksyClip(refLinePointThree, refLinePointFour, canvasBox);\n\n      // Computing rotation handle positions\n      const rotHandleOne = vec2.create();\n      vec2.subtract(\n        rotHandleOne,\n        crosshairCenterCanvas,\n        canvasVectorFromCenterMid\n      );\n\n      const rotHandleTwo = vec2.create();\n      vec2.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);\n\n      // Computing SlabThickness (st below) position\n\n      // SlabThickness center in canvas\n      let stHandlesCenterCanvas = vec2.clone(crosshairCenterCanvas);\n      if (\n        !otherViewportDraggableRotatable &&\n        otherViewportSlabThicknessControlsOn\n      ) {\n        stHandlesCenterCanvas = vec2.clone(otherViewportCenterCanvas);\n      }\n\n      // SlabThickness center in world\n      let stHandlesCenterWorld: Types.Point3 = [...this.toolCenter];\n      if (\n        !otherViewportDraggableRotatable &&\n        otherViewportSlabThicknessControlsOn\n      ) {\n        stHandlesCenterWorld = [...otherViewportCenterWorld];\n      }\n\n      const worldUnitVectorFromCenter: Types.Point3 = [0, 0, 0];\n      vtkMath.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);\n      vtkMath.normalize(worldUnitVectorFromCenter);\n\n      const { viewPlaneNormal } = camera;\n      // @ts-ignore // Todo: fix after vtk pr merged\n      const { matrix } = vtkMatrixBuilder\n        .buildFromDegree()\n        // @ts-ignore fix after vtk pr merged\n        .rotate(90, viewPlaneNormal);\n\n      const worldUnitOrthoVectorFromCenter: Types.Point3 = [0, 0, 0];\n      vec3.transformMat4(\n        worldUnitOrthoVectorFromCenter,\n        worldUnitVectorFromCenter,\n        matrix\n      );\n\n      const slabThicknessValue = otherViewport.getSlabThickness();\n      const worldOrthoVectorFromCenter: Types.Point3 = [\n        ...worldUnitOrthoVectorFromCenter,\n      ];\n      vtkMath.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);\n\n      const worldVerticalRefPoint: Types.Point3 = [0, 0, 0];\n      vtkMath.add(\n        stHandlesCenterWorld,\n        worldOrthoVectorFromCenter,\n        worldVerticalRefPoint\n      );\n\n      // convert vertical world distances in canvas coordinates\n      const canvasVerticalRefPoint = viewport.worldToCanvas(\n        worldVerticalRefPoint\n      );\n\n      // points for slab thickness lines\n      const canvasOrthoVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasOrthoVectorFromCenter,\n        stHandlesCenterCanvas,\n        canvasVerticalRefPoint\n      );\n\n      const stLinePointOne = vec2.create();\n      vec2.subtract(\n        stLinePointOne,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);\n\n      const stLinePointTwo = vec2.create();\n      vec2.add(\n        stLinePointTwo,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);\n\n      liangBarksyClip(stLinePointOne, stLinePointTwo, canvasBox);\n\n      const stLinePointThree = vec2.create();\n      vec2.add(\n        stLinePointThree,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.subtract(\n        stLinePointThree,\n        stLinePointThree,\n        canvasOrthoVectorFromCenter\n      );\n\n      const stLinePointFour = vec2.create();\n      vec2.subtract(\n        stLinePointFour,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.subtract(\n        stLinePointFour,\n        stLinePointFour,\n        canvasOrthoVectorFromCenter\n      );\n\n      liangBarksyClip(stLinePointThree, stLinePointFour, canvasBox);\n\n      // points for slab thickness handles\n      const stHandleOne = vec2.create();\n      const stHandleTwo = vec2.create();\n      const stHandleThree = vec2.create();\n      const stHandleFour = vec2.create();\n\n      vec2.subtract(\n        stHandleOne,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);\n      vec2.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n      vec2.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);\n      vec2.subtract(\n        stHandleThree,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);\n      vec2.add(\n        stHandleFour,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);\n\n      referenceLines.push([\n        otherViewport,\n        refLinePointOne,\n        refLinePointTwo,\n        refLinePointThree,\n        refLinePointFour,\n        stLinePointOne,\n        stLinePointTwo,\n        stLinePointThree,\n        stLinePointFour,\n        rotHandleOne,\n        rotHandleTwo,\n        stHandleOne,\n        stHandleTwo,\n        stHandleThree,\n        stHandleFour,\n      ]);\n    });\n\n    const newRtpoints = [];\n    const newStpoints = [];\n    const viewportColor = this._getReferenceLineColor(viewport.id);\n    const color =\n      viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n    referenceLines.forEach((line, lineIndex) => {\n      // get color for the reference line\n      const otherViewport = line[0];\n      const viewportColor = this._getReferenceLineColor(otherViewport.id);\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id) ||\n        this.configuration.mobile?.enabled;\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) ||\n        this.configuration.mobile?.enabled;\n      const selectedViewportId = data.activeViewportIds.find(\n        (id) => id === otherViewport.id\n      );\n\n      let color =\n        viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n      let lineWidth = 1;\n\n      const lineActive =\n        data.handles.activeOperation !== null &&\n        data.handles.activeOperation === OPERATION.DRAG &&\n        selectedViewportId;\n\n      if (lineActive) {\n        lineWidth = 2.5;\n      }\n\n      let lineUID = `${lineIndex}`;\n      if (viewportControllable && viewportDraggableRotatable) {\n        lineUID = `${lineIndex}One`;\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[1],\n          line[2],\n          {\n            color,\n            lineWidth,\n          }\n        );\n\n        lineUID = `${lineIndex}Two`;\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[3],\n          line[4],\n          {\n            color,\n            lineWidth,\n          }\n        );\n      } else {\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[2],\n          line[4],\n          {\n            color,\n            lineWidth,\n          }\n        );\n      }\n\n      if (viewportControllable) {\n        color =\n          viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n        const rotHandlesActive =\n          data.handles.activeOperation === OPERATION.ROTATE;\n        const rotationHandles = [line[9], line[10]];\n\n        const rotHandleWorldOne = [\n          viewport.canvasToWorld(line[9]),\n          otherViewport,\n          line[1],\n          line[2],\n        ];\n        const rotHandleWorldTwo = [\n          viewport.canvasToWorld(line[10]),\n          otherViewport,\n          line[3],\n          line[4],\n        ];\n        newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);\n\n        const slabThicknessHandlesActive =\n          data.handles.activeOperation === OPERATION.SLAB;\n        const slabThicknessHandles = [line[11], line[12], line[13], line[14]];\n\n        const slabThicknessHandleWorldOne = [\n          viewport.canvasToWorld(line[11]),\n          otherViewport,\n          line[5],\n          line[6],\n        ];\n        const slabThicknessHandleWorldTwo = [\n          viewport.canvasToWorld(line[12]),\n          otherViewport,\n          line[5],\n          line[6],\n        ];\n        const slabThicknessHandleWorldThree = [\n          viewport.canvasToWorld(line[13]),\n          otherViewport,\n          line[7],\n          line[8],\n        ];\n        const slabThicknessHandleWorldFour = [\n          viewport.canvasToWorld(line[14]),\n          otherViewport,\n          line[7],\n          line[8],\n        ];\n        newStpoints.push(\n          slabThicknessHandleWorldOne,\n          slabThicknessHandleWorldTwo,\n          slabThicknessHandleWorldThree,\n          slabThicknessHandleWorldFour\n        );\n\n        if (\n          (lineActive || this.configuration.mobile?.enabled) &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportDraggableRotatable &&\n          viewportSlabThicknessControlsOn\n        ) {\n          // draw all handles inactive (rotation and slab thickness)\n          let handleUID = `${lineIndex}One`;\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'circle',\n            }\n          );\n          handleUID = `${lineIndex}Two`;\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'rect',\n            }\n          );\n        } else if (\n          lineActive &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportDraggableRotatable\n        ) {\n          const handleUID = `${lineIndex}`;\n          // draw rotation handles inactive\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'circle',\n            }\n          );\n        } else if (\n          selectedViewportId &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportSlabThicknessControlsOn\n        ) {\n          const handleUID = `${lineIndex}`;\n          // draw slab thickness handles inactive\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'rect',\n            }\n          );\n        } else if (rotHandlesActive && viewportDraggableRotatable) {\n          const handleUID = `${lineIndex}`;\n          // draw all rotation handles as active\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: 2,\n              fill: color,\n              type: 'circle',\n            }\n          );\n        } else if (\n          slabThicknessHandlesActive &&\n          selectedViewportId &&\n          viewportSlabThicknessControlsOn\n        ) {\n          // draw only the slab thickness handles for the active viewport as active\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: 2,\n              fill: color,\n              type: 'rect',\n            }\n          );\n        }\n        const slabThicknessValue = otherViewport.getSlabThickness();\n        if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {\n          // draw slab thickness reference lines\n          lineUID = `${lineIndex}STOne`;\n          drawLineSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            line[5],\n            line[6],\n            {\n              color,\n              width: 1,\n              lineDash: [2, 3],\n            }\n          );\n\n          lineUID = `${lineIndex}STTwo`;\n          drawLineSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            line[7],\n            line[8],\n            {\n              color,\n              width: line,\n              lineDash: [2, 3],\n            }\n          );\n        }\n      }\n    });\n\n    renderStatus = true;\n\n    // Save new handles points in annotation\n    data.handles.rotationPoints = newRtpoints;\n    data.handles.slabThicknessPoints = newStpoints;\n\n    if (this.configuration.viewportIndicators) {\n      // render a circle to pin point the viewport color\n      // TODO: This should not be part of the tool, and definitely not part of the renderAnnotation loop\n      const referenceColorCoordinates = [\n        clientWidth * 0.95,\n        clientHeight * 0.05,\n      ] as Types.Point2;\n      const circleRadius = canvasDiagonalLength * 0.01;\n\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        referenceColorCoordinates,\n        circleRadius,\n        { color, fill: color }\n      );\n    }\n\n    return renderStatus;\n  };\n\n  _getAnnotations = (enabledElement: Types.IEnabledElement) => {\n    const { viewport } = enabledElement;\n    const annotations =\n      getAnnotations(this.getToolName(), viewport.element) || [];\n    const viewportIds = this._getViewportsInfo().map(\n      ({ viewportId }) => viewportId\n    );\n\n    // filter the annotations to only keep that are for this toolGroup\n    const toolGroupAnnotations = annotations.filter((annotation) => {\n      const { data } = annotation;\n      return viewportIds.includes(data.viewportId);\n    });\n\n    return toolGroupAnnotations;\n  };\n\n  _onNewVolume = (e: any) => {\n    const viewportsInfo = this._getViewportsInfo();\n    this.computeToolCenter(viewportsInfo);\n  };\n\n  _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const { viewport } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      const { element } = viewport;\n\n      element.removeEventListener(\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n        this._onNewVolume\n      );\n    });\n  }\n\n  _subscribeToViewportNewVolumeSet(viewports) {\n    viewports.forEach(({ viewportId, renderingEngineId }) => {\n      const { viewport } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      const { element } = viewport;\n\n      element.addEventListener(\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n        this._onNewVolume\n      );\n    });\n  }\n\n  _autoPanViewportIfNecessary(\n    viewportId: string,\n    renderingEngine: Types.IRenderingEngine\n  ): void {\n    // 1. Check if the toolCenter is outside the viewport\n    // 2. If it is outside, pan the viewport to fit in the toolCenter\n\n    const viewport = renderingEngine.getViewport(viewportId);\n    const { clientWidth, clientHeight } = viewport.canvas;\n\n    const toolCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n\n    // pan the viewport to fit the toolCenter in the direction\n    // that is out of bounds\n    const pan = this.configuration.autoPan.panSize;\n\n    const visiblePointCanvas = <Types.Point2>[\n      toolCenterCanvas[0],\n      toolCenterCanvas[1],\n    ];\n\n    if (toolCenterCanvas[0] < 0) {\n      visiblePointCanvas[0] = pan;\n    } else if (toolCenterCanvas[0] > clientWidth) {\n      visiblePointCanvas[0] = clientWidth - pan;\n    }\n\n    if (toolCenterCanvas[1] < 0) {\n      visiblePointCanvas[1] = pan;\n    } else if (toolCenterCanvas[1] > clientHeight) {\n      visiblePointCanvas[1] = clientHeight - pan;\n    }\n\n    if (\n      visiblePointCanvas[0] === toolCenterCanvas[0] &&\n      visiblePointCanvas[1] === toolCenterCanvas[1]\n    ) {\n      return;\n    }\n\n    const visiblePointWorld = viewport.canvasToWorld(visiblePointCanvas);\n\n    const deltaPointsWorld = [\n      visiblePointWorld[0] - this.toolCenter[0],\n      visiblePointWorld[1] - this.toolCenter[1],\n      visiblePointWorld[2] - this.toolCenter[2],\n    ];\n\n    const camera = viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n\n    viewport.render();\n  }\n\n  _areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {\n    if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {\n      return false;\n    }\n\n    viewportIdArrayOne.forEach((id) => {\n      let itemFound = false;\n      for (let i = 0; i < viewportIdArrayTwo.length; ++i) {\n        if (id === viewportIdArrayTwo[i]) {\n          itemFound = true;\n          break;\n        }\n      }\n      if (itemFound === false) {\n        return false;\n      }\n    });\n\n    return true;\n  };\n\n  // It filters the viewports with crosshairs and only return viewports\n  // that have different camera.\n  _getAnnotationsForViewportsWithDifferentCameras = (\n    enabledElement,\n    annotations\n  ) => {\n    const { viewportId, renderingEngine, viewport } = enabledElement;\n\n    const otherViewportAnnotations = annotations.filter(\n      (annotation) => annotation.data.viewportId !== viewportId\n    );\n\n    if (!otherViewportAnnotations || !otherViewportAnnotations.length) {\n      return [];\n    }\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, position } = camera;\n\n    const viewportsWithDifferentCameras = otherViewportAnnotations.filter(\n      (annotation) => {\n        const { viewportId } = annotation.data;\n        const targetViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfTarget = targetViewport.getCamera();\n\n        return !(\n          csUtils.isEqual(\n            cameraOfTarget.viewPlaneNormal,\n            viewPlaneNormal,\n            1e-2\n          ) && csUtils.isEqual(cameraOfTarget.position, position, 1)\n        );\n      }\n    );\n\n    return viewportsWithDifferentCameras;\n  };\n\n  _filterViewportWithSameOrientation = (\n    enabledElement,\n    referenceAnnotation,\n    annotations\n  ) => {\n    const { renderingEngine } = enabledElement;\n    const { data } = referenceAnnotation;\n    const viewport = renderingEngine.getViewport(data.viewportId);\n\n    const linkedViewportAnnotations = annotations.filter((annotation) => {\n      const { data } = annotation;\n      const otherViewport = renderingEngine.getViewport(data.viewportId);\n      const otherViewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n\n      return otherViewportControllable === true;\n    });\n\n    if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {\n      return [];\n    }\n\n    const camera = viewport.getCamera();\n    const viewPlaneNormal = camera.viewPlaneNormal;\n    vtkMath.normalize(viewPlaneNormal);\n\n    const otherViewportsAnnotationsWithSameCameraDirection =\n      linkedViewportAnnotations.filter((annotation) => {\n        const { viewportId } = annotation.data;\n        const otherViewport = renderingEngine.getViewport(viewportId);\n        const otherCamera = otherViewport.getCamera();\n        const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n        vtkMath.normalize(otherViewPlaneNormal);\n\n        return (\n          csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&\n          csUtils.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2)\n        );\n      });\n\n    return otherViewportsAnnotationsWithSameCameraDirection;\n  };\n\n  _filterAnnotationsByUniqueViewportOrientations = (\n    enabledElement,\n    annotations\n  ) => {\n    const { renderingEngine, viewport } = enabledElement;\n    const camera = viewport.getCamera();\n    const viewPlaneNormal = camera.viewPlaneNormal;\n    vtkMath.normalize(viewPlaneNormal);\n\n    const otherLinkedViewportAnnotationsFromSameScene = annotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const otherViewportControllable = this._getReferenceLineControllable(\n          otherViewport.id\n        );\n\n        return (\n          viewport !== otherViewport &&\n          // scene === otherScene &&\n          otherViewportControllable === true\n        );\n      }\n    );\n\n    const otherViewportsAnnotationsWithUniqueCameras = [];\n    // Iterate first on other viewport from the same scene linked\n    for (\n      let i = 0;\n      i < otherLinkedViewportAnnotationsFromSameScene.length;\n      ++i\n    ) {\n      const annotation = otherLinkedViewportAnnotationsFromSameScene[i];\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const otherViewportControllable = this._getReferenceLineControllable(\n          otherViewport.id\n        );\n\n        return (\n          viewport !== otherViewport &&\n          // scene === otherScene &&\n          otherViewportControllable !== true\n        );\n      }\n    );\n\n    // Iterate second on other viewport from the same scene non linked\n    for (\n      let i = 0;\n      i < otherNonLinkedViewportAnnotationsFromSameScene.length;\n      ++i\n    ) {\n      const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    // Iterate on all the viewport\n    const otherViewportAnnotations =\n      this._getAnnotationsForViewportsWithDifferentCameras(\n        enabledElement,\n        annotations\n      );\n\n    for (let i = 0; i < otherViewportAnnotations.length; ++i) {\n      const annotation = otherViewportAnnotations[i];\n      if (\n        otherViewportsAnnotationsWithUniqueCameras.some(\n          (element) => element === annotation\n        )\n      ) {\n        continue;\n      }\n\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    return otherViewportsAnnotationsWithUniqueCameras;\n  };\n\n  _checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {\n    const actors = viewport.getActors();\n    const otherViewportActors = otherViewport.getActors();\n\n    let sameScene = true;\n\n    actors.forEach((actor) => {\n      if (\n        actors.length !== otherViewportActors.length ||\n        otherViewportActors.find(({ uid }) => uid === actor.uid) === undefined\n      ) {\n        sameScene = false;\n      }\n    });\n\n    return sameScene;\n  };\n\n  _jump = (enabledElement, jumpWorld) => {\n    state.isInteractingWithTool = true;\n    const { viewport, renderingEngine } = enabledElement;\n\n    const annotations = this._getAnnotations(enabledElement);\n\n    const delta: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(jumpWorld, this.toolCenter, delta);\n\n    // TRANSLATION\n    // get the annotation of the other viewport which are parallel to the delta shift and are of the same scene\n    const otherViewportAnnotations =\n      this._getAnnotationsForViewportsWithDifferentCameras(\n        enabledElement,\n        annotations\n      );\n\n    const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n\n        const sameScene = this._checkIfViewportsRenderingSameScene(\n          viewport,\n          otherViewport\n        );\n\n        return (\n          this._getReferenceLineControllable(otherViewport.id) &&\n          this._getReferenceLineDraggableRotatable(otherViewport.id) &&\n          sameScene\n        );\n      }\n    );\n\n    if (viewportsAnnotationsToUpdate.length === 0) {\n      state.isInteractingWithTool = false;\n      return false;\n    }\n\n    this._applyDeltaShiftToSelectedViewportCameras(\n      renderingEngine,\n      viewportsAnnotationsToUpdate,\n      delta\n    );\n\n    state.isInteractingWithTool = false;\n\n    return true;\n  };\n\n  _activateModify = (element) => {\n    // mobile sometimes has lingering interaction even when touchEnd triggers\n    // this check allows for multiple handles to be active which doesn't affect\n    // tool usage.\n    state.isInteractingWithTool = !this.configuration.mobile?.enabled;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    this.editData.annotation.data.handles.activeOperation = null;\n    this.editData.annotation.data.activeViewportIds = [];\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    this.editData = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const requireSameOrientation = false;\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      requireSameOrientation\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const delta = eventDetail.deltaPoints.world;\n\n    if (\n      Math.abs(delta[0]) < 1e-3 &&\n      Math.abs(delta[1]) < 1e-3 &&\n      Math.abs(delta[2]) < 1e-3\n    ) {\n      return;\n    }\n\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const annotations = this._getAnnotations(\n      enabledElement\n    ) as CrosshairsAnnotation[];\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport Annotation\n    const viewportAnnotation = filteredToolAnnotations[0];\n    if (!viewportAnnotation) {\n      return;\n    }\n\n    const { handles } = viewportAnnotation.data;\n    const { currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n\n    if (handles.activeOperation === OPERATION.DRAG) {\n      // TRANSLATION\n      // get the annotation of the other viewport which are parallel to the delta shift and are of the same scene\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportDraggableRotatable =\n            this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportDraggableRotatable === true &&\n            viewportAnnotation.data.activeViewportIds.find(\n              (id) => id === otherViewport.id\n            )\n          );\n        }\n      );\n\n      this._applyDeltaShiftToSelectedViewportCameras(\n        renderingEngine,\n        viewportsAnnotationsToUpdate,\n        delta\n      );\n    } else if (handles.activeOperation === OPERATION.ROTATE) {\n      // ROTATION\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportDraggableRotatable =\n            this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportDraggableRotatable === true\n          );\n        }\n      );\n\n      const dir1 = vec2.create();\n      const dir2 = vec2.create();\n\n      const center: Types.Point3 = [\n        this.toolCenter[0],\n        this.toolCenter[1],\n        this.toolCenter[2],\n      ];\n\n      const centerCanvas = viewport.worldToCanvas(center);\n\n      const finalPointCanvas = eventDetail.currentPoints.canvas;\n      const originalPointCanvas = vec2.create();\n      vec2.sub(\n        originalPointCanvas,\n        finalPointCanvas,\n        eventDetail.deltaPoints.canvas\n      );\n      vec2.sub(dir1, originalPointCanvas, <vec2>centerCanvas);\n      vec2.sub(dir2, finalPointCanvas, <vec2>centerCanvas);\n\n      let angle = vec2.angle(dir1, dir2);\n\n      if (\n        this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)\n      ) {\n        angle *= -1;\n      }\n\n      // Rounding the angle to allow rotated handles to be undone\n      // If we don't round and rotate handles clockwise by 0.0131233 radians,\n      // there's no assurance that the counter-clockwise rotation occurs at\n      // precisely -0.0131233, resulting in the drawn annotations being lost.\n      angle = Math.round(angle * 100) / 100;\n\n      const rotationAxis = viewport.getCamera().viewPlaneNormal;\n      // @ts-ignore : vtkjs incorrect typing\n      const { matrix } = vtkMatrixBuilder\n        .buildFromRadian()\n        .translate(center[0], center[1], center[2])\n        // @ts-ignore\n        .rotate(angle, rotationAxis) //todo: why we are passing\n        .translate(-center[0], -center[1], -center[2]);\n\n      const otherViewportsIds = [];\n      // update camera for the other viewports.\n      // NOTE: The lines then are rendered by the onCameraModified\n      viewportsAnnotationsToUpdate.forEach((annotation) => {\n        const { data } = annotation;\n        data.handles.toolCenter = center;\n\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const camera = otherViewport.getCamera();\n        const { viewUp, position, focalPoint } = camera;\n\n        viewUp[0] += position[0];\n        viewUp[1] += position[1];\n        viewUp[2] += position[2];\n\n        vec3.transformMat4(focalPoint, focalPoint, matrix);\n        vec3.transformMat4(position, position, matrix);\n        vec3.transformMat4(viewUp, viewUp, matrix);\n\n        viewUp[0] -= position[0];\n        viewUp[1] -= position[1];\n        viewUp[2] -= position[2];\n\n        otherViewport.setCamera({\n          position,\n          viewUp,\n          focalPoint,\n        });\n        otherViewportsIds.push(otherViewport.id);\n      });\n      renderingEngine.renderViewports(otherViewportsIds);\n    } else if (handles.activeOperation === OPERATION.SLAB) {\n      // SLAB THICKNESS\n      // this should be just the active one under the mouse,\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const referenceAnnotations = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportSlabThicknessControlsOn =\n            this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportSlabThicknessControlsOn === true &&\n            viewportAnnotation.data.activeViewportIds.find(\n              (id) => id === otherViewport.id\n            )\n          );\n        }\n      );\n\n      if (referenceAnnotations.length === 0) {\n        return;\n      }\n      const viewportsAnnotationsToUpdate =\n        this._filterViewportWithSameOrientation(\n          enabledElement,\n          referenceAnnotations[0],\n          annotations\n        );\n\n      const viewportsIds = [];\n      viewportsIds.push(viewport.id);\n      viewportsAnnotationsToUpdate.forEach(\n        (annotation: CrosshairsAnnotation) => {\n          const { data } = annotation;\n\n          const otherViewport = renderingEngine.getViewport(\n            data.viewportId\n          ) as Types.IVolumeViewport;\n          const camera = otherViewport.getCamera();\n          const normal = camera.viewPlaneNormal;\n\n          const dotProd = vtkMath.dot(delta, normal);\n          const projectedDelta: Types.Point3 = [...normal];\n          vtkMath.multiplyScalar(projectedDelta, dotProd);\n\n          if (\n            Math.abs(projectedDelta[0]) > 1e-3 ||\n            Math.abs(projectedDelta[1]) > 1e-3 ||\n            Math.abs(projectedDelta[2]) > 1e-3\n          ) {\n            const mod = Math.sqrt(\n              projectedDelta[0] * projectedDelta[0] +\n                projectedDelta[1] * projectedDelta[1] +\n                projectedDelta[2] * projectedDelta[2]\n            );\n\n            const currentPoint = eventDetail.lastPoints.world;\n            const direction: Types.Point3 = [0, 0, 0];\n\n            const currentCenter: Types.Point3 = [\n              this.toolCenter[0],\n              this.toolCenter[1],\n              this.toolCenter[2],\n            ];\n\n            // use this.toolCenter only if viewportDraggableRotatable\n            const viewportDraggableRotatable =\n              this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportDraggableRotatable) {\n              const { rotationPoints } = this.editData.annotation.data.handles;\n              // Todo: what is a point uid?\n              const otherViewportRotationPoints = rotationPoints.filter(\n                (point) => point[1].uid === otherViewport.id\n              );\n              if (otherViewportRotationPoints.length === 2) {\n                const point1 = viewport.canvasToWorld(\n                  otherViewportRotationPoints[0][3]\n                );\n                const point2 = viewport.canvasToWorld(\n                  otherViewportRotationPoints[1][3]\n                );\n                vtkMath.add(point1, point2, currentCenter);\n                vtkMath.multiplyScalar(<Types.Point3>currentCenter, 0.5);\n              }\n            }\n\n            vtkMath.subtract(currentPoint, currentCenter, direction);\n            const dotProdDirection = vtkMath.dot(direction, normal);\n            const projectedDirection: Types.Point3 = [...normal];\n            vtkMath.multiplyScalar(projectedDirection, dotProdDirection);\n            const normalizedProjectedDirection: Types.Point3 = [\n              projectedDirection[0],\n              projectedDirection[1],\n              projectedDirection[2],\n            ];\n            vec3.normalize(\n              normalizedProjectedDirection,\n              normalizedProjectedDirection\n            );\n            const normalizedProjectedDelta: Types.Point3 = [\n              projectedDelta[0],\n              projectedDelta[1],\n              projectedDelta[2],\n            ];\n            vec3.normalize(normalizedProjectedDelta, normalizedProjectedDelta);\n\n            let slabThicknessValue = otherViewport.getSlabThickness();\n            if (\n              csUtils.isOpposite(\n                normalizedProjectedDirection,\n                normalizedProjectedDelta,\n                1e-3\n              )\n            ) {\n              slabThicknessValue -= mod;\n            } else {\n              slabThicknessValue += mod;\n            }\n\n            slabThicknessValue = Math.abs(slabThicknessValue);\n            slabThicknessValue = Math.max(\n              RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS,\n              slabThicknessValue\n            );\n\n            const near = this._pointNearReferenceLine(\n              viewportAnnotation,\n              canvasCoords,\n              6,\n              otherViewport\n            );\n\n            if (near) {\n              slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;\n            }\n\n            // We want to set the slabThickness for the viewport's actors but\n            // since the crosshairs tool instance has configuration regarding which\n            // actorUIDs (in case of volume -> actorUID = volumeIds) to set the\n            // slabThickness for, we need to delegate the slabThickness setting\n            // to the crosshairs tool instance of the toolGroup since configurations\n            // exist on the toolInstance and each toolGroup has its own crosshairs\n            // tool instance (Otherwise, we would need to set this filterActorUIDsToSetSlabThickness at\n            // the viewport level which makes tool and viewport state convoluted).\n            const toolGroup = getToolGroupForViewport(\n              otherViewport.id,\n              renderingEngine.id\n            );\n            const crosshairsInstance = toolGroup.getToolInstance(\n              this.getToolName()\n            );\n            crosshairsInstance.setSlabThickness(\n              otherViewport,\n              slabThicknessValue\n            );\n\n            viewportsIds.push(otherViewport.id);\n          }\n        }\n      );\n      renderingEngine.renderViewports(viewportsIds);\n    }\n  };\n\n  setSlabThickness(viewport, slabThickness) {\n    let actorUIDs;\n    const { filterActorUIDsToSetSlabThickness } = this.configuration;\n    if (\n      filterActorUIDsToSetSlabThickness &&\n      filterActorUIDsToSetSlabThickness.length > 0\n    ) {\n      actorUIDs = filterActorUIDsToSetSlabThickness;\n    }\n\n    let blendModeToUse = this.configuration.slabThicknessBlendMode;\n    if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {\n      blendModeToUse = Enums.BlendModes.COMPOSITE;\n    }\n\n    const immediate = false;\n    viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);\n    viewport.setSlabThickness(slabThickness, actorUIDs);\n  }\n\n  _isClockWise(a, b, c) {\n    // return true if the rotation is clockwise\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;\n  }\n\n  _applyDeltaShiftToSelectedViewportCameras(\n    renderingEngine,\n    viewportsAnnotationsToUpdate,\n    delta\n  ) {\n    // update camera for the other viewports.\n    // NOTE1: The lines then are rendered by the onCameraModified\n    // NOTE2: crosshair center are automatically updated in the onCameraModified event\n    viewportsAnnotationsToUpdate.forEach((annotation) => {\n      this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);\n    });\n  }\n\n  _applyDeltaShiftToViewportCamera(\n    renderingEngine: Types.IRenderingEngine,\n    annotation,\n    delta\n  ) {\n    // update camera for the other viewports.\n    // NOTE1: The lines then are rendered by the onCameraModified\n    // NOTE2: crosshair center are automatically updated in the onCameraModified event\n    const { data } = annotation;\n\n    const viewport = renderingEngine.getViewport(data.viewportId);\n    const camera = viewport.getCamera();\n    const normal = camera.viewPlaneNormal;\n\n    // Project delta over camera normal\n    // (we don't need to pan, we need only to scroll the camera as in the wheel stack scroll tool)\n    const dotProd = vtkMath.dot(delta, normal);\n    const projectedDelta: Types.Point3 = [...normal];\n    vtkMath.multiplyScalar(projectedDelta, dotProd);\n\n    if (\n      Math.abs(projectedDelta[0]) > 1e-3 ||\n      Math.abs(projectedDelta[1]) > 1e-3 ||\n      Math.abs(projectedDelta[2]) > 1e-3\n    ) {\n      const newFocalPoint: Types.Point3 = [0, 0, 0];\n      const newPosition: Types.Point3 = [0, 0, 0];\n\n      vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);\n      vtkMath.add(camera.position, projectedDelta, newPosition);\n\n      viewport.setCamera({\n        focalPoint: newFocalPoint,\n        position: newPosition,\n      });\n      viewport.render();\n    }\n  }\n\n  _pointNearReferenceLine = (\n    annotation,\n    canvasCoords,\n    proximity,\n    lineViewport\n  ) => {\n    const { data } = annotation;\n    const { rotationPoints } = data.handles;\n\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      if (otherViewport.id !== lineViewport.id) {\n        continue;\n      }\n\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const lineSegment1 = {\n        start: {\n          x: rotationPoints[i][2][0],\n          y: rotationPoints[i][2][1],\n        },\n        end: {\n          x: rotationPoints[i][3][0],\n          y: rotationPoints[i][3][1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: rotationPoints[i + 1][2][0],\n          y: rotationPoints[i + 1][2][1],\n        },\n        end: {\n          x: rotationPoints[i + 1][3][0],\n          y: rotationPoints[i + 1][3][1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        return true;\n      }\n\n      // rotation handles are two for viewport\n      i++;\n    }\n\n    return false;\n  };\n\n  _getRotationHandleNearImagePoint(\n    viewport,\n    annotation,\n    canvasCoords,\n    proximity\n  ) {\n    const { data } = annotation;\n    const { rotationPoints } = data.handles;\n\n    for (let i = 0; i < rotationPoints.length; i++) {\n      const point = rotationPoints[i][0];\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      if (!viewportDraggableRotatable) {\n        continue;\n      }\n\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n      if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n        data.handles.activeOperation = OPERATION.ROTATE;\n\n        this.editData = {\n          annotation,\n        };\n\n        return point;\n      }\n    }\n\n    return null;\n  }\n\n  _getSlabThicknessHandleNearImagePoint(\n    viewport,\n    annotation,\n    canvasCoords,\n    proximity\n  ) {\n    const { data } = annotation;\n    const { slabThicknessPoints } = data.handles;\n\n    for (let i = 0; i < slabThicknessPoints.length; i++) {\n      const point = slabThicknessPoints[i][0];\n      const otherViewport = slabThicknessPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n      if (!viewportSlabThicknessControlsOn) {\n        continue;\n      }\n\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n      if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n        data.handles.activeOperation = OPERATION.SLAB;\n\n        data.activeViewportIds = [otherViewport.id];\n\n        this.editData = {\n          annotation,\n        };\n\n        return point;\n      }\n    }\n\n    return null;\n  }\n\n  _pointNearTool(element, annotation, canvasCoords, proximity) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { clientWidth, clientHeight } = viewport.canvas;\n    const canvasDiagonalLength = Math.sqrt(\n      clientWidth * clientWidth + clientHeight * clientHeight\n    );\n    const { data } = annotation;\n\n    const { rotationPoints } = data.handles;\n    const { slabThicknessPoints } = data.handles;\n    const viewportIdArray = [];\n\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n      if (!viewportControllable || !viewportDraggableRotatable) {\n        continue;\n      }\n\n      const lineSegment1 = {\n        start: {\n          x: rotationPoints[i][2][0],\n          y: rotationPoints[i][2][1],\n        },\n        end: {\n          x: rotationPoints[i][3][0],\n          y: rotationPoints[i][3][1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: rotationPoints[i + 1][2][0],\n          y: rotationPoints[i + 1][2][1],\n        },\n        end: {\n          x: rotationPoints[i + 1][3][0],\n          y: rotationPoints[i + 1][3][1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        viewportIdArray.push(otherViewport.id);\n        data.handles.activeOperation = OPERATION.DRAG;\n      }\n\n      // rotation handles are two for viewport\n      i++;\n    }\n\n    for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {\n      const otherViewport = slabThicknessPoints[i][1];\n      if (viewportIdArray.find((id) => id === otherViewport.id)) {\n        continue;\n      }\n\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n      if (!viewportControllable || !viewportSlabThicknessControlsOn) {\n        continue;\n      }\n\n      const stPointLineCanvas1 = slabThicknessPoints[i][2];\n      const stPointLineCanvas2 = slabThicknessPoints[i][3];\n\n      const centerCanvas = vec2.create();\n      vec2.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);\n      vec2.scale(centerCanvas, centerCanvas, 0.5);\n\n      const canvasUnitVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasUnitVectorFromCenter,\n        stPointLineCanvas1,\n        centerCanvas\n      );\n      vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n\n      const canvasVectorFromCenterStart = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterStart,\n        canvasUnitVectorFromCenter,\n        canvasDiagonalLength * 0.05\n      );\n\n      const stPointLineCanvas1Start = vec2.create();\n      const stPointLineCanvas2Start = vec2.create();\n      vec2.add(\n        stPointLineCanvas1Start,\n        centerCanvas,\n        canvasVectorFromCenterStart\n      );\n      vec2.subtract(\n        stPointLineCanvas2Start,\n        centerCanvas,\n        canvasVectorFromCenterStart\n      );\n\n      const lineSegment1 = {\n        start: {\n          x: stPointLineCanvas1Start[0],\n          y: stPointLineCanvas1Start[1],\n        },\n        end: {\n          x: stPointLineCanvas1[0],\n          y: stPointLineCanvas1[1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: stPointLineCanvas2Start[0],\n          y: stPointLineCanvas2Start[1],\n        },\n        end: {\n          x: stPointLineCanvas2[0],\n          y: stPointLineCanvas2[1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        viewportIdArray.push(otherViewport.id); // we still need this to draw inactive slab thickness handles\n        data.handles.activeOperation = null; // no operation\n      }\n\n      // slab thickness handles are in couples\n      i++;\n    }\n\n    data.activeViewportIds = [...viewportIdArray];\n\n    this.editData = {\n      annotation,\n    };\n\n    return data.handles.activeOperation === OPERATION.DRAG ? true : false;\n  }\n}\n\nCrosshairsTool.toolName = 'Crosshairs';\nexport default CrosshairsTool;\n","import { vec3 } from 'gl-matrix';\nimport {\n  getRenderingEngines,\n  CONSTANTS,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { type Types, getEnabledElementByViewportId } from '@cornerstonejs/core';\n\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\n\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { PublicToolProps, ToolProps, SVGDrawingHelper } from '../types';\nimport { ReferenceLineAnnotation } from '../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\n\nconst { EPSILON } = CONSTANTS;\n\n/**\n * @public\n */\nclass ReferenceLines extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    renderingEngine: any;\n    sourceViewportId: string;\n    annotation: ReferenceLineAnnotation;\n  } | null = {} as any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        sourceViewportId: '',\n        showFullDimension: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    // this._throttledCalculateCachedStats = throttle(\n    //   this._calculateCachedStats,\n    //   100,\n    //   { trailing: true }\n    // );\n  }\n\n  _init = (): void => {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    // Todo: handle this case where it is too soon to get the rendering engine\n    if (!renderingEngine) {\n      return;\n    }\n\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n\n    const sourceViewport = renderingEngine.getViewport(\n      this.configuration.sourceViewportId\n    ) as Types.IVolumeViewport;\n\n    if (!sourceViewport?.getImageData()) {\n      return;\n    }\n\n    const { element } = sourceViewport;\n    const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();\n\n    const sourceViewportCanvasCornersInWorld =\n      csUtils.getViewportImageCornersInWorld(sourceViewport);\n\n    let annotation = this.editData.annotation;\n    const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();\n\n    if (!annotation) {\n      const newAnnotation: ReferenceLineAnnotation = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n          toolName: this.getToolName(),\n          viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n          viewUp: <Types.Point3>[...viewUp],\n          FrameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          handles: {\n            points: sourceViewportCanvasCornersInWorld,\n          },\n        },\n      };\n\n      addAnnotation(newAnnotation, element);\n      annotation = newAnnotation;\n    } else {\n      this.editData.annotation.data.handles.points =\n        sourceViewportCanvasCornersInWorld;\n    }\n\n    this.editData = {\n      sourceViewportId: sourceViewport.id,\n      renderingEngine,\n      annotation,\n    };\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewports\n        .filter((viewport) => viewport.id !== sourceViewport.id)\n        .map((viewport) => viewport.id)\n    );\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onSetToolConfiguration = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    // If the camera is modified, we need to update the reference lines\n    // we really don't care which viewport triggered the\n    // camera modification, since we want to update all of them\n    // with respect to the targetViewport\n    this._init();\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const { viewport: targetViewport } = enabledElement;\n    const { annotation, sourceViewportId } = this.editData;\n\n    let renderStatus = false;\n\n    // we need to grab the viewport again since there might have been\n    // a change in the viewport state since the last time we cached it\n    const { viewport: sourceViewport } =\n      getEnabledElementByViewportId(sourceViewportId) || {};\n\n    if (!sourceViewport) {\n      return renderStatus;\n    }\n\n    if (sourceViewport.id === targetViewport.id) {\n      // If the source viewport is the same as the current viewport, we don't need to render\n      return renderStatus;\n    }\n\n    if (!annotation || !annotation?.data?.handles?.points) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // top left world, top right world, bottom right world, bottom left world\n    const topLeft = annotation.data.handles.points[0];\n    const topRight = annotation.data.handles.points[1];\n    const bottomLeft = annotation.data.handles.points[2];\n    const bottomRight = annotation.data.handles.points[3];\n\n    const { focalPoint, viewPlaneNormal, viewUp } = targetViewport.getCamera();\n    const { viewPlaneNormal: sourceViewPlaneNormal } =\n      sourceViewport.getCamera();\n\n    if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {\n      // If the source and target viewports are parallel, we don't need to render\n      return renderStatus;\n    }\n\n    const targetViewportPlane = csUtils.planar.planeEquation(\n      viewPlaneNormal,\n      focalPoint\n    );\n\n    // check if the topLeft and bottomLeft line is parallel to the viewUp\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n    const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n\n    let pointSetToUse = pointSet1;\n\n    let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n    topBottomVec = vec3.normalize(vec3.create(), topBottomVec) as Types.Point3;\n\n    let topRightVec = vec3.subtract(vec3.create(), pointSet1[2], pointSet1[0]);\n    topRightVec = vec3.normalize(vec3.create(), topRightVec);\n\n    const newNormal = vec3.cross(\n      vec3.create(),\n      topBottomVec,\n      topRightVec\n    ) as Types.Point3;\n\n    if (this.isParallel(newNormal, viewPlaneNormal)) {\n      return renderStatus;\n    }\n\n    // check if it is perpendicular to the viewPlaneNormal which means\n    // the line does not intersect the viewPlaneNormal\n    if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n      // 'use pointSet2';\n      pointSetToUse = pointSet2;\n    }\n\n    const lineStartWorld = csUtils.planar.linePlaneIntersection(\n      pointSetToUse[0],\n      pointSetToUse[1],\n      targetViewportPlane\n    );\n\n    const lineEndWorld = csUtils.planar.linePlaneIntersection(\n      pointSetToUse[2],\n      pointSetToUse[3],\n      targetViewportPlane\n    );\n    const { annotationUID } = annotation;\n\n    styleSpecifier.annotationUID = annotationUID;\n    const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n    const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n    const color = this.getStyle('color', styleSpecifier, annotation);\n    const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n    let canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) =>\n      targetViewport.worldToCanvas(world)\n    );\n\n    if (this.configuration.showFullDimension) {\n      canvasCoordinates = this.handleFullDimension(\n        targetViewport,\n        lineStartWorld,\n        viewPlaneNormal,\n        viewUp,\n        lineEndWorld,\n        canvasCoordinates\n      );\n    }\n\n    if (canvasCoordinates.length < 2) {\n      return renderStatus;\n    }\n\n    const dataId = `${annotationUID}-line`;\n    const lineUID = '1';\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      lineUID,\n      canvasCoordinates[0],\n      canvasCoordinates[1],\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      dataId\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n\n  isPerpendicular = (vec1: Types.Point3, vec2: Types.Point3): boolean => {\n    const dot = vec3.dot(vec1, vec2);\n    return Math.abs(dot) < EPSILON;\n  };\n\n  private handleFullDimension(\n    targetViewport: Types.IStackViewport | Types.IVolumeViewport,\n    lineStartWorld: Types.Point3,\n    viewPlaneNormal: Types.Point3,\n    viewUp: Types.Point3,\n    lineEndWorld: Types.Point3,\n    canvasCoordinates: Types.Point2[]\n  ) {\n    const renderingEngine = targetViewport.getRenderingEngine();\n    const targetId = this.getTargetId(targetViewport);\n    const targetImage = this.getTargetIdImage(targetId, renderingEngine);\n\n    const referencedImageId = this.getReferencedImageId(\n      targetViewport,\n      lineStartWorld,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    if (referencedImageId && targetImage) {\n      try {\n        const { imageData, dimensions } = targetImage;\n\n        // Calculate bound image coordinates\n        const [\n          topLeftImageCoord,\n          topRightImageCoord,\n          bottomRightImageCoord,\n          bottomLeftImageCoord,\n        ] = [\n          imageData.indexToWorld([0, 0, 0]) as Types.Point3,\n          imageData.indexToWorld([dimensions[0] - 1, 0, 0]) as Types.Point3,\n          imageData.indexToWorld([\n            dimensions[0] - 1,\n            dimensions[1] - 1,\n            0,\n          ]) as Types.Point3,\n          imageData.indexToWorld([0, dimensions[1] - 1, 0]) as Types.Point3,\n        ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n\n        // Calculate line start and end image coordinates\n        const [lineStartImageCoord, lineEndImageCoord] = [\n          lineStartWorld,\n          lineEndWorld,\n        ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n\n        // Calculate intersection points between line and image bounds\n        canvasCoordinates = [\n          [topLeftImageCoord, topRightImageCoord],\n          [topRightImageCoord, bottomRightImageCoord],\n          [bottomLeftImageCoord, bottomRightImageCoord],\n          [topLeftImageCoord, bottomLeftImageCoord],\n        ]\n          .map(([start, end]) =>\n            this.intersectInfiniteLines(\n              start,\n              end,\n              lineStartImageCoord,\n              lineEndImageCoord\n            )\n          )\n          .filter((point) => point && this.isInBound(point, dimensions))\n          .map((point) => {\n            const world = csUtils.imageToWorldCoords(\n              referencedImageId,\n              point as Types.Point2\n            );\n            return targetViewport.worldToCanvas(world);\n          });\n      } catch (err) {\n        console.log(err);\n      }\n    }\n    return canvasCoordinates;\n  }\n\n  // get the intersection point between two infinite lines, not line segments\n  intersectInfiniteLines(\n    line1Start: Types.Point2,\n    line1End: Types.Point2,\n    line2Start: Types.Point2,\n    line2End: Types.Point2\n  ) {\n    const [x1, y1] = line1Start;\n    const [x2, y2] = line1End;\n    const [x3, y3] = line2Start;\n    const [x4, y4] = line2End;\n\n    // Compute a1, b1, c1, where line joining points 1 and 2 is \"a1 x  +  b1 y  +  c1  =  0\"\n    const a1 = y2 - y1;\n    const b1 = x1 - x2;\n    const c1 = x2 * y1 - x1 * y2;\n\n    // Compute a2, b2, c2\n    const a2 = y4 - y3;\n    const b2 = x3 - x4;\n    const c2 = x4 * y3 - x3 * y4;\n\n    if (Math.abs(a1 * b2 - a2 * b1) < EPSILON) {\n      return;\n    }\n\n    const x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n    const y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1);\n\n    return [x, y];\n  }\n\n  isParallel(vec1: Types.Point3, vec2: Types.Point3): boolean {\n    return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n  }\n\n  isInBound(point: number[], dimensions: Types.Point3): boolean {\n    return (\n      point[0] >= 0 &&\n      point[0] <= dimensions[0] &&\n      point[1] >= 0 &&\n      point[1] <= dimensions[1]\n    );\n  }\n}\n\nReferenceLines.toolName = 'ReferenceLines';\nexport default ReferenceLines;\n","import { vec3 } from 'gl-matrix';\nimport {\n  metaData,\n  CONSTANTS,\n  getRenderingEngine,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\n\nimport { getToolGroup } from '../store/ToolGroupManager';\n\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  Annotation,\n} from '../types';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\n\nconst { EPSILON } = CONSTANTS;\n\nexport interface OverlayGridAnnotation extends Annotation {\n  data: {\n    viewportData: Map<string, object>;\n    pointSets: Array<object>;\n  };\n}\n\n/**\n * @public\n */\nclass OverlayGridTool extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        sourceImageIds: [],\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onSetToolActive = (): void => {\n    this._init();\n  };\n\n  _init = (): void => {\n    const sourceImageIds = this.configuration.sourceImageIds;\n    if (!sourceImageIds?.length) {\n      console.warn(\n        'OverlayGridTool: No sourceImageIds provided in configuration'\n      );\n      return;\n    }\n\n    const imagePlaneModule = metaData.get(\n      'imagePlaneModule',\n      sourceImageIds[0]\n    );\n\n    if (!imagePlaneModule) {\n      console.warn(\n        'OverlayGridTool: No imagePlaneModule found for sourceImageIds'\n      );\n      return;\n    }\n\n    const { frameOfReferenceUID } = imagePlaneModule;\n\n    const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    if (!viewportsInfo?.length) {\n      console.warn('OverlayGridTool: No viewports found');\n      return;\n    }\n\n    const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n\n    if (!annotations?.length) {\n      const pointSets = sourceImageIds.map((id) => {\n        // check if pointSets for the imageId was calculated. If not calculate and store\n        return this.calculateImageIdPointSets(id);\n      });\n\n      const newAnnotation: OverlayGridAnnotation = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n          toolName: this.getToolName(),\n          FrameOfReferenceUID: frameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          viewportData: new Map(),\n          pointSets,\n        },\n      };\n\n      addAnnotation(newAnnotation, frameOfReferenceUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      getRenderingEngine(viewportsInfo[0].renderingEngineId),\n      viewportsInfo.map(({ viewportId }) => viewportId)\n    );\n  };\n\n  /**\n   * Calculates the point sets based on the image corners relative to an imageId\n   * @param imageId - The imageId to calculate the point sets for\n   * @returns\n   */\n  calculateImageIdPointSets = (imageId: string) => {\n    const {\n      imagePositionPatient,\n      rows,\n      columns,\n      rowCosines,\n      columnCosines,\n      rowPixelSpacing,\n      columnPixelSpacing,\n    } = metaData.get('imagePlaneModule', imageId);\n\n    // top left world, top right world, bottom right world, bottom left world\n    const topLeft = <Types.Point3>[...imagePositionPatient];\n    const topRight = <Types.Point3>[...imagePositionPatient];\n    const bottomLeft = <Types.Point3>[...imagePositionPatient];\n    const bottomRight = <Types.Point3>[...imagePositionPatient];\n\n    vec3.scaleAndAdd(\n      topRight,\n      imagePositionPatient,\n      columnCosines,\n      columns * columnPixelSpacing\n    );\n    vec3.scaleAndAdd(\n      bottomLeft,\n      imagePositionPatient,\n      rowCosines,\n      rows * rowPixelSpacing\n    );\n\n    vec3.scaleAndAdd(\n      bottomRight,\n      bottomLeft,\n      columnCosines,\n      columns * columnPixelSpacing\n    );\n\n    // check if the topLeft and bottomLeft line is parallel to the viewUp\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n    const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n\n    return { pointSet1, pointSet2 };\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const sourceImageIds = this.configuration.sourceImageIds;\n\n    let renderStatus = false;\n    if (!sourceImageIds?.length) {\n      return renderStatus;\n    }\n\n    const { viewport: targetViewport, FrameOfReferenceUID } = enabledElement;\n    const targetImageIds = targetViewport.getImageIds();\n    if (targetImageIds.length < 2) {\n      return renderStatus;\n    }\n\n    const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n    const annotation = annotations[0];\n    const { annotationUID } = annotation;\n\n    const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n    const imageIdNormal = <Types.Point3>(\n      this.getImageIdNormal(sourceImageIds[0])\n    );\n\n    if (this.isParallel(viewPlaneNormal, imageIdNormal)) {\n      // If the source and target viewports are parallel, we don't need to render\n      return renderStatus;\n    }\n\n    const targetViewportPlane = csUtils.planar.planeEquation(\n      viewPlaneNormal,\n      focalPoint\n    );\n\n    const pointSets = annotation.data.pointSets;\n    const viewportData = annotation.data.viewportData;\n    for (let i = 0; i < sourceImageIds.length; i++) {\n      // check if pointSets for the imageId was calculated. If not calculate and store\n      const { pointSet1, pointSet2 } = pointSets[i];\n\n      const targetData =\n        viewportData.get(targetViewport.id) ||\n        this.initializeViewportData(viewportData, targetViewport.id);\n\n      // check if pointSetToUse was calculated. If not calculate and store\n      if (!targetData.pointSetsToUse[i]) {\n        let pointSetToUse = pointSet1;\n\n        let topBottomVec = vec3.subtract(\n          vec3.create(),\n          pointSet1[0],\n          pointSet1[1]\n        );\n        topBottomVec = vec3.normalize(\n          vec3.create(),\n          topBottomVec\n        ) as Types.Point3;\n\n        // check if it is perpendicular to the viewPlaneNormal which means\n        // the line does not intersect the viewPlaneNormal\n        if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n          // 'use pointSet2';\n          pointSetToUse = pointSet2;\n        }\n\n        targetData.pointSetsToUse[i] = pointSetToUse;\n\n        targetData.lineStartsWorld[i] = csUtils.planar.linePlaneIntersection(\n          pointSetToUse[0],\n          pointSetToUse[1],\n          targetViewportPlane\n        );\n\n        targetData.lineEndsWorld[i] = csUtils.planar.linePlaneIntersection(\n          pointSetToUse[2],\n          pointSetToUse[3],\n          targetViewportPlane\n        );\n      }\n\n      const lineStartWorld = targetData.lineStartsWorld[i];\n      const lineEndWorld = targetData.lineEndsWorld[i];\n\n      styleSpecifier.annotationUID = annotationUID;\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n      const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) =>\n        targetViewport.worldToCanvas(world)\n      );\n\n      const dataId = `${annotationUID}-line`;\n      const lineUID = `${i}`;\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        dataId\n      );\n    }\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n\n  private initializeViewportData = (viewportData, id) => {\n    viewportData.set(id, {\n      pointSetsToUse: [],\n      lineStartsWorld: [],\n      lineEndsWorld: [],\n    });\n\n    return viewportData.get(id);\n  };\n\n  private isPerpendicular = (\n    vec1: Types.Point3,\n    vec2: Types.Point3\n  ): boolean => {\n    const dot = vec3.dot(vec1, vec2);\n    return Math.abs(dot) < EPSILON;\n  };\n\n  private isParallel(vec1: Types.Point3, vec2: Types.Point3): boolean {\n    return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n  }\n\n  private getImageIdNormal(imageId: string): vec3 {\n    const { imageOrientationPatient } = metaData.get(\n      'imagePlaneModule',\n      imageId\n    );\n    const rowCosineVec = vec3.fromValues(\n      imageOrientationPatient[0],\n      imageOrientationPatient[1],\n      imageOrientationPatient[2]\n    );\n    const colCosineVec = vec3.fromValues(\n      imageOrientationPatient[3],\n      imageOrientationPatient[4],\n      imageOrientationPatient[5]\n    );\n    return vec3.cross(vec3.create(), rowCosineVec, colCosineVec);\n  }\n}\n\nOverlayGridTool.toolName = 'OverlayGrid';\nexport default OverlayGridTool;\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport { drawPath } from '../drawingSvg';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { PublicToolProps, ToolProps, SVGDrawingHelper } from '../types';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { Annotation } from '../types';\nimport { distanceToPoint } from '../utilities/math/point';\nimport { pointToString } from '../utilities/pointToString';\nimport { polyDataUtils } from '../utilities';\n\nexport interface SegmentationIntersectionAnnotation extends Annotation {\n  data: {\n    actorsWorldPointsMap: Map<string, Map<string, object>>;\n  };\n}\n\nclass SegmentationIntersectionTool extends AnnotationDisplayTool {\n  static toolName;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        opacity: 0.5,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Initialize the annotation data and calculates surface intersections\n   * @returns\n   */\n  _init = (): void => {\n    const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    if (!viewportsInfo?.length) {\n      console.warn(this.getToolName() + 'Tool: No viewports found');\n      return;\n    }\n\n    const firstViewport = getRenderingEngine(\n      viewportsInfo[0].renderingEngineId\n    )?.getViewport(viewportsInfo[0].viewportId);\n\n    if (!firstViewport) {\n      return;\n    }\n    const frameOfReferenceUID = firstViewport.getFrameOfReferenceUID();\n    const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n\n    if (!annotations?.length) {\n      const actorsWorldPointsMap = new Map();\n      calculateSurfaceSegmentationIntersections(\n        actorsWorldPointsMap,\n        viewportsInfo\n      );\n      const newAnnotation: SegmentationIntersectionAnnotation = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n          toolName: this.getToolName(),\n          FrameOfReferenceUID: frameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          actorsWorldPointsMap,\n        },\n      };\n\n      addAnnotation(newAnnotation, frameOfReferenceUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      getRenderingEngine(viewportsInfo[0].renderingEngineId),\n      viewportsInfo.map(({ viewportId }) => viewportId)\n    );\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    this._init();\n  };\n\n  /**\n   * Renders the surface intersections\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const { viewport, FrameOfReferenceUID } = enabledElement;\n\n    let renderStatus = false;\n\n    const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n    const annotation = annotations[0];\n    const { annotationUID } = annotation;\n    const actorsWorldPointsMap = annotation.data.actorsWorldPointsMap;\n\n    calculateSurfaceSegmentationIntersectionsForViewport(\n      actorsWorldPointsMap,\n      viewport\n    );\n\n    const actorEntries = viewport.getActors();\n    const cacheId = getCacheId(viewport);\n\n    actorEntries.forEach((actorEntry) => {\n      if (!actorEntry?.clippingFilter) {\n        return;\n      }\n      const actorWorldPointMap = actorsWorldPointsMap.get(actorEntry.uid);\n      if (!actorWorldPointMap) {\n        return;\n      }\n      if (!actorWorldPointMap.get(cacheId)) {\n        return;\n      }\n      let polyLineIdx = 1;\n      const { worldPointsSet, color } = actorWorldPointMap.get(cacheId);\n      for (let i = 0; i < worldPointsSet.length; i++) {\n        const worldPoints = worldPointsSet[i];\n        const canvasPoints = worldPoints.map((point) =>\n          viewport.worldToCanvas(point)\n        );\n\n        const options = {\n          color: color,\n          fillColor: color,\n          fillOpacity: this.configuration.opacity,\n          closePath: true,\n          lineWidth: 2,\n        };\n\n        const polyLineUID = actorEntry.uid + '#' + polyLineIdx;\n        drawPath(\n          svgDrawingHelper,\n          annotationUID,\n          polyLineUID,\n          canvasPoints,\n          options\n        );\n        polyLineIdx++;\n      }\n    });\n\n    renderStatus = true;\n    return renderStatus;\n  };\n}\n\n/**\n * Calculates surface intersections points for all surface actors in a list of viewports\n * @param actorWorldPointsMap\n * @param viewportsInfo\n */\nfunction calculateSurfaceSegmentationIntersections(\n  actorsWorldPointsMap,\n  viewportsInfo\n) {\n  viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n    const viewport =\n      getRenderingEngine(renderingEngineId)?.getViewport(viewportId);\n    calculateSurfaceSegmentationIntersectionsForViewport(\n      actorsWorldPointsMap,\n      viewport\n    );\n  });\n}\n\n/**\n * Calculates surface intersections points for all surface actors in a viewport\n * generating a set of polyline points for each actor\n * @param actorWorldPointsMap\n * @param viewport\n */\nfunction calculateSurfaceSegmentationIntersectionsForViewport(\n  actorsWorldPointsMap,\n  viewport\n) {\n  const actorEntries = viewport.getActors();\n\n  // we should not use the focalPoint here, since the pan and zoom updates it,\n  // imageIndex is reliable enough\n  const cacheId = getCacheId(viewport);\n\n  actorEntries.forEach((actorEntry) => {\n    if (!actorEntry?.clippingFilter) {\n      return;\n    }\n\n    let actorWorldPointsMap = actorsWorldPointsMap.get(actorEntry.uid);\n    if (!actorWorldPointsMap) {\n      actorWorldPointsMap = new Map();\n      actorsWorldPointsMap.set(actorEntry.uid, actorWorldPointsMap);\n    }\n    if (!actorWorldPointsMap.get(cacheId)) {\n      const polyData = actorEntry.clippingFilter.getOutputData();\n      const worldPointsSet = polyDataUtils.getPolyDataPoints(polyData);\n      if (!worldPointsSet) {\n        return;\n      }\n\n      // worldPointsSet = removeExtraPoints(viewport, worldPointsSet);\n      const colorArray = actorEntry.actor.getProperty().getColor();\n      const color = colorToString(colorArray);\n      actorWorldPointsMap.set(cacheId, { worldPointsSet, color });\n    }\n  });\n}\n\nfunction getCacheId(viewport) {\n  const { viewPlaneNormal } = viewport.getCamera();\n  const imageIndex = viewport.getCurrentImageIdIndex();\n  return `${viewport.id}-${pointToString(viewPlaneNormal)}-${imageIndex}`;\n}\n\n/**\n * Transform a color array into a string\n * @param colorArray\n * @returns\n */\nfunction colorToString(colorArray): string {\n  function colorComponentToString(component) {\n    let componentString = Math.floor(component * 255).toString(16);\n    if (componentString.length === 1) {\n      componentString = '0' + componentString;\n    }\n    return componentString;\n  }\n  return (\n    '#' +\n    colorComponentToString(colorArray[0]) +\n    colorComponentToString(colorArray[1]) +\n    colorComponentToString(colorArray[2])\n  );\n}\n\n/**\n * Remove duplicate and unnecessary points\n * @param worldPoints\n * @param canvasPoints\n * @returns\n */\nfunction removeExtraPoints(viewport, worldPointsSet) {\n  return worldPointsSet.map((worldPoints) => {\n    const canvasPoints = worldPoints.map((point) => {\n      const canvasPoint = viewport.worldToCanvas(point);\n      return [Math.floor(canvasPoint[0]), Math.floor(canvasPoint[1])];\n    });\n\n    let lastPoint;\n    const newWorldPoints = [];\n    let newCanvasPoints = [];\n    // removing duplicate points\n    for (let i = 0; i < worldPoints.length; i++) {\n      if (lastPoint) {\n        if (distanceToPoint(lastPoint, canvasPoints[i]) > 0) {\n          newWorldPoints.push(worldPoints[i]);\n          newCanvasPoints.push(canvasPoints[i]);\n        }\n      }\n      lastPoint = canvasPoints[i];\n    }\n\n    // checking if a middle point is near the start\n    const firstPoint = newCanvasPoints[0];\n    for (\n      let j = Math.min(30, newCanvasPoints.length);\n      j < newCanvasPoints.length;\n      j++\n    ) {\n      if (distanceToPoint(firstPoint, newCanvasPoints[j]) < 0.5) {\n        newCanvasPoints = newCanvasPoints.slice(0, j);\n        return newWorldPoints.slice(0, j);\n      }\n    }\n    return newWorldPoints;\n  });\n}\n\nSegmentationIntersectionTool.toolName = 'SegmentationIntersection';\nexport default SegmentationIntersectionTool;\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Given two world positions and an orthogonal view to an `imageVolume` defined by\n * a `viewPlaneNormal` and a `viewUp`, get the width and height in world coordinates of the rectangle\n * defined by the two points. The implementation works both with orthogonal\n * non-orthogonal rectangles.\n *\n * @param viewPlaneNormal - The normal of the view.\n * @param viewUp - The up direction of the view.\n * @param imageVolume - The imageVolume to use to measure.\n * @param worldPos1 - The first world position.\n * @param worldPos2 - The second world position.\n *\n * @returns The `worldWidth` and `worldHeight`.\n */\nexport default function getWorldWidthAndHeightFromTwoPoints(\n  viewPlaneNormal: Types.Point3,\n  viewUp: Types.Point3,\n  worldPos1: Types.Point3,\n  worldPos2: Types.Point3\n): { worldWidth: number; worldHeight: number } {\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n  const pos1 = vec3.fromValues(...worldPos1);\n  const pos2 = vec3.fromValues(...worldPos2);\n\n  const diagonal = vec3.create();\n  vec3.subtract(diagonal, pos1, pos2);\n\n  const diagonalLength = vec3.length(diagonal);\n\n  // When the two points are very close to each other return width as 0\n  // to avoid NaN the cosTheta formula calculation\n  if (diagonalLength < 0.0001) {\n    return { worldWidth: 0, worldHeight: 0 };\n  }\n\n  const cosTheta =\n    vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n\n  const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n\n  const worldWidth = sinTheta * diagonalLength;\n  const worldHeight = cosTheta * diagonalLength;\n\n  return { worldWidth, worldHeight };\n}\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport {\n  drawCircle as drawCircleSvg,\n  drawEllipseByCoordinates as drawEllipseSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport {\n  pointInEllipse,\n  getCanvasEllipseCorners,\n} from '../../utilities/math/ellipse';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { EllipticalROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { pointInShapeCallback } from '../../utilities/';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * EllipticalROITool let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of an elliptical region of interest.\n * You can use EllipticalROITool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Elliptical tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * Changing tool configuration (see below) you can make the tool to draw the center\n * point circle with a given radius.\n *\n * ```js\n * cornerstoneTools.addTool(EllipticalROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(EllipticalROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(EllipticalROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // draw a circle at the center point with 4px radius.\n * toolGroup.setToolConfiguration(EllipticalROITool.toolName, {\n *   centerPointRadius: 4,\n * });\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass EllipticalROITool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    centerWorld?: Array<number>;\n    canvasWidth?: number;\n    canvasHeight?: number;\n    originalHandleCanvas?: Array<number>;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        // Radius of the circle to draw  at the center point of the ellipse.\n        // Set this zero(0) in order not to draw the circle.\n        centerPointRadius: 0,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a EllipticalROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): EllipticalROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          points: [\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n          ] as [Types.Point3, Types.Point3, Types.Point3, Types.Point3],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        initialRotation: viewport.getRotation(),\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      centerWorld: worldPos,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: EllipticalROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p)) as [\n      Types.Point2,\n      Types.Point2,\n      Types.Point2,\n      Types.Point2\n    ];\n    const canvasCorners = getCanvasEllipseCorners(canvasCoordinates);\n\n    const [canvasPoint1, canvasPoint2] = canvasCorners;\n\n    const minorEllipse = {\n      left: Math.min(canvasPoint1[0], canvasPoint2[0]) + proximity / 2,\n      top: Math.min(canvasPoint1[1], canvasPoint2[1]) + proximity / 2,\n      width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) - proximity,\n      height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) - proximity,\n    };\n\n    const majorEllipse = {\n      left: Math.min(canvasPoint1[0], canvasPoint2[0]) - proximity / 2,\n      top: Math.min(canvasPoint1[1], canvasPoint2[1]) - proximity / 2,\n      width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) + proximity,\n      height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) + proximity,\n    };\n\n    const pointInMinorEllipse = this._pointInEllipseCanvas(\n      minorEllipse,\n      canvasCoords\n    );\n    const pointInMajorEllipse = this._pointInEllipseCanvas(\n      majorEllipse,\n      canvasCoords\n    );\n\n    if (pointInMajorEllipse && !pointInMinorEllipse) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: EllipticalROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: EllipticalROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    let centerCanvas;\n    let centerWorld;\n    let canvasWidth;\n    let canvasHeight;\n    let originalHandleCanvas;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      const { points } = data.handles;\n      const { viewport } = getEnabledElement(element);\n      const { worldToCanvas, canvasToWorld } = viewport;\n\n      handleIndex = points.findIndex((p) => p === handle);\n\n      const pointsCanvas = points.map(worldToCanvas);\n\n      originalHandleCanvas = pointsCanvas[handleIndex];\n\n      canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);\n      canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);\n\n      centerCanvas = [\n        (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,\n        (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,\n      ];\n\n      centerWorld = canvasToWorld(centerCanvas);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      canvasWidth,\n      canvasHeight,\n      centerWorld,\n      originalHandleCanvas,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    // Elliptical ROI tool should reset its highlight to false on mouse up (as opposed\n    // to other tools that keep it highlighted until the user moves. The reason\n    // is that we use top-left and bottom-right handles to define the ellipse,\n    // and they are by definition not in the ellipse on mouse up.\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const { renderingEngine } = getEnabledElement(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerWorld } = this.editData;\n    const centerCanvas = viewport.worldToCanvas(centerWorld as Types.Point3);\n    const { data } = annotation;\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n\n    // Todo: why bottom is -dY, it should be +dY\n    const bottomCanvas = <Types.Point2>[centerCanvas[0], centerCanvas[1] - dY];\n    const topCanvas = <Types.Point2>[centerCanvas[0], centerCanvas[1] + dY];\n    const leftCanvas = <Types.Point2>[centerCanvas[0] - dX, centerCanvas[1]];\n    const rightCanvas = <Types.Point2>[centerCanvas[0] + dX, centerCanvas[1]];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { viewport } = getEnabledElement(element);\n    const { canvasToWorld, worldToCanvas } = viewport;\n\n    const {\n      annotation,\n      canvasWidth,\n      canvasHeight,\n      handleIndex,\n      centerWorld,\n      originalHandleCanvas,\n    } = this.editData;\n    const centerCanvas = viewport.worldToCanvas(centerWorld as Types.Point3);\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // Move current point in that direction.\n    // Move other points in opposite direction.\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    if (handleIndex === 0 || handleIndex === 1) {\n      // Dragging top or bottom point\n      const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n      const canvasBottom = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] - dYCanvas,\n      ];\n      const canvasTop = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] + dYCanvas,\n      ];\n\n      points[0] = canvasToWorld(canvasBottom);\n      points[1] = canvasToWorld(canvasTop);\n\n      const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];\n      const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;\n      const canvasLeft = <Types.Point2>[\n        centerCanvas[0] - newHalfCanvasWidth,\n        centerCanvas[1],\n      ];\n      const canvasRight = <Types.Point2>[\n        centerCanvas[0] + newHalfCanvasWidth,\n        centerCanvas[1],\n      ];\n\n      points[2] = canvasToWorld(canvasLeft);\n      points[3] = canvasToWorld(canvasRight);\n    } else {\n      // Dragging left or right point\n      const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n      const canvasLeft = <Types.Point2>[\n        centerCanvas[0] - dXCanvas,\n        centerCanvas[1],\n      ];\n      const canvasRight = <Types.Point2>[\n        centerCanvas[0] + dXCanvas,\n        centerCanvas[1],\n      ];\n\n      points[2] = canvasToWorld(canvasLeft);\n      points[3] = canvasToWorld(canvasRight);\n\n      const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];\n      const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;\n      const canvasBottom = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] - newHalfCanvasHeight,\n      ];\n      const canvasTop = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] + newHalfCanvasHeight,\n      ];\n\n      points[0] = canvasToWorld(canvasBottom);\n      points[1] = canvasToWorld(canvasTop);\n    }\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the ellipticalROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as EllipticalROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2, Types.Point2, Types.Point2, Types.Point2];\n\n      const rotation = Math.abs(\n        viewport.getRotation() - (data.initialRotation || 0)\n      );\n      const canvasCorners = <Array<Types.Point2>>(\n        getCanvasEllipseCorners(canvasCoordinates) // bottom, top, left, right, keep as is\n      );\n\n      const { centerPointRadius } = this.configuration;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(annotation, viewport, renderingEngine);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related viewports data, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-ellipse`;\n      const ellipseUID = '0';\n      drawEllipseSvg(\n        svgDrawingHelper,\n        annotationUID,\n        ellipseUID,\n        canvasCoordinates,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      // draw center point, if \"centerPointRadius\" configuration is valid.\n      if (centerPointRadius > 0) {\n        const minRadius = Math.min(\n          Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, // horizontal radius\n          Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2 // vertical radius\n        );\n        if (minRadius > 3 * centerPointRadius) {\n          const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);\n          drawCircleSvg(\n            svgDrawingHelper,\n            annotationUID,\n            `${ellipseUID}-center`,\n            centerPoint,\n            centerPointRadius,\n            {\n              color,\n              lineDash,\n              lineWidth,\n            }\n          );\n        }\n      }\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      // Poor man's cached?\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats = (annotation, viewport, renderingEngine) => {\n    const data = annotation.data;\n    const { element } = viewport;\n\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\n      getCanvasEllipseCorners(canvasCoordinates)\n    );\n\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n    const worldPos1 = topLeftWorld;\n    const worldPos2 = bottomRightWorld;\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata } = image;\n\n      const pos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      pos1Index[0] = Math.floor(pos1Index[0]);\n      pos1Index[1] = Math.floor(pos1Index[1]);\n      pos1Index[2] = Math.floor(pos1Index[2]);\n\n      const post2Index = transformWorldToIndex(imageData, worldPos2);\n\n      post2Index[0] = Math.floor(post2Index[0]);\n      post2Index[1] = Math.floor(post2Index[1]);\n      post2Index[2] = Math.floor(post2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(pos1Index, post2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n\n        const iMin = Math.min(pos1Index[0], post2Index[0]);\n        const iMax = Math.max(pos1Index[0], post2Index[0]);\n\n        const jMin = Math.min(pos1Index[1], post2Index[1]);\n        const jMax = Math.max(pos1Index[1], post2Index[1]);\n\n        const kMin = Math.min(pos1Index[2], post2Index[2]);\n        const kMax = Math.max(pos1Index[2], post2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const center = [\n          (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n          (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n          (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n        ] as Types.Point3;\n\n        const ellipseObj = {\n          center,\n          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n        };\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n        const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n\n        const handles = [pos1Index, post2Index];\n        const { scale, areaUnits } = getCalibratedLengthUnitsAndScale(\n          image,\n          handles\n        );\n\n        const area =\n          Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2)) /\n          scale /\n          scale;\n\n        const modalityUnitOptions = {\n          isPreScaled: isViewportPreScaled(viewport, targetId),\n\n          isSuvScaled: this.isSuvScaled(\n            viewport,\n            targetId,\n            annotation.metadata.referencedImageId\n          ),\n        };\n\n        const modalityUnit = getModalityUnit(\n          metadata.Modality,\n          annotation.metadata.referencedImageId,\n          modalityUnitOptions\n        );\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        const stats = this.configuration.statsCalculator.getStatistics();\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean: stats.mean?.value,\n          max: stats.max?.value,\n          stdDev: stats.stdDev?.value,\n          statsArray: stats.array,\n          pointsInShape,\n          isEmptyArea,\n          areaUnit: areaUnits,\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n\n  /**\n   * This is a temporary function to use the old ellipse's canvas-based\n   * calculation for isPointNearTool, we should move the the world-based\n   * calculation to the tool's isPointNearTool function.\n   *\n   * @param ellipse - The ellipse object\n   * @param location - The location to check\n   * @returns True if the point is inside the ellipse\n   */\n  _pointInEllipseCanvas(ellipse, location: Types.Point2): boolean {\n    const xRadius = ellipse.width / 2;\n    const yRadius = ellipse.height / 2;\n\n    if (xRadius <= 0.0 || yRadius <= 0.0) {\n      return false;\n    }\n\n    const center = [ellipse.left + xRadius, ellipse.top + yRadius];\n    const normalized = [location[0] - center[0], location[1] - center[1]];\n\n    const inEllipse =\n      (normalized[0] * normalized[0]) / (xRadius * xRadius) +\n        (normalized[1] * normalized[1]) / (yRadius * yRadius) <=\n      1.0;\n\n    return inEllipse;\n  }\n\n  /**\n   * It takes the canvas coordinates of the ellipse corners and returns the center point of it\n   *\n   * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\n   * @returns center point.\n   */\n  _getCanvasEllipseCenter(ellipseCanvasPoints: Types.Point2[]): Types.Point2 {\n    const [bottom, top, left, right] = ellipseCanvasPoints;\n    const topLeft = [left[0], top[1]];\n    const bottomRight = [right[0], bottom[1]];\n    return [\n      (topLeft[0] + bottomRight[0]) / 2,\n      (topLeft[1] + bottomRight[1]) / 2,\n    ] as Types.Point2;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit } =\n    cachedVolumeStats;\n\n  const textLines: string[] = [];\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n    textLines.push(areaLine);\n  }\n\n  if (mean) {\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  }\n\n  if (max) {\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  }\n\n  if (stdDev) {\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nEllipticalROITool.toolName = 'EllipticalROI';\nexport default EllipticalROITool;\n","import { distanceToPoint } from '../point';\nimport { canvasCoordinates } from './_types';\n\n/**\n * It takes the canvas coordinates of the circle corners and returns the top left and bottom right\n * corners of it\n *\n * @param circleCanvasPoints - The coordinates of the circle in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasCircleRadius(\n  circleCanvasPoints: canvasCoordinates\n): number {\n  const [center, end] = circleCanvasPoints;\n  return distanceToPoint(center, end);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { distanceToPoint } from '../point';\nimport { canvasCoordinates } from './_types';\n\n/**\n * It takes the canvas coordinates of the circle corners (wrapping square rectangle)\n * and returns the top left and bottom right\n * corners of it\n *\n * @param circleCanvasPoints - The coordinates of the circle in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasCircleCorners(\n  circleCanvasPoints: canvasCoordinates\n): Array<Types.Point2> {\n  const [center, end] = circleCanvasPoints;\n  const radius = distanceToPoint(center, end);\n\n  const topLeft = <Types.Point2>[center[0] - radius, center[1] - radius];\n  const bottomRight = <Types.Point2>[center[0] + radius, center[1] + radius];\n\n  return [topLeft, bottomRight];\n}\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getCalibratedAspect } from '../../utilities/getCalibratedUnits';\nimport { getCalibratedLengthUnitsAndScale, roundNumber } from '../../utilities';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { CircleROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { pointInShapeCallback } from '../../utilities';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport {\n  getCanvasCircleCorners,\n  getCanvasCircleRadius,\n} from '../../utilities/math/circle';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * CircleROITool let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of an elliptical region of interest.\n * You can use CircleROITool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Circle tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * Changing tool configuration (see below) you can make the tool to draw the center\n * point circle with a given radius.\n *\n * ```js\n * cornerstoneTools.addTool(CircleROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(CircleROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(CircleROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // draw a circle at the center point with 4px radius.\n * toolGroup.setToolConfiguration(CircleROITool.toolName, {\n *   centerPointRadius: 4,\n * });\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass CircleROITool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        // Radius of the circle to draw  at the center point of the circle.\n        // Set this zero(0) in order not to draw the circle.\n        centerPointRadius: 0,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): CircleROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          points: [[...worldPos], [...worldPos]] as [\n            Types.Point3, // center\n            Types.Point3 // end\n          ],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CircleROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p)) as [\n      Types.Point2,\n      Types.Point2\n    ];\n\n    const radius = getCanvasCircleRadius(canvasCoordinates);\n    const radiusPoint = getCanvasCircleRadius([\n      canvasCoordinates[0],\n      canvasCoords,\n    ]);\n\n    if (Math.abs(radiusPoint - radius) < proximity / 2) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: CircleROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: CircleROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      const { points } = data.handles;\n\n      handleIndex = points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    // Circle ROI tool should reset its highlight to false on mouse up (as opposed\n    // to other tools that keep it highlighted until the user moves. The reason\n    // is that we use top-left and bottom-right handles to define the circle,\n    // and they are by definition not in the circle on mouse up.\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const { renderingEngine } = getEnabledElement(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n\n    data.handles.points = [\n      data.handles.points[0], // center stays\n      canvasToWorld(currentCanvasPoints), // end point moves (changing radius)\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n\n    const { annotation, handleIndex } = this.editData;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => worldToCanvas(p));\n\n    // Move current point in that direction.\n    // Move other points in opposite direction.\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    if (handleIndex === 0) {\n      // Dragging center, move the circle ROI\n      const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];\n      const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];\n\n      const canvasCenter = currentCanvasPoints as Types.Point2;\n      const canvasEnd = <Types.Point2>[\n        canvasCoordinates[1][0] + dXCanvas,\n        canvasCoordinates[1][1] + dYCanvas,\n      ];\n\n      points[0] = canvasToWorld(canvasCenter);\n      points[1] = canvasToWorld(canvasEnd);\n    } else {\n      // Dragging end point, center stays\n      points[1] = canvasToWorld(currentCanvasPoints);\n    }\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as CircleROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2, Types.Point2];\n      const center = canvasCoordinates[0];\n      const radius = getCanvasCircleRadius(canvasCoordinates);\n      const canvasCorners = getCanvasCircleCorners(canvasCoordinates);\n\n      const { centerPointRadius } = this.configuration;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n          radius: null,\n          radiusUnit: null,\n          perimeter: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related viewports data, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-circle`;\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        center,\n        radius,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      // draw center point, if \"centerPointRadius\" configuration is valid.\n      if (centerPointRadius > 0) {\n        if (radius > 3 * centerPointRadius) {\n          drawCircleSvg(\n            svgDrawingHelper,\n            annotationUID,\n            `${circleUID}-center`,\n            center,\n            centerPointRadius,\n            {\n              color,\n              lineDash,\n              lineWidth,\n            }\n          );\n        }\n      }\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      // Poor man's cached?\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats = (\n    annotation,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const data = annotation.data;\n    const { element } = viewport;\n\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\n      getCanvasCircleCorners(canvasCoordinates)\n    );\n\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n    const worldPos1 = topLeftWorld;\n    const worldPos2 = bottomRightWorld;\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata, hasPixelSpacing } = image;\n\n      const pos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      pos1Index[0] = Math.floor(pos1Index[0]);\n      pos1Index[1] = Math.floor(pos1Index[1]);\n      pos1Index[2] = Math.floor(pos1Index[2]);\n\n      const pos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      pos2Index[0] = Math.floor(pos2Index[0]);\n      pos2Index[1] = Math.floor(pos2Index[1]);\n      pos2Index[2] = Math.floor(pos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n        const iMin = Math.min(pos1Index[0], pos2Index[0]);\n        const iMax = Math.max(pos1Index[0], pos2Index[0]);\n\n        const jMin = Math.min(pos1Index[1], pos2Index[1]);\n        const jMax = Math.max(pos1Index[1], pos2Index[1]);\n\n        const kMin = Math.min(pos1Index[2], pos2Index[2]);\n        const kMax = Math.max(pos1Index[2], pos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const center = [\n          (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n          (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n          (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n        ] as Types.Point3;\n\n        const ellipseObj = {\n          center,\n          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n        };\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n        const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n        const handles = [pos1Index, pos2Index];\n        const { scale, units, areaUnits } = getCalibratedLengthUnitsAndScale(\n          image,\n          handles\n        );\n        const aspect = getCalibratedAspect(image);\n        const area = Math.abs(\n          Math.PI *\n            (worldWidth / scale / 2) *\n            (worldHeight / aspect / scale / 2)\n        );\n\n        const modalityUnitOptions = {\n          isPreScaled: isViewportPreScaled(viewport, targetId),\n          isSuvScaled: this.isSuvScaled(\n            viewport,\n            targetId,\n            annotation.metadata.referencedImageId\n          ),\n        };\n\n        const modalityUnit = getModalityUnit(\n          metadata.Modality,\n          annotation.metadata.referencedImageId,\n          modalityUnitOptions\n        );\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          (pointLPS) =>\n            pointInEllipse(ellipseObj, pointLPS, {\n              fast: true,\n            }),\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        const stats = this.configuration.statsCalculator.getStatistics();\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean: stats.mean?.value,\n          max: stats.max?.value,\n          stdDev: stats.stdDev?.value,\n          statsArray: stats.array,\n          pointsInShape: pointsInShape,\n          isEmptyArea,\n          areaUnit: areaUnits,\n          radius: worldWidth / 2 / scale,\n          radiusUnit: units,\n          perimeter: (2 * Math.PI * (worldWidth / 2)) / scale,\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const {\n    radius,\n    radiusUnit,\n    area,\n    mean,\n    stdDev,\n    max,\n    isEmptyArea,\n    areaUnit,\n    modalityUnit,\n  } = cachedVolumeStats;\n  const textLines: string[] = [];\n\n  if (radius) {\n    const radiusLine = isEmptyArea\n      ? `Radius: Oblique not supported`\n      : `Radius: ${roundNumber(radius)} ${radiusUnit}`;\n    textLines.push(radiusLine);\n  }\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n    textLines.push(areaLine);\n  }\n\n  if (mean) {\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  }\n\n  if (max) {\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  }\n\n  if (stdDev) {\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nCircleROITool.toolName = 'CircleROI';\nexport default CircleROITool;\n","import { Types } from '@cornerstonejs/core';\nimport * as math from '../../../utilities/math';\nimport type {\n  ISpline,\n  SplineProps,\n  SplineLineSegment,\n  ClosestControlPoint,\n  ClosestSplinePoint,\n  ClosestPoint,\n  ControlPointInfo,\n  SplineCurveSegment,\n} from '../../../types';\n\ntype CurveSegmentDistanceSquared = {\n  curveSegmentIndex: number;\n  curveSegment: SplineCurveSegment;\n  distanceSquared: number;\n};\n\n/**\n * Spline curve representation\n *\n * You can find more about splines in this video\n * https://www.youtube.com/watch?v=jvPPXbo87ds&t=11m20s\n */\nabstract class Spline implements ISpline {\n  private _controlPoints: Types.Point2[] = [];\n  private _resolution: number;\n  private _fixedResolution: boolean;\n  private _closed: boolean;\n  private _invalidated = false;\n  private _curveSegments: SplineCurveSegment[];\n  private _aabb: Types.AABB2;\n  private _length = 0;\n\n  constructor(props?: SplineProps) {\n    this._controlPoints = [];\n    this._resolution = props?.resolution ?? 20;\n    this._fixedResolution = props?.fixedResolution ?? false;\n    this._closed = props?.closed ?? false;\n    this._invalidated = true;\n  }\n\n  /**\n   * Return the control points array\n   *\n   * Any external access should be done through getControlPoints because it\n   * clones the points to make sure the data will not get changed by the caller\n   */\n  protected get controlPoints(): Types.Point2[] {\n    return this._controlPoints;\n  }\n\n  /** Number of control points */\n  public get numControlPoints(): number {\n    return this._controlPoints.length;\n  }\n\n  /** Resolution of the spline curve (greater than or equal to 0) */\n  public get resolution(): number {\n    return this._resolution;\n  }\n\n  /** Set the resolution of the spline curve */\n  public set resolution(resolution: number) {\n    if (this._fixedResolution || this._resolution === resolution) {\n      return;\n    }\n\n    this._resolution = resolution;\n    this.invalidated = true;\n  }\n\n  /** Fixed resolution\n   *\n   * Linar spline is one of the splines that does not allow changing the resolution\n   * for better performance otherwise it would calculate and render 20 line segments\n   * instead of a single one..\n   */\n  public get fixedResolution() {\n    return this._fixedResolution;\n  }\n\n  /** Flag that is set to true when the curve is already closed */\n  public get closed(): boolean {\n    return this._closed;\n  }\n\n  /** Set the curve as closed which connects the last to the first point */\n  public set closed(closed: boolean) {\n    if (this._closed === closed) {\n      return;\n    }\n\n    this._closed = closed;\n    this.invalidated = true;\n  }\n\n  /** Axis-aligned bounding box (minX, minY, maxX, maxY) */\n  public get aabb(): Types.AABB2 {\n    this._update();\n    return this._aabb;\n  }\n\n  /** Length of the spline curve in pixels */\n  public get length(): number {\n    this._update();\n    return this._length;\n  }\n\n  /**\n   * Flag that is set to true when the spline needs to be updated. The update\n   * runs automaticaly when needed (eg: getPolylinePoints).\n   */\n  public get invalidated(): boolean {\n    return this._invalidated;\n  }\n\n  /**\n   * Sets the spline as invalid when curve segments need to be recalculated\n   * or as valid after recomputing the curves\n   */\n  protected set invalidated(invalidated: boolean) {\n    this._invalidated = invalidated;\n  }\n\n  /**\n   * Bézier curves have tangent points connected to control points\n   * @returns True if the spline has tangent point or false otherwise\n   */\n  public hasTangentPoints() {\n    return false;\n  }\n\n  /**\n   * Add a control point to the end of the array\n   * @param point - Control point (2D)\n   */\n  public addControlPoint(point: Types.Point2): void {\n    this._controlPoints.push([point[0], point[1]]);\n    this.invalidated = true;\n  }\n\n  /**\n   * Add a list of control poits to the end of the array\n   * @param points - Control points to be added\n   */\n  public addControlPoints(points: Types.Point2[]): void {\n    points.forEach((point) => this.addControlPoint(point));\n  }\n\n  /**\n   * Add a control point specifying its `u` value in Parameter Space which is a number from 0 to N\n   * where N is the number of curve segments. The integer part is the curve segment index and the\n   * decimal part is the `t` value on that curve segment.\n   * @param u - `u` value in Parameter Space\n   */\n  public addControlPointAtU(u: number): ControlPointInfo {\n    const lineSegment = this._getLineSegmentAt(u);\n    const { start: startPoint, end: endPoint } = lineSegment.points;\n    const curveSegmentIndex = Math.floor(u);\n    const curveSegment = this._curveSegments[curveSegmentIndex];\n    const t = u - Math.floor(curveSegmentIndex);\n    const controlPointPos: Types.Point2 = [\n      startPoint[0] + t * (endPoint[0] - startPoint[0]),\n      startPoint[1] + t * (endPoint[1] - startPoint[1]),\n    ];\n\n    const insertIndex =\n      this._controlPoints.indexOf(curveSegment.controlPoints.p1) + 1;\n\n    this._controlPoints.splice(insertIndex, 0, controlPointPos);\n    this.invalidated = true;\n\n    return {\n      index: insertIndex,\n      point: controlPointPos,\n    };\n  }\n\n  /**\n   * Delete a control point given its index\n   * @param index - Control point index to be removed\n   * @returns True if the control point is removed or false otherwise\n   */\n  public deleteControlPointByIndex(index: number): boolean {\n    const minControlPoints = this._closed ? 3 : 1;\n    const canDelete =\n      index >= 0 &&\n      index < this._controlPoints.length &&\n      this._controlPoints.length > minControlPoints;\n\n    if (!canDelete) {\n      return false;\n    }\n\n    this._controlPoints.splice(index, 1);\n    this.invalidated = true;\n\n    return true;\n  }\n\n  /**\n   * Remove all control points\n   */\n  public clearControlPoints(): void {\n    this._controlPoints = [];\n    this.invalidated = true;\n  }\n\n  /**\n   * Replace all control points by some new ones\n   * @param points - Control points to be added to the array\n   */\n  public setControlPoints(points: Types.Point2[]): void {\n    this.clearControlPoints();\n    this.addControlPoints(points);\n  }\n\n  /**\n   * Update the coordinate of a control point given its index\n   * @param index - Control point index\n   * @param newControlPoint - New control point\n   */\n  public updateControlPoint(\n    index: number,\n    newControlPoint: Types.Point2\n  ): void {\n    if (index < 0 || index >= this._controlPoints.length) {\n      throw new Error('Index out of bounds');\n    }\n\n    this._controlPoints[index] = [...newControlPoint];\n    this.invalidated = true;\n  }\n\n  /**\n   * Get a list with all control points. The control points are cloned to prevent\n   * any caller from changing them resulting in unexpected behaviors\n   * @returns - List of all control points\n   */\n  public getControlPoints(): Types.Point2[] {\n    return this._controlPoints.map((controlPoint) => [\n      controlPoint[0],\n      controlPoint[1],\n    ]);\n  }\n\n  /**\n   * Finds the closest control point given a 2D point\n   * @param point - Reference point\n   * @returns Closest control point\n   */\n  public getClosestControlPoint(point: Types.Point2): ClosestControlPoint {\n    const controlPoints = this._controlPoints;\n    let minSquaredDist = Infinity;\n    let closestPointIndex = -1;\n\n    for (let i = 0, len = controlPoints.length; i < len; i++) {\n      const controlPoint = controlPoints[i];\n      const dx = point[0] - controlPoint[0];\n      const dy = point[1] - controlPoint[1];\n      const squaredDist = dx * dx + dy * dy;\n\n      if (squaredDist < minSquaredDist) {\n        minSquaredDist = squaredDist;\n        closestPointIndex = i;\n      }\n    }\n\n    return {\n      index: closestPointIndex,\n      point:\n        closestPointIndex === -1\n          ? undefined\n          : [...controlPoints[closestPointIndex]],\n      distance: Math.sqrt(minSquaredDist),\n    };\n  }\n\n  /**\n   * Finds the closest control point given a 2D point and a maximum distance\n   * @param point - Reference 2D point\n   * @param maxDist - Maximum distance\n   * @returns Closest control point that is within the given range or undefined otherwise\n   */\n  public getClosestControlPointWithinDistance(\n    point: Types.Point2,\n    maxDist: number\n  ): ClosestControlPoint {\n    const closestControlPoint = this.getClosestControlPoint(point);\n\n    return closestControlPoint.distance <= maxDist\n      ? closestControlPoint\n      : undefined;\n  }\n\n  /**\n   * Finds the closest point on the spline curve given 2D point\n   * @param point - Reference 2D point\n   * @returns Closest point on the spline curve\n   */\n  public getClosestPoint(point: Types.Point2): ClosestSplinePoint {\n    this._update();\n\n    const curveSegmentsDistInfo =\n      this._getCurveSegmmentsDistanceSquaredInfo(point);\n\n    if (!curveSegmentsDistInfo.length) {\n      return;\n    }\n\n    // Sort the curves by distance because in most cases the closest point may be in the first\n    // curve segment and there is no need to check all next line segments if theirs curve segments'\n    // AABB is not closest compared to the minDist found saving a lot of cpu time.\n    curveSegmentsDistInfo.sort(\n      (csA, csB) => csA.distanceSquared - csB.distanceSquared\n    );\n\n    let closestPoint: Types.Point2;\n    let closestPointCurveSegmentIndex = -1;\n    let minDistSquared = Infinity;\n    let minDistCurveSegment: SplineCurveSegment;\n    let minDistLineSegment: SplineLineSegment;\n\n    for (let i = 0; i < curveSegmentsDistInfo.length; i++) {\n      const curveSegmentDistInfo = curveSegmentsDistInfo[i];\n\n      // If the distance to curve segments' AABB is greater than the minDist\n      // it does not need to waste time verifying each line segment\n      if (curveSegmentDistInfo.distanceSquared > minDistSquared) {\n        continue;\n      }\n\n      const { curveSegmentIndex, curveSegment } = curveSegmentDistInfo;\n      const { lineSegments } = curveSegment;\n\n      for (let j = 0; j < lineSegments.length; j++) {\n        const lineSegment = lineSegments[j];\n        const { point: lineSegPoint, distanceSquared: lineSegDistSquared } =\n          math.lineSegment.distanceToPointSquaredInfo(\n            lineSegment.points.start,\n            lineSegment.points.end,\n            point\n          );\n\n        if (lineSegDistSquared < minDistSquared) {\n          minDistLineSegment = lineSegment;\n          closestPointCurveSegmentIndex = curveSegmentIndex;\n          minDistCurveSegment = curveSegmentDistInfo.curveSegment;\n          closestPoint = lineSegPoint;\n          minDistSquared = lineSegDistSquared;\n        }\n      }\n    }\n\n    const curveSegmentLengthToPoint =\n      minDistLineSegment.previousLineSegmentsLength +\n      math.point.distanceToPoint(minDistLineSegment.points.start, closestPoint);\n\n    const t = curveSegmentLengthToPoint / minDistCurveSegment.length;\n    const u = closestPointCurveSegmentIndex + t;\n\n    return {\n      point: closestPoint,\n      uValue: u,\n      distance: Math.sqrt(minDistSquared),\n    };\n  }\n\n  /**\n   * Finds the closest point on the straight line that connects all control points given a 2D point\n   * @param point - Reference point\n   * @returns Closest point on the straight line that connects all control points\n   */\n  public getClosestPointOnControlPointLines(point: Types.Point2): ClosestPoint {\n    const linePoints = [...this._controlPoints];\n\n    if (this._closed) {\n      linePoints.push(this._controlPoints[0]);\n    }\n\n    if (!linePoints.length) {\n      return;\n    }\n\n    let closestPoint: Types.Point2;\n    let minDistSquared = Infinity;\n    let startPoint = linePoints[0];\n\n    for (let i = 1, len = linePoints.length; i < len; i++) {\n      const endPoint = linePoints[i];\n      const { point: lineSegPoint, distanceSquared: lineSegDistSquared } =\n        math.lineSegment.distanceToPointSquaredInfo(\n          startPoint,\n          endPoint,\n          point\n        );\n\n      if (lineSegDistSquared < minDistSquared) {\n        closestPoint = lineSegPoint;\n        minDistSquared = lineSegDistSquared;\n      }\n\n      startPoint = endPoint;\n    }\n\n    return {\n      point: closestPoint,\n      distance: Math.sqrt(minDistSquared),\n    };\n  }\n\n  /**\n   * Get all points necessary to draw a spline curve\n   * @returns Array with all points necessary to draw a spline curve\n   */\n  public getPolylinePoints(): Types.Point2[] {\n    this._update();\n\n    return this._convertCurveSegmentsToPolyline(this._curveSegments);\n  }\n\n  /**\n   * Get all points necessary to draw the preview of the changes that shall be\n   * made to the spline if a new control point is added to it\n   * @param controlPointPreview - New control point preview\n   * @param closeDistance - Distance to the first control point to consider it a closed spline\n   * @returns Array with all points necessary to draw a spline curve preview\n   */\n  public getPreviewPolylinePoints(\n    controlPointPreview: Types.Point2,\n    closeDistance: number\n  ): Types.Point2[] {\n    if (this._closed) {\n      return [];\n    }\n\n    this._update();\n\n    // Check if the new control point would be close to the first one\n    // in order to create a preview of a closed spline\n    const closestControlPoint = this.getClosestControlPointWithinDistance(\n      controlPointPreview,\n      closeDistance\n    );\n\n    const closeSpline = closestControlPoint?.index === 0;\n    const previewCurveSegments = this.getPreviewCurveSegments(\n      controlPointPreview,\n      closeSpline\n    );\n\n    return previewCurveSegments?.length\n      ? this._convertCurveSegmentsToPolyline(previewCurveSegments)\n      : [];\n  }\n\n  /**\n   * Checks if a point is near to the spline curve\n   * @param point - Reference point\n   * @param maxDist - Maximum allowed distance\n   * @returns True if the point is close to the spline curve or false otherwise\n   */\n  public isPointNearCurve(point: Types.Point2, maxDist: number): boolean {\n    this._update();\n\n    const curveSegments = this._getCurveSegmmentsWithinDistance(point, maxDist);\n    const maxDistSquared = maxDist * maxDist;\n\n    // Check if the point is close to the spline and doest waste time checking each curve/line\n    for (let i = 0; i < curveSegments.length; i++) {\n      const { lineSegments } = curveSegments[i];\n\n      for (let j = 0; j < lineSegments.length; j++) {\n        const lineSegment = lineSegments[j];\n        const lineDistSquared = math.lineSegment.distanceToPointSquared(\n          lineSegment.points.start,\n          lineSegment.points.end,\n          point\n        );\n\n        if (lineDistSquared <= maxDistSquared) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Checks if a 2D point is inside the spline curve.\n   *\n   * A point is inside a curve/polygon if the number of intersections between the horizontal\n   * ray emanating from the given point and to the right and the line segments is odd.\n   * https://www.eecs.umich.edu/courses/eecs380/HANDOUTS/PROJ2/InsidePoly.html\n   *\n   * @param point - 2D Point\n   * @returns True is the point is inside the spline curve or false otherwise\n   */\n  public containsPoint(point: Types.Point2): boolean {\n    this._update();\n\n    const controlPoints = this._controlPoints;\n\n    if (controlPoints.length < 3) {\n      return false;\n    }\n\n    const curveSegments = [...this._curveSegments];\n    const closingCurveSegment =\n      this._getClosingCurveSegmentWithStraightLineSegment();\n\n    if (closingCurveSegment) {\n      curveSegments.push(closingCurveSegment);\n    }\n\n    let numIntersections = 0;\n\n    for (let i = 0; i < curveSegments.length; i++) {\n      const curveSegment = curveSegments[i];\n      const { aabb: curveSegAABB } = curveSegment;\n      const mayIntersectCurveSegment =\n        point[0] <= curveSegAABB.maxX &&\n        point[1] >= curveSegAABB.minY &&\n        point[1] < curveSegAABB.maxY;\n\n      // Skip all line segments if it is not possible to intersect the curve segment\n      if (!mayIntersectCurveSegment) {\n        continue;\n      }\n\n      const { lineSegments } = curveSegment;\n\n      for (let i = 0; i < lineSegments.length; i++) {\n        const lineSegment = lineSegments[i];\n        const { aabb: lineSegmentAABB } = lineSegment;\n        const mayIntersectLineSegment =\n          point[0] <= lineSegmentAABB.maxX &&\n          point[1] >= lineSegmentAABB.minY &&\n          point[1] < lineSegmentAABB.maxY;\n\n        if (mayIntersectLineSegment) {\n          const { start: p1, end: p2 } = lineSegment.points;\n          const isVerticalLine = p1[0] === p2[0];\n          const xIntersection =\n            ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];\n\n          numIntersections +=\n            isVerticalLine || point[0] <= xIntersection ? 1 : 0;\n        }\n      }\n    }\n\n    return numIntersections % 2 === 1;\n  }\n\n  protected abstract getTransformMatrix(): number[];\n\n  protected abstract getSplineCurves(): SplineCurveSegment[];\n\n  protected abstract getPreviewCurveSegments(\n    controlPointPreview: Types.Point2,\n    closeSpline: boolean\n  ): SplineCurveSegment[];\n\n  private _update() {\n    if (!this._invalidated) {\n      return;\n    }\n\n    const curveSegments = this.getSplineCurves();\n    let length = 0;\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for (let i = 0, len = curveSegments.length; i < len; i++) {\n      const { aabb: curveSegAABB, length: curveSegLength } = curveSegments[i];\n\n      minX = minX <= curveSegAABB.minX ? minX : curveSegAABB.minX;\n      minY = minY <= curveSegAABB.minY ? minY : curveSegAABB.minY;\n      maxX = maxX >= curveSegAABB.maxX ? maxX : curveSegAABB.maxX;\n      maxY = maxY >= curveSegAABB.maxY ? maxY : curveSegAABB.maxY;\n      length += curveSegLength;\n    }\n\n    this._curveSegments = curveSegments;\n    this._aabb = { minX, minY, maxX, maxY };\n    this._length = length;\n    this._invalidated = false;\n  }\n\n  private _convertCurveSegmentsToPolyline(\n    curveSegments: SplineCurveSegment[]\n  ): Types.Point2[] {\n    this._update();\n\n    const polylinePoints: Types.Point2[] = [];\n\n    curveSegments.forEach(({ lineSegments }, curveSegIndex) => {\n      lineSegments.forEach((lineSegment, lineSegIndex) => {\n        // Add the start point before adding all end points\n        if (curveSegIndex === 0 && lineSegIndex === 0) {\n          polylinePoints.push([...lineSegment.points.start]);\n        }\n\n        // Always add 1 because the first segment stored its start point at the first position\n        polylinePoints.push([...lineSegment.points.end]);\n      });\n    });\n\n    return polylinePoints;\n  }\n\n  /**\n   * Returns all curve segments and theirs respective squared distance to a given point\n   * @param point - Reference point\n   * @returns Curve segments and theirs respective squared distance to a given point\n   */\n  private _getCurveSegmmentsDistanceSquaredInfo(\n    point: Types.Point2\n  ): CurveSegmentDistanceSquared[] {\n    this._update();\n\n    const curveSegmentsDistanceSquared: CurveSegmentDistanceSquared[] = [];\n    const { _curveSegments: curveSegments } = this;\n\n    for (let i = 0; i < curveSegments.length; i++) {\n      const curveSegment = curveSegments[i];\n      const distanceSquared = math.aabb.distanceToPointSquared(\n        curveSegment.aabb,\n        point\n      );\n\n      curveSegmentsDistanceSquared.push({\n        curveSegmentIndex: i,\n        curveSegment,\n        distanceSquared,\n      });\n    }\n\n    return curveSegmentsDistanceSquared;\n  }\n\n  private _getCurveSegmmentsWithinDistance(\n    point: Types.Point2,\n    maxDist: number\n  ): SplineCurveSegment[] {\n    this._update();\n\n    const maxDistSquared = maxDist * maxDist;\n\n    // Does not waste time checking each curve segment if the point is not event\n    // close to the spline's AABB\n    if (math.aabb.distanceToPointSquared(this.aabb, point) > maxDistSquared) {\n      return [];\n    }\n\n    const curveSegmentsDistance =\n      this._getCurveSegmmentsDistanceSquaredInfo(point);\n    const curveSegmentsWithinRange: SplineCurveSegment[] = [];\n\n    for (let i = 0, len = curveSegmentsDistance.length; i < len; i++) {\n      const { curveSegment, distanceSquared: curveSegmentDistSquared } =\n        curveSegmentsDistance[i];\n\n      if (curveSegmentDistSquared <= maxDistSquared) {\n        curveSegmentsWithinRange.push(curveSegment);\n      }\n    }\n\n    return curveSegmentsWithinRange;\n  }\n\n  private _getLineSegmentAt(u: number): SplineLineSegment {\n    this._update();\n\n    const curveSegmentIndex = Math.floor(u);\n    const t = u - curveSegmentIndex;\n    const curveSegment = this._curveSegments[curveSegmentIndex];\n    const { lineSegments } = curveSegment;\n    const pointLength = curveSegment.length * t;\n\n    for (let i = 0; i < lineSegments.length; i++) {\n      const lineSegment = lineSegments[i];\n      const lengthEnd =\n        lineSegment.previousLineSegmentsLength + lineSegment.length;\n\n      if (\n        pointLength >= lineSegment.previousLineSegmentsLength &&\n        pointLength <= lengthEnd\n      ) {\n        return lineSegment;\n      }\n    }\n  }\n\n  /**\n   * Creates a curve segment with a single line segment connecting the start and end control points\n   * @returns A curve segment that closes the spline\n   */\n  private _getClosingCurveSegmentWithStraightLineSegment(): SplineCurveSegment {\n    if (this.closed) {\n      return;\n    }\n\n    const controlPoints = this._controlPoints;\n    const startControlPoint = controlPoints[0];\n    const endControlPoint = controlPoints[controlPoints.length - 1];\n\n    // The only properties needed are `points` and `aabb`. All the other ones may undefined\n    const closingLineSegment: SplineLineSegment = {\n      points: {\n        start: [...startControlPoint],\n        end: [...endControlPoint],\n      },\n      aabb: {\n        minX: Math.min(startControlPoint[0], endControlPoint[0]),\n        minY: Math.min(startControlPoint[1], endControlPoint[1]),\n        maxX: Math.max(startControlPoint[0], endControlPoint[0]),\n        maxY: Math.max(startControlPoint[1], endControlPoint[1]),\n      },\n    } as SplineLineSegment;\n\n    // The only properties needed are `lineSegments` and `aabb`. All the other ones may undefined\n    return {\n      aabb: {\n        minX: closingLineSegment.aabb.minX,\n        minY: closingLineSegment.aabb.minY,\n        maxX: closingLineSegment.aabb.maxX,\n        maxY: closingLineSegment.aabb.maxY,\n      },\n      lineSegments: [closingLineSegment],\n    } as SplineCurveSegment;\n  }\n}\n\nexport { Spline as default, Spline };\n","import { vec4, mat4 } from 'gl-matrix';\nimport { Types } from '@cornerstonejs/core';\nimport { Spline } from './Spline';\nimport * as math from '../../../utilities/math';\nimport type { SplineCurveSegment, SplineLineSegment } from '../../../types';\n\n// The `u` in Parameter Space used when spliting a curve segment into line segments must\n// be greater than or equal to `curveSegmentIndex` and smaller than `curveSegmentIndex + 1`.\n// In this case we are using `curveSegmentIndex + 1 - MAX_U_ERROR`\nconst MAX_U_ERROR = 1e-8;\n\n/**\n * Base class for all cubic splines\n */\nabstract class CubicSpline extends Spline {\n  protected getPreviewCurveSegments(\n    controlPointPreview: Types.Point2,\n    closeSpline: boolean\n  ): SplineCurveSegment[] {\n    const previewNumCurveSegments = this._getNumCurveSegments() + 1;\n    const startCurveSegIndex = Math.max(0, previewNumCurveSegments - 2);\n    const endCurveSegIndex = closeSpline\n      ? previewNumCurveSegments\n      : previewNumCurveSegments - 1;\n    const transformMatrix = this.getTransformMatrix();\n    const controlPoints = [...this.controlPoints];\n    const curveSegments: SplineCurveSegment[] = [];\n\n    if (!closeSpline) {\n      controlPoints.push(controlPointPreview);\n    }\n\n    for (let i = startCurveSegIndex; i <= endCurveSegIndex; i++) {\n      const curveSegment = this._getCurveSegment(\n        i,\n        transformMatrix,\n        controlPoints,\n        closeSpline\n      );\n\n      curveSegments.push(curveSegment);\n    }\n\n    return curveSegments;\n  }\n\n  protected getSplineCurves(): SplineCurveSegment[] {\n    const numCurveSegments = this._getNumCurveSegments();\n    const curveSegments: SplineCurveSegment[] = new Array(numCurveSegments);\n\n    if (numCurveSegments <= 0) {\n      return [];\n    }\n\n    const transformMatrix = this.getTransformMatrix();\n    let previousCurveSegmentsLength = 0;\n\n    for (let i = 0; i < numCurveSegments; i++) {\n      const curveSegment = this._getCurveSegment(i, transformMatrix);\n\n      curveSegment.previousCurveSegmentsLength = previousCurveSegmentsLength;\n      curveSegments[i] = curveSegment;\n\n      previousCurveSegmentsLength += curveSegment.length;\n    }\n\n    return curveSegments;\n  }\n\n  private _getNumCurveSegments(\n    controlPoints: Types.Point2[] = this.controlPoints,\n    closed: boolean = this.closed\n  ): number {\n    return closed\n      ? controlPoints.length\n      : Math.max(0, controlPoints.length - 1);\n  }\n\n  /**\n   * Get a point on a spline curve given `u` value\n   *\n   * @param u - `u` value in Parameter Space that must be between 0 and N where N is the number of\n   *   curve segments for opened splines or any negative/positive number for closed splines\n   * @returns - Point (x, y) on the spline. It may return `undefined` when `u` is smaller than 0\n   *   or greater than N for opened splines\n   */\n  private _getPoint(\n    u: number,\n    transformMatrix: number[],\n    controlPoints: Types.Point2[] = this.controlPoints,\n    closed: boolean = this.closed\n  ): Types.Point2 {\n    const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n    const uInt = Math.floor(u);\n    let curveSegmentIndex = uInt % numCurveSegments;\n\n    // `t` must be between 0 and 1\n    const t = u - uInt;\n\n    const curveSegmentIndexOutOfBounds =\n      curveSegmentIndex < 0 || curveSegmentIndex >= numCurveSegments;\n\n    if (curveSegmentIndexOutOfBounds) {\n      if (this.closed) {\n        // Wraps around when the index is negative or greater than or equal to `numSegments`\n        curveSegmentIndex =\n          (numCurveSegments + curveSegmentIndex) % numCurveSegments;\n      } else {\n        // Point is not on the spline curve\n        return;\n      }\n    }\n\n    const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(\n      curveSegmentIndex,\n      controlPoints,\n      closed\n    );\n\n    // Formula to find any point on a cubic spline curve given a `t` value\n    //\n    // P(t) = [1  t  t2  t3] | m00 m01 m02 m03 |  | P0 |\n    //                       | m10 m11 m12 m13 |  | P1 |\n    //                       | m20 m21 m22 m23 |  | P2 |\n    //                       | m30 m31 m32 m33 |  | P3 |\n\n    const tt = t * t;\n    const ttt = tt * t;\n    const tValues = vec4.fromValues(1, t, tt, ttt);\n\n    // Influential field values which tell us how much P0, P1, P2 and P3 influence\n    // each point of the curve\n    const qValues = vec4.transformMat4(\n      vec4.create(),\n      tValues,\n      transformMatrix as mat4\n    );\n\n    return [\n      vec4.dot(qValues, vec4.fromValues(p0[0], p1[0], p2[0], p3[0])),\n      vec4.dot(qValues, vec4.fromValues(p0[1], p1[1], p2[1], p3[1])),\n    ] as Types.Point2;\n  }\n\n  private _getCurveSegmentPoints(\n    curveSegmentIndex: number,\n    controlPoints: Types.Point2[] = this.controlPoints,\n    closed: boolean = this.closed\n  ) {\n    const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n    const p1Index = curveSegmentIndex;\n    const p0Index = p1Index - 1;\n    const p2Index = closed ? (p1Index + 1) % numCurveSegments : p1Index + 1;\n    const p3Index = p2Index + 1;\n    const p1 = controlPoints[p1Index];\n    const p2 = controlPoints[p2Index];\n    let p0;\n    let p3;\n\n    // P0 shall be negative when P1/P2 are the start/end points of the first curve segment\n    if (p0Index >= 0) {\n      p0 = controlPoints[p0Index];\n    } else {\n      p0 = closed\n        ? controlPoints[controlPoints.length - 1]\n        : math.point.mirror(p2, p1);\n    }\n\n    // P3 shall be negative when P1/P2 are the start/end points of the last curve segment\n    if (p3Index < controlPoints.length) {\n      p3 = controlPoints[p3Index];\n    } else {\n      p3 = closed ? controlPoints[0] : math.point.mirror(p1, p2);\n    }\n\n    return { p0, p1, p2, p3 };\n  }\n\n  private _getLineSegments(\n    curveSegmentIndex: number,\n    transformMatrix: number[],\n    controlPoints: Types.Point2[] = this.controlPoints,\n    closed: boolean = this.closed\n  ): SplineLineSegment[] {\n    const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n    const numLineSegments = this.resolution + 1;\n    const inc = 1 / numLineSegments;\n    const minU = curveSegmentIndex;\n    let maxU = minU + 1;\n\n    // 'u' must be greater than or equal to 0 and smaller than N where N is the number of segments\n    // otherwise it does not find the spline segment when it is not a closed curve because it is\n    // 0-based indexed. In this case `u` needs to get very close to the end point but never touch it\n    if (!closed && curveSegmentIndex === numCurveSegments - 1) {\n      maxU -= MAX_U_ERROR;\n    }\n\n    const lineSegments: SplineLineSegment[] = [];\n    let startPoint: Types.Point2;\n    let endPoint: Types.Point2;\n    let previousLineSegmentsLength = 0;\n\n    for (let i = 0, u = minU; i <= numLineSegments; i++, u += inc) {\n      // `u` may be greater than maxU in the last FOR loop due to number precision issue\n      u = u > maxU ? maxU : u;\n\n      const point = this._getPoint(u, transformMatrix, controlPoints, closed);\n\n      if (!i) {\n        startPoint = point;\n        continue;\n      }\n\n      endPoint = point;\n\n      const dx = endPoint[0] - startPoint[0];\n      const dy = endPoint[1] - startPoint[1];\n      const length = Math.sqrt(dx ** 2 + dy ** 2);\n      const aabb: Types.AABB2 = {\n        minX: startPoint[0] <= endPoint[0] ? startPoint[0] : endPoint[0],\n        maxX: startPoint[0] >= endPoint[0] ? startPoint[0] : endPoint[0],\n        minY: startPoint[1] <= endPoint[1] ? startPoint[1] : endPoint[1],\n        maxY: startPoint[1] >= endPoint[1] ? startPoint[1] : endPoint[1],\n      };\n\n      lineSegments.push({\n        points: {\n          start: startPoint,\n          end: endPoint,\n        },\n        aabb,\n        length,\n        previousLineSegmentsLength,\n      });\n\n      startPoint = endPoint;\n      previousLineSegmentsLength += length;\n    }\n\n    return lineSegments;\n  }\n\n  private _getCurveSegment(\n    curveSegmentIndex: number,\n    transformMatrix: number[] = this.getTransformMatrix(),\n    controlPoints: Types.Point2[] = this.controlPoints,\n    closed: boolean = this.closed\n  ): SplineCurveSegment {\n    // Cubic spline curves are mainly controlled by P1 and P2 points but\n    // they are also influenced by previous (P0) and next (P3) poins. For\n    // Cardinal, Linear and Catmull-Rom splines P1 and P2 are also known as\n    // knots because they are the connection between two curve segments.\n    const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(\n      curveSegmentIndex,\n      controlPoints,\n      closed\n    );\n    const lineSegments = this._getLineSegments(\n      curveSegmentIndex,\n      transformMatrix,\n      controlPoints,\n      closed\n    );\n    let curveSegmentLength = 0;\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    lineSegments.forEach(({ aabb: lineSegAABB, length: lineSegLength }) => {\n      minX = Math.min(minX, lineSegAABB.minX);\n      minY = Math.min(minY, lineSegAABB.minY);\n      maxX = Math.max(maxX, lineSegAABB.maxX);\n      maxY = Math.max(maxY, lineSegAABB.maxY);\n      curveSegmentLength += lineSegLength;\n    });\n\n    return {\n      controlPoints: { p0, p1, p2, p3 },\n      aabb: { minX, minY, maxX, maxY },\n      length: curveSegmentLength,\n      previousCurveSegmentsLength: 0,\n      lineSegments,\n    };\n  }\n}\n\nexport { CubicSpline as default, CubicSpline };\n","import { CubicSpline } from './CubicSpline';\nimport { CardinalSplineProps } from '../../../types';\n\nclass CardinalSpline extends CubicSpline {\n  private _scale: number;\n  private _fixedScale: boolean;\n\n  constructor(props?: CardinalSplineProps) {\n    super(props);\n    this._scale = props?.scale ?? 0.5;\n    this._fixedScale = props?.fixedScale ?? false;\n  }\n\n  public get scale() {\n    return this._scale;\n  }\n\n  public set scale(scale: number) {\n    if (this._fixedScale || this._scale === scale) {\n      return;\n    }\n\n    this._scale = scale;\n    this.invalidated = true;\n  }\n\n  public get fixedScale() {\n    return this._fixedScale;\n  }\n\n  protected getTransformMatrix(): number[] {\n    const { scale: s } = this;\n    const s2 = 2 * s;\n\n    // prettier-ignore\n    return [\n       0,      1,       0,   0,\n      -s,      0,       s,   0,\n      s2,  s - 3,  3 - s2,  -s,\n      -s,  2 - s,   s - 2,   s\n    ];\n  }\n}\n\nexport { CardinalSpline as default, CardinalSpline };\n","import { CardinalSpline } from './CardinalSpline';\n\n// TODO: LinearSpline should inherit from Spline\n\n/**\n * Linear spline matrix is the same one from Cardinal spline with scale equal\n * to 0. Then it can inherit from Spline using the matrix below or inherit from\n * CardinalSpline fixing the scale to 0\n *\n * Transformation Matrix:\n *      1,   0,\n *     -1,  -1,\n */\nclass LinearSpline extends CardinalSpline {\n  constructor() {\n    super({ resolution: 0, fixedResolution: true, scale: 0, fixedScale: true });\n  }\n}\n\nexport { LinearSpline as default, LinearSpline };\n","import { CardinalSpline } from './CardinalSpline';\n\n// Catmull-Rom spline matrix is a Cardinal spline with scale equal to 1/2. Then\n// it can inherit from CubicSpline using the matrix below or inherit from\n// CardinalSpline using a fixed scale equal to 0.5.\n//\n// Transformation Matrix:\n//      0,  2,  0,  0,\n//     -1,  0,  1,  0,\n//      2, -5,  4, -1,\n//     -1,  3, -3,  1\n\nclass CatmullRomSpline extends CardinalSpline {\n  constructor() {\n    super({ scale: 0.5, fixedScale: true });\n  }\n}\n\nexport { CatmullRomSpline as default, CatmullRomSpline };\n","import { mat4 } from 'gl-matrix';\nimport { CubicSpline } from './CubicSpline';\n\n// prettier-ignore\nconst TRANSFORM_MATRIX = mat4.multiplyScalar(\n  mat4.create(),\n  mat4.fromValues(\n     1,  4,  1,  0,\n    -3,  0,  3,  0,\n     3, -6,  3,  0,\n    -1,  3, -3,  1,\n  ),\n  1 / 6\n) as number[];\n\nclass BSpline extends CubicSpline {\n  protected getTransformMatrix(): number[] {\n    return TRANSFORM_MATRIX;\n  }\n}\n\nexport { BSpline as default, BSpline };\n","import {\n  getEnabledElement,\n  eventTarget,\n  triggerEvent,\n  utilities,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport {\n  getChildAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawPolyline as drawPolylineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport {\n  Events,\n  MouseBindings,\n  KeyboardBindings,\n  ChangeTypes,\n} from '../../enums';\nimport { resetElementCursor } from '../../cursors/elementCursor';\nimport type {\n  Annotation,\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  AnnotationRenderContext,\n} from '../../types';\nimport {\n  math,\n  throttle,\n  roundNumber,\n  triggerAnnotationRenderForViewportIds,\n  getCalibratedLengthUnitsAndScale,\n} from '../../utilities';\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\n\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport type { SplineROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport type {\n  AnnotationModifiedEventDetail,\n  ContourAnnotationCompletedEventDetail,\n} from '../../types/EventTypes';\nimport { ISpline } from '../../types/ISpline';\nimport { CardinalSpline } from './splines/CardinalSpline';\nimport { LinearSpline } from './splines/LinearSpline';\nimport { CatmullRomSpline } from './splines/CatmullRomSpline';\nimport { BSpline } from './splines/BSpline';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\n\nconst SPLINE_MIN_POINTS = 3;\nconst SPLINE_CLICK_CLOSE_CURVE_DIST = 10;\n\nconst DEFAULT_SPLINE_CONFIG = {\n  resolution: 20,\n  controlPointAdditionDistance: 6,\n  controlPointDeletionDistance: 6,\n  showControlPointsConnectors: false,\n  controlPointAdditionEnabled: true,\n  controlPointDeletionEnabled: true,\n};\n\nenum SplineTypesEnum {\n  Cardinal = 'CARDINAL',\n  Linear = 'LINEAR',\n  CatmullRom = 'CATMULLROM',\n  BSpline = 'BSPLINE',\n}\n\nenum SplineToolActions {\n  AddControlPoint = 'addControlPoint',\n  DeleteControlPoint = 'deleteControlPoint',\n}\n\nclass SplineROITool extends ContourSegmentationBaseTool {\n  static toolName;\n  static SplineTypes = SplineTypesEnum;\n  static Actions = SplineToolActions;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: SplineROIAnnotation;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    lastCanvasPoint?: Types.Point2;\n    contourHoleProcessingEnabled?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n  fireChangeOnUpdate: {\n    annotationUID: string;\n    changeType: ChangeTypes;\n    contourHoleProcessingEnabled: boolean;\n  } = null;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        calculateStats: true,\n        getTextLines: defaultGetTextLines,\n        /**\n         * Specify which modifier key is used to add a hole to a contour. The\n         * modifier must be pressed when the first point of a new contour is added.\n         */\n        contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n        /**\n         * The polyline may get processed in order to reduce the number of points\n         * for better performance and storage.\n         */\n        decimate: {\n          enabled: false,\n          /** A maximum given distance 'epsilon' to decide if a point should or\n           * shouldn't be added the resulting polyline which will have a lower\n           * number of points for higher `epsilon` values.\n           */\n          epsilon: 0.1,\n        },\n        spline: {\n          configuration: {\n            [SplineTypesEnum.Cardinal]: {\n              Class: CardinalSpline,\n              scale: 0.5,\n            },\n            [SplineTypesEnum.CatmullRom]: {\n              Class: CatmullRomSpline,\n            },\n            [SplineTypesEnum.Linear]: {\n              Class: LinearSpline,\n            },\n            [SplineTypesEnum.BSpline]: {\n              Class: BSpline,\n              controlPointAdditionEnabled: false,\n              controlPointDeletionEnabled: false,\n              showControlPointsConnectors: true,\n            },\n          },\n          type: SplineTypesEnum.CatmullRom,\n          drawPreviewEnabled: true,\n          lastControlPointDeletionKeys: ['Backspace', 'Delete'],\n        },\n        actions: {\n          [SplineToolActions.AddControlPoint]: {\n            method: 'addControlPointCallback',\n            bindings: [\n              {\n                mouseButton: MouseBindings.Primary,\n                modifierKey: KeyboardBindings.Shift,\n              },\n            ],\n          },\n          [SplineToolActions.DeleteControlPoint]: {\n            method: 'deleteControlPointCallback',\n            bindings: [\n              {\n                mouseButton: MouseBindings.Primary,\n                modifierKey: KeyboardBindings.Ctrl,\n              },\n            ],\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation(evt: EventTypes.InteractionEventType): SplineROIAnnotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const { canvas: canvasPos } = currentPoints;\n    const contourHoleProcessingEnabled =\n      getMouseModifierKey(evt.detail.event) ===\n      this.configuration.contourHoleAdditionModifierKey;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const annotation = this.createAnnotation(evt) as SplineROIAnnotation;\n\n    this.isDrawing = true;\n    this.addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n      lastCanvasPoint: canvasPos,\n      contourHoleProcessingEnabled,\n    };\n\n    this._activateDraw(element);\n    evt.preventDefault();\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  }\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: SplineROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const { instance: spline } = annotation.data.spline;\n\n    return spline.isPointNearCurve(canvasCoords, proximity);\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this._activateModify(element);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      const { points } = data.handles;\n\n      handleIndex = points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation,\n      contourHoleProcessingEnabled,\n    } = this.editData;\n    const { data } = annotation;\n    annotation.autoGenerated = false;\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    // Decide whether there's at least one point is outside image\n    const image = this.getTargetIdImage(\n      this.getTargetId(enabledElement.viewport),\n      enabledElement.renderingEngine\n    );\n    const { imageData, dimensions } = image;\n    this.isHandleOutsideImage = data.handles.points\n      .map((p) => utilities.transformWorldToIndex(imageData, p))\n      .some((index) => !utilities.indexWithinDimensions(index, dimensions));\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    const changeType = newAnnotation\n      ? ChangeTypes.Completed\n      : ChangeTypes.HandlesUpdated;\n    if (!this.fireChangeOnUpdate) {\n      this.fireChangeOnUpdate = {\n        annotationUID: annotation.annotationUID,\n        changeType,\n        contourHoleProcessingEnabled,\n      };\n    } else {\n      this.fireChangeOnUpdate.annotationUID = annotation.annotationUID;\n      this.fireChangeOnUpdate.changeType = changeType;\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  private _keyDownCallback = (evt: EventTypes.KeyDownEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const key = eventDetail.key ?? '';\n    const { lastControlPointDeletionKeys } = this.configuration.spline;\n    const deleteLastPoint = lastControlPointDeletionKeys.includes(key);\n\n    if (!deleteLastPoint) {\n      return;\n    }\n\n    const { annotation } = this.editData;\n    const { data } = annotation;\n\n    if (data.handles.points.length === SPLINE_MIN_POINTS) {\n      this.cancel(element);\n      return;\n    } else {\n      const controlPointIndex = data.handles.points.length - 1;\n      this._deleteControlPointByIndex(element, annotation, controlPointIndex);\n    }\n\n    evt.preventDefault();\n  };\n\n  private _mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\n    const { drawPreviewEnabled } = this.configuration.spline;\n\n    // Does not force a re-render if preview is not enabled\n    if (!drawPreviewEnabled) {\n      return;\n    }\n\n    const { element } = evt.detail;\n    const { renderingEngine } = getEnabledElement(element);\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData.lastCanvasPoint = evt.detail.currentPoints.canvas;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    evt.preventDefault();\n  };\n\n  private _mouseDownCallback = (evt: EventTypes.InteractionEventType): void => {\n    const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n\n    if (data.contour.closed) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const { canvas: canvasPoint, world: worldPoint } = currentPoints;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    let closeContour = data.handles.points.length >= 2 && doubleClick;\n    let addNewPoint = true;\n\n    // Check if user clicked on the first point to close the curve\n    if (data.handles.points.length >= 3) {\n      const { instance: spline } = data.spline;\n      const closestControlPoint = spline.getClosestControlPointWithinDistance(\n        canvasPoint,\n        SPLINE_CLICK_CLOSE_CURVE_DIST\n      );\n\n      if (closestControlPoint?.index === 0) {\n        addNewPoint = false;\n        closeContour = true;\n      }\n    }\n\n    if (addNewPoint) {\n      data.handles.points.push(worldPoint);\n    }\n\n    data.contour.closed = data.contour.closed || closeContour;\n    annotation.invalidated = true;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (data.contour.closed) {\n      this._endCallback(evt);\n    }\n\n    evt.preventDefault();\n  };\n\n  private _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      this.moveAnnotation(annotation, worldPosDelta);\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel(element: HTMLDivElement) {\n    // If it is not in mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n    if (newAnnotation) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    super.cancelAnnotation(annotation);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData = null;\n    return annotation.annotationUID;\n  }\n\n  /**\n   * Triggers an annotation completed event.\n   */\n  triggerAnnotationCompleted = (\n    annotation: SplineROIAnnotation,\n    contourHoleProcessingEnabled: boolean\n  ): void => {\n    const eventType = Events.ANNOTATION_COMPLETED;\n    const eventDetail: ContourAnnotationCompletedEventDetail = {\n      annotation,\n      changeType: ChangeTypes.Completed,\n      contourHoleProcessingEnabled,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n  };\n\n  /**\n   * Triggers an annotation modified event.\n   */\n  triggerAnnotationModified = (\n    annotation: SplineROIAnnotation,\n    enabledElement: Types.IEnabledElement,\n    changeType = ChangeTypes.StatsUpdated\n  ): void => {\n    const { viewportId, renderingEngineId } = enabledElement;\n    const eventType = Events.ANNOTATION_MODIFIED;\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n      changeType,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n  };\n\n  /**\n   * Triggers an annotation complete or modified event based on changeType.\n   */\n  triggerChangeEvent = (\n    annotation: SplineROIAnnotation,\n    enabledElement: Types.IEnabledElement,\n    changeType = ChangeTypes.StatsUpdated,\n    contourHoleProcessingEnabled\n  ): void => {\n    if (changeType === ChangeTypes.Completed) {\n      this.triggerAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n    } else {\n      this.triggerAnnotationModified(annotation, enabledElement, changeType);\n    }\n  };\n\n  private _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  private _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  private _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.KEY_DOWN, this._keyDownCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n    element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n    element.addEventListener(\n      Events.MOUSE_DOUBLE_CLICK,\n      this._mouseDownCallback\n    );\n\n    element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n  };\n\n  private _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.KEY_DOWN, this._keyDownCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n    element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n    element.removeEventListener(\n      Events.MOUSE_DOUBLE_CLICK,\n      this._mouseDownCallback\n    );\n\n    element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n  };\n\n  protected isContourSegmentationTool(): boolean {\n    // Disable contour segmentation behavior because it shall be activated only\n    // for SplineContourSegmentationTool\n    return false;\n  }\n\n  /**\n   * Render an annotation instance\n   * @param renderContext - Render context that contains the annotation, enabledElement, etc.\n   * @returns True if the annotation is rendered or false otherwise\n   */\n  protected renderAnnotationInstance(\n    renderContext: AnnotationRenderContext\n  ): boolean {\n    const { enabledElement, targetId, svgDrawingHelper, annotationStyle } =\n      renderContext;\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { element } = viewport;\n    const annotation = renderContext.annotation as SplineROIAnnotation;\n    const { annotationUID, data, highlighted } = annotation;\n    const { handles } = data;\n    const { points: controlPoints, activeHandleIndex } = handles;\n    const newAnnotation = this.editData?.newAnnotation;\n\n    const {\n      lineWidth,\n      lineDash,\n      color,\n      locked: annotationLocked,\n    } = annotationStyle;\n\n    const canvasCoordinates = controlPoints.map((p) =>\n      worldToCanvas(p)\n    ) as Types.Point2[];\n\n    const { drawPreviewEnabled } = this.configuration.spline;\n    const splineType = annotation.data.spline.type;\n    const splineConfig = this._getSplineConfig(splineType);\n    const spline = annotation.data.spline.instance;\n\n    const childAnnotations = getChildAnnotations(annotation);\n    const missingAnnotation = childAnnotations.findIndex((it) => !it);\n    if (missingAnnotation !== -1) {\n      // Child annotations go AWOL for a variety of reasons, so report is specifically here\n      throw new Error(\n        `Can't find annotation for child ${annotation.childAnnotationUIDs.join()}`\n      );\n    }\n    // Update current and all child annotations/splines\n    const splineAnnotationsGroup = [annotation, ...childAnnotations].filter(\n      (annotation) => this._isSplineROIAnnotation(annotation)\n    ) as SplineROIAnnotation[];\n\n    splineAnnotationsGroup.forEach((annotation) => {\n      const spline = this._updateSplineInstance(element, annotation);\n      const splinePolylineCanvas = spline.getPolylinePoints();\n\n      this.updateContourPolyline(\n        annotation,\n        {\n          points: splinePolylineCanvas,\n          closed: data.contour.closed,\n          targetWindingDirection: ContourWindingDirection.Clockwise,\n        },\n        viewport\n      );\n    });\n\n    // Let the base class render the contour\n    super.renderAnnotationInstance(renderContext);\n\n    // If cachedStats does not exist, or the areaUnit is missing (as part of\n    // import/hydration etc.), force to recalculate the stats from the points\n    if (\n      !data.cachedStats[targetId] ||\n      data.cachedStats[targetId].areaUnit == null\n    ) {\n      data.cachedStats[targetId] = {\n        Modality: null,\n        area: null,\n        areaUnit: null,\n      };\n\n      this._calculateCachedStats(annotation, element);\n    } else if (annotation.invalidated) {\n      this._throttledCalculateCachedStats(annotation, element);\n    }\n\n    let activeHandleCanvasCoords;\n\n    if (!annotationLocked && !this.editData && activeHandleIndex !== null) {\n      // Not locked or creating and hovering over handle, so render handle.\n      activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n    }\n\n    if (activeHandleCanvasCoords || newAnnotation || highlighted) {\n      const handleGroupUID = '0';\n\n      // Move this call to the base class (contour seg) in the near future\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        canvasCoordinates,\n        {\n          color,\n          lineWidth: Math.max(1, lineWidth),\n          handleRadius: '3',\n        }\n      );\n    }\n\n    if (\n      drawPreviewEnabled &&\n      spline.numControlPoints > 1 &&\n      this.editData?.lastCanvasPoint &&\n      !spline.closed\n    ) {\n      const { lastCanvasPoint } = this.editData;\n      const previewPolylinePoints = spline.getPreviewPolylinePoints(\n        lastCanvasPoint,\n        SPLINE_CLICK_CLOSE_CURVE_DIST\n      );\n\n      drawPolylineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        'previewSplineChange',\n        previewPolylinePoints,\n        {\n          color: '#9EA0CA',\n          lineDash,\n          lineWidth: 1,\n        }\n      );\n    }\n\n    if (splineConfig.showControlPointsConnectors) {\n      const controlPointsConnectors = [...canvasCoordinates];\n\n      // Connect the last point to the first one when the spline is closed\n      if (spline.closed) {\n        controlPointsConnectors.push(canvasCoordinates[0]);\n      }\n\n      drawPolylineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        'controlPointsConnectors',\n        controlPointsConnectors,\n        {\n          color: 'rgba(255, 255, 255, 0.5)',\n          lineWidth: 1,\n        }\n      );\n    }\n\n    this._renderStats(\n      annotation,\n      viewport,\n      svgDrawingHelper,\n      annotationStyle.textbox\n    );\n\n    if (this.fireChangeOnUpdate?.annotationUID === annotationUID) {\n      this.triggerChangeEvent(\n        annotation,\n        enabledElement,\n        this.fireChangeOnUpdate.changeType,\n        this.fireChangeOnUpdate.contourHoleProcessingEnabled\n      );\n      this.fireChangeOnUpdate = null;\n    }\n\n    annotation.invalidated = false;\n    return true;\n  }\n\n  /**\n   * Creates new interpolated handles for the spline control given the\n   * polyline data.  This allows creating the spline from polyline data\n   * directly.\n   */\n  protected createInterpolatedSplineControl(annotation) {\n    if (annotation.data.handles.points?.length) {\n      // The interpolation itself created the handles\n      return;\n    }\n    const { polyline } = annotation.data.contour;\n    if (!polyline || !polyline.length) {\n      return;\n    }\n    annotation.data.handles.points = [];\n    const { points } = annotation.data.handles;\n    const increment = Math.max(10, Math.floor(polyline.length / 20));\n    for (let i = 0; i < polyline.length - increment; i += increment) {\n      points.push(polyline[i]);\n    }\n    points.push(polyline[polyline.length - 1]);\n  }\n\n  protected createAnnotation(evt: EventTypes.InteractionEventType): Annotation {\n    const contourAnnotation = super.createAnnotation(evt);\n    const { world: worldPos } = evt.detail.currentPoints;\n    const { type: splineType } = this.configuration.spline;\n    const splineConfig = this._getSplineConfig(splineType);\n    const spline = new splineConfig.Class();\n    const createSpline = () => ({\n      type: splineConfig.type,\n      instance: spline,\n      resolution: splineConfig.resolution,\n    });\n\n    // Add an action to create a new spline data on creating an interpolated\n    // instance.\n    let onInterpolationComplete;\n    if (this.configuration.interpolation?.enabled) {\n      onInterpolationComplete = (annotation) => {\n        annotation.data.spline ||= createSpline();\n        this.createInterpolatedSplineControl(annotation);\n      };\n    }\n\n    return <SplineROIAnnotation>utilities.deepMerge(contourAnnotation, {\n      data: {\n        handles: {\n          points: [[...worldPos]],\n        },\n        spline: createSpline(),\n        cachedStats: {},\n      },\n      onInterpolationComplete,\n    });\n  }\n\n  private _renderStats = (\n    annotation,\n    viewport,\n    svgDrawingHelper,\n    textboxStyle\n  ) => {\n    const data = annotation.data;\n    const targetId = this.getTargetId(viewport);\n\n    if (!data.spline.instance.closed || !textboxStyle.visibility) {\n      return;\n    }\n\n    const textLines = this.configuration.getTextLines(data, targetId);\n    if (!textLines || textLines.length === 0) {\n      return;\n    }\n\n    const canvasCoordinates = data.handles.points.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n    if (!data.handles.textBox.hasMoved) {\n      const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n      data.handles.textBox.worldPosition =\n        viewport.canvasToWorld(canvasTextBoxCoords);\n    }\n\n    const textBoxPosition = viewport.worldToCanvas(\n      data.handles.textBox.worldPosition\n    );\n\n    const textBoxUID = 'textBox';\n    const boundingBox = drawLinkedTextBoxSvg(\n      svgDrawingHelper,\n      annotation.annotationUID ?? '',\n      textBoxUID,\n      textLines,\n      textBoxPosition,\n      canvasCoordinates,\n      {},\n      textboxStyle\n    );\n\n    const { x: left, y: top, width, height } = boundingBox;\n\n    data.handles.textBox.worldBoundingBox = {\n      topLeft: viewport.canvasToWorld([left, top]),\n      topRight: viewport.canvasToWorld([left + width, top]),\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\n    };\n  };\n\n  addControlPointCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation\n  ) => {\n    const { data } = annotation;\n    const splineType = data.spline.type;\n    const splineConfig = this._getSplineConfig(splineType);\n    const maxDist = splineConfig.controlPointAdditionDistance;\n\n    if (splineConfig.controlPointAdditionEnabled === false) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    const { instance: spline } = data.spline;\n    const canvasPos = evt.detail.currentPoints.canvas;\n    const closestPointInfo = spline.getClosestPoint(canvasPos);\n\n    if (closestPointInfo.distance > maxDist) {\n      return;\n    }\n\n    // Add a point at the `u` position from Parameter Space\n    const { index, point: canvasPoint } = spline.addControlPointAtU(\n      closestPointInfo.uValue\n    );\n\n    data.handles.points.splice(index, 0, canvasToWorld(canvasPoint));\n    annotation.invalidated = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  private _deleteControlPointByIndex(\n    element: HTMLDivElement,\n    annotation: SplineROIAnnotation,\n    controlPointIndex: number\n  ) {\n    const enabledElement = getEnabledElement(element);\n    const { points: controlPoints } = annotation.data.handles;\n\n    // There is no curve with only 2 points\n    if (controlPoints.length === 3) {\n      removeAnnotation(annotation.annotationUID);\n    } else {\n      controlPoints.splice(controlPointIndex, 1);\n    }\n\n    const { renderingEngine } = enabledElement;\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    annotation.invalidated = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  }\n\n  deleteControlPointCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation\n  ) => {\n    const splineType = annotation.data.spline.type;\n    const splineConfig = this._getSplineConfig(splineType);\n    const maxDist = splineConfig.controlPointDeletionDistance;\n\n    if (splineConfig.controlPointDeletionEnabled === false) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { element, currentPoints } = eventDetail;\n    const { canvas: canvasPos } = currentPoints;\n    const { instance: spline } = annotation.data.spline;\n    const closestControlPoint = spline.getClosestControlPointWithinDistance(\n      canvasPos,\n      maxDist\n    );\n\n    if (!closestControlPoint) {\n      return;\n    }\n\n    this._deleteControlPointByIndex(\n      element,\n      annotation,\n      closestControlPoint.index\n    );\n  };\n\n  _isSplineROIAnnotation(\n    annotation: Annotation\n  ): annotation is SplineROIAnnotation {\n    return !!(<SplineROIAnnotation>annotation).data?.spline;\n  }\n\n  /**\n   * Get a spline config merged with the default settings.\n   * @param type - Spline type (CARDINAL, CATMULLROM, LINEAR or BSPLINE)\n   * @returns Spline configuration\n   */\n  private _getSplineConfig(type: string) {\n    const { configuration: config } = this;\n    const splineConfigs = config.spline.configuration;\n\n    return Object.assign({ type }, DEFAULT_SPLINE_CONFIG, splineConfigs[type]);\n  }\n\n  private _updateSplineInstance(\n    element: HTMLDivElement,\n    annotation: SplineROIAnnotation\n  ): ISpline {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { data } = annotation;\n    const { type: splineType, instance: spline } = annotation.data.spline;\n    const splineConfig = this._getSplineConfig(splineType);\n    const worldPoints = data.handles.points;\n    const canvasPoints = worldPoints.map(worldToCanvas);\n    const resolution =\n      splineConfig.resolution !== undefined\n        ? parseInt(splineConfig.resolution)\n        : undefined;\n    const scale =\n      splineConfig.scale !== undefined\n        ? parseFloat(splineConfig.scale)\n        : undefined;\n\n    spline.setControlPoints(canvasPoints);\n    spline.closed = !!data.contour.closed;\n\n    // Update spline resolution in case it has changed\n    if (\n      !spline.fixedResolution &&\n      resolution !== undefined &&\n      spline.resolution !== resolution\n    ) {\n      spline.resolution = resolution;\n      annotation.invalidated = true;\n    }\n\n    // Update Cardinal spline scale in case it has changed\n    if (\n      spline instanceof CardinalSpline &&\n      !spline.fixedScale &&\n      scale !== undefined &&\n      spline.scale !== scale\n    ) {\n      spline.scale = scale;\n      annotation.invalidated = true;\n    }\n\n    return spline;\n  }\n\n  private _calculateCachedStats = (\n    annotation: SplineROIAnnotation,\n    element: HTMLDivElement\n  ) => {\n    if (!this.configuration.calculateStats) {\n      return;\n    }\n    const data = annotation.data;\n\n    if (!data.contour.closed) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { cachedStats } = data;\n    const { polyline: points } = data.contour;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { metadata } = image;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // Using an arbitrary start point (canvasPoint), calculate the\n      // mm spacing for the canvas in the X and Y directions.\n      const canvasPoint = canvasCoordinates[0];\n      const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n      const deltaXPoint = viewport.canvasToWorld([\n        canvasPoint[0] + 1,\n        canvasPoint[1],\n      ]);\n      const deltaYPoint = viewport.canvasToWorld([\n        canvasPoint[0],\n        canvasPoint[1] + 1,\n      ]);\n\n      const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n      const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n\n      const { imageData } = image;\n      const { scale, areaUnits } = getCalibratedLengthUnitsAndScale(\n        image,\n        () => {\n          const {\n            maxX: canvasMaxX,\n            maxY: canvasMaxY,\n            minX: canvasMinX,\n            minY: canvasMinY,\n          } = math.polyline.getAABB(canvasCoordinates);\n\n          const topLeftBBWorld = viewport.canvasToWorld([\n            canvasMinX,\n            canvasMinY,\n          ]);\n\n          const topLeftBBIndex = utilities.transformWorldToIndex(\n            imageData,\n            topLeftBBWorld\n          );\n\n          const bottomRightBBWorld = viewport.canvasToWorld([\n            canvasMaxX,\n            canvasMaxY,\n          ]);\n\n          const bottomRightBBIndex = utilities.transformWorldToIndex(\n            imageData,\n            bottomRightBBWorld\n          );\n\n          return [topLeftBBIndex, bottomRightBBIndex];\n        }\n      );\n      let area = math.polyline.getArea(canvasCoordinates) / scale / scale;\n\n      // Convert from canvas_pixels ^2 to mm^2\n      area *= deltaInX * deltaInY;\n\n      cachedStats[targetId] = {\n        Modality: metadata.Modality,\n        area,\n        areaUnit: areaUnits,\n      };\n    }\n\n    this.triggerAnnotationModified(\n      annotation,\n      enabledElement,\n      ChangeTypes.StatsUpdated\n    );\n\n    return cachedStats;\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, isEmptyArea, areaUnit } = cachedVolumeStats;\n  const textLines: string[] = [];\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n\n    textLines.push(areaLine);\n  }\n\n  return textLines;\n}\n\nSplineROITool.toolName = 'SplineROI';\nexport default SplineROITool;\n","import { utilities } from '@cornerstonejs/core';\nimport { PublicToolProps } from '../../types';\nimport SplineROITool from './SplineROITool';\n\nclass SplineContourSegmentationTool extends SplineROITool {\n  static toolName;\n\n  constructor(toolProps: PublicToolProps) {\n    const initialProps = utilities.deepMerge(\n      {\n        configuration: {\n          calculateStats: false,\n        },\n      },\n      toolProps\n    );\n\n    super(initialProps);\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Re-enable contour segmentation behavior disabled by SplineROITool\n    return true;\n  }\n}\n\nSplineContourSegmentationTool.toolName = 'SplineContourSegmentationTool';\nexport default SplineContourSegmentationTool;\n","type BucketNode<T> = {\n  value: T;\n  next: BucketNode<T>;\n};\n\n/**\n * Circular Bucket Queue.\n *\n * Returns input'd points in sorted order. All operations run in roughly O(1)\n * time (for input with small cost values), but it has a strict requirement:\n *\n * If the most recent point had a cost of c, any points added should have a cost\n * c' in the range c <= c' <= c + (capacity - 1).\n */\nexport class BucketQueue<T> {\n  private _bucketCount: number;\n  private _mask: number;\n  private _size: number;\n  private _currentBucketIndex: number;\n  private _getPriority: (item: T) => number;\n  private _areEqual: (itemA: T, itemB: T) => boolean;\n  private _buckets: BucketNode<T>[];\n\n  /**\n   * @param bits - Number of bits.\n   * @param getPriority - A function that returns the priority of an item\n   */\n  constructor({\n    numBits,\n    getPriority,\n    areEqual,\n  }: {\n    numBits: number;\n    getPriority?: (item: T) => number;\n    areEqual?: (itemA: T, itemB: T) => boolean;\n  }) {\n    this._bucketCount = 1 << numBits; // # of buckets = 2^numBits\n    this._mask = this._bucketCount - 1; // 2^numBits - 1 = index mask\n    this._size = 0;\n    this._currentBucketIndex = 0;\n    this._buckets = this._buildArray(this._bucketCount);\n\n    this._getPriority =\n      typeof getPriority !== 'undefined'\n        ? getPriority\n        : (item) => item as unknown as number;\n\n    this._areEqual =\n      typeof areEqual === 'function'\n        ? areEqual\n        : (itemA, itemB) => itemA === itemB;\n  }\n\n  /**\n   * Prepend item to the list in the appropriate bucket\n   * @param item - Item to be added to the queue based on its priority\n   */\n  public push(item: T) {\n    const bucketIndex = this._getBucketIndex(item);\n    const oldHead = this._buckets[bucketIndex];\n    const newHead: BucketNode<T> = {\n      value: item,\n      next: oldHead,\n    };\n\n    this._buckets[bucketIndex] = newHead;\n    this._size++;\n  }\n\n  public pop(): T {\n    if (this._size === 0) {\n      throw new Error('Cannot pop because the queue is empty.');\n    }\n\n    // Find first empty bucket\n    while (this._buckets[this._currentBucketIndex] === null) {\n      this._currentBucketIndex =\n        (this._currentBucketIndex + 1) % this._bucketCount;\n    }\n\n    // All items in bucket have same cost, return the first one\n    const ret = this._buckets[this._currentBucketIndex];\n\n    this._buckets[this._currentBucketIndex] = ret.next;\n    this._size--;\n\n    return ret.value;\n  }\n\n  /**\n   * Tries to remove item from queue.\n   * @param item - Item to be removed from the queue\n   * @returns True if the item is found and removed or false otherwise\n   */\n  public remove(item: T): boolean {\n    if (!item) {\n      return false;\n    }\n\n    // To find node, go to bucket and search through unsorted list.\n    const bucketIndex = this._getBucketIndex(item);\n    const firstBucketNode = this._buckets[bucketIndex];\n    let node = firstBucketNode;\n    let prevNode: BucketNode<T>;\n\n    while (node !== null) {\n      if (this._areEqual(item, node.value)) {\n        break;\n      }\n\n      prevNode = node;\n      node = node.next;\n    }\n\n    // Item not found\n    if (node === null) {\n      return false;\n    }\n\n    // Item found and it needs to be removed from the list\n    if (node === firstBucketNode) {\n      this._buckets[bucketIndex] = node.next;\n    } else {\n      prevNode.next = node.next;\n    }\n\n    this._size--;\n    return true;\n  }\n\n  public isEmpty(): boolean {\n    return this._size === 0;\n  }\n\n  /**\n   * Return the bucket index\n   * @param item - Item for which the bucket shall be returned\n   * @returns Bucket index for the item provided\n   */\n  private _getBucketIndex(item): number {\n    return this._getPriority(item) & this._mask;\n  }\n\n  /**\n   * Create array and initialze pointers to null\n   * @param size - Size of the new array\n   * @returns An array with `N` buckets pointing to null\n   */\n  private _buildArray(size) {\n    const buckets = new Array(size);\n    buckets.fill(null);\n    return buckets;\n  }\n}\n","import { Types, utilities } from '@cornerstonejs/core';\n\nimport { BucketQueue } from '../BucketQueue';\n\nconst { isEqual } = utilities;\nconst MAX_UINT32 = 4294967295;\nconst TWO_THIRD_PI = 2 / (3 * Math.PI);\n\n/**\n * Scissors\n *\n * Ref: Eric N. Mortensen, William A. Barrett, Interactive Segmentation with\n *   Intelligent Scissors, Graphical Models and Image Processing, Volume 60,\n *   Issue 5, September 1998, Pages 349-384, ISSN 1077-3169,\n *   DOI: 10.1006/gmip.1998.0480.\n *\n * {@link http://www.sciencedirect.com/science/article/B6WG4-45JB8WN-9/2/6fe59d8089fd1892c2bfb82283065579}\n *\n * Implementation based on MIT licensed code at:\n * {@link http://code.google.com/p/livewire-javascript/}\n */\nexport class LivewireScissors {\n  private searchGranularityBits: number;\n  private searchGranularity: number;\n\n  /** Width of the image */\n  public readonly width: number;\n\n  /** Height of the image */\n  public readonly height: number;\n\n  /** Grayscale image */\n  private grayscalePixelData: Types.PixelDataTypedArray;\n\n  // Laplace zero-crossings (either 0 or 1).\n  private laplace: Float32Array;\n\n  /** Gradient vector magnitude for each pixel */\n  private gradMagnitude: Float32Array;\n\n  /** Gradient of each pixel in the x-direction */\n  private gradXNew: Float32Array;\n\n  /** Gradient of each pixel in the y-direction */\n  private gradYNew: Float32Array;\n\n  /** Dijkstra - start point */\n  private startPoint: Types.Point2;\n\n  /** Dijkstra - store the state of a pixel (visited/unvisited) */\n  private visited: boolean[];\n\n  /** Dijkstra - map a point to its parent along the shortest path to root (start point) */\n  private parents: Uint32Array;\n\n  /** Dijkstra - store the cost to go from the start point to each node */\n  private costs: Float32Array;\n\n  /** Dijkstra - BucketQueue to sort items by priority */\n  private priorityQueueNew: BucketQueue<number>;\n\n  constructor(\n    grayscalePixelData: Types.PixelDataTypedArray,\n    width: number,\n    height: number\n  ) {\n    const numPixels = grayscalePixelData.length;\n\n    this.searchGranularityBits = 8; // Bits of resolution for BucketQueue.\n    this.searchGranularity = 1 << this.searchGranularityBits; //bits.\n\n    this.width = width;\n    this.height = height;\n\n    this.grayscalePixelData = grayscalePixelData;\n    this.laplace = null;\n    this.gradXNew = null;\n    this.gradYNew = null;\n\n    this.laplace = this._computeLaplace();\n    this.gradMagnitude = this._computeGradient();\n    this.gradXNew = this._computeGradientX();\n    this.gradYNew = this._computeGradientY();\n\n    this.visited = new Array(numPixels);\n    this.parents = new Uint32Array(numPixels);\n    this.costs = new Float32Array(numPixels);\n  }\n\n  public startSearch(startPoint: Types.Point2): void {\n    const startPointIndex = this._getPointIndex(startPoint[1], startPoint[0]);\n\n    this.startPoint = null;\n    this.visited.fill(false);\n    this.parents.fill(MAX_UINT32);\n    this.costs.fill(Infinity);\n    this.priorityQueueNew = new BucketQueue<number>({\n      numBits: this.searchGranularityBits,\n      getPriority: this._getPointCost,\n    });\n\n    this.startPoint = startPoint;\n    this.costs[startPointIndex] = 0;\n    this.priorityQueueNew.push(startPointIndex);\n  }\n\n  /**\n   * Finds a nearby point with a minimum cost nearby\n   *\n   * @param testPoint - to look nearby\n   * @param delta - how long a distance to look\n   * @returns A point having the minimum weighted distance from the testPoint\n   */\n  public findMinNearby(testPoint: Types.Point2, delta = 2) {\n    const [x, y] = testPoint;\n    const { costs } = this;\n\n    const xRange = [\n      Math.max(0, x - delta),\n      Math.min(x + delta + 1, this.width),\n    ];\n    const yRange = [\n      Math.max(0, y - delta),\n      Math.min(y + delta + 1, this.height),\n    ];\n    let minValue = costs[this._getPointIndex(y, x)] * 0.8;\n\n    let minPoint = testPoint;\n    for (let xTest = xRange[0]; xTest < xRange[1]; xTest++) {\n      for (let yTest = yRange[0]; yTest < yRange[1]; yTest++) {\n        // Cost values are 0...1, with 1 being a poor choice for the\n        // livewire fitting - thus, we want to minimize our value, so the\n        // distance cost should be low for the center point.\n        const distanceCost =\n          1 -\n          (Math.abs(xTest - testPoint[0]) + Math.abs(yTest - testPoint[1])) /\n            delta /\n            2;\n        const weightCost = costs[this._getPointIndex(yTest, xTest)];\n\n        const weight = weightCost * 0.8 + distanceCost * 0.2;\n        if (weight < minValue) {\n          minPoint = [xTest, yTest];\n          minValue = weight;\n        }\n      }\n    }\n    return minPoint;\n  }\n\n  /**\n   * Runs Dijsktra until it finds a path from the start point to the target\n   * point. Once it reaches the target point all the state is preserved in order\n   * to save processing time the next time the method is called for a new target\n   * point. The search is restarted whenever `startSearch` is called.\n   * @param targetPoint - Target point\n   * @returns An array with all points for the shortest path found that goes\n   * from startPoint to targetPoint.\n   */\n  public findPathToPoint(targetPoint: Types.Point2): Types.Point2[] {\n    if (!this.startPoint) {\n      throw new Error('There is no search in progress');\n    }\n\n    const {\n      startPoint,\n      _getPointIndex: index,\n      _getPointCoordinate: coord,\n    } = this;\n    const startPointIndex = index(startPoint[1], startPoint[0]);\n    const targetPointIndex = index(targetPoint[1], targetPoint[0]);\n    const {\n      visited: visited,\n      parents: parents,\n      costs: cost,\n      priorityQueueNew: priorityQueue,\n    } = this;\n\n    if (targetPointIndex === startPointIndex) {\n      return [];\n    }\n\n    // Stop searching until there are no more items in the queue or it has\n    // reached the target point. In case it reaches the target all the remaining\n    // items will stay in the queue then once the user moves the mouse to a new\n    // location the search can continue from where it left off.\n    while (\n      !priorityQueue.isEmpty() &&\n      parents[targetPointIndex] === MAX_UINT32\n    ) {\n      const pointIndex = priorityQueue.pop();\n\n      if (visited[pointIndex]) {\n        continue;\n      }\n\n      const point = coord(pointIndex);\n      const neighborsPoints = this._getNeighborPoints(point);\n\n      visited[pointIndex] = true;\n\n      // Update the cost of all neighbors that have higher costs\n      for (let i = 0, len = neighborsPoints.length; i < len; i++) {\n        const neighborPoint = neighborsPoints[i];\n        const neighborPointIndex = index(neighborPoint[1], neighborPoint[0]);\n        const dist = this._getWeightedDistance(point, neighborPoint);\n        const neighborCost = cost[pointIndex] + dist;\n\n        if (neighborCost < cost[neighborPointIndex]) {\n          if (cost[neighborPointIndex] !== Infinity) {\n            // The item needs to be removed from the priority queue and\n            // re-added in order to be moved to the right bucket.\n            priorityQueue.remove(neighborPointIndex);\n          }\n\n          cost[neighborPointIndex] = neighborCost;\n          parents[neighborPointIndex] = pointIndex;\n          priorityQueue.push(neighborPointIndex);\n        }\n      }\n    }\n\n    const pathPoints = [];\n    let pathPointIndex = targetPointIndex;\n\n    while (pathPointIndex !== MAX_UINT32) {\n      pathPoints.push(coord(pathPointIndex));\n      pathPointIndex = parents[pathPointIndex];\n    }\n\n    return pathPoints.reverse();\n  }\n\n  /**\n   * Convert a point coordinate (x,y) into a point index\n   * @param index - Point index\n   * @returns Point coordinate (x,y)\n   */\n  private _getPointIndex = (row: number, col: number) => {\n    const { width } = this;\n    return row * width + col;\n  };\n\n  /**\n   * Convert a point index into a point coordinate (x,y)\n   * @param index - Point index\n   * @returns Point coordinate (x,y)\n   */\n  private _getPointCoordinate = (index: number): Types.Point2 => {\n    const x = index % this.width;\n    const y = Math.floor(index / this.width);\n\n    return [x, y];\n  };\n\n  /**\n   * Calculate the delta X between a given point and its neighbor at the right\n   * @param x - Point x-coordinate\n   * @param y - Point y-coordinate\n   * @returns Delta Y between the given point and its neighbor at the right\n   */\n  private _getDeltaX(x: number, y: number) {\n    const { grayscalePixelData: data, width } = this;\n    let index = this._getPointIndex(y, x);\n\n    // If it is at the end, back up one\n    if (x + 1 === width) {\n      index--;\n    }\n\n    return data[index + 1] - data[index];\n  }\n\n  /**\n   * Calculate the delta Y between a given point and its neighbor at the bottom\n   * @param x - Point x-coordinate\n   * @param y - Point y-coordinate\n   * @returns Delta Y between the given point and its neighbor at the bottom\n   */\n  private _getDeltaY(x: number, y: number) {\n    const { grayscalePixelData: data, width, height } = this;\n    let index = this._getPointIndex(y, x);\n\n    // If it is at the end, back up one\n    if (y + 1 === height) {\n      index -= width;\n    }\n\n    return data[index] - data[index + width];\n  }\n\n  private _getGradientMagnitude(x: number, y: number): number {\n    const dx = this._getDeltaX(x, y);\n    const dy = this._getDeltaY(x, y);\n\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  /**\n   *  Calculate the Laplacian of Gaussian (LoG) value for a given pixel\n   *\n   *     Kernel Indexes           Laplacian of Gaussian Kernel\n   *   __  __  02  __  __              0   0   1   0   0\n   *   __  11  12  13  __              0   1   2   1   0\n   *   20  21  22  23  24              1   2 -16   2   1\n   *   __  31  32  33  __              0   1   2   1   0\n   *   __  __  42  __  __              0   0   1   0   0\n   */\n  private _getLaplace(x: number, y: number): number {\n    const { grayscalePixelData: data, _getPointIndex: index } = this;\n\n    // Points related to the kernel indexes\n    const p02 = data[index(y - 2, x)];\n    const p11 = data[index(y - 1, x - 1)];\n    const p12 = data[index(y - 1, x)];\n    const p13 = data[index(y - 1, x + 1)];\n    const p20 = data[index(y, x - 2)];\n    const p21 = data[index(y, x - 1)];\n    const p22 = data[index(y, x)];\n    const p23 = data[index(y, x + 1)];\n    const p24 = data[index(y, x + 2)];\n    const p31 = data[index(y + 1, x - 1)];\n    const p32 = data[index(y + 1, x)];\n    const p33 = data[index(y + 1, x + 1)];\n    const p42 = data[index(y + 2, x)];\n\n    // Laplacian of Gaussian\n    let lap = p02;\n    lap += p11 + 2 * p12 + p13;\n    lap += p20 + 2 * p21 - 16 * p22 + 2 * p23 + p24;\n    lap += p31 + 2 * p32 + p33;\n    lap += p42;\n\n    return lap;\n  }\n\n  /**\n   * Returns a 2D array of gradient magnitude values for grayscale. The values\n   * are scaled between 0 and 1, and then flipped, so that it works as a cost\n   * function.\n   * @returns A gradient object\n   */\n  private _computeGradient(): Float32Array {\n    const { width, height } = this;\n    const gradient = new Float32Array(width * height);\n\n    let pixelIndex = 0;\n    let max = 0;\n    let x = 0;\n    let y = 0;\n\n    for (y = 0; y < height - 1; y++) {\n      for (x = 0; x < width - 1; x++) {\n        gradient[pixelIndex] = this._getGradientMagnitude(x, y);\n        max = Math.max(gradient[pixelIndex], max);\n        pixelIndex++;\n      }\n\n      // Make the last column the same as the previous one because there is\n      // no way to calculate `dx` since x+1 gets out of bounds\n      gradient[pixelIndex] = gradient[pixelIndex - 1];\n      pixelIndex++;\n    }\n\n    // Make the last row the same as the previous one because there is\n    // no way to calculate `dy` since y+1 gets out of bounds\n    for (let len = gradient.length; pixelIndex < len; pixelIndex++) {\n      gradient[pixelIndex] = gradient[pixelIndex - width];\n    }\n\n    // Flip and scale\n    for (let i = 0, len = gradient.length; i < len; i++) {\n      gradient[i] = 1 - gradient[i] / max;\n    }\n\n    return gradient;\n  }\n\n  /**\n   * Returns a 2D array of Laplacian of Gaussian values\n   *\n   * @param grayscale - The input grayscale\n   * @returns A laplace object\n   */\n  private _computeLaplace(): Float32Array {\n    const { width, height, _getPointIndex: index } = this;\n    const laplace = new Float32Array(width * height);\n\n    // Make the first two rows low cost\n    laplace.fill(1, 0, index(2, 0));\n\n    for (let y = 2; y < height - 2; y++) {\n      // Make the first two columns low cost\n      laplace[index(y, 0)] = 1;\n      laplace[index(y, 1)] = 1;\n\n      for (let x = 2; x < width - 2; x++) {\n        // Threshold needed to get rid of clutter.\n        laplace[index(y, x)] = this._getLaplace(x, y) > 0.33 ? 0 : 1;\n      }\n\n      // Make the last two columns low cost\n      laplace[index(y, width - 2)] = 1;\n      laplace[index(y, width - 1)] = 1;\n    }\n\n    // Make the last two rows low cost\n    laplace.fill(1, index(height - 2, 0));\n\n    return laplace;\n  }\n\n  /**\n   * Returns 2D array of x-gradient values for grayscale\n   *\n   * @param grayscale - Grayscale pixel data\n   * @returns 2D x-gradient array\n   */\n  private _computeGradientX(): Float32Array {\n    const { width, height } = this;\n    const gradX = new Float32Array(width * height);\n    let pixelIndex = 0;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        gradX[pixelIndex++] = this._getDeltaX(x, y);\n      }\n    }\n\n    return gradX;\n  }\n\n  /**\n   * Compute the Y gradient.\n   *\n   * @param grayscale - Grayscale pixel data\n   * @returns 2D array of y-gradient values for grayscale\n   */\n  private _computeGradientY(): Float32Array {\n    const { width, height } = this;\n    const gradY = new Float32Array(width * height);\n    let pixelIndex = 0;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        gradY[pixelIndex++] = this._getDeltaY(x, y);\n      }\n    }\n\n    return gradY;\n  }\n\n  /**\n   * Compute the gradient unit vector.\n   * @param px - Point x-coordinate\n   * @param py - Point y-coordinate\n   * @returns Gradient vector at (px, py), scaled to a magnitude of 1\n   */\n  private _getGradientUnitVector(px: number, py: number) {\n    const { gradXNew, gradYNew, _getPointIndex: index } = this;\n\n    const pointGradX = gradXNew[index(py, px)];\n    const pointGradY = gradYNew[index(py, px)];\n    let gradVecLen = Math.sqrt(\n      pointGradX * pointGradX + pointGradY * pointGradY\n    );\n\n    // To avoid possible divide-by-0 errors\n    gradVecLen = Math.max(gradVecLen, 1e-100);\n\n    return [pointGradX / gradVecLen, pointGradY / gradVecLen];\n  }\n\n  /**\n   * Compute the gradient direction, in radians, between two points\n   *\n   * @param px - Point `p` x-coordinate of point p.\n   * @param py - Point `p` y-coordinate of point p.\n   * @param qx - Point `q` x-coordinate of point q.\n   * @param qy - Point `q` y-coordinate of point q.\n   * @returns Gradient direction\n   */\n  private _getGradientDirection(\n    px: number,\n    py: number,\n    qx: number,\n    qy: number\n  ): number {\n    const dgpUnitVec = this._getGradientUnitVector(px, py);\n    const gdqUnitVec = this._getGradientUnitVector(qx, qy);\n\n    let dp = dgpUnitVec[1] * (qx - px) - dgpUnitVec[0] * (qy - py);\n    let dq = gdqUnitVec[1] * (qx - px) - gdqUnitVec[0] * (qy - py);\n\n    // Make sure dp is positive, to keep things consistent\n    if (dp < 0) {\n      dp = -dp;\n      dq = -dq;\n    }\n    if (px !== qx && py !== qy) {\n      // It's going diagonally between pixels\n      dp *= Math.SQRT1_2;\n      dq *= Math.SQRT1_2;\n    }\n    dq = Math.min(Math.max(dq, -1), 1);\n\n    const direction =\n      TWO_THIRD_PI * (Math.acos(Math.min(dp, 1)) + Math.acos(dq));\n    if (isNaN(direction) || !isFinite(direction)) {\n      console.warn('Found non-direction:', px, py, qx, qy, dp, dq, direction);\n      return 1;\n    }\n    return direction;\n  }\n\n  /** Gets the cost to go from A to B */\n  public getCost(pointA, pointB): number {\n    return this._getWeightedDistance(pointA, pointB);\n  }\n\n  /**\n   * Return a weighted distance between two points\n   */\n  private _getWeightedDistance(pointA: Types.Point2, pointB: Types.Point2) {\n    const { _getPointIndex: index, width, height } = this;\n    const [aX, aY] = pointA;\n    const [bX, bY] = pointB;\n    // Assign a cost of 1 to any points outside the image, prevents using invalid\n    // points\n    if (bX < 0 || bX >= width || bY < 0 || bY >= height) {\n      return 1;\n    }\n    // Use a cost of 0 if the point was outside and is now going inside\n    if (aX < 0 || aY < 0 || aX >= width || aY >= height) {\n      return 0;\n    }\n\n    const bIndex = index(bY, bX);\n\n    // Weighted distance function\n    let gradient = this.gradMagnitude[bIndex];\n\n    if (aX === bX || aY === bY) {\n      // The distance is Euclidean-ish; non-diagonal edges should be shorter\n      gradient *= Math.SQRT1_2;\n    }\n\n    const laplace = this.laplace[bIndex];\n    const direction = this._getGradientDirection(aX, aY, bX, bY);\n\n    return 0.43 * gradient + 0.43 * laplace + 0.11 * direction;\n  }\n\n  /**\n   * Get up to 8 neighbors points\n   * @param point - Reference point\n   * @returns Up to eight neighbor points\n   */\n  private _getNeighborPoints(point: Types.Point2): Types.Point2[] {\n    const { width, height } = this;\n    const list: Types.Point2[] = [];\n\n    const sx = Math.max(point[0] - 1, 0);\n    const sy = Math.max(point[1] - 1, 0);\n    const ex = Math.min(point[0] + 1, width - 1);\n    const ey = Math.min(point[1] + 1, height - 1);\n\n    for (let y = sy; y <= ey; y++) {\n      for (let x = sx; x <= ex; x++) {\n        if (x !== point[0] || y !== point[1]) {\n          list.push([x, y]);\n        }\n      }\n    }\n\n    return list;\n  }\n\n  private _getPointCost = (pointIndex: number): number => {\n    return Math.round(this.searchGranularity * this.costs[pointIndex]);\n  };\n\n  /**\n   * Create a livewire scissor instance from RAW pixel data\n   * @param pixelData - Raw pixel data\n   * @param width - Width of the image\n   * @param height - Height of the image\n   * @param voiRange - VOI Range\n   * @returns A LivewireScissors instance\n   */\n  public static createInstanceFromRawPixelData(\n    pixelData: Float32Array,\n    width: number,\n    height: number,\n    voiRange: Types.VOIRange\n  ) {\n    const numPixels = pixelData.length;\n    const grayscalePixelData = new Float32Array(numPixels);\n    const { lower: minPixelValue, upper: maxPixelValue } = voiRange;\n    const pixelRange = maxPixelValue - minPixelValue;\n\n    for (let i = 0, len = pixelData.length; i < len; i++) {\n      // Grayscale values must be between 0 and 1\n      grayscalePixelData[i] = Math.max(\n        0,\n        Math.min(1, (pixelData[i] - minPixelValue) / pixelRange)\n      );\n    }\n\n    return new LivewireScissors(grayscalePixelData, width, height);\n  }\n}\n","import { Types } from '@cornerstonejs/core';\n/**\n * Path that contains points and control points to draw a path\n * used by the livewire tool\n */\nexport class LivewirePath {\n  /**\n   * List of points.\n   */\n  public pointArray: Types.Point2[];\n\n  /**\n   * List of control points indexes\n   */\n  private _controlPointIndexes: number[];\n\n  /**\n   * @param inputPointArray - The list of Point2D that make the path (optional).\n   * @param inputControlPointIndexArray - The list of control point of path, as indexes (optional).\n   *   Note: first and last point do not need to be equal.\n   */\n  constructor(\n    inputPointArray?: Types.Point2[],\n    inputControlPointIndexArray?: number[]\n  ) {\n    this.pointArray = inputPointArray ? inputPointArray.slice() : [];\n    this._controlPointIndexes = inputControlPointIndexArray\n      ? inputControlPointIndexArray.slice()\n      : [];\n  }\n\n  /**\n   * Get a point of the list.\n   *\n   * @param index - The index of the point to get\n   * @returns The Point2D at the given index.\n   */\n  public getPoint(index: number): Types.Point2 {\n    return this.pointArray[index];\n  }\n\n  /**\n   * Get the last point of the list.\n   *\n   * @returns The last point of the list.\n   */\n  public getLastPoint(): Types.Point2 {\n    return this.pointArray[this.pointArray.length - 1];\n  }\n\n  /**\n   * Is the given point a control point.\n   *\n   * @param point - The 2D point to check.\n   * @returns True if a control point, false otherwise.\n   */\n  public isControlPoint(point: Types.Point2): boolean {\n    const index = this.pointArray.indexOf(point);\n    if (index !== -1) {\n      return this._controlPointIndexes.indexOf(index) !== -1;\n    } else {\n      throw new Error('Error: isControlPoint called with not in list point.');\n    }\n  }\n\n  /**\n   * Add a point to the path.\n   *\n   * @param point - The 2D point to add.\n   */\n  public addPoint(point: Types.Point2) {\n    this.pointArray.push(point);\n  }\n\n  /**\n   * Add a control point to the path.\n   *\n   * @param point - The 2D point to make a control point.\n   */\n  public addControlPoint(point: Types.Point2) {\n    const index = this.pointArray.indexOf(point);\n\n    if (index !== -1) {\n      this._controlPointIndexes.push(index);\n    } else {\n      throw new Error('Cannot mark a non registered point as control point.');\n    }\n  }\n\n  public getControlPoints() {\n    return this._controlPointIndexes.map((i) => this.pointArray[i]);\n  }\n\n  public getNumControlPoints(): number {\n    return this._controlPointIndexes.length;\n  }\n\n  public removeLastControlPoint(): void {\n    if (this._controlPointIndexes.length) {\n      this._controlPointIndexes.pop();\n    }\n  }\n\n  public getLastControlPoint(): Types.Point2 {\n    if (this._controlPointIndexes.length) {\n      return this.pointArray[\n        this._controlPointIndexes[this._controlPointIndexes.length - 1]\n      ];\n    }\n  }\n\n  public removeLastPoints(count: number) {\n    this.pointArray.splice(this.pointArray.length - count, count);\n  }\n\n  /**\n   * Add points to the path.\n   *\n   * @param newPointArray - The list of 2D points to add.\n   */\n  public addPoints(newPointArray: Types.Point2[]) {\n    this.pointArray = this.pointArray.concat(newPointArray);\n  }\n\n  /**\n   * Prepend a path to this one.\n   *\n   * @param other - The path to append.\n   */\n  public prependPath(other: LivewirePath): void {\n    const otherSize = other.pointArray.length;\n    const shiftedIndexArray: number[] = [];\n\n    this.pointArray = other.pointArray.concat(this.pointArray);\n\n    for (let i = 0; i < this._controlPointIndexes.length; ++i) {\n      shiftedIndexArray[i] = this._controlPointIndexes[i] + otherSize;\n    }\n\n    this._controlPointIndexes =\n      other._controlPointIndexes.concat(shiftedIndexArray);\n  }\n\n  /**\n   * Append a path to this one.\n   *\n   * @param other - The path to append.\n   */\n  public appendPath(other: LivewirePath): void {\n    this.addPoints(other.pointArray);\n    other._controlPointIndexes.forEach((point) =>\n      this._controlPointIndexes.push(point)\n    );\n  }\n}\n","import { vec3 } from 'gl-matrix';\nimport {\n  getEnabledElement,\n  utilities as csUtils,\n  VolumeViewport,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { removeAnnotation } from '../../stateManagement/annotation/annotationState';\nimport { drawHandles as drawHandlesSvg } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events, KeyboardBindings, ChangeTypes } from '../../enums';\nimport { resetElementCursor } from '../../cursors/elementCursor';\nimport type {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\nimport { math, triggerAnnotationRenderForViewportIds } from '../../utilities';\nimport findHandlePolylineIndex from '../../utilities/contours/findHandlePolylineIndex';\nimport { LivewireContourAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport {\n  triggerAnnotationModified,\n  triggerContourAnnotationCompleted,\n} from '../../stateManagement/annotation/helpers/state';\n\nimport { LivewireScissors } from '../../utilities/livewire/LivewireScissors';\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\n\nconst CLICK_CLOSE_CURVE_SQR_DIST = 10 ** 2; // px\n\nclass LivewireContourTool extends ContourSegmentationBaseTool {\n  public static toolName: string;\n  protected scissors: LivewireScissors;\n  /** The scissors from the right handle, used for editing */\n  protected scissorsRight: LivewireScissors;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: LivewireContourAnnotation;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    lastCanvasPoint?: Types.Point2;\n    confirmedPath?: LivewirePath;\n    currentPath?: LivewirePath;\n    /** The next path segment, on the other side of the handle */\n    confirmedPathRight?: LivewirePath;\n    closed?: boolean;\n    worldToSlice?: (point: Types.Point3) => Types.Point2;\n    sliceToWorld?: (point: Types.Point2) => Types.Point3;\n    originalPath?: Types.Point3[];\n    contourHoleProcessingEnabled?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        /**\n         * Specify which modifier key is used to add a hole to a contour. The\n         * modifier must be pressed when the first point of a new contour is added.\n         */\n        contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n\n        /**\n         * Configuring this to a value larger than 0 will snap handles to nearby\n         * livewire points, within the given rectangle surrounding the clicked point.\n         * If set to 0, then the exact clicked point will be used instead, which may\n         * not be an edge and can result in jagged outlines.\n         * The unit is image pixels (index).\n         */\n        snapHandleNearby: 2,\n\n        /**\n         * Interpolation is only available for segmentation versions of these\n         * tools.  To use it on the segmentation tools, set enabled to true,\n         * and create two livewire contours in the same segment index, separated\n         * by at least one slice.\n         */\n        interpolation: {\n          enabled: false,\n\n          /**\n           * Set the nearestEdge to snap interpolated handles to an edge within\n           * the given number of pixels.  Setting to 0 disables snap to pixel\n           * for interpolation and the interpolated point will be used directly.\n           * Setting to too large a value may result in many points outside the contour\n           * being chosen.\n           */\n          nearestEdge: 2,\n          /**\n           * Set to true to show the interpolated polyline, which can be useful\n           * when understanding the nearest edge and\n           */\n          showInterpolationPolyline: false,\n        },\n\n        /**\n         * The polyline may get processed in order to reduce the number of points\n         * for better performance and storage.\n         */\n        decimate: {\n          enabled: false,\n          /** A maximum given distance 'epsilon' to decide if a point should or\n           * shouldn't be added the resulting polyline which will have a lower\n           * number of points for higher `epsilon` values.\n           */\n          epsilon: 0.1,\n        },\n\n        actions: {\n          undo: {\n            method: 'undo',\n            bindings: [\n              {\n                key: 'Escape',\n              },\n            ],\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  protected setupBaseEditData(\n    worldPos,\n    element,\n    annotation,\n    rightPos?,\n    contourHoleProcessingEnabled?\n  ) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    this.isDrawing = true;\n\n    const viewportImageData = viewport.getImageData();\n    const { imageData: vtkImageData } = viewportImageData;\n    let worldToSlice: (point: Types.Point3) => Types.Point2;\n    let sliceToWorld: (point: Types.Point2) => Types.Point3;\n    let { scalarData } = viewportImageData;\n    let width;\n    let height;\n\n    if (!(viewport instanceof VolumeViewport) && scalarData) {\n      width = viewportImageData.dimensions[0];\n      height = viewportImageData.dimensions[1];\n\n      // Method only to simplify the code making stack and volume viewports code\n      // similar and avoiding `if(stack)/else` whenever a coordinate needs to be\n      // transformed because `worldToSlice` in this case returns the same IJK\n      // coordinate from index space.\n      worldToSlice = (point: Types.Point3) => {\n        const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n        return [ijkPoint[0], ijkPoint[1]];\n      };\n\n      // Method only to simplify the code making stack and volume viewports code\n      // similar and avoiding `if(stack)/else` whenever a coordinate needs to be\n      // transformed because `sliceToWorld` in this case receives the same IJK\n      // coordinate from index space.\n      sliceToWorld = (point: Types.Point2) =>\n        csUtils.transformIndexToWorld(vtkImageData, [point[0], point[1], 0]);\n    } else if (viewport instanceof VolumeViewport) {\n      const sliceImageData = csUtils.getCurrentVolumeViewportSlice(viewport);\n      const { sliceToIndexMatrix, indexToSliceMatrix } = sliceImageData;\n\n      worldToSlice = (point: Types.Point3) => {\n        const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n        const slicePoint = vec3.transformMat4(\n          [0, 0, 0],\n          ijkPoint,\n          indexToSliceMatrix\n        );\n\n        return [slicePoint[0], slicePoint[1]];\n      };\n\n      sliceToWorld = (point: Types.Point2) => {\n        const ijkPoint = vec3.transformMat4(\n          [0, 0, 0],\n          [point[0], point[1], 0],\n          sliceToIndexMatrix\n        ) as Types.Point3;\n\n        return csUtils.transformIndexToWorld(vtkImageData, ijkPoint);\n      };\n\n      scalarData = sliceImageData.scalarData;\n      width = sliceImageData.width;\n      height = sliceImageData.height;\n    } else {\n      throw new Error('Viewport not supported');\n    }\n    scalarData = csUtils.convertToGrayscale(scalarData, width, height);\n    const { voiRange } = viewport.getProperties();\n    const startPos = worldToSlice(worldPos);\n\n    this.scissors = LivewireScissors.createInstanceFromRawPixelData(\n      scalarData as Float32Array,\n      width,\n      height,\n      voiRange\n    );\n    if (rightPos) {\n      this.scissorsRight = LivewireScissors.createInstanceFromRawPixelData(\n        scalarData as Float32Array,\n        width,\n        height,\n        voiRange\n      );\n      this.scissorsRight.startSearch(worldToSlice(rightPos));\n    }\n\n    // Scissors always start at the startPos for both editing handles and\n    // for initial rendering\n    this.scissors.startSearch(startPos);\n\n    const newAnnotation = !rightPos;\n\n    const confirmedPath = new LivewirePath();\n    const currentPath = new LivewirePath();\n    const currentPathNext = newAnnotation ? undefined : new LivewirePath();\n\n    confirmedPath.addPoint(startPos);\n    confirmedPath.addControlPoint(startPos);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    const lastCanvasPoint = viewport.worldToCanvas(worldPos);\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation,\n      hasMoved: false,\n      lastCanvasPoint,\n      confirmedPath,\n      currentPath,\n      confirmedPathRight: currentPathNext,\n      closed: false,\n      handleIndex:\n        this.editData?.handleIndex ?? annotation.handles?.activeHandleIndex,\n      worldToSlice,\n      sliceToWorld,\n      contourHoleProcessingEnabled,\n    };\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation(\n    evt: EventTypes.InteractionEventType\n  ): LivewireContourAnnotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const { world: worldPos } = currentPoints;\n    const { renderingEngine } = getEnabledElement(element);\n    const annotation = this.createAnnotation(evt);\n    const contourHoleProcessingEnabled =\n      getMouseModifierKey(evt.detail.event) ===\n      this.configuration.contourHoleAdditionModifierKey;\n\n    this.setupBaseEditData(\n      worldPos,\n      element,\n      annotation,\n      undefined,\n      contourHoleProcessingEnabled\n    );\n    this.addAnnotation(annotation, element);\n\n    this._activateDraw(element);\n    evt.preventDefault();\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      this.editData.viewportIdsToRender\n    );\n\n    return annotation;\n  }\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: LivewireContourAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const proximitySquared = proximity * proximity;\n    const canvasPoints = annotation.data.contour.polyline.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n\n    let startPoint = canvasPoints[canvasPoints.length - 1];\n\n    for (let i = 0; i < canvasPoints.length; i++) {\n      const endPoint = canvasPoints[i];\n      const distanceToPointSquared = math.lineSegment.distanceToPointSquared(\n        startPoint,\n        endPoint,\n        canvasCoords\n      );\n\n      if (distanceToPointSquared <= proximitySquared) {\n        return true;\n      }\n\n      startPoint = endPoint;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: LivewireContourAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n    };\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this._activateModify(element);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: LivewireContourAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    const { points } = data.handles;\n    const handleIndex = points.findIndex((p) => p === handle);\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n    };\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (\n    evt: EventTypes.InteractionEventType,\n    clearAnnotation = false\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation,\n      contourHoleProcessingEnabled,\n    } = this.editData;\n    const { data } = annotation;\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      (this.isHandleOutsideImage &&\n        this.configuration.preventHandleOutsideImage) ||\n      clearAnnotation\n    ) {\n      removeAnnotation(annotation.annotationUID);\n      this.clearEditData();\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n      return;\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    const changeType = newAnnotation\n      ? ChangeTypes.Completed\n      : ChangeTypes.HandlesUpdated;\n\n    this.triggerChangeEvent(\n      annotation,\n      enabledElement,\n      changeType,\n      contourHoleProcessingEnabled\n    );\n    this.clearEditData();\n  };\n\n  protected clearEditData() {\n    this.editData = null;\n    this.scissors = null;\n    this.scissorsRight = null;\n    this.isDrawing = false;\n  }\n\n  /**\n   * Triggers an annotation complete or modified event based on changeType.\n   */\n  triggerChangeEvent = (\n    annotation: LivewireContourAnnotation,\n    enabledElement: Types.IEnabledElement,\n    changeType = ChangeTypes.StatsUpdated,\n    contourHoleProcessingEnabled = false\n  ): void => {\n    if (changeType === ChangeTypes.Completed) {\n      triggerContourAnnotationCompleted(\n        annotation,\n        contourHoleProcessingEnabled\n      );\n    } else {\n      triggerAnnotationModified(\n        annotation,\n        enabledElement.viewport.element,\n        changeType\n      );\n    }\n  };\n\n  private _mouseDownCallback = (evt: EventTypes.InteractionEventType): void => {\n    const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n    const { annotation, viewportIdsToRender, worldToSlice, sliceToWorld } =\n      this.editData;\n\n    if (this.editData.closed) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const { canvas: canvasPos, world: worldPosOriginal } = currentPoints;\n    let worldPos = worldPosOriginal;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const controlPoints = this.editData.currentPath.getControlPoints();\n    let closePath = controlPoints.length >= 2 && doubleClick;\n\n    // Check if user clicked on the first point to close the curve\n    if (controlPoints.length >= 2) {\n      const closestHandlePoint = {\n        index: -1,\n        distSquared: Infinity,\n      };\n\n      // Check if there is a control point close to the cursor\n      for (let i = 0, len = controlPoints.length; i < len; i++) {\n        const controlPoint = controlPoints[i];\n        const worldControlPoint = sliceToWorld(controlPoint);\n        const canvasControlPoint = viewport.worldToCanvas(worldControlPoint);\n\n        const distSquared = math.point.distanceToPointSquared(\n          canvasPos,\n          canvasControlPoint\n        );\n\n        if (\n          distSquared <= CLICK_CLOSE_CURVE_SQR_DIST &&\n          distSquared < closestHandlePoint.distSquared\n        ) {\n          closestHandlePoint.distSquared = distSquared;\n          closestHandlePoint.index = i;\n        }\n      }\n\n      if (closestHandlePoint.index === 0) {\n        closePath = true;\n      }\n    }\n\n    const { snapHandleNearby } = this.configuration;\n    // Snap the handles as they get created, but not during edit\n    if (snapHandleNearby && !this.editData.closed) {\n      const currentPath = new LivewirePath();\n      const snapPoint = this.scissors.findMinNearby(\n        worldToSlice(worldPosOriginal),\n        1\n      );\n      const pathPoints = this.scissors.findPathToPoint(snapPoint);\n      currentPath.addPoints(pathPoints);\n      currentPath.prependPath(this.editData.confirmedPath);\n      worldPos = sliceToWorld(snapPoint);\n      this.editData.currentPath = currentPath;\n    }\n\n    this.editData.closed = this.editData.closed || closePath;\n    this.editData.confirmedPath = this.editData.currentPath;\n\n    // Add the current cursor position as a new control point after clicking\n    const lastPoint = this.editData.currentPath.getLastPoint();\n\n    this.editData.confirmedPath.addControlPoint(lastPoint);\n    annotation.data.handles.points.push(sliceToWorld(lastPoint));\n\n    // Start a new search starting at the last control point\n    this.scissors.startSearch(worldToSlice(worldPos));\n\n    annotation.invalidated = true;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (this.editData.closed) {\n      // Update the annotation because `editData` will be set to null\n      this.updateAnnotation(this.editData.confirmedPath);\n      this._endCallback(evt);\n    }\n\n    evt.preventDefault();\n  };\n\n  private _mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\n    const { element, currentPoints } = evt.detail;\n    const { world: worldPos, canvas: canvasPos } = currentPoints;\n    const { renderingEngine } = getEnabledElement(element);\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData.lastCanvasPoint = canvasPos;\n\n    const { width: imgWidth, height: imgHeight } = this.scissors;\n    const { worldToSlice } = this.editData;\n    const slicePoint: Types.Point2 = worldToSlice(worldPos);\n\n    // Check if the point is inside the bounding box\n    if (\n      slicePoint[0] < 0 ||\n      slicePoint[1] < 0 ||\n      slicePoint[0] >= imgWidth ||\n      slicePoint[1] >= imgHeight\n    ) {\n      return;\n    }\n\n    const pathPoints = this.scissors.findPathToPoint(slicePoint);\n    const currentPath = new LivewirePath();\n    currentPath.addPoints(pathPoints);\n\n    // Merge the \"confirmed\" path that goes from the first control point to the\n    // last one with the current path that goes from the last control point to\n    // the cursor point\n    currentPath.prependPath(this.editData.confirmedPath);\n\n    // Store the new path\n    this.editData.currentPath = currentPath;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    evt.preventDefault();\n  };\n\n  public editHandle(\n    worldPos: Types.Point3,\n    element,\n    annotation,\n    handleIndex: number\n  ) {\n    const { data } = annotation;\n    const { points: handlePoints } = data.handles;\n    const { length: numHandles } = handlePoints;\n    const previousHandle =\n      handlePoints[(handleIndex - 1 + numHandles) % numHandles];\n    const nextHandle = handlePoints[(handleIndex + 1) % numHandles];\n\n    if (!this.editData?.confirmedPathRight) {\n      this.setupBaseEditData(previousHandle, element, annotation, nextHandle);\n      const { polyline } = data.contour;\n      const confirmedPath = new LivewirePath();\n      const confirmedPathRight = new LivewirePath();\n      const { worldToSlice } = this.editData;\n      const previousIndex = findHandlePolylineIndex(\n        annotation,\n        handleIndex - 1\n      );\n      const nextIndex = findHandlePolylineIndex(annotation, handleIndex + 1);\n      if (nextIndex === -1 || previousIndex === -1) {\n        throw new Error(\n          `Can't find handle index ${nextIndex === -1 && nextHandle} ${\n            previousIndex === -1 && previousHandle\n          }`\n        );\n      }\n      if (handleIndex === 0) {\n        // For this case, the next/previous indices are swapped, and the\n        // path data gets inserted in between the newly generated data, so\n        // handle this case specially\n        confirmedPathRight.addPoints(\n          polyline.slice(nextIndex + 1, previousIndex).map(worldToSlice)\n        );\n      } else if (nextIndex < previousIndex) {\n        throw new Error(\n          `Expected right index after left index, but were: ${previousIndex} ${nextIndex}`\n        );\n      } else {\n        confirmedPath.addPoints(\n          polyline.slice(0, previousIndex + 1).map(worldToSlice)\n        );\n        confirmedPathRight.addPoints(\n          polyline.slice(nextIndex, polyline.length).map(worldToSlice)\n        );\n      }\n      this.editData.confirmedPath = confirmedPath;\n      this.editData.confirmedPathRight = confirmedPathRight;\n    }\n    const { editData, scissors } = this;\n    const { worldToSlice, sliceToWorld } = editData;\n\n    const { activeHandleIndex } = data.handles;\n    if (activeHandleIndex === null || activeHandleIndex === undefined) {\n      data.handles.activeHandleIndex = handleIndex;\n    } else if (activeHandleIndex !== handleIndex) {\n      throw new Error(\n        `Trying to edit a different handle than the one currently being edited ${handleIndex}!==${data.handles.activeHandleIndex}`\n      );\n    }\n    const slicePos = worldToSlice(worldPos);\n    if (\n      slicePos[0] < 0 ||\n      slicePos[0] >= scissors.width ||\n      slicePos[1] < 0 ||\n      slicePos[1] >= scissors.height\n    ) {\n      // Find path to point hangs if the position is outside the image data\n      return;\n    }\n    handlePoints[handleIndex] = sliceToWorld(slicePos);\n\n    const pathPointsLeft = scissors.findPathToPoint(slicePos);\n    const pathPointsRight = this.scissorsRight.findPathToPoint(slicePos);\n    const currentPath = new LivewirePath();\n\n    // Merge the \"confirmed\" path that goes from the first control point to the\n    // last one with the current path that goes from the last control point to\n    // the cursor point\n    currentPath.prependPath(editData.confirmedPath);\n    if (handleIndex !== 0) {\n      currentPath.addPoints(pathPointsLeft);\n    }\n    currentPath.addPoints(pathPointsRight.reverse());\n    currentPath.appendPath(editData.confirmedPathRight);\n    if (handleIndex === 0) {\n      currentPath.addPoints(pathPointsLeft);\n    }\n\n    // Store the new path\n    editData.currentPath = currentPath;\n\n    annotation.invalidated = true;\n    editData.hasMoved = true;\n  }\n\n  private _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    if (handleIndex === undefined) {\n      // Drag mode - moving object\n      console.warn('No drag implemented for livewire');\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n      this.editHandle(worldPos, element, annotation, handleIndex);\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is not in mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n    if (newAnnotation) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData = null;\n    this.scissors = null;\n    return annotation.annotationUID;\n  };\n\n  private _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  private _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  private _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n    element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n    element.addEventListener(\n      Events.MOUSE_DOUBLE_CLICK,\n      this._mouseDownCallback\n    );\n\n    element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n  };\n\n  private _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n    element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n    element.removeEventListener(\n      Events.MOUSE_DOUBLE_CLICK,\n      this._mouseDownCallback\n    );\n\n    element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n  };\n\n  public renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean {\n    // Update the annotation that is in editData (being edited)\n    this.updateAnnotation(this.editData?.currentPath);\n\n    return super.renderAnnotation(enabledElement, svgDrawingHelper);\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Disable contour segmentation behavior because it shall be activated only\n    // for LivewireContourSegmentationTool\n    return false;\n  }\n\n  protected createAnnotation(evt: EventTypes.InteractionEventType) {\n    const contourSegmentationAnnotation = super.createAnnotation(evt);\n    const { world: worldPos } = evt.detail.currentPoints;\n\n    const annotation = <LivewireContourAnnotation>csUtils.deepMerge(\n      contourSegmentationAnnotation,\n      {\n        data: {\n          handles: {\n            points: [[...worldPos]],\n          },\n        },\n      }\n    );\n    return annotation;\n  }\n\n  /**\n   * Clears any in progress edits, mostly used to get rid of accidentally started\n   * contours that happen on clicking not quite the right handle point.\n   * Eventually this is to be replaced with a proper undo, once that framework\n   * is available.\n   */\n  public undo(element, config, evt) {\n    if (!this.editData) {\n      // TODO - proper undo\n      return;\n    }\n    this._endCallback(evt, true);\n  }\n\n  /**\n   * Render an annotation instance\n   * @param renderContext - Render context that contains the annotation, enabledElement, etc.\n   * @returns True if the annotation is rendered or false otherwise\n   */\n  protected renderAnnotationInstance(renderContext: {\n    enabledElement: Types.IEnabledElement;\n    targetId: string;\n    annotation: LivewireContourAnnotation;\n    annotationStyle: Record<string, any>;\n    svgDrawingHelper: SVGDrawingHelper;\n  }): boolean {\n    const { annotation, enabledElement, svgDrawingHelper, annotationStyle } =\n      renderContext;\n\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { annotationUID, data, highlighted } = annotation;\n    const { handles } = data;\n    const newAnnotation = this.editData?.newAnnotation;\n    const { lineWidth, lineDash, color } = annotationStyle;\n\n    // Render the first control point only when the annotation is drawn for the\n    // first time to make it easier to know where the user needs to click to\n    // to close the ROI.\n    if (\n      highlighted ||\n      (newAnnotation &&\n        annotation.annotationUID === this.editData?.annotation?.annotationUID)\n    ) {\n      const handleGroupUID = '0';\n      const canvasHandles = handles.points.map(worldToCanvas);\n\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        canvasHandles,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        }\n      );\n    }\n\n    // Let the base class render the contour\n    super.renderAnnotationInstance(renderContext);\n\n    return true;\n  }\n\n  protected updateAnnotation(livewirePath: LivewirePath) {\n    if (!this.editData || !livewirePath) {\n      return;\n    }\n\n    const { annotation, sliceToWorld } = this.editData;\n    let { pointArray: imagePoints } = livewirePath;\n\n    if (imagePoints.length > 1) {\n      imagePoints = [...imagePoints, imagePoints[0]];\n    }\n\n    this.updateContourPolyline(\n      annotation,\n      {\n        points: imagePoints,\n        closed: annotation.data.contour.closed,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n      },\n      {\n        canvasToWorld: sliceToWorld,\n      }\n    );\n  }\n}\n\nLivewireContourTool.toolName = 'LivewireContour';\nexport default LivewireContourTool;\n","import type { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\n\nimport LivewireContourTool from './LivewireContourTool';\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { ChangeTypes } from '../../enums';\nimport type { ContourSegmentationAnnotation } from '../../types';\nimport { drawPolyline as drawPolylineSvg } from '../../drawingSvg';\n\nclass LivewireContourSegmentationTool extends LivewireContourTool {\n  static toolName;\n\n  /**\n   * Updates the interpolated annotations with the currently displayed image data,\n   * performing hte livewire on the image data as generated.\n   * Note - this function is only called for interpolated livewire SEGMENTATION\n   * objects, and will return immediately otherwise.\n   *\n   * The work for the interpolation is performed in a microtask, enabling this\n   * method to return quickly for faster render speeds, but ensuring that the\n   * annotation data isn't updated before the changes are performed.  The removes\n   * some irritating flickering on navigation.\n   */\n  public updateInterpolatedAnnotation(\n    annotation: ContourSegmentationAnnotation,\n    enabledElement: Types.IEnabledElement\n  ) {\n    // The interpolation sources is used as a flag here - a true livewire\n    // behaviour would be to perform a livewire between the two planes\n    // closest to this plane for each point, and use that handle.  That is\n    // oblique, however, which is not currently supported.\n    if (\n      this.editData ||\n      !annotation.invalidated ||\n      !annotation.data.handles.interpolationSources\n    ) {\n      return;\n    }\n    annotation.data.contour.originalPolyline = annotation.data.contour.polyline;\n\n    // See docs above for why this is a microtask\n    queueMicrotask(() => {\n      if (!annotation.data.handles.interpolationSources) {\n        return;\n      }\n      const { points } = annotation.data.handles;\n\n      const { element } = enabledElement.viewport;\n      this.setupBaseEditData(points[0], element, annotation);\n      const { length: count } = points;\n      const { scissors } = this;\n      const { nearestEdge, repeatInterpolation } =\n        this.configuration.interpolation;\n      annotation.data.handles.originalPoints = points;\n      const { worldToSlice, sliceToWorld } = this.editData;\n      const handleSmoothing = [];\n\n      // New path generation - go through the handles and regenerate the polyline\n      if (nearestEdge) {\n        let lastPoint = worldToSlice(points[points.length - 1]);\n        // Nearest edge handling\n        points.forEach((point, hIndex) => {\n          const testPoint = worldToSlice(point);\n          lastPoint = testPoint;\n          handleSmoothing.push(testPoint);\n\n          // Fill the costs buffer and then find the minimum cost\n          // This is a little too aggressive about pulling the line in\n          scissors.startSearch(lastPoint);\n          scissors.findPathToPoint(testPoint);\n          // Fill the costs for a point a bit further along by searching for a\n          // point further along.\n          scissors.findPathToPoint(\n            worldToSlice(points[(hIndex + 3) % points.length])\n          );\n          const minPoint = scissors.findMinNearby(testPoint, nearestEdge);\n          if (!csUtils.isEqual(testPoint, minPoint)) {\n            handleSmoothing[hIndex] = minPoint;\n            lastPoint = minPoint;\n            points[hIndex] = sliceToWorld(minPoint);\n          }\n        });\n      }\n\n      // Regenerate the updated data based on the updated handles\n      const acceptedPath = new LivewirePath();\n      for (let i = 0; i < count; i++) {\n        scissors.startSearch(worldToSlice(points[i]));\n        const path = scissors.findPathToPoint(\n          worldToSlice(points[(i + 1) % count])\n        );\n        acceptedPath.addPoints(path);\n      }\n\n      // Now, update the rendering\n      this.updateAnnotation(acceptedPath);\n      this.scissors = null;\n      this.scissorsRight = null;\n      this.editData = null;\n      annotation.data.handles.interpolationSources = null;\n\n      if (repeatInterpolation) {\n        triggerAnnotationModified(\n          annotation,\n          enabledElement.viewport.element,\n          ChangeTypes.InterpolationUpdated\n        );\n      }\n    });\n  }\n\n  /**\n   * Adds the update to the interpolated annotaiton on render an instance,\n   * but otherwise just calls the parent render annotation instance.\n   */\n  protected renderAnnotationInstance(renderContext): boolean {\n    const { enabledElement, svgDrawingHelper } = renderContext;\n    const annotation =\n      renderContext.annotation as ContourSegmentationAnnotation;\n    const { annotationUID } = annotation;\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { showInterpolationPolyline } =\n      this.configuration.interpolation || {};\n\n    this.updateInterpolatedAnnotation?.(annotation, enabledElement);\n    const { originalPolyline } = annotation.data.contour;\n\n    const rendered = super.renderAnnotationInstance(renderContext);\n\n    if (\n      showInterpolationPolyline &&\n      originalPolyline &&\n      annotation.autoGenerated\n    ) {\n      const polylineCanvasPoints = originalPolyline.map(\n        worldToCanvas\n      ) as Types.Point2[];\n      polylineCanvasPoints.push(polylineCanvasPoints[0]);\n      drawPolylineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        'interpolationContour-0',\n        polylineCanvasPoints,\n        {\n          color: '#70ffff',\n          lineWidth: 1,\n          fillOpacity: 0,\n        }\n      );\n    }\n\n    return rendered;\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Re-enable contour segmentation behavior disabled by LivewireContourTool\n    return true;\n  }\n}\n\nLivewireContourSegmentationTool.toolName = 'LivewireContourSegmentationTool';\nexport default LivewireContourSegmentationTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawArrow as drawArrowSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { ArrowAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass ArrowAnnotateTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        getTextCallback,\n        changeTextCallback,\n        preventHandleOutsideImage: false,\n        arrowFirst: true,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): ArrowAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const { arrowFirst } = this.configuration;\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        text: '',\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          arrowFirst,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: ArrowAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: ArrowAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: ArrowAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const { renderingEngine } = getEnabledElement(element);\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    if (newAnnotation) {\n      this.configuration.getTextCallback((text) => {\n        if (!text) {\n          removeAnnotation(annotation.annotationUID);\n          triggerAnnotationRenderForViewportIds(\n            renderingEngine,\n            viewportIdsToRender\n          );\n          this.editData = null;\n          this.isDrawing = false;\n          return;\n        }\n        annotation.data.text = text;\n\n        triggerAnnotationCompleted(annotation);\n\n        triggerAnnotationRenderForViewportIds(\n          renderingEngine,\n          viewportIdsToRender\n        );\n      });\n    } else {\n      triggerAnnotationModified(annotation, element);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  touchTapCallback = (evt: EventTypes.TouchTapEventType) => {\n    if (evt.detail.taps == 2) {\n      this.doubleClickCallback(evt);\n    }\n  };\n\n  doubleClickCallback = (evt: EventTypes.TouchTapEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return;\n    }\n\n    const clickedAnnotation = annotations.find((annotation) =>\n      this.isPointNearTool(\n        element,\n        annotation as ArrowAnnotation,\n        eventDetail.currentPoints.canvas,\n        6 // Todo: get from configuration\n      )\n    );\n\n    if (!clickedAnnotation) {\n      return;\n    }\n\n    const annotation = clickedAnnotation as ArrowAnnotation;\n\n    this.configuration.changeTextCallback(\n      clickedAnnotation,\n      evt.detail,\n      this._doneChangingTextCallback.bind(this, element, annotation)\n    );\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    // This double click was handled and the dialogue was displayed.\n    // No need for any other listener to handle it too - stopImmediatePropagation\n    // helps ensure this primarily so that no other listeners on the target element\n    // get called.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  };\n\n  _doneChangingTextCallback(element, annotation, updatedText): void {\n    annotation.data.text = updatedText;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n  }\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ArrowAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles, text } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineWidth,\n          }\n        );\n      }\n\n      const arrowUID = '1';\n      if (this.configuration.arrowFirst) {\n        drawArrowSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arrowUID,\n          canvasCoordinates[1],\n          canvasCoordinates[0],\n          {\n            color,\n            width: lineWidth,\n            lineDash: lineDash,\n          }\n        );\n      } else {\n        drawArrowSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arrowUID,\n          canvasCoordinates[0],\n          canvasCoordinates[1],\n          {\n            color,\n            width: lineWidth,\n            lineDash: lineDash,\n          }\n        );\n      }\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (!text) {\n        continue;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      // Need to update to sync w/ annotation while unlinked/not moved\n      if (!data.handles.textBox.hasMoved) {\n        // linked to the point that doesn't have the arrowhead by default\n        const canvasTextBoxCoords = canvasCoordinates[1];\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        [text],\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nfunction getTextCallback(doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nArrowAnnotateTool.toolName = 'ArrowAnnotate';\nexport default ArrowAnnotateTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { roundNumber } from '../../utilities';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { AngleAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass AngleTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  angleStartedNotYetCompleted: boolean;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.InteractionEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): AngleAnnotation => {\n    if (this.angleStartedNotYetCompleted) {\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: AngleAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2, point3] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line1 = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line1.start.x, line1.start.y],\n      [line1.end.x, line1.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n    if (!point3) {\n      return false;\n    }\n\n    const canvasPoint3 = viewport.worldToCanvas(point3);\n\n    const line2 = {\n      start: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n      end: {\n        x: canvasPoint3[0],\n        y: canvasPoint3[1],\n      },\n    };\n\n    const distanceToPoint2 = lineSegment.distanceToPoint(\n      [line2.start.x, line2.start.y],\n      [line2.end.x, line2.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint2 <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: AngleAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: AngleAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n\n    const { data } = annotation;\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    // If preventing new measurement means we are in the middle of an existing measurement\n    // we shouldn't deactivate modify or draw\n    if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {\n      // adds the last point to the measurement\n      this.editData.handleIndex = 2;\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      this.angleStartedNotYetCompleted = false;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as AngleAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].angle == null\n      ) {\n        data.cachedStats[targetId] = {\n          angle: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      let lineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      renderStatus = true;\n\n      // Don't add textBox until annotation has 3 anchor points (actually 4 because of the center point)\n      if (canvasCoordinates.length !== 3) {\n        return renderStatus;\n      }\n\n      lineUID = '2';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[1],\n        canvasCoordinates[2],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      if (!data.cachedStats[targetId]?.angle) {\n        continue;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n\n      if (!data.handles.textBox.hasMoved) {\n        // linked to the vertex by default\n        const canvasTextBoxCoords = canvasCoordinates[1];\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { element } = enabledElement.viewport;\n\n    // Until we have all three anchors bail out\n    if (data.handles.points.length !== 3) {\n      return;\n    }\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const worldPos3 = data.handles.points[2];\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const angle = angleBetweenLines(\n        [worldPos1, worldPos2],\n        [worldPos2, worldPos3]\n      );\n      const { dimensions, imageData } = this.getTargetIdImage(\n        targetId,\n        renderingEngine\n      );\n\n      // Decide if there's at least one handle is outside of image\n      this.isHandleOutsideImage = [worldPos1, worldPos2, worldPos3]\n        .map((worldPos) => csUtils.transformWorldToIndex(imageData, worldPos))\n        .some((index) => !csUtils.indexWithinDimensions(index, dimensions));\n      cachedStats[targetId] = {\n        angle: isNaN(angle) ? 'Incomplete Angle' : angle,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { angle } = cachedVolumeStats;\n\n  if (angle === undefined) {\n    return;\n  }\n\n  if (isNaN(angle)) {\n    // The verbiage for incomplete angle is set in cachedStats\n    return [`${angle}`];\n  }\n\n  const textLines = [`${roundNumber(angle)} ${String.fromCharCode(176)}`];\n\n  return textLines;\n}\n\nAngleTool.toolName = 'Angle';\nexport default AngleTool;\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Return the midpoint (think average) of all the provided points.\n */\nconst midPoint = (\n  ...args: (Types.Point2 | Types.Point3)[]\n): Types.Point2 | Types.Point3 => {\n  const ret =\n    args[0].length === 2 ? <Types.Point2>[0, 0] : <Types.Point3>[0, 0, 0];\n  const len = args.length;\n  for (const arg of args) {\n    ret[0] += arg[0] / len;\n    ret[1] += arg[1] / len;\n    if (ret.length === 3) {\n      ret[2] += arg[2] / len;\n    }\n  }\n  return ret;\n};\n\nconst midPoint2 = midPoint as (...args: Types.Point2[]) => Types.Point2;\n\nexport default midPoint;\n\nexport { midPoint2 };\n","import { vec3 } from 'gl-matrix';\nimport { Events } from '../../enums';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { midPoint2 } from '../../utilities/math/midPoint';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { CobbAngleAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass CobbAngleTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  angleStartedNotYetCompleted: boolean;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    isNearFirstLine?: boolean;\n    isNearSecondLine?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n        showArcLines: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      25,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.MouseDownActivateEventType\n  ): CobbAngleAnnotation => {\n    if (this.angleStartedNotYetCompleted) {\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CobbAngleAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n\n    const { distanceToPoint, distanceToPoint2 } = this.distanceToLines({\n      viewport,\n      points: data.handles.points,\n      canvasCoords,\n      proximity,\n    });\n\n    if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.MouseDownEventType,\n    annotation: CobbAngleAnnotation,\n    interactionType: InteractionTypes,\n    canvasCoords: Types.Point2,\n    proximity = 6\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n\n    const { isNearFirstLine, isNearSecondLine } = this.distanceToLines({\n      viewport,\n      points: annotation.data.handles.points,\n      canvasCoords,\n      proximity,\n    });\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n      isNearFirstLine,\n      isNearSecondLine,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.MouseDownEventType,\n    annotation: CobbAngleAnnotation,\n    handle: ToolHandle,\n    interactionType = 'mouse'\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _mouseUpCallback = (\n    evt: EventTypes.MouseUpEventType | EventTypes.MouseClickEventType\n  ) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n\n    const { data } = annotation;\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    // If preventing new measurement means we are in the middle of an existing measurement\n    // we shouldn't deactivate modify or draw\n    if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {\n      resetElementCursor(element);\n\n      // adds the first point of the second line\n      this.editData.handleIndex = data.handles.points.length;\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  /**\n   * Handles the mouse down for all points that follow the very first mouse down.\n   * The very first mouse down is handled by addAnnotation.\n   * This method ensures that the state of the tool is correct for the drawing of the second line segment.\n   * In particular it ensures that the second segment can be created via a mouse down and drag.\n   */\n  _mouseDownCallback = (\n    evt: EventTypes.MouseUpEventType | EventTypes.MouseClickEventType\n  ) => {\n    const { annotation, handleIndex } = this.editData;\n    const eventDetail = evt.detail;\n    const { element, currentPoints } = eventDetail;\n    const worldPos = currentPoints.world;\n    const { data } = annotation;\n\n    if (handleIndex === 1) {\n      // This is the mouse down for the second point of the first segment.\n      // The mouse up takes care of adding the first point of the second segment.\n      data.handles.points[1] = worldPos;\n      this.editData.hasMoved =\n        data.handles.points[1][0] !== data.handles.points[0][0] ||\n        data.handles.points[1][1] !== data.handles.points[0][0];\n      return;\n    }\n\n    if (handleIndex === 3) {\n      // This is the mouse down for the second point of the second segment (i.e. the last point)\n      data.handles.points[3] = worldPos;\n      this.editData.hasMoved =\n        data.handles.points[3][0] !== data.handles.points[2][0] ||\n        data.handles.points[3][1] !== data.handles.points[2][0];\n\n      this.angleStartedNotYetCompleted = false;\n      return;\n    }\n\n    // This is the first mouse down of the first point of the second line segment.\n    // It is as if we have not moved yet because Cobb Angle has two, disjoint sections, each with its own move.\n    this.editData.hasMoved = false;\n    hideElementCursor(element);\n\n    // Add the last segment points for the subsequent drag/mouse move.\n    data.handles.points[2] = data.handles.points[3] = worldPos;\n    this.editData.handleIndex = data.handles.points.length - 1;\n  };\n\n  _mouseDragCallback = (\n    evt: EventTypes.MouseDragEventType | EventTypes.MouseMoveEventType\n  ) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n      isNearFirstLine,\n      isNearSecondLine,\n    } = this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (\n      handleIndex === undefined &&\n      (isNearFirstLine || isNearSecondLine)\n    ) {\n      // select tool mode - moving annotation\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n      const points = data.handles.points;\n\n      // separate the logic for moving handles to move them separately\n      if (isNearFirstLine) {\n        const firstLinePoints = [points[0], points[1]];\n        firstLinePoints.forEach((point) => {\n          point[0] += worldPosDelta[0];\n          point[1] += worldPosDelta[1];\n          point[2] += worldPosDelta[2];\n        });\n      } else if (isNearSecondLine) {\n        const secondLinePoints = [points[2], points[3]];\n        secondLinePoints.forEach((point) => {\n          point[0] += worldPosDelta[0];\n          point[1] += worldPosDelta[1];\n          point[2] += worldPosDelta[2];\n        });\n      }\n\n      annotation.invalidated = true;\n    } else {\n      // Drag handle mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    if (data.handles.points.length < 4) {\n      // If it is mid-draw\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.angleStartedNotYetCompleted = false;\n    return annotation.annotationUID;\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n\n    // element.addEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n\n    // element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DOWN,\n      this._mouseDownCallback as EventListener\n    );\n\n    // element.addEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DOWN,\n      this._mouseDownCallback as EventListener\n    );\n\n    // element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as CobbAngleAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].angle == null\n      ) {\n        data.cachedStats[targetId] = {\n          angle: null,\n          arc1Angle: null,\n          arc2Angle: null,\n          points: {\n            world: {\n              arc1Start: null,\n              arc1End: null,\n              arc2Start: null,\n              arc2End: null,\n              arc1Angle: null,\n              arc2Angle: null,\n            },\n            canvas: {\n              arc1Start: null,\n              arc1End: null,\n              arc2Start: null,\n              arc2End: null,\n              arc1Angle: null,\n              arc2Angle: null,\n            },\n          },\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      const firstLine = [canvasCoordinates[0], canvasCoordinates[1]] as [\n        Types.Point2,\n        Types.Point2\n      ];\n      const secondLine = [canvasCoordinates[2], canvasCoordinates[3]] as [\n        Types.Point2,\n        Types.Point2\n      ];\n\n      let lineUID = 'line1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        firstLine[0],\n        firstLine[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      renderStatus = true;\n\n      // Don't add the stats until annotation has 4 anchor points\n      if (canvasCoordinates.length < 4) {\n        return renderStatus;\n      }\n\n      lineUID = 'line2';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        secondLine[0],\n        secondLine[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      lineUID = 'linkLine';\n      const mid1 = midPoint2(firstLine[0], firstLine[1]);\n      const mid2 = midPoint2(secondLine[0], secondLine[1]);\n      drawLineSvg(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {\n        color,\n        lineWidth: '1',\n        lineDash: '1,4',\n      });\n\n      // Calculating the arcs\n\n      const { arc1Start, arc1End, arc2End, arc2Start } =\n        data.cachedStats[targetId].points.canvas;\n      const { arc1Angle, arc2Angle } = data.cachedStats[targetId];\n\n      if (this.configuration.showArcLines) {\n        lineUID = 'arc1';\n\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          arc1Start as Types.Point2,\n          arc1End as Types.Point2,\n          {\n            color,\n            lineWidth: '1',\n          }\n        );\n\n        lineUID = 'arc2';\n\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          arc2Start as Types.Point2,\n          arc2End as Types.Point2,\n          {\n            color,\n            lineWidth: '1',\n          }\n        );\n      }\n\n      if (!data.cachedStats[targetId]?.angle) {\n        continue;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = 'cobbAngleText';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n\n      if (this.configuration.showArcLines) {\n        const arc1TextBoxUID = 'arcAngle1';\n\n        const arc1TextLine = [\n          `${arc1Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n        ];\n\n        const arch1TextPosCanvas = midPoint2(arc1Start, arc1End);\n\n        drawTextBoxSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arc1TextBoxUID,\n          arc1TextLine,\n          arch1TextPosCanvas,\n          {\n            ...options,\n            padding: 3,\n          }\n        );\n\n        const arc2TextBoxUID = 'arcAngle2';\n\n        const arc2TextLine = [\n          `${arc2Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n        ];\n\n        const arch2TextPosCanvas = midPoint2(arc2Start, arc2End);\n\n        drawTextBoxSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arc2TextBoxUID,\n          arc2TextLine,\n          arch2TextPosCanvas,\n          {\n            ...options,\n            padding: 3,\n          }\n        );\n      }\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n\n    // Until we have all four anchors bail out\n    if (data.handles.points.length !== 4) {\n      return;\n    }\n\n    const seg1: [Types.Point3, Types.Point3] = [null, null];\n    const seg2: [Types.Point3, Types.Point3] = [null, null];\n    let minDist = Number.MAX_VALUE;\n\n    // Order the endpoints of each line segment such that seg1[1] and seg2[0]\n    // are the closest (Euclidean distance-wise) to each other. Thus\n    // the angle formed between the vectors seg1[1]->seg1[0] and seg2[0]->seg[1]\n    // is calculated.\n    // The assumption here is that the Cobb angle line segments are drawn\n    // such that the segments intersect nearest the segment endpoints\n    // that are closest AND those closest endpoints are the tails of the\n    // vectors used to calculate the angle between the vectors/line segments.\n    for (let i = 0; i < 2; i += 1) {\n      for (let j = 2; j < 4; j += 1) {\n        const dist = vec3.distance(\n          data.handles.points[i],\n          data.handles.points[j]\n        );\n        if (dist < minDist) {\n          minDist = dist;\n          seg1[1] = data.handles.points[i];\n          seg1[0] = data.handles.points[(i + 1) % 2];\n          seg2[0] = data.handles.points[j];\n          seg2[1] = data.handles.points[2 + ((j - 1) % 2)];\n        }\n      }\n    }\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    const canvasPoints = data.handles.points.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n\n    const firstLine = [canvasPoints[0], canvasPoints[1]] as [\n      Types.Point2,\n      Types.Point2\n    ];\n    const secondLine = [canvasPoints[2], canvasPoints[3]] as [\n      Types.Point2,\n      Types.Point2\n    ];\n\n    const mid1 = midPoint2(firstLine[0], firstLine[1]);\n    const mid2 = midPoint2(secondLine[0], secondLine[1]);\n\n    const { arc1Start, arc1End, arc2End, arc2Start, arc1Angle, arc2Angle } =\n      this.getArcsStartEndPoints({\n        firstLine,\n        secondLine,\n        mid1,\n        mid2,\n      });\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      cachedStats[targetId] = {\n        angle: angleBetweenLines(seg1, seg2),\n        arc1Angle,\n        arc2Angle,\n        points: {\n          canvas: {\n            arc1Start,\n            arc1End,\n            arc2End,\n            arc2Start,\n          },\n          world: {\n            arc1Start: viewport.canvasToWorld(arc1Start),\n            arc1End: viewport.canvasToWorld(arc1End),\n            arc2End: viewport.canvasToWorld(arc2End),\n            arc2Start: viewport.canvasToWorld(arc2Start),\n          },\n        },\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  }\n\n  distanceToLines = ({ viewport, points, canvasCoords, proximity }) => {\n    const [point1, point2, point3, point4] = points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n    const canvasPoint3 = viewport.worldToCanvas(point3);\n    const canvasPoint4 = viewport.worldToCanvas(point4);\n\n    const line1 = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const line2 = {\n      start: {\n        x: canvasPoint3[0],\n        y: canvasPoint3[1],\n      },\n      end: {\n        x: canvasPoint4[0],\n        y: canvasPoint4[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line1.start.x, line1.start.y],\n      [line1.end.x, line1.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    const distanceToPoint2 = lineSegment.distanceToPoint(\n      [line2.start.x, line2.start.y],\n      [line2.end.x, line2.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    let isNearFirstLine = false;\n    let isNearSecondLine = false;\n\n    if (distanceToPoint <= proximity) {\n      isNearFirstLine = true;\n    } else if (distanceToPoint2 <= proximity) {\n      isNearSecondLine = true;\n    }\n    return {\n      distanceToPoint,\n      distanceToPoint2,\n      isNearFirstLine,\n      isNearSecondLine,\n    };\n  };\n\n  getArcsStartEndPoints = ({\n    firstLine,\n    secondLine,\n    mid1,\n    mid2,\n  }): {\n    arc1Start: Types.Point2;\n    arc1End: Types.Point2;\n    arc2Start: Types.Point2;\n    arc2End: Types.Point2;\n    arc1Angle: number;\n    arc2Angle: number;\n  } => {\n    const linkLine = [mid1, mid2] as [Types.Point2, Types.Point2];\n\n    const arc1Angle = angleBetweenLines(firstLine, linkLine);\n    const arc2Angle = angleBetweenLines(secondLine, linkLine);\n\n    const arc1Side = arc1Angle > 90 ? 1 : 0;\n    const arc2Side = arc2Angle > 90 ? 0 : 1;\n\n    const midLinkLine = midPoint2(linkLine[0], linkLine[1]);\n\n    const linkLineLength = Math.sqrt(\n      (linkLine[1][0] - linkLine[0][0]) ** 2 +\n        (linkLine[1][1] - linkLine[0][1]) ** 2\n    );\n    const ratio = 0.1; // 10% of the line length\n\n    const midFirstLine = midPoint2(firstLine[0], firstLine[1]);\n    const midSecondLine = midPoint2(secondLine[0], secondLine[1]);\n\n    // For arc1Start\n    const directionVectorStartArc1 = [\n      firstLine[arc1Side][0] - midFirstLine[0],\n      firstLine[arc1Side][1] - midFirstLine[1],\n    ];\n    const magnitudeStartArc1 = Math.sqrt(\n      directionVectorStartArc1[0] ** 2 + directionVectorStartArc1[1] ** 2\n    );\n    const normalizedDirectionStartArc1 = [\n      directionVectorStartArc1[0] / magnitudeStartArc1,\n      directionVectorStartArc1[1] / magnitudeStartArc1,\n    ];\n    const arc1Start = [\n      midFirstLine[0] +\n        normalizedDirectionStartArc1[0] * linkLineLength * ratio,\n      midFirstLine[1] +\n        normalizedDirectionStartArc1[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    // Existing logic for arc1End\n    const directionVectorEndArc1 = [\n      midLinkLine[0] - mid1[0],\n      midLinkLine[1] - mid1[1],\n    ];\n    const magnitudeEndArc1 = Math.sqrt(\n      directionVectorEndArc1[0] ** 2 + directionVectorEndArc1[1] ** 2\n    );\n    const normalizedDirectionEndArc1 = [\n      directionVectorEndArc1[0] / magnitudeEndArc1,\n      directionVectorEndArc1[1] / magnitudeEndArc1,\n    ];\n    const arc1End = [\n      mid1[0] + normalizedDirectionEndArc1[0] * linkLineLength * ratio,\n      mid1[1] + normalizedDirectionEndArc1[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    // Similar logic for arc2Start\n    const directionVectorStartArc2 = [\n      secondLine[arc2Side][0] - midSecondLine[0],\n      secondLine[arc2Side][1] - midSecondLine[1],\n    ];\n    const magnitudeStartArc2 = Math.sqrt(\n      directionVectorStartArc2[0] ** 2 + directionVectorStartArc2[1] ** 2\n    );\n    const normalizedDirectionStartArc2 = [\n      directionVectorStartArc2[0] / magnitudeStartArc2,\n      directionVectorStartArc2[1] / magnitudeStartArc2,\n    ];\n    const arc2Start = [\n      midSecondLine[0] +\n        normalizedDirectionStartArc2[0] * linkLineLength * ratio,\n      midSecondLine[1] +\n        normalizedDirectionStartArc2[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    // Similar logic for arc2End\n    const directionVectorEndArc2 = [\n      midLinkLine[0] - mid2[0],\n      midLinkLine[1] - mid2[1],\n    ];\n    const magnitudeEndArc2 = Math.sqrt(\n      directionVectorEndArc2[0] ** 2 + directionVectorEndArc2[1] ** 2\n    );\n    const normalizedDirectionEndArc2 = [\n      directionVectorEndArc2[0] / magnitudeEndArc2,\n      directionVectorEndArc2[1] / magnitudeEndArc2,\n    ];\n    const arc2End = [\n      mid2[0] + normalizedDirectionEndArc2[0] * linkLineLength * ratio,\n      mid2[1] + normalizedDirectionEndArc2[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    return {\n      arc1Start,\n      arc1End,\n      arc2Start,\n      arc2End,\n      arc1Angle: arc1Angle > 90 ? 180 - arc1Angle : arc1Angle,\n      arc2Angle: arc2Angle > 90 ? 180 - arc2Angle : arc2Angle,\n    };\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { angle } = cachedVolumeStats;\n\n  if (angle === undefined) {\n    return;\n  }\n\n  const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];\n\n  return textLines;\n}\n\nCobbAngleTool.toolName = 'CobbAngle';\nexport default CobbAngleTool;\n","import { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  utilities as csUtils,\n  StackViewport,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport { UltrasoundDirectionalAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport {\n  drawHandle as drawHandleSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { roundNumber } from '../../utilities';\nimport { distanceToPoint } from '../../utilities/math/point';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  Annotation,\n  InteractionTypes,\n} from '../../types';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * The `UltrasoundDirectionalTool` class is a tool for creating directional ultrasound annotations.\n * It allows users to draw lines and measure distances between two points in the image.\n * It automatically calculates the distance based on the relevant unit of measurement.\n */\nclass UltrasoundDirectionalTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  startedDrawing: boolean;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n        /**\n         * Determines whether both horizontal and vertical distances should be displayed\n         * in the text lines when generating annotations' measurement information.\n         */\n        displayBothAxesDistances: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Ultrasound Directional Tool and store it in the annotationManager\n   *\n   * @param evt -  EventTypes.InteractionEventType\n   * @returns The annotation object.\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): UltrasoundDirectionalAnnotation => {\n    if (this.startedDrawing) {\n      return;\n    }\n\n    this.startedDrawing = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    if (!(viewport instanceof StackViewport)) {\n      throw new Error(\n        'UltrasoundDirectionalTool can only be used on a StackViewport'\n      );\n    }\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: UltrasoundDirectionalAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    return false;\n  };\n\n  toolSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes,\n    canvasCoords?: Types.Point2\n  ): void {\n    return;\n  }\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: UltrasoundDirectionalAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    let movingTextBox = false;\n    let handleIndex;\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n\n    this.editData = {\n      handleIndex,\n      annotation,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n\n    const { data } = annotation;\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    // If preventing new measurement means we are in the middle of an existing measurement\n    // we shouldn't deactivate modify or draw\n    if (this.startedDrawing && data.handles.points.length === 1) {\n      // adds the last point to the measurement\n      this.editData.handleIndex = 1;\n      return;\n    }\n\n    this.startedDrawing = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      this.startedDrawing = false;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as UltrasoundDirectionalAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].xValues == null\n      ) {\n        data.cachedStats[targetId] = {\n          xValues: [0, 0],\n          yValues: [0, 0],\n          isHorizontal: false,\n          units: [''],\n          isUnitless: false,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      // draw first point\n      let handleGroupUID = '0';\n      drawHandleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        canvasCoordinates[0],\n        {\n          color,\n        },\n        0\n      );\n\n      renderStatus = true;\n\n      if (canvasCoordinates.length !== 2) {\n        return renderStatus;\n      }\n\n      handleGroupUID = '1';\n      drawHandleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        canvasCoordinates[1],\n        {\n          color,\n        },\n        1\n      );\n\n      const isUnitless = data.cachedStats[targetId].isUnitless;\n\n      if (!isUnitless) {\n        const canvasPoint1 = canvasCoordinates[0];\n        const canvasPoint2 = canvasCoordinates[1];\n\n        const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n        const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n\n        const isHorizontal = data.cachedStats[targetId].isHorizontal;\n\n        // then for the third point we need to go from first point towards\n        // the second point (it can be left or right in the horizontal orientation)\n        // or up or down in the vertical orientation, and only add\n        // the delta y to the x or y coordinate of the first point\n        let projectedPointCanvas = [0, 0] as Types.Point2;\n        if (isHorizontal) {\n          projectedPointCanvas = [\n            canvasPoint1[0] + canvasDeltaX,\n            canvasPoint1[1],\n          ];\n        } else {\n          projectedPointCanvas = [\n            canvasPoint1[0],\n            canvasPoint1[1] + canvasDeltaY,\n          ];\n        }\n\n        // create a line from the first point to the third point\n        let dataId = `${annotationUID}-line-1`;\n        let lineUID = '1';\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          canvasCoordinates[0],\n          projectedPointCanvas,\n          {\n            color,\n            width: 1,\n            shadow: this.configuration.shadow,\n          },\n          dataId\n        );\n\n        // draw another line from first point to the projected one\n        dataId = `${annotationUID}-line-2`;\n        lineUID = '2';\n\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          canvasCoordinates[1],\n          projectedPointCanvas,\n          {\n            color,\n            width: 1,\n            lineDash: [1, 1],\n            shadow: this.configuration.shadow,\n          },\n          dataId\n        );\n      } else {\n        // draw straight line between the two points\n        const dataId = `${annotationUID}-line-1`;\n        const lineUID = '1';\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          canvasCoordinates[0],\n          canvasCoordinates[1],\n          {\n            color,\n            width: 1,\n            shadow: this.configuration.shadow,\n          },\n          dataId\n        );\n      }\n\n      // draw another line from first point to the\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(\n        data,\n        targetId,\n        this.configuration\n      );\n\n      if (!data.handles.textBox.hasMoved) {\n        // linked to the vertex by default\n        const canvasTextBoxCoords = canvasCoordinates[1];\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { element } = enabledElement.viewport;\n\n    // Until we have all two anchors bail out\n    if (data.handles.points.length !== 2) {\n      return;\n    }\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData } = image;\n\n      const worldPos1 = data.handles.points[0];\n      const worldPos2 = data.handles.points[1];\n\n      const imageIndex1 = transformWorldToIndex(imageData, worldPos1);\n      const imageIndex2 = transformWorldToIndex(imageData, worldPos2);\n\n      const { values: values1, units: units1 } =\n        getCalibratedProbeUnitsAndValue(image, [imageIndex1]);\n      const { values: values2, units: units2 } =\n        getCalibratedProbeUnitsAndValue(image, [imageIndex2]);\n\n      let xValues, yValues, units, isHorizontal;\n      let isUnitless = false;\n      if (\n        units1[0] !== units2[0] ||\n        units1[1] !== units2[1] ||\n        (units1[0] === 'raw' && units2[0] === 'raw')\n      ) {\n        // if units are not the same, we cannot calculate the diff\n        // so we just report the px distance\n        const value = distanceToPoint(worldPos1, worldPos2);\n\n        xValues = [value, 0];\n        yValues = [value, 0];\n        units = ['px'];\n        isUnitless = true;\n      } else {\n        const canvasPoint1 = enabledElement.viewport.worldToCanvas(worldPos1);\n        const canvasPoint2 = enabledElement.viewport.worldToCanvas(worldPos2);\n\n        const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n        const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n\n        isHorizontal = Math.abs(canvasDeltaX) > Math.abs(canvasDeltaY);\n        xValues = [values1[0], values2[0]];\n        yValues = [values1[1], values2[1]];\n\n        units = [units1[0], units1[1]];\n      }\n\n      cachedStats[targetId] = {\n        xValues,\n        yValues,\n        isHorizontal,\n        units,\n        isUnitless,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId, configuration): string[] {\n  const cachedStats = data.cachedStats[targetId];\n  const { xValues, yValues, units, isUnitless, isHorizontal } = cachedStats;\n\n  if (isUnitless) {\n    return [`${roundNumber(xValues[0])} px`];\n  }\n\n  if (configuration.displayBothAxesDistances) {\n    const dist1 = Math.abs(xValues[1] - xValues[0]);\n    const dist2 = Math.abs(yValues[1] - yValues[0]);\n    return [\n      `${roundNumber(dist1)} ${units[0]}`,\n      `${roundNumber(dist2)} ${units[1]}`,\n    ];\n  }\n\n  if (isHorizontal) {\n    const dist = Math.abs(xValues[1] - xValues[0]);\n    return [`${roundNumber(dist)} ${units[0]}`];\n  } else {\n    const dist = Math.abs(yValues[1] - yValues[0]);\n    return [`${roundNumber(dist)} ${units[1]}`];\n  }\n}\n\nUltrasoundDirectionalTool.toolName = 'UltrasoundDirectionalTool';\nexport default UltrasoundDirectionalTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\n\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport { drawArrow as drawArrowSvg } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport { resetElementCursor } from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { Annotation } from '../../types';\n\ntype Point2 = Types.Point2;\n\nclass KeyImageTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        getTextCallback,\n        changeTextCallback,\n        canvasPosition: [10, 10],\n        canvasSize: 10,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotation = KeyImageTool.createAnnotation({\n      metadata: { ...viewport.getViewReference(), referencedImageId },\n    });\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.configuration.getTextCallback((text) => {\n      if (!text) {\n        removeAnnotation(annotation.annotationUID);\n        triggerAnnotationRenderForViewportIds(\n          renderingEngine,\n          viewportIdsToRender\n        );\n        this.isDrawing = false;\n        return;\n      }\n      annotation.data.text = text;\n\n      triggerAnnotationCompleted(annotation);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n    });\n\n    return annotation;\n  };\n\n  public cancel() {\n    // No op - the annotation can't be in a partial state\n  }\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n\n    const { canvasPosition, canvasSize } = this.configuration;\n    if (!canvasPosition?.length) {\n      return false;\n    }\n    if (\n      Math.abs(canvasCoords[0] - canvasPosition[0] + canvasSize / 2) <=\n        canvasSize / 2 &&\n      Math.abs(canvasCoords[1] - canvasPosition[1] + canvasSize / 2) <=\n        canvasSize / 2\n    ) {\n      return true;\n    }\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation\n  ): void => {\n    annotation.highlighted = true;\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    handle: ToolHandle\n  ): void {\n    // Nothing special to do here.\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    this._deactivateModify(element);\n    resetElementCursor(element);\n  };\n\n  doubleClickCallback = (evt: EventTypes.TouchTapEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return;\n    }\n\n    const clickedAnnotation = annotations.find((annotation) =>\n      this.isPointNearTool(\n        element,\n        annotation as Annotation,\n        eventDetail.currentPoints.canvas,\n        6 // Todo: get from configuration\n      )\n    );\n\n    if (!clickedAnnotation) {\n      return;\n    }\n\n    const annotation = clickedAnnotation as Annotation;\n\n    this.configuration.changeTextCallback(\n      clickedAnnotation,\n      evt.detail,\n      this._doneChangingTextCallback.bind(this, element, annotation)\n    );\n\n    this.isDrawing = false;\n\n    // This double click was handled and the dialogue was displayed.\n    // No need for any other listener to handle it too - stopImmediatePropagation\n    // helps ensure this primarily so that no other listeners on the target element\n    // get called.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  };\n\n  _doneChangingTextCallback(element, annotation, updatedText): void {\n    annotation.data.text = updatedText;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n  }\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i];\n      const { annotationUID } = annotation;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const { canvasPosition, canvasSize } = this.configuration;\n      if (canvasPosition?.length) {\n        const arrowUID = '1';\n        drawArrowSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arrowUID,\n          canvasPosition.map((it) => it + canvasSize) as Point2,\n          canvasPosition as Point2,\n          {\n            color,\n            width: 1,\n          }\n        );\n      }\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n    }\n\n    return renderStatus;\n  };\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nfunction getTextCallback(doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nKeyImageTool.toolName = 'KeyImage';\n\nexport default KeyImageTool;\n","import { BaseTool } from './base';\nimport { Events } from '../enums';\n\nimport { getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { state } from '../store';\nimport { Enums } from '@cornerstonejs/core';\n\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../cursors/elementCursor';\nimport { IPoints } from '../types';\n\nconst MAGNIFY_VIEWPORT_ID = 'magnify-viewport';\n\nclass MagnifyTool extends BaseTool {\n  static toolName;\n  _bounds: any;\n  editData: {\n    referencedImageId: string;\n    viewportIdsToRender: string[];\n    enabledElement: Types.IEnabledElement;\n    renderingEngine: Types.IRenderingEngine;\n    currentPoints: IPoints;\n  } | null;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        magnifySize: 10, // parallel scale , higher more zoom\n        magnifyWidth: 250, //px\n        magnifyHeight: 250, //px\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  private _hasBeenRemoved = false;\n\n  _getReferencedImageId(\n    viewport: Types.IStackViewport | Types.IVolumeViewport\n  ): string {\n    const targetId = this.getTargetId(viewport);\n\n    let referencedImageId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    }\n\n    return referencedImageId;\n  }\n\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element, currentPoints } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    if (!(viewport instanceof StackViewport)) {\n      throw new Error('MagnifyTool only works on StackViewports');\n    }\n\n    const referencedImageId = this._getReferencedImageId(viewport);\n\n    if (!referencedImageId) {\n      throw new Error(\n        'MagnifyTool: No referenced image id found, reconstructed planes not supported yet'\n      );\n    }\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      referencedImageId,\n      viewportIdsToRender,\n      enabledElement,\n      renderingEngine,\n      currentPoints,\n    };\n\n    this._createMagnificationViewport();\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType) => {\n    this.preMouseDownCallback(evt);\n  };\n\n  _createMagnificationViewport = () => {\n    const {\n      enabledElement,\n      referencedImageId,\n      viewportIdsToRender,\n      renderingEngine,\n      currentPoints,\n    } = this.editData;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    const viewportProperties = viewport.getProperties();\n\n    const { canvas: canvasPos, world: worldPos } = currentPoints;\n\n    let magnifyToolElement: HTMLDivElement;\n\n    magnifyToolElement = element.querySelector('.magnifyTool');\n    if (magnifyToolElement === null) {\n      const magnifyElement = document.createElement('div');\n\n      magnifyElement.classList.add('magnifyTool');\n\n      magnifyElement.style.display = 'block';\n      magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;\n      magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;\n      magnifyElement.style.position = 'absolute';\n\n      magnifyToolElement = magnifyElement;\n\n      const viewportElement = element.querySelector('.viewport-element');\n      viewportElement.appendChild(magnifyElement);\n\n      const viewportInput = {\n        viewportId: MAGNIFY_VIEWPORT_ID,\n        type: Enums.ViewportType.STACK,\n        element: magnifyToolElement as HTMLDivElement,\n      };\n\n      renderingEngine.enableElement(viewportInput);\n    }\n\n    // Todo: use CSS transform instead of setting top and left for better performance\n    magnifyToolElement.style.top = `${\n      canvasPos[1] - this.configuration.magnifyHeight / 2\n    }px`;\n    magnifyToolElement.style.left = `${\n      canvasPos[0] - this.configuration.magnifyWidth / 2\n    }px`;\n\n    const magnifyViewport = renderingEngine.getViewport(\n      MAGNIFY_VIEWPORT_ID\n    ) as Types.IStackViewport;\n    magnifyViewport.setStack([referencedImageId]).then(() => {\n      if (this._hasBeenRemoved) {\n        return;\n      }\n      // match the original viewport voi range\n      magnifyViewport.setProperties(viewportProperties);\n\n      // Use the original viewport for the base for parallelScale\n      const { parallelScale } = viewport.getCamera();\n\n      const { focalPoint, position, viewPlaneNormal } =\n        magnifyViewport.getCamera();\n\n      const distance = Math.sqrt(\n        Math.pow(focalPoint[0] - position[0], 2) +\n          Math.pow(focalPoint[1] - position[1], 2) +\n          Math.pow(focalPoint[2] - position[2], 2)\n      );\n\n      const updatedFocalPoint = <Types.Point3>[\n        worldPos[0],\n        worldPos[1],\n        worldPos[2],\n      ];\n\n      const updatedPosition = <Types.Point3>[\n        updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n        updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n        updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n      ];\n\n      magnifyViewport.setCamera({\n        parallelScale: parallelScale * (1 / this.configuration.magnifySize),\n        focalPoint: updatedFocalPoint,\n        position: updatedPosition,\n      });\n      magnifyViewport.render();\n    });\n\n    magnifyToolElement.style.display = 'block';\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n\n    const { deltaPoints, element, currentPoints } = eventDetail;\n    const deltaPointsWorld = deltaPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n\n    const magnifyElement = element.querySelector(\n      '.magnifyTool'\n    ) as HTMLDivElement;\n\n    if (!magnifyElement) {\n      return;\n    }\n\n    magnifyElement.style.top = `${\n      canvasPos[1] - this.configuration.magnifyHeight / 2\n    }px`;\n    magnifyElement.style.left = `${\n      canvasPos[0] - this.configuration.magnifyWidth / 2\n    }px`;\n\n    const { focalPoint, position } = magnifyViewport.getCamera();\n\n    const updatedPosition = <Types.Point3>[\n      position[0] + deltaPointsWorld[0],\n      position[1] + deltaPointsWorld[1],\n      position[2] + deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] + deltaPointsWorld[0],\n      focalPoint[1] + deltaPointsWorld[1],\n      focalPoint[2] + deltaPointsWorld[2],\n    ];\n\n    magnifyViewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n\n    magnifyViewport.render();\n  };\n\n  _dragEndCallback = (evt: EventTypes.InteractionEventType) => {\n    const { element } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);\n\n    const viewportElement = element.querySelector('.viewport-element');\n\n    const magnifyToolElement = viewportElement.querySelector(\n      '.magnifyTool'\n    ) as HTMLDivElement;\n\n    viewportElement.removeChild(magnifyToolElement);\n\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n    this._hasBeenRemoved = true;\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n    this._hasBeenRemoved = false;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._dragEndCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._dragEndCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._dragEndCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n}\n\nMagnifyTool.toolName = 'Magnify';\nexport default MagnifyTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport {\n  getEnabledElement,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  SegmentationRepresentations,\n  ToolModes,\n  Events as cstEvents,\n} from '../enums';\nimport { ToolGroupManager, state } from '../store';\nimport { debounce } from '../utilities';\nimport { ToolModeChangedEventType } from '../types/EventTypes';\nimport { segmentation } from '..';\nimport { EventTypes, IToolGroup } from '../types';\nimport {\n  AnnotationTool,\n  AdvancedMagnifyTool,\n  SegmentationDisplayTool,\n} from './';\nimport { distanceToPoint } from '../utilities/math/point';\n\nconst MAGNIFY_CLASSNAME = 'advancedMagnifyTool';\nconst MAGNIFY_VIEWPORT_INITIAL_RADIUS = 125;\n\n// TODO: find a better to identify segmentation actors\nconst isSegmentation = (actor) => actor.uid !== actor.referenceId;\n\nexport type AutoPanCallbackData = {\n  points: {\n    currentPosition: {\n      canvas: Types.Point2;\n      world: Types.Point3;\n    };\n    newPosition: {\n      canvas: Types.Point2;\n      world: Types.Point3;\n    };\n  };\n  delta: {\n    canvas: Types.Point2;\n    world: Types.Point3;\n  };\n};\n\nexport type AutoPanCallback = (data: AutoPanCallbackData) => void;\n\nclass AdvancedMagnifyViewport {\n  private _viewportId: string;\n  private _sourceEnabledElement: Types.IEnabledElement;\n  private _enabledElement: Types.IEnabledElement = null;\n  private _sourceToolGroup: IToolGroup = null;\n  private _magnifyToolGroup: IToolGroup = null;\n  private _isViewportReady = false;\n  private _radius = 0;\n  private _resized = false;\n  private _resizeViewportAsync: () => void;\n  private _canAutoPan = false;\n  private _autoPan: {\n    enabled: boolean;\n    padding: number;\n    callback: AutoPanCallback;\n  };\n  public position: Types.Point2;\n  public zoomFactor: number;\n  public visible: boolean;\n\n  constructor({\n    magnifyViewportId,\n    sourceEnabledElement,\n    radius = MAGNIFY_VIEWPORT_INITIAL_RADIUS,\n    position = [0, 0],\n    zoomFactor,\n    autoPan,\n  }: {\n    magnifyViewportId?: string;\n    sourceEnabledElement: Types.IEnabledElement;\n    radius?: number;\n    position?: Types.Point2;\n    zoomFactor: number;\n    autoPan: {\n      enabled: boolean;\n      padding: number;\n      callback: AutoPanCallback;\n    };\n  }) {\n    // Private properties\n    this._viewportId = magnifyViewportId ?? csUtils.uuidv4();\n    this._sourceEnabledElement = sourceEnabledElement;\n    this._autoPan = autoPan;\n\n    // Public properties\n    this.radius = radius;\n    this.position = position;\n    this.zoomFactor = zoomFactor;\n    this.visible = true;\n\n    this._browserMouseDownCallback = this._browserMouseDownCallback.bind(this);\n    this._browserMouseUpCallback = this._browserMouseUpCallback.bind(this);\n    this._handleToolModeChanged = this._handleToolModeChanged.bind(this);\n    this._mouseDragCallback = this._mouseDragCallback.bind(this);\n    this._resizeViewportAsync = <() => void>(\n      debounce(this._resizeViewport.bind(this), 1)\n    );\n\n    this._initialize();\n  }\n\n  public get sourceEnabledElement() {\n    return this._sourceEnabledElement;\n  }\n\n  public get viewportId() {\n    return this._viewportId;\n  }\n\n  public get radius() {\n    return this._radius;\n  }\n\n  public set radius(radius: number) {\n    // Just moving the magnifying glass around may change its radius\n    // by very small amount due to floating number precision\n    if (Math.abs(this._radius - radius) > 0.00001) {\n      this._radius = radius;\n      this._resized = true;\n    }\n  }\n\n  public update() {\n    const { radius, position, visible } = this;\n    const { viewport } = this._enabledElement;\n    const { element } = viewport;\n    const size = 2 * radius;\n    const [x, y] = position;\n\n    if (this._resized) {\n      this._resizeViewportAsync();\n      this._resized = false;\n    }\n\n    Object.assign(element.style, {\n      display: visible ? 'block' : 'hidden',\n      width: `${size}px`,\n      height: `${size}px`,\n      left: `${-radius}px`,\n      top: `${-radius}px`,\n      transform: `translate(${x}px, ${y}px)`,\n    });\n\n    if (this._isViewportReady) {\n      this._syncViewports();\n      viewport.render();\n    }\n  }\n\n  public dispose() {\n    const { viewport } = this._enabledElement;\n    const { element } = viewport;\n    const renderingEngine = viewport.getRenderingEngine();\n\n    this._removeEventListeners(element);\n    renderingEngine.disableElement(viewport.id);\n\n    if (element.parentNode) {\n      element.parentNode.removeChild(element);\n    }\n  }\n\n  private _handleToolModeChanged(evt: ToolModeChangedEventType) {\n    const { _magnifyToolGroup: magnifyToolGroup } = this;\n    const { toolGroupId, toolName, mode, toolBindingsOptions } = evt.detail;\n\n    if (this._sourceToolGroup?.id !== toolGroupId) {\n      return;\n    }\n\n    switch (mode) {\n      case ToolModes.Active:\n        magnifyToolGroup.setToolActive(toolName, toolBindingsOptions);\n        break;\n      case ToolModes.Passive:\n        magnifyToolGroup.setToolPassive(toolName);\n        break;\n      case ToolModes.Enabled:\n        magnifyToolGroup.setToolEnabled(toolName);\n        break;\n      case ToolModes.Disabled:\n        magnifyToolGroup.setToolDisabled(toolName);\n        break;\n      default:\n        throw new Error(`Unknow tool mode (${mode})`);\n    }\n  }\n\n  // Children elements need to inherit border-radius otherwise the canvas will\n  // trigger events when moving/dragging/clicking on the corners outside of the\n  // border (circle) region.\n  private _inheritBorderRadius(magnifyElement) {\n    const viewport = magnifyElement.querySelector('.viewport-element');\n    const canvas = magnifyElement.querySelector('.cornerstone-canvas');\n\n    viewport.style.borderRadius = 'inherit';\n    canvas.style.borderRadius = 'inherit';\n  }\n\n  private _createViewportNode(): HTMLDivElement {\n    const magnifyElement = document.createElement('div');\n    const { radius } = this;\n    const size = radius * 2;\n\n    magnifyElement.classList.add(MAGNIFY_CLASSNAME);\n\n    // Update the style and move the element out of the screen with \"transforms\"\n    // to make it \"invisible\" and preserving its size because when \"display\" is\n    // set to \"none\" both \"offsetWidth\" and \"offsetHeight\" returns zero. Another\n    // way would be setting \"visibility\" to \"hidden\" but \"transforms\" is used\n    // because it is already being updated when update() is called\n    Object.assign(magnifyElement.style, {\n      display: 'block',\n      width: `${size}px`,\n      height: `${size}px`,\n      position: 'absolute',\n      overflow: 'hidden',\n      borderRadius: '50%',\n      boxSizing: 'border-box',\n      left: `${-radius}px`,\n      top: `${-radius}px`,\n      transform: `translate(-1000px, -1000px)`,\n    });\n\n    return magnifyElement;\n  }\n\n  private _convertZoomFactorToParallelScale(\n    viewport,\n    magnifyViewport,\n    zoomFactor\n  ) {\n    const { parallelScale } = viewport.getCamera();\n    const canvasRatio =\n      magnifyViewport.canvas.offsetWidth / viewport.canvas.offsetWidth;\n\n    return parallelScale * (1 / zoomFactor) * canvasRatio;\n  }\n\n  private _isStackViewport(\n    viewport: Types.IViewport\n  ): viewport is Types.IStackViewport {\n    return 'setStack' in viewport;\n  }\n\n  private _isVolumeViewport(\n    viewport: Types.IViewport\n  ): viewport is Types.IVolumeViewport {\n    return 'addVolumes' in viewport;\n  }\n\n  private _cloneToolGroups(\n    sourceViewport: Types.IViewport,\n    magnifyViewport: Types.IViewport\n  ) {\n    const sourceActors = sourceViewport.getActors();\n    const magnifyToolGroupId = `${magnifyViewport.id}-toolGroup`;\n    const sourceToolGroup = ToolGroupManager.getToolGroupForViewport(\n      sourceViewport.id,\n      sourceViewport.renderingEngineId\n    );\n\n    const magnifyToolGroup = sourceToolGroup.clone(\n      magnifyToolGroupId,\n      (toolName) => {\n        const toolInstance = sourceToolGroup.getToolInstance(toolName);\n        const isAnnotationTool =\n          toolInstance instanceof AnnotationTool &&\n          !(toolInstance instanceof AdvancedMagnifyTool);\n\n        return (\n          isAnnotationTool || toolName === SegmentationDisplayTool.toolName\n        );\n      }\n    );\n\n    magnifyToolGroup.addViewport(\n      magnifyViewport.id,\n      magnifyViewport.renderingEngineId\n    );\n\n    sourceActors.filter(isSegmentation).forEach((actor) => {\n      segmentation.addSegmentationRepresentations(magnifyToolGroupId, [\n        {\n          segmentationId: actor.referenceId,\n          type: SegmentationRepresentations.Labelmap,\n        },\n      ]);\n    });\n\n    return { sourceToolGroup, magnifyToolGroup };\n  }\n\n  private _cloneStack(\n    sourceViewport: Types.IStackViewport,\n    magnifyViewport: Types.IStackViewport\n  ): void {\n    const imageIds = sourceViewport.getImageIds();\n\n    magnifyViewport.setStack(imageIds).then(() => {\n      this._isViewportReady = true;\n      this.update();\n    });\n  }\n\n  private _cloneVolumes(\n    sourceViewport: Types.IVolumeViewport,\n    magnifyViewport: Types.IVolumeViewport\n  ): Types.IVolumeViewport {\n    const actors = sourceViewport.getActors();\n    const volumeInputArray: Types.IVolumeInput[] = actors\n      .filter((actor) => !isSegmentation(actor))\n      .map((actor) => ({ volumeId: actor.uid }));\n\n    magnifyViewport.setVolumes(volumeInputArray).then(() => {\n      this._isViewportReady = true;\n      this.update();\n    });\n\n    return magnifyViewport;\n  }\n\n  private _cloneViewport(sourceViewport, magnifyElement) {\n    const { viewportId: magnifyViewportId } = this;\n    const renderingEngine =\n      sourceViewport.getRenderingEngine() as Types.IRenderingEngine;\n\n    const { options: sourceViewportOptions } = sourceViewport;\n    const viewportInput = {\n      element: magnifyElement,\n      viewportId: magnifyViewportId,\n      type: sourceViewport.type,\n      defaultOptions: { ...sourceViewportOptions },\n    };\n\n    renderingEngine.enableElement(viewportInput);\n\n    const magnifyViewport = <Types.IViewport>(\n      renderingEngine.getViewport(magnifyViewportId)\n    );\n\n    if (this._isStackViewport(sourceViewport)) {\n      this._cloneStack(sourceViewport, magnifyViewport as Types.IStackViewport);\n    } else if (this._isVolumeViewport(sourceViewport)) {\n      this._cloneVolumes(\n        sourceViewport,\n        magnifyViewport as Types.IVolumeViewport\n      );\n    }\n\n    // Prevent handling events outside of the magnifying glass because it has rounded border\n    this._inheritBorderRadius(magnifyElement);\n\n    const toolGroups = this._cloneToolGroups(sourceViewport, magnifyViewport);\n\n    this._sourceToolGroup = toolGroups.sourceToolGroup;\n    this._magnifyToolGroup = toolGroups.magnifyToolGroup;\n  }\n\n  private _cancelMouseEventCallback(evt): void {\n    evt.stopPropagation();\n    evt.preventDefault();\n  }\n\n  private _browserMouseUpCallback(evt) {\n    const { element } = this._enabledElement.viewport;\n\n    document.removeEventListener('mouseup', this._browserMouseUpCallback);\n\n    // Restrict the scope of magnifying glass events again\n    element.addEventListener('mouseup', this._cancelMouseEventCallback);\n    element.addEventListener('mousemove', this._cancelMouseEventCallback);\n  }\n\n  private _browserMouseDownCallback(evt) {\n    const { element } = this._enabledElement.viewport;\n\n    // Enable auto pan only when user clicks inside of the magnifying glass\n    // viewport otherwise it can move when interacting with annotations outside\n    // of the magnifying glass or when trying to move/resize it.\n    this._canAutoPan = !!evt.target?.closest('.advancedMagnifyTool');\n\n    // Wait for the mouseup event to restrict the scope of magnifying glass events again\n    document.addEventListener('mouseup', this._browserMouseUpCallback);\n\n    // Allow mouseup and mousemove events to make it possible to manipulate the\n    // tool when passing the mouse over the magnifying glass (dragging a handle).\n    // Just relying on state.isInteractingWithTool does not work because there\n    // is a 400ms delay to handle double click (see mouseDownListener) which\n    // makes the magnifying glass unresponsive for that amount of time.\n    element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n    element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n  }\n\n  private _mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    if (!state.isInteractingWithTool) {\n      return;\n    }\n\n    const { _autoPan: autoPan } = this;\n\n    if (!autoPan.enabled || !this._canAutoPan) {\n      return;\n    }\n\n    const { currentPoints } = evt.detail;\n    const { viewport } = this._enabledElement;\n    const { canvasToWorld } = viewport;\n    const { canvas: canvasCurrent } = currentPoints;\n    const { radius: magnifyRadius } = this;\n    const canvasCenter: Types.Point2 = [magnifyRadius, magnifyRadius];\n    const dist = distanceToPoint(canvasCenter, canvasCurrent);\n    const maxDist = magnifyRadius - autoPan.padding;\n\n    // No need to pan if it is not close to the border\n    if (dist <= maxDist) {\n      return;\n    }\n\n    const panDist = dist - maxDist;\n    const canvasDeltaPos = vec2.sub(\n      vec2.create(),\n      canvasCurrent,\n      canvasCenter\n    ) as Types.Point2;\n\n    vec2.normalize(canvasDeltaPos, canvasDeltaPos);\n    vec2.scale(canvasDeltaPos, canvasDeltaPos, panDist);\n\n    const newCanvasPosition = vec2.add(\n      vec2.create(),\n      this.position,\n      canvasDeltaPos\n    ) as Types.Point2;\n    const currentWorldPos = canvasToWorld(this.position);\n    const newWorldPos = canvasToWorld(newCanvasPosition);\n    const worldDeltaPos = vec3.sub(\n      vec3.create(),\n      newWorldPos,\n      currentWorldPos\n    ) as Types.Point3;\n\n    const autoPanCallbackData: AutoPanCallbackData = {\n      points: {\n        currentPosition: {\n          canvas: this.position,\n          world: currentWorldPos,\n        },\n        newPosition: {\n          canvas: newCanvasPosition,\n          world: newWorldPos,\n        },\n      },\n      delta: {\n        canvas: canvasDeltaPos,\n        world: worldDeltaPos,\n      },\n    };\n\n    autoPan.callback(autoPanCallbackData);\n  }\n\n  private _addBrowserEventListeners(element) {\n    // mousedown on document is handled in the capture phase because the other\n    // mousedown event listener added to the magnifying glass element does not\n    // allow the event to buble up and reach the document.\n    document.addEventListener(\n      'mousedown',\n      this._browserMouseDownCallback,\n      true\n    );\n\n    // All mouse events should not buble up avoiding the source viewport from\n    // handling those events resulting in unexpected behaviors.\n    element.addEventListener('mousedown', this._cancelMouseEventCallback);\n    element.addEventListener('mouseup', this._cancelMouseEventCallback);\n    element.addEventListener('mousemove', this._cancelMouseEventCallback);\n    element.addEventListener('dblclick', this._cancelMouseEventCallback);\n  }\n\n  private _removeBrowserEventListeners(element) {\n    document.removeEventListener(\n      'mousedown',\n      this._browserMouseDownCallback,\n      true\n    );\n    document.removeEventListener('mouseup', this._browserMouseUpCallback);\n\n    element.removeEventListener('mousedown', this._cancelMouseEventCallback);\n    element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n    element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n    element.removeEventListener('dblclick', this._cancelMouseEventCallback);\n  }\n\n  private _addEventListeners(element) {\n    eventTarget.addEventListener(\n      cstEvents.TOOL_MODE_CHANGED,\n      this._handleToolModeChanged\n    );\n\n    element.addEventListener(\n      cstEvents.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n\n    element.addEventListener(\n      cstEvents.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n\n    this._addBrowserEventListeners(element);\n  }\n\n  private _removeEventListeners(element) {\n    eventTarget.removeEventListener(\n      cstEvents.TOOL_MODE_CHANGED,\n      this._handleToolModeChanged\n    );\n\n    element.addEventListener(\n      cstEvents.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n\n    element.addEventListener(\n      cstEvents.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n\n    this._removeBrowserEventListeners(element);\n  }\n\n  private _initialize() {\n    const { _sourceEnabledElement: sourceEnabledElement } = this;\n    const { viewport: sourceViewport } = sourceEnabledElement;\n    const { canvas: sourceCanvas } = sourceViewport;\n    const magnifyElement = this._createViewportNode();\n\n    sourceCanvas.parentNode.appendChild(magnifyElement);\n\n    this._addEventListeners(magnifyElement);\n    this._cloneViewport(sourceViewport, magnifyElement);\n    this._enabledElement = getEnabledElement(magnifyElement);\n  }\n\n  private _syncViewportsCameras(sourceViewport, magnifyViewport) {\n    const worldPos = sourceViewport.canvasToWorld(this.position);\n\n    // Use the original viewport for the base for parallelScale\n    const parallelScale = this._convertZoomFactorToParallelScale(\n      sourceViewport,\n      magnifyViewport,\n      this.zoomFactor\n    );\n\n    const { focalPoint, position, viewPlaneNormal } =\n      magnifyViewport.getCamera();\n\n    const distance = Math.sqrt(\n      Math.pow(focalPoint[0] - position[0], 2) +\n        Math.pow(focalPoint[1] - position[1], 2) +\n        Math.pow(focalPoint[2] - position[2], 2)\n    );\n\n    const updatedFocalPoint = <Types.Point3>[\n      worldPos[0],\n      worldPos[1],\n      worldPos[2],\n    ];\n\n    const updatedPosition = <Types.Point3>[\n      updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n      updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n      updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n    ];\n\n    magnifyViewport.setCamera({\n      parallelScale,\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n  }\n\n  private _syncStackViewports(\n    sourceViewport: Types.IStackViewport,\n    magnifyViewport: Types.IStackViewport\n  ) {\n    magnifyViewport.setImageIdIndex(sourceViewport.getCurrentImageIdIndex());\n  }\n\n  private _syncViewports() {\n    const { viewport: sourceViewport } = this._sourceEnabledElement;\n    const { viewport: magnifyViewport } = this._enabledElement;\n    const sourceProperties = sourceViewport.getProperties();\n    const imageData = magnifyViewport.getImageData();\n\n    if (!imageData) {\n      return;\n    }\n\n    magnifyViewport.setProperties(sourceProperties);\n    this._syncViewportsCameras(sourceViewport, magnifyViewport);\n\n    if (this._isStackViewport(sourceViewport)) {\n      this._syncStackViewports(\n        sourceViewport as Types.IStackViewport,\n        magnifyViewport as Types.IStackViewport\n      );\n    }\n\n    this._syncViewportsCameras(sourceViewport, magnifyViewport);\n    magnifyViewport.render();\n  }\n\n  private _resizeViewport() {\n    const { viewport } = this._enabledElement;\n    const renderingEngine = viewport.getRenderingEngine();\n\n    renderingEngine.resize();\n  }\n}\n\nexport { AdvancedMagnifyViewport as default, AdvancedMagnifyViewport };\n","import { vec3 } from 'gl-matrix';\nimport {\n  eventTarget,\n  Enums,\n  getRenderingEngine,\n  CONSTANTS,\n  getEnabledElementByViewportId,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { AnnotationRemovedEventType } from '../types/EventTypes';\nimport { Events as cstEvents } from '../enums';\nimport {\n  AdvancedMagnifyViewport,\n  AutoPanCallback,\n} from './AdvancedMagnifyViewport';\nimport { AdvancedMagnifyAnnotation } from '../types/ToolSpecificAnnotationTypes';\n\n// Defined the tool name internally instead of importing\n// AdvancedMagnifyTool due to cyclic dependency\nconst ADVANCED_MAGNIFY_TOOL_NAME = 'AdvancedMagnify';\n\nconst PARALLEL_THRESHOLD = 1 - CONSTANTS.EPSILON;\nconst { Events } = Enums;\n\nexport type MagnifyViewportInfo = {\n  // Viewport id to be used or new v4 compliant GUID is used instead\n  magnifyViewportId?: string;\n  // Enabled element where the magnifying glass shall be added to\n  sourceEnabledElement: Types.IEnabledElement;\n  // Magnifying glass position (center)\n  position: Types.Point2;\n  // Magnifying glass radius (pixels)\n  radius: number;\n  // Amount of magnification applied to the magnifying glass image compared to the source viewport.\n  zoomFactor: number;\n  // Allow panning the viewport when moving an annotation point close to the border of the magnifying glass\n  autoPan: {\n    // Enable or disable auto pan\n    enabled: boolean;\n    // Minimum distance to the border before start auto panning\n    padding: number;\n    // Callback function responsible for updating the annotation (circle)\n    // that contains the magnifying viewport\n    callback: AutoPanCallback;\n  };\n};\n\ntype MagnifyViewportsMapEntry = {\n  annotation: AdvancedMagnifyAnnotation;\n  magnifyViewport: AdvancedMagnifyViewport;\n  magnifyViewportInfo: MagnifyViewportInfo;\n};\n\n/**\n * Manager responsible for creating, storing and destroying magnifying glass\n * viewports. There are no restrictions to create a new instance of it but it\n * should be accessed through getInstance() method.\n */\nclass AdvancedMagnifyViewportManager {\n  private static _singleton: AdvancedMagnifyViewportManager;\n  private _magnifyViewportsMap: Map<string, MagnifyViewportsMapEntry>;\n\n  constructor() {\n    this._magnifyViewportsMap = new Map();\n    this._initialize();\n  }\n\n  /**\n   * Creates a new magnifying glass viewport manager instance when this method is\n   * called for the first time or return the instance previously created for\n   * any subsequent call (singleton pattern).\n   * @returns A magnifying viewport manager instance\n   */\n  public static getInstance(): AdvancedMagnifyViewportManager {\n    AdvancedMagnifyViewportManager._singleton =\n      AdvancedMagnifyViewportManager._singleton ??\n      new AdvancedMagnifyViewportManager();\n\n    return AdvancedMagnifyViewportManager._singleton;\n  }\n\n  /**\n   * Creates a new magnifying glass viewport instance\n   * @param viewportInfo - Viewport data used when creating a new magnifying glass viewport\n   * @returns A magnifying glass viewport instance\n   */\n  public createViewport = (\n    annotation: AdvancedMagnifyAnnotation,\n    viewportInfo: MagnifyViewportInfo\n  ): AdvancedMagnifyViewport => {\n    const {\n      magnifyViewportId,\n      sourceEnabledElement,\n      position,\n      radius,\n      zoomFactor,\n      autoPan,\n    } = viewportInfo;\n    const { viewport: sourceViewport } = sourceEnabledElement;\n    const { element: sourceElement } = sourceViewport;\n\n    const magnifyViewport = new AdvancedMagnifyViewport({\n      magnifyViewportId,\n      sourceEnabledElement,\n      radius,\n      position,\n      zoomFactor,\n      autoPan,\n    });\n\n    this._addSourceElementEventListener(sourceElement);\n    this._magnifyViewportsMap.set(magnifyViewport.viewportId, {\n      annotation,\n      magnifyViewport,\n      magnifyViewportInfo: viewportInfo,\n    });\n\n    return magnifyViewport;\n  };\n\n  /**\n   * Find and return a magnifying glass viewport based on its id\n   * @param magnifyViewportId - Magnifying glass viewport id\n   * @returns A magnifying glass viewport instance\n   */\n  public getViewport(magnifyViewportId: string): AdvancedMagnifyViewport {\n    return this._magnifyViewportsMap.get(magnifyViewportId)?.magnifyViewport;\n  }\n\n  /**\n   * Release all magnifying glass viewport instances and remove all event\n   * listeners making all objects available to be garbage collected.\n   */\n  public dispose() {\n    this._removeEventListeners();\n    this._destroyViewports();\n  }\n\n  public destroyViewport(magnifyViewportId: string) {\n    const magnifyViewportMapEntry =\n      this._magnifyViewportsMap.get(magnifyViewportId);\n\n    if (magnifyViewportMapEntry) {\n      const { magnifyViewport } = magnifyViewportMapEntry;\n      const { viewport: sourceViewport } = magnifyViewport.sourceEnabledElement;\n      const { element: sourceElement } = sourceViewport;\n\n      this._removeSourceElementEventListener(sourceElement);\n\n      magnifyViewport.dispose();\n      this._magnifyViewportsMap.delete(magnifyViewportId);\n    }\n  }\n\n  private _destroyViewports() {\n    const magnifyViewportIds = Array.from(this._magnifyViewportsMap.keys());\n\n    magnifyViewportIds.forEach((magnifyViewportId) =>\n      this.destroyViewport(magnifyViewportId)\n    );\n  }\n\n  private _annotationRemovedCallback = (evt: AnnotationRemovedEventType) => {\n    const { annotation } = evt.detail;\n\n    if (annotation.metadata.toolName !== ADVANCED_MAGNIFY_TOOL_NAME) {\n      return;\n    }\n\n    this.destroyViewport(annotation.data.magnifyViewportId);\n  };\n\n  private _getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId) {\n    const magnifyViewportsMapEntries = Array.from(\n      this._magnifyViewportsMap.values()\n    );\n\n    return magnifyViewportsMapEntries.filter(({ magnifyViewport }) => {\n      const { viewport } = magnifyViewport.sourceEnabledElement;\n      return viewport.id === sourceViewportId;\n    });\n  }\n\n  private _newStackImageCallback = (\n    evt: Types.EventTypes.StackNewImageEvent\n  ) => {\n    const { viewportId: sourceViewportId, imageId } = evt.detail;\n    const magnifyViewportsMapEntries =\n      this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n\n    const { viewport } = getEnabledElementByViewportId(sourceViewportId);\n\n    // if the viewport was new in terms of image, we need to destroy the magnify\n    // viewports and recreate them, the new image might have different dimensions\n    // or orientation etc.\n    if ((viewport as Types.IStackViewport).stackActorReInitialized) {\n      // we should invalidate the viewport as well\n      // this will trigger the magnify viewport to be updated\n      this._reset(sourceViewportId);\n    }\n\n    magnifyViewportsMapEntries.forEach(({ annotation }) => {\n      annotation.metadata.referencedImageId = imageId;\n      annotation.invalidated = true;\n    });\n  };\n\n  private _newVolumeImageCallback = (\n    evt: Types.EventTypes.VolumeNewImageEvent\n  ) => {\n    const { renderingEngineId, viewportId: sourceViewportId } = evt.detail;\n    const renderingEngine = getRenderingEngine(renderingEngineId);\n    const sourceViewport = renderingEngine.getViewport(sourceViewportId);\n    const { viewPlaneNormal: currentViewPlaneNormal } =\n      sourceViewport.getCamera();\n\n    const magnifyViewportsMapEntries =\n      this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n\n    magnifyViewportsMapEntries.forEach(({ annotation }) => {\n      const { viewPlaneNormal } = annotation.metadata;\n\n      // Compare the normal to make sure the volume is not rotate in 3D space\n      const isParallel =\n        Math.abs(vec3.dot(viewPlaneNormal, currentViewPlaneNormal)) >\n        PARALLEL_THRESHOLD;\n\n      if (!isParallel) {\n        return;\n      }\n\n      const { handles } = annotation.data;\n      const worldImagePlanePoint = sourceViewport.canvasToWorld([0, 0]);\n      const vecHandleToImagePlane = vec3.sub(\n        vec3.create(),\n        worldImagePlanePoint,\n        handles.points[0]\n      );\n      const worldDist = vec3.dot(vecHandleToImagePlane, currentViewPlaneNormal);\n      const worldDelta = vec3.scale(\n        vec3.create(),\n        currentViewPlaneNormal,\n        worldDist\n      );\n\n      // Move all handle points to the image plane to make the annotation visible\n      for (let i = 0, len = handles.points.length; i < len; i++) {\n        const point = handles.points[i];\n\n        point[0] += worldDelta[0];\n        point[1] += worldDelta[1];\n        point[2] += worldDelta[2];\n      }\n\n      annotation.invalidated = true;\n    });\n  };\n\n  private _reset(sourceViewportId: string) {\n    const magnifyViewports =\n      this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n\n    magnifyViewports.forEach(\n      ({ magnifyViewport, annotation, magnifyViewportInfo }) => {\n        this.destroyViewport(magnifyViewport.viewportId);\n\n        // if it is new image we need to update the magnifyViewportInfo\n        // since it might have new image dimensions etc.\n        const newEnabledElement =\n          getEnabledElementByViewportId(sourceViewportId);\n\n        this.createViewport(annotation, {\n          ...magnifyViewportInfo,\n          sourceEnabledElement: {\n            ...newEnabledElement,\n          },\n        });\n      }\n    );\n  }\n\n  private _addEventListeners() {\n    eventTarget.addEventListener(\n      cstEvents.ANNOTATION_REMOVED,\n      this._annotationRemovedCallback\n    );\n  }\n\n  private _removeEventListeners() {\n    eventTarget.removeEventListener(\n      cstEvents.ANNOTATION_REMOVED,\n      this._annotationRemovedCallback\n    );\n  }\n\n  private _addSourceElementEventListener(element) {\n    element.addEventListener(\n      Events.STACK_NEW_IMAGE,\n      this._newStackImageCallback\n    );\n\n    const newStackHandler = (evt) => {\n      const { viewportId: sourceViewportId } = evt.detail;\n      this._reset(sourceViewportId);\n    };\n\n    element.addEventListener(Events.STACK_VIEWPORT_NEW_STACK, newStackHandler);\n\n    const newVolumeHandler = (evt) => {\n      const { viewportId: sourceViewportId } = evt.detail;\n      this._reset(sourceViewportId);\n    };\n    element.addEventListener(\n      Events.VOLUME_VIEWPORT_NEW_VOLUME,\n      newVolumeHandler\n    );\n\n    element.addEventListener(\n      Events.VOLUME_NEW_IMAGE,\n      this._newVolumeImageCallback\n    );\n\n    // Store the event handlers to remove later\n    element.newStackHandler = newStackHandler;\n    element.newVolumeHandler = newVolumeHandler;\n  }\n\n  private _removeSourceElementEventListener(element) {\n    element.removeEventListener(\n      Events.STACK_NEW_IMAGE,\n      this._newStackImageCallback\n    );\n\n    element.removeEventListener(\n      Events.VOLUME_NEW_IMAGE,\n      this._newVolumeImageCallback\n    );\n\n    // Remove using the stored handlers\n    element.removeEventListener(\n      Events.STACK_VIEWPORT_NEW_STACK,\n      element.newStackHandler\n    );\n    element.removeEventListener(\n      Events.VOLUME_VIEWPORT_NEW_VOLUME,\n      element.newVolumeHandler\n    );\n\n    // Clean up references\n    delete element.newStackHandler;\n    delete element.newVolumeHandler;\n  }\n\n  private _initialize() {\n    this._addEventListeners();\n  }\n}\n\nexport {\n  AdvancedMagnifyViewportManager as default,\n  AdvancedMagnifyViewportManager,\n};\n","import { AnnotationTool } from './base';\n\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  addAnnotation,\n  getAllAnnotations,\n  getAnnotations,\n  removeAnnotation,\n} from '../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted } from '../stateManagement/annotation/helpers/state';\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n} from '../drawingSvg';\nimport { state } from '../store';\nimport { Events, MouseBindings, KeyboardBindings } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../types';\nimport { AdvancedMagnifyAnnotation } from '../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { getCanvasCircleRadius } from '../utilities/math/circle';\nimport AdvancedMagnifyViewportManager from './AdvancedMagnifyViewportManager';\nimport type { AutoPanCallbackData } from './AdvancedMagnifyViewport';\n\nenum AdvancedMagnifyToolActions {\n  ShowZoomFactorsList = 'showZoomFactorsList',\n}\n\nclass AdvancedMagnifyTool extends AnnotationTool {\n  static toolName;\n  static Actions = AdvancedMagnifyToolActions;\n\n  magnifyViewportManager: AdvancedMagnifyViewportManager;\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        magnifyingGlass: {\n          radius: 125, // px\n          zoomFactor: 3,\n          zoomFactorList: [1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5],\n          autoPan: {\n            enabled: true,\n            padding: 10, // px\n          },\n        },\n        actions: {\n          showZoomFactorsList: {\n            method: 'showZoomFactorsList',\n            bindings: [\n              {\n                mouseButton: MouseBindings.Secondary,\n                modifierKey: KeyboardBindings.Shift,\n              },\n            ],\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.magnifyViewportManager = AdvancedMagnifyViewportManager.getInstance();\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): AdvancedMagnifyAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const { magnifyingGlass: config } = this.configuration;\n    const { radius, zoomFactor, autoPan } = config;\n\n    const canvasHandlePoints = this._getCanvasHandlePoints(\n      canvasPos,\n      radius\n    ) as [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotationUID = csUtils.uuidv4();\n    const magnifyViewportId = csUtils.uuidv4();\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: AdvancedMagnifyAnnotation = {\n      annotationUID,\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        sourceViewportId: viewport.id,\n        magnifyViewportId,\n        zoomFactor,\n        // this means that the last coordinate for the points\n        // is 0 and should not be used for calculations\n        isCanvasAnnotation: true,\n        handles: {\n          points: canvasHandlePoints,\n          activeHandleIndex: null,\n        },\n      },\n    };\n\n    this.magnifyViewportManager.createViewport(annotation, {\n      magnifyViewportId,\n      sourceEnabledElement: enabledElement,\n      position: canvasPos,\n      radius,\n      zoomFactor,\n      autoPan: {\n        enabled: autoPan.enabled,\n        padding: autoPan.padding,\n        callback: (data: AutoPanCallbackData) => {\n          const annotationPoints = annotation.data.handles.points;\n          const { canvas: canvasDelta } = data.delta;\n\n          for (let i = 0, len = annotationPoints.length; i < len; i++) {\n            const point = annotationPoints[i];\n            point[0] += canvasDelta[0];\n            point[1] += canvasDelta[1];\n            annotation.invalidated = true;\n          }\n        },\n      },\n    });\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    evt.preventDefault();\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  onSetToolDisabled = () => {\n    // reset\n    this.magnifyViewportManager.dispose();\n    // remove the annotations from the state for that toolGroup\n    const annotations = getAllAnnotations();\n    annotations.forEach((annotation) => {\n      if (annotation.metadata.toolName === this.getToolName()) {\n        removeAnnotation(annotation.annotationUID);\n      }\n    });\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  public isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: AdvancedMagnifyAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points;\n\n    const canvasTop = canvasCoordinates[0];\n    const canvasBottom = canvasCoordinates[2];\n    const canvasLeft = canvasCoordinates[3];\n    const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n    const center = [\n      canvasLeft[0] + radius,\n      canvasTop[1] + radius,\n    ] as Types.Point2;\n    const radiusPoint = getCanvasCircleRadius([center, canvasCoords]);\n\n    if (Math.abs(radiusPoint - radius) < proximity * 2) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: AdvancedMagnifyAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: AdvancedMagnifyAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    const { points } = data.handles;\n    const handleIndex = points.findIndex((p) => p === handle);\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element, deltaPoints } = eventDetail;\n    const canvasDelta = deltaPoints?.canvas ?? [0, 0, 0];\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { points } = annotation.data.handles;\n\n    points.forEach((point) => {\n      point[0] += canvasDelta[0];\n      point[1] += canvasDelta[1];\n    });\n\n    annotation.invalidated = true;\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const canvasDelta = deltaPoints.canvas;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += canvasDelta[0];\n        point[1] += canvasDelta[1];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n\n    const { annotation } = this.editData;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasCoordinates = points;\n    const canvasTop = canvasCoordinates[0];\n    const canvasBottom = canvasCoordinates[2];\n    const canvasLeft = canvasCoordinates[3];\n    const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n    const canvasCenter: Types.Point2 = [\n      canvasLeft[0] + radius,\n      canvasTop[1] + radius,\n    ];\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    const newRadius = getCanvasCircleRadius([\n      canvasCenter,\n      currentCanvasPoints,\n    ]);\n    const newCanvasHandlePoints = this._getCanvasHandlePoints(\n      canvasCenter,\n      newRadius\n    );\n\n    points[0] = newCanvasHandlePoints[0];\n    points[1] = newCanvasHandlePoints[1];\n    points[2] = newCanvasHandlePoints[2];\n    points[3] = newCanvasHandlePoints[3];\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    return annotation.annotationUID;\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = annotations?.filter(\n      (annotation) =>\n        (<AdvancedMagnifyAnnotation>annotation).data.sourceViewportId ===\n        viewport.id\n    );\n\n    const filteredAnnotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!filteredAnnotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < filteredAnnotations.length; i++) {\n      const annotation = filteredAnnotations[i] as AdvancedMagnifyAnnotation;\n      const { annotationUID, data } = annotation;\n      const { magnifyViewportId, zoomFactor, handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points;\n      const canvasTop = canvasCoordinates[0];\n      const canvasBottom = canvasCoordinates[2];\n      const canvasLeft = canvasCoordinates[3];\n      const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n      const center = [\n        canvasLeft[0] + radius,\n        canvasTop[1] + radius,\n      ] as Types.Point2;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-advancedMagnify`;\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        center,\n        radius,\n        {\n          color,\n          lineWidth: 5,\n        },\n        dataId\n      );\n\n      const magnifyViewport =\n        this.magnifyViewportManager.getViewport(magnifyViewportId);\n\n      magnifyViewport.position = center;\n      magnifyViewport.radius = radius;\n      magnifyViewport.zoomFactor = zoomFactor;\n      magnifyViewport.update();\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  // Basic dropdown component that allows the user to select a different zoom factor.\n  // configurations.actions may be changed to use a customized dropdown.\n  public showZoomFactorsList(\n    evt: EventTypes.InteractionEventType,\n    annotation: AdvancedMagnifyAnnotation\n  ) {\n    const { element, currentPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { canvas: canvasPoint } = currentPoints;\n    const viewportElement = element.querySelector(':scope .viewport-element');\n    const currentZoomFactor = annotation.data.zoomFactor;\n    const remove = () => dropdown.parentElement.removeChild(dropdown);\n\n    const dropdown = this._getZoomFactorsListDropdown(\n      currentZoomFactor,\n      (newZoomFactor) => {\n        if (newZoomFactor !== undefined) {\n          annotation.data.zoomFactor = Number.parseFloat(newZoomFactor);\n          annotation.invalidated = true;\n        }\n\n        remove();\n        viewport.render();\n      }\n    );\n\n    Object.assign(dropdown.style, {\n      left: `${canvasPoint[0]}px`,\n      top: `${canvasPoint[1]}px`,\n    });\n\n    viewportElement.appendChild(dropdown);\n    dropdown.focus();\n  }\n\n  private _getZoomFactorsListDropdown(currentZoomFactor, onChangeCallback) {\n    const { zoomFactorList } = this.configuration.magnifyingGlass;\n    const dropdown = document.createElement('select');\n\n    dropdown.size = 5;\n    Object.assign(dropdown.style, {\n      width: '50px',\n      position: 'absolute',\n    });\n\n    ['mousedown', 'mouseup', 'mousemove', 'click'].forEach((eventName) => {\n      dropdown.addEventListener(eventName, (evt) => evt.stopPropagation());\n    });\n\n    dropdown.addEventListener('change', (evt) => {\n      evt.stopPropagation();\n      onChangeCallback(dropdown.value);\n    });\n\n    dropdown.addEventListener('keydown', (evt) => {\n      const shouldCancel =\n        (evt.keyCode ?? evt.which === 27) ||\n        evt.key?.toLowerCase() === 'escape';\n\n      if (shouldCancel) {\n        evt.stopPropagation();\n        onChangeCallback();\n      }\n    });\n\n    zoomFactorList.forEach((zoomFactor) => {\n      const option = document.createElement('option');\n\n      option.label = zoomFactor;\n      option.title = `Zoom factor ${zoomFactor.toFixed(1)}`;\n      option.value = zoomFactor;\n      option.defaultSelected = zoomFactor === currentZoomFactor;\n\n      dropdown.add(option);\n    });\n\n    return dropdown;\n  }\n\n  private _getCanvasHandlePoints = (canvasCenterPos, canvasRadius) => {\n    return [\n      [canvasCenterPos[0], canvasCenterPos[1] - canvasRadius, 0], // top\n      [canvasCenterPos[0] + canvasRadius, canvasCenterPos[1], 0], // right\n      [canvasCenterPos[0], canvasCenterPos[1] + canvasRadius, 0], // bottom\n      [canvasCenterPos[0] - canvasRadius, canvasCenterPos[1], 0], // left\n    ];\n  };\n}\n\nAdvancedMagnifyTool.toolName = 'AdvancedMagnify';\n\nexport { AdvancedMagnifyTool as default };\n","import {\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  utilities,\n  getEnabledElementByIds,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { drawLine } from '../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  EventTypes,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  Annotation,\n  Annotations,\n} from '../types';\nimport { ReferenceCursor } from '../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { vec3 } from 'gl-matrix';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../cursors/elementCursor';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\n/**\n * ReferenceCursors is a tool that will show your cursors position in all other elements in the toolGroup if they have a matching FrameOfReference relative to its position in world space.\n * Also when positionSync is enabled, it will try to sync viewports so that the cursor can be displayed in the correct position in all viewports.\n *\n * Configuration:\n * - positionSync: boolean, if true, it will try to sync viewports so that the cursor can be displayed in the correct position in all viewports.\n * - disableCursor: boolean, if true, it will hide the cursor in all viewports. You need to disable and reactivate the tool for this to apply.\n * - displayThreshold: number, if the distance of the cursor in a viewport is bigger than this threshold the cursor will not be displayed.\n *\n * Only uses Active and Disabled state\n */\nclass ReferenceCursors extends AnnotationDisplayTool {\n  static toolName;\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  isDrawing = false;\n  isHandleOutsideImage = false;\n  _elementWithCursor: null | HTMLDivElement = null;\n  _currentCursorWorldPosition: null | Types.Point3 = null;\n  _currentCanvasPosition: null | Types.Point2 = null;\n  //need to keep track if this was enabled when tool was enabled because we need to know if we should reset cursors\n  _disableCursorEnabled = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        displayThreshold: 5,\n        positionSync: true,\n        disableCursor: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this._disableCursorEnabled = this.configuration.disableCursor;\n  }\n\n  /**\n   * Overwritten mouseMoveCallback since we want to keep track of the current mouse position and redraw on mouseMove\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\n   *\n   *\n   * @param evt - The normalized mouse event\n   * @param filteredAnnotations - The annotations to check for hover interactions\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\n   */\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const { detail } = evt;\n    const { element, currentPoints } = detail;\n\n    //save current positions and current element the curser is hovering over\n    this._currentCursorWorldPosition = currentPoints.world;\n    this._currentCanvasPosition = currentPoints.canvas;\n    this._elementWithCursor = element;\n\n    const annotation = this.getActiveAnnotation(element);\n    if (annotation === null) {\n      this.createInitialAnnotation(currentPoints.world, element);\n      return false;\n    }\n    this.updateAnnotationPosition(element, annotation);\n    return false;\n  };\n\n  onSetToolActive(): void {\n    this._disableCursorEnabled = this.configuration.disableCursor;\n    if (!this._disableCursorEnabled) {\n      return;\n    }\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n    if (!viewportIds) {\n      return;\n    }\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n\n    enabledElements.forEach((element) => {\n      if (element) {\n        hideElementCursor(element.viewport.element);\n      }\n    });\n  }\n  onSetToolDisabled(): void {\n    if (!this._disableCursorEnabled) {\n      return;\n    }\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n    if (!viewportIds) {\n      return;\n    }\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n    enabledElements.forEach((element) => {\n      if (element) {\n        resetElementCursor(element.viewport.element);\n      }\n    });\n  }\n\n  createInitialAnnotation = (\n    worldPos: Types.Point3,\n    element: HTMLDivElement\n  ): void => {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n      throw new Error('No enabled element found');\n    }\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    if (!viewPlaneNormal || !viewUp) {\n      throw new Error('Camera not found');\n    }\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          points: [[...worldPos]] as [Types.Point3],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n      },\n    };\n\n    const annotations = getAnnotations(this.getToolName(), element);\n\n    if (annotations.length > 0) {\n      return null;\n    }\n    const annotationId = addAnnotation(annotation, element);\n\n    if (annotationId === null) {\n      return;\n    }\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  getActiveAnnotation(element: HTMLDivElement): null | Annotation {\n    const annotations = getAnnotations(this.getToolName(), element);\n    if (!annotations.length) {\n      return null;\n    }\n    const targetAnnotation = annotations[0];\n    return targetAnnotation;\n  }\n\n  /**\n   * updates the position of the annotation to match the currently set world position\n   */\n  updateAnnotationPosition(\n    element: HTMLDivElement,\n    annotation: Annotation\n  ): void {\n    const worldPos = this._currentCursorWorldPosition;\n    if (!worldPos) {\n      return;\n    }\n    if (!annotation.data?.handles?.points) {\n      return;\n    }\n    annotation.data.handles.points = [[...worldPos]];\n    annotation.invalidated = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n      return;\n    }\n    const { renderingEngine } = enabledElement;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  }\n\n  //checks if we need to update the annotation position due to camera changes\n  onCameraModified = (evt: any): void => {\n    const eventDetail = evt.detail;\n    const { element, previousCamera, camera } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const viewport = enabledElement.viewport as\n      | Types.IVolumeViewport\n      | Types.IStackViewport;\n\n    //only react to changes for element with cursor, otherwise would cause infinite loop\n    if (element !== this._elementWithCursor) {\n      return;\n    }\n    //check if camera moved along its normal\n    const oldFocalPoint = previousCamera.focalPoint;\n    const cameraNormal = camera.viewPlaneNormal;\n    const newFocalPoint = camera.focalPoint;\n\n    const deltaCameraFocalPoint: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);\n    //check if focal point changed\n    if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0) {\n      return;\n    }\n    //if nomrmal is perpendicular to focal point change, then we are not moving along the normal\n    const dotProduct = vtkMath.dot(deltaCameraFocalPoint, cameraNormal);\n    //dot product is 0 -> perpendicular\n    if (Math.abs(dotProduct) < 1e-2) {\n      return;\n    }\n\n    //need to update the position of the annotation since camera changed\n    if (!this._currentCanvasPosition) {\n      return;\n    }\n\n    const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);\n    this._currentCursorWorldPosition = newWorldPos;\n    this.updateAnnotationPosition(element, this.getActiveAnnotation(element));\n  };\n\n  //display annotation if current viewing plane has a max distance of \"displayThreshold\" from the annotation\n  filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations {\n    //calculate distance of current viewport to annotation\n    if (!(annotations instanceof Array) || annotations.length === 0) {\n      return [];\n    }\n    const annotation = annotations[0];\n    const viewport = getEnabledElement(element)?.viewport;\n    if (!viewport) {\n      return [];\n    }\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, focalPoint } = camera;\n    if (!viewPlaneNormal || !focalPoint) {\n      return [];\n    }\n    const points = annotation.data?.handles?.points;\n    if (!(points instanceof Array) || points.length !== 1) {\n      return [];\n    }\n    const worldPos = points[0];\n    const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n    const distance = utilities.planar.planeDistanceToPoint(plane, worldPos);\n    return distance < this.configuration.displayThreshold ? [annotation] : [];\n  }\n\n  /**\n   * Draws the cursor representation on the enabledElement\n   * Checks if a stack change has happened and updates annotation in that case\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, FrameOfReferenceUID } = enabledElement;\n\n    const isElementWithCursor = this._elementWithCursor === viewport.element;\n\n    //update stack position if position sync is enabled\n    if (this.configuration.positionSync && !isElementWithCursor) {\n      this.updateViewportImage(viewport);\n    }\n\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    //the viewport change from updateStackPosition might not be applied yet, so sometimes the annotation might not be immediately visible\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    ) as Annotations;\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ReferenceCursor;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points } = handles;\n\n      if (!annotationUID) {\n        return renderStatus;\n      }\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidthBase = parseFloat(\n        this.getStyle('lineWidth', styleSpecifier, annotation) as string\n      );\n\n      const lineWidth =\n        typeof lineWidthBase === 'number' && isElementWithCursor\n          ? lineWidthBase\n          : lineWidthBase;\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      if (points[0].some((e) => isNaN(e))) {\n        return renderStatus;\n      }\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2];\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      const crosshairUIDs = {\n        upper: 'upper',\n        right: 'right',\n        lower: 'lower',\n        left: 'left',\n      };\n      const [x, y] = canvasCoordinates[0];\n      const centerSpace = isElementWithCursor ? 20 : 7;\n      const lineLength = isElementWithCursor ? 5 : 7;\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.upper,\n        [x, y - (centerSpace / 2 + lineLength)],\n        [x, y - centerSpace / 2],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.lower,\n        [x, y + (centerSpace / 2 + lineLength)],\n        [x, y + centerSpace / 2],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.right,\n        [x + (centerSpace / 2 + lineLength), y],\n        [x + centerSpace / 2, y],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.left,\n        [x - (centerSpace / 2 + lineLength), y],\n        [x - centerSpace / 2, y],\n        { color, lineDash, lineWidth }\n      );\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  updateViewportImage(\n    viewport: Types.IStackViewport | Types.IVolumeViewport\n  ): void {\n    const currentMousePosition = this._currentCursorWorldPosition;\n\n    if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e))) {\n      return;\n    }\n\n    if (viewport instanceof StackViewport) {\n      const closestIndex = utilities.getClosestStackImageIndexForPoint(\n        currentMousePosition,\n        viewport\n      );\n\n      if (closestIndex === null) {\n        return;\n      }\n      if (closestIndex !== viewport.getCurrentImageIdIndex()) {\n        viewport.setImageIdIndex(closestIndex);\n      }\n    } else if (viewport instanceof VolumeViewport) {\n      const { focalPoint, viewPlaneNormal } = viewport.getCamera();\n      if (!focalPoint || !viewPlaneNormal) {\n        return;\n      }\n      const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n      const currentDistance = utilities.planar.planeDistanceToPoint(\n        plane,\n        currentMousePosition,\n        true\n      );\n\n      if (Math.abs(currentDistance) < 0.5) {\n        return;\n      }\n      const normalizedViewPlane = vec3.normalize(\n        vec3.create(),\n        vec3.fromValues(...viewPlaneNormal)\n      );\n      const scaledPlaneNormal = vec3.scale(\n        vec3.create(),\n        normalizedViewPlane,\n        currentDistance\n      );\n      const newFocalPoint = vec3.add(\n        vec3.create(),\n        vec3.fromValues(...focalPoint),\n        scaledPlaneNormal\n      ) as Types.Point3;\n      //TODO: make check if new focal point is within bounds of volume\n      const isInBounds = true;\n      if (isInBounds) {\n        viewport.setCamera({ focalPoint: newFocalPoint });\n        const renderingEngine = viewport.getRenderingEngine();\n        if (renderingEngine) {\n          renderingEngine.renderViewport(viewport.id);\n        }\n      }\n    }\n  }\n}\n\nReferenceCursors.toolName = 'ReferenceCursors';\nexport default ReferenceCursors;\n","import AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { vec3 } from 'gl-matrix';\nimport {\n  getEnabledElementByIds,\n  getRenderingEngines,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { ScaleOverlayAnnotation } from '../types/ToolSpecificAnnotationTypes';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport {\n  drawLine as drawLineSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../drawingSvg';\nimport {\n  EventTypes,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../types';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\nconst SCALEOVERLAYTOOL_ID = 'scaleoverlay-viewport';\nconst viewportsWithAnnotations = [];\n\n/**\n * @public\n * @class ScaleOverlayTool\n * @memberof Tools\n *\n * @classdesc Tool for displaying a scale overlay on the image.\n * @extends Tools.Base.BaseTool\n */\nclass ScaleOverlayTool extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    renderingEngine: any;\n    viewport: any;\n    annotation: ScaleOverlayAnnotation;\n  } | null = {} as any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        viewportId: '',\n        scaleLocation: 'bottom',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  _init = (): void => {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    if (!renderingEngine) {\n      return;\n    }\n\n    // get viewports with tool enabled\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    if (!viewportIds) {\n      return;\n    }\n\n    // get enabled elements\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n\n    let { viewport } = enabledElements[0];\n    const { FrameOfReferenceUID } = enabledElements[0];\n\n    // onCameraModified, configuration.viewportId is set to the active\n    // viewport Id, here we are setting the viewport variable to the\n    // viewport with the matching Id\n    if (this.configuration.viewportId) {\n      enabledElements.forEach((element) => {\n        if (element.viewport.id == this.configuration.viewportId) {\n          viewport = element.viewport;\n        }\n      });\n    }\n\n    if (!viewport) {\n      return;\n    }\n\n    const { viewUp, viewPlaneNormal } = viewport.getCamera();\n\n    const viewportCanvasCornersInWorld =\n      csUtils.getViewportImageCornersInWorld(viewport);\n\n    let annotation = this.editData.annotation;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    // if annotations have been created, get the annotation for the\n    // current viewport Id\n    if (annotations.length) {\n      annotation = annotations.filter(\n        (thisAnnotation) => thisAnnotation.data.viewportId == viewport.id\n      )[0] as ScaleOverlayAnnotation;\n    }\n\n    // viewportsWithAnnotations stores which viewports have an annotation,\n    // if the viewport does not have an annotation, create a new one\n    if (!viewportsWithAnnotations.includes(viewport.id)) {\n      const newAnnotation: ScaleOverlayAnnotation = {\n        metadata: {\n          toolName: this.getToolName(),\n          viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n          viewUp: <Types.Point3>[...viewUp],\n          FrameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          handles: {\n            points: viewportCanvasCornersInWorld,\n          },\n          viewportId: viewport.id,\n        },\n      };\n\n      viewportsWithAnnotations.push(viewport.id);\n\n      addAnnotation(newAnnotation, viewport.element);\n      annotation = newAnnotation;\n    } else if (\n      this.editData.annotation &&\n      this.editData.annotation.data.viewportId == viewport.id\n    ) {\n      this.editData.annotation.data.handles.points =\n        viewportCanvasCornersInWorld;\n      this.editData.annotation.data.viewportId = viewport.id;\n    }\n\n    this.editData = {\n      viewport,\n      renderingEngine,\n      annotation,\n    };\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    // If the camera is modified, we need to update the viewport\n    // that the camera was modified on\n    this.configuration.viewportId = evt.detail.viewportId;\n    this._init();\n  };\n\n  /**\n   * Used to draw the scale annotation in each request animation\n   * frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   * @returns\n   */\n\n  renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ) {\n    if (!this.editData.viewport) {\n      return;\n    }\n    const location = this.configuration.scaleLocation;\n    const { viewport } = enabledElement;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n    const annotation = annotations.filter(\n      (thisAnnotation) => thisAnnotation.data.viewportId == viewport.id\n    )[0];\n    const canvas = enabledElement.viewport.canvas;\n\n    const renderStatus = false;\n\n    if (!viewport) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const canvasSize = {\n      width: canvas.width,\n      height: canvas.height,\n    };\n\n    const topLeft = annotation.data.handles.points[0];\n    const topRight = annotation.data.handles.points[1];\n    const bottomLeft = annotation.data.handles.points[2];\n    const bottomRight = annotation.data.handles.points[3];\n\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n\n    const worldWidthViewport = vec3.distance(bottomLeft, bottomRight);\n    const worldHeightViewport = vec3.distance(topLeft, bottomLeft);\n\n    // hscaleBounds and vscaleBounds compute the max bound for scales on the image\n    const hscaleBounds = this.computeScaleBounds(\n      canvasSize,\n      0.05,\n      0.05,\n      location\n    );\n\n    const vscaleBounds = this.computeScaleBounds(\n      canvasSize,\n      0.05,\n      0.05,\n      location\n    );\n\n    // Computes which scale size to use, ex: 100mm, 50mm\n    const scaleSize = this.computeScaleSize(\n      worldWidthViewport,\n      worldHeightViewport,\n      location\n    );\n\n    // Applies the scale with the predetermined size to the image in\n    // world coordinates, then converts them to canvas coordinates\n    const canvasCoordinates = this.computeWorldScaleCoordinates(\n      scaleSize,\n      location,\n      pointSet1\n    ).map((world) => viewport.worldToCanvas(world));\n\n    // Uses the bounds and canvas size to center the scale\n    // based on the location\n    const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(\n      canvasSize,\n      canvasCoordinates,\n      vscaleBounds,\n      hscaleBounds,\n      location\n    );\n\n    // Computes the end scale ticks coordinates\n    const scaleTicks = this.computeEndScaleTicks(\n      scaleCanvasCoordinates,\n      location\n    );\n\n    const { annotationUID } = annotation;\n\n    styleSpecifier.annotationUID = annotationUID;\n    const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n    const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n    const color = this.getStyle('color', styleSpecifier, annotation);\n    const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n    const scaleId = `${annotationUID}-scaleline`;\n    const scaleLineUID = '1';\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      scaleLineUID,\n      scaleCanvasCoordinates[0],\n      scaleCanvasCoordinates[1],\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      scaleId\n    );\n    const leftTickId = `${annotationUID}-left`;\n    const leftTickUID = '2';\n\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      leftTickUID,\n      scaleTicks.endTick1[0] as Types.Point2,\n      scaleTicks.endTick1[1] as Types.Point2,\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      leftTickId\n    );\n    const rightTickId = `${annotationUID}-right`;\n    const rightTickUID = '3';\n\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      rightTickUID,\n      scaleTicks.endTick2[0] as Types.Point2,\n      scaleTicks.endTick2[1] as Types.Point2,\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      rightTickId\n    );\n\n    const locationTextOffest = {\n      bottom: [-10, -42],\n      top: [-12, -35],\n      left: [-40, -20],\n      right: [-50, -20],\n    };\n\n    const textCanvasCoordinates = [\n      scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],\n      scaleCanvasCoordinates[0][1] + locationTextOffest[location][1],\n    ];\n    const textBoxLines = this._getTextLines(scaleSize);\n\n    const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(\n      scaleSize,\n      location,\n      annotationUID,\n      scaleTicks.endTick1,\n      scaleTicks.endTick2\n    );\n\n    // draws inner ticks for scale\n    for (let i = 0; i < tickUIDs.length; i++) {\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        tickUIDs[i],\n        tickCoordinates[i][0],\n        tickCoordinates[i][1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        tickIds[i]\n      );\n    }\n\n    const textUID = 'text0';\n    drawTextBoxSvg(\n      svgDrawingHelper,\n      annotationUID,\n      textUID,\n      textBoxLines,\n      [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n      {\n        fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n        fontSize: '14px',\n        lineDash: '2,3',\n        lineWidth: '1',\n        shadow: true,\n        color: color,\n      }\n    );\n\n    return renderStatus;\n  }\n\n  _getTextLines(scaleSize: number): string[] | undefined {\n    let scaleSizeDisplayValue;\n    let scaleSizeUnits;\n    if (scaleSize >= 50) {\n      scaleSizeDisplayValue = scaleSize / 10; //convert to cm\n      scaleSizeUnits = ' cm';\n    } else {\n      scaleSizeDisplayValue = scaleSize; //convert to cm\n      scaleSizeUnits = ' mm';\n    }\n\n    const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];\n\n    return textLines;\n  }\n\n  /**\n   *\n   * @param worldWidthViewport\n   * @returns currentScaleSize\n   */\n  computeScaleSize = (\n    worldWidthViewport: number,\n    worldHeightViewport: number,\n    location: any\n  ) => {\n    const scaleSizes = [\n      16000, 8000, 4000, 2000, 1000, 500, 250, 100, 50, 25, 10, 5, 2,\n    ];\n    let currentScaleSize;\n    if (location == 'top' || location == 'bottom') {\n      currentScaleSize = scaleSizes.filter(\n        (scaleSize) =>\n          scaleSize < worldWidthViewport * 0.6 &&\n          scaleSize > worldWidthViewport * 0.2\n      );\n    } else {\n      currentScaleSize = scaleSizes.filter(\n        (scaleSize) =>\n          scaleSize < worldHeightViewport * 0.6 &&\n          scaleSize > worldHeightViewport * 0.2\n      );\n    }\n\n    return currentScaleSize[0];\n  };\n\n  /**\n   *  calculates scale ticks for ends of the scale\n   * @param canvasCoordinates\n   * @returns leftTick, rightTick\n   */\n  computeEndScaleTicks = (canvasCoordinates, location) => {\n    const locationTickOffset = {\n      bottom: [\n        [0, -10],\n        [0, -10],\n      ],\n      top: [\n        [0, 10],\n        [0, 10],\n      ],\n      left: [\n        [0, 0],\n        [10, 0],\n      ],\n      right: [\n        [0, 0],\n        [-10, 0],\n      ],\n    };\n\n    const endTick1 = [\n      [\n        canvasCoordinates[1][0] + locationTickOffset[location][0][0],\n        canvasCoordinates[1][1] + locationTickOffset[location][0][0],\n      ],\n      [\n        canvasCoordinates[1][0] + locationTickOffset[location][1][0],\n        canvasCoordinates[1][1] + locationTickOffset[location][1][1],\n      ],\n    ];\n    const endTick2 = [\n      [\n        canvasCoordinates[0][0] + locationTickOffset[location][0][0],\n        canvasCoordinates[0][1] + locationTickOffset[location][0][0],\n      ],\n      [\n        canvasCoordinates[0][0] + locationTickOffset[location][1][0],\n        canvasCoordinates[0][1] + locationTickOffset[location][1][1],\n      ],\n    ];\n\n    return {\n      endTick1: endTick1,\n      endTick2: endTick2,\n    };\n  };\n\n  computeInnerScaleTicks = (\n    scaleSize: number,\n    location: string,\n    annotationUID: string,\n    leftTick: any[][],\n    rightTick: any[][]\n  ) => {\n    let canvasScaleSize;\n    if (location == 'bottom' || location == 'top') {\n      canvasScaleSize = rightTick[0][0] - leftTick[0][0];\n    } else if (location == 'left' || location == 'right') {\n      canvasScaleSize = rightTick[0][1] - leftTick[0][1];\n    }\n    const tickIds = [];\n    const tickUIDs = [];\n    const tickCoordinates = [];\n    let numberSmallTicks = scaleSize;\n\n    if (scaleSize >= 50) {\n      numberSmallTicks = scaleSize / 10;\n    }\n\n    const tickSpacing = canvasScaleSize / numberSmallTicks;\n\n    for (let i = 0; i < numberSmallTicks - 1; i++) {\n      const locationOffset = {\n        bottom: [\n          [tickSpacing * (i + 1), 0],\n          [tickSpacing * (i + 1), 5],\n        ],\n        top: [\n          [tickSpacing * (i + 1), 0],\n          [tickSpacing * (i + 1), -5],\n        ],\n        left: [\n          [0, tickSpacing * (i + 1)],\n          [-5, tickSpacing * (i + 1)],\n        ],\n        right: [\n          [0, tickSpacing * (i + 1)],\n          [5, tickSpacing * (i + 1)],\n        ],\n      };\n      tickIds.push(`${annotationUID}-tick${i}`);\n      tickUIDs.push(`tick${i}`);\n      if ((i + 1) % 5 == 0) {\n        tickCoordinates.push([\n          [\n            leftTick[0][0] + locationOffset[location][0][0],\n            leftTick[0][1] + locationOffset[location][0][1],\n          ],\n          [\n            leftTick[1][0] + locationOffset[location][0][0],\n            leftTick[1][1] + locationOffset[location][0][1],\n          ],\n        ]);\n      } else {\n        tickCoordinates.push([\n          [\n            leftTick[0][0] + locationOffset[location][0][0],\n            leftTick[0][1] + locationOffset[location][0][1],\n          ],\n          [\n            leftTick[1][0] + locationOffset[location][1][0],\n            leftTick[1][1] + locationOffset[location][1][1],\n          ],\n        ]);\n      }\n    }\n\n    return { tickIds, tickUIDs, tickCoordinates };\n  };\n\n  computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {\n    let worldCoordinates;\n    let topBottomVec = vec3.subtract(vec3.create(), pointSet[0], pointSet[1]);\n    topBottomVec = vec3.normalize(vec3.create(), topBottomVec) as Types.Point3;\n\n    let topRightVec = vec3.subtract(vec3.create(), pointSet[2], pointSet[0]);\n    topRightVec = vec3.normalize(vec3.create(), topRightVec);\n\n    const midpointLocation = {\n      bottom: [pointSet[1], pointSet[2]],\n      top: [pointSet[0], pointSet[3]],\n      right: [pointSet[2], pointSet[3]],\n      left: [pointSet[0], pointSet[1]],\n    };\n\n    const midpoint = vec3\n      .add(\n        vec3.create(),\n        midpointLocation[location][0],\n        midpointLocation[location][0]\n      )\n      .map((i) => i / 2) as Types.Point3;\n\n    const offset =\n      scaleSize /\n      2 /\n      Math.sqrt(\n        Math.pow(topBottomVec[0], 2) +\n          Math.pow(topBottomVec[1], 2) +\n          Math.pow(topBottomVec[2], 2)\n      );\n\n    if (location == 'top' || location == 'bottom') {\n      worldCoordinates = [\n        vec3.subtract(\n          vec3.create(),\n          midpoint,\n          topRightVec.map((i) => i * offset) as Types.Point3\n        ),\n        vec3.add(\n          vec3.create(),\n          midpoint,\n          topRightVec.map((i) => i * offset) as Types.Point3\n        ),\n      ];\n    } else if (location == 'left' || location == 'right') {\n      worldCoordinates = [\n        vec3.add(\n          vec3.create(),\n          midpoint,\n          topBottomVec.map((i) => i * offset) as Types.Point3\n        ),\n        vec3.subtract(\n          vec3.create(),\n          midpoint,\n          topBottomVec.map((i) => i * offset) as Types.Point3\n        ),\n      ];\n    }\n\n    return worldCoordinates;\n  };\n\n  /**\n   * Computes the centered canvas coordinates for scale\n   * @param canvasSize\n   * @param canvasCoordinates\n   * @param vscaleBounds\n   * @returns scaleCanvasCoordinates\n   */\n  computeCanvasScaleCoordinates = (\n    canvasSize,\n    canvasCoordinates,\n    vscaleBounds,\n    hscaleBounds,\n    location\n  ) => {\n    let scaleCanvasCoordinates;\n    if (location == 'top' || location == 'bottom') {\n      const worldDistanceOnCanvas =\n        canvasCoordinates[0][0] - canvasCoordinates[1][0];\n      scaleCanvasCoordinates = [\n        [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],\n        [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height],\n      ];\n    } else if (location == 'left' || location == 'right') {\n      const worldDistanceOnCanvas =\n        canvasCoordinates[0][1] - canvasCoordinates[1][1];\n      scaleCanvasCoordinates = [\n        [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],\n        [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2],\n      ];\n    }\n\n    return scaleCanvasCoordinates;\n  };\n\n  /**\n   * Computes the max bound for scales on the image\n   * @param  {{width: number, height: number}} canvasSize\n   * @param  {number} horizontalReduction\n   * @param  {number} verticalReduction\n   * @returns {Object.<string, { x:number, y:number }>}\n   */\n  computeScaleBounds = (\n    canvasSize,\n    horizontalReduction,\n    verticalReduction,\n    location\n  ) => {\n    const hReduction = horizontalReduction * Math.min(1000, canvasSize.width);\n    const vReduction = verticalReduction * Math.min(1000, canvasSize.height);\n    const locationBounds = {\n      bottom: [-vReduction, -hReduction],\n      top: [vReduction, hReduction],\n      left: [vReduction, hReduction],\n      right: [-vReduction, -hReduction],\n    };\n    const canvasBounds = {\n      bottom: [canvasSize.height, canvasSize.width],\n      top: [0, canvasSize.width],\n      left: [canvasSize.height, 0],\n      right: [canvasSize.height, canvasSize.width],\n    };\n\n    return {\n      height: canvasBounds[location][0] + locationBounds[location][0],\n      width: canvasBounds[location][1] + locationBounds[location][1],\n    };\n  };\n}\n\nScaleOverlayTool.toolName = 'ScaleOverlay';\nexport default ScaleOverlayTool;\n","import { BaseTool } from './base';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\nimport { ToolGroupManager } from '../store';\nimport {\n  getAnnotations,\n  removeAnnotation,\n} from '../stateManagement/annotation/annotationState';\nimport { setAnnotationSelected } from '../stateManagement/annotation/annotationSelection';\n\nclass AnnotationEraserTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    return this._deleteNearbyAnnotations(evt, 'mouse');\n  };\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    return this._deleteNearbyAnnotations(evt, 'touch');\n  };\n\n  _deleteNearbyAnnotations(\n    evt: EventTypes.InteractionEventType,\n    interactionType: string\n  ): boolean {\n    const { renderingEngineId, viewportId, element, currentPoints } =\n      evt.detail;\n\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n      viewportId,\n      renderingEngineId\n    );\n\n    if (!toolGroup) {\n      return false;\n    }\n\n    const tools = toolGroup._toolInstances;\n    const annotationsToRemove = [];\n\n    for (const toolName in tools) {\n      const toolInstance = tools[toolName];\n\n      if (\n        typeof toolInstance.isPointNearTool !== 'function' ||\n        typeof toolInstance.filterInteractableAnnotationsForElement !==\n          'function'\n      ) {\n        continue;\n      }\n\n      const annotations = getAnnotations(toolName, element);\n\n      if (!annotations) {\n        continue;\n      }\n\n      const interactableAnnotations =\n        toolInstance.filterInteractableAnnotationsForElement(\n          element,\n          annotations\n        );\n\n      for (const annotation of interactableAnnotations) {\n        if (\n          toolInstance.isPointNearTool(\n            element,\n            annotation,\n            currentPoints.canvas,\n            10,\n            interactionType\n          )\n        ) {\n          annotationsToRemove.push(annotation.annotationUID);\n        }\n      }\n    }\n\n    for (const annotationUID of annotationsToRemove) {\n      setAnnotationSelected(annotationUID);\n      removeAnnotation(annotationUID);\n    }\n\n    evt.preventDefault();\n\n    return true;\n  }\n}\n\nAnnotationEraserTool.toolName = 'Eraser';\nexport default AnnotationEraserTool;\n","import { utilities as csUtils, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getBoundingBoxAroundShapeIJK,\n  getBoundingBoxAroundShapeWorld,\n} from '../../../utilities/boundingBox';\nimport { pointInShapeCallback } from '../../../utilities';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { LabelmapToolOperationData } from '../../../types';\nimport { getStrategyData } from './utils/getStrategyData';\nimport { isAxisAlignedRectangle } from '../../../utilities/rectangleROITool/isAxisAlignedRectangle';\n\nconst { transformWorldToIndex } = csUtils;\n\ntype OperationData = LabelmapToolOperationData & {\n  points: [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n};\n\n/**\n * For each point in the bounding box around the rectangle, if the point is inside\n * the rectangle, set the scalar value to the segmentIndex\n * @param toolGroupId - string\n * @param operationData - OperationData\n * @param inside - boolean\n */\n// Todo: why we have another constraintFn? in addition to the one in the operationData?\nfunction fillRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData,\n  inside = true\n): void {\n  const { points, segmentsLocked, segmentIndex, segmentationId } =\n    operationData;\n\n  const { viewport } = enabledElement;\n  const strategyData = getStrategyData({\n    operationData,\n    viewport: enabledElement.viewport,\n  });\n\n  if (!strategyData) {\n    console.warn('No data found for fillRectangle');\n    return;\n  }\n\n  const { segmentationImageData, segmentationScalarData } = strategyData;\n\n  let rectangleCornersIJK = points.map((world) => {\n    return transformWorldToIndex(segmentationImageData, world);\n  });\n\n  // math round\n  rectangleCornersIJK = rectangleCornersIJK.map((point) => {\n    return point.map((coord) => {\n      return Math.round(coord);\n    });\n  });\n\n  const boundsIJK = getBoundingBoxAroundShapeIJK(\n    rectangleCornersIJK,\n    segmentationImageData.getDimensions()\n  );\n\n  const isStackViewport = viewport instanceof StackViewport;\n\n  // Are we working with 2D rectangle in axis aligned viewport view or not\n  const isAligned =\n    isStackViewport || isAxisAlignedRectangle(rectangleCornersIJK);\n\n  const direction = segmentationImageData.getDirection();\n  const spacing = segmentationImageData.getSpacing();\n  const { viewPlaneNormal } = viewport.getCamera();\n\n  // In case that we are working on oblique, our EPS is really the spacing in the\n  // normal direction, since we can't really test each voxel against a 2D rectangle\n  // we need some tolerance in the normal direction.\n  const EPS = csUtils.getSpacingInNormalDirection(\n    {\n      direction,\n      spacing,\n    },\n    viewPlaneNormal\n  );\n\n  const pointsBoundsLPS = getBoundingBoxAroundShapeWorld(points);\n  let [[xMin, xMax], [yMin, yMax], [zMin, zMax]] = pointsBoundsLPS;\n\n  // Update the bounds with +/- EPS\n  xMin -= EPS;\n  xMax += EPS;\n  yMin -= EPS;\n  yMax += EPS;\n  zMin -= EPS;\n  zMax += EPS;\n\n  const pointInShapeFn = isAligned\n    ? () => true\n    : (pointLPS) => {\n        const [x, y, z] = pointLPS;\n        const xInside = x >= xMin && x <= xMax;\n        const yInside = y >= yMin && y <= yMax;\n        const zInside = z >= zMin && z <= zMax;\n\n        return xInside && yInside && zInside;\n      };\n\n  const callback = ({ value, index }) => {\n    if (segmentsLocked.includes(value)) {\n      return;\n    }\n\n    segmentationScalarData[index] = segmentIndex;\n  };\n\n  pointInShapeCallback(\n    segmentationImageData,\n    pointInShapeFn,\n    callback,\n    boundsIJK\n  );\n\n  triggerSegmentationDataModified(segmentationId);\n}\n\n/**\n * Fill the inside of a rectangle\n * @param toolGroupId - The unique identifier of the tool group.\n * @param operationData - The data that will be used to create the\n * new rectangle.\n */\nexport function fillInsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  fillRectangle(enabledElement, operationData, true);\n}\n\n/**\n * Fill the area outside of a rectangle for the toolGroupId and segmentationRepresentationUID.\n * @param toolGroupId - The unique identifier of the tool group.\n * @param operationData - The data that will be used to create the\n * new rectangle.\n */\nexport function fillOutsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  fillRectangle(enabledElement, operationData, false);\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport { LabelmapToolOperationData } from '../../../types';\nimport { fillInsideRectangle } from './fillRectangle';\n\ntype OperationData = LabelmapToolOperationData & {\n  points: [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n};\n\nfunction eraseRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData,\n  inside = true\n): void {\n  // Take the arguments and set the segmentIndex to 0,\n  // Then use existing fillRectangle functionality.\n  const eraseOperationData = Object.assign({}, operationData, {\n    segmentIndex: 0,\n  });\n\n  fillInsideRectangle(enabledElement, eraseOperationData);\n}\n\n/**\n * Erase the rectangle region segment inside the segmentation defined by the operationData.\n * It erases the segmentation pixels inside the defined rectangle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - OperationData\n */\nexport function eraseInsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  eraseRectangle(enabledElement, operationData, true);\n}\n\n/**\n * Erase the rectangle region segment inside the segmentation defined by the operationData.\n * It erases the segmentation pixels outside the defined rectangle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - OperationData\n */\nexport function eraseOutsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  eraseRectangle(enabledElement, operationData, false);\n}\n","import { cache, getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { fillInsideRectangle } from './strategies/fillRectangle';\nimport { eraseInsideRectangle } from './strategies/eraseRectangle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\n\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawRect as drawRectSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { LabelmapSegmentationData } from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\n/**\n * Tool for manipulating segmentation data by drawing a rectangle. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex.\n */\nclass RectangleScissorsTool extends BaseTool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    //\n    imageIdReferenceMap: Map<string, string>;\n    volumeId: string;\n    referencedVolumeId: string;\n    //\n    annotation: any;\n    segmentationId: string;\n    segmentIndex: number;\n    segmentsLocked: number[];\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideRectangle,\n          ERASE_INSIDE: eraseInsideRectangle,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    // if we are already drawing, means we have started with a click, and now we\n    // are moving the mouse (not dragging) so the final click should not\n    // be handled by this preMouseDownCallback but rather the endCallback\n    if (this.isDrawing === true) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId, type } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const { representationData } = getSegmentation(segmentationId);\n    const labelmapData = representationData[\n      SegmentationRepresentations.Labelmap\n    ] as LabelmapSegmentationData;\n\n    // Todo: Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n      },\n    };\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n    this.editData = {\n      annotation,\n      segmentIndex,\n      segmentationId,\n      segmentsLocked,\n      segmentColor,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n      segmentationRepresentationUID,\n    } as any;\n\n    if (\n      isVolumeSegmentation(labelmapData as LabelmapSegmentationData, viewport)\n    ) {\n      const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n      const segmentation = cache.getVolume(volumeId);\n\n      this.editData = {\n        ...this.editData,\n        volumeId,\n        referencedVolumeId: segmentation.referencedVolumeId,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      this.editData = {\n        ...this.editData,\n        imageIdReferenceMap,\n      };\n    }\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    // Moving handle.\n    const { currentPoints } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n    const worldPos = currentPoints.world;\n\n    const { points } = data.handles;\n\n    // Move this handle.\n    points[handleIndex] = [...worldPos];\n\n    let bottomLeftCanvas;\n    let bottomRightCanvas;\n    let topLeftCanvas;\n    let topRightCanvas;\n\n    let bottomLeftWorld;\n    let bottomRightWorld;\n    let topLeftWorld;\n    let topRightWorld;\n\n    switch (handleIndex) {\n      case 0:\n      case 3:\n        // Moving bottomLeft or topRight\n\n        bottomLeftCanvas = worldToCanvas(points[0]);\n        topRightCanvas = worldToCanvas(points[3]);\n\n        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n        topLeftWorld = canvasToWorld(topLeftCanvas);\n\n        points[1] = bottomRightWorld;\n        points[2] = topLeftWorld;\n\n        break;\n      case 1:\n      case 2:\n        // Moving bottomRight or topLeft\n        bottomRightCanvas = worldToCanvas(points[1]);\n        topLeftCanvas = worldToCanvas(points[2]);\n\n        bottomLeftCanvas = <Types.Point2>[\n          topLeftCanvas[0],\n          bottomRightCanvas[1],\n        ];\n        topRightCanvas = <Types.Point2>[bottomRightCanvas[0], topLeftCanvas[1]];\n\n        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n        topRightWorld = canvasToWorld(topRightCanvas);\n\n        points[0] = bottomLeftWorld;\n        points[3] = topRightWorld;\n\n        break;\n    }\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, newAnnotation, hasMoved } = this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    const operationData = {\n      ...this.editData,\n      points: data.handles.points,\n    };\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n  };\n\n  /**\n   * it is used to draw the rectangleScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const rectangleUID = '0';\n    drawRectSvg(\n      svgDrawingHelper,\n      annotationUID,\n      rectangleUID,\n      canvasCoordinates[0],\n      canvasCoordinates[3],\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n}\n\nRectangleScissorsTool.toolName = 'RectangleScissor';\nexport default RectangleScissorsTool;\n","import { cache, getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\n\nimport { fillInsideCircle } from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { Events } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  segmentLocking,\n  activeSegmentation,\n  segmentIndex as segmentIndexController,\n  config as segmentationConfig,\n} from '../../stateManagement/segmentation';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\n/**\n * Tool for manipulating segmentation data by drawing a circle. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex.\n */\nclass CircleScissorsTool extends BaseTool {\n  static toolName;\n  editData: {\n    annotation: any;\n    segmentIndex: number;\n    //\n    volumeId: string;\n    referencedVolumeId: string;\n    imageIdReferenceMap: Map<string, string>;\n    //\n    segmentsLocked: number[];\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    centerCanvas?: Array<number>;\n    segmentationRepresentationUID?: string;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideCircle,\n          ERASE_INSIDE: eraseInsideCircle,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    // if we are already drawing, means we have started with a click, and now we\n    // are moving the mouse (not dragging) so the final click should not\n    // be handled by this preMouseDownCallback but rather the endCallback\n    if (this.isDrawing === true) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId, type } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const { representationData } = getSegmentation(segmentationId);\n\n    // Todo: are we going to support contour editing with rectangle scissors?\n    const labelmapData = representationData[type];\n\n    if (!labelmapData) {\n      throw new Error(\n        'No labelmap data found for the active segmentation, create one before using scissors tool'\n      );\n    }\n\n    // Todo: Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        handles: {\n          points: [[...worldPos], [...worldPos], [...worldPos], [...worldPos]],\n          activeHandleIndex: null,\n        },\n        isDrawing: true,\n        cachedStats: {},\n      },\n    };\n\n    const viewportIdsToRender = [viewport.id];\n\n    this.editData = {\n      annotation,\n      centerCanvas: canvasPos,\n      segmentIndex,\n      segmentationId,\n      segmentsLocked,\n      segmentColor,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n      segmentationRepresentationUID,\n    } as any;\n\n    if (\n      isVolumeSegmentation(labelmapData as LabelmapSegmentationData, viewport)\n    ) {\n      const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n      const segmentation = cache.getVolume(volumeId);\n\n      this.editData = {\n        ...this.editData,\n        volumeId,\n        referencedVolumeId: segmentation.referencedVolumeId,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      this.editData = {\n        ...this.editData,\n        imageIdReferenceMap,\n      };\n    }\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n    const { data } = annotation;\n\n    // Center of circle in canvas Coordinates\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n    const radius = Math.sqrt(dX * dX + dY * dY);\n\n    const bottomCanvas: Types.Point2 = [\n      centerCanvas[0],\n      centerCanvas[1] + radius,\n    ];\n    const topCanvas: Types.Point2 = [centerCanvas[0], centerCanvas[1] - radius];\n    const leftCanvas: Types.Point2 = [\n      centerCanvas[0] - radius,\n      centerCanvas[1],\n    ];\n    const rightCanvas: Types.Point2 = [\n      centerCanvas[0] + radius,\n      centerCanvas[1],\n    ];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, newAnnotation, hasMoved } = this.editData;\n    const { data } = annotation;\n    const { viewPlaneNormal, viewUp } = annotation.metadata;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    const operationData = {\n      ...this.editData,\n      points: data.handles.points,\n      viewPlaneNormal,\n      viewUp,\n      strategySpecificConfiguration: {},\n    };\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender } = this.editData;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return renderStatus;\n    }\n\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n    return renderStatus;\n  };\n}\n\nCircleScissorsTool.toolName = 'CircleScissor';\nexport default CircleScissorsTool;\n","import { cache, getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\n\nimport { fillInsideSphere } from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataVolume,\n  LabelmapSegmentationDataStack,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n/**\n * Tool for manipulating segmentation data by drawing a sphere in 3d space. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex. Todo: sphere scissor has some memory problem which\n * lead to ui blocking behavior that needs to be fixed.\n */\nclass SphereScissorsTool extends BaseTool {\n  static toolName;\n  editData: {\n    annotation: any;\n    segmentIndex: number;\n    segmentsLocked: number[];\n    segmentationRepresentationUID: string;\n    //\n    volumeId: string;\n    referencedVolumeId: string;\n    imageIdReferenceMap: Map<string, string>;\n    //\n    toolGroupId: string;\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    centerCanvas?: Array<number>;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideSphere,\n          ERASE_INSIDE: eraseInsideSphere,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): true => {\n    // if we are already drawing, means we have started with a click, and now we\n    // are moving the mouse (not dragging) so the final click should not\n    // be handled by this preMouseDownCallback but rather the endCallback\n    if (this.isDrawing === true) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    this.isDrawing = true;\n\n    // Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        invalidated: true,\n        handles: {\n          points: [[...worldPos], [...worldPos], [...worldPos], [...worldPos]],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        highlighted: true,\n      },\n    };\n\n    const viewportIdsToRender = [viewport.id];\n\n    this.editData = {\n      annotation,\n      centerCanvas: canvasPos,\n      segmentationRepresentationUID,\n      segmentIndex,\n      segmentationId,\n      segmentsLocked,\n      segmentColor,\n      toolGroupId,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    } as any;\n\n    const { representationData } = getSegmentation(segmentationId);\n    const labelmapData =\n      representationData[SegmentationRepresentations.Labelmap];\n\n    if (\n      isVolumeSegmentation(labelmapData as LabelmapSegmentationData, viewport)\n    ) {\n      const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n      const segmentation = cache.getVolume(volumeId);\n\n      this.editData = {\n        ...this.editData,\n        volumeId,\n        referencedVolumeId: segmentation.referencedVolumeId,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      this.editData = {\n        ...this.editData,\n        imageIdReferenceMap,\n      };\n    }\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n    const { data } = annotation;\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n    const radius = Math.sqrt(dX * dX + dY * dY);\n\n    const bottomCanvas: Types.Point2 = [\n      centerCanvas[0],\n      centerCanvas[1] + radius,\n    ];\n    const topCanvas: Types.Point2 = [centerCanvas[0], centerCanvas[1] - radius];\n    const leftCanvas: Types.Point2 = [\n      centerCanvas[0] - radius,\n      centerCanvas[1],\n    ];\n    const rightCanvas: Types.Point2 = [\n      centerCanvas[0] + radius,\n      centerCanvas[1],\n    ];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      newAnnotation,\n      hasMoved,\n      segmentIndex,\n      segmentationRepresentationUID,\n      segmentsLocked,\n    } = this.editData;\n    const { data } = annotation;\n    const { viewPlaneNormal, viewUp } = annotation.metadata;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    const operationData = {\n      ...this.editData,\n      points: data.handles.points,\n      segmentIndex,\n      segmentationRepresentationUID,\n      segmentsLocked,\n      viewPlaneNormal,\n      viewUp,\n    };\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the sphereScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender } = this.editData;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return renderStatus;\n    }\n\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n}\n\nSphereScissorsTool.toolName = 'SphereScissor';\nexport default SphereScissorsTool;\n","import {\n  StackViewport,\n  Types,\n  cache,\n  getEnabledElement,\n  utilities as csUtils,\n  metaData,\n  triggerEvent,\n  eventTarget,\n} from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\nimport { Events } from '../../enums';\nimport {\n  addAnnotation,\n  removeAnnotation,\n  getAnnotations,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport throttle from '../../utilities/throttle';\nimport { AnnotationModifiedEventDetail } from '../../types/EventTypes';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted } from '../../stateManagement/annotation/helpers/state';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { CircleROIStartEndThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport CircleROITool from '../annotation/CircleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport {\n  getCanvasCircleCorners,\n  getCanvasCircleRadius,\n} from '../../utilities/math/circle';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { pointInShapeCallback } from '../../utilities';\n\nconst { transformWorldToIndex } = csUtils;\n\nclass CircleROIStartEndThresholdTool extends CircleROITool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        numSlicesToPropagate: 10,\n        calculatePointsInsideVolume: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStatsTool,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    let referencedImageId, imageVolume, volumeId;\n    if (viewport instanceof StackViewport) {\n      throw new Error('Stack Viewport Not implemented');\n    } else {\n      const targetId = this.getTargetId(viewport);\n      volumeId = csUtils.getVolumeId(targetId);\n      imageVolume = cache.getVolume(volumeId);\n\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    // if (!referencedImageId) {\n    //   throw new Error('This tool does not work on non-acquisition planes');\n    // }\n\n    const spacingInNormal = csUtils.getSpacingInNormalDirection(\n      imageVolume,\n      viewPlaneNormal\n    );\n\n    const newStartIndex = this._getStartSliceIndex(\n      imageVolume,\n      worldPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    // We cannot newStartIndex add numSlicesToPropagate to startIndex because\n    // the order of imageIds can be from top to bottom or bottom to top and\n    // we want to make sure it is always propagated in the direction of the\n    // view and also to make sure we don't go out of bounds.\n    const endIndex = this._getEndSliceIndex(\n      imageVolume,\n      worldPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        volumeId,\n        spacingInNormal,\n        enabledElement,\n      },\n      data: {\n        label: '',\n        startSlice: newStartIndex,\n        endSlice: endIndex,\n\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [[...worldPos], [...worldPos]] as [\n            Types.Point3, // center\n            Types.Point3 // end\n          ],\n          activeHandleIndex: null,\n        },\n        cachedStats: {\n          pointsInVolume: [],\n          projectionPoints: [],\n        },\n        labelmapUID: null,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n\n    this._activateDraw(element);\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    // Circle ROI tool should reset its highlight to false on mouse up (as opposed\n    // to other tools that keep it highlighted until the user moves. The reason\n    // is that we use top-left and bottom-right handles to define the circle,\n    // and they are by definition not in the circle on mouse up.\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    const targetId = this.getTargetId(enabledElement.viewport);\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n\n    if (this.configuration.calculatePointsInsideVolume) {\n      this._computePointsInsideVolume(annotation, imageVolume, enabledElement);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      enabledElement.renderingEngine,\n      viewportIdsToRender\n    );\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  /**\n   * it is used to draw the circleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const sliceIndex = viewport.getCurrentImageIdIndex();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as CircleROIStartEndThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { startSlice, endSlice } = data;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2, Types.Point2];\n      const center = canvasCoordinates[0];\n\n      const radius = getCanvasCircleRadius(canvasCoordinates);\n      const { centerPointRadius } = this.configuration;\n\n      // range of slices to render based on the start and end slice, like\n      // np.arange\n\n      // if indexIJK is outside the start/end slice, we don't render\n      if (\n        sliceIndex < Math.min(startSlice, endSlice) ||\n        sliceIndex > Math.max(startSlice, endSlice)\n      ) {\n        continue;\n      }\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n\n      if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(annotation, enabledElement);\n      }\n\n      const middleSlice = Math.round((startSlice + endSlice) / 2);\n      // if it is inside the start/end slice, but not exactly the first or\n      // last slice, we render the line in dash, but not the handles\n\n      let isMiddleSlice = false;\n      if (sliceIndex === middleSlice) {\n        isMiddleSlice = true;\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null &&\n        isMiddleSlice\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      let lineWidthToUse = lineWidth;\n\n      if (isMiddleSlice) {\n        lineWidthToUse = 3;\n      }\n\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        center,\n        radius,\n        {\n          color,\n          lineDash,\n          lineWidth: lineWidthToUse,\n        }\n      );\n\n      // draw center point, if \"centerPointRadius\" configuration is valid.\n      if (centerPointRadius > 0) {\n        if (radius > 3 * centerPointRadius) {\n          drawCircleSvg(\n            svgDrawingHelper,\n            annotationUID,\n            `${circleUID}-center`,\n            center,\n            centerPointRadius,\n            {\n              color,\n              lineDash,\n              lineWidth,\n            }\n          );\n        }\n      }\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  // Todo: make it work for planes other than acquisition planes\n  _computeProjectionPoints(\n    annotation: CircleROIStartEndThresholdAnnotation,\n    imageVolume: Types.IImageVolume\n  ): void {\n    const { data, metadata } = annotation;\n    const { viewPlaneNormal, spacingInNormal } = metadata;\n    const { imageData } = imageVolume;\n    const { startSlice, endSlice } = data;\n    const { points } = data.handles;\n\n    const startIJK = transformWorldToIndex(imageData, points[0]);\n    startIJK[2] = startSlice;\n\n    if (startIJK[2] !== startSlice) {\n      throw new Error('Start slice does not match');\n    }\n\n    // substitute the end slice index 2 with startIJK index 2\n    const endIJK = vec3.fromValues(startIJK[0], startIJK[1], endSlice);\n\n    const startWorld = vec3.create();\n    imageData.indexToWorldVec3(startIJK, startWorld);\n\n    const endWorld = vec3.create();\n    imageData.indexToWorldVec3(endIJK, endWorld);\n\n    // distance between start and end slice in the world coordinate\n    const distance = vec3.distance(startWorld, endWorld);\n\n    // for each point inside points, navigate in the direction of the viewPlaneNormal\n    // with amount of spacingInNormal, and calculate the next slice until we reach the distance\n    const newProjectionPoints = [];\n    for (let dist = 0; dist < distance; dist += spacingInNormal) {\n      newProjectionPoints.push(\n        points.map((point) => {\n          const newPoint = vec3.create();\n          //@ts-ignore\n          vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\n          return Array.from(newPoint);\n        })\n      );\n    }\n\n    data.cachedStats.projectionPoints = newProjectionPoints;\n  }\n\n  _computePointsInsideVolume(annotation, imageVolume, enabledElement) {\n    const { data } = annotation;\n    const { viewport } = enabledElement;\n    const projectionPoints = data.cachedStats.projectionPoints;\n\n    const pointsInsideVolume: Types.Point3[][] = [[]];\n\n    for (let i = 0; i < projectionPoints.length; i++) {\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!imageVolume) {\n        continue;\n      }\n\n      const centerWorld = projectionPoints[i][0];\n      const canvasCoordinates = projectionPoints[i].map((p) =>\n        viewport.worldToCanvas(p)\n      );\n\n      const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\n        getCanvasCircleCorners(canvasCoordinates)\n      );\n\n      const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n      const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n\n      const worldPos1 = topLeftWorld;\n      const worldPos2 = bottomRightWorld;\n\n      const { dimensions, imageData } = imageVolume;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n      const worldCenterIndex = transformWorldToIndex(imageData, centerWorld);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldCenterIndex[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldCenterIndex[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const center = centerWorld as Types.Point3;\n\n        const ellipseObj = {\n          center,\n          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n        };\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          //@ts-ignore\n          (pointLPS) => pointInEllipse(ellipseObj, pointLPS),\n          null,\n          boundsIJK\n        );\n\n        //@ts-ignore\n        pointsInsideVolume.push(pointsInShape);\n      }\n    }\n    data.cachedStats.pointsInVolume = pointsInsideVolume;\n  }\n\n  _calculateCachedStatsTool(annotation, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId, viewport } = enabledElement;\n\n    const { cachedStats } = data;\n    const targetId = this.getTargetId(viewport);\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n\n    // Todo: this shouldn't be here, this is a performance issue\n    // Since we are extending the RectangleROI class, we need to\n    // bring the logic for handle to some cachedStats calculation\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  }\n\n  _getStartSliceIndex(\n    imageVolume: Types.IImageVolume,\n    worldPos: Types.Point3,\n    spacingInNormal: number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n\n    const numSlicesToPropagateFromStart = Math.round(numSlicesToPropagate / 2);\n    // get end position by moving from worldPos in the direction of viewplaneNormal\n    // with amount of numSlicesToPropagate * spacingInNormal\n    const startPos = vec3.create();\n    vec3.scaleAndAdd(\n      startPos,\n      worldPos,\n      viewPlaneNormal,\n      numSlicesToPropagateFromStart * -spacingInNormal\n    );\n\n    const imageIdIndex = this._getImageIdIndex(\n      imageVolume,\n      startPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    return imageIdIndex;\n  }\n\n  _getEndSliceIndex(\n    imageVolume: Types.IImageVolume,\n    worldPos: Types.Point3,\n    spacingInNormal: number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n    const numSlicesToPropagateFromStart = Math.round(numSlicesToPropagate / 2);\n\n    // get end position by moving from worldPos in the direction of viewplaneNormal\n    // with amount of numSlicesToPropagate * spacingInNormal\n    const endPos = vec3.create();\n    vec3.scaleAndAdd(\n      endPos,\n      worldPos,\n      viewPlaneNormal,\n      numSlicesToPropagateFromStart * spacingInNormal\n    );\n\n    const imageIdIndex = this._getImageIdIndex(\n      imageVolume,\n      endPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    return imageIdIndex;\n  }\n\n  _getImageIdIndex(\n    imageVolume: Types.IImageVolume,\n    pos: vec3,\n    spacingInNormal: number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const halfSpacingInNormalDirection = spacingInNormal / 2;\n    // Loop through imageIds of the imageVolume and find the one that is closest to endPos\n    const { imageIds } = imageVolume;\n    let imageIdIndex;\n    for (let i = 0; i < imageIds.length; i++) {\n      const imageId = imageIds[i];\n\n      const { imagePositionPatient } = metaData.get(\n        'imagePlaneModule',\n        imageId\n      );\n\n      const dir = vec3.create();\n      vec3.sub(dir, pos, imagePositionPatient);\n\n      const dot = vec3.dot(dir, viewPlaneNormal);\n\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\n        imageIdIndex = i;\n      }\n    }\n\n    return imageIdIndex;\n  }\n}\n\nCircleROIStartEndThresholdTool.toolName = 'CircleROIStartEndThreshold';\nexport default CircleROIStartEndThresholdTool;\n","import vtkOrientationMarkerWidget from '@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget';\nimport vtkAnnotatedCubeActor from '@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor';\nimport vtkAxesActor from '@kitware/vtk.js/Rendering/Core/AxesActor';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkXMLPolyDataReader from '@kitware/vtk.js/IO/XML/XMLPolyDataReader';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\n\nimport { BaseTool } from './base';\nimport {\n  Enums,\n  eventTarget,\n  getEnabledElementByIds,\n  getRenderingEngines,\n} from '@cornerstonejs/core';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport { Events } from '../enums';\n\nconst OverlayMarkerType = {\n  ANNOTATED_CUBE: 1,\n  AXES: 2,\n  CUSTOM: 3,\n};\n\n/**\n * The OrientationMarker is a tool that includes an orientation marker in viewports\n * when activated\n */\nclass OrientationMarkerTool extends BaseTool {\n  static toolName;\n  static CUBE = 1;\n  static AXIS = 2;\n  static VTPFILE = 3;\n  orientationMarkers;\n  polyDataURL;\n  _resizeObservers = new Map();\n\n  static OVERLAY_MARKER_TYPES = OverlayMarkerType;\n\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      configuration: {\n        orientationWidget: {\n          enabled: true,\n          viewportCorner: vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT,\n          viewportSize: 0.15,\n          minPixelSize: 100,\n          maxPixelSize: 300,\n        },\n        overlayMarkerType:\n          OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE,\n        overlayConfiguration: {\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE]: {\n            faceProperties: {\n              xPlus: { text: 'R', faceColor: '#ffff00', faceRotation: 90 },\n              xMinus: { text: 'L', faceColor: '#ffff00', faceRotation: 270 },\n              yPlus: {\n                text: 'P',\n                faceColor: '#00ffff',\n                fontColor: 'white',\n                faceRotation: 180,\n              },\n              yMinus: { text: 'A', faceColor: '#00ffff', fontColor: 'white' },\n              zPlus: { text: 'S' },\n              zMinus: { text: 'I' },\n            },\n            defaultStyle: {\n              fontStyle: 'bold',\n              fontFamily: 'Arial',\n              fontColor: 'black',\n              fontSizeScale: (res) => res / 2,\n              faceColor: '#0000ff',\n              edgeThickness: 0.1,\n              edgeColor: 'black',\n              resolution: 400,\n            },\n          },\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.AXES]: {},\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.CUSTOM]: {\n            polyDataURL:\n              'https://raw.githubusercontent.com/Slicer/Slicer/80ad0a04dacf134754459557bf2638c63f3d1d1b/Base/Logic/Resources/OrientationMarkers/Human.vtp',\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.orientationMarkers = {};\n  }\n\n  onSetToolEnabled = (): void => {\n    this.initViewports();\n    this._subscribeToViewportEvents();\n  };\n\n  onSetToolActive = (): void => {\n    this.initViewports();\n\n    this._subscribeToViewportEvents();\n  };\n\n  onSetToolDisabled = (): void => {\n    this.cleanUpData();\n    this._unsubscribeToViewportNewVolumeSet();\n  };\n\n  _getViewportsInfo = () => {\n    const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    return viewports;\n  };\n\n  resize = (viewportId) => {\n    const orientationMarker = this.orientationMarkers[viewportId];\n    if (!orientationMarker) {\n      return;\n    }\n\n    const { orientationWidget } = orientationMarker;\n    orientationWidget.updateViewport();\n  };\n\n  _unsubscribeToViewportNewVolumeSet() {\n    const unsubscribe = () => {\n      const viewportsInfo = this._getViewportsInfo();\n      viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n        const { viewport } = getEnabledElementByIds(\n          viewportId,\n          renderingEngineId\n        );\n        const { element } = viewport;\n\n        element.removeEventListener(\n          Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n          this.initViewports.bind(this)\n        );\n\n        const resizeObserver = this._resizeObservers.get(viewportId);\n        resizeObserver.unobserve(element);\n      });\n    };\n\n    eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {\n      if (evt.detail.toolGroupId !== this.toolGroupId) {\n        return;\n      }\n      unsubscribe();\n      this.initViewports();\n    });\n  }\n\n  _subscribeToViewportEvents() {\n    const subscribeToElementResize = () => {\n      const viewportsInfo = this._getViewportsInfo();\n      viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n        const { viewport } = getEnabledElementByIds(\n          viewportId,\n          renderingEngineId\n        );\n        const { element } = viewport;\n        this.initViewports();\n\n        element.addEventListener(\n          Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n          this.initViewports.bind(this)\n        );\n\n        const resizeObserver = new ResizeObserver(() => {\n          // Todo: i wish there was a better way to do this\n          setTimeout(() => {\n            const { viewport } = getEnabledElementByIds(\n              viewportId,\n              renderingEngineId\n            );\n            this.resize(viewportId);\n            viewport.render();\n          }, 100);\n        });\n\n        resizeObserver.observe(element);\n\n        this._resizeObservers.set(viewportId, resizeObserver);\n      });\n    };\n\n    subscribeToElementResize();\n\n    eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {\n      if (evt.detail.toolGroupId !== this.toolGroupId) {\n        return;\n      }\n\n      subscribeToElementResize();\n      this.initViewports();\n    });\n  }\n\n  private cleanUpData() {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n    const viewports = renderingEngine.getViewports();\n\n    viewports.forEach((viewport) => {\n      const orientationMarker = this.orientationMarkers[viewport.id];\n      if (!orientationMarker) {\n        return;\n      }\n\n      const { actor, orientationWidget } = orientationMarker;\n      orientationWidget?.setEnabled(false);\n      orientationWidget?.delete();\n      actor?.delete();\n\n      const renderWindow = viewport\n        .getRenderingEngine()\n        .offscreenMultiRenderWindow.getRenderWindow();\n      renderWindow.render();\n      viewport.getRenderingEngine().render();\n\n      delete this.orientationMarkers[viewport.id];\n    });\n  }\n\n  private initViewports() {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    if (!renderingEngine) {\n      return;\n    }\n\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n\n    viewports.forEach((viewport) => {\n      if (!viewport.getWidget(this.getToolName())) {\n        this.addAxisActorInViewport(viewport);\n      }\n    });\n  }\n\n  async addAxisActorInViewport(viewport) {\n    const viewportId = viewport.id;\n    const type = this.configuration.overlayMarkerType;\n\n    const overlayConfiguration = this.configuration.overlayConfiguration[type];\n\n    if (this.orientationMarkers[viewportId]) {\n      const { actor, orientationWidget } = this.orientationMarkers[viewportId];\n      // remove the previous one\n      viewport.getRenderer().removeActor(actor);\n      orientationWidget.setEnabled(false);\n    }\n\n    let actor;\n    if (type === 1) {\n      actor = this.createAnnotationCube(overlayConfiguration);\n    } else if (type === 2) {\n      actor = vtkAxesActor.newInstance();\n    } else if (type === 3) {\n      actor = await this.createCustomActor();\n    }\n\n    const renderer = viewport.getRenderer();\n    const renderWindow = viewport\n      .getRenderingEngine()\n      .offscreenMultiRenderWindow.getRenderWindow();\n\n    const {\n      enabled,\n      viewportCorner,\n      viewportSize,\n      minPixelSize,\n      maxPixelSize,\n    } = this.configuration.orientationWidget;\n\n    const orientationWidget = vtkOrientationMarkerWidget.newInstance({\n      actor,\n      interactor: renderWindow.getInteractor(),\n      parentRenderer: renderer,\n    });\n\n    orientationWidget.setEnabled(enabled);\n    orientationWidget.setViewportCorner(viewportCorner);\n    orientationWidget.setViewportSize(viewportSize);\n    orientationWidget.setMinPixelSize(minPixelSize);\n    orientationWidget.setMaxPixelSize(maxPixelSize);\n\n    orientationWidget.updateMarkerOrientation();\n    this.orientationMarkers[viewportId] = {\n      orientationWidget,\n      actor,\n    };\n    viewport.addWidget(this.getToolName(), orientationWidget);\n    renderWindow.render();\n    viewport.getRenderingEngine().render();\n  }\n\n  private async createCustomActor() {\n    const url =\n      this.configuration.overlayConfiguration[OverlayMarkerType.CUSTOM]\n        .polyDataURL;\n\n    const response = await fetch(url);\n    const arrayBuffer = await response.arrayBuffer();\n    const vtpReader = vtkXMLPolyDataReader.newInstance();\n    vtpReader.parseAsArrayBuffer(arrayBuffer);\n    vtpReader.update();\n\n    const polyData = vtkPolyData.newInstance();\n    polyData.shallowCopy(vtpReader.getOutputData());\n    polyData.getPointData().setActiveScalars('Color');\n    const mapper = vtkMapper.newInstance();\n    mapper.setInputData(polyData);\n    mapper.setColorModeToDirectScalars();\n\n    const actor = vtkActor.newInstance();\n    actor.setMapper(mapper);\n    actor.rotateZ(180);\n    return actor;\n  }\n\n  private createAnnotationCube(overlayConfiguration: any) {\n    const actor = vtkAnnotatedCubeActor.newInstance();\n    actor.setDefaultStyle({ ...overlayConfiguration.defaultStyle });\n    actor.setXPlusFaceProperty({\n      ...overlayConfiguration.faceProperties.xPlus,\n    });\n    actor.setXMinusFaceProperty({\n      ...overlayConfiguration.faceProperties.xMinus,\n    });\n    actor.setYPlusFaceProperty({\n      ...overlayConfiguration.faceProperties.yPlus,\n    });\n    actor.setYMinusFaceProperty({\n      ...overlayConfiguration.faceProperties.yMinus,\n    });\n    actor.setZPlusFaceProperty({\n      ...overlayConfiguration.faceProperties.zPlus,\n    });\n    actor.setZMinusFaceProperty({\n      ...overlayConfiguration.faceProperties.zMinus,\n    });\n    return actor;\n  }\n\n  async createAnnotatedCubeActor() {\n    const axes = vtkAnnotatedCubeActor.newInstance();\n    const { faceProperties, defaultStyle } = this.configuration.annotatedCube;\n\n    axes.setDefaultStyle(defaultStyle);\n\n    Object.keys(faceProperties).forEach((key) => {\n      const methodName = `set${\n        key.charAt(0).toUpperCase() + key.slice(1)\n      }FaceProperty`;\n      axes[methodName](faceProperties[key]);\n    });\n\n    return axes;\n  }\n}\n\nOrientationMarkerTool.toolName = 'OrientationMarker';\nexport default OrientationMarkerTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  ToolGroupSpecificRepresentation,\n} from '../../types';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getActiveSegmentationRepresentation } from '../../stateManagement/segmentation/activeSegmentation';\nimport RepresentationTypes from '../../enums/SegmentationRepresentations';\nimport { setActiveSegmentIndex } from '../../stateManagement/segmentation/segmentIndex';\nimport {\n  getHoveredContourSegmentationAnnotation,\n  getSegmentAtLabelmapBorder,\n  getSegmentAtWorldPoint,\n} from '../../utilities/segmentation';\nimport { state } from '../../store';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\n\n/**\n * Represents a tool used for segment selection. It is used to select a segment\n * by hovering over it.\n *\n */\nclass SegmentSelectTool extends BaseTool {\n  static toolName;\n  private hoverTimer: ReturnType<typeof setTimeout> | null;\n\n  static SelectMode = {\n    Inside: 'Inside',\n    Border: 'Border',\n  };\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        hoverTimeout: 100,\n        mode: SegmentSelectTool.SelectMode.Border,\n        searchRadius: 6, // search for border in a 6px radius\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.hoverTimer = null;\n  }\n\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    if (this.hoverTimer) {\n      clearTimeout(this.hoverTimer);\n    }\n\n    this.hoverTimer = setTimeout(() => {\n      this._setActiveSegment(evt);\n      this.hoverTimer = null;\n    }, this.configuration.hoverTimeout);\n\n    return true;\n  };\n\n  onSetToolEnabled = (): void => {\n    this.onSetToolActive();\n  };\n\n  onSetToolActive = (): void => {\n    this.hoverTimer = null;\n  };\n\n  onSetToolDisabled = (): void => {\n    this.hoverTimer = null;\n  };\n\n  _setActiveSegment(evt = {} as EventTypes.InteractionEventType): void {\n    if (state.isInteractingWithTool) {\n      return;\n    }\n\n    const { element, currentPoints } = evt.detail;\n\n    const worldPoint = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n\n    if (!enabledElement) {\n      return;\n    }\n\n    const { viewport } = enabledElement;\n\n    const activeSegmentationReps = getActiveSegmentationRepresentation(\n      this.toolGroupId\n    );\n\n    if (!activeSegmentationReps) {\n      return;\n    }\n\n    const supportedTypes = [\n      RepresentationTypes.Labelmap,\n      RepresentationTypes.Contour,\n    ];\n\n    if (supportedTypes.includes(activeSegmentationReps.type)) {\n      this._setActiveSegmentForType(\n        activeSegmentationReps,\n        worldPoint,\n        viewport\n      );\n    } else {\n      console.warn(\n        'SegmentSelectTool does not support the current segmentation type.'\n      );\n    }\n  }\n\n  _setActiveSegmentForType(\n    activeSegmentationReps: ToolGroupSpecificRepresentation,\n    worldPoint: Types.Point3,\n    viewport: Types.IStackViewport | Types.IVolumeViewport\n  ): void {\n    const imageDataInfo = viewport.getImageData();\n\n    if (!imageDataInfo) {\n      return;\n    }\n\n    const { segmentationId, type } = activeSegmentationReps;\n\n    let hoveredSegmentIndex;\n\n    if (this.configuration.mode === SegmentSelectTool.SelectMode.Inside) {\n      hoveredSegmentIndex = getSegmentAtWorldPoint(segmentationId, worldPoint, {\n        viewport,\n      });\n    } else {\n      switch (type) {\n        case SegmentationRepresentations.Labelmap:\n          hoveredSegmentIndex = getSegmentAtLabelmapBorder(\n            segmentationId,\n            worldPoint,\n            {\n              viewport,\n              searchRadius: this.configuration.searchRadius,\n            }\n          );\n          break;\n\n        case SegmentationRepresentations.Contour:\n          hoveredSegmentIndex =\n            getHoveredContourSegmentationAnnotation(segmentationId);\n          break;\n      }\n    }\n\n    // No need to select background\n    if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {\n      return;\n    }\n\n    setActiveSegmentIndex(segmentationId, hoveredSegmentIndex);\n\n    const renderingEngine = viewport.getRenderingEngine();\n    const viewportIds = renderingEngine.getViewports().map((v) => v.id);\n\n    // update states\n    triggerSegmentationModified(segmentationId);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n  }\n}\n\nSegmentSelectTool.toolName = 'SegmentSelectTool';\nexport default SegmentSelectTool;\n","import {\n  cache,\n  getEnabledElement,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport { PublicToolProps, ToolProps, EventTypes } from '../../types';\nimport { SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport {\n  segmentLocking,\n  activeSegmentation,\n  segmentIndex as segmentIndexController,\n} from '../../stateManagement/segmentation';\nimport floodFill from '../../utilities/segmentation/floodFill';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { FloodFillResult, FloodFillGetter } from '../../types';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\nconst { transformWorldToIndex, isEqual } = csUtils;\n\ntype PaintFillToolHelpers = {\n  getScalarDataPositionFromPlane: (x: number, y: number) => number;\n  getLabelValue: (x: number, y: number, z: number) => number;\n  floodFillGetter: FloodFillGetter;\n  inPlaneSeedPoint: Types.Point2;\n  fixedDimensionValue: number;\n};\n\n/**\n * Tool for manipulating segmentation data by filling in regions. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will fill a given labelled\n * or empty region with the the activeSegmentIndex label. You can use the\n * SegmentationModule to set the active segmentation and segmentIndex.\n */\nclass PaintFillTool extends BaseTool {\n  static toolName;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationId, type } = activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked: number[] =\n      segmentLocking.getLockedSegments(segmentationId);\n    const { representationData } = getSegmentation(segmentationId);\n\n    const labelmapData =\n      representationData[SegmentationRepresentations.Labelmap];\n\n    let dimensions: Types.Point3;\n    let direction: Types.Mat3;\n    let scalarData: Types.PixelDataTypedArray;\n    let index: Types.Point3;\n\n    if (isVolumeSegmentation(labelmapData, viewport)) {\n      const { volumeId } = representationData[\n        type\n      ] as LabelmapSegmentationDataVolume;\n\n      const segmentation = cache.getVolume(volumeId);\n      ({ dimensions, direction } = segmentation);\n      scalarData = segmentation.getScalarData();\n\n      index = transformWorldToIndex(segmentation.imageData, worldPos);\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      const currentImageId = enabledElement.viewport.getCurrentImageId();\n      const currentSegmentationImageId =\n        imageIdReferenceMap.get(currentImageId);\n\n      if (!currentSegmentationImageId) {\n        throw new Error(\n          'No active segmentation imageId detected, create one before using scissors tool'\n        );\n      }\n\n      const segmentationImage = cache.getImage(currentSegmentationImageId);\n      scalarData = segmentationImage.getPixelData();\n      const { imageData } = viewport.getImageData();\n      dimensions = imageData.getDimensions();\n      direction = imageData.getDirection();\n      index = transformWorldToIndex(imageData, worldPos);\n    }\n\n    const fixedDimension = this.getFixedDimension(\n      viewPlaneNormal,\n      direction as number[]\n    );\n\n    if (fixedDimension === undefined) {\n      console.warn('Oblique paint fill not yet supported');\n      return;\n    }\n\n    const {\n      floodFillGetter,\n      getLabelValue,\n      getScalarDataPositionFromPlane,\n      inPlaneSeedPoint,\n      fixedDimensionValue,\n    } = this.generateHelpers(scalarData, dimensions, index, fixedDimension);\n\n    // Check if within volume\n    if (\n      index[0] < 0 ||\n      index[0] >= dimensions[0] ||\n      index[1] < 0 ||\n      index[1] >= dimensions[1] ||\n      index[2] < 0 ||\n      index[2] >= dimensions[2]\n    ) {\n      // Clicked outside segmentation volume, no good way to fill.\n      return;\n    }\n    //@ts-ignore // todo type\n    const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);\n\n    if (segmentsLocked.includes(clickedLabelValue)) {\n      // Label is locked, cannot fill.\n      return;\n    }\n\n    const floodFillResult = floodFill(floodFillGetter, inPlaneSeedPoint);\n\n    const { flooded } = floodFillResult;\n\n    flooded.forEach((index) => {\n      const scalarDataPosition = getScalarDataPositionFromPlane(\n        index[0],\n        index[1]\n      );\n\n      scalarData[scalarDataPosition] = segmentIndex;\n    });\n\n    const framesModified = this.getFramesModified(\n      fixedDimension,\n      fixedDimensionValue,\n      floodFillResult\n    );\n\n    triggerSegmentationDataModified(segmentationId, framesModified);\n\n    return true;\n  };\n\n  private getFramesModified = (\n    fixedDimension: number,\n    fixedDimensionValue: number,\n    floodFillResult: FloodFillResult\n  ): number[] => {\n    const { boundaries } = floodFillResult;\n\n    if (fixedDimension === 2) {\n      return [fixedDimensionValue];\n    }\n\n    // For both the fixedDimensions being 0 and 1, the Z (stack) direction is j,\n    // so we don't need to find min/max i.\n\n    let minJ = Infinity;\n    let maxJ = -Infinity;\n\n    for (let b = 0; b < boundaries.length; b++) {\n      const j = boundaries[b][1];\n\n      if (j < minJ) {\n        minJ = j;\n      }\n      if (j > maxJ) {\n        maxJ = j;\n      }\n    }\n\n    const framesModified = [];\n\n    for (let frame = minJ; frame <= maxJ; frame++) {\n      framesModified.push(frame);\n    }\n\n    return framesModified;\n  };\n\n  private generateHelpers = (\n    scalarData: Types.PixelDataTypedArray,\n    dimensions: Types.Point3,\n    seedIndex3D: Types.Point3,\n    fixedDimension = 2\n  ): PaintFillToolHelpers => {\n    let fixedDimensionValue: number;\n    let inPlaneSeedPoint: Types.Point2;\n\n    switch (fixedDimension) {\n      case 0:\n        fixedDimensionValue = seedIndex3D[0]; // X\n        inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]]; // Y,Z\n        break;\n      case 1:\n        fixedDimensionValue = seedIndex3D[1]; // Y\n        inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]]; // X,Z\n        break;\n      case 2:\n        fixedDimensionValue = seedIndex3D[2]; // Z\n        inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]]; // X, Y\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    const getScalarDataPosition = (x: number, y: number, z: number): number => {\n      return z * dimensions[1] * dimensions[0] + y * dimensions[0] + x;\n    };\n\n    const getLabelValue = (x: number, y: number, z: number): number => {\n      return scalarData[getScalarDataPosition(x, y, z)];\n    };\n\n    const floodFillGetter = this.generateFloodFillGetter(\n      dimensions,\n      fixedDimension,\n      fixedDimensionValue,\n      getLabelValue\n    );\n\n    const getScalarDataPositionFromPlane =\n      this.generateGetScalarDataPositionFromPlane(\n        getScalarDataPosition,\n        fixedDimension,\n        fixedDimensionValue\n      );\n\n    return {\n      getScalarDataPositionFromPlane,\n      getLabelValue,\n      floodFillGetter,\n      inPlaneSeedPoint,\n      fixedDimensionValue,\n    };\n  };\n\n  private getFixedDimension(\n    viewPlaneNormal: Types.Point3,\n    direction: number[]\n  ): number | undefined {\n    const xDirection = direction.slice(0, 3);\n    const yDirection = direction.slice(3, 6);\n    const zDirection = direction.slice(6, 9);\n\n    const absoluteOfViewPlaneNormal = [\n      Math.abs(viewPlaneNormal[0]),\n      Math.abs(viewPlaneNormal[1]),\n      Math.abs(viewPlaneNormal[2]),\n    ];\n\n    const absoluteOfXDirection = [\n      Math.abs(xDirection[0]),\n      Math.abs(xDirection[1]),\n      Math.abs(xDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {\n      return 0;\n    }\n\n    const absoluteOfYDirection = [\n      Math.abs(yDirection[0]),\n      Math.abs(yDirection[1]),\n      Math.abs(yDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {\n      return 1;\n    }\n\n    const absoluteOfZDirection = [\n      Math.abs(zDirection[0]),\n      Math.abs(zDirection[1]),\n      Math.abs(zDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {\n      return 2;\n    }\n  }\n\n  // Define a getter for the fill routine to access the working label map.\n  private generateFloodFillGetter = (\n    dimensions: Types.Point3,\n    fixedDimension: number,\n    fixedDimensionValue: number,\n    getLabelValue: PaintFillToolHelpers['getLabelValue']\n  ): FloodFillGetter => {\n    let floodFillGetter;\n\n    // In each helper we first check if out of bounds, as the flood filler\n    // doesn't know about the dimensions of the data structure that sits on top\n    // of the scalarData. E.g. if cols is 10, (0,1) and (10, 0) would point to\n    // the same position in these getters.\n\n    switch (fixedDimension) {\n      case 0:\n        floodFillGetter = (y, z) => {\n          if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {\n            return;\n          }\n\n          return getLabelValue(fixedDimensionValue, y, z);\n        };\n        break;\n\n      case 1:\n        floodFillGetter = (x, z) => {\n          if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {\n            return;\n          }\n\n          return getLabelValue(x, fixedDimensionValue, z);\n        };\n        break;\n\n      case 2:\n        floodFillGetter = (x, y) => {\n          if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {\n            return;\n          }\n\n          return getLabelValue(x, y, fixedDimensionValue);\n        };\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    return floodFillGetter;\n  };\n\n  private generateGetScalarDataPositionFromPlane = (\n    getScalarDataPosition: (x: number, y: number, z: number) => number,\n    fixedDimension: number,\n    fixedDimensionValue: number\n  ): PaintFillToolHelpers['getScalarDataPositionFromPlane'] => {\n    let getScalarDataPositionFromPlane;\n\n    switch (fixedDimension) {\n      case 0:\n        getScalarDataPositionFromPlane = (y, z) => {\n          return getScalarDataPosition(fixedDimensionValue, y, z);\n        };\n        break;\n      case 1:\n        getScalarDataPositionFromPlane = (x, z) => {\n          return getScalarDataPosition(x, fixedDimensionValue, z);\n        };\n        break;\n      case 2:\n        getScalarDataPositionFromPlane = (x, y) => {\n          return getScalarDataPosition(x, y, fixedDimensionValue);\n        };\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    return getScalarDataPositionFromPlane;\n  };\n}\n\nPaintFillTool.toolName = 'PaintFill';\nexport default PaintFillTool;\n","import { vec3, vec2 } from 'gl-matrix';\n\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n  cache,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\n\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRedactionRect as drawRedactionRectSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport { EventTypes, SVGDrawingHelper } from '../../types';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { VideoRedactionAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nclass VideoRedactionTool extends AnnotationTool {\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportUIDsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  _configuration: any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(toolConfiguration = {}) {\n    super(toolConfiguration, {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: { shadow: true, preventHandleOutsideImage: false },\n    });\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): VideoRedactionAnnotation => {\n    const eventData = evt.detail;\n    const { currentPoints, element } = eventData;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotation = {\n      metadata: {\n        // We probably just want a different type of data here, hacking this\n        // together for now.\n        viewPlaneNormal: <Types.Point3>[0, 0, 1],\n        viewUp: <Types.Point3>[0, 1, 0],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId,\n        toolName: this.getToolName(),\n      },\n      data: {\n        invalidated: true,\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        active: true,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    this.editData = {\n      annotation,\n      viewportUIDsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    return annotation;\n  };\n\n  getHandleNearImagePoint = (element, annotation, canvasCoords, proximity) => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      const toolDataCanvasCoordinate = viewport.worldToCanvas(point);\n\n      const near =\n        vec2.distance(canvasCoords, <vec2>toolDataCanvasCoordinate) < proximity;\n\n      if (near === true) {\n        data.handles.activeHandleIndex = i;\n        return point;\n      }\n    }\n\n    data.handles.activeHandleIndex = null;\n  };\n\n  isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasPoint1 = viewport.worldToCanvas(points[0]);\n    const canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    const rect = this._getRectangleImageCoordinates([\n      canvasPoint1,\n      canvasPoint2,\n    ]);\n\n    const point = [canvasCoords[0], canvasCoords[1]] as Types.Point2;\n    const { left, top, width, height } = rect;\n\n    const distanceToPoint = rectangle.distanceToPoint(\n      [left, top, width, height],\n      point\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n  };\n\n  toolSelectedCallback = (evt, annotation, interactionType = 'mouse') => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { data } = annotation;\n\n    data.active = true;\n\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    this.editData = {\n      annotation,\n      viewportUIDsToRender,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt,\n    annotation,\n    handle,\n    interactionType = 'mouse'\n  ) => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const { data } = annotation;\n\n    data.active = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if (handle.worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    this.editData = {\n      annotation,\n      viewportUIDsToRender,\n      handleIndex,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    evt.preventDefault();\n  };\n\n  _mouseUpCallback = (evt) => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { annotation, viewportUIDsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.active = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n  };\n\n  _mouseDragCallback = (evt) => {\n    this.isDrawing = true;\n\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { annotation, viewportUIDsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    if (handleIndex === undefined) {\n      // Moving tool, so move all points by the world points delta\n      const { deltaPoints } = eventData;\n      const worldPosDelta = deltaPoints.world;\n\n      const { points } = data.handles;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      data.invalidated = true;\n    } else {\n      // Moving handle.\n      const { currentPoints } = eventData;\n      const enabledElement = getEnabledElement(element);\n      const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n      const worldPos = currentPoints.world;\n\n      const { points } = data.handles;\n\n      // Move this handle.\n      points[handleIndex] = [...worldPos];\n\n      let bottomLeftCanvas;\n      let bottomRightCanvas;\n      let topLeftCanvas;\n      let topRightCanvas;\n\n      let bottomLeftWorld;\n      let bottomRightWorld;\n      let topLeftWorld;\n      let topRightWorld;\n\n      switch (handleIndex) {\n        case 0:\n        case 3:\n          // Moving bottomLeft or topRight\n\n          bottomLeftCanvas = worldToCanvas(points[0]);\n          topRightCanvas = worldToCanvas(points[3]);\n\n          bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n          topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n          bottomRightWorld = canvasToWorld(bottomRightCanvas);\n          topLeftWorld = canvasToWorld(topLeftCanvas);\n\n          points[1] = bottomRightWorld;\n          points[2] = topLeftWorld;\n\n          break;\n        case 1:\n        case 2:\n          // Moving bottomRight or topLeft\n          bottomRightCanvas = worldToCanvas(points[1]);\n          topLeftCanvas = worldToCanvas(points[2]);\n\n          bottomLeftCanvas = <Types.Point2>[\n            topLeftCanvas[0],\n            bottomRightCanvas[1],\n          ];\n          topRightCanvas = <Types.Point2>[\n            bottomRightCanvas[0],\n            topLeftCanvas[1],\n          ];\n\n          bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n          topRightWorld = canvasToWorld(topRightCanvas);\n\n          points[0] = bottomLeftWorld;\n          points[3] = topRightWorld;\n\n          break;\n      }\n      data.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n  };\n\n  cancel(element) {\n    // If it is mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportUIDsToRender } = this.editData;\n\n    const { data } = annotation;\n\n    data.active = false;\n    data.handles.activeHandleIndex = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    this.editData = null;\n    return annotation.metadata.annotationUID;\n  }\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  /**\n   * Remove event handlers for the modify event loop, and enable default event propagation.\n   */\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i];\n      const { annotationUID } = annotation;\n      const toolMetadata = annotation.metadata;\n\n      const data = annotation.data;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        // !isToolDataLocked(toolData) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const rectangleUID = '0';\n      drawRedactionRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color: 'black',\n          lineDash,\n          lineWidth,\n        }\n      );\n    }\n  };\n\n  _getRectangleImageCoordinates = (\n    points: Array<Types.Point2>\n  ): {\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n  } => {\n    const [point0, point1] = points;\n\n    return {\n      left: Math.min(point0[0], point1[0]),\n      top: Math.min(point0[1], point1[1]),\n      width: Math.abs(point0[0] - point1[0]),\n      height: Math.abs(point0[1] - point1[1]),\n    };\n  };\n\n  _getImageVolumeFromTargetUID(targetUID, renderingEngine) {\n    let imageVolume, viewport;\n    if (targetUID.startsWith('stackTarget')) {\n      const coloneIndex = targetUID.indexOf(':');\n      const viewportUID = targetUID.substring(coloneIndex + 1);\n      const viewport = renderingEngine.getViewport(viewportUID);\n      imageVolume = viewport.getImageData();\n    } else {\n      imageVolume = cache.getVolume(targetUID);\n    }\n\n    return { imageVolume, viewport };\n  }\n\n  /**\n   * _calculateCachedStats - For each volume in the frame of reference that a\n   * tool instance in particular viewport defines as its target volume, find the\n   * volume coordinates (i,j,k) being probed by the two corners. One of i,j or k\n   * will be constant across the two points. In the other two directions iterate\n   * over the voxels and calculate the first and second-order statistics.\n   *\n   * @param {object} data - The toolData tool-specific data.\n   * @param {Array<number>} viewPlaneNormal The normal vector of the camera.\n   * @param {Array<number>} viewUp The viewUp vector of the camera.\n   */\n  _calculateCachedStats = (\n    annotation,\n    viewPlaneNormal,\n    viewUp,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const { data } = annotation;\n    const { viewportUID, renderingEngineUID, sceneUID } = enabledElement;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[3];\n    const { cachedStats } = data;\n\n    const targetUIDs = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetUIDs.length; i++) {\n      const targetUID = targetUIDs[i];\n\n      const { imageVolume } = this._getImageVolumeFromTargetUID(\n        targetUID,\n        renderingEngine\n      );\n\n      const {\n        dimensions,\n        scalarData,\n        vtkImageData: imageData,\n        metadata,\n      } = imageVolume;\n      const worldPos1Index = vec3.fromValues(0, 0, 0);\n      const worldPos2Index = vec3.fromValues(0, 0, 0);\n\n      imageData.worldToIndexVec3(worldPos1, worldPos1Index);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      imageData.worldToIndexVec3(worldPos2, worldPos2Index);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n\n        // Calculate index bounds to iterate over\n\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n\n        const area = worldWidth * worldHeight;\n\n        let count = 0;\n        let mean = 0;\n        let stdDev = 0;\n\n        const yMultiple = dimensions[0];\n        const zMultiple = dimensions[0] * dimensions[1];\n\n        // This is a triple loop, but one of these 3 values will be constant\n        // In the planar view.\n        for (let k = kMin; k <= kMax; k++) {\n          for (let j = jMin; j <= jMax; j++) {\n            for (let i = iMin; i <= iMax; i++) {\n              const value = scalarData[k * zMultiple + j * yMultiple + i];\n\n              count++;\n              mean += value;\n            }\n          }\n        }\n\n        mean /= count;\n\n        for (let k = kMin; k <= kMax; k++) {\n          for (let j = jMin; j <= jMax; j++) {\n            for (let i = iMin; i <= iMax; i++) {\n              const value = scalarData[k * zMultiple + j * yMultiple + i];\n\n              const valueMinusMean = value - mean;\n\n              stdDev += valueMinusMean * valueMinusMean;\n            }\n          }\n        }\n\n        stdDev /= count;\n        stdDev = Math.sqrt(stdDev);\n\n        cachedStats[targetUID] = {\n          Modality: metadata.Modality,\n          area,\n          mean,\n          stdDev,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetUID] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    data.invalidated = false;\n\n    // Dispatching measurement modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail = {\n      annotation,\n      viewportUID,\n      renderingEngineUID,\n      sceneUID: sceneUID,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n\n  _getTargetStackUID(viewport) {\n    return `stackTarget:${viewport.uid}`;\n  }\n\n  _getTargetVolumeUID = (scene) => {\n    if (this.configuration.volumeUID) {\n      return this.configuration.volumeUID;\n    }\n\n    const volumeActors = scene.getVolumeActors();\n\n    if (!volumeActors && !volumeActors.length) {\n      // No stack to scroll through\n      return;\n    }\n\n    return volumeActors[0].uid;\n  };\n}\n\nVideoRedactionTool.toolName = 'VideoRedaction';\nexport default VideoRedactionTool;\n"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__976__","__WEBPACK_EXTERNAL_MODULE__953__","__WEBPACK_EXTERNAL_MODULE__807__","__WEBPACK_EXTERNAL_MODULE__543__","__WEBPACK_EXTERNAL_MODULE__785__","__WEBPACK_EXTERNAL_MODULE__283__","__WEBPACK_EXTERNAL_MODULE__441__","__WEBPACK_EXTERNAL_MODULE__795__","__WEBPACK_EXTERNAL_MODULE__396__","__WEBPACK_EXTERNAL_MODULE__348__","__WEBPACK_EXTERNAL_MODULE__70__","__WEBPACK_EXTERNAL_MODULE__127__","__WEBPACK_EXTERNAL_MODULE__474__","__WEBPACK_EXTERNAL_MODULE__610__","__WEBPACK_EXTERNAL_MODULE__847__","__WEBPACK_EXTERNAL_MODULE__518__","__WEBPACK_EXTERNAL_MODULE__744__","__WEBPACK_EXTERNAL_MODULE__424__","__WEBPACK_EXTERNAL_MODULE__614__","HASH_UNDEFINED","MAX_SAFE_INTEGER","argsTag","boolTag","dateTag","funcTag","genTag","mapTag","numberTag","objectTag","promiseTag","regexpTag","setTag","stringTag","symbolTag","weakMapTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","reFlags","reIsHostCtor","reIsUint","cloneableTags","freeGlobal","g","Object","freeSelf","Function","freeExports","nodeType","freeModule","moduleExports","addMapEntry","map","pair","set","addSetEntry","value","add","arrayReduce","array","iteratee","accumulator","initAccum","index","length","isHostObject","result","toString","e","mapToArray","Array","size","forEach","key","overArg","func","transform","arg","setToArray","uid","arrayProto","prototype","funcProto","objectProto","coreJsData","maskSrcKey","exec","keys","IE_PROTO","funcToString","hasOwnProperty","objectToString","reIsNative","RegExp","call","replace","Buffer","undefined","Symbol","Uint8Array","getPrototype","getPrototypeOf","objectCreate","create","propertyIsEnumerable","splice","nativeGetSymbols","getOwnPropertySymbols","nativeIsBuffer","isBuffer","nativeKeys","DataView","getNative","Map","Promise","Set","WeakMap","nativeCreate","dataViewCtorString","toSource","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","symbolValueOf","valueOf","Hash","entries","this","clear","entry","ListCache","MapCache","Stack","__data__","assignValue","object","objValue","eq","assocIndexOf","baseClone","isDeep","isFull","customizer","stack","isObject","isArr","isArray","constructor","input","initCloneArray","source","copyArray","tag","getTag","isFunc","buffer","slice","copy","cloneBuffer","isPrototype","proto","initCloneObject","copyObject","getSymbols","copySymbols","baseAssign","cloneFunc","symbol","Ctor","cloneArrayBuffer","dataView","byteOffset","byteLength","cloneDataView","typedArray","cloneTypedArray","cloneMap","regexp","lastIndex","cloneRegExp","cloneSet","initCloneByTag","stacked","get","props","keysFunc","symbolsFunc","values","offset","arrayPush","baseGetAllKeys","getAllKeys","arrayEach","subValue","arrayBuffer","newValue","getMapData","type","data","getValue","isFunction","test","baseIsNative","has","pop","push","cache","pairs","LARGE_ARRAY_SIZE","isIndex","other","ArrayBuffer","resolve","ctorString","isArrayLike","isLength","inherited","isObjectLike","isArrayLikeObject","isArguments","n","baseTimes","String","skipIndexes","arrayLikeKeys","baseKeys","INFINITY","reIsDeepProp","reIsPlainProp","reLeadingDot","rePropName","reEscapeChar","symbolToString","pattern","stringToPath","memoize","string","isSymbol","baseToString","match","number","quote","toKey","resolver","TypeError","memoized","args","arguments","apply","Cache","path","defaultValue","isKey","baseGet","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","id","loaded","__webpack_modules__","m","getter","__esModule","d","a","definition","o","defineProperty","enumerable","u","chunkId","globalThis","window","obj","prop","r","toStringTag","nmd","paths","children","scriptUrl","importScripts","location","document","currentScript","src","scripts","getElementsByTagName","i","Error","p","b","baseURI","href","Events","_typeof","iterator","_defineProperty","hint","prim","toPrimitive","res","configurable","writable","globalLockedAnnotationsSet","setAnnotationLocked","annotation","locked","detail","makeEventDetail","lockedAnnotationsSet","added","lock","unlock","publish","unlockAllAnnotations","clearLockedAnnotationsSet","getAnnotationsLocked","from","isAnnotationLocked","getAnnotationsLockedCount","checkAndDefineIsLockedProperty","isLocked","descriptor","getOwnPropertyDescriptor","setIsLocked","getIsLocked","isExtensible","shouldDefineIsLockedProperty","freeze","removed","delete","item","triggerEvent","eventTarget","selectedAnnotationUIDs","setAnnotationSelected","annotationUID","deselectAnnotation","preserveSelected","clearSelectionSet","selectAnnotation","getAnnotationsSelected","getAnnotationsSelectedByToolName","toolName","filter","_annotation$metadata","getAnnotation","metadata","isAnnotationSelected","getAnnotationsSelectedCount","selection","selectionSet","globalHiddenAnnotationUIDsSet","setAnnotationVisibility","visible","show","annotationUIDsSet","lastHidden","hide","showAllAnnotations","isAnnotationVisible","checkAndDefineIsVisibleProperty","_annotation$isVisible","isVisible","setIsVisible","getIsVisible","shouldDefineIsVisibleProperty","lastVisible","hidden","FrameOfReferenceSpecificAnnotationManager","annotationGroupSelector","element","enabledElement","getEnabledElement","FrameOfReferenceUID","evt","eventDetail","frameOfReferenceSpecificAnnotations","annotations","invalidated","groupKey","frameOfReferenceUID","frameOfReferenceAnnotations","toolSpecificAnnotations","getAnnotations","total","groupAnnotations","toolAnnotations","findIndex","cloneDeep","state","flat","count","utilities","Enums","_imageVolumeModifiedHandler","defaultFrameOfReferenceSpecificAnnotationManager","ChangeTypes","svgNodeCache","defaultState","isInteractingWithTool","isMultiPartToolActive","tools","toolGroups","synchronizers","enabledElements","handleRadius","ToolModes","MODES","_ref","toolOptions","toolGroupToolNames","includes","mode","triggerAnnotationModified","changeType","viewportId","renderingEngineId","eventType","triggerAnnotationCompleted","_triggerAnnotationCompleted","triggerContourAnnotationCompleted","contourHoleProcessingEnabled","defaultManager","getAnnotationManager","setAnnotationManager","annotationManager","resetAnnotationManager","manager","getGroupKey","getAllAnnotations","clearParentAnnotation","childUID","parentAnnotationUID","parentAnnotation","childUIDIndex","childAnnotationUIDs","indexOf","addChildAnnotation","childAnnotation","parentUID","getParentAnnotation","getChildAnnotations","_annotation$childAnno","_annotation$childAnno2","childAnnotationUID","addAnnotation","csUtils","HTMLDivElement","renderingEngine","triggerAnnotationAddedForElement","getToolGroupsWithToolName","viewportsToRender","toolGroup","viewportsInfo","viewportInfo","getEnabledElementByIds","triggerAnnotationAddedForFOR","getNumberOfAnnotations","removeAnnotation","_annotation$childAnno3","annotationManagerUID","removeAllAnnotations","invalidateAnnotation","currAnnotation","SegmentationRepresentations","defaultContourConfig","renderOutline","outlineWidthAutoGenerated","outlineWidthActive","outlineWidthInactive","outlineOpacity","outlineOpacityInactive","outlineDashActive","outlineDashInactive","outlineDashAutoGenerated","activeSegmentOutlineWidthDelta","renderFill","fillAlpha","fillAlphaInactive","fillAlphaAutoGenerated","defaultLabelmapConfig","renderFillInactive","defaultSurfaceConfig","getDefaultLabelmapConfig","initialDefaultState","colorLUT","segmentations","globalConfig","renderInactiveSegmentations","representations","defaultSegmentationStateManager","getState","getToolGroups","getColorLUT","lutIndex","getNextColorLUTIndex","resetState","getSegmentation","segmentationId","find","segmentation","addSegmentation","concat","getSegmentationRepresentations","toolGroupId","toolGroupSegRepresentationsWithConfig","segmentationRepresentations","getAllSegmentationRepresentations","toolGroupSegReps","addSegmentationRepresentation","segmentationRepresentation","config","_handleActiveSegmentation","getGlobalConfig","setGlobalConfig","getSegmentationRepresentationByUID","segmentationRepresentationUID","toolGroupSegRepresentations","representation","removeSegmentation","removeSegmentationRepresentation","toolGroupSegmentationRepresentations","segData","console","warn","removedSegmentationRepresentation","setActiveSegmentationRepresentation","toolGroupSegmentations","segmentationData","active","getToolGroupSpecificConfig","toolGroupStateWithConfig","getSegmentationRepresentationSpecificConfig","segmentationRepresentationSpecificConfig","setSegmentationRepresentationSpecificConfig","getSegmentSpecificConfig","segmentIndex","segmentSpecificConfig","setSegmentSpecificConfig","options","setSegmentationRepresentationConfig","addColorLUT","removeColorLUT","colorLUTIndex","recentlyAddedOrRemovedSegmentationRepresentation","isVolumeSegmentation","operationData","viewport","imageIdReferenceMap","volumeId","VolumeViewport","segmentIndicesCache","setSegmentationDirty","cached","isDirty","getUniqueSegmentIndices","cachedResult","indices","getCachedSegmentIndices","labelmapData","representationData","keySet","getScalarData","addVolumeSegmentIndices","segmentationImageId","getPixelData","addImageSegmentIndices","Number","sort","handleLabelmapSegmentation","annotationUIDsMap","geometryIds","CONTOUR","geometryId","geometry","getSegmentIndex","handleContourSegmentation","_segmentation$represe","_segmentation$represe2","SURFACE","handleSurfaceSegmentation","triggerSegmentationRemoved","triggerSegmentationRepresentationRemoved","triggerSegmentationRepresentationModified","triggerSegmentationModified","segmentationIds","getSegmentations","triggerSegmentationDataModified","modifiedSlicesToUse","segmentationInput","isContourRepresentation","_contourData$geometry","_contourData$annotati","contourData","cachedStats","segmentLabels","label","segmentsLocked","activeSegmentIndex","getDefaultSegmentationStateManager","suppressEvents","segmentationStateManager","normalizeSegmentationInput","getSegmentationIdRepresentations","allRepresentations","foundRepresentations","foundRepresentation","findSegmentationRepresentationByUID","allToolGroupRepresentations","toolGroupIds","getToolGroupIdsWithSegmentation","foundToolGroupIds","setToolGroupSpecificConfig","getSegmentSpecificRepresentationConfig","setSegmentSpecificRepresentationConfig","getToolGroupIdFromSegmentationRepresentationUID","removeSegmentationRepresentations","getMouseEventPoints","elementToUse","currentTarget","clientPoint","clientX","clientY","_clientToPoint","pagePoint","pageX","pageY","_pageToPoint","canvasPoint","rect","getBoundingClientRect","left","pageXOffset","top","pageYOffset","_pagePointsToCanvasPoints","page","client","canvas","world","canvasToWorld","startPoints","event","eventName","camera","lastPoints","currentPoints","deltaPoints","stopImmediatePropagation","preventDefault","MOUSE_DOWN","MOUSE_DOWN_ACTIVATE","MOUSE_CLICK","MOUSE_UP","MOUSE_DRAG","DOUBLE_CLICK_DRAG_TOLERANCE","mouseButton","isClickEvent","clickDelay","preventClickTimeout","doubleClickState","doubleClickTimeout","mouseDownEvent","mouseUpEvent","ignoreDoubleClick","_onMouseDrag","_updateMouseEventsLastPoints","_getDeltaPoints","_isDragPastDoubleClickTolerance","_doStateMouseDownAndUp","_copyPoints","_onMouseUp","clearTimeout","_cleanUp","addEventListener","_onMouseMove","removeEventListener","mouseMoveListener","delta","Math","abs","_preventClickHandler","_clearDoubleClickTimeoutAndEvents","_doMouseDown","_state$element","_state$element2","JSON","parse","stringify","points","_subtractPoints2D","point0","point1","mouseDoubleClickIgnoreListener","buttons","setTimeout","disable","mouseDoubleClickListener","mouseDownListener","capture","enable","deltaY","spinX","spinY","pixelX","pixelY","wheelDelta","wheelDeltaY","wheelDeltaX","deltaX","deltaMode","normalizeWheel","direction","wheel","wheelListener","passive","pointerType","lastInteractionType","lastInteractionTime","handleTap","now","Date","stopPropagation","handleTapMouse","bind","handleTapTouch","attachEvents","eventList","interactionType","tapHandler","removeEvents","mouseEvents","touchEvents","Swipe","getTouchEventPoints","touches","changedTouches","touch","identifier","radiusX","radiusY","force","rotationAngle","getDeltaPoints","curr","getMeanPoints","last","getDeltaDistance","_getDistance2D","_getDistance3D","getDeltaRotation","getDeltaDistanceBetweenIPoints","currentDistance","_getMeanDistanceBetweenAllIPoints","lastDistance","copyPointsList","copyPoints","reduce","prev","getMeanTouchPoints","pairedDistance","j","sqrt","pow","Settings","TOUCH_START","TOUCH_START_ACTIVATE","TOUCH_PRESS","TOUCH_DRAG","TOUCH_END","TOUCH_TAP","TOUCH_SWIPE","zeroIPoint","zeroIDistance","startPointsList","lastPointsList","isTouchStart","startTime","pressTimeout","pressDelay","pressMaxDistance","accumulatedDistance","swipeDistanceThreshold","swiped","swipeToleranceMs","defaultTapState","taps","tapTimeout","tapMaxDistance","tapToleranceMs","tapState","triggerEventCallback","ele","name","_onTouchDrag","currentPointsList","_updateTouchEventsLastPoints","deltaDistance","totalDistance","currentTime","getTime","x","y","swipe","RIGHT","LEFT","DOWN","UP","_checkTouchSwipe","_onTouchEnd","_checkTouchTap","lp","_onTouchPress","_onTouchStart","preventGhostClick","touchStartListener","keyCode","keyListener","_onKeyUp","_onVisibilityChange","visibilityState","resetModifierKey","keyDownListener","getModifierKey","_getRenderingEngines$","getRenderingEngines","re","getViewports","vp","toolGroupFilteredByIds","tg","some","s","SegmentationState","segmentationConfig","getGlobalRepresentationConfig","representationType","setGlobalRepresentationConfig","segmentationRepresentationConfig","setSegmentationVisibility","visibility","segmentsHidden","getSegmentationVisibility","indicesSet","setSegmentsVisibility","segmentIndices","segRepresentation","setSegmentVisibility","getSegmentVisibility","BaseTool","toolProps","defaultToolProps","initialProps","configuration","supportedInteractionTypes","strategies","defaultStrategy","activeStrategy","strategyOptions","assign","getToolName","applyActiveStrategy","_strategies$activeStr","applyActiveStrategyCallback","callbackType","_strategies$activeStr2","setConfiguration","newConfiguration","setActiveStrategy","strategyName","getTargetVolumeId","_actorEntries$find","actorEntries","getActors","actorEntry","actor","getClassName","getTargetIdImage","targetId","startsWith","imageId","split","imageURI","viewports","getCurrentImageId","getImageData","getTargetId","_viewport$getReferenc","getReferenceId","BaseVolumeViewport","actorUIDsToRemove","Boolean","removeActors","pointToString","point","decimals","parseFloat","toFixed","registered","registerPolySegWorker","getWebWorkerManager","registerWorker","workerFn","Worker","URL","maxWorkerInstances","autoTerminateOnIdle","enabled","idleTimeThreshold","workerManager","polyDataCache","surfacesAABBCache","triggerWorkerProgress","progress","WorkerTypes","SURFACE_CLIPPING","async","clipAndCacheSurfacesForViewport","surfacesInfo","_viewport$getSlicesCl","planesInfo","getSlicesClippingPlanes","currentSliceIndex","getSliceIndex","sliceIndex","surfacesWithoutAABB","surface","executeTask","callbacks","_ref3","aabb","updateSurfacesAABBCache","surfacesAABB","getCamera","_ref2","polyDataResults","polyDataResult","surfaceId","actorUID","cacheId","viewPlaneNormal","generateCacheId","lines","numberOfCells","actorCache","updatePolyDataCache","catch","error","validateRepresentationData","segmentationRepresentationData","validate","conversionPaths","canComputeRequestedRepresentation","representationInfo","polySeg","existingRepresentationTypes","supportedTypes","representationTypeData","validateFn","validateLabelmap","getExistingRepresentationTypes","existingRepresentationType","fromRepresentationType","toRepresentationType","_conversionPaths$get","canConvertFromTo","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","useRAF","requestAnimationFrame","invokeFunc","time","thisArg","startTimer","pendingFunc","shouldInvoke","timeSinceLastCall","timerExpired","trailingEdge","timeSinceLastInvoke","timeWaiting","min","remainingWait","debounced","isInvoking","_len","_key","leadingEdge","max","cancel","cancelAnimationFrame","cancelTimer","flush","pending","computedRepresentations","computeAndAddRepresentation","computeFunction","updateFunction","addRepresentationData","_debouncedUpdateFunction","_debouncedSegmentationModified","subscribeToSegmentationChanges","debounce","POLYSEG_CONTOUR_TO_SURFACE","unshift","setColorLUT","getColorForSegmentIndex","colorValue","setColorForSegmentIndex","color","colorReference","createAndCacheSurfacesFromRaw","rawSurfacesData","promises","rawSurfaceData","closedSurface","polys","geometryLoader","geometryData","all","POLYSEG_CONTOUR_TO_LABELMAP","convertContourToVolumeLabelmap","contourRepresentationData","imageIds","segmentationVolumeId","volumeProps","dimensions","origin","spacing","scalarData","segmentationVolume","volumeLoader","referencedImageIds","annotationUIDsInSegmentMap","_getAnnotationMapFromSegmentation","newScalarData","imageData","getPointData","getScalars","setData","modified","convertContourToStackLabelmap","getImageIds","segmentationImageIds","imageLoader","segmentationsInfo","segImageId","_columnCosines","_rowCosines","_rowPixelSpacing","_columnPixelSpacing","_imagePositionPatient","segImage","imagePlaneModule","metaData","columnCosines","rowCosines","rowPixelSpacing","columnPixelSpacing","imagePositionPatient","rowCosineVec","vec3","colCosineVec","scanAxisNormal","width","height","newSegmentationsScalarData","referencedImageId","_segImage$imageFrame","segmentationInfo","imageFrame","pixelData","_options$segmentIndic","annotationMap","annotationUIDsInSegment","uids","hasChildAnnotations","polyline","contour","holesPolyline","POLYSEG_SURFACE_TO_LABELMAP","createImageIdReferenceMap","imageIdsArray","computeStackSegmentationFromVolume","isAllImagesCached","imageCacheOffsetMap","every","volumeUsedInOtherViewports","getVolumeViewports","hasVolumeId","decache","_segmentationVolume$a","_segmentationVolume$r","additionalDetails","reverse","_referencedVolume$ima","_referencedVolume$ima2","_segmentationImageIds","referencedVolumeId","referencedVolume","segmentationImageIdsToUse","convertToImageSlicesAndCache","_getImageIdReferenceMapForStackSegmentation","convertVolumeToStackSegmentation","LABELMAP","removeOriginal","addSegmentationRepresentations","triggerSegmentationRender","updateStackSegmentationState","computeAndAddLabelmapRepresentation","rawLabelmapData","_options$segmentIndic2","isVolume","convertFunction","computeLabelmapFromContourSegmentation","_options$segmentIndic3","segmentsGeometryIds","defaultActor","getDefaultActor","surfaceRepresentationData","segmentsInfo","getPoints","getPolys","convertSurfaceToVolumeLabelmap","computeLabelmapFromSurfaceSegmentation","computeLabelmapData","labelMapConfigCache","getRepresentationRenderingConfig","cfun","vtkColorTransferFunction","ofun","vtkPiecewiseFunction","addPoint","polySegConversionInProgress","_getLabelmapConfig","toolGroupLabelmapConfig","segmentationRepresentationLabelmapConfig","isActiveLabelmap","segmentsLabelmapConfig","configToUse","outlineWidth","_needsTransferFunctionUpdate","segmentColor","cacheUID","oldConfig","forceOpacityUpdate","forceColorUpdate","oldFillAlpha","oldRenderFill","oldRenderOutline","oldOutlineWidth","oldSegmentColor","oldSegmentsHidden","_addLabelmapToViewport","labelMapData","volumeInputs","blendMode","addVolumesToViewports","stackInputs","addImageSlicesToViewports","addLabelmapToElement","render","toolGroupConfig","renderingConfig","Representations","getActor","_labelmapData","StackViewport","labelmapUID","defaultActorUID","volume","isSameFrameOfReference","numColors","_segmentSpecificConfi","segmentSpecificLabelmapConfig","addRGBPoint","segmentOpacity","removePoint","addPointLong","getProperty","setRGBTransferFunction","setClamping","setScalarOpacity","setInterpolationTypeToNearest","setUseLabelOutline","setLabelOutlineOpacity","outlineWidths","setLabelOutlineThickness","setVisibility","_setLabelmapColorAndOpacity","renderImmediate","getToolGroup","removeLabelmapFromElement","_removeLabelmapFromToolGroupViewports","getViewportsInfo","getRepresentationSpecificConfig","representationInput","getLabelmapRenderingConfig","getSvgNode","canvasHash","cacheKey","domRef","appendNode","svgLayerElement","svgNode","touched","appendChild","setNodeTouched","clearUntouched","cacheEntry","removeChild","fn","svgDrawingHelper","viewportElement","querySelector","_getSvgLayer","svgNodeCacheForCanvas","getSvgDrawingHelper","getToolsWithModesForElement","modesFilter","ToolGroupManager","enabledTools","toolInstance","getToolInstance","Active","Passive","Enabled","annotationRenderingEngine","_throwIfDestroyed","elements","_viewportElements","_needsRender","_triggerRender","_animationFrameSet","_animationFrameHandle","_render","addViewportElement","removeViewportElement","_reset","renderViewport","_setViewportsToBeRenderedNextFrame","hasBeenDestroyed","_setAllViewportsToBeRenderedNextFrame","_renderFlaggedViewports","elementsEnabled","getRenderingEngine","drawSvg","anyRendered","tool","renderAnnotation","rendered","viewportIdsToRender","getViewport","triggerAnnotationRender","representationInputArray","toolGroupSpecificRepresentationConfig","toolGroupSpecificConfig","_representationInput$","colorLUTIndexToUse","colorLUTOrIndexInput","colorLUTOrIndex","nextIndex","CORNERSTONE_COLOR_LUT","getColorLUTIndex","toolGroupSpecificRepresentation","currentToolGroupConfig","SegmentationConfig","mergedConfig","addSegmentationRepresentationToState","triggerAnnotationRenderForViewportIds","computeVolumeSegmentationFromStack","_options$volumeId","convertStackToVolumeSegmentation","updateSegmentationState","POLYSEG_LABELMAP_TO_SURFACE","computeSurfaceFromLabelmapSegmentation","labelmapRepresentationData","results","convertLabelmapToSurface","surfaces","allSettled","errors","status","computeAndAddSurfaceRepresentation","polylines","numPointsArray","annotationUIDs","convertContourToSurface","computeSurfaceFromContourSegmentation","computeSurfaceData","surfacesObj","setPoints","setPolys","updateSurfaceData","VolumeViewport3D","SurfaceData","setColor","_viewport$getActor","getSurfaceActorUID","surfaceActor","surfaceMapper","getMapper","currentPolyData","getInputData","newPoints","newPolys","getData","currentPolys","polyData","vtkPolyData","triangles","vtkCellArray","Float32Array","setInputData","getRenderer","resetCameraClippingRange","getColor","surfacePolyData","mapper","vtkMapper","vtkActor","setMapper","setLineWidth","addActor","clippingFilter","resetCamera","addOrUpdateSurfaceToElement","removeSurfaceFromElement","_removeSurfaceFromToolGroupViewports","contourRepresentation","segmentId","_contourRepresentatio","_contourRepresentatio2","configCachePerSegmentationRepresentationUID","getConfigCache","setConfigCache","addContourSetsToElement","contourRepresentationConfig","contourActorUID","appendPolyData","vtkAppendPolyData","scalarToColorMap","segmentSpecificMap","validateGeometry","contourSet","pointArray","vtkPoints","pointIndex","getContours","pointList","flatPoints","getFlatPointsArray","getType","pointIndexes","_","pointListIndex","linePoints","insertNextCell","polygon","setLines","getPolyData","getNumberOfPoints","scalars","vtkDataArray","numberOfComponents","dataType","setTuple","setScalars","addInputData","polyDataOutput","getOutputData","setForceOpaque","updateVTKContourSets","newContourConfig","cachedConfig","contourSetsActor","newOutlineWithActive","lut","getLookupTable","segmentsToSetToInvisible","segmentsToSetToVisible","mergedInvisibleSegments","contourSets","segmentSpecificConfigs","acc","affectedSegments","hasCustomSegmentSpecificConfig","polyDataModified","appendScalarsData","getTotalNumberOfPoints","segmentConfig","setLookupTable","extractContourData","segmentIndexMap","rawResults","intersectionInfo","CalibrationTypes","PIXEL_UNITS","SUPPORTED_REGION_DATA_TYPES","SUPPORTED_LENGTH_VARIANT","SUPPORTED_PROBE_VARIANT","UNIT_MAPPING","SQUARE","getCalibratedLengthUnitsAndScale","image","handles","calibration","hasPixelSpacing","units","areaUnits","scale","calibrationType","sequenceOfUltrasoundRegions","UNCALIBRATED","_regions","imageIndex1","imageIndex2","regions","region","regionLocationMinX0","regionLocationMaxX1","regionLocationMinY0","regionLocationMaxY1","regionDataType","physicalUnitsXDirection","physicalUnitsYDirection","physicalDeltaX","physicalDeltaY","ERMF","USER","ERROR","PROJECTION","getCalibratedProbeUnitsAndValue","imageIndex","supportedRegionsMetadata","referencePixelX0","referencePixelY0","yValue","getCalibratedAspect","_image$calibration","aspect","getAABB","polylineToUse","numDimensions","is3D","currentPolyline","totalPoints","len","minX","Infinity","minY","maxX","maxY","minZ","maxZ","z","getAnnotationNearPoint","proximity","getAnnotationNearPointOnEnabledElement","_toolInstances","found","findAnnotationNearPointByTool","_viewport$getCurrentI","currentId","isPointNearTool","getHandleNearImagePoint","val","low","high","calibratedPixelSpacingMetadataProvider","calibrateImageSpacing","calibrationOrScale","getStackViewports","calibrateSpacing","scroll","viewportType","scrollSlabs","debounceLoading","loop","useSlabThickness","numScrollSteps","currentStepIndex","sliceRangeInfo","sliceRange","spacingInNormalDirection","focalPoint","position","newFocalPoint","newPosition","setCamera","desiredStepIndex","VolumeScrollEventDetail","currentImageId","EVENTS","scrollVolume","VideoViewport","currentImageIndex","numberOfSlices","getTargetImageIdIndex","getCurrentImageIdIndex","_getImageSliceData","imageIndexToJump","clip","_getImageIndexToJump","pointInShapeCallback","pointInShapeFn","callback","boundsIJK","iMin","iMax","jMin","jMax","kMin","kMax","numComps","getDimensions","start","getDirection","getSpacing","rowSpacing","columnSpacing","scanAxisSpacing","worldPosStart","indexToWorld","rowStep","columnStep","scanAxisStep","xMultiple","yMultiple","zMultiple","pointsInShape","currentPos","k","startPosJ","startPosI","pointIJK","pointLPS","EPSILON","CONSTANTS","calculateBoundingBox","_points$","isWorld","xMin","xMax","yMin","yMax","zMin","zMax","_p$","_p$2","getBoundingBoxAroundShapeIJK","getBoundingBoxAroundShapeWorld","clipBounds","transformWorldToIndex","getSphereBoundsInfo","circlePoints","bottom","centerWorld","radiusWorld","topLeftWorld","bottomRightWorld","viewUp","viewRight","_computeBoundsIJKWithCamera","AnnotationFrameRange","imageIdToFrames","frameRangeExtractor","range","it","framesToString","framesToImageId","newRangeString","setFrameRange","eventBase","getFrameRange","pointInSphere","sphere","center","radius","radius2","pointInSurroundingSphereCallback","centerIJK","spacings","minSpacing","maxRadiusIJK","ceil","getBoundingBoxAroundShape","_getBounds","sphereObj","isEqual","getViewportsForAnnotation","getEnabledElements","getViewportForAnnotation","areCoplanarContours","firstAnnotation","secondAnnotation","firstViewPlaneNormal","secondViewPlaneNormal","dot","glMatrix","firstPolyline","secondPolyline","firstDistance","secondDistance","findNextLink","line","contourPoints","cell","nextLine","remainingLines","findContours","firstCell","shift","extraContours","findContoursFromReducedSet","getDeduplicatedVTKPolyDataPoints","bypass","getLines","pointsArray","fill","getPoint","linesArray","getNumberOfCells","getCell","pt","newIndex","processContourHoles","contours","useXOR","retContours","closedContours","contourWithHoles","contourWithoutHoles","holes","hContour","hIndex","outerContour","innerContour","vertices","pointsNotEnclosed","getIsPointInsidePolygon","inside","xi","yi","xj","yj","checkEnclosed","contourHoleSet","holeIndex","contourIndex","Labelmap","generateContourSetsFromLabelmap","segments","segVolumeId","vol","cornerstoneCache","numSlices","pixelsPerSlice","ContourSets","numSegments","segIndex","segment","sliceContours","containedSegmentIndices","isSliceEmptyForSegment","frameStart","_reducedSet$points","setValue","mSquares","vtkImageMarchingSquares","imageDataCopy","vtkImageData","shallowCopy","cValues","setContourValues","setMergePoints","reducedSet","FrameNumber","ContourSet","startIdx","endIdx","RectangleROIStartEndThreshold","getContourSequence","toolData","metadataProvider","projectionPoints","projectionPointsImageIds","ContourData","pointsArrayWithPrecision","ContourImageSequence","sopCommon","ReferencedSOPClassUID","sopClassUID","ReferencedSOPInstanceUID","sopInstanceUID","getContourImageSequence","NumberOfContourPoints","ContourGeometricType","AnnotationToPointData","convert","referenceImageId","validateAnnotation","toolClass","TOOL_NAMES","ContourSequence","ReferencedROINumber","ROIDisplayColor","floor","random","register","getContourHolesDataWorld","getContourHolesDataCanvas","worldHoleContours","canvasHoleContours","worldHoleContour","numPoints","canvasHoleContour","worldToCanvas","distanceToPointSquared","p1","p2","x1","y1","z1","x2","y2","z2","dx","dy","dz","distanceToPointSquaredInfo","lineStart","lineEnd","closestPoint","distanceSquared","math","dotProduct","DEFAULT_EPSILON","decimate","epsilon","epsilonSquared","partitionQueue","polylinePointFlags","numDecimatedPoints","startIndex","endIndex","startPoint","endPoint","maxDistSquared","maxDistIndex","distSquared","mathLine","decimatedPolyline","srcIndex","dstIndex","getSignedArea","refPoint","area","aX","aY","bX","getWindingDirection","updateContourPolyline","polylineData","transforms","_options$decimate","targetWindingDirection","_options$decimate2","closed","polylineWorldPoints","currentWindingDirection","currentClosedState","lastToFirstDist","windingDirection","DEFAULT_CONTOUR_SEG_TOOLNAME","getInterpolationData","viewportData","filterParams","sliceData","interpolationDatas","originalToolName","testToolName","modifiedAnnotations","imageAnnotations","filteredInterpolatedAnnotations","imageAnnotation","parent","parentKey","createPolylineToolData","handlePoints","referencedToolData","highlighted","autoGenerated","interpolationSources","sources","activeHandleIndex","textBox","hasMoved","worldPosition","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","_sliceNeedsInterpolating","interpolationData","_appendInterpolationList","contourPair","interpolationList","itemIndex","list","_getBoundingPair","annotationPair","canInterpolate","PointsManager","addInterval","finish","interval","distance","indexValue","v","round","intersectAABB","aabb1","aabb2","areLineSegmentsIntersecting","q1","q2","line1MinX","line1MinY","line1MaxX","line1MaxY","line2MinX","line2MinY","line2MaxX","line2MaxY","orient","orientation","onSegment","q","orientationValue","getFirstLineSegmentIntersectionIndexes","initialI","intersectPolyline","sourcePolyline","targetPolyline","sourceLen","intersectionPointIndexes","isClosed","numPolylinePoints","distFirstToLastPoints","containsPoint","numIntersections","hole","shouldClose","maxSegmentIndex","intersects","xIntersection","containsPoints","numPoint","getLineSegmentIntersectionsIndexes","intersections","maxI","getNormal2","ORIENTATION_TOLERANCE","isPointOnLineSegment","PARALLEL_LINES_TOLERANCE","getLinesIntersection","diffQ1P1","diffQ2P2","denominator","line1AABB","line2AABB","numerator2","PolylinePointType","PolylinePointPosition","PolylinePointDirection","ensuresNextPointers","polylinePoints","currentPoint","next","getSourceAndTargetPointsList","targetPolylinePoints","sourcePolylinePoints","sourceIntersectionsCache","intersectionPointDirection","Exiting","Entering","pointInside","vertexPoint","Vertex","coordinates","Inside","Outside","visited","intersectionsInfo","intersectedLineSegment","sourceLineSegmentId","intersectionCoordinate","coordinate","targetStartPointDistSquared","mathPoint","right","targetEdgePoint","Intersection","Edge","sourceEdgePoint","Unknown","cloned","sourceIntersectionPoints","lineSegmentId","intersectionPoint","lineSegStartDistSquared","getUnvisitedOutsidePoint","mergePolylines","targetNormal","sourceNormal","dotNormals","mergedPolyline","subtractPolylines","subtractedPolylines","subtractedPolyline","filterViewportsWithFrameOfReferenceUID","numViewports","viewportsWithFrameOfReferenceUID","getFrameOfReferenceUID","filterViewportsWithToolEnabled","viewportsWithToolEnabled","_toolGroupHasActiveEnabledOrPassiveTool","toolMode","EPS","vpCamera","getViewportIdsWithToolToRender","requireParallelNormals","filterViewportsWithParallelNormals","isContourSegmentationAnnotation","_data","areSameSegment","firstSegmentation","secondSegmentation","removeContourSegmentationAnnotation","annotationsUIDsSet","addContourSegmentationAnnotation","addTool","ToolClass","toolAlreadyAdded","removeTool","ContourWindingDirection","isFreehandContourSegToolRegisteredForViewport","silent","PlanarFreehandContourSegmentationTool","errorMessage","hasTool","getToolOptions","convertContourPolylineToCanvasSpace","projectedPolyline","createPolylineHole","targetAnnotation","holeAnnotation","holeWindingDirection","contourSegUtils","updatedToolNames","_linearlyInterpolateBetween","eventData","annotation0","annotation1","c1","_generateClosedContour","c2","c1Interp","c2Interp","cumPerim1","_getCumulativePerimeter","cumPerim2","interpNodes","cumPerim1Norm","_normalisedCumulativePerimeter","cumPerim2Norm","numNodes1","numNodes2","perim1Interp","_getInterpolatedPerim","perim2Interp","perim1Ind","_getIndicatorArray","perim2Ind","nodesPerSegment1","_getNodesPerSegment","nodesPerSegment2","c1i","_getSuperSampledContour","c2i","c1iLength","optimal","startingNode","totalSquaredXYLengths","node","iteration","_shiftCircularArray","I","_shiftSuperSampledContourInPlace","_reduceContoursToOriginNodes","_generateInterpolationContourPair","kIndex","c1HasMoreNodes","zInterp","interpolated3DPoints","c1ir","c2ir","fromXYZ","cInterp","create3","vecSubtract","vecResult","c1Source","c2Source","c1point","c2point","_generateInterpolatedOpenContour","nearestAnnotation","handleCount","destPoints","sourcePoints","subselect","dotValues","prevVec3","nextVec3","prevPoint","nextPoint","createDotValues","minimumRegions","deviation","sum","sumSq","mean","valueDiff","getStats","inflection","minValue","minIndex","findMinimumRegions","lastHandle","thirdInterval","end","midIndex","firstHandle","getPointArray","destSourceIndex","selectHandles","oldAnnotationData","_findExistingAnnotation","interpolatedAnnotation","_editInterpolatedContour","_referencedToolData$o","annotationState","onInterpolationComplete","_addInterpolatedContour","_linearlyInterpolateContour","interpolationUID","arr","slicedArray","c","nodesPerSegment","ci","xSpacing","ySpacing","zSpacing","perimInterp","perimInd","idx","perimIndSorted","indicesOfOriginNodes","elementValue","numFalse","numTrue","numNodes","cumPerimNorm","diff","linspace","cumPerim","cumulativePerimeter","lengthOfSegment","isInterpolationUpdate","queueMicrotask","updateChildInterpolationUID","rangeToInterpolate","first","getRangeToInterpolate","sliceEdited","_getSlicePositionOfToolData","findAnnotationsForInterpolation","toolType","eventDetails","EventTypes","startInterpolation","deleteRelatedAnnotations","interpolationAnnotations","referencedSliceIndex","minInterpolation","maxInterpolation","nonInterpolated","removedAnnotations","annotationToDelete","annotationStateManagement","nextAnnotation","viewportNewData","interpolate","uuidv4","ChangeTypesForInterpolation","InterpolationManager","toolNames","acceptAutoGenerated","selector","interpolationCompleted","getSliceData","getNumberOfSlices","acceptAutogeneratedInterpolations","_class","_interpolationAnnotat","hasInterpolationUID","filterData","interpolatedDataCollection","getInterpolationDataCollection","skipUIDs","interpolationAnnotation","findHandlePolylineIndex","handleIndex","handle","closestDistance","closestIndex","testIndex","perimeter","point2","firstPoint","lastPoint","StrategyCallbacks","strategySpecificConfiguration","centerSegmentIndex","previewSegmentIndex","segmentationVoxelManager","imageVoxelManager","segmentationImageData","preview","useCenterSegmentIndex","hasSegmentIndex","hasPreviewIndex","isInObject","existingValue","getAtIJKPoint","operationName","THRESHOLD","isDynamic","threshold","oldThreshold","dynamicRadius","useDelta","nestedBounds","ijk","gray","_strategySpecificConf","centerCanvas","clientWidth","clientHeight","radiusInWorld","offSetCenterInWorld","coord","offSetCenterCanvas","dynamicRadiusInCanvas","lpad","character","join","seed","onFlood","onBoundary","equals","diagonals","startNode","permutations","perms","permutation","parseInt","permute","perm","countNonZeroes","flooded","visits","bounds","currentArgs","flood","boundaries","job","getArgs","prevArgs","previousArgs","iKey","markAsVisited","member","markAsFlooded","nextArgs","pushAdjacent","markAsBoundary","determineSegmentIndex","dynamicThreshold","erase","islandRemoval","previewVoxelManager","clickedPoints","getBoundsIJK","bound","floodedSet","toIndex","oldVal","getAtIndex","isIn","floodedCount","setAtIJK","clickedPoint","floodFill","clearedCount","previewCount","trackValue","setAtIJKPoint","islandMap","isInternal","internalSet","onFloodInternal","floodIndex","toIJK","setAtIndex","getArrayOfSlices","_this$onInteractionSt","previewColors","onInteractionStart","_this$onInteractionEn","isPreviewFromHover","onInteractionEnd","sourceVoxelManager","configColor","factor","lightenColor","_preview$segmentIndex","tracking","modifiedSlices","regionFill","_brushStrategy$create","brushStrategy","isWithinThreshold","createIsInThreshold","oldValue","useSegmentIndex","THRESHOLD_INSIDE_CIRCLE","voxelValue","VoxelManager","getStrategyData","segmentationScalarData","imageScalarData","imageDimensions","segmentationDimensions","voxelManager","imageVolume","_segmentationImage$ge","currentSegmentationImageId","segmentationImage","columns","rows","createVolumeVoxelManager","BrushStrategy","initializedData","initialize","_fill","_onInteractionStart","configurationName","initializers","compositions","initializer","childFunctions","strategyFunction","_operationData$previe","createHistoryVoxelManager","_initialize","addListMethod","createInitialized","listName","addSingletonMethod","isInitialized","getCanvasEllipseCorners","ellipseCanvasPoints","pointInEllipse","ellipse","inverts","precalculated","precalculatePointInEllipse","xRadius","yRadius","zRadius","invXRadiusSq","invYRadiusSq","invZRadiusSq","centerL","centerP","centerS","initializeCircle","canvasCoordinates","topLeftCanvas","bottomRightCanvas","createPointInEllipse","worldInfo","ellipseObj","CIRCLE_STRATEGY","CIRCLE_THRESHOLD_STRATEGY","fillInsideCircle","thresholdInsideCircle","sphereComposition","newBoundsIJK","createEllipseInPoint","SPHERE_STRATEGY","fillInsideSphere","thresholdInsideSphere","eraseInsideSphere","eraseInsideCircle","drawingElementType","nodeUID","attributes","currentValue","getAttribute","removeAttribute","setAttribute","circleUID","dataId","lineWidth","lineDash","fillOpacity","strokeOpacity","strokeWidth","svgNodeHash","_getHash","existingCircleElement","cx","cy","stroke","setAttributesIfNecessary","newCircleElement","createElementNS","setNewAttributesIfValid","DEFINED_CURSORS","STANDARD_CURSORS","MouseCursor","fallback","getName","addFallbackStyleProperty","style","getStyleProperty","getDefinedCursor","definedCursors","getDefinedCursors","mouseCursor","setDefinedCursor","cursor","context","standardCursorNames","ELEMENT_CURSORS_MAP","initElementCursor","_getElementCursors","_setElementCursor","cursors","resetElementCursor","hideElementCursor","getActiveSegmentationRepresentation","getActiveSegmentation","activeRepresentation","isSegmentIndexLocked","setSegmentIndexLocked","getLockedSegments","invalidateBrushCursor","getBrushToolInstances","viewportsInfoArray","viewportIds","getViewportIds","setActiveSegmentIndex","getActiveSegmentIndex","BrushTool","super","FILL_INSIDE_CIRCLE","ERASE_INSIDE_CIRCLE","FILL_INSIDE_SPHERE","ERASE_INSIDE_SPHERE","THRESHOLD_INSIDE_SPHERE","thresholdVolumeId","brushSize","previewTimeMs","previewMoveDistance","dragMoveDistance","dragTimeMs","actions","method","bindings","timerStart","timer","NaN","isDrag","disableCursor","_editData","createEditData","_activateDraw","_previewData","hoverData","_hoverData","createHoverData","triggerAnnotationRenderForViewportUIDs","getOperationData","updateCursor","vec2","rejectPreview","previewCallback","_deactivateDraw","acceptPreview","_endCallback","_dragCallback","activeSegmentationRepresentation","activeSegmentation","segmentLocking","segmentationState","_volumes$find","_volumes$","_this$configuration$t","actors","CustomEvent","message","cancelable","volumes","referenceId","referencedVolumeIdToThreshold","getActiveSegmentationData","brushCursor","segmentIndexController","_calculateCursor","_data$handles","_this$_previewData","editData","centerCursorInWorld","bottomCursorInWorld","topCursorInWorld","leftCursorInWorld","rightCursorInWorld","strategy","computeInnerCircleRadius","_toolMetadata$segment","toolMetadata","brushCursorUID","drawCircleSvg","toolInstances","getVoxelOverlap","voxelSpacing","voxelCenter","voxelCornersWorld","processVolumes","thresholdVolumeInformation","segmentationSpacing","volumeInfoList","baseVolumeIdx","volumeSize","referenceValues","lower","upper","equalsCheck","overwrite","overlapType","overlaps","testOverlapRange","volumeInfo","overlapBounds","overlapTest","testRange","computeOffsetIndex","insert","handleGroupUID","uniqueIndex","opacity","side","rx","existingHandleElement","newHandleElement","drawHandle","drawRect","rectangleUID","_width","existingRect","tlhc","svgRectElement","PARALLEL_THRESHOLD","filterAnnotationsWithinSlice","annotationsWithParallelNormals","td","annotationViewPlaneNormal","imageOrientationPatient","isParallel","halfSpacingInNormalDirection","annotationsWithinSlice","dir","filterAnnotationsForDisplay","filterOptions","colonIndex","substring","isCanvasAnnotation","isReferenceViewable","_initializeConfig","colorHighlighted","colorSelected","colorLocked","shadow","textBoxVisibility","textBoxFontFamily","textBoxFontSize","textBoxColor","textBoxColorHighlighted","textBoxColorSelected","textBoxColorLocked","textBoxBackground","textBoxLinkLineWidth","textBoxLinkLineDash","textBoxShadow","getAnnotationToolStyles","getViewportToolStyles","getToolGroupToolStyles","getDefaultToolStyles","default","setAnnotationStyles","styles","annotationSpecificStyles","setViewportToolStyles","viewportSpecificStyles","setToolGroupToolStyles","toolGroupSpecificStyles","setDefaultToolStyles","toolStyle","specifications","_getToolStyle","property","annotationToolStyles","viewportToolStyles","global","toolGroupToolStyles","globalStyles","toolStyles","styleSpecifier","alternatives","getHierarchalPropertyStyles","AnnotationStyleStates","AnnotationDisplayTool","getFramesOfReference","frameOfReference","filterInteractableAnnotationsForElement","getReferencedImageId","worldPos","getStyle","AnnotationTool","createAnnotation","text","annotationBaseData","baseData","createAnnotationForViewport","_len2","_key2","getViewReference","createAndAddAnnotation","_len3","_key3","_toolProps$configurat","_toolProps$configurat2","filteredAnnotations","canvasCoords","annotationsNeedToBeRedrawn","activateHandleIndex","near","_imagePointNearToolOrHandle","nearToolAndNotMarkedActive","notNearToolAndMarkedActive","getTextLines","statsCalculator","canvasBoundingBox","annotationCanvasCoordinate","getLinkedTextBoxStyle","fontFamily","fontSize","background","isSuvScaled","_volume$scaling","scaling","PT","scalingModule","suvbw","getAnnotationStyle","lineOpacity","fillColor","textbox","_createTextSpan","textSpanElement","textContent","_drawTextBackground","group","getBBox","insertBefore","firstChild","bBox","textUID","textLines","padding","textGroupBoundingBox","existingTextGroup","textElement","textSpans","textSpan","textAttributes","textGroupAttributes","textGroup","dropShadowStyle","combinedStyle","_createTextElement","_drawTextGroup","centerX","centerY","drawLine","lineUID","isNaN","existingLine","newLine","findClosestPoint","targetPoint","minPoint","minDistance","sourcePoint","_distanceBetween","textBoxUID","textBoxPosition","annotationAnchorPoints","mergedOptions","centering","drawTextBox","linkUID","boundingBox","halfWidth","halfHeight","_boundingBoxPoints","drawLink","distanceToPoint","lineSegments","rectToLineSegments","lineSegment","getTextBoxCoordsCanvas","annotationCanvasPoints","corners","canvasPoints","handlesLeftToRight","handlesTopToBottom","_determineCorners","getWorldWidthAndHeightFromCorners","pos1","pos2","diagonal","diagonalLength","worldWidth","worldHeight","cosTheta","getModalityUnit","modality","isPreScaled","generalSeriesModule","petSeriesModule","_handlePTModality","isViewportPreScaled","targetIdTokens","preScale","scaled","Calculator","BasicStatsCalculator","singleArrayAsNumber","sumSquares","squaredDiffSum","newArray","stdDev","stdDevWithSumSquare","named","unit","RectangleROITool","preventHandleOutsideImage","defaultGetTextLines","isDrawing","movingTextBox","newAnnotation","canvasPoint1","canvasPoint2","_getRectangleImageCoordinates","rectangle","_activateModify","_deactivateModify","isHandleOutsideImage","worldPosDelta","bottomLeftCanvas","topRightCanvas","bottomLeftWorld","topRightWorld","_annotations","_annotations2","renderStatus","areaUnit","_throttledCalculateCachedStats","referencedImageURI","hasImageURI","currentImageURI","Modality","_calculateCachedStats","activeHandleCanvasCoords","drawHandlesSvg","drawRectSvg","canvasTextBoxCoords","drawLinkedTextBoxSvg","worldPos1","worldPos2","targetIds","pos1Index","pos2Index","_isInsideVolume","_stats$mean","_stats$stdDev","_stats$max","modalityUnitOptions","modalityUnit","statsCallback","stats","getStatistics","statsArray","index1","index2","throttle","cachedVolumeStats","roundNumber","RectangleROIThresholdTool","RectangleROIStartEndThresholdTool","numSlicesToPropagate","computePointsInsideVolume","spacingInNormal","_getEndSliceIndex","startSlice","endSlice","pointsInVolume","_computeProjectionPoints","calculatePointsInsideVolume","_computePointsInsideVolume","firstOrLastSlice","lineDashToUse","_calculateCachedStatsTool","startIJK","endIJK","startWorld","indexToWorldVec3","endWorld","newProjectionPoints","dist","newPoint","RectanglePoints","pointsInsideVolume","projectionPoint","worldPos1Index","worldProjectionPointIndex","worldPos2Index","endPos","imageIdIndex","numSlicesToProject","sliceNormalIndex","referenceVolume","AllBoundsIJK","_data$cachedStats","_data$cachedStats2","pointsToUse","extend2DBoundingBoxInViewAxis","validToolNames","_validateAnnotations","getBoundsIJKFromRectangleAnnotations","outputSegmentationVolume","thresholdVolumeByRange","labelmaps","labelmap","outputData","arrayType","isValidRepresentationConfig","SegmentationRepresentation","isValidLabelmapConfig","getDefaultRepresentationConfig","createLabelmapVolumeForViewport","properties","setBrushSizeForToolGroup","getBrushSizeForToolGroup","brushToolInstance","setBrushThresholdForToolGroup","otherArgs","brushBasedToolInstances","getBrushThresholdForToolGroup","segmentationIndex","_handleSameSizeVolume","callbackOverlap","_handleDifferentSizeVolume","isLineInSegment","isInSegment","ijk1","ijk2","testPoint","testIJK","testSize","unitDelta","createBidirectionalForSlice","sliceContour","currentMax","maxMajor","maxMinor","currentMaxMinor","currentMaxMajor","maxMajorPoints","distance2","testCenter","handle0","handle1","unitMajor","maxMinorPoints","majorAxis","minorAxis","contourAndFindLargestBidirectional","maxBidirectional","worldToIndex","createIsInSegment","bidirectional","findLargestBidirectional","createBidirectionalToolData","bidirectionalData","major0","major1","minor0","minor1","sign","intersectLine","line1Start","line1End","line2Start","line2End","x3","y3","x4","y4","a1","b1","r3","r4","a2","b2","r1","r2","denom","num","BidirectionalTool","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","currentShortAxisVector","shortAxis","canvasCoordPoints","shortAxisDistFromCenter","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","angle","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","cos","sin","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","_dragDrawCallback","_dragModifyCallback","dataId1","dataId2","drawLineSvg","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos3","worldPos4","index3","index4","handles1","handles2","scale1","units1","scale2","units2","dist1","_calculateLength","dist2","lengthUnit","widthUnit","vector1","vector2","atan2","addNewAnnotation","segmentContourAction","configurationData","getSegment","defaultGetSegment","segmentationsList","bidirectionals","hasExistingActiveSegment","existingLargestBidirectionals","existingBidirectionalItem","newBidirectional","existingLargestBidirectional","updateSegment","bidirectionalToolData","annotationConfig","jumpToSlice","_configuration$segmen","_configuration$segmen2","segmentData","projectTo2D","sharedDimensionIndex","testPoints","points2D","firstDim","secondDim","isPointInsidePolyline3D","projectedHoles","hole2D","getSegmentAtWorldPoint","worldPoint","_options$representati","desiredRepresentation","getScalarValueFromWorld","segmentationActor","indexIJK","getSegmentAtWorldForLabelmap","annotationsSet","getSegmentAtWorldForContour","getSegmentAtLabelmapBorder","searchRadius","onEdge","isSegmentOnEdge","getNeighborIndex","deltaI","deltaJ","neighborCanvas","isSegmentOnEdgeCanvas","deltaK","neighborIJK","getAtIJK","isSegmentOnEdgeIJK","neighborRange","neighborIndex","getHoveredContourSegmentationAnnotation","aabbWidth","aabbHeight","aabbSize","aabbCenter","translatedPoint","mirror","mirrorPoint","staticPoint","getArea","getNormal3","vecArea","aZ","bY","bZ","_getAreaVector","getLineSegmentIntersectionsCoordinates","polylineIndexes","intersection","getClosestLineSegmentIntersection","initialQ2Index","p2Index","q2Index","distances","intersectionPoints","midpoint","getSubPixelSpacingAndXYDirections","subPixelResolution","xDir","yDir","volumeSpacing","iVector","jVector","kVector","absViewRightDotI","absViewRightDotJ","absViewRightDotK","absViewUpDotI","absViewUpDotJ","absViewUpDotK","pointsAreWithinCloseContourProximity","closeContourProximity","addCanvasPointsToArray","newCanvasPoint","commonData","log","lastWorldPos","newWorldPos","worldPosDiff","xDist","yDist","numPointsToAdd","lastCanvasPoint","canvasDist","canvasDir","distPerPoint","pointCanProjectOnLine","p1p","p1p2","p1p2Mag","projectionVectorMag","p1p2UnitVector","projectionVector","INSIDE","OUTSIDE","clipT","tE","tL","t","box","da","db","getPointInLineOfSightWithCriteria","targetVolumeId","criteriaFunction","stepSize","cameraPosition","step","getBounds","vector","pickedPoint","vtkMath","pointT","_inBounds","pointToPick","getIntensityFromWorld","isPlaneIntersectingAABB","normal","normalVec","originVec","planeDistance","initialSign","vertex","getOrientationStringLPS","orientationX","orientationY","orientationZ","MIN","invertOrientationStringLPS","orientationString","inverted","toUpperCase","addToolState","getToolState","ViewportStatus","dynamicVolumesPlayingMap","playClip","playClipOptions","_playClipOptions$dyna","playClipTimeouts","playClipIsTimeVarying","dynamicCineEnabled","_getVolumeFromViewport","playClipContext","_playClipOptions$wait","waitForRendered","frameTimeVectorEnabled","waitForRenderedCount","viewportStatus","RENDERED","_createStackViewportCinePlayContext","isDynamicVolume","numTimePoints","timePointIndex","_createDynamicVolumeViewportCinePlayContext","cachedScrollInfo","scrollInfo","getScrollInfo","volumeViewPlaneNormal","_createVolumeViewportCinePlayContext","_createCinePlayContext","playClipData","isDynamicCinePlaying","_playClipOptions$fram","_playClipOptions$fram2","_playClipOptions$reve","_playClipOptions$loop","_stopDynamicVolumeCine","_stopClip","stopDynamicCine","intervalId","framesPerSecond","lastFrameTimeStamp","ignoreFrameTimeVector","usingFrameTimeVector","frameTimeVector","speed","frameTimeVectorSpeedMultiplier","timeouts","isTimeVarying","sample","delay","limit","_getPlayClipTimeouts","playClipAction","newStepIndex","newStepIndexOutOfRange","CINE_EVENTS","playClipTimeoutHandler","setInterval","stopClip","toolState","getToolStateByViewportId","clearInterval","_stopClipWithData","dynamicCineElement","_getVolumesFromViewport","dynamicVolume","v1","v2","v0","v3","t1","t2","t3","basis","interpolator","samples","zip","matrix","valueof","transpose","row","interpolateSegmentPoints","iniIndex","knotsRatioPercentage","_Math$floor","_Math$floor2","segmentSize","amountOfKnots","minKnotDistance","interpolationIniIndex","interpolationEndIndex","segmentPointsUnchangedBeg","segmentPointsUnchangedEnd","originalPoints","knotsIndexes","xInterpolator","d3InterpolateBasis","yInterpolator","zInterpolator","d3Zip","d3Quantize","interpolatePoints","minDistributionDistance","closedInterval","intervalIni","intervalEnd","intervalSize","intensity","continuosDistributionValue","getContinuousUniformDistributionValues","smoothAnnotation","_annotation$data","PlanarFreehandROITool","isEditingOpen","isEditingClosed","shouldPreventInterpolation","interpolatedCanvasPoints","axisList","isAxisAlignedRectangle","rectangleCornersIJK","rectangleVec1","rectangleVec2","calculateAnglesWithAxes","vec","axes","axis","PI","requestType","priority","lowEnd","highEnd","getStackData","currentImageIdIndex","getPromiseRemovedHandler","stackData","stackPrefetchData","indicesToRequest","clearFromImageIds","imageIdSet","requestDetails","resetPrefetchTimeout","maxImagesToPrefetch","preserveExistingPool","prefetch","_stack$imageIds","_stackPrefetch$indice","stackPrefetch","removeFromList","imageLoadPoolManager","nearest","nearestIndex","nextImageIdIndex","lowerIndex","higherIndex","imageIdsToPrefetch","currentIndex","shouldLoadLower","shouldLoadHigher","requestFn","useNorm16Texture","preferSizeOverAccuracy","getCoreConfiguration","rendering","useNativeDataType","targetBuffer","onImageUpdated","target","indexOfCurrentImage","promiseRemovedHandler","getConfiguration","minBefore","maxAfter","directionExtraImages","indicesToRequestCopy","then","_image$image","decodeTimeInMS","_image$image2","loadTimeInMS","sizeInBytes","usage","cacheFill","fillTime","fillSize","initialTime","initialSize","updateToolState","doneCallback","stackCount","totalBytes","positionFraction","maxIndex","jumpToWorld","jumpWorld","dotProd","projectedDelta","_applyShift","frames","frameNumbers","maskVolumeId","imageCoordinate","dataInTime","ijkCoords","maskImageData","segScalarData","nonZeroVoxelIndices","actualLen","dynamicVolumeScalarDataArray","getScalarDataArrays","indexValues","frame","activeScalarData","segPointLPS","segValue","segPointIJK","overlapIJKMinMax","perFrameSum","averageValues","_getTimePointDataMask","allScalarData","scalarIndex","_getTimePointDataCoordinate","operation","numFrames","typedArrays","arrayLength","finalArray","currentArray","idx3","getPolyDataPointIndexes","linesData","findStartingPoint","getPolyDataPoints","contoursIndexes","rawPointsData","contourIndexes","ColorbarRangeTextPosition","isRangeValid","areColorbarRangesEqual","isColorbarSizeValid","areColorbarSizesEqual","clamp","ColorbarCanvas","validateProps","colormap","imageRange","voiRange","container","showFullPixelValueRange","_colormap","_imageRange","_voiRange","_showFullImageRange","_canvas","_createRootElement","appendTo","_setCanvasSize","showFullImageRange","dispose","parentElement","createElement","pointerEvents","boxSizing","isConnected","RGBPoints","rgbPoints","colorsCount","getColorPoint","canvasContext","getContext","isHorizontal","maxValue","windowWidth","previousColorPoint","currentColorPoint","incRawPixelValue","rawPixelValue","tVoiRange","normColor","tColorRange","fillStyle","fillRect","interpolateVec3","DEFAULTS","FONT","COLOR","TICK_SIZE","TICK_WIDTH","TICK_LABEL_MARGIN","MAX_NUM_TICKS","TICKS_STEPS","ColorbarTicks","_ticksStyle$font","_ticksStyle$color","_ticksStyle$tickSize","_ticksStyle$tickWidth","_ticksStyle$labelMarg","_ticksStyle$maxNumTic","ticks","ticksProps","ticksStyle","rangeTextPosition","_font","font","_color","_tickSize","tickSize","_tickWidth","tickWidth","_labelMargin","labelMargin","_maxNumTicks","maxNumTicks","_rangeTextPosition","Right","_showFullPixelValueRange","_createCanvasElement","showFullRange","display","_getTicks","roughStep","stepPower","log10","roughtStepNormalized","scaleMax","scaleMin","ticksCount","_getLeftTickInfo","labelMeasure","labelPoint","tickPoints","_getRightTickInfo","_getTopTickInfo","_getBottomTickInfo","_ref4","maxCanvasPixelValue","rangeWidth","clearRect","textBaseline","strokeStyle","tick","measureText","tickInfo","Top","Left","tickStart","tickEnd","beginPath","moveTo","lineTo","fillText","Widget","contentRect","contentBoxSize","inlineSize","blockSize","_containerSize","onContainerResize","_id","_rootElement","createRootElement","_containerResizeObserver","ResizeObserver","_containerResizeCallback","rootElement","resizeObserver","currentContainer","unobserve","observe","destroy","disconnect","containerSize","classList","MULTIPLIER","RANGE_TEXT_POSITION","TICKS_BAR_SIZE","Colorbar","_props$ticks$position","_props$ticks","_isMouseOver","showTicks","hideTicks","_isInteracting","_addVOIEventListeners","initialState","multipliers","getVOIMultipliers","_getPointsFromMouseEvent","startVOIRange","canvasDelta","local","wwDelta","wcDelta","voiLower","voiUpper","windowCenter","newVoiRange","_removeVOIEventListeners","_eventListenersManager","_colormaps","getColormapsMap","_activeColormapName","getInitialColormapName","_createCanvas","_ticksBar","_createTicksBar","_addRootElementEventListeners","activeColormapName","colormapName","currentVoiRange","onVoiChange","reset","updateTicksBar","colormaps","items","Name","cm","containerWidth","containerHeight","ticksBar","colorbarWidth","colorbarHeight","Bottom","isRangeTextPositionValid","ticksBarTop","ticksBarLeft","_mouseOverCallback","_mouseOutCallback","_mouseDownCallback","initialDragState","_mouseUpCallback","_mouseDragCallback","defaultImageRange","ViewportColorbar","_getImageRange","_getVOIRange","_hideTicksTimeoutId","timeLeft","_hideTicksTime","autoHideTicks","_element","_volumeId","showAndAutoHideTicks","_addCornerstoneEventListener","ptMultiplier","fixedPTWindowWidth","xMultiplier","setProperties","viewportsContainingVolumeUID","getRange","volumeActor","getRGBTransferFunction","IMAGE_VOLUME_MODIFIED","_imageVolumeModifiedCallback","STACK_NEW_IMAGE","_stackNewImageCallback","VOI_MODIFIED","_viewportVOIModifiedCallback","COLORMAP_MODIFIED","_viewportColormapModifiedCallback","shouldSmooth","_configuration$smooth","_configuration$smooth2","smoothing","smoothOnAdd","smoothOnEdit","followingIndex","circularFindNextIndexBy","listParams","otherListParams","criteria","indexDelimiter","otherIndexDelimiter","otherPoints","pointsLength","otherPointsLength","otherStartIndex","getInterpolatedPoints","pointsOfReference","interpolation","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","changedIniIndex","changedEndIndex","previousPoints","firstMatchIndex","previousFirstMatchIndex","findMatchIndexes","toBeNotEqualCriteria","pointA","pointB","isEqualByProximity","lowDiffIndex","lowOtherDiffIndex","highIndex","findChangedSegment","MouseBindings","KeyboardBindings","shiftKey","ctrlKey","kb","altKey","metaKey","findOpenUShapedContourVectorToPeak","firstToLastUnitVector","normalVector1","normalVector2","centerOfFirstToLast","furthest","activateDraw","canvasPos","getMouseModifierKey","contourHoleAdditionModifierKey","drawData","polylineIndex","mouseUpDrawCallback","mouseDragDrawCallback","deactivateDraw","lastWorldPoint","crossingIndex","findCrossingIndexDuringCreate","applyCreateOnCross","numPointsAdded","allowOpenContours","completeDrawOpenContour","completeDrawClosedContour","removeCrossedLinesOnCompleteDraw","minPointsToSave","haltDrawing","updatedPoints","Clockwise","endToStart","canvasPointsMinusEnds","indexToRemoveUpTo","worldPoints","isOpenUShapeContour","openUShapeContourVectorToPeak","pointsLessLastOne","newArea","activateClosedContourEdit","cancelDrawing","minPoints","shouldHaltDrawing","checkForFirstCrossing","isClosedContour","editCanvasPoints","prevCanvasPoints","crossedLineSegment","startCrossingIndex","removePointsUpUntilFirstCrossing","checkCanvasEditFallbackProximity","firstEditCanvasPoint","distanceIndexPairs","prevCanvasPoint","twoClosestDistanceIndexPairs","lowestIndex","extendedPoint","crossedLineSegmentFromExtendedPoint","pointsToPrepend","editIndex","numPointsToRemove","firstLine","checkForSecondCrossing","removePointsAfterSecondCrossing","lastLine","didCrossLine","findSnapIndex","lastEditCanvasPoint","editCanvasPointsLessLastOne","snapCanvasPosition","checkAndRemoveCrossesOnEditLine","editIndexCrossed","mouseUpClosedContourEditCallback","mouseDragClosedContourEditCallback","deactivateClosedContourEdit","currentEditIndex","snapIndex","fusedCanvasPoints","fuseEditPointsWithClosedContour","finishEditAndStartNewEdit","augmentedEditCanvasPoints","lowIndex","distanceBetweenLowAndFirstPoint","distanceBetweenLowAndLastPoint","distanceBetweenHighAndFirstPoint","distanceBetweenHighAndLastPoint","pointSet1","inPlaceDistance","reverseDistance","pointSet2","completeClosedContourEdit","cancelClosedContourEdit","activateOpenContourEdit","mouseUpOpenContourEditCallback","mouseDragOpenContourEditCallback","deactivateOpenContourEdit","fuseEditPointsWithOpenContour","finishEditOpenOnSecondCrossing","checkIfShouldOverwriteAnEnd","openContourEditOverwriteEnd","fuseEditPointsForOpenContourEndEdit","activateOpenContourEndEdit","lastCanvasPos","p3","aDotb","magA","magB","acos","newCanvasPoints","pointsToRender","completeOpenContourEdit","cancelOpenContourEdit","drawPath","pathUID","pointsArrays","closePath","existingNode","pointsAttribute","numArrays","newNode","drawPolyline","polylineUID","existingPolyLine","newPolyLine","_getRenderingOptions","renderContour","_enabledElement$viewp","renderClosedContour","findOpenUShapedContourVectorToPeakOnRender","calculateUShapeContourVectorToPeakIfNotPresent","renderOpenUShapedContour","renderOpenContour","allContours","drawPathSvg","_this$configuration$a","drawPolylineSvg","alwaysRenderOpenContourHandles","handlePoint","firstCanvasPoint","openUShapeContourVectorToPeakCanvas","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","ContourBaseTool","annotationStyle","annotationRendered","renderAnnotationInstance","viewReference","cancelAnnotation","moveAnnotation","_this$configuration","decimateConfig","getPolylinePoints","_annotation$data$cont","_annotation$data$cont2","renderContext","polylineCanvasPoints","ContourSegmentationBaseTool","_this$configuration$i","isContourSegmentationTool","contourAnnotation","segmentationType","contourSegmentationStyle","_getContourSegmentationStyle","renderResult","triggerAnnotationRenderForToolGroupIds","_globalConfig$represe","_globalConfig$represe2","_toolGroupConfig$repr","_toolGroupConfig$repr2","_segmentationRepresen","_segmentConfig$CONTOU","_getSegmentationRepresentation","annotationLocked","segmentationVisible","segmentVisible","_mergedConfig$outline","_mergedConfig$outline2","_mergedConfig$outline3","_mergedConfig$fillAlp","_mergedConfig$outline4","_mergedConfig$outline5","_mergedConfig$outline6","_mergedConfig$fillAlp2","_mergedConfig$outline7","_mergedConfig$outline8","_mergedConfig$outline9","_mergedConfig$fillAlp3","validSegmentationRepresentations","Shift","makeClockWise","calculateStats","previousPoint","pStart","pEnd","originalWorldPoint","deltaXPoint","deltaYPoint","deltaInX","deltaInY","worldPosIndex","worldPosIndex2","canvasMaxX","canvasMaxY","canvasMinX","canvasMinY","topLeftBBWorld","topLeftBBIndex","bottomRightBBWorld","iDelta","jDelta","kDelta","worldPosEnd","canvasPosEnd","curRow","intersectionCounter","calculatePerimeter","_annotation$annotatio","drawLinkedTextBox","registerDrawLoop","registerEditLoopCommon","registerClosedContourEditLoop","registerOpenContourEditLoop","registerOpenContourEndEditLoop","registerRenderMethods","annotationsToDisplay","activeAnnotationUID","_calculateStatsIfActive","_renderStats","_this$commonData","_this$commonData2","_this$commonData3","isEmptyArea","areaLine","_extractLineSegments","linesNumberOfPoints","pointsInLine","computeAndAddContourRepresentation","_getToolGroupForViewp","rawContourData","segmentIndexToSurfaceId","surfaceIdToSegmentIndex","_cache$getGeometry","computeContourFromSurfaceSegmentation","pointsAndPolys","computeContourFromLabelmapSegmentation","contoursData","contourSegmentationAnnotation","currentSet","createAndAddContourSegmentationsFromClippedSurfaces","getToolGroupForViewport","computeContourData","representationConfig","addOrUpdateVTKContourSets","removeContourFromElement","_removeContourFromToolGroupViewports","deleteConfigCache","planarContourToolName","SegmentationDisplayTool","toolGroupViewports","segmentationRenderList","_getMergedRepresentationsConfig","viewportsRenderList","renderers","labelmapDisplay","contourDisplay","surfaceDisplay","addPlanarFreeHandToolIfAbsent","renderedViewport","onSetToolEnabled","onSetToolDisabled","setToolPassive","segmentationRenderingEngine","removeToolGroup","renderToolGroupSegmentations","_setToolGroupSegmentationToBeRenderedNextFrame","_renderFlaggedToolGroups","segmentationDisplayToolInstance","onSegmentationRender","csToolsEvents","renderSegmentation","perToolGroupManualTriggers","_imageChangeEventListener","_toolGroupSegmentatio","representationList","derivedImageId","setDerivedImage","scalarArray","derivedImage","getImageDataMetadata","currentImage","currentOrigin","originToUse","setOrigin","addImages","imageActor","setDimensions","setSpacing","setDirection","onImageRendered","getToolsWithModesForMouseEvent","evtButton","correctBinding","binding","onCameraModified","onImageSpacingCalibrated","customCallbackHandler","handlerType","customFunction","activeTool","filterToolsWithMoveableHandles","ToolAndAnnotations","toolsWithMoveableHandles","filterToolsWithAnnotationsForElement","filterMoveableAnnotationTools","moveableAnnotationTools","getActiveToolForMouseEvent","mouseEvent","modifierKey","getMouseModifier","keyEventListener","defaultMousePrimary","getDefaultMousePrimary","mouseDown","preMouseDownCallback","isPrimaryClick","applicableTools","toolsWithActions","toolModes","_mouseEvent$buttons","_tool$configuration$a","_tool$configuration","actionsConfig","action","getToolsWithActionsForMouseEvent","mouseDownAnnotationAction","annotationToolsWithAnnotations","annotationToolsWithMoveableHandles","isMultiSelect","getAnnotationForSelection","toggleAnnotationSelection","handleSelectedCallback","toolSelectedCallback","postMouseDownCallback","toolsWithMovableHandles","mouseDownActivate","mouseDrag","mouseDragCallback","mouseMove","activeAndPassiveTools","toolsWithAnnotations","toolsWithoutAnnotations","toolAndAnnotation","mouseMoveCallback","mouseClick","mouseDoubleClick","mouseUp","mouseWheel","getActiveToolForKeyboardEvent","keyDown","setViewportsCursorByToolName","activeToolsWithEventBinding","getToolsWithActionsForKeyboardEvent","keyUp","getActiveToolForTouchEvent","touchEvent","numTouchPoints","getToolsWithModesForTouchEvent","touchStart","preTouchStartCallback","postTouchStartCallback","touchStartActivate","touchDrag","touchDragCallback","touchEnd","touchTap","touchPress","addEnabledElement","svgLayer","svgns","svgLayerId","defs","feOffset","feColorMatrix","feBlend","_createSvgAnnotationLayer","viewportUid","renderingEngineUid","dataset","elementHash","_setSvgNodeCache","mouseEventListeners","wheelEventListener","touchEventListeners","imageChangeEventListener","imageRenderedEventDispatcher","cameraModifiedEventDispatcher","imageSpacingCalibratedEventDispatcher","mouseToolEventDispatcher","keyboardToolEventDispatcher","touchToolEventDispatcher","synchronizersFilteredByIds","synchronizer","notDisabled","isDisabled","hasSourceViewport","hasTargetViewport","elementDisabledEvt","_resetSvgNodeCache","internalViewportNode","_removeSvgNode","getSynchronizersForViewport","sync","remove","_removeViewportFromSynchronizers","removeViewports","_removeViewportFromToolGroup","foundElementIndex","el","_removeEnabledElement","annotationCompletedListener","sourceAnnotation","viewportWithToolRegistered","contourSegmentationAnnotations","sourceAnnotationUID","getValidContourSegmentationAnnotations","targetAnnotationInfo","sourceAABB","aabbIntersect","lineSegmentsIntersect","isContourHole","findIntersectingContour","cstHasTool","contourHolesData","getContourHolesData","unassignedContourHolesSet","reassignedContourHolesMap","assignHoleToPolyline","parentPolyline","holeData","newPolylines","newPolyline","contourHolesDataArray","contourHoleData","_reassignedContourHol","spline","contourUtils","updatedTtoolNames","updateViewports","combinePolylines","contourSegmentationCompleted","annotationRemovedListener","contourSegmentationRemoved","vtkOpenGLTexture","slicesToUpdate","setUpdatedFrame","performVolumeLabelmapUpdate","segImageData","performStackLabelmapUpdate","onLabelmapSegmentationDataModified","handleAnnotationCompleted","handleAnnotationUpdate","handleAnnotationDelete","segmentationRepresentationUIDs","immediate","toolGroupSegRepresentationUIDs","segRepresentationUIDsToRemove","invalidSegRepresentationUIDs","segRepresentationUID","segmentationDataUID","_removeSegmentation","toolGroupIndex","removeSegmentationsFromToolGroup","csToolsState","destroyToolGroup","csToolsInitialized","init","_removeCornerstoneEventListeners","elementEnabledEvent","elementDisabledEvent","removeEnabledElement","annotationInterpolationEventDispatcher","_addCornerstoneEventListeners","_removeCornerstoneToolsEventListeners","TOOLS_EVENTS","annotationModifiedListener","annotationSelectionListener","segmentationModifiedListener","segmentationDataModifiedEventListener","segmentationRepresentationModifiedEventListener","segmentationRepresentationRemovedEventListener","restoreAnnotations","cancelActiveManipulations","toolsWithData","_getViewportIndex","ar","_containsViewport","synchronizerId","eventHandler","_ignoreFiredEvents","_targetViewports","_sourceViewports","fireEvent","_enabled","_eventName","_eventHandler","_options","_auxiliaryEventNames","auxiliaryEventNames","_hasSourceElements","setOptions","_viewportOptions","setEnabled","getOptions","addTarget","addSource","_onEvent","_updateDisableHandlers","getSourceViewports","getTargetViewports","removeSource","removeTarget","_getViewportElement","sourceViewport","sourceEvent","targetViewport","ex","vp1","vp2","unique","vps","_getUniqueViewports","_remove","disableHandler","vUid","Synchronizer","synchronizerIndex","ImageMouseCursor","url","getUniqueInstanceName","prefix","BASE","iconContent","iconSize","viewBox","mousePoint","mousePointerGroupString","SEGMENTATION_CURSOR_BOUNDARIES","MINUS_RECT","PLUS_RECT","SCISSOR_ICON","RECTANGLE_ICON","CIRCLE_ICON","CursorSVG","Angle","extend","ArrowAnnotate","Bidirectional","CobbAngle","CircleROI","EllipticalROI","FreehandROI","FreehandROISculptor","Length","Probe","RectangleROI","TextMarker","Crosshairs","Eraser","Magnify","Pan","Rotate","StackScroll","WindowLevelRegion","WindowLevel","Zoom","SegmentationFreeHandEraseInside","SegmentationFreeHandFillInside","SegmentationFreeHandEraseOutside","SegmentationFreeHandFillOutside","SegmentationRectangleEraseInside","RectangleScissor","CircleScissor","base","registerCursor","svgCursorNames","STATE","MODE","SVGMouseCursor","pointer","urn","getCursorURN","getDefinedSVGCursorDescriptor","createObjectURL","svgString","createSVGIconWithPointer","createSVGIcon","Blob","createSVGIconBlob","createSVGIconUrl","createSVGMouseCursor","format","template","dictionary","dict","defined","svgSize","Disabled","PRIMARY_BINDINGS","Primary","ToolGroup","toolInstanceName","getToolInstances","toolDefinition","hasToolName","localToolInstance","instantiatedTool","addToolInstance","parentClassName","_state$tools$toolName","ToolClassToUse","ParentClass","ToolInstance","addViewport","renderingEngines","renderingEngineUIDToUse","vpId","getActivePrimaryMouseButtonTool","vpInfo","setToolMode","setToolDisabled","setToolEnabled","setToolActive","restoreToolOptions","toolBindingsOptions","TouchBinding","MouseBinding","hasSameBinding","useCursor","_hasMousePrimaryButtonBinding","_setCursorForViewports","prevActivePrimaryToolName","currentActivePrimaryToolName","onSetToolActive","_renderViewports","_triggerToolModeChangedEvent","prevToolOptions","matchBindings","removeAllBindings","getDefaultPrimaryBindings","matchBinding","onSetToolPassive","toolOptionsForTool","_getCursor","cursorName","setToolConfiguration","_configuration","onSetToolConfiguration","getToolConfiguration","configurationPath","getPrevActivePrimaryToolName","clone","newToolGroupId","_fnToolFilter","fnToolFilter","_sourceToolOptions$bi","sourceToolInstance","sourceToolOptions","sourceToolMode","_toolOptions$bindings","primaryBindings","primary","binding1","binding2","cameraSyncCallback","synchronizerInstance","cameraModifiedEvent","tViewport","CAMERA_MODIFIED","createCameraPositionSynchronizer","synchronizerName","createSynchronizer","presentationViewSyncCallback","_synchronizerInstance","_sourceEvent","presentationView","getViewPresentation","setView","createPresentationViewSynchronizer","voiSyncCallback","modifiedEvent","invertStateChanged","invert","tProperties","syncInvertState","syncColormap","_actors","createVOISynchronizer","zoomPanSyncCallback","sViewport","syncZoom","srcZoom","getZoom","setZoom","syncPan","srcPan","getPan","setPan","createZoomPanSynchronizer","getSpatialRegistration","sourceId","imageSliceSyncCallback","disabled","imageId1","sourceImagePositionPatient","targetImageIds","viewport1","viewport2","viewPlaneNormal1","viewPlaneNormal2","dotProducts","areViewportsCoplanar","registrationMatrixMat4","useInitialPosition","mat4","targetImagePositionPatientWithRegistrationMatrix","closestImageIdIndex2","closestImageIdIndex","imageIndexToSet","VOLUME_NEW_IMAGE","createImageSliceSynchronizer","slabThicknessSyncCallback","_getSlabThickness","_setSlabThickness","slabThickness","getSlabThickness","setSlabThickness","createStackImageSynchronizer","ellipseUID","existingEllipse","w","hypot","h","ry","svgEllipseElement","corner1","corner2","drawEllipseByCoordinates","drawArrow","arrowUID","secondLine","drawRedactionRect","_setAttributesIfNecessary","_setNewAttributesIfValid","setElementCursor","CursorNames","AnnotationGroup","visibleFilter","unboundVisibleFilter","_isVisible","setVisible","baseEvent","findNearby","segmentationInputArray","validatePublicLabelmap","validateSegmentationInput","segInput","addSegmentationToState","PanTool","deltaPointsWorld","updatedPosition","updatedFocalPoint","TrackballRotateTool","rotateIncrementDegrees","originalSampleDistance","getSampleDistance","setSampleDistance","cleanUp","once","vtkCamera","getVtkActiveCamera","getViewUp","getFocalPoint","getPosition","newViewUp","currentPointsCanvas","lastPointsCanvas","normalizedPosition","normalizedPreviousPosition","radsq","op","oe","opsq","oesq","lop","loe","nop","noe","angleX","upVec","atV","rightV","forwardV","rotateCamera","angleY","ProbeTool","eventDispatchDetail","textCanvasCoordinates","drawTextBoxSvg","samplesPerPixel","baseIndex","calibratedResults","hasEnhancedRegionValues","DragProbeTool","WindowLevelTool","middleSliceIndex","frameLength","bytesPerVoxel","TypedArrayConstructor","Uint16Array","Int16Array","_getMinMax","newRange","getProperties","_viewport$getImageDat","_preScale$scalingPara","scalingParameters","getPTScaledNewRange","deltaPointsCanvas","getNewRange","multiplier","_getMultiplierFromDynamicRange","imageDynamicRange","_imageVolume$metadata","calculatedDynamicRange","_getImageDynamicRangeFromMiddleSlice","BitsStored","metadataDynamicRange","_getImageDynamicRangeFromViewport","ratio","imageDataRange","voxel","ZoomTool","_this","zoomToCenter","minZoomScale","maxZoomScale","pinchToZoom","pan","initialMousePosWorld","dirVec","pinch","parallelScale","parallelScaleToSet","focalPointToSet","positionToSet","distanceToCanvasCenter","cappedParallelScale","thresholdExceeded","zoomScale","directionOfProjection","tmp","_pinchCallback","parallelProjection","_dragParallelProjection","_dragPerspectiveProjection","_panCallback","StackScrollTool","debounceIfNotLoaded","deltaPointY","pixelsPerImage","_getPixelPerImage","imageIdIndexOffset","offsetHeight","angleBetweenLines","line1","line2","p4","angleBetween3DLines","angleBetween2DLines","PlanarRotateTool","currentPointWorld","startPointWorld","cross","rotAngle","rotMat","rotatedViewUp","rotation","StackScrollMouseWheelTool","mouseWheelCallback","DIRECTIONS","X","Y","Z","CUSTOM","VolumeRotateMouseWheelTool","cz","ax","ay","az","MIPJumpToClickTool","targetViewportIds","mouseClickCallback","maxIntensity","brightestPoint","maxFn","foundToolGroup","LengthTool","RENDERING_DEFAULTS","defaultReferenceLineColor","defaultReferenceLineControllable","defaultReferenceLineDraggableRotatable","defaultReferenceLineSlabThicknessControlsOn","CrosshairsTool","_toolProps$configurat3","_toolProps$configurat4","viewportIndicators","autoPan","panSize","referenceLinesCenterGapRadius","filterActorUIDsToSetSlabThickness","slabThicknessBlendMode","mobile","_getAnnotations","cameraFocalPoint","rotationPoints","slabThicknessPoints","toolCenter","activeOperation","activeViewportIds","_getViewportsInfo","computeToolCenter","firstViewport","secondViewport","thirdViewport","normal1","initializeViewport","normal2","normal3","point3","firstPlane","secondPlane","thirdPlane","_jump","viewportIdArray","otherViewport","viewportControllable","_getReferenceLineControllable","viewportDraggableRotatable","_getReferenceLineDraggableRotatable","_pointNearTool","viewportAnnotation","currentCamera","oldCameraPosition","deltaCameraPosition","oldCameraFocalPoint","deltaCameraFocalPoint","isRotation","cameraModifiedInPlane","_autoPanViewportIfNecessary","filteredToolAnnotations","imageNeedsUpdate","previousActiveOperation","previousActiveViewportIds","_areViewportIdArraysEqual","canvasDiagonalLength","canvasMinDimensionLength","crosshairCenterCanvas","otherViewportAnnotations","_filterAnnotationsByUniqueViewportOrientations","referenceLines","canvasBox","otherCamera","otherViewportControllable","otherViewportDraggableRotatable","otherViewportSlabThicknessControlsOn","_getReferenceLineSlabThicknessControlsOn","otherCanvasDiagonalLength","otherCanvasCenter","otherViewportCenterWorld","pointWorld0","pointWorld1","pointCanvas0","otherViewportCenterCanvas","canvasUnitVectorFromCenter","canvasVectorFromCenterLong","canvasVectorFromCenterMid","canvasVectorFromCenterShort","canvasVectorFromCenterStart","centerGap","refLinePointOne","refLinePointTwo","refLinePointThree","refLinePointFour","refLinesCenter","liangBarksyClip","rotHandleOne","rotHandleTwo","stHandlesCenterCanvas","stHandlesCenterWorld","worldUnitVectorFromCenter","vtkMatrixBuilder","rotate","worldUnitOrthoVectorFromCenter","slabThicknessValue","worldOrthoVectorFromCenter","worldVerticalRefPoint","canvasVerticalRefPoint","canvasOrthoVectorFromCenter","stLinePointOne","stLinePointTwo","stLinePointThree","stLinePointFour","stHandleOne","stHandleTwo","stHandleThree","stHandleFour","newRtpoints","newStpoints","viewportColor","_getReferenceLineColor","lineIndex","_this$configuration$m","_this$configuration$m2","viewportSlabThicknessControlsOn","selectedViewportId","lineActive","_this$configuration$m3","rotHandlesActive","rotationHandles","rotHandleWorldOne","rotHandleWorldTwo","slabThicknessHandlesActive","slabThicknessHandles","slabThicknessHandleWorldOne","slabThicknessHandleWorldTwo","slabThicknessHandleWorldThree","slabThicknessHandleWorldFour","_this$configuration$m4","_this$configuration$m5","_this$configuration$m6","_this$configuration$m7","_this$configuration$m8","_this$configuration$m9","_this$configuration$m10","_this$configuration$m11","handleUID","_this$configuration$m12","_this$configuration$m13","_this$configuration$m14","_this$configuration$m15","_this$configuration$m16","_this$configuration$m17","_this$configuration$m18","_this$configuration$m19","viewportIdArrayOne","viewportIdArrayTwo","itemFound","viewportsWithDifferentCameras","cameraOfTarget","referenceAnnotation","linkedViewportAnnotations","otherViewPlaneNormal","otherLinkedViewportAnnotationsFromSameScene","otherViewportsAnnotationsWithUniqueCameras","cameraFound","jj","cameraOfStocked","otherNonLinkedViewportAnnotationsFromSameScene","_getAnnotationsForViewportsWithDifferentCameras","otherViewportActors","sameScene","_ref5","viewportsAnnotationsToUpdate","_checkIfViewportsRenderingSameScene","_applyDeltaShiftToSelectedViewportCameras","_this$configuration$m20","dir1","dir2","finalPointCanvas","originalPointCanvas","_isClockWise","rotationAxis","translate","otherViewportsIds","renderViewports","referenceAnnotations","_filterViewportWithSameOrientation","viewportsIds","mod","currentCenter","otherViewportRotationPoints","dotProdDirection","projectedDirection","normalizedProjectedDirection","normalizedProjectedDelta","MINIMUM_SLAB_THICKNESS","_pointNearReferenceLine","lineViewport","lineSegment1","distanceToPoint1","lineSegment2","distanceToPoint2","getReferenceLineColor","getReferenceLineControllable","getReferenceLineDraggableRotatable","getReferenceLineSlabThicknessControlsOn","_unsubscribeToViewportNewVolumeSet","_subscribeToViewportNewVolumeSet","_ref6","_getRotationHandleNearImagePoint","_getSlabThicknessHandleNearImagePoint","_ref7","_onNewVolume","_ref8","toolCenterCanvas","visiblePointCanvas","visiblePointWorld","actorUIDs","blendModeToUse","setBlendMode","_applyDeltaShiftToViewportCamera","stPointLineCanvas1","stPointLineCanvas2","stPointLineCanvas1Start","stPointLineCanvas2Start","ReferenceLines","sourceViewportId","showFullDimension","sourceViewportCanvasCornersInWorld","_init","getEnabledElementByViewportId","sourceViewPlaneNormal","targetViewportPlane","pointSetToUse","topBottomVec","topRightVec","newNormal","isPerpendicular","lineStartWorld","lineEndWorld","handleFullDimension","vec1","targetImage","topLeftImageCoord","topRightImageCoord","bottomRightImageCoord","bottomLeftImageCoord","lineStartImageCoord","lineEndImageCoord","intersectInfiniteLines","isInBound","err","OverlayGridTool","sourceImageIds","pointSets","calculateImageIdPointSets","imageIdNormal","getImageIdNormal","targetData","initializeViewportData","pointSetsToUse","lineStartsWorld","lineEndsWorld","SegmentationIntersectionTool","_getRenderingEngine","actorsWorldPointsMap","_getRenderingEngine2","calculateSurfaceSegmentationIntersectionsForViewport","calculateSurfaceSegmentationIntersections","getCacheId","actorWorldPointMap","polyLineIdx","worldPointsSet","polyLineUID","actorWorldPointsMap","polyDataUtils","colorArray","colorComponentToString","component","componentString","colorToString","getWorldWidthAndHeightFromTwoPoints","EllipticalROITool","centerPointRadius","initialRotation","getRotation","canvasCorners","minorEllipse","majorEllipse","pointInMinorEllipse","_pointInEllipseCanvas","canvasWidth","canvasHeight","originalHandleCanvas","pointsCanvas","currentCanvasPoints","dX","dY","bottomCanvas","topCanvas","leftCanvas","rightCanvas","_dragHandle","dYCanvas","canvasBottom","canvasTop","newHalfCanvasWidth","canvasLeft","canvasRight","dXCanvas","newHalfCanvasHeight","drawEllipseSvg","centerPoint","_getCanvasEllipseCenter","post2Index","fast","normalized","getCanvasCircleRadius","circleCanvasPoints","getCanvasCircleCorners","CircleROITool","radiusPoint","canvasCenter","canvasEnd","radiusUnit","radiusLine","Spline","_props$resolution","_props$fixedResolutio","_props$closed","_controlPoints","_resolution","resolution","_fixedResolution","fixedResolution","_closed","_invalidated","controlPoints","numControlPoints","_update","_aabb","_length","hasTangentPoints","addControlPoint","addControlPoints","addControlPointAtU","_getLineSegmentAt","curveSegmentIndex","curveSegment","_curveSegments","controlPointPos","insertIndex","deleteControlPointByIndex","minControlPoints","clearControlPoints","setControlPoints","updateControlPoint","newControlPoint","getControlPoints","controlPoint","getClosestControlPoint","minSquaredDist","closestPointIndex","squaredDist","getClosestControlPointWithinDistance","maxDist","closestControlPoint","getClosestPoint","curveSegmentsDistInfo","_getCurveSegmmentsDistanceSquaredInfo","csA","csB","minDistCurveSegment","minDistLineSegment","closestPointCurveSegmentIndex","minDistSquared","curveSegmentDistInfo","lineSegPoint","lineSegDistSquared","uValue","previousLineSegmentsLength","getClosestPointOnControlPointLines","_convertCurveSegmentsToPolyline","getPreviewPolylinePoints","controlPointPreview","closeDistance","closeSpline","previewCurveSegments","getPreviewCurveSegments","isPointNearCurve","curveSegments","_getCurveSegmmentsWithinDistance","closingCurveSegment","_getClosingCurveSegmentWithStraightLineSegment","curveSegAABB","lineSegmentAABB","isVerticalLine","getSplineCurves","curveSegLength","curveSegIndex","lineSegIndex","curveSegmentsDistanceSquared","curveSegmentsDistance","curveSegmentsWithinRange","curveSegmentDistSquared","pointLength","lengthEnd","startControlPoint","endControlPoint","closingLineSegment","CubicSpline","previewNumCurveSegments","_getNumCurveSegments","startCurveSegIndex","endCurveSegIndex","transformMatrix","getTransformMatrix","_getCurveSegment","numCurveSegments","previousCurveSegmentsLength","_getPoint","uInt","p0","_getCurveSegmentPoints","tt","ttt","tValues","vec4","qValues","p0Index","p3Index","_getLineSegments","numLineSegments","inc","maxU","curveSegmentLength","lineSegAABB","lineSegLength","CardinalSpline","_props$scale","_props$fixedScale","_scale","_fixedScale","fixedScale","s2","LinearSpline","CatmullRomSpline","TRANSFORM_MATRIX","BSpline","DEFAULT_SPLINE_CONFIG","controlPointAdditionDistance","controlPointDeletionDistance","showControlPointsConnectors","controlPointAdditionEnabled","controlPointDeletionEnabled","SplineTypesEnum","SplineToolActions","SplineROITool","Cardinal","Class","CatmullRom","Linear","drawPreviewEnabled","lastControlPointDeletionKeys","AddControlPoint","DeleteControlPoint","Ctrl","instance","fireChangeOnUpdate","_eventDetail$key","controlPointIndex","_deleteControlPointByIndex","doubleClick","closeContour","addNewPoint","_keyDownCallback","_mouseMoveCallback","textboxStyle","splineType","splineConfig","_getSplineConfig","closestPointInfo","_this$editData","_this$editData2","_this$fireChangeOnUpd","childAnnotations","_isSplineROIAnnotation","splinePolylineCanvas","_updateSplineInstance","controlPointsConnectors","triggerChangeEvent","createInterpolatedSplineControl","_annotation$data$hand","increment","createSpline","splineConfigs","SplineContourSegmentationTool","BucketQueue","numBits","getPriority","areEqual","_bucketCount","_mask","_size","_currentBucketIndex","_buckets","_buildArray","_getPriority","_areEqual","itemA","itemB","bucketIndex","_getBucketIndex","newHead","ret","firstBucketNode","prevNode","isEmpty","buckets","MAX_UINT32","TWO_THIRD_PI","LivewireScissors","grayscalePixelData","col","searchGranularity","costs","numPixels","searchGranularityBits","laplace","gradXNew","gradYNew","_computeLaplace","gradMagnitude","_computeGradient","_computeGradientX","_computeGradientY","parents","Uint32Array","startSearch","startPointIndex","_getPointIndex","priorityQueueNew","_getPointCost","findMinNearby","xRange","yRange","xTest","yTest","distanceCost","weight","findPathToPoint","_getPointCoordinate","targetPointIndex","cost","priorityQueue","neighborsPoints","_getNeighborPoints","neighborPoint","neighborPointIndex","_getWeightedDistance","neighborCost","pathPoints","pathPointIndex","_getDeltaX","_getDeltaY","_getGradientMagnitude","_getLaplace","lap","gradient","pixelIndex","gradX","gradY","_getGradientUnitVector","px","py","pointGradX","pointGradY","gradVecLen","_getGradientDirection","qx","qy","dgpUnitVec","gdqUnitVec","dp","dq","SQRT1_2","isFinite","getCost","bIndex","sx","sy","ey","createInstanceFromRawPixelData","minPixelValue","maxPixelValue","pixelRange","LivewirePath","inputPointArray","inputControlPointIndexArray","_controlPointIndexes","getLastPoint","isControlPoint","getNumControlPoints","removeLastControlPoint","getLastControlPoint","removeLastPoints","addPoints","newPointArray","prependPath","otherSize","shiftedIndexArray","appendPath","LivewireContourTool","snapHandleNearby","nearestEdge","showInterpolationPolyline","undo","proximitySquared","clearAnnotation","clearEditData","worldToSlice","sliceToWorld","worldPosOriginal","currentPath","closestHandlePoint","worldControlPoint","snapPoint","scissors","confirmedPath","updateAnnotation","imgWidth","imgHeight","slicePoint","editHandle","setupBaseEditData","rightPos","_this$editData$handle","_annotation$handles","viewportImageData","sliceImageData","sliceToIndexMatrix","indexToSliceMatrix","ijkPoint","startPos","scissorsRight","currentPathNext","confirmedPathRight","numHandles","previousHandle","nextHandle","previousIndex","slicePos","pathPointsLeft","pathPointsRight","_this$editData3","_this$editData4","_this$editData5","canvasHandles","livewirePath","imagePoints","LivewireContourSegmentationTool","updateInterpolatedAnnotation","originalPolyline","repeatInterpolation","handleSmoothing","acceptedPath","_this$updateInterpola","ArrowAnnotateTool","getTextCallback","changeTextCallback","arrowFirst","doubleClickCallback","clickedAnnotation","_doneChangingTextCallback","_annotations3","drawArrowSvg","updatedText","doneChangingTextCallback","prompt","AngleTool","angleStartedNotYetCompleted","canvasPoint3","_data$cachedStats$tar","fromCharCode","midPoint2","CobbAngleTool","showArcLines","distanceToLines","isNearFirstLine","isNearSecondLine","arc1Angle","arc2Angle","arc1Start","arc1End","arc2Start","arc2End","arc1TextBoxUID","arc1TextLine","arch1TextPosCanvas","arc2TextBoxUID","arc2TextLine","arch2TextPosCanvas","point4","canvasPoint4","mid1","mid2","linkLine","arc1Side","arc2Side","midLinkLine","linkLineLength","midFirstLine","midSecondLine","directionVectorStartArc1","magnitudeStartArc1","normalizedDirectionStartArc1","directionVectorEndArc1","magnitudeEndArc1","normalizedDirectionEndArc1","directionVectorStartArc2","magnitudeStartArc2","normalizedDirectionStartArc2","directionVectorEndArc2","magnitudeEndArc2","normalizedDirectionEndArc2","seg1","seg2","minDist","MAX_VALUE","getArcsStartEndPoints","UltrasoundDirectionalTool","displayBothAxesDistances","startedDrawing","xValues","yValues","isUnitless","drawHandleSvg","canvasDeltaY","canvasDeltaX","projectedPointCanvas","values1","values2","KeyImageTool","canvasPosition","canvasSize","MAGNIFY_VIEWPORT_ID","MagnifyTool","magnifySize","magnifyWidth","magnifyHeight","_getReferencedImageId","_createMagnificationViewport","viewportProperties","magnifyToolElement","magnifyElement","viewportInput","enableElement","magnifyViewport","setStack","_hasBeenRemoved","disableElement","_dragEndCallback","MAGNIFY_VIEWPORT_INITIAL_RADIUS","isSegmentation","AdvancedMagnifyViewport","magnifyViewportId","sourceEnabledElement","zoomFactor","_viewportId","_sourceEnabledElement","_autoPan","_browserMouseDownCallback","_browserMouseUpCallback","_handleToolModeChanged","_resizeViewportAsync","_resizeViewport","_radius","_resized","update","_enabledElement","_isViewportReady","_syncViewports","_removeEventListeners","parentNode","_this$_sourceToolGrou","_magnifyToolGroup","magnifyToolGroup","_sourceToolGroup","_inheritBorderRadius","borderRadius","_createViewportNode","overflow","_convertZoomFactorToParallelScale","offsetWidth","_isStackViewport","_isVolumeViewport","_cloneToolGroups","sourceActors","magnifyToolGroupId","sourceToolGroup","AdvancedMagnifyTool","_cloneStack","_cloneVolumes","volumeInputArray","setVolumes","_cloneViewport","sourceViewportOptions","defaultOptions","_cancelMouseEventCallback","_evt$target","_canAutoPan","closest","canvasCurrent","magnifyRadius","panDist","canvasDeltaPos","newCanvasPosition","currentWorldPos","worldDeltaPos","autoPanCallbackData","currentPosition","_addBrowserEventListeners","_removeBrowserEventListeners","_addEventListeners","cstEvents","sourceCanvas","_syncViewportsCameras","_syncStackViewports","setImageIdIndex","sourceProperties","resize","AdvancedMagnifyViewportManager","sourceElement","_addSourceElementEventListener","_magnifyViewportsMap","magnifyViewportInfo","destroyViewport","magnifyViewportsMapEntries","_getMagnifyViewportsMapEntriesBySourceViewportId","stackActorReInitialized","currentViewPlaneNormal","worldImagePlanePoint","vecHandleToImagePlane","worldDist","worldDelta","getInstance","_AdvancedMagnifyViewp","_singleton","_this$_magnifyViewpor","_destroyViewports","magnifyViewportMapEntry","_removeSourceElementEventListener","newEnabledElement","createViewport","_annotationRemovedCallback","_newStackImageCallback","newStackHandler","STACK_VIEWPORT_NEW_STACK","newVolumeHandler","VOLUME_VIEWPORT_NEW_VOLUME","_newVolumeImageCallback","AdvancedMagnifyToolActions","magnifyingGlass","zoomFactorList","showZoomFactorsList","Secondary","canvasHandlePoints","_getCanvasHandlePoints","magnifyViewportManager","annotationPoints","_deltaPoints$canvas","newRadius","newCanvasHandlePoints","canvasCenterPos","canvasRadius","currentZoomFactor","dropdown","_getZoomFactorsListDropdown","newZoomFactor","focus","onChangeCallback","_evt$keyCode","_evt$key","which","toLowerCase","option","title","defaultSelected","ReferenceCursors","displayThreshold","positionSync","_currentCursorWorldPosition","_currentCanvasPosition","_elementWithCursor","getActiveAnnotation","createInitialAnnotation","updateAnnotationPosition","previousCamera","oldFocalPoint","cameraNormal","isElementWithCursor","updateViewportImage","crosshairUIDs","centerSpace","lineLength","_disableCursorEnabled","_getEnabledElement","_annotation$data2","plane","currentMousePosition","normalizedViewPlane","scaledPlaneNormal","viewportsWithAnnotations","ScaleOverlayTool","scaleLocation","viewportCanvasCornersInWorld","thisAnnotation","worldWidthViewport","worldHeightViewport","scaleSizes","currentScaleSize","scaleSize","locationTickOffset","endTick1","endTick2","leftTick","rightTick","canvasScaleSize","tickIds","tickUIDs","tickCoordinates","numberSmallTicks","tickSpacing","locationOffset","pointSet","worldCoordinates","midpointLocation","vscaleBounds","hscaleBounds","scaleCanvasCoordinates","worldDistanceOnCanvas","horizontalReduction","verticalReduction","hReduction","vReduction","locationBounds","canvasBounds","computeScaleBounds","computeScaleSize","computeWorldScaleCoordinates","computeCanvasScaleCoordinates","scaleTicks","computeEndScaleTicks","scaleId","leftTickId","rightTickId","locationTextOffest","textBoxLines","_getTextLines","computeInnerScaleTicks","scaleSizeDisplayValue","scaleSizeUnits","AnnotationEraserTool","_deleteNearbyAnnotations","annotationsToRemove","interactableAnnotations","fillInsideRectangle","strategyData","isAligned","pointsBoundsLPS","fillRectangle","eraseInsideRectangle","eraseRectangle","RectangleScissorsTool","FILL_INSIDE","ERASE_INSIDE","CircleScissorsTool","SphereScissorsTool","CircleROIStartEndThresholdTool","newStartIndex","_getStartSliceIndex","isMiddleSlice","lineWidthToUse","worldCenterIndex","numSlicesToPropagateFromStart","_getImageIdIndex","pos","OverlayMarkerType","ANNOTATED_CUBE","AXES","OrientationMarkerTool","orientationWidget","viewportCorner","vtkOrientationMarkerWidget","viewportSize","minPixelSize","maxPixelSize","overlayMarkerType","OVERLAY_MARKER_TYPES","overlayConfiguration","faceProperties","xPlus","faceColor","faceRotation","xMinus","yPlus","fontColor","yMinus","zPlus","zMinus","defaultStyle","fontStyle","fontSizeScale","edgeThickness","edgeColor","polyDataURL","initViewports","_subscribeToViewportEvents","cleanUpData","orientationMarker","orientationMarkers","updateViewport","unsubscribe","_resizeObservers","subscribeToElementResize","offscreenMultiRenderWindow","getRenderWindow","getWidget","addAxisActorInViewport","removeActor","createAnnotationCube","vtkAxesActor","createCustomActor","renderer","renderWindow","interactor","getInteractor","parentRenderer","setViewportCorner","setViewportSize","setMinPixelSize","setMaxPixelSize","updateMarkerOrientation","addWidget","response","fetch","vtpReader","vtkXMLPolyDataReader","parseAsArrayBuffer","setActiveScalars","setColorModeToDirectScalars","rotateZ","vtkAnnotatedCubeActor","setDefaultStyle","setXPlusFaceProperty","setXMinusFaceProperty","setYPlusFaceProperty","setYMinusFaceProperty","setZPlusFaceProperty","setZMinusFaceProperty","createAnnotatedCubeActor","annotatedCube","methodName","charAt","SegmentSelectTool","hoverTimeout","SelectMode","Border","hoverTimer","_setActiveSegment","activeSegmentationReps","RepresentationTypes","_setActiveSegmentForType","hoveredSegmentIndex","PaintFillTool","fixedDimension","getFixedDimension","floodFillGetter","getLabelValue","getScalarDataPositionFromPlane","inPlaneSeedPoint","fixedDimensionValue","generateHelpers","clickedLabelValue","floodFillResult","scalarDataPosition","getFramesModified","minJ","maxJ","framesModified","seedIndex3D","getScalarDataPosition","generateFloodFillGetter","generateGetScalarDataPositionFromPlane","xDirection","yDirection","zDirection","absoluteOfViewPlaneNormal","absoluteOfXDirection","absoluteOfYDirection","absoluteOfZDirection","VideoRedactionTool","viewportUIDsToRender","toolDataCanvasCoordinate","drawRedactionRectSvg","viewportUID","renderingEngineUID","sceneUID","targetUIDs","targetUID","_getImageVolumeFromTargetUID","worldToIndexVec3","valueMinusMean","scene","volumeUID","volumeActors","getVolumeActors","coloneIndex","_getTargetStackUID"],"sourceRoot":""}