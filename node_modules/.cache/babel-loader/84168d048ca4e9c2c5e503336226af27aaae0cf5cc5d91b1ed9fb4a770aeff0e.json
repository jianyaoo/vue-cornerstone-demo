{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/web.dom-exception.stack.js\";\nimport \"core-js/modules/web.structured-clone.js\";\nimport Constants from './Texture/Constants.js';\nimport HalfFloat from '../../Common/Core/HalfFloat.js';\nimport { n as newInstance$1, o as obj, s as set, e as setGet, g as get, i as moveToProtected, a as newTypedArray, c as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { S as isPowerOfTwo, O as nearestPowerOfTwo } from '../../Common/Core/Math/index.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nconst {\n  Wrap,\n  Filter\n} = Constants;\nconst {\n  VtkDataTypes\n} = vtkDataArray;\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\nconst {\n  toHalf\n} = HalfFloat;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLTexture methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLTexture(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLTexture');\n  // Renders myself\n  publicAPI.render = function () {\n    let renWin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    if (renWin) {\n      model._openGLRenderWindow = renWin;\n    } else {\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      // sync renderable properties\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n    }\n    model.context = model._openGLRenderWindow.getContext();\n    if (model.renderable.getInterpolate()) {\n      if (model.generateMipmap) {\n        publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n      } else {\n        publicAPI.setMinificationFilter(Filter.LINEAR);\n      }\n      publicAPI.setMagnificationFilter(Filter.LINEAR);\n    } else {\n      publicAPI.setMinificationFilter(Filter.NEAREST);\n      publicAPI.setMagnificationFilter(Filter.NEAREST);\n    }\n    if (model.renderable.getRepeat()) {\n      publicAPI.setWrapR(Wrap.REPEAT);\n      publicAPI.setWrapS(Wrap.REPEAT);\n      publicAPI.setWrapT(Wrap.REPEAT);\n    }\n    // clear image if input data is set\n    if (model.renderable.getInputData()) {\n      model.renderable.setImage(null);\n    }\n    // create the texture if it is not done already\n    if (!model.handle || model.renderable.getMTime() > model.textureBuildTime.getMTime()) {\n      // if we have an Image\n      if (model.renderable.getImage() !== null) {\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        // Have an Image which may not be complete\n        if (model.renderable.getImage() && model.renderable.getImageLoaded()) {\n          publicAPI.create2DFromImage(model.renderable.getImage());\n          publicAPI.activate();\n          publicAPI.sendParameters();\n          model.textureBuildTime.modified();\n        }\n      }\n      // if we have a canvas\n      if (model.renderable.getCanvas() !== null) {\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        const canvas = model.renderable.getCanvas();\n        publicAPI.create2DFromRaw(canvas.width, canvas.height, 4, VtkDataTypes.UNSIGNED_CHAR, canvas, true);\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n      // if we have jsImageData\n      if (model.renderable.getJsImageData() !== null) {\n        const jsid = model.renderable.getJsImageData();\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        publicAPI.create2DFromRaw(jsid.width, jsid.height, 4, VtkDataTypes.UNSIGNED_CHAR, jsid.data, true);\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n      // if we have InputData\n      const input = model.renderable.getInputData(0);\n      if (input && input.getPointData().getScalars()) {\n        const ext = input.getExtent();\n        const inScalars = input.getPointData().getScalars();\n\n        // do we have a cube map? Six inputs\n        const data = [];\n        for (let i = 0; i < model.renderable.getNumberOfInputPorts(); ++i) {\n          const indata = model.renderable.getInputData(i);\n          const scalars = indata ? indata.getPointData().getScalars().getData() : null;\n          if (scalars) {\n            data.push(scalars);\n          }\n        }\n        if (model.renderable.getInterpolate() && inScalars.getNumberOfComponents() === 4) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        if (data.length % 6 === 0) {\n          publicAPI.createCubeFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), data);\n        } else {\n          publicAPI.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());\n        }\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n    }\n    if (model.handle) {\n      publicAPI.activate();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.destroyTexture = () => {\n    // deactivate it first\n    publicAPI.deactivate();\n    if (model.context && model.handle) {\n      model.context.deleteTexture(model.handle);\n    }\n    model.handle = 0;\n    model.numberOfDimensions = 0;\n    model.target = 0;\n    model.components = 0;\n    model.width = 0;\n    model.height = 0;\n    model.depth = 0;\n    publicAPI.resetFormatAndType();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createTexture = () => {\n    // reuse the existing handle if we have one\n    if (!model.handle) {\n      model.handle = model.context.createTexture();\n      if (model.target) {\n        model.context.bindTexture(model.target, model.handle);\n\n        // See: http://www.openmodel.context..org/wiki/Common_Mistakes#Creating_a_complete_texture\n        // turn off mip map filter or set the base and max level correctly. here\n        // both are done.\n        model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));\n        model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));\n        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));\n        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));\n        if (model._openGLRenderWindow.getWebgl2()) {\n          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));\n        }\n        model.context.bindTexture(model.target, null);\n      }\n    }\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.getTextureUnit = () => {\n    if (model._openGLRenderWindow) {\n      return model._openGLRenderWindow.getTextureUnitForTexture(publicAPI);\n    }\n    return -1;\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.activate = () => {\n    // activate a free texture unit for this texture\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.bind();\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.deactivate = () => {\n    if (model._openGLRenderWindow) {\n      model._openGLRenderWindow.deactivateTexture(publicAPI);\n    }\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.releaseGraphicsResources = rwin => {\n    if (rwin && model.handle) {\n      rwin.activateTexture(publicAPI);\n      rwin.deactivateTexture(publicAPI);\n      model.context.deleteTexture(model.handle);\n      model.handle = 0;\n      model.numberOfDimensions = 0;\n      model.target = 0;\n      model.internalFormat = 0;\n      model.format = 0;\n      model.openGLDataType = 0;\n      model.components = 0;\n      model.width = 0;\n      model.height = 0;\n      model.depth = 0;\n      model.allocatedGPUMemoryInBytes = 0;\n    }\n    if (model.shaderProgram) {\n      model.shaderProgram.releaseGraphicsResources(rwin);\n      model.shaderProgram = null;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.bind = () => {\n    model.context.bindTexture(model.target, model.handle);\n    if (model.autoParameters && publicAPI.getMTime() > model.sendParametersTime.getMTime()) {\n      publicAPI.sendParameters();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.isBound = () => {\n    let result = false;\n    if (model.context && model.handle) {\n      let target = 0;\n      switch (model.target) {\n        case model.context.TEXTURE_2D:\n          target = model.context.TEXTURE_BINDING_2D;\n          break;\n        default:\n          vtkWarningMacro('impossible case');\n          break;\n      }\n      const oid = model.context.getIntegerv(target);\n      result = oid === model.handle;\n    }\n    return result;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.sendParameters = () => {\n    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));\n    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));\n    }\n    model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));\n    model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.context.texParameteri(model.target, model.context.TEXTURE_BASE_LEVEL, model.baseLevel);\n      model.context.texParameteri(model.target, model.context.TEXTURE_MAX_LEVEL, model.maxLevel);\n    }\n\n    // model.context.texParameterf(model.target, model.context.TEXTURE_MIN_LOD, model.minLOD);\n    // model.context.texParameterf(model.target, model.context.TEXTURE_MAX_LOD, model.maxLOD);\n\n    model.sendParametersTime.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getInternalFormat = (vtktype, numComps) => {\n    if (!model._forceInternalFormat) {\n      model.internalFormat = publicAPI.getDefaultInternalFormat(vtktype, numComps);\n    }\n    if (!model.internalFormat) {\n      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);\n    }\n    return model.internalFormat;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultInternalFormat = (vtktype, numComps) => {\n    let result = 0;\n    // try default next\n    result = model._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, model.oglNorm16Ext, model.useHalfFloat);\n    if (result) {\n      return result;\n    }\n    if (!result) {\n      vtkDebugMacro('Unsupported internal texture type!');\n      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);\n    }\n    return result;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.setInternalFormat = iFormat => {\n    model._forceInternalFormat = true;\n    if (iFormat !== model.internalFormat) {\n      model.internalFormat = iFormat;\n      publicAPI.modified();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getFormat = (vtktype, numComps) => {\n    model.format = publicAPI.getDefaultFormat(vtktype, numComps);\n    return model.format;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultFormat = (vtktype, numComps) => {\n    if (model._openGLRenderWindow.getWebgl2()) {\n      switch (numComps) {\n        case 1:\n          return model.context.RED;\n        case 2:\n          return model.context.RG;\n        case 3:\n          return model.context.RGB;\n        case 4:\n          return model.context.RGBA;\n        default:\n          return model.context.RGB;\n      }\n    } else {\n      // webgl1\n      switch (numComps) {\n        case 1:\n          return model.context.LUMINANCE;\n        case 2:\n          return model.context.LUMINANCE_ALPHA;\n        case 3:\n          return model.context.RGB;\n        case 4:\n          return model.context.RGBA;\n        default:\n          return model.context.RGB;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.resetFormatAndType = () => {\n    model.format = 0;\n    model.internalFormat = 0;\n    model._forceInternalFormat = false;\n    model.openGLDataType = 0;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultDataType = vtkScalarType => {\n    // DON'T DEAL with VTK_CHAR as this is platform dependent.\n    if (model._openGLRenderWindow.getWebgl2()) {\n      switch (vtkScalarType) {\n        // case VtkDataTypes.SIGNED_CHAR:\n        //   return model.context.BYTE;\n        case VtkDataTypes.UNSIGNED_CHAR:\n          return model.context.UNSIGNED_BYTE;\n        // prefer norm16 since that is accurate compared to\n        // half float which is not\n        case model.oglNorm16Ext && !model.useHalfFloat && VtkDataTypes.SHORT:\n          return model.context.SHORT;\n        case model.oglNorm16Ext && !model.useHalfFloat && VtkDataTypes.UNSIGNED_SHORT:\n          return model.context.UNSIGNED_SHORT;\n        // use half float type\n        case model.useHalfFloat && VtkDataTypes.SHORT:\n          return model.context.HALF_FLOAT;\n        case model.useHalfFloat && VtkDataTypes.UNSIGNED_SHORT:\n          return model.context.HALF_FLOAT;\n        // case VtkDataTypes.INT:\n        //   return model.context.INT;\n        // case VtkDataTypes.UNSIGNED_INT:\n        //   return model.context.UNSIGNED_INT;\n        case VtkDataTypes.FLOAT:\n        case VtkDataTypes.VOID: // used for depth component textures.\n        default:\n          return model.context.FLOAT;\n      }\n    }\n    switch (vtkScalarType) {\n      // case VtkDataTypes.SIGNED_CHAR:\n      //   return model.context.BYTE;\n      case VtkDataTypes.UNSIGNED_CHAR:\n        return model.context.UNSIGNED_BYTE;\n      // case VtkDataTypes.SHORT:\n      //   return model.context.SHORT;\n      // case VtkDataTypes.UNSIGNED_SHORT:\n      //   return model.context.UNSIGNED_SHORT;\n      // case VtkDataTypes.INT:\n      //   return model.context.INT;\n      // case VtkDataTypes.UNSIGNED_INT:\n      //   return model.context.UNSIGNED_INT;\n      case VtkDataTypes.FLOAT:\n      case VtkDataTypes.VOID: // used for depth component textures.\n      default:\n        if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n          return model.context.FLOAT;\n        }\n        {\n          const halfFloat = model.context.getExtension('OES_texture_half_float');\n          if (halfFloat && model.context.getExtension('OES_texture_half_float_linear')) {\n            return halfFloat.HALF_FLOAT_OES;\n          }\n        }\n        return model.context.UNSIGNED_BYTE;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLDataType = function (vtkScalarType) {\n    let forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!model.openGLDataType || forceUpdate) {\n      model.openGLDataType = publicAPI.getDefaultDataType(vtkScalarType);\n    }\n    return model.openGLDataType;\n  };\n  publicAPI.getShiftAndScale = () => {\n    let shift = 0.0;\n    let scale = 1.0;\n\n    // for all float type internal formats\n    switch (model.openGLDataType) {\n      case model.context.BYTE:\n        scale = 127.5;\n        shift = scale - 128.0;\n        break;\n      case model.context.UNSIGNED_BYTE:\n        scale = 255.0;\n        shift = 0.0;\n        break;\n      case model.context.SHORT:\n        scale = 32767.5;\n        shift = scale - 32768.0;\n        break;\n      case model.context.UNSIGNED_SHORT:\n        scale = 65536.0;\n        shift = 0.0;\n        break;\n      case model.context.INT:\n        scale = 2147483647.5;\n        shift = scale - 2147483648.0;\n        break;\n      case model.context.UNSIGNED_INT:\n        scale = 4294967295.0;\n        shift = 0.0;\n        break;\n      case model.context.FLOAT:\n    }\n    return {\n      shift,\n      scale\n    };\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLFilterMode = emode => {\n    switch (emode) {\n      case Filter.NEAREST:\n        return model.context.NEAREST;\n      case Filter.LINEAR:\n        return model.context.LINEAR;\n      case Filter.NEAREST_MIPMAP_NEAREST:\n        return model.context.NEAREST_MIPMAP_NEAREST;\n      case Filter.NEAREST_MIPMAP_LINEAR:\n        return model.context.NEAREST_MIPMAP_LINEAR;\n      case Filter.LINEAR_MIPMAP_NEAREST:\n        return model.context.LINEAR_MIPMAP_NEAREST;\n      case Filter.LINEAR_MIPMAP_LINEAR:\n        return model.context.LINEAR_MIPMAP_LINEAR;\n      default:\n        return model.context.NEAREST;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLWrapMode = vtktype => {\n    switch (vtktype) {\n      case Wrap.CLAMP_TO_EDGE:\n        return model.context.CLAMP_TO_EDGE;\n      case Wrap.REPEAT:\n        return model.context.REPEAT;\n      case Wrap.MIRRORED_REPEAT:\n        return model.context.MIRRORED_REPEAT;\n      default:\n        return model.context.CLAMP_TO_EDGE;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  function updateArrayDataType(dataType, data) {\n    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const pixData = [];\n    let pixCount = model.width * model.height * model.components;\n    if (depth) {\n      pixCount *= model.depth;\n    }\n\n    // if the opengl data type is float\n    // then the data array must be float\n    if (dataType !== VtkDataTypes.FLOAT && model.openGLDataType === model.context.FLOAT) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];\n          pixData.push(new Float32Array(dataArrayToCopy));\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // if the opengl data type is ubyte\n    // then the data array must be u8, we currently simply truncate the data\n    if (dataType !== VtkDataTypes.UNSIGNED_CHAR && model.openGLDataType === model.context.UNSIGNED_BYTE) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];\n          pixData.push(new Uint8Array(dataArrayToCopy));\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // if the opengl data type is half float\n    // then the data array must be u16\n    let halfFloat = false;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      halfFloat = model.openGLDataType === model.context.HALF_FLOAT;\n    } else {\n      const halfFloatExt = model.context.getExtension('OES_texture_half_float');\n      halfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;\n    }\n    if (halfFloat) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const newArray = new Uint16Array(pixCount);\n          const src = data[idx];\n          for (let i = 0; i < pixCount; i++) {\n            newArray[i] = toHalf(src[i]);\n          }\n          pixData.push(newArray);\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // The output has to be filled\n    if (pixData.length === 0) {\n      for (let i = 0; i < data.length; i++) {\n        pixData.push(data[i]);\n      }\n    }\n    return pixData;\n  }\n\n  //----------------------------------------------------------------------------\n  function scaleTextureToHighestPowerOfTwo(data) {\n    if (model._openGLRenderWindow.getWebgl2()) {\n      // No need if webGL2\n      return data;\n    }\n    const pixData = [];\n    const width = model.width;\n    const height = model.height;\n    const numComps = model.components;\n    if (data && (!isPowerOfTwo(width) || !isPowerOfTwo(height))) {\n      // Scale up the texture to the next highest power of two dimensions.\n      const halfFloat = model.context.getExtension('OES_texture_half_float');\n      const newWidth = nearestPowerOfTwo(width);\n      const newHeight = nearestPowerOfTwo(height);\n      const pixCount = newWidth * newHeight * model.components;\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx] !== null) {\n          let newArray = null;\n          const jFactor = height / newHeight;\n          const iFactor = width / newWidth;\n          let usingHalf = false;\n          if (model.openGLDataType === model.context.FLOAT) {\n            newArray = new Float32Array(pixCount);\n          } else if (halfFloat && model.openGLDataType === halfFloat.HALF_FLOAT_OES) {\n            newArray = new Uint16Array(pixCount);\n            usingHalf = true;\n          } else {\n            newArray = new Uint8Array(pixCount);\n          }\n          for (let j = 0; j < newHeight; j++) {\n            const joff = j * newWidth * numComps;\n            const jidx = j * jFactor;\n            let jlow = Math.floor(jidx);\n            let jhi = Math.ceil(jidx);\n            if (jhi >= height) {\n              jhi = height - 1;\n            }\n            const jmix = jidx - jlow;\n            const jmix1 = 1.0 - jmix;\n            jlow = jlow * width * numComps;\n            jhi = jhi * width * numComps;\n            for (let i = 0; i < newWidth; i++) {\n              const ioff = i * numComps;\n              const iidx = i * iFactor;\n              let ilow = Math.floor(iidx);\n              let ihi = Math.ceil(iidx);\n              if (ihi >= width) {\n                ihi = width - 1;\n              }\n              const imix = iidx - ilow;\n              ilow *= numComps;\n              ihi *= numComps;\n              for (let c = 0; c < numComps; c++) {\n                if (usingHalf) {\n                  newArray[joff + ioff + c] = HalfFloat.toHalf(HalfFloat.fromHalf(data[idx][jlow + ilow + c]) * jmix1 * (1.0 - imix) + HalfFloat.fromHalf(data[idx][jlow + ihi + c]) * jmix1 * imix + HalfFloat.fromHalf(data[idx][jhi + ilow + c]) * jmix * (1.0 - imix) + HalfFloat.fromHalf(data[idx][jhi + ihi + c]) * jmix * imix);\n                } else {\n                  newArray[joff + ioff + c] = data[idx][jlow + ilow + c] * jmix1 * (1.0 - imix) + data[idx][jlow + ihi + c] * jmix1 * imix + data[idx][jhi + ilow + c] * jmix * (1.0 - imix) + data[idx][jhi + ihi + c] * jmix * imix;\n                }\n              }\n            }\n          }\n          pixData.push(newArray);\n          model.width = newWidth;\n          model.height = newHeight;\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // The output has to be filled\n    if (pixData.length === 0) {\n      for (let i = 0; i < data.length; i++) {\n        pixData.push(data[i]);\n      }\n    }\n    return pixData;\n  }\n\n  //----------------------------------------------------------------------------\n  function useTexStorage(dataType) {\n    if (model._openGLRenderWindow) {\n      if (model.resizable || model.renderable?.getResizable()) {\n        // Cannot use texStorage if the texture is supposed to be resizable.\n        return false;\n      }\n      if (model._openGLRenderWindow.getWebgl2()) {\n        const webGLInfo = model._openGLRenderWindow.getGLInformations();\n        if (webGLInfo.RENDERER.value.match(/WebKit/gi) && navigator.platform.match(/Mac/gi) && model.oglNorm16Ext && (dataType === VtkDataTypes.UNSIGNED_SHORT || dataType === VtkDataTypes.SHORT)) {\n          // Cannot use texStorage with EXT_texture_norm16 textures on Mac M1 GPU.\n          // No errors reported but the texture is unusable.\n          return false;\n        }\n        // Use texStorage for WebGL2\n        return true;\n      }\n      return false;\n    }\n    return false;\n  }\n\n  //----------------------------------------------------------------------------\n  publicAPI.create2DFromRaw = function (width, height, numComps, dataType, data) {\n    let flip = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType, true);\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Create an array of texture with one texture\n    const dataArray = [data];\n    const pixData = updateArrayDataType(dataType, dataArray);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // Source texture data from the PBO.\n    model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flip);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (scaledData[0] != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, scaledData[0]);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, scaledData[0]);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n\n    // always reset the flip\n    if (flip) {\n      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, false);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createCubeFromRaw = (width, height, numComps, dataType, data) => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_CUBE_MAP;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    model.maxLevel = data.length / 6 - 1;\n    publicAPI.createTexture();\n    publicAPI.bind();\n    const pixData = updateArrayDataType(dataType, data);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // invert the data because opengl is messed up with cube maps\n    // and uses the old renderman standard with Y going down\n    // even though it is completely at odds with OpenGL standards\n    const invertedData = [];\n    let widthLevel = model.width;\n    let heightLevel = model.height;\n    for (let i = 0; i < scaledData.length; i++) {\n      if (i % 6 === 0 && i !== 0) {\n        widthLevel /= 2;\n        heightLevel /= 2;\n      }\n      invertedData[i] = newTypedArray(dataType, heightLevel * widthLevel * model.components);\n      for (let y = 0; y < heightLevel; ++y) {\n        const row1 = y * widthLevel * model.components;\n        const row2 = (heightLevel - y - 1) * widthLevel * model.components;\n        invertedData[i].set(scaledData[i].slice(row2, row2 + widthLevel * model.components), row1);\n      }\n    }\n\n    // Source texture data from the PBO.\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 6, model.internalFormat, model.width, model.height);\n    }\n    // We get the 6 images\n    for (let i = 0; i < 6; i++) {\n      // For each mipmap level\n      let j = 0;\n      let w = model.width;\n      let h = model.height;\n      while (w >= 1 && h >= 1) {\n        // In webgl 1, all levels need to be defined. So if the latest level size is\n        // 8x8, we have to add 3 more null textures (4x4, 2x2, 1x1)\n        // In webgl 2, the attribute maxLevel will be use.\n        let tempData = null;\n        if (j <= model.maxLevel) {\n          tempData = invertedData[6 * j + i];\n        }\n        if (useTexStorage(dataType)) {\n          if (tempData != null) {\n            model.context.texSubImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, w, h, model.format, model.openGLDataType, tempData);\n          }\n        } else {\n          model.context.texImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, model.internalFormat, w, h, 0, model.format, model.openGLDataType, tempData);\n        }\n        j++;\n        w /= 2;\n        h /= 2;\n      }\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);\n    // generateMipmap must not be called here because we manually upload all levels\n    // if it is called, all levels will be overwritten\n\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createDepthFromRaw = (width, height, dataType, data) => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    model.format = model.context.DEPTH_COMPONENT;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      if (dataType === VtkDataTypes.FLOAT) {\n        model.internalFormat = model.context.DEPTH_COMPONENT32F;\n      } else {\n        model.internalFormat = model.context.DEPTH_COMPONENT16;\n      }\n    } else {\n      model.internalFormat = model.context.DEPTH_COMPONENT;\n    }\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = 1;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (data != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, data);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, data);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.create2DFromImage = image => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(VtkDataTypes.UNSIGNED_CHAR);\n    publicAPI.getInternalFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n    publicAPI.getFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = 4;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n\n    // Scale up the texture to the next highest power of two dimensions (if needed) and flip y.\n    const needNearestPowerOfTwo = !model._openGLRenderWindow.getWebgl2() && (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height));\n    const canvas = document.createElement('canvas');\n    canvas.width = needNearestPowerOfTwo ? nearestPowerOfTwo(image.width) : image.width;\n    canvas.height = needNearestPowerOfTwo ? nearestPowerOfTwo(image.height) : image.height;\n    model.width = canvas.width;\n    model.height = canvas.height;\n    const ctx = canvas.getContext('2d');\n    ctx.translate(0, canvas.height);\n    ctx.scale(1, -1);\n    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);\n    const safeImage = canvas;\n    if (useTexStorage(VtkDataTypes.UNSIGNED_CHAR)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (safeImage != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, safeImage);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, safeImage);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(VtkDataTypes.UNSIGNED_CHAR, model.oglNorm16Ext, model.useHalfFloat);\n    publicAPI.deactivate();\n    return true;\n  };\n\n  // Compute scale and offset per component from min and max per component\n  function computeScaleOffsets(min, max, numComps) {\n    const offset = new Array(numComps);\n    const scale = new Array(numComps);\n    for (let c = 0; c < numComps; ++c) {\n      offset[c] = min[c];\n      scale[c] = max[c] - min[c] || 1.0;\n    }\n    return {\n      scale,\n      offset\n    };\n  }\n\n  // HalfFloat only represents numbers between [-2048, 2048] exactly accurate,\n  // for numbers outside of this range there is a precision limitation\n  function hasExactHalfFloat(offset, scale) {\n    // Per Component\n    for (let c = 0; c < offset.length; c++) {\n      const min = offset[c];\n      const max = scale[c] + min;\n      if (min < -2048 || min > 2048 || max < -2048 || max > 2048) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function setUseHalfFloat(dataType, offset, scale, preferSizeOverAccuracy) {\n    publicAPI.getOpenGLDataType(dataType);\n    let useHalfFloat = false;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      useHalfFloat = model.openGLDataType === model.context.HALF_FLOAT;\n    } else {\n      const halfFloatExt = model.context.getExtension('OES_texture_half_float');\n      useHalfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;\n    }\n\n    // Don't consider halfFloat and convert back to Float when the range of data does not generate an accurate halfFloat\n    // AND it is not preferable to have a smaller texture than an exact texture.\n    const isHalfFloat = useHalfFloat && (hasExactHalfFloat(offset, scale) || preferSizeOverAccuracy);\n    model.useHalfFloat = isHalfFloat;\n  }\n  function processDataArray(dataArray, preferSizeOverAccuracy) {\n    const numComps = dataArray.getNumberOfComponents();\n    const dataType = dataArray.getDataType();\n    const data = dataArray.getData();\n\n    // Compute min max from array\n    // Using the vtkDataArray.getRange() enables caching\n    const minArray = new Array(numComps);\n    const maxArray = new Array(numComps);\n    for (let c = 0; c < numComps; ++c) {\n      const [min, max] = dataArray.getRange(c);\n      minArray[c] = min;\n      maxArray[c] = max;\n    }\n    const scaleOffsets = computeScaleOffsets(minArray, maxArray, numComps);\n\n    // preferSizeOverAccuracy will override norm16 due to bug with norm16 implementation\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1408247\n    setUseHalfFloat(dataType, scaleOffsets.offset, scaleOffsets.scale, preferSizeOverAccuracy);\n\n    // since our default is to use half float, in case that we can't use it\n    // we need to use another type\n    if (!model.useHalfFloat) {\n      publicAPI.getOpenGLDataType(dataType, true);\n    }\n    return {\n      numComps,\n      dataType,\n      data,\n      scaleOffsets\n    };\n  }\n  publicAPI.create2DFilterableFromRaw = function (width, height, numberOfComponents, dataType, values) {\n    let preferSizeOverAccuracy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    return publicAPI.create2DFilterableFromDataArray(width, height, vtkDataArray.newInstance({\n      numberOfComponents,\n      dataType,\n      values\n    }), preferSizeOverAccuracy);\n  };\n  publicAPI.create2DFilterableFromDataArray = function (width, height, dataArray) {\n    let preferSizeOverAccuracy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const {\n      numComps,\n      dataType,\n      data\n    } = processDataArray(dataArray, preferSizeOverAccuracy);\n    publicAPI.create2DFromRaw(width, height, numComps, dataType, data);\n  };\n  //----------------------------------------------------------------------------\n  publicAPI.create3DFromRaw = (width, height, depth, numComps, dataType, data) => {\n    // Permit OpenGLDataType to be half float, if applicable, for 3D\n    publicAPI.getOpenGLDataType(dataType);\n\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_3D;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = depth;\n    model.numberOfDimensions = 3;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n    // Create an array of texture with one texture\n    const dataArray = [data];\n    const is3DArray = true;\n    const pixData = updateArrayDataType(dataType, dataArray, is3DArray);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n\n    // openGLDataType\n\n    if (useTexStorage(dataType)) {\n      model.context.texStorage3D(model.target, 1, model.internalFormat, model.width, model.height, model.depth);\n      if (scaledData[0] != null) {\n        model.context.texSubImage3D(model.target, 0, 0, 0, 0, model.width, model.height, model.depth, model.format, model.openGLDataType, scaledData[0]);\n      }\n    } else {\n      model.context.texImage3D(model.target, 0, model.internalFormat, model.width, model.height, model.depth, 0, model.format, model.openGLDataType, scaledData[0]);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  // This method simulates a 3D texture using 2D\n  // Prefer create3DFilterableFromDataArray to enable caching of min and max values\n  publicAPI.create3DFilterableFromRaw = function (width, height, depth, numberOfComponents, dataType, values) {\n    let preferSizeOverAccuracy = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    return publicAPI.create3DFilterableFromDataArray(width, height, depth, vtkDataArray.newInstance({\n      numberOfComponents,\n      dataType,\n      values\n    }), preferSizeOverAccuracy);\n  };\n\n  //----------------------------------------------------------------------------\n  // This method create a 3D texture from dimensions and a DataArray\n  publicAPI.create3DFilterableFromDataArray = function (width, height, depth, dataArray) {\n    let preferSizeOverAccuracy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const {\n      numComps,\n      dataType,\n      data,\n      scaleOffsets\n    } = processDataArray(dataArray, preferSizeOverAccuracy);\n    const numPixelsIn = width * height * depth;\n    const offset = [];\n    const scale = [];\n    for (let c = 0; c < numComps; ++c) {\n      offset[c] = 0.0;\n      scale[c] = 1.0;\n    }\n\n    // store the information, we will need it later\n    // offset and scale are the offset and scale required to get\n    // the texture value back to data values ala\n    // data = texture * scale + offset\n    // and texture = (data - offset)/scale\n    model.volumeInfo = {\n      scale,\n      offset,\n      dataComputedScale: scaleOffsets.scale,\n      dataComputedOffset: scaleOffsets.offset,\n      width,\n      height,\n      depth\n    };\n\n    // Create a copy of scale and offset to avoid aliasing issues\n    // Original is read only, copy is read/write\n    // Use the copy as volumeInfo.scale and volumeInfo.offset\n    const scaleOffsetsCopy = structuredClone(scaleOffsets);\n\n    // WebGL2 path, we have 3d textures etc\n    if (model._openGLRenderWindow.getWebgl2()) {\n      if (model.oglNorm16Ext && !model.useHalfFloat && dataType === VtkDataTypes.SHORT) {\n        for (let c = 0; c < numComps; ++c) {\n          model.volumeInfo.scale[c] = 32767.0;\n        }\n        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);\n      }\n      if (model.oglNorm16Ext && !model.useHalfFloat && dataType === VtkDataTypes.UNSIGNED_SHORT) {\n        for (let c = 0; c < numComps; ++c) {\n          model.volumeInfo.scale[c] = 65535.0;\n        }\n        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);\n      }\n      if (dataType === VtkDataTypes.FLOAT || model.useHalfFloat && (dataType === VtkDataTypes.SHORT || dataType === VtkDataTypes.UNSIGNED_SHORT)) {\n        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);\n      }\n      if (dataType === VtkDataTypes.UNSIGNED_CHAR) {\n        for (let c = 0; c < numComps; ++c) {\n          model.volumeInfo.scale[c] = 255.0;\n        }\n        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);\n      }\n      // otherwise convert to float\n      const newArray = new Float32Array(numPixelsIn * numComps);\n      // use computed scale and offset\n      model.volumeInfo.offset = scaleOffsetsCopy.offset;\n      model.volumeInfo.scale = scaleOffsetsCopy.scale;\n      let count = 0;\n      const scaleInverse = scaleOffsetsCopy.scale.map(s => 1 / s);\n      for (let i = 0; i < numPixelsIn; i++) {\n        for (let nc = 0; nc < numComps; nc++) {\n          newArray[count] = (data[count] - scaleOffsetsCopy.offset[nc]) * scaleInverse[nc];\n          count++;\n        }\n      }\n      return publicAPI.create3DFromRaw(width, height, depth, numComps, VtkDataTypes.FLOAT, newArray);\n    }\n\n    // not webgl2, deal with webgl1, no 3d textures\n    // and maybe no float textures\n\n    let volCopyData = (outArray, outIdx, inValue, smin, smax) => {\n      outArray[outIdx] = inValue;\n    };\n    let dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;\n    // unsigned char gets used as is\n    if (dataType === VtkDataTypes.UNSIGNED_CHAR) {\n      for (let c = 0; c < numComps; ++c) {\n        scaleOffsetsCopy.offset[c] = 0.0;\n        scaleOffsetsCopy.scale[c] = 255.0;\n      }\n    } else if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n      // use float textures scaled to 0.0 to 1.0\n      dataTypeToUse = VtkDataTypes.FLOAT;\n      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {\n        outArray[outIdx] = (inValue - soffset) / sscale;\n      };\n    } else {\n      // worst case, scale data to uchar\n      dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;\n      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {\n        outArray[outIdx] = 255.0 * (inValue - soffset) / sscale;\n      };\n    }\n\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataTypeToUse);\n    publicAPI.getInternalFormat(dataTypeToUse, numComps);\n    publicAPI.getFormat(dataTypeToUse, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n\n    // have to pack this 3D texture into pot 2D texture\n    model.target = model.context.TEXTURE_2D;\n    model.components = numComps;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n\n    // MAX_TEXTURE_SIZE gives the max dimensions that can be supported by the GPU,\n    // but it doesn't mean it will fit in memory. If we have to use a float data type\n    // or 4 components, there are good chances that the texture size will blow up\n    // and could not fit in the GPU memory. Use a smaller texture size in that case,\n    // which will force a downsampling of the dataset.\n    // That problem does not occur when using webGL2 since we can pack the data in\n    // denser textures based on our data type.\n    // TODO: try to fit in the biggest supported texture, catch the gl error if it\n    // does not fix (OUT_OF_MEMORY), then attempt with smaller texture\n    let maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);\n    if (maxTexDim > 4096 && (dataTypeToUse === VtkDataTypes.FLOAT || numComps >= 3)) {\n      maxTexDim = 4096;\n    }\n\n    // compute estimate for XY subsample\n    let xstride = 1;\n    let ystride = 1;\n    if (numPixelsIn > maxTexDim * maxTexDim) {\n      xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));\n      ystride = xstride;\n    }\n    let targetWidth = Math.sqrt(numPixelsIn) / xstride;\n    targetWidth = nearestPowerOfTwo(targetWidth);\n    // determine X reps\n    const xreps = Math.floor(targetWidth * xstride / width);\n    const yreps = Math.ceil(depth / xreps);\n    const targetHeight = nearestPowerOfTwo(height * yreps / ystride);\n    model.width = targetWidth;\n    model.height = targetHeight;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // store the information, we will need it later\n    model.volumeInfo.xreps = xreps;\n    model.volumeInfo.yreps = yreps;\n    model.volumeInfo.xstride = xstride;\n    model.volumeInfo.ystride = ystride;\n    model.volumeInfo.offset = scaleOffsetsCopy.offset;\n    model.volumeInfo.scale = scaleOffsetsCopy.scale;\n\n    // OK stuff the data into the 2d TEXTURE\n\n    // first allocate the new texture\n    let newArray;\n    const pixCount = targetWidth * targetHeight * numComps;\n    if (dataTypeToUse === VtkDataTypes.FLOAT) {\n      newArray = new Float32Array(pixCount);\n    } else {\n      newArray = new Uint8Array(pixCount);\n    }\n\n    // then stuff the data into it, nothing fancy right now\n    // for stride\n    let outIdx = 0;\n    const tileWidth = Math.floor(width / xstride);\n    const tileHeight = Math.floor(height / ystride);\n    for (let yRep = 0; yRep < yreps; yRep++) {\n      const xrepsThisRow = Math.min(xreps, depth - yRep * xreps);\n      const outXContIncr = numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));\n      for (let tileY = 0; tileY < tileHeight; tileY++) {\n        for (let xRep = 0; xRep < xrepsThisRow; xRep++) {\n          const inOffset = numComps * ((yRep * xreps + xRep) * width * height + ystride * tileY * width);\n          for (let tileX = 0; tileX < tileWidth; tileX++) {\n            // copy value\n            for (let nc = 0; nc < numComps; nc++) {\n              volCopyData(newArray, outIdx, data[inOffset + xstride * tileX * numComps + nc], scaleOffsetsCopy.offset[nc], scaleOffsetsCopy.scale[nc]);\n              outIdx++;\n            }\n          }\n        }\n        outIdx += outXContIncr;\n      }\n    }\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataTypeToUse)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (newArray != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, newArray);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, newArray);\n    }\n    publicAPI.deactivate();\n    return true;\n  };\n  publicAPI.setOpenGLRenderWindow = rw => {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getMaximumTextureSize = ctx => {\n    if (ctx && ctx.isCurrent()) {\n      return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);\n    }\n    return -1;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  _openGLRenderWindow: null,\n  _forceInternalFormat: false,\n  context: null,\n  handle: 0,\n  sendParametersTime: null,\n  textureBuildTime: null,\n  numberOfDimensions: 0,\n  target: 0,\n  format: 0,\n  openGLDataType: 0,\n  components: 0,\n  width: 0,\n  height: 0,\n  depth: 0,\n  autoParameters: true,\n  wrapS: Wrap.CLAMP_TO_EDGE,\n  wrapT: Wrap.CLAMP_TO_EDGE,\n  wrapR: Wrap.CLAMP_TO_EDGE,\n  minificationFilter: Filter.NEAREST,\n  magnificationFilter: Filter.NEAREST,\n  minLOD: -1000.0,\n  maxLOD: 1000.0,\n  baseLevel: 0,\n  maxLevel: 1000,\n  generateMipmap: false,\n  // use half float by default, but it will get set\n  // to false if the context does not support it or\n  // the voxel intensity range is out of the accurate\n  // range of half float\n  useHalfFloat: true,\n  oglNorm16Ext: null,\n  allocatedGPUMemoryInBytes: 0\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.sendParametersTime = {};\n  obj(model.sendParametersTime, {\n    mtime: 0\n  });\n  model.textureBuildTime = {};\n  obj(model.textureBuildTime, {\n    mtime: 0\n  });\n\n  // Build VTK API\n  set(publicAPI, model, ['format', 'openGLDataType']);\n  setGet(publicAPI, model, ['keyMatrixTime', 'minificationFilter', 'magnificationFilter', 'wrapS', 'wrapT', 'wrapR', 'generateMipmap', 'oglNorm16Ext']);\n  get(publicAPI, model, ['width', 'height', 'volumeInfo', 'components', 'handle', 'target', 'allocatedGPUMemoryInBytes']);\n  moveToProtected(publicAPI, model, ['openGLRenderWindow']);\n\n  // Object methods\n  vtkOpenGLTexture(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLTexture');\n\n// ----------------------------------------------------------------------------\n\nvar vtkOpenGLTexture$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkTexture', newInstance);\nexport { vtkOpenGLTexture$1 as default, extend, newInstance };","map":{"version":3,"names":["Constants","HalfFloat","n","newInstance$1","o","obj","s","set","e","setGet","g","get","i","moveToProtected","a","newTypedArray","c","macro","vtkDataArray","S","isPowerOfTwo","O","nearestPowerOfTwo","vtkViewNode","registerOverride","Wrap","Filter","VtkDataTypes","vtkDebugMacro","vtkErrorMacro","vtkWarningMacro","toHalf","vtkOpenGLTexture","publicAPI","model","classHierarchy","push","render","renWin","arguments","length","undefined","_openGLRenderWindow","_openGLRenderer","getFirstAncestorOfType","getParent","context","getContext","renderable","getInterpolate","generateMipmap","setMinificationFilter","LINEAR_MIPMAP_LINEAR","LINEAR","setMagnificationFilter","NEAREST","getRepeat","setWrapR","REPEAT","setWrapS","setWrapT","getInputData","setImage","handle","getMTime","textureBuildTime","getImage","getImageLoaded","create2DFromImage","activate","sendParameters","modified","getCanvas","canvas","create2DFromRaw","width","height","UNSIGNED_CHAR","getJsImageData","jsid","data","input","getPointData","getScalars","ext","getExtent","inScalars","getNumberOfInputPorts","indata","scalars","getData","getNumberOfComponents","createCubeFromRaw","getDataType","destroyTexture","deactivate","deleteTexture","numberOfDimensions","target","components","depth","resetFormatAndType","createTexture","bindTexture","texParameteri","TEXTURE_MIN_FILTER","getOpenGLFilterMode","minificationFilter","TEXTURE_MAG_FILTER","magnificationFilter","TEXTURE_WRAP_S","getOpenGLWrapMode","wrapS","TEXTURE_WRAP_T","wrapT","getWebgl2","TEXTURE_WRAP_R","wrapR","getTextureUnit","getTextureUnitForTexture","activateTexture","bind","deactivateTexture","releaseGraphicsResources","rwin","internalFormat","format","openGLDataType","allocatedGPUMemoryInBytes","shaderProgram","autoParameters","sendParametersTime","isBound","result","TEXTURE_2D","TEXTURE_BINDING_2D","oid","getIntegerv","TEXTURE_BASE_LEVEL","baseLevel","TEXTURE_MAX_LEVEL","maxLevel","getInternalFormat","vtktype","numComps","_forceInternalFormat","getDefaultInternalFormat","getDefaultTextureInternalFormat","oglNorm16Ext","useHalfFloat","setInternalFormat","iFormat","getFormat","getDefaultFormat","RED","RG","RGB","RGBA","LUMINANCE","LUMINANCE_ALPHA","getDefaultDataType","vtkScalarType","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","HALF_FLOAT","FLOAT","VOID","getExtension","halfFloat","HALF_FLOAT_OES","getOpenGLDataType","forceUpdate","getShiftAndScale","shift","scale","BYTE","INT","UNSIGNED_INT","emode","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","CLAMP_TO_EDGE","MIRRORED_REPEAT","updateArrayDataType","dataType","pixData","pixCount","idx","dataArrayToCopy","subarray","Float32Array","Uint8Array","halfFloatExt","newArray","Uint16Array","src","scaleTextureToHighestPowerOfTwo","newWidth","newHeight","jFactor","iFactor","usingHalf","j","joff","jidx","jlow","Math","floor","jhi","ceil","jmix","jmix1","ioff","iidx","ilow","ihi","imix","fromHalf","useTexStorage","resizable","getResizable","webGLInfo","getGLInformations","RENDERER","value","match","navigator","platform","flip","dataArray","scaledData","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_ALIGNMENT","texStorage2D","texSubImage2D","texImage2D","getDefaultTextureByteSize","TEXTURE_CUBE_MAP","invertedData","widthLevel","heightLevel","y","row1","row2","slice","w","h","tempData","TEXTURE_CUBE_MAP_POSITIVE_X","createDepthFromRaw","DEPTH_COMPONENT","DEPTH_COMPONENT32F","DEPTH_COMPONENT16","image","needNearestPowerOfTwo","document","createElement","ctx","translate","drawImage","safeImage","computeScaleOffsets","min","max","offset","Array","hasExactHalfFloat","setUseHalfFloat","preferSizeOverAccuracy","isHalfFloat","processDataArray","minArray","maxArray","getRange","scaleOffsets","create2DFilterableFromRaw","numberOfComponents","values","create2DFilterableFromDataArray","newInstance","create3DFromRaw","TEXTURE_3D","is3DArray","texStorage3D","texSubImage3D","texImage3D","create3DFilterableFromRaw","create3DFilterableFromDataArray","numPixelsIn","volumeInfo","dataComputedScale","dataComputedOffset","scaleOffsetsCopy","structuredClone","count","scaleInverse","map","nc","volCopyData","outArray","outIdx","inValue","smin","smax","dataTypeToUse","soffset","sscale","maxTexDim","getParameter","MAX_TEXTURE_SIZE","xstride","ystride","sqrt","targetWidth","xreps","yreps","targetHeight","tileWidth","tileHeight","yRep","xrepsThisRow","outXContIncr","tileY","xRep","inOffset","tileX","setOpenGLRenderWindow","rw","getMaximumTextureSize","isCurrent","DEFAULT_VALUES","minLOD","maxLOD","extend","initialValues","Object","assign","mtime","vtkOpenGLTexture$1","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js"],"sourcesContent":["import Constants from './Texture/Constants.js';\nimport HalfFloat from '../../Common/Core/HalfFloat.js';\nimport { n as newInstance$1, o as obj, s as set, e as setGet, g as get, i as moveToProtected, a as newTypedArray, c as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { S as isPowerOfTwo, O as nearestPowerOfTwo } from '../../Common/Core/Math/index.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  Wrap,\n  Filter\n} = Constants;\nconst {\n  VtkDataTypes\n} = vtkDataArray;\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\nconst {\n  toHalf\n} = HalfFloat;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLTexture methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLTexture(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLTexture');\n  // Renders myself\n  publicAPI.render = function () {\n    let renWin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    if (renWin) {\n      model._openGLRenderWindow = renWin;\n    } else {\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      // sync renderable properties\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n    }\n    model.context = model._openGLRenderWindow.getContext();\n    if (model.renderable.getInterpolate()) {\n      if (model.generateMipmap) {\n        publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n      } else {\n        publicAPI.setMinificationFilter(Filter.LINEAR);\n      }\n      publicAPI.setMagnificationFilter(Filter.LINEAR);\n    } else {\n      publicAPI.setMinificationFilter(Filter.NEAREST);\n      publicAPI.setMagnificationFilter(Filter.NEAREST);\n    }\n    if (model.renderable.getRepeat()) {\n      publicAPI.setWrapR(Wrap.REPEAT);\n      publicAPI.setWrapS(Wrap.REPEAT);\n      publicAPI.setWrapT(Wrap.REPEAT);\n    }\n    // clear image if input data is set\n    if (model.renderable.getInputData()) {\n      model.renderable.setImage(null);\n    }\n    // create the texture if it is not done already\n    if (!model.handle || model.renderable.getMTime() > model.textureBuildTime.getMTime()) {\n      // if we have an Image\n      if (model.renderable.getImage() !== null) {\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        // Have an Image which may not be complete\n        if (model.renderable.getImage() && model.renderable.getImageLoaded()) {\n          publicAPI.create2DFromImage(model.renderable.getImage());\n          publicAPI.activate();\n          publicAPI.sendParameters();\n          model.textureBuildTime.modified();\n        }\n      }\n      // if we have a canvas\n      if (model.renderable.getCanvas() !== null) {\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        const canvas = model.renderable.getCanvas();\n        publicAPI.create2DFromRaw(canvas.width, canvas.height, 4, VtkDataTypes.UNSIGNED_CHAR, canvas, true);\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n      // if we have jsImageData\n      if (model.renderable.getJsImageData() !== null) {\n        const jsid = model.renderable.getJsImageData();\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        publicAPI.create2DFromRaw(jsid.width, jsid.height, 4, VtkDataTypes.UNSIGNED_CHAR, jsid.data, true);\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n      // if we have InputData\n      const input = model.renderable.getInputData(0);\n      if (input && input.getPointData().getScalars()) {\n        const ext = input.getExtent();\n        const inScalars = input.getPointData().getScalars();\n\n        // do we have a cube map? Six inputs\n        const data = [];\n        for (let i = 0; i < model.renderable.getNumberOfInputPorts(); ++i) {\n          const indata = model.renderable.getInputData(i);\n          const scalars = indata ? indata.getPointData().getScalars().getData() : null;\n          if (scalars) {\n            data.push(scalars);\n          }\n        }\n        if (model.renderable.getInterpolate() && inScalars.getNumberOfComponents() === 4) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        if (data.length % 6 === 0) {\n          publicAPI.createCubeFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), data);\n        } else {\n          publicAPI.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());\n        }\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n    }\n    if (model.handle) {\n      publicAPI.activate();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.destroyTexture = () => {\n    // deactivate it first\n    publicAPI.deactivate();\n    if (model.context && model.handle) {\n      model.context.deleteTexture(model.handle);\n    }\n    model.handle = 0;\n    model.numberOfDimensions = 0;\n    model.target = 0;\n    model.components = 0;\n    model.width = 0;\n    model.height = 0;\n    model.depth = 0;\n    publicAPI.resetFormatAndType();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createTexture = () => {\n    // reuse the existing handle if we have one\n    if (!model.handle) {\n      model.handle = model.context.createTexture();\n      if (model.target) {\n        model.context.bindTexture(model.target, model.handle);\n\n        // See: http://www.openmodel.context..org/wiki/Common_Mistakes#Creating_a_complete_texture\n        // turn off mip map filter or set the base and max level correctly. here\n        // both are done.\n        model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));\n        model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));\n        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));\n        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));\n        if (model._openGLRenderWindow.getWebgl2()) {\n          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));\n        }\n        model.context.bindTexture(model.target, null);\n      }\n    }\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.getTextureUnit = () => {\n    if (model._openGLRenderWindow) {\n      return model._openGLRenderWindow.getTextureUnitForTexture(publicAPI);\n    }\n    return -1;\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.activate = () => {\n    // activate a free texture unit for this texture\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.bind();\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.deactivate = () => {\n    if (model._openGLRenderWindow) {\n      model._openGLRenderWindow.deactivateTexture(publicAPI);\n    }\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.releaseGraphicsResources = rwin => {\n    if (rwin && model.handle) {\n      rwin.activateTexture(publicAPI);\n      rwin.deactivateTexture(publicAPI);\n      model.context.deleteTexture(model.handle);\n      model.handle = 0;\n      model.numberOfDimensions = 0;\n      model.target = 0;\n      model.internalFormat = 0;\n      model.format = 0;\n      model.openGLDataType = 0;\n      model.components = 0;\n      model.width = 0;\n      model.height = 0;\n      model.depth = 0;\n      model.allocatedGPUMemoryInBytes = 0;\n    }\n    if (model.shaderProgram) {\n      model.shaderProgram.releaseGraphicsResources(rwin);\n      model.shaderProgram = null;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.bind = () => {\n    model.context.bindTexture(model.target, model.handle);\n    if (model.autoParameters && publicAPI.getMTime() > model.sendParametersTime.getMTime()) {\n      publicAPI.sendParameters();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.isBound = () => {\n    let result = false;\n    if (model.context && model.handle) {\n      let target = 0;\n      switch (model.target) {\n        case model.context.TEXTURE_2D:\n          target = model.context.TEXTURE_BINDING_2D;\n          break;\n        default:\n          vtkWarningMacro('impossible case');\n          break;\n      }\n      const oid = model.context.getIntegerv(target);\n      result = oid === model.handle;\n    }\n    return result;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.sendParameters = () => {\n    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));\n    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));\n    }\n    model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));\n    model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.context.texParameteri(model.target, model.context.TEXTURE_BASE_LEVEL, model.baseLevel);\n      model.context.texParameteri(model.target, model.context.TEXTURE_MAX_LEVEL, model.maxLevel);\n    }\n\n    // model.context.texParameterf(model.target, model.context.TEXTURE_MIN_LOD, model.minLOD);\n    // model.context.texParameterf(model.target, model.context.TEXTURE_MAX_LOD, model.maxLOD);\n\n    model.sendParametersTime.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getInternalFormat = (vtktype, numComps) => {\n    if (!model._forceInternalFormat) {\n      model.internalFormat = publicAPI.getDefaultInternalFormat(vtktype, numComps);\n    }\n    if (!model.internalFormat) {\n      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);\n    }\n    return model.internalFormat;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultInternalFormat = (vtktype, numComps) => {\n    let result = 0;\n    // try default next\n    result = model._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, model.oglNorm16Ext, model.useHalfFloat);\n    if (result) {\n      return result;\n    }\n    if (!result) {\n      vtkDebugMacro('Unsupported internal texture type!');\n      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);\n    }\n    return result;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.setInternalFormat = iFormat => {\n    model._forceInternalFormat = true;\n    if (iFormat !== model.internalFormat) {\n      model.internalFormat = iFormat;\n      publicAPI.modified();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getFormat = (vtktype, numComps) => {\n    model.format = publicAPI.getDefaultFormat(vtktype, numComps);\n    return model.format;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultFormat = (vtktype, numComps) => {\n    if (model._openGLRenderWindow.getWebgl2()) {\n      switch (numComps) {\n        case 1:\n          return model.context.RED;\n        case 2:\n          return model.context.RG;\n        case 3:\n          return model.context.RGB;\n        case 4:\n          return model.context.RGBA;\n        default:\n          return model.context.RGB;\n      }\n    } else {\n      // webgl1\n      switch (numComps) {\n        case 1:\n          return model.context.LUMINANCE;\n        case 2:\n          return model.context.LUMINANCE_ALPHA;\n        case 3:\n          return model.context.RGB;\n        case 4:\n          return model.context.RGBA;\n        default:\n          return model.context.RGB;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.resetFormatAndType = () => {\n    model.format = 0;\n    model.internalFormat = 0;\n    model._forceInternalFormat = false;\n    model.openGLDataType = 0;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultDataType = vtkScalarType => {\n    // DON'T DEAL with VTK_CHAR as this is platform dependent.\n    if (model._openGLRenderWindow.getWebgl2()) {\n      switch (vtkScalarType) {\n        // case VtkDataTypes.SIGNED_CHAR:\n        //   return model.context.BYTE;\n        case VtkDataTypes.UNSIGNED_CHAR:\n          return model.context.UNSIGNED_BYTE;\n        // prefer norm16 since that is accurate compared to\n        // half float which is not\n        case model.oglNorm16Ext && !model.useHalfFloat && VtkDataTypes.SHORT:\n          return model.context.SHORT;\n        case model.oglNorm16Ext && !model.useHalfFloat && VtkDataTypes.UNSIGNED_SHORT:\n          return model.context.UNSIGNED_SHORT;\n        // use half float type\n        case model.useHalfFloat && VtkDataTypes.SHORT:\n          return model.context.HALF_FLOAT;\n        case model.useHalfFloat && VtkDataTypes.UNSIGNED_SHORT:\n          return model.context.HALF_FLOAT;\n        // case VtkDataTypes.INT:\n        //   return model.context.INT;\n        // case VtkDataTypes.UNSIGNED_INT:\n        //   return model.context.UNSIGNED_INT;\n        case VtkDataTypes.FLOAT:\n        case VtkDataTypes.VOID: // used for depth component textures.\n        default:\n          return model.context.FLOAT;\n      }\n    }\n    switch (vtkScalarType) {\n      // case VtkDataTypes.SIGNED_CHAR:\n      //   return model.context.BYTE;\n      case VtkDataTypes.UNSIGNED_CHAR:\n        return model.context.UNSIGNED_BYTE;\n      // case VtkDataTypes.SHORT:\n      //   return model.context.SHORT;\n      // case VtkDataTypes.UNSIGNED_SHORT:\n      //   return model.context.UNSIGNED_SHORT;\n      // case VtkDataTypes.INT:\n      //   return model.context.INT;\n      // case VtkDataTypes.UNSIGNED_INT:\n      //   return model.context.UNSIGNED_INT;\n      case VtkDataTypes.FLOAT:\n      case VtkDataTypes.VOID: // used for depth component textures.\n      default:\n        if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n          return model.context.FLOAT;\n        }\n        {\n          const halfFloat = model.context.getExtension('OES_texture_half_float');\n          if (halfFloat && model.context.getExtension('OES_texture_half_float_linear')) {\n            return halfFloat.HALF_FLOAT_OES;\n          }\n        }\n        return model.context.UNSIGNED_BYTE;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLDataType = function (vtkScalarType) {\n    let forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!model.openGLDataType || forceUpdate) {\n      model.openGLDataType = publicAPI.getDefaultDataType(vtkScalarType);\n    }\n    return model.openGLDataType;\n  };\n  publicAPI.getShiftAndScale = () => {\n    let shift = 0.0;\n    let scale = 1.0;\n\n    // for all float type internal formats\n    switch (model.openGLDataType) {\n      case model.context.BYTE:\n        scale = 127.5;\n        shift = scale - 128.0;\n        break;\n      case model.context.UNSIGNED_BYTE:\n        scale = 255.0;\n        shift = 0.0;\n        break;\n      case model.context.SHORT:\n        scale = 32767.5;\n        shift = scale - 32768.0;\n        break;\n      case model.context.UNSIGNED_SHORT:\n        scale = 65536.0;\n        shift = 0.0;\n        break;\n      case model.context.INT:\n        scale = 2147483647.5;\n        shift = scale - 2147483648.0;\n        break;\n      case model.context.UNSIGNED_INT:\n        scale = 4294967295.0;\n        shift = 0.0;\n        break;\n      case model.context.FLOAT:\n    }\n    return {\n      shift,\n      scale\n    };\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLFilterMode = emode => {\n    switch (emode) {\n      case Filter.NEAREST:\n        return model.context.NEAREST;\n      case Filter.LINEAR:\n        return model.context.LINEAR;\n      case Filter.NEAREST_MIPMAP_NEAREST:\n        return model.context.NEAREST_MIPMAP_NEAREST;\n      case Filter.NEAREST_MIPMAP_LINEAR:\n        return model.context.NEAREST_MIPMAP_LINEAR;\n      case Filter.LINEAR_MIPMAP_NEAREST:\n        return model.context.LINEAR_MIPMAP_NEAREST;\n      case Filter.LINEAR_MIPMAP_LINEAR:\n        return model.context.LINEAR_MIPMAP_LINEAR;\n      default:\n        return model.context.NEAREST;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLWrapMode = vtktype => {\n    switch (vtktype) {\n      case Wrap.CLAMP_TO_EDGE:\n        return model.context.CLAMP_TO_EDGE;\n      case Wrap.REPEAT:\n        return model.context.REPEAT;\n      case Wrap.MIRRORED_REPEAT:\n        return model.context.MIRRORED_REPEAT;\n      default:\n        return model.context.CLAMP_TO_EDGE;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  function updateArrayDataType(dataType, data) {\n    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const pixData = [];\n    let pixCount = model.width * model.height * model.components;\n    if (depth) {\n      pixCount *= model.depth;\n    }\n\n    // if the opengl data type is float\n    // then the data array must be float\n    if (dataType !== VtkDataTypes.FLOAT && model.openGLDataType === model.context.FLOAT) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];\n          pixData.push(new Float32Array(dataArrayToCopy));\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // if the opengl data type is ubyte\n    // then the data array must be u8, we currently simply truncate the data\n    if (dataType !== VtkDataTypes.UNSIGNED_CHAR && model.openGLDataType === model.context.UNSIGNED_BYTE) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];\n          pixData.push(new Uint8Array(dataArrayToCopy));\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // if the opengl data type is half float\n    // then the data array must be u16\n    let halfFloat = false;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      halfFloat = model.openGLDataType === model.context.HALF_FLOAT;\n    } else {\n      const halfFloatExt = model.context.getExtension('OES_texture_half_float');\n      halfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;\n    }\n    if (halfFloat) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const newArray = new Uint16Array(pixCount);\n          const src = data[idx];\n          for (let i = 0; i < pixCount; i++) {\n            newArray[i] = toHalf(src[i]);\n          }\n          pixData.push(newArray);\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // The output has to be filled\n    if (pixData.length === 0) {\n      for (let i = 0; i < data.length; i++) {\n        pixData.push(data[i]);\n      }\n    }\n    return pixData;\n  }\n\n  //----------------------------------------------------------------------------\n  function scaleTextureToHighestPowerOfTwo(data) {\n    if (model._openGLRenderWindow.getWebgl2()) {\n      // No need if webGL2\n      return data;\n    }\n    const pixData = [];\n    const width = model.width;\n    const height = model.height;\n    const numComps = model.components;\n    if (data && (!isPowerOfTwo(width) || !isPowerOfTwo(height))) {\n      // Scale up the texture to the next highest power of two dimensions.\n      const halfFloat = model.context.getExtension('OES_texture_half_float');\n      const newWidth = nearestPowerOfTwo(width);\n      const newHeight = nearestPowerOfTwo(height);\n      const pixCount = newWidth * newHeight * model.components;\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx] !== null) {\n          let newArray = null;\n          const jFactor = height / newHeight;\n          const iFactor = width / newWidth;\n          let usingHalf = false;\n          if (model.openGLDataType === model.context.FLOAT) {\n            newArray = new Float32Array(pixCount);\n          } else if (halfFloat && model.openGLDataType === halfFloat.HALF_FLOAT_OES) {\n            newArray = new Uint16Array(pixCount);\n            usingHalf = true;\n          } else {\n            newArray = new Uint8Array(pixCount);\n          }\n          for (let j = 0; j < newHeight; j++) {\n            const joff = j * newWidth * numComps;\n            const jidx = j * jFactor;\n            let jlow = Math.floor(jidx);\n            let jhi = Math.ceil(jidx);\n            if (jhi >= height) {\n              jhi = height - 1;\n            }\n            const jmix = jidx - jlow;\n            const jmix1 = 1.0 - jmix;\n            jlow = jlow * width * numComps;\n            jhi = jhi * width * numComps;\n            for (let i = 0; i < newWidth; i++) {\n              const ioff = i * numComps;\n              const iidx = i * iFactor;\n              let ilow = Math.floor(iidx);\n              let ihi = Math.ceil(iidx);\n              if (ihi >= width) {\n                ihi = width - 1;\n              }\n              const imix = iidx - ilow;\n              ilow *= numComps;\n              ihi *= numComps;\n              for (let c = 0; c < numComps; c++) {\n                if (usingHalf) {\n                  newArray[joff + ioff + c] = HalfFloat.toHalf(HalfFloat.fromHalf(data[idx][jlow + ilow + c]) * jmix1 * (1.0 - imix) + HalfFloat.fromHalf(data[idx][jlow + ihi + c]) * jmix1 * imix + HalfFloat.fromHalf(data[idx][jhi + ilow + c]) * jmix * (1.0 - imix) + HalfFloat.fromHalf(data[idx][jhi + ihi + c]) * jmix * imix);\n                } else {\n                  newArray[joff + ioff + c] = data[idx][jlow + ilow + c] * jmix1 * (1.0 - imix) + data[idx][jlow + ihi + c] * jmix1 * imix + data[idx][jhi + ilow + c] * jmix * (1.0 - imix) + data[idx][jhi + ihi + c] * jmix * imix;\n                }\n              }\n            }\n          }\n          pixData.push(newArray);\n          model.width = newWidth;\n          model.height = newHeight;\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // The output has to be filled\n    if (pixData.length === 0) {\n      for (let i = 0; i < data.length; i++) {\n        pixData.push(data[i]);\n      }\n    }\n    return pixData;\n  }\n\n  //----------------------------------------------------------------------------\n  function useTexStorage(dataType) {\n    if (model._openGLRenderWindow) {\n      if (model.resizable || model.renderable?.getResizable()) {\n        // Cannot use texStorage if the texture is supposed to be resizable.\n        return false;\n      }\n      if (model._openGLRenderWindow.getWebgl2()) {\n        const webGLInfo = model._openGLRenderWindow.getGLInformations();\n        if (webGLInfo.RENDERER.value.match(/WebKit/gi) && navigator.platform.match(/Mac/gi) && model.oglNorm16Ext && (dataType === VtkDataTypes.UNSIGNED_SHORT || dataType === VtkDataTypes.SHORT)) {\n          // Cannot use texStorage with EXT_texture_norm16 textures on Mac M1 GPU.\n          // No errors reported but the texture is unusable.\n          return false;\n        }\n        // Use texStorage for WebGL2\n        return true;\n      }\n      return false;\n    }\n    return false;\n  }\n\n  //----------------------------------------------------------------------------\n  publicAPI.create2DFromRaw = function (width, height, numComps, dataType, data) {\n    let flip = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType, true);\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Create an array of texture with one texture\n    const dataArray = [data];\n    const pixData = updateArrayDataType(dataType, dataArray);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // Source texture data from the PBO.\n    model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flip);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (scaledData[0] != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, scaledData[0]);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, scaledData[0]);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n\n    // always reset the flip\n    if (flip) {\n      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, false);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createCubeFromRaw = (width, height, numComps, dataType, data) => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_CUBE_MAP;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    model.maxLevel = data.length / 6 - 1;\n    publicAPI.createTexture();\n    publicAPI.bind();\n    const pixData = updateArrayDataType(dataType, data);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // invert the data because opengl is messed up with cube maps\n    // and uses the old renderman standard with Y going down\n    // even though it is completely at odds with OpenGL standards\n    const invertedData = [];\n    let widthLevel = model.width;\n    let heightLevel = model.height;\n    for (let i = 0; i < scaledData.length; i++) {\n      if (i % 6 === 0 && i !== 0) {\n        widthLevel /= 2;\n        heightLevel /= 2;\n      }\n      invertedData[i] = newTypedArray(dataType, heightLevel * widthLevel * model.components);\n      for (let y = 0; y < heightLevel; ++y) {\n        const row1 = y * widthLevel * model.components;\n        const row2 = (heightLevel - y - 1) * widthLevel * model.components;\n        invertedData[i].set(scaledData[i].slice(row2, row2 + widthLevel * model.components), row1);\n      }\n    }\n\n    // Source texture data from the PBO.\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 6, model.internalFormat, model.width, model.height);\n    }\n    // We get the 6 images\n    for (let i = 0; i < 6; i++) {\n      // For each mipmap level\n      let j = 0;\n      let w = model.width;\n      let h = model.height;\n      while (w >= 1 && h >= 1) {\n        // In webgl 1, all levels need to be defined. So if the latest level size is\n        // 8x8, we have to add 3 more null textures (4x4, 2x2, 1x1)\n        // In webgl 2, the attribute maxLevel will be use.\n        let tempData = null;\n        if (j <= model.maxLevel) {\n          tempData = invertedData[6 * j + i];\n        }\n        if (useTexStorage(dataType)) {\n          if (tempData != null) {\n            model.context.texSubImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, w, h, model.format, model.openGLDataType, tempData);\n          }\n        } else {\n          model.context.texImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, model.internalFormat, w, h, 0, model.format, model.openGLDataType, tempData);\n        }\n        j++;\n        w /= 2;\n        h /= 2;\n      }\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);\n    // generateMipmap must not be called here because we manually upload all levels\n    // if it is called, all levels will be overwritten\n\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createDepthFromRaw = (width, height, dataType, data) => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    model.format = model.context.DEPTH_COMPONENT;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      if (dataType === VtkDataTypes.FLOAT) {\n        model.internalFormat = model.context.DEPTH_COMPONENT32F;\n      } else {\n        model.internalFormat = model.context.DEPTH_COMPONENT16;\n      }\n    } else {\n      model.internalFormat = model.context.DEPTH_COMPONENT;\n    }\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = 1;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (data != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, data);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, data);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.create2DFromImage = image => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(VtkDataTypes.UNSIGNED_CHAR);\n    publicAPI.getInternalFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n    publicAPI.getFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = 4;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n\n    // Scale up the texture to the next highest power of two dimensions (if needed) and flip y.\n    const needNearestPowerOfTwo = !model._openGLRenderWindow.getWebgl2() && (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height));\n    const canvas = document.createElement('canvas');\n    canvas.width = needNearestPowerOfTwo ? nearestPowerOfTwo(image.width) : image.width;\n    canvas.height = needNearestPowerOfTwo ? nearestPowerOfTwo(image.height) : image.height;\n    model.width = canvas.width;\n    model.height = canvas.height;\n    const ctx = canvas.getContext('2d');\n    ctx.translate(0, canvas.height);\n    ctx.scale(1, -1);\n    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);\n    const safeImage = canvas;\n    if (useTexStorage(VtkDataTypes.UNSIGNED_CHAR)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (safeImage != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, safeImage);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, safeImage);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(VtkDataTypes.UNSIGNED_CHAR, model.oglNorm16Ext, model.useHalfFloat);\n    publicAPI.deactivate();\n    return true;\n  };\n\n  // Compute scale and offset per component from min and max per component\n  function computeScaleOffsets(min, max, numComps) {\n    const offset = new Array(numComps);\n    const scale = new Array(numComps);\n    for (let c = 0; c < numComps; ++c) {\n      offset[c] = min[c];\n      scale[c] = max[c] - min[c] || 1.0;\n    }\n    return {\n      scale,\n      offset\n    };\n  }\n\n  // HalfFloat only represents numbers between [-2048, 2048] exactly accurate,\n  // for numbers outside of this range there is a precision limitation\n  function hasExactHalfFloat(offset, scale) {\n    // Per Component\n    for (let c = 0; c < offset.length; c++) {\n      const min = offset[c];\n      const max = scale[c] + min;\n      if (min < -2048 || min > 2048 || max < -2048 || max > 2048) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function setUseHalfFloat(dataType, offset, scale, preferSizeOverAccuracy) {\n    publicAPI.getOpenGLDataType(dataType);\n    let useHalfFloat = false;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      useHalfFloat = model.openGLDataType === model.context.HALF_FLOAT;\n    } else {\n      const halfFloatExt = model.context.getExtension('OES_texture_half_float');\n      useHalfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;\n    }\n\n    // Don't consider halfFloat and convert back to Float when the range of data does not generate an accurate halfFloat\n    // AND it is not preferable to have a smaller texture than an exact texture.\n    const isHalfFloat = useHalfFloat && (hasExactHalfFloat(offset, scale) || preferSizeOverAccuracy);\n    model.useHalfFloat = isHalfFloat;\n  }\n  function processDataArray(dataArray, preferSizeOverAccuracy) {\n    const numComps = dataArray.getNumberOfComponents();\n    const dataType = dataArray.getDataType();\n    const data = dataArray.getData();\n\n    // Compute min max from array\n    // Using the vtkDataArray.getRange() enables caching\n    const minArray = new Array(numComps);\n    const maxArray = new Array(numComps);\n    for (let c = 0; c < numComps; ++c) {\n      const [min, max] = dataArray.getRange(c);\n      minArray[c] = min;\n      maxArray[c] = max;\n    }\n    const scaleOffsets = computeScaleOffsets(minArray, maxArray, numComps);\n\n    // preferSizeOverAccuracy will override norm16 due to bug with norm16 implementation\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1408247\n    setUseHalfFloat(dataType, scaleOffsets.offset, scaleOffsets.scale, preferSizeOverAccuracy);\n\n    // since our default is to use half float, in case that we can't use it\n    // we need to use another type\n    if (!model.useHalfFloat) {\n      publicAPI.getOpenGLDataType(dataType, true);\n    }\n    return {\n      numComps,\n      dataType,\n      data,\n      scaleOffsets\n    };\n  }\n  publicAPI.create2DFilterableFromRaw = function (width, height, numberOfComponents, dataType, values) {\n    let preferSizeOverAccuracy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    return publicAPI.create2DFilterableFromDataArray(width, height, vtkDataArray.newInstance({\n      numberOfComponents,\n      dataType,\n      values\n    }), preferSizeOverAccuracy);\n  };\n  publicAPI.create2DFilterableFromDataArray = function (width, height, dataArray) {\n    let preferSizeOverAccuracy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const {\n      numComps,\n      dataType,\n      data\n    } = processDataArray(dataArray, preferSizeOverAccuracy);\n    publicAPI.create2DFromRaw(width, height, numComps, dataType, data);\n  };\n  //----------------------------------------------------------------------------\n  publicAPI.create3DFromRaw = (width, height, depth, numComps, dataType, data) => {\n    // Permit OpenGLDataType to be half float, if applicable, for 3D\n    publicAPI.getOpenGLDataType(dataType);\n\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_3D;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = depth;\n    model.numberOfDimensions = 3;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n    // Create an array of texture with one texture\n    const dataArray = [data];\n    const is3DArray = true;\n    const pixData = updateArrayDataType(dataType, dataArray, is3DArray);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n\n    // openGLDataType\n\n    if (useTexStorage(dataType)) {\n      model.context.texStorage3D(model.target, 1, model.internalFormat, model.width, model.height, model.depth);\n      if (scaledData[0] != null) {\n        model.context.texSubImage3D(model.target, 0, 0, 0, 0, model.width, model.height, model.depth, model.format, model.openGLDataType, scaledData[0]);\n      }\n    } else {\n      model.context.texImage3D(model.target, 0, model.internalFormat, model.width, model.height, model.depth, 0, model.format, model.openGLDataType, scaledData[0]);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  // This method simulates a 3D texture using 2D\n  // Prefer create3DFilterableFromDataArray to enable caching of min and max values\n  publicAPI.create3DFilterableFromRaw = function (width, height, depth, numberOfComponents, dataType, values) {\n    let preferSizeOverAccuracy = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    return publicAPI.create3DFilterableFromDataArray(width, height, depth, vtkDataArray.newInstance({\n      numberOfComponents,\n      dataType,\n      values\n    }), preferSizeOverAccuracy);\n  };\n\n  //----------------------------------------------------------------------------\n  // This method create a 3D texture from dimensions and a DataArray\n  publicAPI.create3DFilterableFromDataArray = function (width, height, depth, dataArray) {\n    let preferSizeOverAccuracy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const {\n      numComps,\n      dataType,\n      data,\n      scaleOffsets\n    } = processDataArray(dataArray, preferSizeOverAccuracy);\n    const numPixelsIn = width * height * depth;\n    const offset = [];\n    const scale = [];\n    for (let c = 0; c < numComps; ++c) {\n      offset[c] = 0.0;\n      scale[c] = 1.0;\n    }\n\n    // store the information, we will need it later\n    // offset and scale are the offset and scale required to get\n    // the texture value back to data values ala\n    // data = texture * scale + offset\n    // and texture = (data - offset)/scale\n    model.volumeInfo = {\n      scale,\n      offset,\n      dataComputedScale: scaleOffsets.scale,\n      dataComputedOffset: scaleOffsets.offset,\n      width,\n      height,\n      depth\n    };\n\n    // Create a copy of scale and offset to avoid aliasing issues\n    // Original is read only, copy is read/write\n    // Use the copy as volumeInfo.scale and volumeInfo.offset\n    const scaleOffsetsCopy = structuredClone(scaleOffsets);\n\n    // WebGL2 path, we have 3d textures etc\n    if (model._openGLRenderWindow.getWebgl2()) {\n      if (model.oglNorm16Ext && !model.useHalfFloat && dataType === VtkDataTypes.SHORT) {\n        for (let c = 0; c < numComps; ++c) {\n          model.volumeInfo.scale[c] = 32767.0;\n        }\n        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);\n      }\n      if (model.oglNorm16Ext && !model.useHalfFloat && dataType === VtkDataTypes.UNSIGNED_SHORT) {\n        for (let c = 0; c < numComps; ++c) {\n          model.volumeInfo.scale[c] = 65535.0;\n        }\n        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);\n      }\n      if (dataType === VtkDataTypes.FLOAT || model.useHalfFloat && (dataType === VtkDataTypes.SHORT || dataType === VtkDataTypes.UNSIGNED_SHORT)) {\n        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);\n      }\n      if (dataType === VtkDataTypes.UNSIGNED_CHAR) {\n        for (let c = 0; c < numComps; ++c) {\n          model.volumeInfo.scale[c] = 255.0;\n        }\n        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);\n      }\n      // otherwise convert to float\n      const newArray = new Float32Array(numPixelsIn * numComps);\n      // use computed scale and offset\n      model.volumeInfo.offset = scaleOffsetsCopy.offset;\n      model.volumeInfo.scale = scaleOffsetsCopy.scale;\n      let count = 0;\n      const scaleInverse = scaleOffsetsCopy.scale.map(s => 1 / s);\n      for (let i = 0; i < numPixelsIn; i++) {\n        for (let nc = 0; nc < numComps; nc++) {\n          newArray[count] = (data[count] - scaleOffsetsCopy.offset[nc]) * scaleInverse[nc];\n          count++;\n        }\n      }\n      return publicAPI.create3DFromRaw(width, height, depth, numComps, VtkDataTypes.FLOAT, newArray);\n    }\n\n    // not webgl2, deal with webgl1, no 3d textures\n    // and maybe no float textures\n\n    let volCopyData = (outArray, outIdx, inValue, smin, smax) => {\n      outArray[outIdx] = inValue;\n    };\n    let dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;\n    // unsigned char gets used as is\n    if (dataType === VtkDataTypes.UNSIGNED_CHAR) {\n      for (let c = 0; c < numComps; ++c) {\n        scaleOffsetsCopy.offset[c] = 0.0;\n        scaleOffsetsCopy.scale[c] = 255.0;\n      }\n    } else if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n      // use float textures scaled to 0.0 to 1.0\n      dataTypeToUse = VtkDataTypes.FLOAT;\n      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {\n        outArray[outIdx] = (inValue - soffset) / sscale;\n      };\n    } else {\n      // worst case, scale data to uchar\n      dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;\n      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {\n        outArray[outIdx] = 255.0 * (inValue - soffset) / sscale;\n      };\n    }\n\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataTypeToUse);\n    publicAPI.getInternalFormat(dataTypeToUse, numComps);\n    publicAPI.getFormat(dataTypeToUse, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n\n    // have to pack this 3D texture into pot 2D texture\n    model.target = model.context.TEXTURE_2D;\n    model.components = numComps;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n\n    // MAX_TEXTURE_SIZE gives the max dimensions that can be supported by the GPU,\n    // but it doesn't mean it will fit in memory. If we have to use a float data type\n    // or 4 components, there are good chances that the texture size will blow up\n    // and could not fit in the GPU memory. Use a smaller texture size in that case,\n    // which will force a downsampling of the dataset.\n    // That problem does not occur when using webGL2 since we can pack the data in\n    // denser textures based on our data type.\n    // TODO: try to fit in the biggest supported texture, catch the gl error if it\n    // does not fix (OUT_OF_MEMORY), then attempt with smaller texture\n    let maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);\n    if (maxTexDim > 4096 && (dataTypeToUse === VtkDataTypes.FLOAT || numComps >= 3)) {\n      maxTexDim = 4096;\n    }\n\n    // compute estimate for XY subsample\n    let xstride = 1;\n    let ystride = 1;\n    if (numPixelsIn > maxTexDim * maxTexDim) {\n      xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));\n      ystride = xstride;\n    }\n    let targetWidth = Math.sqrt(numPixelsIn) / xstride;\n    targetWidth = nearestPowerOfTwo(targetWidth);\n    // determine X reps\n    const xreps = Math.floor(targetWidth * xstride / width);\n    const yreps = Math.ceil(depth / xreps);\n    const targetHeight = nearestPowerOfTwo(height * yreps / ystride);\n    model.width = targetWidth;\n    model.height = targetHeight;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // store the information, we will need it later\n    model.volumeInfo.xreps = xreps;\n    model.volumeInfo.yreps = yreps;\n    model.volumeInfo.xstride = xstride;\n    model.volumeInfo.ystride = ystride;\n    model.volumeInfo.offset = scaleOffsetsCopy.offset;\n    model.volumeInfo.scale = scaleOffsetsCopy.scale;\n\n    // OK stuff the data into the 2d TEXTURE\n\n    // first allocate the new texture\n    let newArray;\n    const pixCount = targetWidth * targetHeight * numComps;\n    if (dataTypeToUse === VtkDataTypes.FLOAT) {\n      newArray = new Float32Array(pixCount);\n    } else {\n      newArray = new Uint8Array(pixCount);\n    }\n\n    // then stuff the data into it, nothing fancy right now\n    // for stride\n    let outIdx = 0;\n    const tileWidth = Math.floor(width / xstride);\n    const tileHeight = Math.floor(height / ystride);\n    for (let yRep = 0; yRep < yreps; yRep++) {\n      const xrepsThisRow = Math.min(xreps, depth - yRep * xreps);\n      const outXContIncr = numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));\n      for (let tileY = 0; tileY < tileHeight; tileY++) {\n        for (let xRep = 0; xRep < xrepsThisRow; xRep++) {\n          const inOffset = numComps * ((yRep * xreps + xRep) * width * height + ystride * tileY * width);\n          for (let tileX = 0; tileX < tileWidth; tileX++) {\n            // copy value\n            for (let nc = 0; nc < numComps; nc++) {\n              volCopyData(newArray, outIdx, data[inOffset + xstride * tileX * numComps + nc], scaleOffsetsCopy.offset[nc], scaleOffsetsCopy.scale[nc]);\n              outIdx++;\n            }\n          }\n        }\n        outIdx += outXContIncr;\n      }\n    }\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataTypeToUse)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (newArray != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, newArray);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, newArray);\n    }\n    publicAPI.deactivate();\n    return true;\n  };\n  publicAPI.setOpenGLRenderWindow = rw => {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getMaximumTextureSize = ctx => {\n    if (ctx && ctx.isCurrent()) {\n      return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);\n    }\n    return -1;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  _openGLRenderWindow: null,\n  _forceInternalFormat: false,\n  context: null,\n  handle: 0,\n  sendParametersTime: null,\n  textureBuildTime: null,\n  numberOfDimensions: 0,\n  target: 0,\n  format: 0,\n  openGLDataType: 0,\n  components: 0,\n  width: 0,\n  height: 0,\n  depth: 0,\n  autoParameters: true,\n  wrapS: Wrap.CLAMP_TO_EDGE,\n  wrapT: Wrap.CLAMP_TO_EDGE,\n  wrapR: Wrap.CLAMP_TO_EDGE,\n  minificationFilter: Filter.NEAREST,\n  magnificationFilter: Filter.NEAREST,\n  minLOD: -1000.0,\n  maxLOD: 1000.0,\n  baseLevel: 0,\n  maxLevel: 1000,\n  generateMipmap: false,\n  // use half float by default, but it will get set\n  // to false if the context does not support it or\n  // the voxel intensity range is out of the accurate\n  // range of half float\n  useHalfFloat: true,\n  oglNorm16Ext: null,\n  allocatedGPUMemoryInBytes: 0\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.sendParametersTime = {};\n  obj(model.sendParametersTime, {\n    mtime: 0\n  });\n  model.textureBuildTime = {};\n  obj(model.textureBuildTime, {\n    mtime: 0\n  });\n\n  // Build VTK API\n  set(publicAPI, model, ['format', 'openGLDataType']);\n  setGet(publicAPI, model, ['keyMatrixTime', 'minificationFilter', 'magnificationFilter', 'wrapS', 'wrapT', 'wrapR', 'generateMipmap', 'oglNorm16Ext']);\n  get(publicAPI, model, ['width', 'height', 'volumeInfo', 'components', 'handle', 'target', 'allocatedGPUMemoryInBytes']);\n  moveToProtected(publicAPI, model, ['openGLRenderWindow']);\n\n  // Object methods\n  vtkOpenGLTexture(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLTexture');\n\n// ----------------------------------------------------------------------------\n\nvar vtkOpenGLTexture$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkTexture', newInstance);\n\nexport { vtkOpenGLTexture$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}