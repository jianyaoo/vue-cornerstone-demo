{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { m as macro } from '../../macros2.js';\nimport { d as dot, e as distance2BetweenPoints } from '../../Common/Core/Math/index.js';\nimport vtkCellArray from '../../Common/Core/CellArray.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport vtkPoints from '../../Common/Core/Points.js';\nimport vtkDataSetAttributes from '../../Common/DataModel/DataSetAttributes.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkContourTriangulator from './ContourTriangulator.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport Constants from './ClipClosedSurface/Constants.js';\nconst {\n  vtkErrorMacro,\n  capitalize\n} = macro;\nconst {\n  ScalarMode\n} = Constants;\nfunction vtkClipClosedSurface(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkClipClosedSurface');\n  publicAPI.getMTime = () => model.clippingPlanes.reduce((a, b) => b.getMTime() > a ? b.getMTime() : a, model.mtime);\n\n  /**\n   * Take three colors as doubles, and convert to unsigned char.\n   *\n   * @param {Number} color1\n   * @param {Number} color2\n   * @param {Number} color3\n   * @param {Number[3][3]} colors\n   */\n  function createColorValues(color1, color2, color3, colors) {\n    const dcolors = [color1, color2, color3];\n    const clamp = (n, min, max) => Math.min(Math.max(n, min), max);\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        colors[i][j] = Math.round(clamp(dcolors[i][j], 0, 1) * 255);\n      }\n    }\n  }\n\n  /**\n   * Point interpolation for clipping and contouring, given the scalar\n   * values (v0, v1) for the two endpoints (p0, p1).  The use of this\n   * function guarantees perfect consistency in the results.\n   *\n   * @param {vtkPoints} points\n   * @param {vtkDataArray} pointData\n   * @param {CCSEdgeLocator} locator\n   * @param {Number} tol\n   * @param {Number} i0\n   * @param {Number} i1\n   * @param {Number} v0\n   * @param {Number} v1\n   * @param {Number} i\n   * @returns {Number}\n   */\n  function interpolateEdge(points, pointData, locator, tol, i0, i1, v0, v1) {\n    // This swap guarantees that exactly the same point is computed\n    // for both line directions, as long as the endpoints are the same.\n    if (v1 > 0) {\n      // eslint-disable-next-line no-param-reassign\n      [i0, i1] = [i1, i0];\n      // eslint-disable-next-line no-param-reassign\n      [v0, v1] = [v1, v0];\n    }\n    // After the above swap, i0 will be kept, and i1 will be clipped\n\n    // Check to see if this point has already been computed\n    const edge = locator.insertUniqueEdge(i0, i1);\n    if (edge.value != null) {\n      return edge.value;\n    }\n\n    // Get the edge and interpolate the new point\n    const p0 = points.getPoint(i0);\n    const p1 = points.getPoint(i1);\n    const f = v0 / (v0 - v1);\n    const s = 1.0 - f;\n    const t = 1.0 - s;\n    const p = [s * p0[0] + t * p1[0], s * p0[1] + t * p1[1], s * p0[2] + t * p1[2]];\n    const tol2 = tol * tol;\n\n    // Make sure that new point is far enough from kept point\n    if (distance2BetweenPoints(p, p0) < tol2) {\n      edge.value = i0;\n      return i0;\n    }\n    if (distance2BetweenPoints(p, p1) < tol2) {\n      edge.value = i1;\n      return i1;\n    }\n    edge.value = points.insertNextTuple(p);\n    pointData.interpolateData(pointData, i0, i1, edge.value, t);\n    return edge.value;\n  }\n\n  /**\n   * Method for clipping lines and copying the scalar data.\n   *\n   * @param {vtkPoints} points\n   * @param {vtkDataArray} pointScalars\n   * @param {vtkDataSetAttributesk} pointData\n   * @param {vtkEdgeLocator} edgeLocator\n   * @param {vtkCellArray} inputLines\n   * @param {vtkCellArray} outputLines\n   * @param {vtkDataSetAttributes} inLineData\n   * @param {vtkDataSetAttributes} outLineData\n   */\n  function clipLines(points, pointScalars, pointData, edgeLocator, inputLines, outputLines, inLineData, outLineData) {\n    let numPts;\n    let i0;\n    let i1;\n    let v0;\n    let v1;\n    let c0;\n    let c1;\n    const linePts = [];\n    const values = inputLines.getData();\n    let cellId = 0;\n    for (let i = 0; i < values.length; i += numPts + 1, cellId++) {\n      numPts = values[i];\n      i1 = values[i + 1];\n      v1 = pointScalars.getData()[i1];\n      c1 = v1 > 0;\n      for (let j = 2; j <= numPts; j++) {\n        i0 = i1;\n        v0 = v1;\n        c0 = c1;\n        i1 = values[i + j];\n        v1 = pointScalars.getData()[i1];\n        c1 = v1 > 0;\n\n        // If at least one point wasn't clipped\n        if (c0 || c1) {\n          // If only one end was clipped, interpolate new point\n          if (c0 ? !c1 : c1) {\n            linePts[c0 ? 1 : 0] = interpolateEdge(points, pointData, edgeLocator, model.tolerance, i0, i1, v0, v1);\n          }\n\n          // If endpoints are different, insert the line segment\n          if (i0 !== i1) {\n            linePts[0] = i0;\n            linePts[1] = i1;\n            const newCellId = outputLines.insertNextCell(linePts);\n            // outLineData.copyData(inLineData, cellId, newCellId);\n            outLineData.passData(inLineData, cellId, newCellId);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Break polylines into individual lines, copying scalar values from\n   * inputScalars starting at firstLineScalar.  If inputScalars is zero,\n   * then scalars will be set to color.  If scalars is zero, then no\n   * scalars will be generated.\n   *\n   * @param {vtkCellArray} inputLines\n   * @param {vtkCellArray} outputLines\n   * @param {vtkDataArray} inputScalars\n   * @param {Number} firstLineScalar\n   * @param {vtkDataArray} scalars\n   * @param {Vector3} color\n   */\n  function breakPolylines(inputLines, outputLines, inputScalars, firstLineScalar, scalars, color) {\n    const cellColor = [...color];\n    let cellId = 0;\n    const values = inputLines.getData();\n    let numPts;\n    for (let i = 0; i < values.length; i += numPts + 1) {\n      numPts = values[i];\n      if (inputScalars) {\n        inputScalars.getTuple(firstLineScalar + cellId++, cellColor);\n      }\n      for (let j = 1; j < numPts; j++) {\n        outputLines.insertNextCell([values[i + j], values[i + j + 1]]);\n        if (scalars) {\n          scalars.insertNextTuple(cellColor);\n        }\n      }\n    }\n  }\n\n  /**\n   * Copy polygons and their associated scalars to a new array.\n   * If inputScalars is set to zero, set polyScalars to color instead.\n   * If polyScalars is set to zero, don't generate scalars.\n   *\n   * @param {vtkCellArray} inputPolys\n   * @param {vtkCellArray} outputPolys\n   * @param {vtkDataArray} inputScalars\n   * @param {Number} firstPolyScalar\n   * @param {vtkDataArray} polyScalars\n   * @param {Vector3} color\n   */\n  function copyPolygons(inputPolys, outputPolys, inputScalars, firstPolyScalar, polyScalars, color) {\n    if (!inputPolys) {\n      return;\n    }\n    outputPolys.deepCopy(inputPolys);\n    if (polyScalars) {\n      const scalarValue = [...color];\n      const n = outputPolys.getNumberOfCells();\n      polyScalars.insertTuple(n - 1, scalarValue);\n      if (inputScalars) {\n        for (let i = 0; i < n; i++) {\n          inputScalars.getTuple(i + firstPolyScalar, scalarValue);\n          polyScalars.setTuple(i, scalarValue);\n        }\n      } else {\n        for (let i = 0; i < n; i++) {\n          polyScalars.setTuple(i, scalarValue);\n        }\n      }\n    }\n  }\n  function breakTriangleStrips(inputStrips, polys, inputScalars, firstStripScalar, polyScalars, color) {\n    if (inputStrips.getNumberOfCells() === 0) {\n      return;\n    }\n    const values = inputStrips.getData();\n    let cellId = firstStripScalar;\n    let numPts;\n    for (let i = 0; i < values.length; i += numPts + 1, cellId++) {\n      numPts = values[i];\n      // vtkTriangleStrip.decomposeStrip(numPts, values, polys);\n      let p1 = values[i + 1];\n      let p2 = values[i + 2];\n      for (let j = 0; j < numPts - 2; j++) {\n        const p3 = values[i + j + 3];\n        if (j % 2) {\n          polys.insertNextCell([p2, p1, p3]);\n        } else {\n          polys.insertNextCell([p1, p2, p3]);\n        }\n        p1 = p2;\n        p2 = p3;\n      }\n      if (polyScalars) {\n        const scalarValue = [...color];\n        if (inputScalars) {\n          // If there are input scalars, use them instead of \"color\"\n          inputScalars.getTuple(cellId, scalarValue);\n        }\n        const n = numPts - 3;\n        const m = polyScalars.getNumberOfTuples();\n        if (n >= 0) {\n          // First insert is just to allocate space\n          polyScalars.insertTuple(m + n, scalarValue);\n          for (let k = 0; k < n; k++) {\n            polyScalars.setTuple(m + k, scalarValue);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Given some closed contour lines, create a triangle mesh that\n   * fills those lines.  The input lines must be single-segment lines,\n   * not polylines.  The input lines do not have to be in order.\n   * Only lines from firstLine to will be used.  Specify the normal\n   * of the clip plane, which will be opposite the normals\n   * of the polys that will be produced.  If outCD has scalars, then color\n   * scalars will be added for each poly that is created.\n   *\n   * @param {vtkPolyData} polyData\n   * @param {Number} firstLine\n   * @param {Number} numLines\n   * @param {vtkCellArray} outputPolys\n   * @param {Vector3} normal\n   */\n  function triangulateContours(polyData, firstLine, numLines, outputPolys, normal) {\n    // If no cut lines were generated, there's nothing to do\n    if (numLines <= 0) {\n      return;\n    }\n    const triangulationError = !vtkContourTriangulator.triangulateContours(polyData, firstLine, numLines, outputPolys, [-normal[0], -normal[1], -normal[2]]);\n    if (triangulationError && model.triangulationErrorDisplay) {\n      vtkErrorMacro('Triangulation failed, polyData may not be watertight.');\n    }\n  }\n\n  /**\n   * Break polylines into individual lines, copying scalar values from\n   * inputScalars starting at firstLineScalar. If inputScalars is zero,\n   * then scalars will be set to color. If scalars is zero, then no\n   * scalars will be generated.\n   *\n   * @param {Number[]} polygon\n   * @param {vtkPoints} points\n   * @param {vtkCellArray} triangles\n   * @returns {Boolean}\n   */\n  function triangulatePolygon(polygon, points, triangles) {\n    return vtkContourTriangulator.triangulatePolygon(polygon, points, triangles);\n  }\n\n  /**\n   * Clip and contour polys in one step, in order to guarantee\n   * that the contour lines exactly match the new free edges of\n   * the clipped polygons.  This exact correspondence is necessary\n   * in order to guarantee that the surface remains closed.\n   *\n   * @param {vtkPoints} points\n   * @param {vtkDataArray} pointScalars\n   * @param {vtkDataSetAttributes} pointData\n   * @param {vtkEdgeLocator} edgeLocator\n   * @param {Number} triangulate\n   * @param {vtkCellArray} inputPolys\n   * @param {vtkCellArray} outputPolys\n   * @param {vtkCellArray} outputLines\n   * @param {vtkDataSetAttributes} inCellData\n   * @param {vtkDataSetAttributes} outPolyData\n   * @param {vtkDataSetAttributes} outLineData\n   */\n  function clipAndContourPolys(points, pointScalars, pointData, edgeLocator, triangulate, inputPolys, outputPolys, outputLines, inCellData, outPolyData, outLineData) {\n    const idList = model._idList;\n    // How many sides for output polygons?\n    let polyMax = Number.MAX_VALUE;\n    if (triangulate) {\n      if (triangulate < 4) {\n        // triangles only\n        polyMax = 3;\n      } else if (triangulate === 4) {\n        // allow triangles and quads\n        polyMax = 4;\n      }\n    }\n\n    // eslint-disable-next-line prefer-const\n    let triangulationFailure = false;\n\n    // Go through all cells and clip them\n    const values = inputPolys.getData();\n    const linePts = [];\n    let cellId = 0;\n    let numPts;\n    for (let i = 0; i < values.length; i += numPts + 1, cellId++) {\n      numPts = values[i];\n      let i1 = values[i + numPts];\n      let v1 = pointScalars.getData()[i1];\n      let c1 = v1 > 0;\n\n      // The ids for the current edge: init j0 to -1 if i1 will be clipped\n      let j0 = c1 ? i1 : -1;\n      let j1 = 0;\n\n      // To store the ids of the contour line\n      linePts[0] = 0;\n      linePts[1] = 0;\n      let idListIdx = 0;\n      for (let j = 1; j <= numPts; j++) {\n        // Save previous point info\n        const i0 = i1;\n        const v0 = v1;\n        const c0 = c1;\n\n        // Generate new point info\n        i1 = values[i + j];\n        v1 = pointScalars.getData()[i1];\n        c1 = v1 > 0;\n\n        // If at least one edge end point wasn't clipped\n        if (c0 || c1) {\n          // If only one end was clipped, interpolate new point\n          if (c0 ? !c1 : c1) {\n            j1 = interpolateEdge(points, pointData, edgeLocator, model.tolerance, i0, i1, v0, v1);\n            if (j1 !== j0) {\n              idList[idListIdx++] = j1;\n              j0 = j1;\n            }\n\n            // Save as one end of the contour line\n            linePts[c0 ? 1 : 0] = j1;\n          }\n          if (c1) {\n            j1 = i1;\n            if (j1 !== j0) {\n              idList[idListIdx++] = j1;\n              j0 = j1;\n            }\n          }\n        }\n      }\n\n      // Insert the clipped poly\n      const numPoints = idListIdx;\n      idList.length = numPoints;\n      if (model.triangulatePolys && numPoints > polyMax) {\n        // TODO: Support triangulatePolygon\n        let newCellId = outputPolys.getNumberOfCells();\n        // Triangulate the poly and insert triangles into output.\n        const success = triangulatePolygon(idList, points, outputPolys);\n        if (!success) {\n          triangulationFailure = true;\n        }\n\n        // Copy the attribute data to the triangle cells\n        const ncells = outputPolys.getNumberOfCells();\n        for (; newCellId < ncells; newCellId++) {\n          outPolyData.passData(inCellData, cellId, newCellId);\n        }\n      } else if (numPoints > 2) {\n        // Insert the polygon without triangulating it\n        const newCellId = outputPolys.insertNextCell(idList);\n        outPolyData.passData(inCellData, cellId, newCellId);\n      }\n\n      // Insert the contour line if one was created\n      if (linePts[0] !== linePts[1]) {\n        const newCellId = outputLines.insertNextCell(linePts);\n        outLineData.passData(inCellData, cellId, newCellId);\n      }\n    }\n    if (triangulationFailure && model.triangulationErrorDisplay) {\n      vtkErrorMacro('Triangulation failed, output may not be watertight');\n    }\n  }\n\n  /**\n   * Squeeze the points and store them in the output.  Only the points that\n   * are used by the cells will be saved, and the pointIds of the cells will\n   * be modified.\n   *\n   * @param {vtkPolyData} output\n   * @param {vtkPoints} points\n   * @param {vtkDataSetAttributes} pointData\n   * @param {String} outputPointDataType\n   */\n  function squeezeOutputPoints(output, points, pointData, outputPointDataType) {\n    // Create a list of points used by cells\n    const n = points.getNumberOfPoints();\n    let numNewPoints = 0;\n    const outPointData = output.getPointData();\n    const pointMap = [];\n    pointMap.length = n;\n    const cellArrays = [output.getVerts(), output.getLines(), output.getPolys(), output.getStrips()];\n\n    // Find all the newPoints that are used by cells\n    cellArrays.forEach(cellArray => {\n      if (!cellArray) {\n        return;\n      }\n      const values = cellArray.getData();\n      let numPts;\n      let pointId;\n      for (let i = 0; i < values.length; i += numPts + 1) {\n        numPts = values[i];\n        for (let j = 1; j <= numPts; j++) {\n          pointId = values[i + j];\n          if (pointMap[pointId] === undefined) {\n            pointMap[pointId] = numNewPoints++;\n          }\n        }\n      }\n    });\n\n    // Create exactly the number of points that are required\n    const newPoints = vtkPoints.newInstance({\n      size: numNewPoints * 3,\n      dataType: outputPointDataType\n    });\n    // outPointData.copyAllocate(pointData, numNewPoints, 0);\n\n    const p = [];\n    let newPointId;\n    for (let pointId = 0; pointId < n; pointId++) {\n      newPointId = pointMap[pointId];\n      if (newPointId !== undefined) {\n        points.getPoint(pointId, p);\n        newPoints.setTuple(newPointId, p);\n        outPointData.passData(pointData, pointId, newPointId);\n        // outPointData.copyData(pointData, pointId, newPointId);\n      }\n    }\n\n    // Change the cell pointIds to reflect the new point array\n    cellArrays.forEach(cellArray => {\n      if (!cellArray) {\n        return;\n      }\n      const values = cellArray.getData();\n      let numPts;\n      let pointId;\n      for (let i = 0; i < values.length; i += numPts + 1) {\n        numPts = values[i];\n        for (let j = 1; j <= numPts; j++) {\n          pointId = values[i + j];\n          values[i + j] = pointMap[pointId];\n        }\n      }\n    });\n    output.setPoints(newPoints);\n  }\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    const output = vtkPolyData.newInstance();\n    outData[0] = output;\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (model._idList == null) {\n      model._idList = [];\n    } else {\n      model._idList.length = 0;\n    }\n\n    // Get the input points\n    const inputPoints = input.getPoints();\n    let numPts = 0;\n    let inputPointsType = VtkDataTypes.FLOAT;\n    if (inputPoints) {\n      numPts = inputPoints.getNumberOfPoints();\n      inputPointsType = inputPoints.getDataType();\n    }\n\n    // Force points to double precision, copy the point attributes\n    const points = vtkPoints.newInstance({\n      size: numPts * 3,\n      dataType: VtkDataTypes.DOUBLE\n    });\n    const pointData = vtkDataSetAttributes.newInstance();\n    let inPointData = null;\n    if (model.passPointData) {\n      inPointData = input.getPointData();\n      // pointData.interpolateAllocate(inPointData, numPts, 0);\n    }\n    const point = [];\n    for (let ptId = 0; ptId < numPts; ptId++) {\n      inputPoints.getPoint(ptId, point);\n      points.setTuple(ptId, point);\n      if (inPointData) {\n        // pointData.copyData(inPointData, ptId, ptId);\n        pointData.passData(inPointData, ptId, ptId);\n      }\n    }\n\n    // An edge locator to avoid point duplication while clipping\n    const edgeLocator = vtkEdgeLocator.newInstance();\n\n    // A temporary polydata for the contour lines that are triangulated\n    const tmpContourData = vtkPolyData.newInstance();\n\n    // The cell scalars\n    let lineScalars;\n    let polyScalars;\n    let inputScalars;\n\n    // For input scalars: the offsets to the various cell types\n    let firstLineScalar = 0;\n    let firstPolyScalar = 0;\n    let firstStripScalar = 0;\n\n    // Make the colors to be used on the data\n    let numberOfScalarComponents = 1;\n    const colors = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\n    if (model.scalarMode === ScalarMode.COLORS) {\n      numberOfScalarComponents = 3;\n      createColorValues(model.baseColor, model.clipColor, model.activePlaneColor, colors);\n    } else if (model.scalarMode === ScalarMode.LABELS) {\n      colors[0][0] = 0;\n      colors[1][0] = 1;\n      colors[2][0] = 2;\n    }\n\n    // This is set if we have to work with scalars. The input scalars\n    // will be copied if they are unsigned char with 3 components, otherwise\n    // new scalars will be generated.\n    const numVerts = input.getVerts()?.getNumberOfCells() || 0;\n    const inputLines = input.getLines();\n    const numLines = inputLines?.getNumberOfCells() || 0;\n    const inputPolys = input.getPolys();\n    const numPolys = inputPolys?.getNumberOfCells() || 0;\n    const numStrips = input.getStrips()?.getNumberOfCells() || 0;\n    if (model.scalarMode !== ScalarMode.NONE) {\n      lineScalars = vtkDataArray.newInstance({\n        dataType: VtkDataTypes.UNSIGNED_CHAR,\n        empty: true,\n        // size: 0,\n        // values: new Uint8Array(numLines * 3),\n        numberOfComponents: numberOfScalarComponents\n      });\n      const tryInputScalars = input.getCellData().getScalars();\n      // Get input scalars if they are RGB color scalars\n      if (tryInputScalars && tryInputScalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR && numberOfScalarComponents === 3 && tryInputScalars.getNumberOfComponents() === 3) {\n        inputScalars = input.getCellData().getScalars();\n        firstLineScalar = numVerts;\n        firstPolyScalar = numVerts + numLines;\n        firstStripScalar = numVerts + numLines + numPolys;\n      }\n    }\n\n    // Break the input lines into segments, generate scalars for lines\n    let lines;\n    if (numLines > 0) {\n      lines = vtkCellArray.newInstance({\n        dataType: inputLines.getDataType(),\n        values: new Uint8Array(numLines * 3),\n        // we will have at least that amount of lines\n        size: 0\n      });\n      breakPolylines(inputLines, lines, inputScalars, firstLineScalar, lineScalars, colors[0]);\n    } else {\n      lines = vtkCellArray.newInstance({\n        empty: true\n      });\n    }\n    let polys = null;\n    let polyMax = 3;\n    if (numPolys > 0 || numStrips > 0) {\n      // If there are line scalars, then poly scalars are needed too\n      if (lineScalars) {\n        polyScalars = vtkDataArray.newInstance({\n          dataType: VtkDataTypes.UNSIGNED_CHAR,\n          empty: true,\n          // size: 0,\n          // values: new Uint8Array(inputPolys.getNumberOfCells(false) * 3),\n          numberOfComponents: numberOfScalarComponents\n        });\n      }\n      polys = vtkCellArray.newInstance();\n      copyPolygons(inputPolys, polys, inputScalars, firstPolyScalar, polyScalars, colors[0]);\n      // TODO: Support triangle strips\n      breakTriangleStrips(input.getStrips(), polys, inputScalars, firstStripScalar, polyScalars, colors[0]);\n\n      // Check if the input has polys and quads or just triangles\n      polyMax = inputPolys.getCellSizes().reduce((a, b) => a > b ? a : b, 0);\n    }\n\n    // Arrays for storing the clipped lines and polys\n    let newLines = vtkCellArray.newInstance({\n      dataType: lines.getDataType(),\n      empty: true\n    });\n    let newPolys = null;\n    if (polys) {\n      newPolys = vtkCellArray.newInstance({\n        dataType: polys.getDataType(),\n        empty: true\n      });\n    }\n\n    // The line scalars, for coloring the outline\n    let inLineData = vtkDataSetAttributes.newInstance();\n    inLineData.copyScalarsOn();\n    inLineData.setScalars(lineScalars);\n\n    // The poly scalars, for coloring the faces\n    let inPolyData = vtkDataSetAttributes.newInstance();\n    inPolyData.copyScalarsOn();\n    inPolyData.setScalars(polyScalars);\n\n    // Also create output attribute data\n    let outLineData = vtkDataSetAttributes.newInstance();\n    outLineData.copyScalarsOn();\n    let outPolyData = vtkDataSetAttributes.newInstance();\n    outPolyData.copyScalarsOn();\n    const planes = model.clippingPlanes;\n\n    // Go through the clipping planes and clip the input with each plane\n    for (let planeId = 0; planeId < planes.length; planeId++) {\n      const plane = planes[planeId];\n      let triangulate = 5;\n      if (planeId === planes.length - 1) {\n        triangulate = polyMax;\n      }\n      const active = planeId === model.activePlaneId;\n\n      // Convert the plane into an easy-to-evaluate function\n      const pc = plane.getNormal();\n      // OK to modify pc because vtkPlane.getNormal() returns a copy\n      pc[3] = -dot(pc, plane.getOrigin());\n\n      // Create the clip scalars by evaluating the plane at each point\n      const numPoints = points.getNumberOfPoints();\n\n      // The point scalars, needed for clipping (not for the output!)\n      const pointScalars = vtkDataArray.newInstance({\n        dataType: VtkDataTypes.DOUBLE,\n        size: numPoints\n      });\n      const pointScalarsData = pointScalars.getData();\n      const pointsData = points.getData();\n      let i = 0;\n      for (let pointId = 0; pointId < numPoints; pointId) {\n        pointScalarsData[pointId++] = pointsData[i++] * pc[0] + pointsData[i++] * pc[1] + pointsData[i++] * pc[2] + pc[3];\n      }\n\n      // Prepare the output scalars\n      // outLineData.copyAllocate(inLineData, 0, 0);\n      // outPolyData.copyAllocate(inPolyData, 0, 0);\n\n      // Reset the locator\n      edgeLocator.initialize();\n\n      // Clip the lines\n      clipLines(points, pointScalars, pointData, edgeLocator, lines, newLines, inLineData, outLineData);\n\n      // Clip the polys\n      if (polys) {\n        // Get the number of lines remaining after the clipping\n        const numClipLines = newLines.getNumberOfCells();\n\n        // Cut the polys to generate more lines\n        clipAndContourPolys(points, pointScalars, pointData, edgeLocator, triangulate, polys, newPolys, newLines, inPolyData, outPolyData, outLineData);\n\n        // Add scalars for the newly-created contour lines\n        let scalars = outLineData.getScalars();\n        if (scalars) {\n          // Set the color to the active color if plane is active\n          const color = colors[1 + (active ? 1 : 0)];\n          const activeColor = colors[2];\n          const numNewLines = newLines.getNumberOfCells();\n          const oldColor = [];\n          for (let lineId = numClipLines; lineId < numNewLines; lineId++) {\n            scalars.getTuple(lineId, oldColor);\n            if (numberOfScalarComponents !== 3 || oldColor[0] !== activeColor[0] || oldColor[1] !== activeColor[1] || oldColor[2] !== activeColor[2]) {\n              scalars.setTuple(lineId, color);\n            }\n          }\n        }\n\n        // Generate new polys from the cut lines\n        let cellId = newPolys.getNumberOfCells();\n        const numClipAndContourLines = newLines.getNumberOfCells();\n\n        // Create a polydata for the lines\n        tmpContourData.setPoints(points);\n        tmpContourData.setLines(newLines);\n        tmpContourData.buildCells();\n        triangulateContours(tmpContourData, numClipLines, numClipAndContourLines - numClipLines, newPolys, pc);\n\n        // Add scalars for the newly-created polys\n        scalars = outPolyData.getScalars();\n        if (scalars) {\n          const color = colors[1 + (active ? 1 : 0)];\n          const numCells = newPolys.getNumberOfCells();\n          if (numCells > cellId) {\n            // The insert allocates space up to numCells - 1\n            scalars.insertTuple(numCells - 1, color);\n            for (; cellId < numCells; cellId++) {\n              scalars.setTuple(cellId, color);\n            }\n          }\n        }\n\n        // Add scalars to any diagnostic lines that added by\n        // triangulateContours(). In usual operation, no lines are added.\n        scalars = outLineData.getScalars();\n        if (scalars) {\n          const color = [0, 255, 255];\n          const numCells = newLines.getNumberOfCells();\n          if (numCells > numClipAndContourLines) {\n            // The insert allocates space up to numCells - 1\n            scalars.insertTuple(numCells - 1, color);\n            for (let lineCellId = numClipAndContourLines; lineCellId < numCells; lineCellId++) {\n              scalars.setTuple(lineCellId, color);\n            }\n          }\n        }\n      }\n\n      // Swap the lines, points, etcetera: old output becomes new input\n      [lines, newLines] = [newLines, lines];\n      newLines.initialize();\n      if (polys) {\n        [polys, newPolys] = [newPolys, polys];\n        newPolys.initialize();\n      }\n      [inLineData, outLineData] = [outLineData, inLineData];\n      outLineData.initialize();\n      [inPolyData, outPolyData] = [outPolyData, inPolyData];\n      outPolyData.initialize();\n    }\n\n    // Get the line scalars\n    const scalars = inLineData.getScalars();\n    if (model.generateOutline) {\n      output.setLines(lines);\n    } else if (scalars) {\n      scalars.initialize();\n    }\n    if (model.generateFaces) {\n      output.setPolys(polys);\n      if (polys && scalars) {\n        const pScalars = inPolyData.getScalars();\n        const m = scalars.getNumberOfTuples();\n        const n = pScalars.getNumberOfTuples();\n        if (n > 0) {\n          const color = [0, 0, 0];\n\n          // This is just to expand the array\n          scalars.insertTuple(n + m - 1, color);\n\n          // Fill in the poly scalars\n          for (let i = 0; i < n; i++) {\n            pScalars.getTuple(i, color);\n            scalars.setTuple(i + m, color);\n          }\n        }\n      }\n    }\n    if (scalars && model.scalarMode === ScalarMode.COLORS) {\n      scalars.setName('Colors');\n      output.getCellData().setScalars(scalars);\n    } else if (model.scalarMode === ScalarMode.LABELS) {\n      // Don't use VTK_UNSIGNED_CHAR or they will look like color scalars\n      // const categories = vtkSignedCharArray.newInstance();\n      // categories.deepCopy(scalars);\n      // categories.setName(\"Labels\");\n      // output.getCellData().setScalars(categories);\n      // categories.delete();\n      // TODO: Check\n      const categories = scalars.newClone();\n      categories.setData(scalars.getData().slice());\n      categories.setName('Labels');\n      output.getCellData().setScalars(categories);\n    } else {\n      output.getCellData().setScalars(null);\n    }\n\n    // Finally, store the points in the output\n    squeezeOutputPoints(output, points, pointData, inputPointsType);\n    // TODO: Check\n    // output.squeeze();\n    outData[0] = output;\n  };\n  Object.keys(ScalarMode).forEach(key => {\n    const name = capitalize(key.toLowerCase());\n    publicAPI[`setScalarModeTo${name}`] = () => {\n      model.scalarMode = ScalarMode[key];\n    };\n  });\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  clippingPlanes: null,\n  tolerance: 1e-6,\n  passPointData: false,\n  triangulatePolys: false,\n  scalarMode: ScalarMode.NONE,\n  generateOutline: false,\n  generateFaces: true,\n  activePlaneId: -1,\n  baseColor: [255 / 255, 99 / 255, 71 / 255],\n  // Tomato\n  clipColor: [244 / 255, 164 / 255, 96 / 255],\n  // Sandy brown\n  activePlaneColor: [227 / 255, 207 / 255, 87 / 255],\n  // Banana\n\n  triangulationErrorDisplay: false\n  // _idList: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['clippingPlanes', 'tolerance', 'passPointData', 'triangulatePolys', 'scalarMode', 'generateOutline', 'generateFaces', 'activePlaneId', 'triangulationErrorDisplay']);\n  macro.setGetArray(publicAPI, model, ['baseColor', 'clipColor', 'activePlaneColor'], 3);\n\n  // Object specific methods\n  vtkClipClosedSurface(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkClipClosedSurface');\n\n// ----------------------------------------------------------------------------\n\nvar vtkClipClosedSurface$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\nexport { vtkClipClosedSurface$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","d","dot","e","distance2BetweenPoints","vtkCellArray","vtkDataArray","VtkDataTypes","vtkPoints","vtkDataSetAttributes","vtkPolyData","vtkContourTriangulator","vtkEdgeLocator","Constants","vtkErrorMacro","capitalize","ScalarMode","vtkClipClosedSurface","publicAPI","model","classHierarchy","push","getMTime","clippingPlanes","reduce","a","b","mtime","createColorValues","color1","color2","color3","colors","dcolors","clamp","n","min","max","Math","i","j","round","interpolateEdge","points","pointData","locator","tol","i0","i1","v0","v1","edge","insertUniqueEdge","value","p0","getPoint","p1","f","s","t","p","tol2","insertNextTuple","interpolateData","clipLines","pointScalars","edgeLocator","inputLines","outputLines","inLineData","outLineData","numPts","c0","c1","linePts","values","getData","cellId","length","tolerance","newCellId","insertNextCell","passData","breakPolylines","inputScalars","firstLineScalar","scalars","color","cellColor","getTuple","copyPolygons","inputPolys","outputPolys","firstPolyScalar","polyScalars","deepCopy","scalarValue","getNumberOfCells","insertTuple","setTuple","breakTriangleStrips","inputStrips","polys","firstStripScalar","p2","p3","getNumberOfTuples","k","triangulateContours","polyData","firstLine","numLines","normal","triangulationError","triangulationErrorDisplay","triangulatePolygon","polygon","triangles","clipAndContourPolys","triangulate","inCellData","outPolyData","idList","_idList","polyMax","Number","MAX_VALUE","triangulationFailure","j0","j1","idListIdx","numPoints","triangulatePolys","success","ncells","squeezeOutputPoints","output","outputPointDataType","getNumberOfPoints","numNewPoints","outPointData","getPointData","pointMap","cellArrays","getVerts","getLines","getPolys","getStrips","forEach","cellArray","pointId","undefined","newPoints","newInstance","size","dataType","newPointId","setPoints","requestData","inData","outData","input","inputPoints","getPoints","inputPointsType","FLOAT","getDataType","DOUBLE","inPointData","passPointData","point","ptId","tmpContourData","lineScalars","numberOfScalarComponents","scalarMode","COLORS","baseColor","clipColor","activePlaneColor","LABELS","numVerts","numPolys","numStrips","NONE","UNSIGNED_CHAR","empty","numberOfComponents","tryInputScalars","getCellData","getScalars","getNumberOfComponents","lines","Uint8Array","getCellSizes","newLines","newPolys","copyScalarsOn","setScalars","inPolyData","planes","planeId","plane","active","activePlaneId","pc","getNormal","getOrigin","pointScalarsData","pointsData","initialize","numClipLines","activeColor","numNewLines","oldColor","lineId","numClipAndContourLines","setLines","buildCells","numCells","lineCellId","generateOutline","generateFaces","setPolys","pScalars","setName","categories","newClone","setData","slice","Object","keys","key","name","toLowerCase","DEFAULT_VALUES","extend","initialValues","arguments","assign","obj","algo","setGet","setGetArray","vtkClipClosedSurface$1","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Filters/General/ClipClosedSurface.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport { d as dot, e as distance2BetweenPoints } from '../../Common/Core/Math/index.js';\nimport vtkCellArray from '../../Common/Core/CellArray.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport vtkPoints from '../../Common/Core/Points.js';\nimport vtkDataSetAttributes from '../../Common/DataModel/DataSetAttributes.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkContourTriangulator from './ContourTriangulator.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport Constants from './ClipClosedSurface/Constants.js';\n\nconst {\n  vtkErrorMacro,\n  capitalize\n} = macro;\nconst {\n  ScalarMode\n} = Constants;\nfunction vtkClipClosedSurface(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkClipClosedSurface');\n  publicAPI.getMTime = () => model.clippingPlanes.reduce((a, b) => b.getMTime() > a ? b.getMTime() : a, model.mtime);\n\n  /**\n   * Take three colors as doubles, and convert to unsigned char.\n   *\n   * @param {Number} color1\n   * @param {Number} color2\n   * @param {Number} color3\n   * @param {Number[3][3]} colors\n   */\n  function createColorValues(color1, color2, color3, colors) {\n    const dcolors = [color1, color2, color3];\n    const clamp = (n, min, max) => Math.min(Math.max(n, min), max);\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        colors[i][j] = Math.round(clamp(dcolors[i][j], 0, 1) * 255);\n      }\n    }\n  }\n\n  /**\n   * Point interpolation for clipping and contouring, given the scalar\n   * values (v0, v1) for the two endpoints (p0, p1).  The use of this\n   * function guarantees perfect consistency in the results.\n   *\n   * @param {vtkPoints} points\n   * @param {vtkDataArray} pointData\n   * @param {CCSEdgeLocator} locator\n   * @param {Number} tol\n   * @param {Number} i0\n   * @param {Number} i1\n   * @param {Number} v0\n   * @param {Number} v1\n   * @param {Number} i\n   * @returns {Number}\n   */\n  function interpolateEdge(points, pointData, locator, tol, i0, i1, v0, v1) {\n    // This swap guarantees that exactly the same point is computed\n    // for both line directions, as long as the endpoints are the same.\n    if (v1 > 0) {\n      // eslint-disable-next-line no-param-reassign\n      [i0, i1] = [i1, i0];\n      // eslint-disable-next-line no-param-reassign\n      [v0, v1] = [v1, v0];\n    }\n    // After the above swap, i0 will be kept, and i1 will be clipped\n\n    // Check to see if this point has already been computed\n    const edge = locator.insertUniqueEdge(i0, i1);\n    if (edge.value != null) {\n      return edge.value;\n    }\n\n    // Get the edge and interpolate the new point\n    const p0 = points.getPoint(i0);\n    const p1 = points.getPoint(i1);\n    const f = v0 / (v0 - v1);\n    const s = 1.0 - f;\n    const t = 1.0 - s;\n    const p = [s * p0[0] + t * p1[0], s * p0[1] + t * p1[1], s * p0[2] + t * p1[2]];\n    const tol2 = tol * tol;\n\n    // Make sure that new point is far enough from kept point\n    if (distance2BetweenPoints(p, p0) < tol2) {\n      edge.value = i0;\n      return i0;\n    }\n    if (distance2BetweenPoints(p, p1) < tol2) {\n      edge.value = i1;\n      return i1;\n    }\n    edge.value = points.insertNextTuple(p);\n    pointData.interpolateData(pointData, i0, i1, edge.value, t);\n    return edge.value;\n  }\n\n  /**\n   * Method for clipping lines and copying the scalar data.\n   *\n   * @param {vtkPoints} points\n   * @param {vtkDataArray} pointScalars\n   * @param {vtkDataSetAttributesk} pointData\n   * @param {vtkEdgeLocator} edgeLocator\n   * @param {vtkCellArray} inputLines\n   * @param {vtkCellArray} outputLines\n   * @param {vtkDataSetAttributes} inLineData\n   * @param {vtkDataSetAttributes} outLineData\n   */\n  function clipLines(points, pointScalars, pointData, edgeLocator, inputLines, outputLines, inLineData, outLineData) {\n    let numPts;\n    let i0;\n    let i1;\n    let v0;\n    let v1;\n    let c0;\n    let c1;\n    const linePts = [];\n    const values = inputLines.getData();\n    let cellId = 0;\n    for (let i = 0; i < values.length; i += numPts + 1, cellId++) {\n      numPts = values[i];\n      i1 = values[i + 1];\n      v1 = pointScalars.getData()[i1];\n      c1 = v1 > 0;\n      for (let j = 2; j <= numPts; j++) {\n        i0 = i1;\n        v0 = v1;\n        c0 = c1;\n        i1 = values[i + j];\n        v1 = pointScalars.getData()[i1];\n        c1 = v1 > 0;\n\n        // If at least one point wasn't clipped\n        if (c0 || c1) {\n          // If only one end was clipped, interpolate new point\n          if (c0 ? !c1 : c1) {\n            linePts[c0 ? 1 : 0] = interpolateEdge(points, pointData, edgeLocator, model.tolerance, i0, i1, v0, v1);\n          }\n\n          // If endpoints are different, insert the line segment\n          if (i0 !== i1) {\n            linePts[0] = i0;\n            linePts[1] = i1;\n            const newCellId = outputLines.insertNextCell(linePts);\n            // outLineData.copyData(inLineData, cellId, newCellId);\n            outLineData.passData(inLineData, cellId, newCellId);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Break polylines into individual lines, copying scalar values from\n   * inputScalars starting at firstLineScalar.  If inputScalars is zero,\n   * then scalars will be set to color.  If scalars is zero, then no\n   * scalars will be generated.\n   *\n   * @param {vtkCellArray} inputLines\n   * @param {vtkCellArray} outputLines\n   * @param {vtkDataArray} inputScalars\n   * @param {Number} firstLineScalar\n   * @param {vtkDataArray} scalars\n   * @param {Vector3} color\n   */\n  function breakPolylines(inputLines, outputLines, inputScalars, firstLineScalar, scalars, color) {\n    const cellColor = [...color];\n    let cellId = 0;\n    const values = inputLines.getData();\n    let numPts;\n    for (let i = 0; i < values.length; i += numPts + 1) {\n      numPts = values[i];\n      if (inputScalars) {\n        inputScalars.getTuple(firstLineScalar + cellId++, cellColor);\n      }\n      for (let j = 1; j < numPts; j++) {\n        outputLines.insertNextCell([values[i + j], values[i + j + 1]]);\n        if (scalars) {\n          scalars.insertNextTuple(cellColor);\n        }\n      }\n    }\n  }\n\n  /**\n   * Copy polygons and their associated scalars to a new array.\n   * If inputScalars is set to zero, set polyScalars to color instead.\n   * If polyScalars is set to zero, don't generate scalars.\n   *\n   * @param {vtkCellArray} inputPolys\n   * @param {vtkCellArray} outputPolys\n   * @param {vtkDataArray} inputScalars\n   * @param {Number} firstPolyScalar\n   * @param {vtkDataArray} polyScalars\n   * @param {Vector3} color\n   */\n  function copyPolygons(inputPolys, outputPolys, inputScalars, firstPolyScalar, polyScalars, color) {\n    if (!inputPolys) {\n      return;\n    }\n    outputPolys.deepCopy(inputPolys);\n    if (polyScalars) {\n      const scalarValue = [...color];\n      const n = outputPolys.getNumberOfCells();\n      polyScalars.insertTuple(n - 1, scalarValue);\n      if (inputScalars) {\n        for (let i = 0; i < n; i++) {\n          inputScalars.getTuple(i + firstPolyScalar, scalarValue);\n          polyScalars.setTuple(i, scalarValue);\n        }\n      } else {\n        for (let i = 0; i < n; i++) {\n          polyScalars.setTuple(i, scalarValue);\n        }\n      }\n    }\n  }\n  function breakTriangleStrips(inputStrips, polys, inputScalars, firstStripScalar, polyScalars, color) {\n    if (inputStrips.getNumberOfCells() === 0) {\n      return;\n    }\n    const values = inputStrips.getData();\n    let cellId = firstStripScalar;\n    let numPts;\n    for (let i = 0; i < values.length; i += numPts + 1, cellId++) {\n      numPts = values[i];\n      // vtkTriangleStrip.decomposeStrip(numPts, values, polys);\n      let p1 = values[i + 1];\n      let p2 = values[i + 2];\n      for (let j = 0; j < numPts - 2; j++) {\n        const p3 = values[i + j + 3];\n        if (j % 2) {\n          polys.insertNextCell([p2, p1, p3]);\n        } else {\n          polys.insertNextCell([p1, p2, p3]);\n        }\n        p1 = p2;\n        p2 = p3;\n      }\n      if (polyScalars) {\n        const scalarValue = [...color];\n        if (inputScalars) {\n          // If there are input scalars, use them instead of \"color\"\n          inputScalars.getTuple(cellId, scalarValue);\n        }\n        const n = numPts - 3;\n        const m = polyScalars.getNumberOfTuples();\n        if (n >= 0) {\n          // First insert is just to allocate space\n          polyScalars.insertTuple(m + n, scalarValue);\n          for (let k = 0; k < n; k++) {\n            polyScalars.setTuple(m + k, scalarValue);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Given some closed contour lines, create a triangle mesh that\n   * fills those lines.  The input lines must be single-segment lines,\n   * not polylines.  The input lines do not have to be in order.\n   * Only lines from firstLine to will be used.  Specify the normal\n   * of the clip plane, which will be opposite the normals\n   * of the polys that will be produced.  If outCD has scalars, then color\n   * scalars will be added for each poly that is created.\n   *\n   * @param {vtkPolyData} polyData\n   * @param {Number} firstLine\n   * @param {Number} numLines\n   * @param {vtkCellArray} outputPolys\n   * @param {Vector3} normal\n   */\n  function triangulateContours(polyData, firstLine, numLines, outputPolys, normal) {\n    // If no cut lines were generated, there's nothing to do\n    if (numLines <= 0) {\n      return;\n    }\n    const triangulationError = !vtkContourTriangulator.triangulateContours(polyData, firstLine, numLines, outputPolys, [-normal[0], -normal[1], -normal[2]]);\n    if (triangulationError && model.triangulationErrorDisplay) {\n      vtkErrorMacro('Triangulation failed, polyData may not be watertight.');\n    }\n  }\n\n  /**\n   * Break polylines into individual lines, copying scalar values from\n   * inputScalars starting at firstLineScalar. If inputScalars is zero,\n   * then scalars will be set to color. If scalars is zero, then no\n   * scalars will be generated.\n   *\n   * @param {Number[]} polygon\n   * @param {vtkPoints} points\n   * @param {vtkCellArray} triangles\n   * @returns {Boolean}\n   */\n  function triangulatePolygon(polygon, points, triangles) {\n    return vtkContourTriangulator.triangulatePolygon(polygon, points, triangles);\n  }\n\n  /**\n   * Clip and contour polys in one step, in order to guarantee\n   * that the contour lines exactly match the new free edges of\n   * the clipped polygons.  This exact correspondence is necessary\n   * in order to guarantee that the surface remains closed.\n   *\n   * @param {vtkPoints} points\n   * @param {vtkDataArray} pointScalars\n   * @param {vtkDataSetAttributes} pointData\n   * @param {vtkEdgeLocator} edgeLocator\n   * @param {Number} triangulate\n   * @param {vtkCellArray} inputPolys\n   * @param {vtkCellArray} outputPolys\n   * @param {vtkCellArray} outputLines\n   * @param {vtkDataSetAttributes} inCellData\n   * @param {vtkDataSetAttributes} outPolyData\n   * @param {vtkDataSetAttributes} outLineData\n   */\n  function clipAndContourPolys(points, pointScalars, pointData, edgeLocator, triangulate, inputPolys, outputPolys, outputLines, inCellData, outPolyData, outLineData) {\n    const idList = model._idList;\n    // How many sides for output polygons?\n    let polyMax = Number.MAX_VALUE;\n    if (triangulate) {\n      if (triangulate < 4) {\n        // triangles only\n        polyMax = 3;\n      } else if (triangulate === 4) {\n        // allow triangles and quads\n        polyMax = 4;\n      }\n    }\n\n    // eslint-disable-next-line prefer-const\n    let triangulationFailure = false;\n\n    // Go through all cells and clip them\n    const values = inputPolys.getData();\n    const linePts = [];\n    let cellId = 0;\n    let numPts;\n    for (let i = 0; i < values.length; i += numPts + 1, cellId++) {\n      numPts = values[i];\n      let i1 = values[i + numPts];\n      let v1 = pointScalars.getData()[i1];\n      let c1 = v1 > 0;\n\n      // The ids for the current edge: init j0 to -1 if i1 will be clipped\n      let j0 = c1 ? i1 : -1;\n      let j1 = 0;\n\n      // To store the ids of the contour line\n      linePts[0] = 0;\n      linePts[1] = 0;\n      let idListIdx = 0;\n      for (let j = 1; j <= numPts; j++) {\n        // Save previous point info\n        const i0 = i1;\n        const v0 = v1;\n        const c0 = c1;\n\n        // Generate new point info\n        i1 = values[i + j];\n        v1 = pointScalars.getData()[i1];\n        c1 = v1 > 0;\n\n        // If at least one edge end point wasn't clipped\n        if (c0 || c1) {\n          // If only one end was clipped, interpolate new point\n          if (c0 ? !c1 : c1) {\n            j1 = interpolateEdge(points, pointData, edgeLocator, model.tolerance, i0, i1, v0, v1);\n            if (j1 !== j0) {\n              idList[idListIdx++] = j1;\n              j0 = j1;\n            }\n\n            // Save as one end of the contour line\n            linePts[c0 ? 1 : 0] = j1;\n          }\n          if (c1) {\n            j1 = i1;\n            if (j1 !== j0) {\n              idList[idListIdx++] = j1;\n              j0 = j1;\n            }\n          }\n        }\n      }\n\n      // Insert the clipped poly\n      const numPoints = idListIdx;\n      idList.length = numPoints;\n      if (model.triangulatePolys && numPoints > polyMax) {\n        // TODO: Support triangulatePolygon\n        let newCellId = outputPolys.getNumberOfCells();\n        // Triangulate the poly and insert triangles into output.\n        const success = triangulatePolygon(idList, points, outputPolys);\n        if (!success) {\n          triangulationFailure = true;\n        }\n\n        // Copy the attribute data to the triangle cells\n        const ncells = outputPolys.getNumberOfCells();\n        for (; newCellId < ncells; newCellId++) {\n          outPolyData.passData(inCellData, cellId, newCellId);\n        }\n      } else if (numPoints > 2) {\n        // Insert the polygon without triangulating it\n        const newCellId = outputPolys.insertNextCell(idList);\n        outPolyData.passData(inCellData, cellId, newCellId);\n      }\n\n      // Insert the contour line if one was created\n      if (linePts[0] !== linePts[1]) {\n        const newCellId = outputLines.insertNextCell(linePts);\n        outLineData.passData(inCellData, cellId, newCellId);\n      }\n    }\n    if (triangulationFailure && model.triangulationErrorDisplay) {\n      vtkErrorMacro('Triangulation failed, output may not be watertight');\n    }\n  }\n\n  /**\n   * Squeeze the points and store them in the output.  Only the points that\n   * are used by the cells will be saved, and the pointIds of the cells will\n   * be modified.\n   *\n   * @param {vtkPolyData} output\n   * @param {vtkPoints} points\n   * @param {vtkDataSetAttributes} pointData\n   * @param {String} outputPointDataType\n   */\n  function squeezeOutputPoints(output, points, pointData, outputPointDataType) {\n    // Create a list of points used by cells\n    const n = points.getNumberOfPoints();\n    let numNewPoints = 0;\n    const outPointData = output.getPointData();\n    const pointMap = [];\n    pointMap.length = n;\n    const cellArrays = [output.getVerts(), output.getLines(), output.getPolys(), output.getStrips()];\n\n    // Find all the newPoints that are used by cells\n    cellArrays.forEach(cellArray => {\n      if (!cellArray) {\n        return;\n      }\n      const values = cellArray.getData();\n      let numPts;\n      let pointId;\n      for (let i = 0; i < values.length; i += numPts + 1) {\n        numPts = values[i];\n        for (let j = 1; j <= numPts; j++) {\n          pointId = values[i + j];\n          if (pointMap[pointId] === undefined) {\n            pointMap[pointId] = numNewPoints++;\n          }\n        }\n      }\n    });\n\n    // Create exactly the number of points that are required\n    const newPoints = vtkPoints.newInstance({\n      size: numNewPoints * 3,\n      dataType: outputPointDataType\n    });\n    // outPointData.copyAllocate(pointData, numNewPoints, 0);\n\n    const p = [];\n    let newPointId;\n    for (let pointId = 0; pointId < n; pointId++) {\n      newPointId = pointMap[pointId];\n      if (newPointId !== undefined) {\n        points.getPoint(pointId, p);\n        newPoints.setTuple(newPointId, p);\n        outPointData.passData(pointData, pointId, newPointId);\n        // outPointData.copyData(pointData, pointId, newPointId);\n      }\n    }\n\n    // Change the cell pointIds to reflect the new point array\n    cellArrays.forEach(cellArray => {\n      if (!cellArray) {\n        return;\n      }\n      const values = cellArray.getData();\n      let numPts;\n      let pointId;\n      for (let i = 0; i < values.length; i += numPts + 1) {\n        numPts = values[i];\n        for (let j = 1; j <= numPts; j++) {\n          pointId = values[i + j];\n          values[i + j] = pointMap[pointId];\n        }\n      }\n    });\n    output.setPoints(newPoints);\n  }\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    const output = vtkPolyData.newInstance();\n    outData[0] = output;\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (model._idList == null) {\n      model._idList = [];\n    } else {\n      model._idList.length = 0;\n    }\n\n    // Get the input points\n    const inputPoints = input.getPoints();\n    let numPts = 0;\n    let inputPointsType = VtkDataTypes.FLOAT;\n    if (inputPoints) {\n      numPts = inputPoints.getNumberOfPoints();\n      inputPointsType = inputPoints.getDataType();\n    }\n\n    // Force points to double precision, copy the point attributes\n    const points = vtkPoints.newInstance({\n      size: numPts * 3,\n      dataType: VtkDataTypes.DOUBLE\n    });\n    const pointData = vtkDataSetAttributes.newInstance();\n    let inPointData = null;\n    if (model.passPointData) {\n      inPointData = input.getPointData();\n      // pointData.interpolateAllocate(inPointData, numPts, 0);\n    }\n\n    const point = [];\n    for (let ptId = 0; ptId < numPts; ptId++) {\n      inputPoints.getPoint(ptId, point);\n      points.setTuple(ptId, point);\n      if (inPointData) {\n        // pointData.copyData(inPointData, ptId, ptId);\n        pointData.passData(inPointData, ptId, ptId);\n      }\n    }\n\n    // An edge locator to avoid point duplication while clipping\n    const edgeLocator = vtkEdgeLocator.newInstance();\n\n    // A temporary polydata for the contour lines that are triangulated\n    const tmpContourData = vtkPolyData.newInstance();\n\n    // The cell scalars\n    let lineScalars;\n    let polyScalars;\n    let inputScalars;\n\n    // For input scalars: the offsets to the various cell types\n    let firstLineScalar = 0;\n    let firstPolyScalar = 0;\n    let firstStripScalar = 0;\n\n    // Make the colors to be used on the data\n    let numberOfScalarComponents = 1;\n    const colors = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\n    if (model.scalarMode === ScalarMode.COLORS) {\n      numberOfScalarComponents = 3;\n      createColorValues(model.baseColor, model.clipColor, model.activePlaneColor, colors);\n    } else if (model.scalarMode === ScalarMode.LABELS) {\n      colors[0][0] = 0;\n      colors[1][0] = 1;\n      colors[2][0] = 2;\n    }\n\n    // This is set if we have to work with scalars. The input scalars\n    // will be copied if they are unsigned char with 3 components, otherwise\n    // new scalars will be generated.\n    const numVerts = input.getVerts()?.getNumberOfCells() || 0;\n    const inputLines = input.getLines();\n    const numLines = inputLines?.getNumberOfCells() || 0;\n    const inputPolys = input.getPolys();\n    const numPolys = inputPolys?.getNumberOfCells() || 0;\n    const numStrips = input.getStrips()?.getNumberOfCells() || 0;\n    if (model.scalarMode !== ScalarMode.NONE) {\n      lineScalars = vtkDataArray.newInstance({\n        dataType: VtkDataTypes.UNSIGNED_CHAR,\n        empty: true,\n        // size: 0,\n        // values: new Uint8Array(numLines * 3),\n        numberOfComponents: numberOfScalarComponents\n      });\n      const tryInputScalars = input.getCellData().getScalars();\n      // Get input scalars if they are RGB color scalars\n      if (tryInputScalars && tryInputScalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR && numberOfScalarComponents === 3 && tryInputScalars.getNumberOfComponents() === 3) {\n        inputScalars = input.getCellData().getScalars();\n        firstLineScalar = numVerts;\n        firstPolyScalar = numVerts + numLines;\n        firstStripScalar = numVerts + numLines + numPolys;\n      }\n    }\n\n    // Break the input lines into segments, generate scalars for lines\n    let lines;\n    if (numLines > 0) {\n      lines = vtkCellArray.newInstance({\n        dataType: inputLines.getDataType(),\n        values: new Uint8Array(numLines * 3),\n        // we will have at least that amount of lines\n        size: 0\n      });\n      breakPolylines(inputLines, lines, inputScalars, firstLineScalar, lineScalars, colors[0]);\n    } else {\n      lines = vtkCellArray.newInstance({\n        empty: true\n      });\n    }\n    let polys = null;\n    let polyMax = 3;\n    if (numPolys > 0 || numStrips > 0) {\n      // If there are line scalars, then poly scalars are needed too\n      if (lineScalars) {\n        polyScalars = vtkDataArray.newInstance({\n          dataType: VtkDataTypes.UNSIGNED_CHAR,\n          empty: true,\n          // size: 0,\n          // values: new Uint8Array(inputPolys.getNumberOfCells(false) * 3),\n          numberOfComponents: numberOfScalarComponents\n        });\n      }\n      polys = vtkCellArray.newInstance();\n      copyPolygons(inputPolys, polys, inputScalars, firstPolyScalar, polyScalars, colors[0]);\n      // TODO: Support triangle strips\n      breakTriangleStrips(input.getStrips(), polys, inputScalars, firstStripScalar, polyScalars, colors[0]);\n\n      // Check if the input has polys and quads or just triangles\n      polyMax = inputPolys.getCellSizes().reduce((a, b) => a > b ? a : b, 0);\n    }\n\n    // Arrays for storing the clipped lines and polys\n    let newLines = vtkCellArray.newInstance({\n      dataType: lines.getDataType(),\n      empty: true\n    });\n    let newPolys = null;\n    if (polys) {\n      newPolys = vtkCellArray.newInstance({\n        dataType: polys.getDataType(),\n        empty: true\n      });\n    }\n\n    // The line scalars, for coloring the outline\n    let inLineData = vtkDataSetAttributes.newInstance();\n    inLineData.copyScalarsOn();\n    inLineData.setScalars(lineScalars);\n\n    // The poly scalars, for coloring the faces\n    let inPolyData = vtkDataSetAttributes.newInstance();\n    inPolyData.copyScalarsOn();\n    inPolyData.setScalars(polyScalars);\n\n    // Also create output attribute data\n    let outLineData = vtkDataSetAttributes.newInstance();\n    outLineData.copyScalarsOn();\n    let outPolyData = vtkDataSetAttributes.newInstance();\n    outPolyData.copyScalarsOn();\n    const planes = model.clippingPlanes;\n\n    // Go through the clipping planes and clip the input with each plane\n    for (let planeId = 0; planeId < planes.length; planeId++) {\n      const plane = planes[planeId];\n      let triangulate = 5;\n      if (planeId === planes.length - 1) {\n        triangulate = polyMax;\n      }\n      const active = planeId === model.activePlaneId;\n\n      // Convert the plane into an easy-to-evaluate function\n      const pc = plane.getNormal();\n      // OK to modify pc because vtkPlane.getNormal() returns a copy\n      pc[3] = -dot(pc, plane.getOrigin());\n\n      // Create the clip scalars by evaluating the plane at each point\n      const numPoints = points.getNumberOfPoints();\n\n      // The point scalars, needed for clipping (not for the output!)\n      const pointScalars = vtkDataArray.newInstance({\n        dataType: VtkDataTypes.DOUBLE,\n        size: numPoints\n      });\n      const pointScalarsData = pointScalars.getData();\n      const pointsData = points.getData();\n      let i = 0;\n      for (let pointId = 0; pointId < numPoints; pointId) {\n        pointScalarsData[pointId++] = pointsData[i++] * pc[0] + pointsData[i++] * pc[1] + pointsData[i++] * pc[2] + pc[3];\n      }\n\n      // Prepare the output scalars\n      // outLineData.copyAllocate(inLineData, 0, 0);\n      // outPolyData.copyAllocate(inPolyData, 0, 0);\n\n      // Reset the locator\n      edgeLocator.initialize();\n\n      // Clip the lines\n      clipLines(points, pointScalars, pointData, edgeLocator, lines, newLines, inLineData, outLineData);\n\n      // Clip the polys\n      if (polys) {\n        // Get the number of lines remaining after the clipping\n        const numClipLines = newLines.getNumberOfCells();\n\n        // Cut the polys to generate more lines\n        clipAndContourPolys(points, pointScalars, pointData, edgeLocator, triangulate, polys, newPolys, newLines, inPolyData, outPolyData, outLineData);\n\n        // Add scalars for the newly-created contour lines\n        let scalars = outLineData.getScalars();\n        if (scalars) {\n          // Set the color to the active color if plane is active\n          const color = colors[1 + (active ? 1 : 0)];\n          const activeColor = colors[2];\n          const numNewLines = newLines.getNumberOfCells();\n          const oldColor = [];\n          for (let lineId = numClipLines; lineId < numNewLines; lineId++) {\n            scalars.getTuple(lineId, oldColor);\n            if (numberOfScalarComponents !== 3 || oldColor[0] !== activeColor[0] || oldColor[1] !== activeColor[1] || oldColor[2] !== activeColor[2]) {\n              scalars.setTuple(lineId, color);\n            }\n          }\n        }\n\n        // Generate new polys from the cut lines\n        let cellId = newPolys.getNumberOfCells();\n        const numClipAndContourLines = newLines.getNumberOfCells();\n\n        // Create a polydata for the lines\n        tmpContourData.setPoints(points);\n        tmpContourData.setLines(newLines);\n        tmpContourData.buildCells();\n        triangulateContours(tmpContourData, numClipLines, numClipAndContourLines - numClipLines, newPolys, pc);\n\n        // Add scalars for the newly-created polys\n        scalars = outPolyData.getScalars();\n        if (scalars) {\n          const color = colors[1 + (active ? 1 : 0)];\n          const numCells = newPolys.getNumberOfCells();\n          if (numCells > cellId) {\n            // The insert allocates space up to numCells - 1\n            scalars.insertTuple(numCells - 1, color);\n            for (; cellId < numCells; cellId++) {\n              scalars.setTuple(cellId, color);\n            }\n          }\n        }\n\n        // Add scalars to any diagnostic lines that added by\n        // triangulateContours(). In usual operation, no lines are added.\n        scalars = outLineData.getScalars();\n        if (scalars) {\n          const color = [0, 255, 255];\n          const numCells = newLines.getNumberOfCells();\n          if (numCells > numClipAndContourLines) {\n            // The insert allocates space up to numCells - 1\n            scalars.insertTuple(numCells - 1, color);\n            for (let lineCellId = numClipAndContourLines; lineCellId < numCells; lineCellId++) {\n              scalars.setTuple(lineCellId, color);\n            }\n          }\n        }\n      }\n\n      // Swap the lines, points, etcetera: old output becomes new input\n      [lines, newLines] = [newLines, lines];\n      newLines.initialize();\n      if (polys) {\n        [polys, newPolys] = [newPolys, polys];\n        newPolys.initialize();\n      }\n      [inLineData, outLineData] = [outLineData, inLineData];\n      outLineData.initialize();\n      [inPolyData, outPolyData] = [outPolyData, inPolyData];\n      outPolyData.initialize();\n    }\n\n    // Get the line scalars\n    const scalars = inLineData.getScalars();\n    if (model.generateOutline) {\n      output.setLines(lines);\n    } else if (scalars) {\n      scalars.initialize();\n    }\n    if (model.generateFaces) {\n      output.setPolys(polys);\n      if (polys && scalars) {\n        const pScalars = inPolyData.getScalars();\n        const m = scalars.getNumberOfTuples();\n        const n = pScalars.getNumberOfTuples();\n        if (n > 0) {\n          const color = [0, 0, 0];\n\n          // This is just to expand the array\n          scalars.insertTuple(n + m - 1, color);\n\n          // Fill in the poly scalars\n          for (let i = 0; i < n; i++) {\n            pScalars.getTuple(i, color);\n            scalars.setTuple(i + m, color);\n          }\n        }\n      }\n    }\n    if (scalars && model.scalarMode === ScalarMode.COLORS) {\n      scalars.setName('Colors');\n      output.getCellData().setScalars(scalars);\n    } else if (model.scalarMode === ScalarMode.LABELS) {\n      // Don't use VTK_UNSIGNED_CHAR or they will look like color scalars\n      // const categories = vtkSignedCharArray.newInstance();\n      // categories.deepCopy(scalars);\n      // categories.setName(\"Labels\");\n      // output.getCellData().setScalars(categories);\n      // categories.delete();\n      // TODO: Check\n      const categories = scalars.newClone();\n      categories.setData(scalars.getData().slice());\n      categories.setName('Labels');\n      output.getCellData().setScalars(categories);\n    } else {\n      output.getCellData().setScalars(null);\n    }\n\n    // Finally, store the points in the output\n    squeezeOutputPoints(output, points, pointData, inputPointsType);\n    // TODO: Check\n    // output.squeeze();\n    outData[0] = output;\n  };\n  Object.keys(ScalarMode).forEach(key => {\n    const name = capitalize(key.toLowerCase());\n    publicAPI[`setScalarModeTo${name}`] = () => {\n      model.scalarMode = ScalarMode[key];\n    };\n  });\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  clippingPlanes: null,\n  tolerance: 1e-6,\n  passPointData: false,\n  triangulatePolys: false,\n  scalarMode: ScalarMode.NONE,\n  generateOutline: false,\n  generateFaces: true,\n  activePlaneId: -1,\n  baseColor: [255 / 255, 99 / 255, 71 / 255],\n  // Tomato\n  clipColor: [244 / 255, 164 / 255, 96 / 255],\n  // Sandy brown\n  activePlaneColor: [227 / 255, 207 / 255, 87 / 255],\n  // Banana\n\n  triangulationErrorDisplay: false\n  // _idList: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['clippingPlanes', 'tolerance', 'passPointData', 'triangulatePolys', 'scalarMode', 'generateOutline', 'generateFaces', 'activePlaneId', 'triangulationErrorDisplay']);\n  macro.setGetArray(publicAPI, model, ['baseColor', 'clipColor', 'activePlaneColor'], 3);\n\n  // Object specific methods\n  vtkClipClosedSurface(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkClipClosedSurface');\n\n// ----------------------------------------------------------------------------\n\nvar vtkClipClosedSurface$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\nexport { vtkClipClosedSurface$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}