{"ast":null,"code":"import { m as macro } from '../../macros2.js';\nimport vtkDataArray from './DataArray.js';\nimport { VtkDataTypes } from './DataArray/Constants.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction extractCellSizes(cellArray) {\n  let currentIdx = 0;\n  return cellArray.filter((value, index) => {\n    if (index === currentIdx) {\n      currentIdx += value + 1;\n      return true;\n    }\n    return false;\n  });\n}\nfunction getNumberOfCells(cellArray) {\n  let cellId = 0;\n  for (let cellArrayIndex = 0; cellArrayIndex < cellArray.length;) {\n    cellArrayIndex += cellArray[cellArrayIndex] + 1;\n    cellId++;\n  }\n  return cellId;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  extractCellSizes,\n  getNumberOfCells\n};\n\n// ----------------------------------------------------------------------------\n// vtkCellArray methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellArray(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellArray');\n  const superClass = {\n    ...publicAPI\n  };\n  publicAPI.getNumberOfCells = recompute => {\n    if (model.numberOfCells !== undefined && !recompute) {\n      return model.numberOfCells;\n    }\n    if (model.cellSizes) {\n      model.numberOfCells = model.cellSizes.length;\n    } else {\n      model.numberOfCells = getNumberOfCells(publicAPI.getData());\n    }\n    return model.numberOfCells;\n  };\n  publicAPI.getCellSizes = recompute => {\n    if (model.cellSizes !== undefined && !recompute) {\n      return model.cellSizes;\n    }\n    model.cellSizes = extractCellSizes(publicAPI.getData());\n    return model.cellSizes;\n  };\n\n  /**\n   * When `resize()` is being used, you then MUST use `insertNextCell()`.\n   */\n  publicAPI.resize = requestedNumTuples => {\n    const oldNumTuples = publicAPI.getNumberOfTuples();\n    superClass.resize(requestedNumTuples);\n    const newNumTuples = publicAPI.getNumberOfTuples();\n    if (newNumTuples < oldNumTuples) {\n      if (newNumTuples === 0) {\n        model.numberOfCells = 0;\n        model.cellSizes = [];\n      } else {\n        // We do not know how many cells are left.\n        // Set to undefined to ensure insertNextCell works correctly.\n        model.numberOfCells = undefined;\n        model.cellSizes = undefined;\n      }\n    }\n  };\n  publicAPI.setData = typedArray => {\n    superClass.setData(typedArray, 1);\n    model.numberOfCells = undefined;\n    model.cellSizes = undefined;\n  };\n  publicAPI.getCell = loc => {\n    let cellLoc = loc;\n    const numberOfPoints = model.values[cellLoc++];\n    return model.values.subarray(cellLoc, cellLoc + numberOfPoints);\n  };\n  publicAPI.insertNextCell = cellPointIds => {\n    const cellId = publicAPI.getNumberOfCells();\n    publicAPI.insertNextTuples([cellPointIds.length, ...cellPointIds]);\n    // By computing the number of cells earlier, we made sure that numberOfCells is defined\n    ++model.numberOfCells;\n    if (model.cellSizes != null) {\n      model.cellSizes.push(cellPointIds.length);\n    }\n    return cellId;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(initialValues) {\n  return {\n    empty: true,\n    numberOfComponents: 1,\n    dataType: VtkDataTypes.UNSIGNED_INT,\n    ...initialValues\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  vtkDataArray.extend(publicAPI, model, defaultValues(initialValues));\n  vtkCellArray(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCellArray');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellArray$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\nexport { STATIC, vtkCellArray$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkDataArray","VtkDataTypes","extractCellSizes","cellArray","currentIdx","filter","value","index","getNumberOfCells","cellId","cellArrayIndex","length","STATIC","vtkCellArray","publicAPI","model","classHierarchy","push","superClass","recompute","numberOfCells","undefined","cellSizes","getData","getCellSizes","resize","requestedNumTuples","oldNumTuples","getNumberOfTuples","newNumTuples","setData","typedArray","getCell","loc","cellLoc","numberOfPoints","values","subarray","insertNextCell","cellPointIds","insertNextTuples","defaultValues","initialValues","empty","numberOfComponents","dataType","UNSIGNED_INT","extend","arguments","newInstance","vtkCellArray$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Common/Core/CellArray.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkDataArray from './DataArray.js';\nimport { VtkDataTypes } from './DataArray/Constants.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction extractCellSizes(cellArray) {\n  let currentIdx = 0;\n  return cellArray.filter((value, index) => {\n    if (index === currentIdx) {\n      currentIdx += value + 1;\n      return true;\n    }\n    return false;\n  });\n}\nfunction getNumberOfCells(cellArray) {\n  let cellId = 0;\n  for (let cellArrayIndex = 0; cellArrayIndex < cellArray.length;) {\n    cellArrayIndex += cellArray[cellArrayIndex] + 1;\n    cellId++;\n  }\n  return cellId;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  extractCellSizes,\n  getNumberOfCells\n};\n\n// ----------------------------------------------------------------------------\n// vtkCellArray methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellArray(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellArray');\n  const superClass = {\n    ...publicAPI\n  };\n  publicAPI.getNumberOfCells = recompute => {\n    if (model.numberOfCells !== undefined && !recompute) {\n      return model.numberOfCells;\n    }\n    if (model.cellSizes) {\n      model.numberOfCells = model.cellSizes.length;\n    } else {\n      model.numberOfCells = getNumberOfCells(publicAPI.getData());\n    }\n    return model.numberOfCells;\n  };\n  publicAPI.getCellSizes = recompute => {\n    if (model.cellSizes !== undefined && !recompute) {\n      return model.cellSizes;\n    }\n    model.cellSizes = extractCellSizes(publicAPI.getData());\n    return model.cellSizes;\n  };\n\n  /**\n   * When `resize()` is being used, you then MUST use `insertNextCell()`.\n   */\n  publicAPI.resize = requestedNumTuples => {\n    const oldNumTuples = publicAPI.getNumberOfTuples();\n    superClass.resize(requestedNumTuples);\n    const newNumTuples = publicAPI.getNumberOfTuples();\n    if (newNumTuples < oldNumTuples) {\n      if (newNumTuples === 0) {\n        model.numberOfCells = 0;\n        model.cellSizes = [];\n      } else {\n        // We do not know how many cells are left.\n        // Set to undefined to ensure insertNextCell works correctly.\n        model.numberOfCells = undefined;\n        model.cellSizes = undefined;\n      }\n    }\n  };\n  publicAPI.setData = typedArray => {\n    superClass.setData(typedArray, 1);\n    model.numberOfCells = undefined;\n    model.cellSizes = undefined;\n  };\n  publicAPI.getCell = loc => {\n    let cellLoc = loc;\n    const numberOfPoints = model.values[cellLoc++];\n    return model.values.subarray(cellLoc, cellLoc + numberOfPoints);\n  };\n  publicAPI.insertNextCell = cellPointIds => {\n    const cellId = publicAPI.getNumberOfCells();\n    publicAPI.insertNextTuples([cellPointIds.length, ...cellPointIds]);\n    // By computing the number of cells earlier, we made sure that numberOfCells is defined\n    ++model.numberOfCells;\n    if (model.cellSizes != null) {\n      model.cellSizes.push(cellPointIds.length);\n    }\n    return cellId;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(initialValues) {\n  return {\n    empty: true,\n    numberOfComponents: 1,\n    dataType: VtkDataTypes.UNSIGNED_INT,\n    ...initialValues\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  vtkDataArray.extend(publicAPI, model, defaultValues(initialValues));\n  vtkCellArray(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCellArray');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellArray$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkCellArray$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}