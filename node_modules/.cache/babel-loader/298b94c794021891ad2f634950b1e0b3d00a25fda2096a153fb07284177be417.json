{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/es.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/es.typed-array.with.js\");\n/*! dicom-parser - 1.8.12 - 2023-02-20 | (c) 2017 Chris Hafey | https://github.com/cornerstonejs/dicomParser */\n!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t(require(\"zlib\")) : \"function\" == typeof define && define.amd ? define(\"dicom-parser\", [\"zlib\"], t) : \"object\" == typeof exports ? exports[\"dicom-parser\"] = t(require(\"zlib\")) : e.dicomParser = t(e.zlib);\n}(this, function (r) {\n  return a = [function (e, t) {\n    e.exports = r;\n  }, function (e, t, s) {\n    \"use strict\";\n\n    s.r(t), s.d(t, \"isStringVr\", function () {\n      return d;\n    }), s.d(t, \"isPrivateTag\", function () {\n      return f;\n    }), s.d(t, \"parsePN\", function () {\n      return a;\n    }), s.d(t, \"parseTM\", function () {\n      return n;\n    }), s.d(t, \"parseDA\", function () {\n      return o;\n    }), s.d(t, \"explicitElementToString\", function () {\n      return l;\n    }), s.d(t, \"explicitDataSetToJS\", function () {\n      return u;\n    }), s.d(t, \"createJPEGBasicOffsetTable\", function () {\n      return p;\n    }), s.d(t, \"parseDicomDataSetExplicit\", function () {\n      return q;\n    }), s.d(t, \"parseDicomDataSetImplicit\", function () {\n      return T;\n    }), s.d(t, \"readFixedString\", function () {\n      return b;\n    }), s.d(t, \"alloc\", function () {\n      return k;\n    }), s.d(t, \"version\", function () {\n      return L;\n    }), s.d(t, \"bigEndianByteArrayParser\", function () {\n      return N;\n    }), s.d(t, \"ByteStream\", function () {\n      return J;\n    }), s.d(t, \"sharedCopy\", function () {\n      return j;\n    }), s.d(t, \"DataSet\", function () {\n      return w;\n    }), s.d(t, \"findAndSetUNElementLength\", function () {\n      return y;\n    }), s.d(t, \"findEndOfEncapsulatedElement\", function () {\n      return g;\n    }), s.d(t, \"findItemDelimitationItemAndSetElementLength\", function () {\n      return x;\n    }), s.d(t, \"littleEndianByteArrayParser\", function () {\n      return M;\n    }), s.d(t, \"parseDicom\", function () {\n      return V;\n    }), s.d(t, \"readDicomElementExplicit\", function () {\n      return B;\n    }), s.d(t, \"readDicomElementImplicit\", function () {\n      return A;\n    }), s.d(t, \"readEncapsulatedImageFrame\", function () {\n      return W;\n    }), s.d(t, \"readEncapsulatedPixelData\", function () {\n      return K;\n    }), s.d(t, \"readEncapsulatedPixelDataFromFragments\", function () {\n      return _;\n    }), s.d(t, \"readPart10Header\", function () {\n      return G;\n    }), s.d(t, \"readSequenceItemsExplicit\", function () {\n      return I;\n    }), s.d(t, \"readSequenceItemsImplicit\", function () {\n      return F;\n    }), s.d(t, \"readSequenceItem\", function () {\n      return S;\n    }), s.d(t, \"readTag\", function () {\n      return h;\n    });\n    var r = {\n        AE: !0,\n        AS: !0,\n        AT: !1,\n        CS: !0,\n        DA: !0,\n        DS: !0,\n        DT: !0,\n        FL: !1,\n        FD: !1,\n        IS: !0,\n        LO: !0,\n        LT: !0,\n        OB: !1,\n        OD: !1,\n        OF: !1,\n        OW: !1,\n        PN: !0,\n        SH: !0,\n        SL: !1,\n        SQ: !1,\n        SS: !1,\n        ST: !0,\n        TM: !0,\n        UI: !0,\n        UL: !1,\n        UN: void 0,\n        UR: !0,\n        US: !1,\n        UT: !0\n      },\n      d = function (e) {\n        return r[e];\n      },\n      f = function (e) {\n        e = parseInt(e[4], 16);\n        if (isNaN(e)) throw \"dicomParser.isPrivateTag: cannot parse last character of group\";\n        return e % 2 == 1;\n      },\n      a = function (e) {\n        if (void 0 !== e) {\n          e = e.split(\"^\");\n          return {\n            familyName: e[0],\n            givenName: e[1],\n            middleName: e[2],\n            prefix: e[3],\n            suffix: e[4]\n          };\n        }\n      };\n    function n(e, t) {\n      if (2 <= e.length) {\n        var r = parseInt(e.substring(0, 2), 10),\n          a = 4 <= e.length ? parseInt(e.substring(2, 4), 10) : void 0,\n          n = 6 <= e.length ? parseInt(e.substring(4, 6), 10) : void 0,\n          i = 8 <= e.length ? e.substring(7, 13) : void 0,\n          i = i ? parseInt(i, 10) * Math.pow(10, 6 - i.length) : void 0;\n        if (t && (isNaN(r) || void 0 !== a && isNaN(a) || void 0 !== n && isNaN(n) || void 0 !== i && isNaN(i) || r < 0 || 23 < r || a && (a < 0 || 59 < a) || n && (n < 0 || 59 < n) || i && (i < 0 || 999999 < i))) throw \"invalid TM '\".concat(e, \"'\");\n        return {\n          hours: r,\n          minutes: a,\n          seconds: n,\n          fractionalSeconds: i\n        };\n      }\n      if (t) throw \"invalid TM '\".concat(e, \"'\");\n    }\n    function i(e, t, r) {\n      return !isNaN(r) && 0 < t && t <= 12 && 0 < e && e <= function (e, t) {\n        switch (e) {\n          case 2:\n            return t % 4 == 0 && t % 100 || t % 400 == 0 ? 29 : 28;\n          case 9:\n          case 4:\n          case 6:\n          case 11:\n            return 30;\n          default:\n            return 31;\n        }\n      }(t, r);\n    }\n    function o(e, t) {\n      if (e && 8 === e.length) {\n        var r = parseInt(e.substring(0, 4), 10),\n          a = parseInt(e.substring(4, 6), 10),\n          n = parseInt(e.substring(6, 8), 10);\n        if (t && !0 !== i(n, a, r)) throw \"invalid DA '\".concat(e, \"'\");\n        return {\n          year: r,\n          month: a,\n          day: n\n        };\n      }\n      if (t) throw \"invalid DA '\".concat(e, \"'\");\n    }\n    function l(n, e) {\n      if (void 0 === n || void 0 === e) throw \"dicomParser.explicitElementToString: missing required parameters\";\n      if (void 0 === e.vr) throw \"dicomParser.explicitElementToString: cannot convert implicit element to string\";\n      var t,\n        r = e.vr,\n        i = e.tag;\n      function a(e, t) {\n        for (var r = \"\", a = 0; a < e; a++) 0 !== a && (r += \"/\"), r += t.call(n, i, a).toString();\n        return r;\n      }\n      if (!0 === d(r)) t = n.string(i);else {\n        if (\"AT\" === r) {\n          var o = n.uint32(i);\n          return void 0 === o ? void 0 : \"x\".concat((o = o < 0 ? 4294967295 + o + 1 : o).toString(16).toUpperCase());\n        }\n        \"US\" === r ? t = a(e.length / 2, n.uint16) : \"SS\" === r ? t = a(e.length / 2, n.int16) : \"UL\" === r ? t = a(e.length / 4, n.uint32) : \"SL\" === r ? t = a(e.length / 4, n.int32) : \"FD\" === r ? t = a(e.length / 8, n.double) : \"FL\" === r && (t = a(e.length / 4, n.float));\n      }\n      return t;\n    }\n    function u(e, t) {\n      if (void 0 === e) throw \"dicomParser.explicitDataSetToJS: missing required parameter dataSet\";\n      t = t || {\n        omitPrivateAttibutes: !0,\n        maxElementLength: 128\n      };\n      var r,\n        a = {};\n      for (r in e.elements) {\n        var n = e.elements[r];\n        if (!0 !== t.omitPrivateAttibutes || !f(r)) if (n.items) {\n          for (var i = [], o = 0; o < n.items.length; o++) i.push(u(n.items[o].dataSet, t));\n          a[r] = i;\n        } else {\n          var s = void 0;\n          n.length < t.maxElementLength && (s = l(e, n)), a[r] = void 0 !== s ? s : {\n            dataOffset: n.dataOffset,\n            length: n.length\n          };\n        }\n      }\n      return a;\n    }\n    function c(e, t) {\n      return 255 === e.byteArray[t] && 217 === e.byteArray[t + 1];\n    }\n    function m(e, t, r) {\n      for (var a, n, i = r; i < t.fragments.length; i++) if (a = e, n = i, n = t.fragments[n], !(!c(a, n.position + n.length - 2) && !c(a, n.position + n.length - 3))) return i;\n    }\n    function p(e, t, r) {\n      if (void 0 === e) throw \"dicomParser.createJPEGBasicOffsetTable: missing required parameter dataSet\";\n      if (void 0 === t) throw \"dicomParser.createJPEGBasicOffsetTable: missing required parameter pixelDataElement\";\n      if (\"x7fe00010\" !== t.tag) throw \"dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010'\";\n      if (!0 !== t.encapsulatedPixelData) throw \"dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data\";\n      if (!0 !== t.hadUndefinedLength) throw \"dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data\";\n      if (void 0 === t.basicOffsetTable) throw \"dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data\";\n      if (void 0 === t.fragments) throw \"dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data\";\n      if (t.fragments.length <= 0) throw \"dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data\";\n      if (r && r.length <= 0) throw \"dicomParser.createJPEGBasicOffsetTable: parameter 'fragments' must not be zero length\";\n      r = r || t.fragments;\n      for (var a = [], n = 0;;) {\n        a.push(t.fragments[n].offset);\n        var i = m(e, t, n);\n        if (void 0 === i || i === t.fragments.length - 1) return a;\n        n = i + 1;\n      }\n    }\n    function h(e) {\n      if (void 0 === e) throw \"dicomParser.readTag: missing required parameter 'byteStream'\";\n      var t = 256 * e.readUint16() * 256,\n        e = e.readUint16();\n      return \"x\".concat(\"00000000\".concat((t + e).toString(16)).substr(-8));\n    }\n    function g(e, t, r) {\n      if (void 0 === e) throw \"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'byteStream'\";\n      if (void 0 === t) throw \"dicomParser.findEndOfEncapsulatedElement: missing required parameter 'element'\";\n      if (t.encapsulatedPixelData = !0, t.basicOffsetTable = [], t.fragments = [], \"xfffee000\" !== h(e)) throw \"dicomParser.findEndOfEncapsulatedElement: basic offset table not found\";\n      for (var a = e.readUint32() / 4, n = 0; n < a; n++) {\n        var i = e.readUint32();\n        t.basicOffsetTable.push(i);\n      }\n      for (var o = e.position; e.position < e.byteArray.length;) {\n        var s = h(e),\n          d = e.readUint32();\n        if (\"xfffee0dd\" === s) return e.seek(d), void (t.length = e.position - t.dataOffset);\n        if (\"xfffee000\" !== s) return r && r.push(\"unexpected tag \".concat(s, \" while searching for end of pixel data element with undefined length\")), d > e.byteArray.length - e.position && (d = e.byteArray.length - e.position), t.fragments.push({\n          offset: e.position - o - 8,\n          position: e.position,\n          length: d\n        }), e.seek(d), void (t.length = e.position - t.dataOffset);\n        t.fragments.push({\n          offset: e.position - o - 8,\n          position: e.position,\n          length: d\n        }), e.seek(d);\n      }\n      r && r.push(\"pixel data element \".concat(t.tag, \" missing sequence delimiter tag xfffee0dd\"));\n    }\n    function y(e, t) {\n      if (void 0 === e) throw \"dicomParser.findAndSetUNElementLength: missing required parameter 'byteStream'\";\n      for (var r = e.byteArray.length - 8; e.position <= r;) if (65534 === e.readUint16()) {\n        var a = e.readUint16();\n        if (57565 === a) return 0 !== e.readUint32() && e.warnings(\"encountered non zero length following item delimiter at position \".concat(e.position - 4, \" while reading element of undefined length with tag \").concat(t.tag)), void (t.length = e.position - t.dataOffset);\n      }\n      t.length = e.byteArray.length - t.dataOffset, e.seek(e.byteArray.length - e.position);\n    }\n    function b(e, t, r) {\n      if (r < 0) throw \"dicomParser.readFixedString - length cannot be less than 0\";\n      if (t + r > e.length) throw \"dicomParser.readFixedString: attempt to read past end of buffer\";\n      for (var a, n = \"\", i = 0; i < r; i++) {\n        if (0 === (a = e[t + i])) return t += r, n;\n        n += String.fromCharCode(a);\n      }\n      return n;\n    }\n    function v(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n    function P(e, t) {\n      return void 0 !== e.parser ? e.parser : t;\n    }\n    var w = function () {\n      function a(e, t, r) {\n        !function (e, t) {\n          if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, a), this.byteArrayParser = e, this.byteArray = t, this.elements = r;\n      }\n      var e, t, r;\n      return e = a, (t = [{\n        key: \"uint16\",\n        value: function (e, t) {\n          e = this.elements[e];\n          if (t = void 0 !== t ? t : 0, e && 0 !== e.length) return P(e, this.byteArrayParser).readUint16(this.byteArray, e.dataOffset + 2 * t);\n        }\n      }, {\n        key: \"int16\",\n        value: function (e, t) {\n          e = this.elements[e];\n          if (t = void 0 !== t ? t : 0, e && 0 !== e.length) return P(e, this.byteArrayParser).readInt16(this.byteArray, e.dataOffset + 2 * t);\n        }\n      }, {\n        key: \"uint32\",\n        value: function (e, t) {\n          e = this.elements[e];\n          if (t = void 0 !== t ? t : 0, e && 0 !== e.length) return P(e, this.byteArrayParser).readUint32(this.byteArray, e.dataOffset + 4 * t);\n        }\n      }, {\n        key: \"int32\",\n        value: function (e, t) {\n          e = this.elements[e];\n          if (t = void 0 !== t ? t : 0, e && 0 !== e.length) return P(e, this.byteArrayParser).readInt32(this.byteArray, e.dataOffset + 4 * t);\n        }\n      }, {\n        key: \"float\",\n        value: function (e, t) {\n          e = this.elements[e];\n          if (t = void 0 !== t ? t : 0, e && 0 !== e.length) return P(e, this.byteArrayParser).readFloat(this.byteArray, e.dataOffset + 4 * t);\n        }\n      }, {\n        key: \"double\",\n        value: function (e, t) {\n          e = this.elements[e];\n          if (t = void 0 !== t ? t : 0, e && 0 !== e.length) return P(e, this.byteArrayParser).readDouble(this.byteArray, e.dataOffset + 8 * t);\n        }\n      }, {\n        key: \"numStringValues\",\n        value: function (e) {\n          e = this.elements[e];\n          if (e && 0 < e.length) {\n            e = b(this.byteArray, e.dataOffset, e.length).match(/\\\\/g);\n            return null === e ? 1 : e.length + 1;\n          }\n        }\n      }, {\n        key: \"string\",\n        value: function (e, t) {\n          e = this.elements[e];\n          if (e && e.Value) return e.Value;\n          if (e && 0 < e.length) {\n            e = b(this.byteArray, e.dataOffset, e.length);\n            return 0 <= t ? e.split(\"\\\\\")[t].trim() : e.trim();\n          }\n        }\n      }, {\n        key: \"text\",\n        value: function (e, t) {\n          e = this.elements[e];\n          if (e && 0 < e.length) {\n            e = b(this.byteArray, e.dataOffset, e.length);\n            return 0 <= t ? e.split(\"\\\\\")[t].replace(/ +$/, \"\") : e.replace(/ +$/, \"\");\n          }\n        }\n      }, {\n        key: \"floatString\",\n        value: function (e, t) {\n          var r = this.elements[e];\n          if (r && 0 < r.length) {\n            t = this.string(e, t = void 0 !== t ? t : 0);\n            if (void 0 !== t) return parseFloat(t);\n          }\n        }\n      }, {\n        key: \"intString\",\n        value: function (e, t) {\n          var r = this.elements[e];\n          if (r && 0 < r.length) {\n            t = this.string(e, t = void 0 !== t ? t : 0);\n            if (void 0 !== t) return parseInt(t);\n          }\n        }\n      }, {\n        key: \"attributeTag\",\n        value: function (e) {\n          var t = this.elements[e];\n          if (t && 4 === t.length) {\n            var r = P(t, this.byteArrayParser).readUint16,\n              e = this.byteArray,\n              t = t.dataOffset;\n            return \"x\".concat(\"00000000\".concat((256 * r(e, t) * 256 + r(e, t + 2)).toString(16)).substr(-8));\n          }\n        }\n      }]) && v(e.prototype, t), r && v(e, r), Object.defineProperty(e, \"prototype\", {\n        writable: !1\n      }), a;\n    }();\n    function x(e, t) {\n      if (void 0 === e) throw \"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'\";\n      for (var r = e.byteArray.length - 8; e.position <= r;) if (65534 === e.readUint16()) {\n        var a = e.readUint16();\n        if (57357 === a) return 0 !== e.readUint32() && e.warnings(\"encountered non zero length following item delimiter at position \".concat(e.position - 4, \" while reading element of undefined length with tag \").concat(t.tag)), void (t.length = e.position - t.dataOffset);\n      }\n      t.length = e.byteArray.length - t.dataOffset, e.seek(e.byteArray.length - e.position);\n    }\n    var E = function (e, t) {\n      if (void 0 !== e.vr) return \"SQ\" === e.vr;\n      if (t.position + 4 <= t.byteArray.length) {\n        e = h(t);\n        return t.seek(-4), \"xfffee000\" === e || \"xfffee0dd\" === e;\n      }\n      return t.warnings.push(\"eof encountered before finding sequence item tag or sequence delimiter tag in peeking to determine VR\"), !1;\n    };\n    function A(e, t, r) {\n      if (void 0 === e) throw \"dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'\";\n      var a = h(e),\n        a = {\n          tag: a,\n          vr: void 0 !== r ? r(a) : void 0,\n          length: e.readUint32(),\n          dataOffset: e.position\n        };\n      return 4294967295 === a.length && (a.hadUndefinedLength = !0), a.tag === t || (!E(a, e) || f(a.tag) && !a.hadUndefinedLength ? a.hadUndefinedLength ? x(e, a) : e.seek(a.length) : (F(e, a, r), f(a.tag) && (a.items = void 0))), a;\n    }\n    function S(e) {\n      if (void 0 === e) throw \"dicomParser.readSequenceItem: missing required parameter 'byteStream'\";\n      var t = {\n        tag: h(e),\n        length: e.readUint32(),\n        dataOffset: e.position\n      };\n      if (\"xfffee000\" !== t.tag) throw \"dicomParser.readSequenceItem: item tag (FFFE,E000) not found at offset \".concat(e.position);\n      return t;\n    }\n    function D(e, t) {\n      var r = S(e);\n      return 4294967295 === r.length ? (r.hadUndefinedLength = !0, r.dataSet = function (e, t) {\n        for (var r = {}; e.position < e.byteArray.length;) {\n          var a = A(e, void 0, t);\n          if (\"xfffee00d\" === (r[a.tag] = a).tag) return new w(e.byteArrayParser, e.byteArray, r);\n        }\n        return e.warnings.push(\"eof encountered before finding sequence item delimiter in sequence item of undefined length\"), new w(e.byteArrayParser, e.byteArray, r);\n      }(e, t), r.length = e.position - r.dataOffset) : (r.dataSet = new w(e.byteArrayParser, e.byteArray, {}), T(r.dataSet, e, e.position + r.length, {\n        vrCallback: t\n      })), r;\n    }\n    function F(e, t, r) {\n      if (void 0 === e) throw \"dicomParser.readSequenceItemsImplicit: missing required parameter 'byteStream'\";\n      if (void 0 === t) throw \"dicomParser.readSequenceItemsImplicit: missing required parameter 'element'\";\n      t.items = [], (4294967295 === t.length ? function (e, t, r) {\n        for (; e.position + 4 <= e.byteArray.length;) {\n          var a = h(e);\n          if (e.seek(-4), \"xfffee0dd\" === a) return t.length = e.position - t.dataOffset, e.seek(8);\n          a = D(e, r);\n          t.items.push(a);\n        }\n        e.warnings.push(\"eof encountered before finding sequence delimiter in sequence of undefined length\"), t.length = e.byteArray.length - t.dataOffset;\n      } : function (e, t, r) {\n        for (var a = t.dataOffset + t.length; e.position < a;) {\n          var n = D(e, r);\n          t.items.push(n);\n        }\n      })(e, t, r);\n    }\n    function O(e, t) {\n      var r = S(e);\n      return 4294967295 === r.length ? (r.hadUndefinedLength = !0, r.dataSet = function (e, t) {\n        for (var r = {}; e.position < e.byteArray.length;) {\n          var a = B(e, t);\n          if (\"xfffee00d\" === (r[a.tag] = a).tag) return new w(e.byteArrayParser, e.byteArray, r);\n        }\n        return t.push(\"eof encountered before finding item delimiter tag while reading sequence item of undefined length\"), new w(e.byteArrayParser, e.byteArray, r);\n      }(e, t), r.length = e.position - r.dataOffset) : (r.dataSet = new w(e.byteArrayParser, e.byteArray, {}), q(r.dataSet, e, e.position + r.length)), r;\n    }\n    function I(e, t, r) {\n      if (void 0 === e) throw \"dicomParser.readSequenceItemsExplicit: missing required parameter 'byteStream'\";\n      if (void 0 === t) throw \"dicomParser.readSequenceItemsExplicit: missing required parameter 'element'\";\n      t.items = [], (4294967295 === t.length ? function (e, t, r) {\n        for (; e.position + 4 <= e.byteArray.length;) {\n          var a = h(e);\n          if (e.seek(-4), \"xfffee0dd\" === a) return t.length = e.position - t.dataOffset, e.seek(8);\n          a = O(e, r);\n          t.items.push(a);\n        }\n        r.push(\"eof encountered before finding sequence delimitation tag while reading sequence of undefined length\"), t.length = e.position - t.dataOffset;\n      } : function (e, t, r) {\n        for (var a = t.dataOffset + t.length; e.position < a;) {\n          var n = O(e, r);\n          t.items.push(n);\n        }\n      })(e, t, r);\n    }\n    var U = function (e) {\n      return \"OB\" === e || \"OD\" === e || \"OL\" === e || \"OW\" === e || \"SQ\" === e || \"OF\" === e || \"UC\" === e || \"UR\" === e || \"UT\" === e || \"UN\" === e ? 4 : 2;\n    };\n    function B(e, t, r) {\n      if (void 0 === e) throw \"dicomParser.readDicomElementExplicit: missing required parameter 'byteStream'\";\n      var a = {\n        tag: h(e),\n        vr: e.readFixedString(2)\n      };\n      return 2 === U(a.vr) ? a.length = e.readUint16() : (e.seek(2), a.length = e.readUint32()), a.dataOffset = e.position, 4294967295 === a.length && (a.hadUndefinedLength = !0), a.tag === r || (\"SQ\" === a.vr ? I(e, a, t) : 4294967295 === a.length ? \"x7fe00010\" === a.tag ? g(e, a, t) : (\"UN\" === a.vr ? F : x)(e, a) : e.seek(a.length)), a;\n    }\n    function q(e, t, r) {\n      var a = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : {};\n      if (r = void 0 === r ? t.byteArray.length : r, void 0 === t) throw \"dicomParser.parseDicomDataSetExplicit: missing required parameter 'byteStream'\";\n      if (r < t.position || r > t.byteArray.length) throw \"dicomParser.parseDicomDataSetExplicit: invalid value for parameter 'maxP osition'\";\n      for (var n = e.elements; t.position < r;) {\n        var i = B(t, e.warnings, a.untilTag);\n        if ((n[i.tag] = i).tag === a.untilTag) return;\n      }\n      if (t.position > r) throw \"dicomParser:parseDicomDataSetExplicit: buffer overrun\";\n    }\n    function T(e, t, r) {\n      var a = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : {};\n      if (r = void 0 === r ? e.byteArray.length : r, void 0 === t) throw \"dicomParser.parseDicomDataSetImplicit: missing required parameter 'byteStream'\";\n      if (r < t.position || r > t.byteArray.length) throw \"dicomParser.parseDicomDataSetImplicit: invalid value for parameter 'maxPosition'\";\n      for (var n = e.elements; t.position < r;) {\n        var i = A(t, a.untilTag, a.vrCallback);\n        if ((n[i.tag] = i).tag === a.untilTag) return;\n      }\n    }\n    function k(e, t) {\n      if (\"undefined\" != typeof Buffer && e instanceof Buffer) return Buffer.alloc(t);\n      if (e instanceof Uint8Array) return new Uint8Array(t);\n      throw \"dicomParser.alloc: unknown type for byteArray\";\n    }\n    var L = \"1.8.12\",\n      N = {\n        readUint16: function (e, t) {\n          if (t < 0) throw \"bigEndianByteArrayParser.readUint16: position cannot be less than 0\";\n          if (t + 2 > e.length) throw \"bigEndianByteArrayParser.readUint16: attempt to read past end of buffer\";\n          return (e[t] << 8) + e[t + 1];\n        },\n        readInt16: function (e, t) {\n          if (t < 0) throw \"bigEndianByteArrayParser.readInt16: position cannot be less than 0\";\n          if (t + 2 > e.length) throw \"bigEndianByteArrayParser.readInt16: attempt to read past end of buffer\";\n          t = (e[t] << 8) + e[t + 1];\n          return t = 32768 & t ? t - 65535 - 1 : t;\n        },\n        readUint32: function (e, t) {\n          if (t < 0) throw \"bigEndianByteArrayParser.readUint32: position cannot be less than 0\";\n          if (t + 4 > e.length) throw \"bigEndianByteArrayParser.readUint32: attempt to read past end of buffer\";\n          return 256 * (256 * (256 * e[t] + e[t + 1]) + e[t + 2]) + e[t + 3];\n        },\n        readInt32: function (e, t) {\n          if (t < 0) throw \"bigEndianByteArrayParser.readInt32: position cannot be less than 0\";\n          if (t + 4 > e.length) throw \"bigEndianByteArrayParser.readInt32: attempt to read past end of buffer\";\n          return (e[t] << 24) + (e[t + 1] << 16) + (e[t + 2] << 8) + e[t + 3];\n        },\n        readFloat: function (e, t) {\n          if (t < 0) throw \"bigEndianByteArrayParser.readFloat: position cannot be less than 0\";\n          if (t + 4 > e.length) throw \"bigEndianByteArrayParser.readFloat: attempt to read past end of buffer\";\n          var r = new Uint8Array(4);\n          return r[3] = e[t], r[2] = e[t + 1], r[1] = e[t + 2], r[0] = e[t + 3], new Float32Array(r.buffer)[0];\n        },\n        readDouble: function (e, t) {\n          if (t < 0) throw \"bigEndianByteArrayParser.readDouble: position cannot be less than 0\";\n          if (t + 8 > e.length) throw \"bigEndianByteArrayParser.readDouble: attempt to read past end of buffer\";\n          var r = new Uint8Array(8);\n          return r[7] = e[t], r[6] = e[t + 1], r[5] = e[t + 2], r[4] = e[t + 3], r[3] = e[t + 4], r[2] = e[t + 5], r[1] = e[t + 6], r[0] = e[t + 7], new Float64Array(r.buffer)[0];\n        }\n      };\n    function j(e, t, r) {\n      if (\"undefined\" != typeof Buffer && e instanceof Buffer) return e.slice(t, t + r);\n      if (e instanceof Uint8Array) return new Uint8Array(e.buffer, e.byteOffset + t, r);\n      throw \"dicomParser.from: unknown type for byteArray\";\n    }\n    function C(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var a = t[r];\n        a.enumerable = a.enumerable || !1, a.configurable = !0, \"value\" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);\n      }\n    }\n    var J = function () {\n        function a(e, t, r) {\n          if (!function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, a), void 0 === e) throw \"dicomParser.ByteStream: missing required parameter 'byteArrayParser'\";\n          if (void 0 === t) throw \"dicomParser.ByteStream: missing required parameter 'byteArray'\";\n          if (t instanceof Uint8Array == !1 && (\"undefined\" == typeof Buffer || t instanceof Buffer == !1)) throw \"dicomParser.ByteStream: parameter byteArray is not of type Uint8Array or Buffer\";\n          if (r < 0) throw \"dicomParser.ByteStream: parameter 'position' cannot be less than 0\";\n          if (r >= t.length) throw \"dicomParser.ByteStream: parameter 'position' cannot be greater than or equal to 'byteArray' length\";\n          this.byteArrayParser = e, this.byteArray = t, this.position = r || 0, this.warnings = [];\n        }\n        var e, t, r;\n        return e = a, (t = [{\n          key: \"seek\",\n          value: function (e) {\n            if (this.position + e < 0) throw \"dicomParser.ByteStream.prototype.seek: cannot seek to position < 0\";\n            this.position += e;\n          }\n        }, {\n          key: \"readByteStream\",\n          value: function (e) {\n            if (this.position + e > this.byteArray.length) throw \"dicomParser.ByteStream.prototype.readByteStream: readByteStream - buffer overread\";\n            var t = j(this.byteArray, this.position, e);\n            return this.position += e, new a(this.byteArrayParser, t);\n          }\n        }, {\n          key: \"getSize\",\n          value: function () {\n            return this.byteArray.length;\n          }\n        }, {\n          key: \"readUint16\",\n          value: function () {\n            var e = this.byteArrayParser.readUint16(this.byteArray, this.position);\n            return this.position += 2, e;\n          }\n        }, {\n          key: \"readUint32\",\n          value: function () {\n            var e = this.byteArrayParser.readUint32(this.byteArray, this.position);\n            return this.position += 4, e;\n          }\n        }, {\n          key: \"readFixedString\",\n          value: function (e) {\n            var t = b(this.byteArray, this.position, e);\n            return this.position += e, t;\n          }\n        }]) && C(e.prototype, t), r && C(e, r), Object.defineProperty(e, \"prototype\", {\n          writable: !1\n        }), a;\n      }(),\n      M = {\n        readUint16: function (e, t) {\n          if (t < 0) throw \"littleEndianByteArrayParser.readUint16: position cannot be less than 0\";\n          if (t + 2 > e.length) throw \"littleEndianByteArrayParser.readUint16: attempt to read past end of buffer\";\n          return e[t] + 256 * e[t + 1];\n        },\n        readInt16: function (e, t) {\n          if (t < 0) throw \"littleEndianByteArrayParser.readInt16: position cannot be less than 0\";\n          if (t + 2 > e.length) throw \"littleEndianByteArrayParser.readInt16: attempt to read past end of buffer\";\n          t = e[t] + (e[t + 1] << 8);\n          return t = 32768 & t ? t - 65535 - 1 : t;\n        },\n        readUint32: function (e, t) {\n          if (t < 0) throw \"littleEndianByteArrayParser.readUint32: position cannot be less than 0\";\n          if (t + 4 > e.length) throw \"littleEndianByteArrayParser.readUint32: attempt to read past end of buffer\";\n          return e[t] + 256 * e[t + 1] + 256 * e[t + 2] * 256 + 256 * e[t + 3] * 256 * 256;\n        },\n        readInt32: function (e, t) {\n          if (t < 0) throw \"littleEndianByteArrayParser.readInt32: position cannot be less than 0\";\n          if (t + 4 > e.length) throw \"littleEndianByteArrayParser.readInt32: attempt to read past end of buffer\";\n          return e[t] + (e[t + 1] << 8) + (e[t + 2] << 16) + (e[t + 3] << 24);\n        },\n        readFloat: function (e, t) {\n          if (t < 0) throw \"littleEndianByteArrayParser.readFloat: position cannot be less than 0\";\n          if (t + 4 > e.length) throw \"littleEndianByteArrayParser.readFloat: attempt to read past end of buffer\";\n          var r = new Uint8Array(4);\n          return r[0] = e[t], r[1] = e[t + 1], r[2] = e[t + 2], r[3] = e[t + 3], new Float32Array(r.buffer)[0];\n        },\n        readDouble: function (e, t) {\n          if (t < 0) throw \"littleEndianByteArrayParser.readDouble: position cannot be less than 0\";\n          if (t + 8 > e.length) throw \"littleEndianByteArrayParser.readDouble: attempt to read past end of buffer\";\n          var r = new Uint8Array(8);\n          return r[0] = e[t], r[1] = e[t + 1], r[2] = e[t + 2], r[3] = e[t + 3], r[4] = e[t + 4], r[5] = e[t + 5], r[6] = e[t + 6], r[7] = e[t + 7], new Float64Array(r.buffer)[0];\n        }\n      };\n    function G(e) {\n      var i = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};\n      if (void 0 === e) throw \"dicomParser.readPart10Header: missing required parameter 'byteArray'\";\n      var o = i.TransferSyntaxUID,\n        s = new J(M, e);\n      return function () {\n        var e = function () {\n            if (s.getSize() <= 132 && o) return !1;\n            if (s.seek(128), \"DICM\" === s.readFixedString(4)) return !0;\n            if (!(i || {}).TransferSyntaxUID) throw \"dicomParser.readPart10Header: DICM prefix not found at location 132 - this is not a valid DICOM P10 file.\";\n            return s.seek(0), !1;\n          }(),\n          t = [],\n          r = {};\n        if (!e) return s.position = 0, {\n          elements: {\n            x00020010: {\n              tag: \"x00020010\",\n              vr: \"UI\",\n              Value: o\n            }\n          },\n          warnings: t\n        };\n        for (; s.position < s.byteArray.length;) {\n          var a = s.position,\n            n = B(s, t);\n          if (\"x0002ffff\" < n.tag) {\n            s.position = a;\n            break;\n          }\n          n.parser = M, r[n.tag] = n;\n        }\n        return (e = new w(s.byteArrayParser, s.byteArray, r)).warnings = s.warnings, e.position = s.position, e;\n      }();\n    }\n    var z = \"1.2.840.10008.1.2.2\";\n    function V(i) {\n      var o = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};\n      if (void 0 === i) throw new Error(\"dicomParser.parseDicom: missing required parameter 'byteArray'\");\n      var e,\n        a = function (e) {\n          if (void 0 === e.elements.x00020010) throw new Error(\"dicomParser.parseDicom: missing required meta header attribute 0002,0010\");\n          e = e.elements.x00020010;\n          return e && e.Value || b(i, e.dataOffset, e.length);\n        };\n      function t(t) {\n        var e = a(t),\n          r = \"1.2.840.10008.1.2\" !== e,\n          e = function (e, t) {\n            var r = \"[object process]\" === Object.prototype.toString.call(\"undefined\" != typeof process ? process : 0);\n            if (\"1.2.840.10008.1.2.1.99\" !== e) return new J(e === z ? N : M, i, t);\n            if (o && o.inflater) {\n              e = o.inflater(i, t);\n              return new J(M, e, 0);\n            }\n            if (!0 == r) {\n              var a = s(0),\n                n = j(i, t, i.length - t),\n                a = a.inflateRawSync(n),\n                n = k(i, a.length + t);\n              return i.copy(n, 0, 0, t), a.copy(n, t), new J(M, n, 0);\n            }\n            if (\"undefined\" == typeof pako) throw \"dicomParser.parseDicom: no inflater available to handle deflate transfer syntax\";\n            return a = i.slice(t), n = pako.inflateRaw(a), (a = k(i, n.length + t)).set(i.slice(0, t), 0), a.set(n, t), new J(M, a, 0);\n          }(e, t.position),\n          t = new w(e.byteArrayParser, e.byteArray, {});\n        t.warnings = e.warnings;\n        try {\n          (r ? q : T)(t, e, e.byteArray.length, o);\n        } catch (e) {\n          throw {\n            exception: e,\n            dataSet: t\n          };\n        }\n        return t;\n      }\n      return function (e, t) {\n        for (var r in e.elements) e.elements.hasOwnProperty(r) && (t.elements[r] = e.elements[r]);\n        return void 0 !== e.warnings && (t.warnings = e.warnings.concat(t.warnings)), t;\n      }(e = G(i, o), t(e));\n    }\n    var R = function (e, t, r) {\n      for (var a = 0, n = t; n < t + r; n++) a += e[n].length;\n      return a;\n    };\n    function _(e, t, r, a, n) {\n      if (n = n || t.fragments, void 0 === e) throw \"dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'dataSet'\";\n      if (void 0 === t) throw \"dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'pixelDataElement'\";\n      if (void 0 === r) throw \"dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'startFragmentIndex'\";\n      if (void 0 === (a = a || 1)) throw \"dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'numFragments'\";\n      if (\"x7fe00010\" !== t.tag) throw \"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010\";\n      if (!0 !== t.encapsulatedPixelData) throw \"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data\";\n      if (!0 !== t.hadUndefinedLength) throw \"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data\";\n      if (void 0 === t.basicOffsetTable) throw \"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data\";\n      if (void 0 === t.fragments) throw \"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data\";\n      if (t.fragments.length <= 0) throw \"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data\";\n      if (r < 0) throw \"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragmentIndex' must be >= 0\";\n      if (r >= t.fragments.length) throw \"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragmentIndex' must be < number of fragments\";\n      if (a < 1) throw \"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'numFragments' must be > 0\";\n      if (r + a > t.fragments.length) throw \"dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragment' + 'numFragments' < number of fragments\";\n      var i = new J(e.byteArrayParser, e.byteArray, t.dataOffset),\n        t = S(i);\n      if (\"xfffee000\" !== t.tag) throw \"dicomParser.readEncapsulatedPixelData: missing basic offset table xfffee000\";\n      i.seek(t.length);\n      var o = i.position;\n      if (1 === a) return j(i.byteArray, o + n[r].offset + 8, n[r].length);\n      for (var t = R(n, r, a), s = k(i.byteArray, t), d = 0, f = r; f < r + a; f++) for (var l = o + n[f].offset + 8, u = 0; u < n[f].length; u++) s[d++] = i.byteArray[l++];\n      return s;\n    }\n    var H = function (e, t) {\n        for (var r = 0; r < e.length; r++) if (e[r].offset === t) return r;\n      },\n      Q = function (e, t, r, a) {\n        if (e === t.length - 1) return r.length - a;\n        for (var n = t[e + 1], i = a + 1; i < r.length; i++) if (r[i].offset === n) return i - a;\n        throw \"dicomParser.calculateNumberOfFragmentsForFrame: could not find fragment with offset matching basic offset table\";\n      };\n    function W(e, t, r, a, n) {\n      if (a = a || t.basicOffsetTable, n = n || t.fragments, void 0 === e) throw \"dicomParser.readEncapsulatedImageFrame: missing required parameter 'dataSet'\";\n      if (void 0 === t) throw \"dicomParser.readEncapsulatedImageFrame: missing required parameter 'pixelDataElement'\";\n      if (void 0 === r) throw \"dicomParser.readEncapsulatedImageFrame: missing required parameter 'frameIndex'\";\n      if (void 0 === a) throw \"dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' does not have basicOffsetTable\";\n      if (\"x7fe00010\" !== t.tag) throw \"dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010)\";\n      if (!0 !== t.encapsulatedPixelData) throw \"dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data\";\n      if (!0 !== t.hadUndefinedLength) throw \"dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have undefined length\";\n      if (void 0 === t.fragments) throw \"dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have fragments\";\n      if (0 === a.length) throw \"dicomParser.readEncapsulatedImageFrame: basicOffsetTable has zero entries\";\n      if (r < 0) throw \"dicomParser.readEncapsulatedImageFrame: parameter 'frameIndex' must be >= 0\";\n      if (r >= a.length) throw \"dicomParser.readEncapsulatedImageFrame: parameter 'frameIndex' must be < basicOffsetTable.length\";\n      var i = a[r],\n        i = H(n, i);\n      if (void 0 === i) throw \"dicomParser.readEncapsulatedImageFrame: unable to find fragment that matches basic offset table entry\";\n      return _(e, t, i, Q(r, a, n, i), n);\n    }\n    var $ = !1;\n    function K(e, t, r) {\n      if ($ || ($ = !0, console && console.log && console.log(\"WARNING: dicomParser.readEncapsulatedPixelData() has been deprecated\")), void 0 === e) throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'dataSet'\";\n      if (void 0 === t) throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'element'\";\n      if (void 0 === r) throw \"dicomParser.readEncapsulatedPixelData: missing required parameter 'frame'\";\n      if (\"x7fe00010\" !== t.tag) throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to non pixel data tag (expected tag = x7fe00010)\";\n      if (!0 !== t.encapsulatedPixelData) throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n      if (!0 !== t.hadUndefinedLength) throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n      if (void 0 === t.basicOffsetTable) throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n      if (void 0 === t.fragments) throw \"dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data\";\n      if (r < 0) throw \"dicomParser.readEncapsulatedPixelData: parameter 'frame' must be >= 0\";\n      return 0 !== t.basicOffsetTable.length ? W(e, t, r) : _(e, t, 0, t.fragments.length);\n    }\n    t.default = {\n      isStringVr: d,\n      isPrivateTag: f,\n      parsePN: a,\n      parseTM: n,\n      parseDA: o,\n      explicitElementToString: l,\n      explicitDataSetToJS: u,\n      createJPEGBasicOffsetTable: p,\n      parseDicomDataSetExplicit: q,\n      parseDicomDataSetImplicit: T,\n      readFixedString: b,\n      alloc: k,\n      version: L,\n      bigEndianByteArrayParser: N,\n      ByteStream: J,\n      sharedCopy: j,\n      DataSet: w,\n      findAndSetUNElementLength: y,\n      findEndOfEncapsulatedElement: g,\n      findItemDelimitationItemAndSetElementLength: x,\n      littleEndianByteArrayParser: M,\n      parseDicom: V,\n      readDicomElementExplicit: B,\n      readDicomElementImplicit: A,\n      readEncapsulatedImageFrame: W,\n      readEncapsulatedPixelData: K,\n      readEncapsulatedPixelDataFromFragments: _,\n      readPart10Header: G,\n      readSequenceItemsExplicit: I,\n      readSequenceItemsImplicit: F,\n      readSequenceItem: S,\n      readTag: h,\n      LEI: \"1.2.840.10008.1.2\",\n      LEE: \"1.2.840.10008.1.2.1\"\n    };\n  }], i = {}, n.m = a, n.c = i, n.d = function (e, t, r) {\n    n.o(e, t) || Object.defineProperty(e, t, {\n      enumerable: !0,\n      get: r\n    });\n  }, n.r = function (e) {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n      value: \"Module\"\n    }), Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n  }, n.t = function (t, e) {\n    if (1 & e && (t = n(t)), 8 & e) return t;\n    if (4 & e && \"object\" == typeof t && t && t.__esModule) return t;\n    var r = Object.create(null);\n    if (n.r(r), Object.defineProperty(r, \"default\", {\n      enumerable: !0,\n      value: t\n    }), 2 & e && \"string\" != typeof t) for (var a in t) n.d(r, a, function (e) {\n      return t[e];\n    }.bind(null, a));\n    return r;\n  }, n.n = function (e) {\n    var t = e && e.__esModule ? function () {\n      return e.default;\n    } : function () {\n      return e;\n    };\n    return n.d(t, \"a\", t), t;\n  }, n.o = function (e, t) {\n    return Object.prototype.hasOwnProperty.call(e, t);\n  }, n.p = \"\", n(n.s = 1);\n  function n(e) {\n    if (i[e]) return i[e].exports;\n    var t = i[e] = {\n      i: e,\n      l: !1,\n      exports: {}\n    };\n    return a[e].call(t.exports, t, t.exports, n), t.l = !0, t.exports;\n  }\n  var a, i;\n});","map":{"version":3,"names":["e","t","exports","module","require","define","amd","dicomParser","zlib","r","AE","AS","AT","CS","DA","DS","DT","FL","FD","IS","LO","LT","OB","OD","OF","OW","PN","SH","SL","SQ","SS","ST","TM","UI","UL","UN","UR","US","UT","d","isStringVr","f","isPrivateTag","parseInt","isNaN","a","parsePN","split","familyName","givenName","middleName","prefix","suffix","n","length","substring","i","Math","pow","concat","hours","minutes","seconds","fractionalSeconds","o","year","month","day","l","vr","tag","call","toString","string","uint32","toUpperCase","uint16","int16","int32","double","float","u","omitPrivateAttibutes","maxElementLength","elements","items","push","dataSet","s","dataOffset","c","byteArray","m","fragments","position","p","encapsulatedPixelData","hadUndefinedLength","basicOffsetTable","offset","h","readUint16","substr","g","readUint32","seek","y","warnings","b","String","fromCharCode","P","parser","w","byteArrayParser","value","readInt16","readInt32","readFloat","readDouble","match","Value","trim","replace","parseFloat","x","E","isSequence","A","F","S","D","T","vrCallback","O","B","q","I","U","getDataLengthSizeInBytesForVR","readFixedString","arguments","untilTag","k","Buffer","alloc","Uint8Array","L","N","Float32Array","buffer","Float64Array","j","slice","byteOffset","J","M","G","TransferSyntaxUID","getSize","x00020010","z","V","Error","readTransferSyntax","Object","prototype","process","inflater","inflateRawSync","copy","pako","inflateRaw","set","exception","hasOwnProperty","R","calculateBufferSize","_","H","findFragmentIndexWithOffset","Q","calculateNumberOfFragmentsForFrame","W","$","K","console","log","default","parseTM","parseDA","explicitElementToString","explicitDataSetToJS","createJPEGBasicOffsetTable","parseDicomDataSetExplicit","parseDicomDataSetImplicit","version","bigEndianByteArrayParser","ByteStream","sharedCopy","DataSet","findAndSetUNElementLength","findEndOfEncapsulatedElement","findItemDelimitationItemAndSetElementLength","littleEndianByteArrayParser","parseDicom","readDicomElementExplicit","readDicomElementImplicit","readEncapsulatedImageFrame","readEncapsulatedPixelData","readEncapsulatedPixelDataFromFragments","readPart10Header","readSequenceItemsExplicit","readSequenceItemsImplicit","readSequenceItem","readTag","LEI","LEE","defineProperty","enumerable","get","Symbol","toStringTag","__esModule","create","bind"],"sources":["webpack://dicomParser/webpack/universalModuleDefinition","webpack://dicomParser/external \"zlib\"","webpack://dicomParser/util/util.js","webpack://dicomParser/util/parseTM.js","webpack://dicomParser/util/parseDA.js","webpack://dicomParser/util/elementToString.js","webpack://dicomParser/util/dataSetToJS.js","webpack://dicomParser/util/createJPEGBasicOffsetTable.js","webpack://dicomParser/readTag.js","webpack://dicomParser/findEndOfEncapsulatedPixelData.js","webpack://dicomParser/findAndSetUNElementLength.js","webpack://dicomParser/byteArrayParser.js","webpack://dicomParser/dataSet.js","webpack://dicomParser/findItemDelimitationItem.js","webpack://dicomParser/readDicomElementImplicit.js","webpack://dicomParser/readSequenceItem.js","webpack://dicomParser/readSequenceElementImplicit.js","webpack://dicomParser/readSequenceElementExplicit.js","webpack://dicomParser/readDicomElementExplicit.js","webpack://dicomParser/parseDicomDataSet.js","webpack://dicomParser/alloc.js","webpack://dicomParser/version.js","webpack://dicomParser/bigEndianByteArrayParser.js","webpack://dicomParser/sharedCopy.js","webpack://dicomParser/byteStream.js","webpack://dicomParser/littleEndianByteArrayParser.js","webpack://dicomParser/readPart10Header.js","webpack://dicomParser/parseDicom.js","webpack://dicomParser/readEncapsulatedPixelDataFromFragments.js","webpack://dicomParser/readEncapsulatedImageFrame.js","webpack://dicomParser/readEncapsulatedPixelData.js","webpack://dicomParser/index.js","webpack://dicomParser/webpack/bootstrap"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"zlib\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"dicom-parser\", [\"zlib\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"dicom-parser\"] = factory(require(\"zlib\"));\n\telse\n\t\troot[\"dicomParser\"] = factory(root[\"zlib\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","const stringVrs = {\n  AE: true,\n  AS: true,\n  AT: false,\n  CS: true,\n  DA: true,\n  DS: true,\n  DT: true,\n  FL: false,\n  FD: false,\n  IS: true,\n  LO: true,\n  LT: true,\n  OB: false,\n  OD: false,\n  OF: false,\n  OW: false,\n  PN: true,\n  SH: true,\n  SL: false,\n  SQ: false,\n  SS: false,\n  ST: true,\n  TM: true,\n  UI: true,\n  UL: false,\n  UN: undefined, // dunno\n  UR: true,\n  US: false,\n  UT: true\n};\n\n/**\n * Tests to see if vr is a string or not.\n * @param vr\n * @returns true if string, false it not string, undefined if unknown vr or UN type\n */\nconst isStringVr = (vr) => stringVrs[vr];\n\n/**\n * Tests to see if a given tag in the format xggggeeee is a private tag or not\n * @param tag\n * @returns {boolean}\n * @throws error if fourth character cannot be parsed\n */\nconst isPrivateTag = (tag) => {\n  const lastGroupDigit = parseInt(tag[4], 16);\n  if (isNaN(lastGroupDigit)) {\n    throw 'dicomParser.isPrivateTag: cannot parse last character of group';\n  }\n  const groupIsOdd = (lastGroupDigit % 2) === 1;\n\n  return groupIsOdd;\n};\n\n/**\n * Parses a PN formatted string into a javascript object with properties for givenName, familyName, middleName, prefix and suffix\n * @param personName a string in the PN VR format\n * @param index\n * @returns {*} javascript object with properties for givenName, familyName, middleName, prefix and suffix or undefined if no element or data\n */\nconst parsePN = (personName) => {\n  if (personName === undefined) {\n    return undefined;\n  }\n  const stringValues = personName.split('^');\n\n\n  return {\n    familyName: stringValues[0],\n    givenName: stringValues[1],\n    middleName: stringValues[2],\n    prefix: stringValues[3],\n    suffix: stringValues[4]\n  };\n};\n\nexport {\n  isStringVr,\n  isPrivateTag,\n  parsePN\n};\n","/**\n * Parses a TM formatted string into a javascript object with properties for hours, minutes, seconds and fractionalSeconds\n * @param {string} time - a string in the TM VR format\n * @param {boolean} [validate] - true if an exception should be thrown if the date is invalid\n * @returns {*} javascript object with properties for hours, minutes, seconds and fractionalSeconds or undefined if no element or data.  Missing fields are set to undefined\n */\nexport default function parseTM (time, validate) {\n  if (time.length >= 2) { // must at least have HH\n    // 0123456789\n    // HHMMSS.FFFFFF\n    const hh = parseInt(time.substring(0, 2), 10);\n    const mm = time.length >= 4 ? parseInt(time.substring(2, 4), 10) : undefined;\n    const ss = time.length >= 6 ? parseInt(time.substring(4, 6), 10) : undefined;\n\n    const fractionalStr = time.length >= 8 ? time.substring(7, 13) : undefined;\n    const ffffff = fractionalStr ? (parseInt(fractionalStr, 10) * Math.pow(10, 6 - fractionalStr.length)) : undefined;\n\n    if (validate) {\n      if ((isNaN(hh)) ||\n        (mm !== undefined && isNaN(mm)) ||\n        (ss !== undefined && isNaN(ss)) ||\n        (ffffff !== undefined && isNaN(ffffff)) ||\n        (hh < 0 || hh > 23) ||\n        (mm && (mm < 0 || mm > 59)) ||\n        (ss && (ss < 0 || ss > 59)) ||\n        (ffffff && (ffffff < 0 || ffffff > 999999))) {\n        throw `invalid TM '${time}'`;\n      }\n    }\n\n    return {\n      hours: hh,\n      minutes: mm,\n      seconds: ss,\n      fractionalSeconds: ffffff\n    };\n  }\n\n  if (validate) {\n    throw `invalid TM '${time}'`;\n  }\n\n  return undefined;\n}\n","// algorithm based on http://stackoverflow.com/questions/1433030/validate-number-of-days-in-a-given-month\nfunction daysInMonth (m, y) { // m is 0 indexed: 0-11\n  switch (m) {\n  case 2 :\n    return (y % 4 == 0 && y % 100) || y % 400 == 0 ? 29 : 28;\n  case 9 : case 4 : case 6 : case 11 :\n    return 30;\n  default :\n    return 31;\n  }\n}\n\nfunction isValidDate (d, m, y) {\n  // make year is a number\n  if (isNaN(y)) {\n    return false;\n  }\n\n  return m > 0 && m <= 12 && d > 0 && d <= daysInMonth(m, y);\n}\n\n\n/**\n * Parses a DA formatted string into a Javascript object\n * @param {string} date a string in the DA VR format\n * @param {boolean} [validate] - true if an exception should be thrown if the date is invalid\n * @returns {*} Javascript object with properties year, month and day or undefined if not present or not 8 bytes long\n */\nexport default function parseDA (date, validate) {\n  if (date && date.length === 8) {\n    var yyyy = parseInt(date.substring(0, 4), 10);\n    var mm = parseInt(date.substring(4, 6), 10);\n    var dd = parseInt(date.substring(6, 8), 10);\n\n    if (validate) {\n      if (isValidDate(dd, mm, yyyy) !== true) {\n        throw `invalid DA '${date}'`;\n      }\n    }\n\n    return {\n      year: yyyy,\n      month: mm,\n      day: dd\n    };\n  }\n  if (validate) {\n    throw `invalid DA '${date}'`;\n  }\n\n  return undefined;\n}\n","import * as util from './util.js';\n\n/**\n * Converts an explicit VR element to a string or undefined if it is not possible to convert.\n * Throws an error if an implicit element is supplied\n * @param dataSet\n * @param element\n * @returns {*}\n */\nexport default function explicitElementToString (dataSet, element) {\n  if (dataSet === undefined || element === undefined) {\n    throw 'dicomParser.explicitElementToString: missing required parameters';\n  }\n  if (element.vr === undefined) {\n    throw 'dicomParser.explicitElementToString: cannot convert implicit element to string';\n  }\n  var vr = element.vr;\n  var tag = element.tag;\n\n  var textResult;\n\n  function multiElementToString (numItems, func) {\n    var result = '';\n\n    for (var i = 0; i < numItems; i++) {\n      if (i !== 0) {\n        result += '/';\n      }\n      result += func.call(dataSet, tag, i).toString();\n    }\n\n    return result;\n  }\n\n  if (util.isStringVr(vr) === true) {\n    textResult = dataSet.string(tag);\n  } else if (vr === 'AT') {\n    var num = dataSet.uint32(tag);\n\n    if (num === undefined) {\n      return undefined;\n    }\n    if (num < 0) {\n      num = 0xFFFFFFFF + num + 1;\n    }\n\n    return `x${num.toString(16).toUpperCase()}`;\n  } else if (vr === 'US') {\n    textResult = multiElementToString(element.length / 2, dataSet.uint16);\n  } else if (vr === 'SS') {\n    textResult = multiElementToString(element.length / 2, dataSet.int16);\n  } else if (vr === 'UL') {\n    textResult = multiElementToString(element.length / 4, dataSet.uint32);\n  } else if (vr === 'SL') {\n    textResult = multiElementToString(element.length / 4, dataSet.int32);\n  } else if (vr === 'FD') {\n    textResult = multiElementToString(element.length / 8, dataSet.double);\n  } else if (vr === 'FL') {\n    textResult = multiElementToString(element.length / 4, dataSet.float);\n  }\n\n  return textResult;\n}\n","import explicitElementToString from './elementToString.js';\nimport * as util from './util.js';\n\n/**\n * converts an explicit dataSet to a javascript object\n * @param dataSet\n * @param options\n */\nexport default function explicitDataSetToJS (dataSet, options) {\n  if (dataSet === undefined) {\n    throw 'dicomParser.explicitDataSetToJS: missing required parameter dataSet';\n  }\n\n  options = options || {\n    omitPrivateAttibutes: true, // true if private elements should be omitted\n    maxElementLength: 128 // maximum element length to try and convert to string format\n  };\n\n  var result = {\n\n  };\n\n  for (var tag in dataSet.elements) {\n    var element = dataSet.elements[tag];\n\n    // skip this element if it a private element and our options specify that we should\n    if (options.omitPrivateAttibutes === true && util.isPrivateTag(tag)) {\n      continue;\n    }\n\n    if (element.items) {\n      // handle sequences\n      var sequenceItems = [];\n\n      for (var i = 0; i < element.items.length; i++) {\n        sequenceItems.push(explicitDataSetToJS(element.items[i].dataSet, options));\n      }\n      result[tag] = sequenceItems;\n    } else {\n      var asString;\n\n      asString = undefined;\n      if (element.length < options.maxElementLength) {\n        asString = explicitElementToString(dataSet, element);\n      }\n\n      if (asString !== undefined) {\n        result[tag] = asString;\n      } else {\n        result[tag] = {\n          dataOffset: element.dataOffset,\n          length: element.length\n        };\n      }\n    }\n  }\n\n  return result;\n}\n","// Each JPEG image has an end of image marker 0xFFD9\nfunction isEndOfImageMarker (dataSet, position) {\n  return (dataSet.byteArray[position] === 0xFF &&\n  dataSet.byteArray[position + 1] === 0xD9);\n}\n\nfunction isFragmentEndOfImage (dataSet, pixelDataElement, fragmentIndex) {\n  var fragment = pixelDataElement.fragments[fragmentIndex];\n  // Need to check the last two bytes and the last three bytes for marker since odd length\n  // fragments are zero padded\n\n  if (isEndOfImageMarker(dataSet, fragment.position + fragment.length - 2) ||\n    isEndOfImageMarker(dataSet, fragment.position + fragment.length - 3)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction findLastImageFrameFragmentIndex (dataSet, pixelDataElement, startFragment) {\n  for (var fragmentIndex = startFragment; fragmentIndex < pixelDataElement.fragments.length; fragmentIndex++) {\n    if (isFragmentEndOfImage(dataSet, pixelDataElement, fragmentIndex)) {\n      return fragmentIndex;\n    }\n  }\n}\n\n/**\n * Creates a basic offset table by scanning fragments for JPEG start of image and end Of Image markers\n * @param {object} dataSet - the parsed dicom dataset\n * @param {object} pixelDataElement - the pixel data element\n * @param [fragments] - optional array of objects describing each fragment (offset, position, length)\n * @returns {Array} basic offset table (array of offsets to beginning of each frame)\n */\nexport default function createJPEGBasicOffsetTable (dataSet, pixelDataElement, fragments) {\n  // Validate parameters\n  if (dataSet === undefined) {\n    throw 'dicomParser.createJPEGBasicOffsetTable: missing required parameter dataSet';\n  }\n  if (pixelDataElement === undefined) {\n    throw 'dicomParser.createJPEGBasicOffsetTable: missing required parameter pixelDataElement';\n  }\n  if (pixelDataElement.tag !== 'x7fe00010') {\n    throw 'dicomParser.createJPEGBasicOffsetTable: parameter \\'pixelDataElement\\' refers to non pixel data tag (expected tag = x7fe00010\\'';\n  }\n  if (pixelDataElement.encapsulatedPixelData !== true) {\n    throw 'dicomParser.createJPEGBasicOffsetTable: parameter \\'pixelDataElement\\' refers to pixel data element that does not have encapsulated pixel data';\n  }\n  if (pixelDataElement.hadUndefinedLength !== true) {\n    throw 'dicomParser.createJPEGBasicOffsetTable: parameter \\'pixelDataElement\\' refers to pixel data element that does not have encapsulated pixel data';\n  }\n  if (pixelDataElement.basicOffsetTable === undefined) {\n    throw 'dicomParser.createJPEGBasicOffsetTable: parameter \\'pixelDataElement\\' refers to pixel data element that does not have encapsulated pixel data';\n  }\n  if (pixelDataElement.fragments === undefined) {\n    throw 'dicomParser.createJPEGBasicOffsetTable: parameter \\'pixelDataElement\\' refers to pixel data element that does not have encapsulated pixel data';\n  }\n  if (pixelDataElement.fragments.length <= 0) {\n    throw 'dicomParser.createJPEGBasicOffsetTable: parameter \\'pixelDataElement\\' refers to pixel data element that does not have encapsulated pixel data';\n  }\n  if (fragments && fragments.length <= 0) {\n    throw 'dicomParser.createJPEGBasicOffsetTable: parameter \\'fragments\\' must not be zero length';\n  }\n\n  // Default values\n  fragments = fragments || pixelDataElement.fragments;\n\n  var basicOffsetTable = [];\n\n  var startFragmentIndex = 0;\n\n  while (true) {\n    // Add the offset for the start fragment\n    basicOffsetTable.push(pixelDataElement.fragments[startFragmentIndex].offset);\n    var endFragmentIndex = findLastImageFrameFragmentIndex(dataSet, pixelDataElement, startFragmentIndex);\n\n    if (endFragmentIndex === undefined || endFragmentIndex === pixelDataElement.fragments.length - 1) {\n      return basicOffsetTable;\n    }\n    startFragmentIndex = endFragmentIndex + 1;\n  }\n}\n","/**\n * Internal helper functions for parsing DICOM elements\n */\n\n/**\n * Reads a tag (group number and element number) from a byteStream\n * @param byteStream the byte stream to read from\n * @returns {string} the tag in format xggggeeee where gggg is the lowercase hex value of the group number\n * and eeee is the lower case hex value of the element number\n */\nexport default function readTag (byteStream) {\n  if (byteStream === undefined) {\n    throw 'dicomParser.readTag: missing required parameter \\'byteStream\\'';\n  }\n\n  const groupNumber = byteStream.readUint16() * 256 * 256;\n  const elementNumber = byteStream.readUint16();\n  const tag = `x${(`00000000${(groupNumber + elementNumber).toString(16)}`).substr(-8)}`;\n\n  return tag;\n}\n","import readTag from './readTag.js';\n\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\n/**\n * Reads an encapsulated pixel data element and adds an array of fragments to the element\n * containing the offset and length of each fragment and any offsets from the basic offset\n * table\n * @param byteStream\n * @param element\n */\nexport default function findEndOfEncapsulatedElement (byteStream, element, warnings) {\n  if (byteStream === undefined) {\n    throw 'dicomParser.findEndOfEncapsulatedElement: missing required parameter \\'byteStream\\'';\n  }\n\n  if (element === undefined) {\n    throw 'dicomParser.findEndOfEncapsulatedElement: missing required parameter \\'element\\'';\n  }\n\n  element.encapsulatedPixelData = true;\n  element.basicOffsetTable = [];\n  element.fragments = [];\n\n  const basicOffsetTableItemTag = readTag(byteStream);\n\n  if (basicOffsetTableItemTag !== 'xfffee000') {\n    throw 'dicomParser.findEndOfEncapsulatedElement: basic offset table not found';\n  }\n\n  const basicOffsetTableItemlength = byteStream.readUint32();\n  const numFragments = basicOffsetTableItemlength / 4;\n\n  // Bad idea to not include the basic offset table, as it means writing the data out is inconsistent with reading it\n  // but leave this for now.  To fix later.\n  for (let i = 0; i < numFragments; i++) {\n    const offset = byteStream.readUint32();\n\n    element.basicOffsetTable.push(offset);\n  }\n\n  const baseOffset = byteStream.position;\n\n  while (byteStream.position < byteStream.byteArray.length) {\n    const tag = readTag(byteStream);\n    let length = byteStream.readUint32();\n\n    if (tag === 'xfffee0dd') {\n      byteStream.seek(length);\n      element.length = byteStream.position - element.dataOffset;\n\n      return;\n    } else if (tag === 'xfffee000') {\n      element.fragments.push({\n        offset: byteStream.position - baseOffset - 8,\n        position: byteStream.position,\n        length\n      });\n    } else {\n      if (warnings) {\n        warnings.push(`unexpected tag ${tag} while searching for end of pixel data element with undefined length`);\n      }\n\n      if (length > byteStream.byteArray.length - byteStream.position) {\n        // fix length\n        length = byteStream.byteArray.length - byteStream.position;\n      }\n\n      element.fragments.push({\n        offset: byteStream.position - baseOffset - 8,\n        position: byteStream.position,\n        length\n      });\n\n      byteStream.seek(length);\n      element.length = byteStream.position - element.dataOffset;\n\n      return;\n    }\n\n    byteStream.seek(length);\n  }\n\n  if (warnings) {\n    warnings.push(`pixel data element ${element.tag} missing sequence delimiter tag xfffee0dd`);\n  }\n}\n","/**\n * Internal helper functions for parsing DICOM elements\n */\n\n/**\n * reads from the byte stream until it finds the magic number for the Sequence Delimitation\n * Item item and then sets the length of the element\n * @param byteStream\n * @param element\n */\nexport default function findAndSetUNElementLength (byteStream, element) {\n  if (byteStream === undefined) {\n    throw 'dicomParser.findAndSetUNElementLength: missing required parameter \\'byteStream\\'';\n  }\n\n  // group, element, length\n  const itemDelimitationItemLength = 8;\n  const maxPosition = byteStream.byteArray.length - itemDelimitationItemLength;\n\n  while (byteStream.position <= maxPosition) {\n    const groupNumber = byteStream.readUint16();\n\n    if (groupNumber === 0xfffe) {\n      const elementNumber = byteStream.readUint16();\n\n      if (elementNumber === 0xe0dd) {\n        // NOTE: It would be better to also check for the length to be 0 as part of the check above\n        // but we will just log a warning for now\n        const itemDelimiterLength = byteStream.readUint32();\n\n        if (itemDelimiterLength !== 0) {\n          byteStream.warnings(`encountered non zero length following item delimiter at position ${byteStream.position - 4} while reading element of undefined length with tag ${element.tag}`);\n        }\n        element.length = byteStream.position - element.dataOffset;\n\n        return;\n      }\n    }\n  }\n\n  // No item delimitation item - silently set the length to the end\n  // of the buffer and set the position past the end of the buffer\n  element.length = byteStream.byteArray.length - element.dataOffset;\n  byteStream.seek(byteStream.byteArray.length - byteStream.position);\n}\n","/**\n * Internal helper functions common to parsing byte arrays of any type\n */\n\n/**\n * Reads a string of 8-bit characters from an array of bytes and advances\n * the position by length bytes.  A null terminator will end the string\n * but will not affect advancement of the position.  Trailing and leading\n * spaces are preserved (not trimmed)\n * @param byteArray the byteArray to read from\n * @param position the position in the byte array to read from\n * @param length the maximum number of bytes to parse\n * @returns {string} the parsed string\n * @throws error if buffer overread would occur\n * @access private\n */\nexport function readFixedString (byteArray, position, length) {\n  if (length < 0) {\n    throw 'dicomParser.readFixedString - length cannot be less than 0';\n  }\n\n  if (position + length > byteArray.length) {\n    throw 'dicomParser.readFixedString: attempt to read past end of buffer';\n  }\n\n  var result = '';\n  var byte;\n\n  for (var i = 0; i < length; i++) {\n    byte = byteArray[position + i];\n    if (byte === 0) {\n      position += length;\n\n      return result;\n    }\n    result += String.fromCharCode(byte);\n  }\n\n  return result;\n}\n","import { readFixedString } from './byteArrayParser.js';\n\n/**\n *\n * The DataSet class encapsulates a collection of DICOM Elements and provides various functions\n * to access the data in those elements\n *\n * Rules for handling padded spaces:\n * DS = Strip leading and trailing spaces\n * DT = Strip trailing spaces\n * IS = Strip leading and trailing spaces\n * PN = Strip trailing spaces\n * TM = Strip trailing spaces\n * AE = Strip leading and trailing spaces\n * CS = Strip leading and trailing spaces\n * SH = Strip leading and trailing spaces\n * LO = Strip leading and trailing spaces\n * LT = Strip trailing spaces\n * ST = Strip trailing spaces\n * UT = Strip trailing spaces\n *\n */\n\nfunction getByteArrayParser (element, defaultParser) {\n  return (element.parser !== undefined ? element.parser : defaultParser);\n}\n\n/**\n * Constructs a new DataSet given byteArray and collection of elements\n * @param byteArrayParser\n * @param byteArray\n * @param elements\n * @constructor\n */\nexport default class DataSet {\n  constructor (byteArrayParser, byteArray, elements) {\n    this.byteArrayParser = byteArrayParser;\n    this.byteArray = byteArray;\n    this.elements = elements;\n  }\n\n  /**\n     * Finds the element for tag and returns an unsigned int 16 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} unsigned int 16 or undefined if the attribute is not present or has data of length 0\n     */\n  uint16 (tag, index) {\n    var element = this.elements[tag];\n\n    index = (index !== undefined) ? index : 0;\n    if (element && element.length !== 0) {\n      return getByteArrayParser(element, this.byteArrayParser).readUint16(this.byteArray, element.dataOffset + (index * 2));\n    }\n\n    return undefined;\n  }\n\n  /**\n     * Finds the element for tag and returns an signed int 16 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} signed int 16 or undefined if the attribute is not present or has data of length 0\n     */\n  int16 (tag, index) {\n    var element = this.elements[tag];\n\n    index = (index !== undefined) ? index : 0;\n    if (element && element.length !== 0) {\n      return getByteArrayParser(element, this.byteArrayParser).readInt16(this.byteArray, element.dataOffset + (index * 2));\n    }\n\n    return undefined;\n  }\n\n  /**\n     * Finds the element for tag and returns an unsigned int 32 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} unsigned int 32 or undefined if the attribute is not present or has data of length 0\n     */\n  uint32 (tag, index) {\n    var element = this.elements[tag];\n\n    index = (index !== undefined) ? index : 0;\n    if (element && element.length !== 0) {\n      return getByteArrayParser(element, this.byteArrayParser).readUint32(this.byteArray, element.dataOffset + (index * 4));\n    }\n\n    return undefined;\n  }\n\n  /**\n     * Finds the element for tag and returns an signed int 32 if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} signed int 32 or undefined if the attribute is not present or has data of length 0\n     */\n  int32 (tag, index) {\n    var element = this.elements[tag];\n\n    index = (index !== undefined) ? index : 0;\n    if (element && element.length !== 0) {\n      return getByteArrayParser(element, this.byteArrayParser).readInt32(this.byteArray, element.dataOffset + (index * 4));\n    }\n\n    return undefined;\n  }\n\n  /**\n     * Finds the element for tag and returns a 32 bit floating point number (VR=FL) if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} float or undefined if the attribute is not present or has data of length 0\n     */\n  float (tag, index) {\n    var element = this.elements[tag];\n\n    index = (index !== undefined) ? index : 0;\n    if (element && element.length !== 0) {\n      return getByteArrayParser(element, this.byteArrayParser).readFloat(this.byteArray, element.dataOffset + (index * 4));\n    }\n\n    return undefined;\n  }\n\n  /**\n     * Finds the element for tag and returns a 64 bit floating point number (VR=FD) if it exists and has data\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied\n     * @returns {*} float or undefined if the attribute is not present or doesn't has data of length 0\n     */\n  double (tag, index) {\n    var element = this.elements[tag];\n\n    index = (index !== undefined) ? index : 0;\n    if (element && element.length !== 0) {\n      return getByteArrayParser(element, this.byteArrayParser).readDouble(this.byteArray, element.dataOffset + (index * 8));\n    }\n\n    return undefined;\n  }\n\n  /**\n     * Returns the number of string values for the element\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @returns {*} the number of string values or undefined if the attribute is not present or has zero length data\n     */\n  numStringValues (tag) {\n    var element = this.elements[tag];\n\n    if (element && element.length > 0) {\n      var fixedString = readFixedString(this.byteArray, element.dataOffset, element.length);\n      var numMatching = fixedString.match(/\\\\/g);\n\n      if (numMatching === null) {\n        return 1;\n      }\n\n      return numMatching.length + 1;\n    }\n\n    return undefined;\n  }\n\n  /**\n     * Returns a string for the element.  If index is provided, the element is assumed to be\n     * multi-valued and will return the component specified by index.  Undefined is returned\n     * if there is no component with the specified index, the element does not exist or is zero length.\n     *\n     * Use this function for VR types of AE, CS, SH and LO\n     *\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the entire string\n     * @returns {*}\n     */\n  string (tag, index) {\n    var element = this.elements[tag];\n\n    if( element && element.Value ) return element.Value;\n    \n    if (element && element.length > 0) {\n      var fixedString = readFixedString(this.byteArray, element.dataOffset, element.length);\n\n      if (index >= 0) {\n        var values = fixedString.split('\\\\');\n        // trim trailing spaces\n\n        return values[index].trim();\n      }\n      // trim trailing spaces\n      return fixedString.trim();\n    }\n\n    return undefined;\n  }\n\n  /**\n     * Returns a string with the leading spaces preserved and trailing spaces removed.\n     *\n     * Use this function to access data for VRs of type UT, ST and LT\n     *\n     * @param tag\n     * @param index\n     * @returns {*}\n     */\n  text (tag, index) {\n    var element = this.elements[tag];\n\n    if (element && element.length > 0) {\n      var fixedString = readFixedString(this.byteArray, element.dataOffset, element.length);\n\n      if (index >= 0) {\n        var values = fixedString.split('\\\\');\n\n\n        return values[index].replace(/ +$/, '');\n      }\n\n      return fixedString.replace(/ +$/, '');\n    }\n\n    return undefined;\n  }\n\n  /**\n     * Parses a string to a float for the specified index in a multi-valued element.  If index is not specified,\n     * the first value in a multi-valued VR will be parsed if present.\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the first value\n     * @returns {*} a floating point number or undefined if not present or data not long enough\n     */\n  floatString (tag, index) {\n    var element = this.elements[tag];\n\n    if (element && element.length > 0) {\n      index = (index !== undefined) ? index : 0;\n      var value = this.string(tag, index);\n\n      if (value !== undefined) {\n        return parseFloat(value);\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n     * Parses a string to an integer for the specified index in a multi-valued element.  If index is not specified,\n     * the first value in a multi-valued VR will be parsed if present.\n     * @param tag The DICOM tag in the format xGGGGEEEE\n     * @param index the index of the desired value in a multi valued string or undefined for the first value\n     * @returns {*} an integer or undefined if not present or data not long enough\n     */\n  intString (tag, index) {\n    var element = this.elements[tag];\n\n    if (element && element.length > 0) {\n      index = (index !== undefined) ? index : 0;\n      var value = this.string(tag, index);\n\n      if (value !== undefined) {\n        return parseInt(value);\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n     * Parses an element tag according to the 'AT' VR definition (VR=AT).\n     * @param {String} A DICOM tag with in the format xGGGGEEEE.\n     * @returns {String} A string representation of a data element tag or undefined if the field is not present or data is not long enough.\n     */\n  attributeTag (tag) {\n    const element = this.elements[tag];\n\n    if (element && element.length === 4) {\n      const parser = getByteArrayParser(element, this.byteArrayParser).readUint16;\n      const bytes = this.byteArray;\n      const offset = element.dataOffset;\n\n      return `x${(`00000000${(parser(bytes, offset) * 256 * 256 + parser(bytes, offset + 2)).toString(16)}`).substr(-8)}`;\n    }\n\n    return undefined;\n  }\n}\n","/**\n * Internal helper functions for parsing DICOM elements\n */\n\n/**\n * reads from the byte stream until it finds the magic numbers for the item delimitation item\n * and then sets the length of the element\n * @param byteStream\n * @param element\n */\nexport default function findItemDelimitationItemAndSetElementLength (byteStream, element) {\n  if (byteStream === undefined) {\n    throw 'dicomParser.readDicomElementImplicit: missing required parameter \\'byteStream\\'';\n  }\n\n  const itemDelimitationItemLength = 8; // group, element, length\n  const maxPosition = byteStream.byteArray.length - itemDelimitationItemLength;\n\n  while (byteStream.position <= maxPosition) {\n    const groupNumber = byteStream.readUint16();\n\n    if (groupNumber === 0xfffe) {\n      const elementNumber = byteStream.readUint16();\n\n      if (elementNumber === 0xe00d) {\n        // NOTE: It would be better to also check for the length to be 0 as part of the check above\n        // but we will just log a warning for now\n        const itemDelimiterLength = byteStream.readUint32(); // the length\n\n        if (itemDelimiterLength !== 0) {\n          byteStream.warnings(`encountered non zero length following item delimiter at position ${byteStream.position - 4} while reading element of undefined length with tag ${element.tag}`);\n        }\n\n        element.length = byteStream.position - element.dataOffset;\n\n        return;\n      }\n    }\n  }\n\n  // No item delimitation item - silently set the length to the end of the buffer and set the position past the end of the buffer\n  element.length = byteStream.byteArray.length - element.dataOffset;\n  byteStream.seek(byteStream.byteArray.length - byteStream.position);\n}\n","import findItemDelimitationItemAndSetElementLength from './findItemDelimitationItem.js';\nimport readSequenceItemsImplicit from './readSequenceElementImplicit.js';\nimport readTag from './readTag.js';\nimport { isPrivateTag } from './util/util.js';\n\n/**\n * Internal helper functions for for parsing DICOM elements\n */\n\nconst isSequence = (element, byteStream) => {\n  if (element.vr !== undefined) {\n    return (element.vr === 'SQ');\n  }\n\n  if ((byteStream.position + 4) <= byteStream.byteArray.length) {\n    const nextTag = readTag(byteStream);\n\n    byteStream.seek(-4);\n\n    // Item start tag (fffe,e000) or sequence delimiter (i.e. end of sequence) tag (0fffe,e0dd)\n    // These are the tags that could potentially be found directly after a sequence start tag (the delimiter\n    // is found in the case of an empty sequence). This is not 100% safe because a non-sequence item\n    // could have data that has these bytes, but this is how to do it without a data dictionary.\n    return (nextTag === 'xfffee000') || (nextTag === 'xfffee0dd');\n  }\n\n  byteStream.warnings.push('eof encountered before finding sequence item tag or sequence delimiter tag in peeking to determine VR');\n\n  return false;\n};\n\nexport default function readDicomElementImplicit (byteStream, untilTag, vrCallback) {\n  if (byteStream === undefined) {\n    throw 'dicomParser.readDicomElementImplicit: missing required parameter \\'byteStream\\'';\n  }\n\n  const tag = readTag(byteStream);\n\n  const element = {\n    tag,\n    vr: (vrCallback !== undefined ? vrCallback(tag) : undefined),\n    length: byteStream.readUint32(),\n    dataOffset: byteStream.position\n  };\n\n  if (element.length === 4294967295) {\n    element.hadUndefinedLength = true;\n  }\n\n  if (element.tag === untilTag) {\n    return element;\n  }\n\n  // always parse sequences with undefined lengths, since there's no other way to know how long they are.\n  if (isSequence(element, byteStream) && (!isPrivateTag(element.tag) || element.hadUndefinedLength)) {\n    // parse the sequence\n    readSequenceItemsImplicit(byteStream, element, vrCallback);\n\n    if (isPrivateTag(element.tag)) {\n      element.items = undefined;\n    }\n\n    return element;\n  }\n\n  // if element is not a sequence and has undefined length, we have to\n  // scan the data for a magic number to figure out when it ends.\n  if (element.hadUndefinedLength) {\n    findItemDelimitationItemAndSetElementLength(byteStream, element);\n\n    return element;\n  }\n\n  // non sequence element with known length, skip over the data part\n  byteStream.seek(element.length);\n\n  return element;\n}\n","import readTag from './readTag.js';\n\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\n/**\n * Reads the tag and length of a sequence item and returns them as an object with the following properties\n *  tag : string for the tag of this element in the format xggggeeee\n *  length: the number of bytes in this item or 4294967295 if undefined\n *  dataOffset: the offset into the byteStream of the data for this item\n * @param byteStream the byte\n * @returns {{tag: string, length: integer, dataOffset: integer}}\n */\nexport default function readSequenceItem (byteStream) {\n  if (byteStream === undefined) {\n    throw 'dicomParser.readSequenceItem: missing required parameter \\'byteStream\\'';\n  }\n\n  const element = {\n    tag: readTag(byteStream),\n    length: byteStream.readUint32(),\n    dataOffset: byteStream.position\n  };\n\n  if (element.tag !== 'xfffee000') {\n    throw `dicomParser.readSequenceItem: item tag (FFFE,E000) not found at offset ${byteStream.position}`;\n  }\n\n  return element;\n}\n","import DataSet from './dataSet.js';\nimport readDicomElementImplicit from './readDicomElementImplicit.js';\nimport readSequenceItem from './readSequenceItem.js';\nimport readTag from './readTag.js';\nimport * as parseDicomDataSet from './parseDicomDataSet.js';\n\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nfunction readDicomDataSetImplicitUndefinedLength (byteStream, vrCallback) {\n  const elements = {};\n\n  while (byteStream.position < byteStream.byteArray.length) {\n    const element = readDicomElementImplicit(byteStream, undefined, vrCallback);\n\n    elements[element.tag] = element;\n\n    // we hit an item delimiter tag, return the current offset to mark\n    // the end of this sequence item\n    if (element.tag === 'xfffee00d') {\n      return new DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n    }\n  }\n\n  // eof encountered - log a warning and return what we have for the element\n  byteStream.warnings.push('eof encountered before finding sequence item delimiter in sequence item of undefined length');\n\n  return new DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n}\n\nfunction readSequenceItemImplicit (byteStream, vrCallback) {\n  const item = readSequenceItem(byteStream);\n\n  if (item.length === 4294967295) {\n    item.hadUndefinedLength = true;\n    item.dataSet = readDicomDataSetImplicitUndefinedLength(byteStream, vrCallback);\n    item.length = byteStream.position - item.dataOffset;\n  } else {\n    item.dataSet = new DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});\n    parseDicomDataSet.parseDicomDataSetImplicit(item.dataSet, byteStream, byteStream.position + item.length, { vrCallback });\n  }\n\n  return item;\n}\n\nfunction readSQElementUndefinedLengthImplicit (byteStream, element, vrCallback) {\n  while ((byteStream.position + 4) <= byteStream.byteArray.length) {\n    // end reading this sequence if the next tag is the sequence delimitation item\n    const nextTag = readTag(byteStream);\n\n    byteStream.seek(-4);\n\n    if (nextTag === 'xfffee0dd') {\n      // set the correct length\n      element.length = byteStream.position - element.dataOffset;\n      byteStream.seek(8);\n\n      return element;\n    }\n\n    const item = readSequenceItemImplicit(byteStream, vrCallback);\n\n    element.items.push(item);\n  }\n\n  byteStream.warnings.push('eof encountered before finding sequence delimiter in sequence of undefined length');\n  element.length = byteStream.byteArray.length - element.dataOffset;\n}\n\nfunction readSQElementKnownLengthImplicit (byteStream, element, vrCallback) {\n  const maxPosition = element.dataOffset + element.length;\n\n  while (byteStream.position < maxPosition) {\n    const item = readSequenceItemImplicit(byteStream, vrCallback);\n\n    element.items.push(item);\n  }\n}\n\n/**\n * Reads sequence items for an element in an implicit little endian byte stream\n * @param byteStream the implicit little endian byte stream\n * @param element the element to read the sequence items for\n * @param vrCallback an optional method that returns a VR string given a tag\n */\nexport default function readSequenceItemsImplicit (byteStream, element, vrCallback) {\n  if (byteStream === undefined) {\n    throw 'dicomParser.readSequenceItemsImplicit: missing required parameter \\'byteStream\\'';\n  }\n\n  if (element === undefined) {\n    throw 'dicomParser.readSequenceItemsImplicit: missing required parameter \\'element\\'';\n  }\n\n  element.items = [];\n\n  if (element.length === 4294967295) {\n    readSQElementUndefinedLengthImplicit(byteStream, element, vrCallback);\n  } else {\n    readSQElementKnownLengthImplicit(byteStream, element, vrCallback);\n  }\n}\n","import DataSet from './dataSet.js';\nimport readDicomElementExplicit from './readDicomElementExplicit.js';\nimport readSequenceItem from './readSequenceItem.js';\nimport readTag from './readTag.js';\nimport * as parseDicomDataSet from './parseDicomDataSet.js';\n\n/**\n * Internal helper functions for parsing DICOM elements\n */\n\nfunction readDicomDataSetExplicitUndefinedLength (byteStream, warnings) {\n  const elements = {};\n\n  while (byteStream.position < byteStream.byteArray.length) {\n    const element = readDicomElementExplicit(byteStream, warnings);\n\n    elements[element.tag] = element;\n\n    // we hit an item delimiter tag, return the current offset to mark\n    // the end of this sequence item\n    if (element.tag === 'xfffee00d') {\n      return new DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n    }\n  }\n\n  // eof encountered - log a warning and return what we have for the element\n  warnings.push('eof encountered before finding item delimiter tag while reading sequence item of undefined length');\n\n  return new DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);\n}\n\nfunction readSequenceItemExplicit (byteStream, warnings) {\n  const item = readSequenceItem(byteStream);\n\n  if (item.length === 4294967295) {\n    item.hadUndefinedLength = true;\n    item.dataSet = readDicomDataSetExplicitUndefinedLength(byteStream, warnings);\n    item.length = byteStream.position - item.dataOffset;\n  } else {\n    item.dataSet = new DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});\n    parseDicomDataSet.parseDicomDataSetExplicit(item.dataSet, byteStream, byteStream.position + item.length);\n  }\n\n  return item;\n}\n\nfunction readSQElementUndefinedLengthExplicit (byteStream, element, warnings) {\n  while ((byteStream.position + 4) <= byteStream.byteArray.length) {\n    // end reading this sequence if the next tag is the sequence delimitation item\n    const nextTag = readTag(byteStream);\n\n    byteStream.seek(-4);\n    if (nextTag === 'xfffee0dd') {\n      // set the correct length\n      element.length = byteStream.position - element.dataOffset;\n      byteStream.seek(8);\n\n      return element;\n    }\n\n    const item = readSequenceItemExplicit(byteStream, warnings);\n\n    element.items.push(item);\n  }\n\n  warnings.push('eof encountered before finding sequence delimitation tag while reading sequence of undefined length');\n  element.length = byteStream.position - element.dataOffset;\n}\n\nfunction readSQElementKnownLengthExplicit (byteStream, element, warnings) {\n  const maxPosition = element.dataOffset + element.length;\n\n  while (byteStream.position < maxPosition) {\n    const item = readSequenceItemExplicit(byteStream, warnings);\n\n    element.items.push(item);\n  }\n}\n\nexport default function readSequenceItemsExplicit (byteStream, element, warnings) {\n  if (byteStream === undefined) {\n    throw 'dicomParser.readSequenceItemsExplicit: missing required parameter \\'byteStream\\'';\n  }\n\n  if (element === undefined) {\n    throw 'dicomParser.readSequenceItemsExplicit: missing required parameter \\'element\\'';\n  }\n\n  element.items = [];\n\n  if (element.length === 4294967295) {\n    readSQElementUndefinedLengthExplicit(byteStream, element, warnings);\n  } else {\n    readSQElementKnownLengthExplicit(byteStream, element, warnings);\n  }\n}\n","import findEndOfEncapsulatedElement from './findEndOfEncapsulatedPixelData.js';\nimport findAndSetUNElementLength from './findAndSetUNElementLength.js';\nimport readSequenceItemsImplicit  from './readSequenceElementImplicit.js';\nimport readTag from './readTag.js';\nimport findItemDelimitationItemAndSetElementLength from './findItemDelimitationItem.js';\nimport readSequenceItemsExplicit from './readSequenceElementExplicit.js';\n\n/**\n * Internal helper functions for for parsing DICOM elements\n */\n\nconst getDataLengthSizeInBytesForVR = (vr) => {\n  if (vr === 'OB' ||\n      vr === 'OD' ||\n      vr === 'OL' ||\n      vr === 'OW' ||\n      vr === 'SQ' ||\n      vr === 'OF' ||\n      vr === 'UC' ||\n      vr === 'UR' ||\n      vr === 'UT' ||\n      vr === 'UN') {\n    return 4;\n  }\n\n  return 2;\n};\n\nexport default function readDicomElementExplicit (byteStream, warnings, untilTag) {\n  if (byteStream === undefined) {\n    throw 'dicomParser.readDicomElementExplicit: missing required parameter \\'byteStream\\'';\n  }\n\n  const element = {\n    tag: readTag(byteStream),\n    vr: byteStream.readFixedString(2)\n    // length set below based on VR\n    // dataOffset set below based on VR and size of length\n  };\n\n  const dataLengthSizeBytes = getDataLengthSizeInBytesForVR(element.vr);\n\n  if (dataLengthSizeBytes === 2) {\n    element.length = byteStream.readUint16();\n    element.dataOffset = byteStream.position;\n  } else {\n    byteStream.seek(2);\n    element.length = byteStream.readUint32();\n    element.dataOffset = byteStream.position;\n  }\n\n  if (element.length === 4294967295) {\n    element.hadUndefinedLength = true;\n  }\n\n  if (element.tag === untilTag) {\n    return element;\n  }\n\n  // if VR is SQ, parse the sequence items\n  if (element.vr === 'SQ') {\n    readSequenceItemsExplicit(byteStream, element, warnings);\n\n    return element;\n  }\n\n  if (element.length === 4294967295) {\n    if (element.tag === 'x7fe00010') {\n      findEndOfEncapsulatedElement(byteStream, element, warnings);\n\n      return element;\n    } else if (element.vr === 'UN') {\n      readSequenceItemsImplicit(byteStream, element);\n\n      return element;\n    }\n\n    findItemDelimitationItemAndSetElementLength(byteStream, element);\n\n    return element;\n  }\n\n  byteStream.seek(element.length);\n\n  return element;\n}\n","import readDicomElementExplicit from './readDicomElementExplicit.js';\nimport readDicomElementImplicit from './readDicomElementImplicit.js';\n\n/**\n * Internal helper functions for parsing implicit and explicit DICOM data sets\n */\n\n/**\n * reads an explicit data set\n * @param byteStream the byte stream to read from\n * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)\n */\nexport function parseDicomDataSetExplicit (dataSet, byteStream, maxPosition, options = {}) {\n  maxPosition = (maxPosition === undefined) ? byteStream.byteArray.length : maxPosition;\n\n  if (byteStream === undefined) {\n    throw 'dicomParser.parseDicomDataSetExplicit: missing required parameter \\'byteStream\\'';\n  }\n\n  if (maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length) {\n    throw 'dicomParser.parseDicomDataSetExplicit: invalid value for parameter \\'maxP osition\\'';\n  }\n\n  const elements = dataSet.elements;\n\n  while (byteStream.position < maxPosition) {\n    const element = readDicomElementExplicit(byteStream, dataSet.warnings, options.untilTag);\n\n    elements[element.tag] = element;\n    if (element.tag === options.untilTag) {\n      return;\n    }\n  }\n\n  if (byteStream.position > maxPosition) {\n    throw 'dicomParser:parseDicomDataSetExplicit: buffer overrun';\n  }\n}\n\n/**\n * reads an implicit data set\n * @param byteStream the byte stream to read from\n * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)\n */\nexport function parseDicomDataSetImplicit (dataSet, byteStream, maxPosition, options = {}) {\n  maxPosition = (maxPosition === undefined) ? dataSet.byteArray.length : maxPosition;\n\n  if (byteStream === undefined) {\n    throw 'dicomParser.parseDicomDataSetImplicit: missing required parameter \\'byteStream\\'';\n  }\n\n  if (maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length) {\n    throw 'dicomParser.parseDicomDataSetImplicit: invalid value for parameter \\'maxPosition\\'';\n  }\n\n  const elements = dataSet.elements;\n\n  while (byteStream.position < maxPosition) {\n    const element = readDicomElementImplicit(byteStream, options.untilTag, options.vrCallback);\n\n    elements[element.tag] = element;\n    if (element.tag === options.untilTag) {\n      return;\n    }\n  }\n}\n","/**\n * Creates a new byteArray of the same type (Uint8Array or Buffer) of the specified length.\n * @param byteArray the underlying byteArray (either Uint8Array or Buffer)\n * @param length number of bytes of the Byte Array\n * @returns {object} Uint8Array or Buffer depending on the type of byteArray\n */\nexport default function alloc (byteArray, length) {\n  if (typeof Buffer !== 'undefined' && byteArray instanceof Buffer) {\n    return Buffer.alloc(length);\n  } else if (byteArray instanceof Uint8Array) {\n    return new Uint8Array(length);\n  }\n  throw 'dicomParser.alloc: unknown type for byteArray';\n}\n","export default '1.8.12';\n","/**\n * Internal helper functions for parsing different types from a big-endian byte array\n */\nexport default {\n\n  /**\n     *\n     * Parses an unsigned int 16 from a big-endian byte array\n     *\n     * @param byteArray the byte array to read from\n     * @param position the position in the byte array to read from\n     * @returns {*} the parsed unsigned int 16\n     * @throws error if buffer overread would occur\n     * @access private\n     */\n  readUint16 (byteArray, position) {\n    if (position < 0) {\n      throw 'bigEndianByteArrayParser.readUint16: position cannot be less than 0';\n    }\n    if (position + 2 > byteArray.length) {\n      throw 'bigEndianByteArrayParser.readUint16: attempt to read past end of buffer';\n    }\n\n    return (byteArray[position] << 8) + byteArray[position + 1];\n  },\n\n  /**\n     *\n     * Parses a signed int 16 from a big-endian byte array\n     *\n     * @param byteArray the byte array to read from\n     * @param position the position in the byte array to read from\n     * @returns {*} the parsed signed int 16\n     * @throws error if buffer overread would occur\n     * @access private\n     */\n  readInt16 (byteArray, position) {\n    if (position < 0) {\n      throw 'bigEndianByteArrayParser.readInt16: position cannot be less than 0';\n    }\n    if (position + 2 > byteArray.length) {\n      throw 'bigEndianByteArrayParser.readInt16: attempt to read past end of buffer';\n    }\n    var int16 = (byteArray[position] << 8) + byteArray[position + 1];\n    // fix sign\n\n    if (int16 & 0x8000) {\n      int16 = int16 - 0xFFFF - 1;\n    }\n\n    return int16;\n  },\n\n  /**\n     * Parses an unsigned int 32 from a big-endian byte array\n     *\n     * @param byteArray the byte array to read from\n     * @param position the position in the byte array to read from\n     * @returns {*} the parsed unsigned int 32\n     * @throws error if buffer overread would occur\n     * @access private\n     */\n  readUint32 (byteArray, position) {\n    if (position < 0) {\n      throw 'bigEndianByteArrayParser.readUint32: position cannot be less than 0';\n    }\n\n    if (position + 4 > byteArray.length) {\n      throw 'bigEndianByteArrayParser.readUint32: attempt to read past end of buffer';\n    }\n\n    var uint32 = (256 * (256 * (256 * byteArray[position] +\n                                          byteArray[position + 1]) +\n                                          byteArray[position + 2]) +\n                                          byteArray[position + 3]);\n\n    return uint32;\n  },\n\n  /**\n     * Parses a signed int 32 from a big-endian byte array\n     *\n     * @param byteArray the byte array to read from\n     * @param position the position in the byte array to read from\n     * @returns {*} the parsed signed int 32\n     * @throws error if buffer overread would occur\n     * @access private\n     */\n  readInt32 (byteArray, position) {\n    if (position < 0) {\n      throw 'bigEndianByteArrayParser.readInt32: position cannot be less than 0';\n    }\n\n    if (position + 4 > byteArray.length) {\n      throw 'bigEndianByteArrayParser.readInt32: attempt to read past end of buffer';\n    }\n\n    var int32 = ((byteArray[position] << 24) +\n                     (byteArray[position + 1] << 16) +\n                     (byteArray[position + 2] << 8) +\n                      byteArray[position + 3]);\n\n    return int32;\n  },\n\n  /**\n     * Parses 32-bit float from a big-endian byte array\n     *\n     * @param byteArray the byte array to read from\n     * @param position the position in the byte array to read from\n     * @returns {*} the parsed 32-bit float\n     * @throws error if buffer overread would occur\n     * @access private\n     */\n  readFloat (byteArray, position) {\n    if (position < 0) {\n      throw 'bigEndianByteArrayParser.readFloat: position cannot be less than 0';\n    }\n\n    if (position + 4 > byteArray.length) {\n      throw 'bigEndianByteArrayParser.readFloat: attempt to read past end of buffer';\n    }\n\n    // I am sure there is a better way than this but this should be safe\n    var byteArrayForParsingFloat = new Uint8Array(4);\n\n    byteArrayForParsingFloat[3] = byteArray[position];\n    byteArrayForParsingFloat[2] = byteArray[position + 1];\n    byteArrayForParsingFloat[1] = byteArray[position + 2];\n    byteArrayForParsingFloat[0] = byteArray[position + 3];\n    var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);\n\n\n    return floatArray[0];\n  },\n\n  /**\n     * Parses 64-bit float from a big-endian byte array\n     *\n     * @param byteArray the byte array to read from\n     * @param position the position in the byte array to read from\n     * @returns {*} the parsed 64-bit float\n     * @throws error if buffer overread would occur\n     * @access private\n     */\n  readDouble (byteArray, position) {\n    if (position < 0) {\n      throw 'bigEndianByteArrayParser.readDouble: position cannot be less than 0';\n    }\n\n    if (position + 8 > byteArray.length) {\n      throw 'bigEndianByteArrayParser.readDouble: attempt to read past end of buffer';\n    }\n\n    // I am sure there is a better way than this but this should be safe\n    var byteArrayForParsingFloat = new Uint8Array(8);\n\n    byteArrayForParsingFloat[7] = byteArray[position];\n    byteArrayForParsingFloat[6] = byteArray[position + 1];\n    byteArrayForParsingFloat[5] = byteArray[position + 2];\n    byteArrayForParsingFloat[4] = byteArray[position + 3];\n    byteArrayForParsingFloat[3] = byteArray[position + 4];\n    byteArrayForParsingFloat[2] = byteArray[position + 5];\n    byteArrayForParsingFloat[1] = byteArray[position + 6];\n    byteArrayForParsingFloat[0] = byteArray[position + 7];\n    var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);\n\n\n    return floatArray[0];\n  }\n};\n","/**\n *\n * Internal helper function to create a shared copy of a byteArray\n *\n */\n\n/**\n * Creates a view of the underlying byteArray.  The view is of the same type as the byteArray (e.g.\n * Uint8Array or Buffer) and shares the same underlying memory (changing one changes the other)\n * @param byteArray the underlying byteArray (either Uint8Array or Buffer)\n * @param byteOffset offset into the underlying byteArray to create the view of\n * @param length number of bytes in the view\n * @returns {object} Uint8Array or Buffer depending on the type of byteArray\n */\nexport default function sharedCopy (byteArray, byteOffset, length) {\n  if (typeof Buffer !== 'undefined' && byteArray instanceof Buffer) {\n    return byteArray.slice(byteOffset, byteOffset + length);\n  } else if (byteArray instanceof Uint8Array) {\n    return new Uint8Array(byteArray.buffer, byteArray.byteOffset + byteOffset, length);\n  }\n  throw 'dicomParser.from: unknown type for byteArray';\n}\n","import sharedCopy from './sharedCopy.js';\nimport { readFixedString } from './byteArrayParser.js';\n\n/**\n *\n * Internal helper class to assist with parsing. Supports reading from a byte\n * stream contained in a Uint8Array.  Example usage:\n *\n *  var byteArray = new Uint8Array(32);\n *  var byteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);\n *\n * */\n\n/**\n * Constructor for ByteStream objects.\n * @param byteArrayParser a parser for parsing the byte array\n * @param byteArray a Uint8Array containing the byte stream\n * @param position (optional) the position to start reading from.  0 if not specified\n * @constructor\n * @throws will throw an error if the byteArrayParser parameter is not present\n * @throws will throw an error if the byteArray parameter is not present or invalid\n * @throws will throw an error if the position parameter is not inside the byte array\n */\nexport default class ByteStream {\n  constructor (byteArrayParser, byteArray, position) {\n    if (byteArrayParser === undefined) {\n      throw 'dicomParser.ByteStream: missing required parameter \\'byteArrayParser\\'';\n    }\n    if (byteArray === undefined) {\n      throw 'dicomParser.ByteStream: missing required parameter \\'byteArray\\'';\n    }\n    if ((byteArray instanceof Uint8Array) === false &&\n          ((typeof Buffer === 'undefined') ||\n          (byteArray instanceof Buffer) === false)) {\n      throw 'dicomParser.ByteStream: parameter byteArray is not of type Uint8Array or Buffer';\n    }\n    if (position < 0) {\n      throw 'dicomParser.ByteStream: parameter \\'position\\' cannot be less than 0';\n    }\n    if (position >= byteArray.length) {\n      throw 'dicomParser.ByteStream: parameter \\'position\\' cannot be greater than or equal to \\'byteArray\\' length';\n    }\n    this.byteArrayParser = byteArrayParser;\n    this.byteArray = byteArray;\n    this.position = position ? position : 0;\n    this.warnings = []; // array of string warnings encountered while parsing\n  }\n\n  /**\n     * Safely seeks through the byte stream.  Will throw an exception if an attempt\n     * is made to seek outside of the byte array.\n     * @param offset the number of bytes to add to the position\n     * @throws error if seek would cause position to be outside of the byteArray\n     */\n  seek (offset) {\n    if (this.position + offset < 0) {\n      throw 'dicomParser.ByteStream.prototype.seek: cannot seek to position < 0';\n    }\n    this.position += offset;\n  }\n\n  /**\n     * Returns a new ByteStream object from the current position and of the requested number of bytes\n     * @param numBytes the length of the byte array for the ByteStream to contain\n     * @returns {dicomParser.ByteStream}\n     * @throws error if buffer overread would occur\n     */\n  readByteStream (numBytes) {\n    if (this.position + numBytes > this.byteArray.length) {\n      throw 'dicomParser.ByteStream.prototype.readByteStream: readByteStream - buffer overread';\n    }\n    var byteArrayView = sharedCopy(this.byteArray, this.position, numBytes);\n\n    this.position += numBytes;\n\n    return new ByteStream(this.byteArrayParser, byteArrayView);\n  }\n\n  getSize() {\n    return this.byteArray.length;\n  }\n\n  /**\n     *\n     * Parses an unsigned int 16 from a byte array and advances\n     * the position by 2 bytes\n     *\n     * @returns {*} the parsed unsigned int 16\n     * @throws error if buffer overread would occur\n     */\n  readUint16 () {\n    var result = this.byteArrayParser.readUint16(this.byteArray, this.position);\n\n    this.position += 2;\n\n    return result;\n  }\n\n  /**\n     * Parses an unsigned int 32 from a byte array and advances\n     * the position by 2 bytes\n     *\n     * @returns {*} the parse unsigned int 32\n     * @throws error if buffer overread would occur\n     */\n  readUint32 () {\n    var result = this.byteArrayParser.readUint32(this.byteArray, this.position);\n\n    this.position += 4;\n\n    return result;\n  }\n\n  /**\n     * Reads a string of 8-bit characters from an array of bytes and advances\n     * the position by length bytes.  A null terminator will end the string\n     * but will not effect advancement of the position.\n     * @param length the maximum number of bytes to parse\n     * @returns {string} the parsed string\n     * @throws error if buffer overread would occur\n     */\n  readFixedString (length) {\n    var result = readFixedString(this.byteArray, this.position, length);\n\n    this.position += length;\n\n    return result;\n  }\n}\n","/**\n * Internal helper functions for parsing different types from a little-endian byte array\n */\n\nexport default {\n\n  /**\n   *\n   * Parses an unsigned int 16 from a little-endian byte array\n   *\n   * @param byteArray the byte array to read from\n   * @param position the position in the byte array to read from\n   * @returns {*} the parsed unsigned int 16\n   * @throws error if buffer overread would occur\n   * @access private\n   */\n  readUint16 (byteArray, position) {\n    if (position < 0) {\n      throw 'littleEndianByteArrayParser.readUint16: position cannot be less than 0';\n    }\n\n    if (position + 2 > byteArray.length) {\n      throw 'littleEndianByteArrayParser.readUint16: attempt to read past end of buffer';\n    }\n\n    return byteArray[position] + (byteArray[position + 1] * 256);\n  },\n\n  /**\n   *\n   * Parses a signed int 16 from a little-endian byte array\n   *\n   * @param byteArray the byte array to read from\n   * @param position the position in the byte array to read from\n   * @returns {*} the parsed signed int 16\n   * @throws error if buffer overread would occur\n   * @access private\n   */\n  readInt16 (byteArray, position) {\n    if (position < 0) {\n      throw 'littleEndianByteArrayParser.readInt16: position cannot be less than 0';\n    }\n    if (position + 2 > byteArray.length) {\n      throw 'littleEndianByteArrayParser.readInt16: attempt to read past end of buffer';\n    }\n\n    let int16 = byteArray[position] + (byteArray[position + 1] << 8);\n\n    // fix sign\n    if (int16 & 0x8000) {\n      int16 = int16 - 0xFFFF - 1;\n    }\n\n    return int16;\n  },\n\n\n  /**\n   * Parses an unsigned int 32 from a little-endian byte array\n   *\n   * @param byteArray the byte array to read from\n   * @param position the position in the byte array to read from\n   * @returns {*} the parsed unsigned int 32\n   * @throws error if buffer overread would occur\n   * @access private\n   */\n  readUint32 (byteArray, position) {\n    if (position < 0) {\n      throw 'littleEndianByteArrayParser.readUint32: position cannot be less than 0';\n    }\n\n    if (position + 4 > byteArray.length) {\n      throw 'littleEndianByteArrayParser.readUint32: attempt to read past end of buffer';\n    }\n\n    return (byteArray[position] +\n           (byteArray[position + 1] * 256) +\n           (byteArray[position + 2] * 256 * 256) +\n           (byteArray[position + 3] * 256 * 256 * 256));\n  },\n\n  /**\n * Parses a signed int 32 from a little-endian byte array\n *\n * @param byteArray the byte array to read from\n * @param position the position in the byte array to read from\n   * @returns {*} the parsed unsigned int 32\n   * @throws error if buffer overread would occur\n   * @access private\n   */\n  readInt32 (byteArray, position) {\n    if (position < 0) {\n      throw 'littleEndianByteArrayParser.readInt32: position cannot be less than 0';\n    }\n\n    if (position + 4 > byteArray.length) {\n      throw 'littleEndianByteArrayParser.readInt32: attempt to read past end of buffer';\n    }\n\n    return (byteArray[position] +\n           (byteArray[position + 1] << 8) +\n           (byteArray[position + 2] << 16) +\n           (byteArray[position + 3] << 24));\n  },\n\n  /**\n   * Parses 32-bit float from a little-endian byte array\n   *\n   * @param byteArray the byte array to read from\n   * @param position the position in the byte array to read from\n   * @returns {*} the parsed 32-bit float\n   * @throws error if buffer overread would occur\n   * @access private\n   */\n  readFloat (byteArray, position) {\n    if (position < 0) {\n      throw 'littleEndianByteArrayParser.readFloat: position cannot be less than 0';\n    }\n\n    if (position + 4 > byteArray.length) {\n      throw 'littleEndianByteArrayParser.readFloat: attempt to read past end of buffer';\n    }\n\n    // I am sure there is a better way than this but this should be safe\n    const byteArrayForParsingFloat = new Uint8Array(4);\n\n    byteArrayForParsingFloat[0] = byteArray[position];\n    byteArrayForParsingFloat[1] = byteArray[position + 1];\n    byteArrayForParsingFloat[2] = byteArray[position + 2];\n    byteArrayForParsingFloat[3] = byteArray[position + 3];\n\n    const floatArray = new Float32Array(byteArrayForParsingFloat.buffer);\n\n    return floatArray[0];\n  },\n\n  /**\n   * Parses 64-bit float from a little-endian byte array\n   *\n   * @param byteArray the byte array to read from\n   * @param position the position in the byte array to read from\n   * @returns {*} the parsed 64-bit float\n   * @throws error if buffer overread would occur\n   * @access private\n   */\n  readDouble (byteArray, position) {\n    if (position < 0) {\n      throw 'littleEndianByteArrayParser.readDouble: position cannot be less than 0';\n    }\n\n    if (position + 8 > byteArray.length) {\n      throw 'littleEndianByteArrayParser.readDouble: attempt to read past end of buffer';\n    }\n\n    // I am sure there is a better way than this but this should be safe\n    const byteArrayForParsingFloat = new Uint8Array(8);\n\n    byteArrayForParsingFloat[0] = byteArray[position];\n    byteArrayForParsingFloat[1] = byteArray[position + 1];\n    byteArrayForParsingFloat[2] = byteArray[position + 2];\n    byteArrayForParsingFloat[3] = byteArray[position + 3];\n    byteArrayForParsingFloat[4] = byteArray[position + 4];\n    byteArrayForParsingFloat[5] = byteArray[position + 5];\n    byteArrayForParsingFloat[6] = byteArray[position + 6];\n    byteArrayForParsingFloat[7] = byteArray[position + 7];\n\n    const floatArray = new Float64Array(byteArrayForParsingFloat.buffer);\n\n    return floatArray[0];\n  }\n};\n","import ByteStream from './byteStream.js';\nimport DataSet from './dataSet.js';\nimport littleEndianByteArrayParser from './littleEndianByteArrayParser.js';\nimport readDicomElementExplicit from './readDicomElementExplicit.js';\n\n/**\n * Parses a DICOM P10 byte array and returns a DataSet object with the parsed elements.  If the options\n * argument is supplied and it contains the untilTag property, parsing will stop once that\n * tag is encoutered.  This can be used to parse partial byte streams.\n *\n * @param byteArray the byte array\n * @param options Optional options values\n *    TransferSyntaxUID: String to specify a default raw transfer syntax UID.\n *        Use the LEI transfer syntax for raw files, or the provided one for SCP transfers.\n * @returns {DataSet}\n * @throws error if an error occurs while parsing.  The exception object will contain a property dataSet with the\n *         elements successfully parsed before the error.\n */\n\nexport default function readPart10Header (byteArray, options = {}) {\n  if (byteArray === undefined) {\n    throw 'dicomParser.readPart10Header: missing required parameter \\'byteArray\\'';\n  }\n\n  const { TransferSyntaxUID } = options;\n  const littleEndianByteStream = new ByteStream(littleEndianByteArrayParser, byteArray);\n\n  function readPrefix() {\n    if (littleEndianByteStream.getSize() <= 132 && TransferSyntaxUID) {\n      return false;\n    }\n    littleEndianByteStream.seek(128);\n    const prefix = littleEndianByteStream.readFixedString(4);\n\n    if (prefix !== 'DICM') {\n      const { TransferSyntaxUID } = options || {};\n      if (!TransferSyntaxUID) {\n        throw 'dicomParser.readPart10Header: DICM prefix not found at location 132 - this is not a valid DICOM P10 file.';\n      }\n      littleEndianByteStream.seek(0);\n      return false;\n    }\n    return true;\n  }\n\n  // main function here\n  function readTheHeader() {\n    // Per the DICOM standard, the header is always encoded in Explicit VR Little Endian (see PS3.10, section 7.1)\n    // so use littleEndianByteStream throughout this method regardless of the transfer syntax\n    const isPart10 = readPrefix();\n\n    const warnings = [];\n    const elements = {};\n\n    if (!isPart10) {\n      littleEndianByteStream.position = 0;\n      const metaHeaderDataSet = {\n        elements: { x00020010: { tag: 'x00020010', vr: 'UI', Value: TransferSyntaxUID } },\n        warnings,\n      };\n      // console.log('Returning metaHeaderDataSet', metaHeaderDataSet);\n      return metaHeaderDataSet;\n    }\n\n    while (littleEndianByteStream.position < littleEndianByteStream.byteArray.length) {\n      const position = littleEndianByteStream.position;\n      const element = readDicomElementExplicit(littleEndianByteStream, warnings);\n\n      if (element.tag > 'x0002ffff') {\n        littleEndianByteStream.position = position;\n        break;\n      }\n      // Cache the littleEndianByteArrayParser for meta header elements, since the rest of the data set may be big endian\n      // and this parser will be needed later if the meta header values are to be read.\n      element.parser = littleEndianByteArrayParser;\n      elements[element.tag] = element;\n    }\n\n    const metaHeaderDataSet = new DataSet(littleEndianByteStream.byteArrayParser, littleEndianByteStream.byteArray, elements);\n\n    metaHeaderDataSet.warnings = littleEndianByteStream.warnings;\n    metaHeaderDataSet.position = littleEndianByteStream.position;\n\n    return metaHeaderDataSet;\n  }\n\n  // This is where we actually start parsing\n  return readTheHeader();\n}\n","import alloc from './alloc.js';\nimport bigEndianByteArrayParser from './bigEndianByteArrayParser.js';\nimport ByteStream from './byteStream.js';\nimport DataSet from './dataSet.js';\nimport littleEndianByteArrayParser from './littleEndianByteArrayParser.js';\nimport readPart10Header from './readPart10Header.js';\nimport sharedCopy from './sharedCopy.js';\nimport * as byteArrayParser from './byteArrayParser.js';\nimport * as parseDicomDataSet from './parseDicomDataSet.js';\n\n// LEE (Little Endian Explicit) is the transfer syntax used in dimse operations when there is a split\n// between the header and data.\nconst LEE = '1.2.840.10008.1.2.1';\n\n// LEI (Little Endian Implicit) is the transfer syntax in raw files\nconst LEI = '1.2.840.10008.1.2';\n\n// BEI (Big Endian Implicit) is deprecated, but needs special parse handling\nconst BEI = '1.2.840.10008.1.2.2';\n\n/**\n * Parses a DICOM P10 byte array and returns a DataSet object with the parsed elements.\n * If the options argument is supplied and it contains the untilTag property, parsing\n * will stop once that tag is encoutered.  This can be used to parse partial byte streams.\n *\n * @param byteArray the byte array\n * @param options object to control parsing behavior (optional)\n * @returns {DataSet}\n * @throws error if an error occurs while parsing.  The exception object will contain a\n *         property dataSet with the elements successfully parsed before the error.\n */\n\nexport default function parseDicom(byteArray, options = {}) {\n  if (byteArray === undefined) {\n    throw new Error('dicomParser.parseDicom: missing required parameter \\'byteArray\\'');\n  }\n\n  \n  const readTransferSyntax = (metaHeaderDataSet) => {\n    if (metaHeaderDataSet.elements.x00020010 === undefined) {\n      throw new Error('dicomParser.parseDicom: missing required meta header attribute 0002,0010');\n    }\n\n    const transferSyntaxElement = metaHeaderDataSet.elements.x00020010;\n    return transferSyntaxElement && transferSyntaxElement.Value ||\n      byteArrayParser.readFixedString(byteArray, transferSyntaxElement.dataOffset, transferSyntaxElement.length);\n  }\n\n  function isExplicit(transferSyntax) {\n    // implicit little endian\n    if (transferSyntax === '1.2.840.10008.1.2') {\n      return false;\n    }\n\n    // all other transfer syntaxes should be explicit\n    return true;\n  }\n\n  function getDataSetByteStream(transferSyntax, position) {\n    // Detect whether we are inside a browser or Node.js\n    const isNode = (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]');\n\n    if (transferSyntax === '1.2.840.10008.1.2.1.99') {\n      // if an infalter callback is registered, use it\n      if (options && options.inflater) {\n        const fullByteArrayCallback = options.inflater(byteArray, position);\n\n        return new ByteStream(littleEndianByteArrayParser, fullByteArrayCallback, 0);\n      }\n      // if running on node, use the zlib library to inflate\n      // http://stackoverflow.com/questions/4224606/how-to-check-whether-a-script-is-running-under-node-js\n      else if (isNode === true) {\n        // inflate it\n        const zlib = require('zlib');\n        const deflatedBuffer = sharedCopy(byteArray, position, byteArray.length - position);\n        const inflatedBuffer = zlib.inflateRawSync(deflatedBuffer);\n\n        // create a single byte array with the full header bytes and the inflated bytes\n        const fullByteArrayBuffer = alloc(byteArray, inflatedBuffer.length + position);\n\n        byteArray.copy(fullByteArrayBuffer, 0, 0, position);\n        inflatedBuffer.copy(fullByteArrayBuffer, position);\n\n        return new ByteStream(littleEndianByteArrayParser, fullByteArrayBuffer, 0);\n      }\n      // if pako is defined - use it.  This is the web browser path\n      // https://github.com/nodeca/pako\n      else if (typeof pako !== 'undefined') {\n        // inflate it\n        const deflated = byteArray.slice(position);\n        const inflated = pako.inflateRaw(deflated);\n\n        // create a single byte array with the full header bytes and the inflated bytes\n        const fullByteArray = alloc(byteArray, inflated.length + position);\n\n        fullByteArray.set(byteArray.slice(0, position), 0);\n        fullByteArray.set(inflated, position);\n\n        return new ByteStream(littleEndianByteArrayParser, fullByteArray, 0);\n      }\n\n      // throw exception since no inflater is available\n      throw 'dicomParser.parseDicom: no inflater available to handle deflate transfer syntax';\n    }\n\n    // explicit big endian\n    if (transferSyntax === BEI) {\n      return new ByteStream(bigEndianByteArrayParser, byteArray, position);\n    }\n\n    // all other transfer syntaxes are little endian; only the pixel encoding differs\n    // make a new stream so the metaheader warnings don't come along for the ride\n    return new ByteStream(littleEndianByteArrayParser, byteArray, position);\n  }\n\n  function mergeDataSets(metaHeaderDataSet, instanceDataSet) {\n    for (const propertyName in metaHeaderDataSet.elements) {\n      if (metaHeaderDataSet.elements.hasOwnProperty(propertyName)) {\n        instanceDataSet.elements[propertyName] = metaHeaderDataSet.elements[propertyName];\n      }\n    }\n\n    if (metaHeaderDataSet.warnings !== undefined) {\n      instanceDataSet.warnings = metaHeaderDataSet.warnings.concat(instanceDataSet.warnings);\n    }\n\n    return instanceDataSet;\n  }\n\n  function readDataSet(metaHeaderDataSet) {\n    const transferSyntax = readTransferSyntax(metaHeaderDataSet);\n    const explicit = isExplicit(transferSyntax);\n    const dataSetByteStream = getDataSetByteStream(transferSyntax, metaHeaderDataSet.position);\n\n    const elements = {};\n    const dataSet = new DataSet(dataSetByteStream.byteArrayParser, dataSetByteStream.byteArray, elements);\n\n    dataSet.warnings = dataSetByteStream.warnings;\n\n    try {\n      if (explicit) {\n        parseDicomDataSet.parseDicomDataSetExplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);\n      } else {\n        parseDicomDataSet.parseDicomDataSetImplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);\n      }\n    } catch (e) {\n      const ex = {\n        exception: e,\n        dataSet\n      };\n\n      throw ex;\n    }\n\n    return dataSet;\n  }\n\n  // main function here\n  function parseTheByteStream() {\n    const metaHeaderDataSet = readPart10Header(byteArray, options);\n    const dataSet = readDataSet(metaHeaderDataSet);\n\n    return mergeDataSets(metaHeaderDataSet, dataSet);\n  }\n\n  // This is where we actually start parsing\n  return parseTheByteStream();\n}\n\nexport { LEI, LEE, BEI };","import alloc from './alloc.js';\nimport ByteStream from './byteStream.js';\nimport readSequenceItem from './readSequenceItem.js';\nimport sharedCopy from './sharedCopy.js';\n\n/**\n * Functionality for extracting encapsulated pixel data\n */\n\nconst calculateBufferSize = (fragments, startFragment, numFragments) => {\n  let bufferSize = 0;\n\n  for (let i = startFragment; i < startFragment + numFragments; i++) {\n    bufferSize += fragments[i].length;\n  }\n\n  return bufferSize;\n};\n\n/**\n * Returns the encapsulated pixel data from the specified fragments.  Use this function when you know\n * the fragments you want to extract data from.  See\n *\n * @param dataSet - the dataSet containing the encapsulated pixel data\n * @param pixelDataElement - the pixel data element (x7fe00010) to extract the fragment data from\n * @param startFragmentIndex - zero based index of the first fragment to extract from\n * @param [numFragments] - the number of fragments to extract from, default is 1\n * @param [fragments] - optional array of objects describing each fragment (offset, position, length)\n * @returns {object} byte array with the encapsulated pixel data\n */\nexport default function readEncapsulatedPixelDataFromFragments (dataSet, pixelDataElement, startFragmentIndex, numFragments, fragments) {\n  // default values\n  numFragments = numFragments || 1;\n  fragments = fragments || pixelDataElement.fragments;\n\n  // check parameters\n  if (dataSet === undefined) {\n    throw 'dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter \\'dataSet\\'';\n  }\n  if (pixelDataElement === undefined) {\n    throw 'dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter \\'pixelDataElement\\'';\n  }\n  if (startFragmentIndex === undefined) {\n    throw 'dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter \\'startFragmentIndex\\'';\n  }\n  if (numFragments === undefined) {\n    throw 'dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter \\'numFragments\\'';\n  }\n  if (pixelDataElement.tag !== 'x7fe00010') {\n    throw 'dicomParser.readEncapsulatedPixelDataFromFragments: parameter \\'pixelDataElement\\' refers to non pixel data tag (expected tag = x7fe00010';\n  }\n  if (pixelDataElement.encapsulatedPixelData !== true) {\n    throw 'dicomParser.readEncapsulatedPixelDataFromFragments: parameter \\'pixelDataElement\\' refers to pixel data element that does not have encapsulated pixel data';\n  }\n  if (pixelDataElement.hadUndefinedLength !== true) {\n    throw 'dicomParser.readEncapsulatedPixelDataFromFragments: parameter \\'pixelDataElement\\' refers to pixel data element that does not have encapsulated pixel data';\n  }\n  if (pixelDataElement.basicOffsetTable === undefined) {\n    throw 'dicomParser.readEncapsulatedPixelDataFromFragments: parameter \\'pixelDataElement\\' refers to pixel data element that does not have encapsulated pixel data';\n  }\n  if (pixelDataElement.fragments === undefined) {\n    throw 'dicomParser.readEncapsulatedPixelDataFromFragments: parameter \\'pixelDataElement\\' refers to pixel data element that does not have encapsulated pixel data';\n  }\n  if (pixelDataElement.fragments.length <= 0) {\n    throw 'dicomParser.readEncapsulatedPixelDataFromFragments: parameter \\'pixelDataElement\\' refers to pixel data element that does not have encapsulated pixel data';\n  }\n  if (startFragmentIndex < 0) {\n    throw 'dicomParser.readEncapsulatedPixelDataFromFragments: parameter \\'startFragmentIndex\\' must be >= 0';\n  }\n  if (startFragmentIndex >= pixelDataElement.fragments.length) {\n    throw 'dicomParser.readEncapsulatedPixelDataFromFragments: parameter \\'startFragmentIndex\\' must be < number of fragments';\n  }\n  if (numFragments < 1) {\n    throw 'dicomParser.readEncapsulatedPixelDataFromFragments: parameter \\'numFragments\\' must be > 0';\n  }\n  if (startFragmentIndex + numFragments > pixelDataElement.fragments.length) {\n    throw 'dicomParser.readEncapsulatedPixelDataFromFragments: parameter \\'startFragment\\' + \\'numFragments\\' < number of fragments';\n  }\n\n  // create byte stream on the data for this pixel data element\n  const byteStream = new ByteStream(dataSet.byteArrayParser, dataSet.byteArray, pixelDataElement.dataOffset);\n\n  // seek past the basic offset table (no need to parse it again since we already have)\n  const basicOffsetTable = readSequenceItem(byteStream);\n\n  if (basicOffsetTable.tag !== 'xfffee000') {\n    throw 'dicomParser.readEncapsulatedPixelData: missing basic offset table xfffee000';\n  }\n\n  byteStream.seek(basicOffsetTable.length);\n\n  const fragmentZeroPosition = byteStream.position;\n\n  // tag + length\n  const fragmentHeaderSize = 8;\n\n  // if there is only one fragment, return a view on this array to avoid copying\n  if (numFragments === 1) {\n    return sharedCopy(byteStream.byteArray, fragmentZeroPosition + fragments[startFragmentIndex].offset + fragmentHeaderSize, fragments[startFragmentIndex].length);\n  }\n\n  // more than one fragment, combine all of the fragments into one buffer\n  const bufferSize = calculateBufferSize(fragments, startFragmentIndex, numFragments);\n  const pixelData = alloc(byteStream.byteArray, bufferSize);\n  let pixelDataIndex = 0;\n\n  for (let i = startFragmentIndex; i < startFragmentIndex + numFragments; i++) {\n    let fragmentOffset = fragmentZeroPosition + fragments[i].offset + fragmentHeaderSize;\n\n    for (let j = 0; j < fragments[i].length; j++) {\n      pixelData[pixelDataIndex++] = byteStream.byteArray[fragmentOffset++];\n    }\n  }\n\n  return pixelData;\n}\n","import readEncapsulatedPixelDataFromFragments from './readEncapsulatedPixelDataFromFragments.js';\n\n/**\n * Functionality for extracting encapsulated pixel data\n */\n\nconst findFragmentIndexWithOffset = (fragments, offset) => {\n  for (let i = 0; i < fragments.length; i++) {\n    if (fragments[i].offset === offset) {\n      return i;\n    }\n  }\n};\n\nconst calculateNumberOfFragmentsForFrame = (frameIndex, basicOffsetTable, fragments, startFragmentIndex) => {\n  // special case for last frame\n  if (frameIndex === basicOffsetTable.length - 1) {\n    return fragments.length - startFragmentIndex;\n  }\n\n  // iterate through each fragment looking for the one matching the offset for the next frame\n  const nextFrameOffset = basicOffsetTable[frameIndex + 1];\n\n  for (let i = startFragmentIndex + 1; i < fragments.length; i++) {\n    if (fragments[i].offset === nextFrameOffset) {\n      return i - startFragmentIndex;\n    }\n  }\n\n  throw 'dicomParser.calculateNumberOfFragmentsForFrame: could not find fragment with offset matching basic offset table';\n};\n\n/**\n * Returns the pixel data for the specified frame in an encapsulated pixel data element that has a non\n * empty basic offset table.  Note that this function will fail if the basic offset table is empty - in that\n * case you need to determine which fragments map to which frames and read them using\n * readEncapsulatedPixelDataFromFragments().  Also see the function createJEPGBasicOffsetTable() to see\n * how a basic offset table can be created for JPEG images\n *\n * @param dataSet - the dataSet containing the encapsulated pixel data\n * @param pixelDataElement - the pixel data element (x7fe00010) to extract the frame from\n * @param frameIndex - the zero based frame index\n * @param [basicOffsetTable] - optional array of starting offsets for frames\n * @param [fragments] - optional array of objects describing each fragment (offset, position, length)\n * @returns {object} with the encapsulated pixel data\n */\nexport default function readEncapsulatedImageFrame (dataSet, pixelDataElement, frameIndex, basicOffsetTable, fragments) {\n  // default parameters\n  basicOffsetTable = basicOffsetTable || pixelDataElement.basicOffsetTable;\n  fragments = fragments || pixelDataElement.fragments;\n\n  // Validate parameters\n  if (dataSet === undefined) {\n    throw 'dicomParser.readEncapsulatedImageFrame: missing required parameter \\'dataSet\\'';\n  }\n  if (pixelDataElement === undefined) {\n    throw 'dicomParser.readEncapsulatedImageFrame: missing required parameter \\'pixelDataElement\\'';\n  }\n  if (frameIndex === undefined) {\n    throw 'dicomParser.readEncapsulatedImageFrame: missing required parameter \\'frameIndex\\'';\n  }\n  if (basicOffsetTable === undefined) {\n    throw 'dicomParser.readEncapsulatedImageFrame: parameter \\'pixelDataElement\\' does not have basicOffsetTable';\n  }\n  if (pixelDataElement.tag !== 'x7fe00010') {\n    throw 'dicomParser.readEncapsulatedImageFrame: parameter \\'pixelDataElement\\' refers to non pixel data tag (expected tag = x7fe00010)';\n  }\n  if (pixelDataElement.encapsulatedPixelData !== true) {\n    throw 'dicomParser.readEncapsulatedImageFrame: parameter \\'pixelDataElement\\' refers to pixel data element that does not have encapsulated pixel data';\n  }\n  if (pixelDataElement.hadUndefinedLength !== true) {\n    throw 'dicomParser.readEncapsulatedImageFrame: parameter \\'pixelDataElement\\' refers to pixel data element that does not have undefined length';\n  }\n  if (pixelDataElement.fragments === undefined) {\n    throw 'dicomParser.readEncapsulatedImageFrame: parameter \\'pixelDataElement\\' refers to pixel data element that does not have fragments';\n  }\n  if (basicOffsetTable.length === 0) {\n    throw 'dicomParser.readEncapsulatedImageFrame: basicOffsetTable has zero entries';\n  }\n  if (frameIndex < 0) {\n    throw 'dicomParser.readEncapsulatedImageFrame: parameter \\'frameIndex\\' must be >= 0';\n  }\n  if (frameIndex >= basicOffsetTable.length) {\n    throw 'dicomParser.readEncapsulatedImageFrame: parameter \\'frameIndex\\' must be < basicOffsetTable.length';\n  }\n\n  // find starting fragment based on the offset for the frame in the basic offset table\n  const offset = basicOffsetTable[frameIndex];\n  const startFragmentIndex = findFragmentIndexWithOffset(fragments, offset);\n\n  if (startFragmentIndex === undefined) {\n    throw 'dicomParser.readEncapsulatedImageFrame: unable to find fragment that matches basic offset table entry';\n  }\n\n  // calculate the number of fragments for this frame\n  const numFragments = calculateNumberOfFragmentsForFrame(frameIndex, basicOffsetTable, fragments, startFragmentIndex);\n\n  // now extract the frame from the fragments\n  return readEncapsulatedPixelDataFromFragments(dataSet, pixelDataElement, startFragmentIndex, numFragments, fragments);\n}\n","import readEncapsulatedImageFrame from './readEncapsulatedImageFrame.js';\nimport readEncapsulatedPixelDataFromFragments from './readEncapsulatedPixelDataFromFragments.js';\n\n/**\n * Functionality for extracting encapsulated pixel data\n */\n\nlet deprecatedNoticeLogged = false;\n\n/**\n * Returns the pixel data for the specified frame in an encapsulated pixel data element.  If no basic offset\n * table is present, it assumes that all fragments are for one frame.  Note that this assumption/logic is not\n * valid for multi-frame instances so this function has been deprecated and will eventually be removed.  Code\n * should be updated to use readEncapsulatedPixelDataFromFragments() or readEncapsulatedImageFrame()\n *\n * @deprecated since version 1.6 - use readEncapsulatedPixelDataFromFragments() or readEncapsulatedImageFrame()\n * @param dataSet - the dataSet containing the encapsulated pixel data\n * @param pixelDataElement - the pixel data element (x7fe00010) to extract the frame from\n * @param frame - the zero based frame index\n * @returns {object} with the encapsulated pixel data\n */\nexport default function readEncapsulatedPixelData (dataSet, pixelDataElement, frame) {\n  if (!deprecatedNoticeLogged) {\n    deprecatedNoticeLogged = true;\n\n    if (console && console.log) {\n      console.log('WARNING: dicomParser.readEncapsulatedPixelData() has been deprecated');\n    }\n  }\n\n  if (dataSet === undefined) {\n    throw 'dicomParser.readEncapsulatedPixelData: missing required parameter \\'dataSet\\'';\n  }\n  if (pixelDataElement === undefined) {\n    throw 'dicomParser.readEncapsulatedPixelData: missing required parameter \\'element\\'';\n  }\n  if (frame === undefined) {\n    throw 'dicomParser.readEncapsulatedPixelData: missing required parameter \\'frame\\'';\n  }\n  if (pixelDataElement.tag !== 'x7fe00010') {\n    throw 'dicomParser.readEncapsulatedPixelData: parameter \\'element\\' refers to non pixel data tag (expected tag = x7fe00010)';\n  }\n  if (pixelDataElement.encapsulatedPixelData !== true) {\n    throw 'dicomParser.readEncapsulatedPixelData: parameter \\'element\\' refers to pixel data element that does not have encapsulated pixel data';\n  }\n  if (pixelDataElement.hadUndefinedLength !== true) {\n    throw 'dicomParser.readEncapsulatedPixelData: parameter \\'element\\' refers to pixel data element that does not have encapsulated pixel data';\n  }\n  if (pixelDataElement.basicOffsetTable === undefined) {\n    throw 'dicomParser.readEncapsulatedPixelData: parameter \\'element\\' refers to pixel data element that does not have encapsulated pixel data';\n  }\n  if (pixelDataElement.fragments === undefined) {\n    throw 'dicomParser.readEncapsulatedPixelData: parameter \\'element\\' refers to pixel data element that does not have encapsulated pixel data';\n  }\n  if (frame < 0) {\n    throw 'dicomParser.readEncapsulatedPixelData: parameter \\'frame\\' must be >= 0';\n  }\n\n  // If the basic offset table is not empty, we can extract the frame\n  if (pixelDataElement.basicOffsetTable.length !== 0) {\n    return readEncapsulatedImageFrame(dataSet, pixelDataElement, frame);\n  }\n\n  // No basic offset table, assume all fragments are for one frame - NOTE that this is NOT a valid\n  // assumption but is the original behavior so we are keeping it for now\n  return readEncapsulatedPixelDataFromFragments(dataSet, pixelDataElement, 0, pixelDataElement.fragments.length);\n}\n","import {\n  isStringVr,\n  isPrivateTag,\n  parsePN,\n  parseTM,\n  parseDA,\n  explicitElementToString,\n  explicitDataSetToJS,\n  createJPEGBasicOffsetTable\n} from './util/index.js';\n\nimport { parseDicomDataSetExplicit, parseDicomDataSetImplicit } from './parseDicomDataSet.js';\nimport { readFixedString } from './byteArrayParser.js';\n\nimport alloc from './alloc.js';\nimport version from './version.js';\nimport bigEndianByteArrayParser from './bigEndianByteArrayParser.js';\nimport ByteStream from './byteStream.js';\nimport sharedCopy from './sharedCopy.js';\nimport DataSet from './dataSet.js';\nimport findAndSetUNElementLength from './findAndSetUNElementLength.js';\nimport findEndOfEncapsulatedElement from './findEndOfEncapsulatedPixelData.js';\nimport findItemDelimitationItemAndSetElementLength from './findItemDelimitationItem.js';\nimport littleEndianByteArrayParser from './littleEndianByteArrayParser.js';\nimport parseDicom, { LEI, LEE } from './parseDicom.js';\nimport readDicomElementExplicit from './readDicomElementExplicit.js';\nimport readDicomElementImplicit from './readDicomElementImplicit.js';\nimport readEncapsulatedImageFrame from './readEncapsulatedImageFrame.js';\nimport readEncapsulatedPixelData from './readEncapsulatedPixelData.js';\nimport readEncapsulatedPixelDataFromFragments from './readEncapsulatedPixelDataFromFragments.js';\nimport readPart10Header from './readPart10Header.js';\nimport readSequenceItemsExplicit from './readSequenceElementExplicit.js';\nimport readSequenceItemsImplicit from './readSequenceElementImplicit.js';\nimport readSequenceItem from './readSequenceItem.js';\nimport readTag from './readTag.js';\n\nconst dicomParser = {\n  isStringVr,\n  isPrivateTag,\n  parsePN,\n  parseTM,\n  parseDA,\n  explicitElementToString,\n  explicitDataSetToJS,\n  createJPEGBasicOffsetTable,\n  parseDicomDataSetExplicit,\n  parseDicomDataSetImplicit,\n  readFixedString,\n  alloc,\n  version,\n  bigEndianByteArrayParser,\n  ByteStream,\n  sharedCopy,\n  DataSet,\n  findAndSetUNElementLength,\n  findEndOfEncapsulatedElement,\n  findItemDelimitationItemAndSetElementLength,\n  littleEndianByteArrayParser,\n  parseDicom,\n  readDicomElementExplicit,\n  readDicomElementImplicit,\n  readEncapsulatedImageFrame,\n  readEncapsulatedPixelData,\n  readEncapsulatedPixelDataFromFragments,\n  readPart10Header,\n  readSequenceItemsExplicit,\n  readSequenceItemsImplicit,\n  readSequenceItem,\n  readTag,\n  LEI,\n  LEE,\n};\n\nexport {\n  isStringVr,\n  isPrivateTag,\n  parsePN,\n  parseTM,\n  parseDA,\n  explicitElementToString,\n  explicitDataSetToJS,\n  createJPEGBasicOffsetTable,\n  parseDicomDataSetExplicit,\n  parseDicomDataSetImplicit,\n  readFixedString,\n  alloc,\n  version,\n  bigEndianByteArrayParser,\n  ByteStream,\n  sharedCopy,\n  DataSet,\n  findAndSetUNElementLength,\n  findEndOfEncapsulatedElement,\n  findItemDelimitationItemAndSetElementLength,\n  littleEndianByteArrayParser,\n  parseDicom,\n  readDicomElementExplicit,\n  readDicomElementImplicit,\n  readEncapsulatedImageFrame,\n  readEncapsulatedPixelData,\n  readEncapsulatedPixelDataFromFragments,\n  readPart10Header,\n  readSequenceItemsExplicit,\n  readSequenceItemsImplicit,\n  readSequenceItem,\n  readTag\n};\n\nexport default dicomParser;\n"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}