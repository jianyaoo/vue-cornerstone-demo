{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { n as newInstance$1, o as obj, d as algo, e as setGet, c as macro, b as newTypedArrayFrom } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nconst {\n  vtkErrorMacro\n} = macro;\nfunction initPolyIterator(pd) {\n  const polys = pd.getPolys().getData();\n  const strips = pd.getStrips().getData();\n  const it = {\n    cellSize: 0,\n    cell: [],\n    done: false,\n    polyIdx: 0,\n    stripIdx: 0,\n    remainingStripLength: 0,\n    // returns a single poly cell\n    next() {\n      if (it.polyIdx < polys.length) {\n        it.cellSize = polys[it.polyIdx];\n        const start = it.polyIdx + 1;\n        const end = start + it.cellSize;\n        it.polyIdx = end;\n        let p = 0;\n        for (let i = start; i < end; ++i) {\n          it.cell[p++] = polys[i];\n        }\n      } else if (it.stripIdx < strips.length) {\n        it.cellSize = 3;\n        if (it.remainingStripLength === 0) {\n          it.remainingStripLength = strips[it.stripIdx] - 2; // sliding window of 3 points\n          // stripIdx points to the last point in a triangle 3-tuple\n          it.stripIdx += 3;\n        }\n        const start = it.stripIdx - 2;\n        const end = it.stripIdx + 1;\n        it.stripIdx++;\n        it.remainingStripLength--;\n        let p = 0;\n        for (let i = start; i < end; ++i) {\n          it.cell[p++] = strips[i];\n        }\n      } else if (!it.done) {\n        it.done = true;\n      } else {\n        throw new Error('Iterator is done');\n      }\n    }\n  };\n  it.next();\n  return it;\n}\n\n// ----------------------------------------------------------------------------\n// vtkCutter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCutter(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCutter');\n\n  // Capture \"parentClass\" api for internal use\n  const superClass = {\n    ...publicAPI\n  };\n  publicAPI.getMTime = () => {\n    let mTime = superClass.getMTime();\n    if (!model.cutFunction) {\n      return mTime;\n    }\n    mTime = Math.max(mTime, model.cutFunction.getMTime());\n    return mTime;\n  };\n  function dataSetCutter(input, output) {\n    const points = input.getPoints();\n    const pointsData = points.getData();\n    const numPts = points.getNumberOfPoints();\n    const newPointsData = [];\n    const newLinesData = [];\n    const newPolysData = [];\n    if (!model.cutScalars || model.cutScalars.length < numPts) {\n      model.cutScalars = new Float32Array(numPts);\n    }\n\n    // Loop over all points evaluating scalar function at each point\n    let inOffset = 0;\n    let outOffset = 0;\n    while (inOffset < pointsData.length) {\n      model.cutScalars[outOffset++] = model.cutFunction.evaluateFunction(pointsData[inOffset++], pointsData[inOffset++], pointsData[inOffset++]);\n    }\n    const crossedEdges = [];\n    const x1 = new Array(3);\n    const x2 = new Array(3);\n    const cellPointsScalars = [];\n\n    // Loop over all cells; get scalar values for all cell points\n    // and process each cell.\n    /* eslint-disable no-continue */\n    for (const it = initPolyIterator(input); !it.done; it.next()) {\n      // cell contains the point IDs/indices\n\n      // Check that cells have at least 3 points\n      if (it.cellSize <= 2) {\n        continue;\n      }\n\n      // Get associated scalar of points that constitute the current cell\n      for (let i = 0; i < it.cellSize;) {\n        cellPointsScalars[i] = model.cutScalars[it.cell[i++]];\n      }\n\n      // Check if all cell points are on same side (same side == cell not crossed by cut function)\n      // TODO: won't work if one point scalar is = 0 ?\n      const sideFirstPoint = cellPointsScalars[0] > 0;\n      let allPointsSameSide = true;\n      for (let i = 1; i < it.cell.length; i++) {\n        const sideCurrentPoint = cellPointsScalars[i] > 0;\n        if (sideCurrentPoint !== sideFirstPoint) {\n          allPointsSameSide = false;\n          break;\n        }\n      }\n\n      // Go to next cell if cell is not crossed by cut function\n      if (allPointsSameSide) {\n        continue;\n      }\n\n      // Find and compute edges which intersect cells\n      const intersectedEdgesList = [];\n      for (let i = 0; i < it.cellSize; i++) {\n        const idNext = i + 1 === it.cellSize ? 0 : i + 1;\n\n        // Go to next edge if edge is not crossed\n        // TODO: in most come cases, (numberOfPointsInCell - 1) or 0 edges of the cell\n        // will be crossed, but if it crosses right at a point, it could be intersecting\n        // with (numberOfPoints) or 1 edge(s). Do we account for that?\n        const signPoint0 = cellPointsScalars[i] > 0;\n        const signPoint1 = cellPointsScalars[idNext] > 0;\n        if (signPoint1 === signPoint0) {\n          continue;\n        }\n\n        // Compute preferred interpolation direction\n        let e1 = i;\n        let e2 = idNext;\n        let deltaScalar = cellPointsScalars[e2] - cellPointsScalars[e1];\n        if (deltaScalar <= 0) {\n          e1 = idNext;\n          e2 = i;\n          deltaScalar *= -1;\n        }\n\n        // linear interpolation\n        let t = 0.0;\n        if (deltaScalar !== 0.0) {\n          t = (model.cutValue - cellPointsScalars[e1]) / deltaScalar;\n        }\n\n        // points position\n        const pointID1 = it.cell[e1];\n        const pointID2 = it.cell[e2];\n        x1[0] = pointsData[pointID1 * 3];\n        x1[1] = pointsData[pointID1 * 3 + 1];\n        x1[2] = pointsData[pointID1 * 3 + 2];\n        x2[0] = pointsData[pointID2 * 3];\n        x2[1] = pointsData[pointID2 * 3 + 1];\n        x2[2] = pointsData[pointID2 * 3 + 2];\n\n        // Compute the intersected point on edge\n        const computedIntersectedPoint = [x1[0] + t * (x2[0] - x1[0]), x1[1] + t * (x2[1] - x1[1]), x1[2] + t * (x2[2] - x1[2])];\n\n        // Keep track of it\n        intersectedEdgesList.push({\n          pointEdge1: pointID1,\n          // id of one point of the edge\n          pointEdge2: pointID2,\n          // id of one point of the edge\n          intersectedPoint: computedIntersectedPoint,\n          // 3D coordinate of points that intersected edge\n          newPointID: -1 // id of the intersected point when it will be added into vtkPoints\n        });\n      }\n\n      // Add points into newPointList\n      for (let i = 0; i < intersectedEdgesList.length; i++) {\n        const intersectedEdge = intersectedEdgesList[i];\n        let alreadyAdded = false;\n        // Check if point/edge already added\n        for (let j = 0; j < crossedEdges.length; j++) {\n          const crossedEdge = crossedEdges[j];\n          const sameEdge = intersectedEdge.pointEdge1 === crossedEdge.pointEdge1 && intersectedEdge.pointEdge2 === crossedEdge.pointEdge2;\n          const samePoint = intersectedEdge.intersectedPoint[0] === crossedEdge.intersectedPoint[0] && intersectedEdge.intersectedPoint[1] === crossedEdge.intersectedPoint[1] && intersectedEdge.intersectedPoint[2] === crossedEdge.intersectedPoint[2];\n          if (sameEdge || samePoint) {\n            alreadyAdded = true;\n            intersectedEdgesList[i].newPointID = crossedEdges[j].newPointID;\n            break;\n          }\n        }\n        if (!alreadyAdded) {\n          newPointsData.push(intersectedEdge.intersectedPoint[0]);\n          newPointsData.push(intersectedEdge.intersectedPoint[1]);\n          newPointsData.push(intersectedEdge.intersectedPoint[2]);\n          intersectedEdgesList[i].newPointID = newPointsData.length / 3 - 1;\n          crossedEdges.push(intersectedEdgesList[i]);\n        }\n      }\n\n      // Store cells\n      const cellSize = intersectedEdgesList.length;\n      if (cellSize === 2) {\n        newLinesData.push(cellSize, intersectedEdgesList[0].newPointID, intersectedEdgesList[1].newPointID);\n      } else if (cellSize > 2) {\n        newPolysData.push(cellSize);\n        intersectedEdgesList.forEach(edge => {\n          newPolysData.push(edge.newPointID);\n        });\n      }\n    }\n\n    // Set points\n    const outputPoints = output.getPoints();\n    outputPoints.setData(newTypedArrayFrom(points.getDataType(), newPointsData), 3);\n\n    // Set lines\n    if (newLinesData.length !== 0) {\n      output.getLines().setData(Uint16Array.from(newLinesData));\n    }\n\n    // Set polys\n    if (newPolysData.length !== 0) {\n      output.getPolys().setData(Uint16Array.from(newPolysData));\n    }\n  }\n\n  // expose requestData\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (!model.cutFunction) {\n      vtkErrorMacro('Missing cut function');\n      return;\n    }\n    const output = vtkPolyData.newInstance();\n    dataSetCutter(input, output);\n    outData[0] = output;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  cutFunction: null,\n  // support method with evaluateFunction method\n  cutScalars: null,\n  cutValue: 0.0\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  algo(publicAPI, model, 1, 1);\n\n  // Set implicit function use to cut the input data (is vtkPlane)\n  setGet(publicAPI, model, ['cutFunction', 'cutValue']);\n\n  // Object specific methods\n  vtkCutter(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkCutter');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCutter$1 = {\n  newInstance,\n  extend\n};\nexport { vtkCutter$1 as default, extend, newInstance };","map":{"version":3,"names":["n","newInstance$1","o","obj","d","algo","e","setGet","c","macro","b","newTypedArrayFrom","vtkPolyData","vtkErrorMacro","initPolyIterator","pd","polys","getPolys","getData","strips","getStrips","it","cellSize","cell","done","polyIdx","stripIdx","remainingStripLength","next","length","start","end","p","i","Error","vtkCutter","publicAPI","model","classHierarchy","push","superClass","getMTime","mTime","cutFunction","Math","max","dataSetCutter","input","output","points","getPoints","pointsData","numPts","getNumberOfPoints","newPointsData","newLinesData","newPolysData","cutScalars","Float32Array","inOffset","outOffset","evaluateFunction","crossedEdges","x1","Array","x2","cellPointsScalars","sideFirstPoint","allPointsSameSide","sideCurrentPoint","intersectedEdgesList","idNext","signPoint0","signPoint1","e1","e2","deltaScalar","t","cutValue","pointID1","pointID2","computedIntersectedPoint","pointEdge1","pointEdge2","intersectedPoint","newPointID","intersectedEdge","alreadyAdded","j","crossedEdge","sameEdge","samePoint","forEach","edge","outputPoints","setData","getDataType","getLines","Uint16Array","from","requestData","inData","outData","newInstance","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","vtkCutter$1","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Filters/Core/Cutter.js"],"sourcesContent":["import { n as newInstance$1, o as obj, d as algo, e as setGet, c as macro, b as newTypedArrayFrom } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nfunction initPolyIterator(pd) {\n  const polys = pd.getPolys().getData();\n  const strips = pd.getStrips().getData();\n  const it = {\n    cellSize: 0,\n    cell: [],\n    done: false,\n    polyIdx: 0,\n    stripIdx: 0,\n    remainingStripLength: 0,\n    // returns a single poly cell\n    next() {\n      if (it.polyIdx < polys.length) {\n        it.cellSize = polys[it.polyIdx];\n        const start = it.polyIdx + 1;\n        const end = start + it.cellSize;\n        it.polyIdx = end;\n        let p = 0;\n        for (let i = start; i < end; ++i) {\n          it.cell[p++] = polys[i];\n        }\n      } else if (it.stripIdx < strips.length) {\n        it.cellSize = 3;\n        if (it.remainingStripLength === 0) {\n          it.remainingStripLength = strips[it.stripIdx] - 2; // sliding window of 3 points\n          // stripIdx points to the last point in a triangle 3-tuple\n          it.stripIdx += 3;\n        }\n        const start = it.stripIdx - 2;\n        const end = it.stripIdx + 1;\n        it.stripIdx++;\n        it.remainingStripLength--;\n        let p = 0;\n        for (let i = start; i < end; ++i) {\n          it.cell[p++] = strips[i];\n        }\n      } else if (!it.done) {\n        it.done = true;\n      } else {\n        throw new Error('Iterator is done');\n      }\n    }\n  };\n  it.next();\n  return it;\n}\n\n// ----------------------------------------------------------------------------\n// vtkCutter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCutter(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCutter');\n\n  // Capture \"parentClass\" api for internal use\n  const superClass = {\n    ...publicAPI\n  };\n  publicAPI.getMTime = () => {\n    let mTime = superClass.getMTime();\n    if (!model.cutFunction) {\n      return mTime;\n    }\n    mTime = Math.max(mTime, model.cutFunction.getMTime());\n    return mTime;\n  };\n  function dataSetCutter(input, output) {\n    const points = input.getPoints();\n    const pointsData = points.getData();\n    const numPts = points.getNumberOfPoints();\n    const newPointsData = [];\n    const newLinesData = [];\n    const newPolysData = [];\n    if (!model.cutScalars || model.cutScalars.length < numPts) {\n      model.cutScalars = new Float32Array(numPts);\n    }\n\n    // Loop over all points evaluating scalar function at each point\n    let inOffset = 0;\n    let outOffset = 0;\n    while (inOffset < pointsData.length) {\n      model.cutScalars[outOffset++] = model.cutFunction.evaluateFunction(pointsData[inOffset++], pointsData[inOffset++], pointsData[inOffset++]);\n    }\n    const crossedEdges = [];\n    const x1 = new Array(3);\n    const x2 = new Array(3);\n    const cellPointsScalars = [];\n\n    // Loop over all cells; get scalar values for all cell points\n    // and process each cell.\n    /* eslint-disable no-continue */\n    for (const it = initPolyIterator(input); !it.done; it.next()) {\n      // cell contains the point IDs/indices\n\n      // Check that cells have at least 3 points\n      if (it.cellSize <= 2) {\n        continue;\n      }\n\n      // Get associated scalar of points that constitute the current cell\n      for (let i = 0; i < it.cellSize;) {\n        cellPointsScalars[i] = model.cutScalars[it.cell[i++]];\n      }\n\n      // Check if all cell points are on same side (same side == cell not crossed by cut function)\n      // TODO: won't work if one point scalar is = 0 ?\n      const sideFirstPoint = cellPointsScalars[0] > 0;\n      let allPointsSameSide = true;\n      for (let i = 1; i < it.cell.length; i++) {\n        const sideCurrentPoint = cellPointsScalars[i] > 0;\n        if (sideCurrentPoint !== sideFirstPoint) {\n          allPointsSameSide = false;\n          break;\n        }\n      }\n\n      // Go to next cell if cell is not crossed by cut function\n      if (allPointsSameSide) {\n        continue;\n      }\n\n      // Find and compute edges which intersect cells\n      const intersectedEdgesList = [];\n      for (let i = 0; i < it.cellSize; i++) {\n        const idNext = i + 1 === it.cellSize ? 0 : i + 1;\n\n        // Go to next edge if edge is not crossed\n        // TODO: in most come cases, (numberOfPointsInCell - 1) or 0 edges of the cell\n        // will be crossed, but if it crosses right at a point, it could be intersecting\n        // with (numberOfPoints) or 1 edge(s). Do we account for that?\n        const signPoint0 = cellPointsScalars[i] > 0;\n        const signPoint1 = cellPointsScalars[idNext] > 0;\n        if (signPoint1 === signPoint0) {\n          continue;\n        }\n\n        // Compute preferred interpolation direction\n        let e1 = i;\n        let e2 = idNext;\n        let deltaScalar = cellPointsScalars[e2] - cellPointsScalars[e1];\n        if (deltaScalar <= 0) {\n          e1 = idNext;\n          e2 = i;\n          deltaScalar *= -1;\n        }\n\n        // linear interpolation\n        let t = 0.0;\n        if (deltaScalar !== 0.0) {\n          t = (model.cutValue - cellPointsScalars[e1]) / deltaScalar;\n        }\n\n        // points position\n        const pointID1 = it.cell[e1];\n        const pointID2 = it.cell[e2];\n        x1[0] = pointsData[pointID1 * 3];\n        x1[1] = pointsData[pointID1 * 3 + 1];\n        x1[2] = pointsData[pointID1 * 3 + 2];\n        x2[0] = pointsData[pointID2 * 3];\n        x2[1] = pointsData[pointID2 * 3 + 1];\n        x2[2] = pointsData[pointID2 * 3 + 2];\n\n        // Compute the intersected point on edge\n        const computedIntersectedPoint = [x1[0] + t * (x2[0] - x1[0]), x1[1] + t * (x2[1] - x1[1]), x1[2] + t * (x2[2] - x1[2])];\n\n        // Keep track of it\n        intersectedEdgesList.push({\n          pointEdge1: pointID1,\n          // id of one point of the edge\n          pointEdge2: pointID2,\n          // id of one point of the edge\n          intersectedPoint: computedIntersectedPoint,\n          // 3D coordinate of points that intersected edge\n          newPointID: -1 // id of the intersected point when it will be added into vtkPoints\n        });\n      }\n\n      // Add points into newPointList\n      for (let i = 0; i < intersectedEdgesList.length; i++) {\n        const intersectedEdge = intersectedEdgesList[i];\n        let alreadyAdded = false;\n        // Check if point/edge already added\n        for (let j = 0; j < crossedEdges.length; j++) {\n          const crossedEdge = crossedEdges[j];\n          const sameEdge = intersectedEdge.pointEdge1 === crossedEdge.pointEdge1 && intersectedEdge.pointEdge2 === crossedEdge.pointEdge2;\n          const samePoint = intersectedEdge.intersectedPoint[0] === crossedEdge.intersectedPoint[0] && intersectedEdge.intersectedPoint[1] === crossedEdge.intersectedPoint[1] && intersectedEdge.intersectedPoint[2] === crossedEdge.intersectedPoint[2];\n          if (sameEdge || samePoint) {\n            alreadyAdded = true;\n            intersectedEdgesList[i].newPointID = crossedEdges[j].newPointID;\n            break;\n          }\n        }\n        if (!alreadyAdded) {\n          newPointsData.push(intersectedEdge.intersectedPoint[0]);\n          newPointsData.push(intersectedEdge.intersectedPoint[1]);\n          newPointsData.push(intersectedEdge.intersectedPoint[2]);\n          intersectedEdgesList[i].newPointID = newPointsData.length / 3 - 1;\n          crossedEdges.push(intersectedEdgesList[i]);\n        }\n      }\n\n      // Store cells\n      const cellSize = intersectedEdgesList.length;\n      if (cellSize === 2) {\n        newLinesData.push(cellSize, intersectedEdgesList[0].newPointID, intersectedEdgesList[1].newPointID);\n      } else if (cellSize > 2) {\n        newPolysData.push(cellSize);\n        intersectedEdgesList.forEach(edge => {\n          newPolysData.push(edge.newPointID);\n        });\n      }\n    }\n\n    // Set points\n    const outputPoints = output.getPoints();\n    outputPoints.setData(newTypedArrayFrom(points.getDataType(), newPointsData), 3);\n\n    // Set lines\n    if (newLinesData.length !== 0) {\n      output.getLines().setData(Uint16Array.from(newLinesData));\n    }\n\n    // Set polys\n    if (newPolysData.length !== 0) {\n      output.getPolys().setData(Uint16Array.from(newPolysData));\n    }\n  }\n\n  // expose requestData\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (!model.cutFunction) {\n      vtkErrorMacro('Missing cut function');\n      return;\n    }\n    const output = vtkPolyData.newInstance();\n    dataSetCutter(input, output);\n    outData[0] = output;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  cutFunction: null,\n  // support method with evaluateFunction method\n  cutScalars: null,\n  cutValue: 0.0\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  algo(publicAPI, model, 1, 1);\n\n  // Set implicit function use to cut the input data (is vtkPlane)\n  setGet(publicAPI, model, ['cutFunction', 'cutValue']);\n\n  // Object specific methods\n  vtkCutter(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkCutter');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCutter$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkCutter$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}