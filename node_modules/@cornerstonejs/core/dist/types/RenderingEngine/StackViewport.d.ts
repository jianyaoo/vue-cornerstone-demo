import type { vtkImageData as vtkImageDataType } from '@kitware/vtk.js/Common/DataModel/ImageData';
import type { ActorEntry, CPUIImageData, ICamera, IImage, IImageData, IImagesLoader, IStackInput, IStackViewport, ImageLoadListener, Mat3, Point2, Point3, Scaling, StackViewportProperties, ViewReference, ViewPresentation } from '../types';
import { ViewReferenceSpecifier, ReferenceCompatibleOptions, ViewportInput } from '../types/IViewport';
import Viewport from './Viewport';
import { InterpolationType, RequestType, ViewportStatus } from '../enums';
import { ImagePixelModule, ImagePlaneModule } from '../types';
interface ImageDataMetaData {
    bitsAllocated: number;
    numComps: number;
    origin: Point3;
    direction: Mat3;
    dimensions: Point3;
    spacing: Point3;
    numVoxels: number;
    imagePlaneModule: ImagePlaneModule;
    imagePixelModule: ImagePixelModule;
}
declare class StackViewport extends Viewport implements IStackViewport, IImagesLoader {
    private imageIds;
    private currentImageIdIndex;
    private targetImageIdIndex;
    private debouncedTimeout;
    protected imagesLoader: IImagesLoader;
    private globalDefaultProperties;
    private perImageIdDefaultProperties;
    private colormap;
    private voiRange;
    private voiUpdatedWithSetProperties;
    private VOILUTFunction;
    private invert;
    private initialInvert;
    private initialTransferFunctionNodes;
    private interpolationType;
    private _imageData;
    private cameraFocalPointOnRender;
    private stackInvalidated;
    private _publishCalibratedEvent;
    private _calibrationEvent;
    private _cpuFallbackEnabledElement?;
    private useCPURendering;
    private useNativeDataType;
    private cpuImagePixelData;
    private cpuRenderingInvalidated;
    private csImage;
    modality: string;
    scaling: Scaling;
    private initialViewUp;
    stackActorReInitialized: boolean;
    constructor(props: ViewportInput);
    setUseCPURendering(value: boolean): void;
    static get useCustomRenderingPipeline(): boolean;
    updateRenderingPipeline: () => void;
    private _configureRenderingPipeline;
    private _resetCPUFallbackElement;
    private _resetGPUViewport;
    getImageData: () => IImageData | CPUIImageData;
    getCamera: () => ICamera;
    setCamera: (cameraInterface: ICamera, storeAsInitialCamera?: boolean) => void;
    getRotation: () => number;
    unsetColormap: () => void;
    resetCamera: (resetPan?: boolean, resetZoom?: boolean) => boolean;
    canvasToWorld: (canvasPos: Point2) => Point3;
    worldToCanvas: (worldPos: Point3) => Point2;
    getRenderer: () => any;
    getDefaultActor: () => ActorEntry;
    getActors: () => Array<ActorEntry>;
    getActor: (actorUID: string) => ActorEntry;
    setActors: (actors: Array<ActorEntry>) => void;
    addActors: (actors: Array<ActorEntry>) => void;
    addActor: (actorEntry: ActorEntry) => void;
    removeAllActors: () => void;
    private setVOI;
    protected setInterpolationType: (interpolationType: InterpolationType) => void;
    private setInvertColor;
    private setColormap;
    private initializeElementDisabledHandler;
    resize: () => void;
    private _resizeCPU;
    private getImageDataGPU;
    private getImageDataCPU;
    getFrameOfReferenceUID: () => string | undefined;
    getCornerstoneImage: () => IImage;
    private createActorMapper;
    getNumberOfSlices: () => number;
    private buildMetadata;
    private calibrateIfNecessary;
    setDefaultProperties(ViewportProperties: StackViewportProperties, imageId?: string): void;
    clearDefaultProperties(imageId?: string): void;
    setProperties({ colormap, voiRange, VOILUTFunction, invert, interpolationType, rotation, }?: StackViewportProperties, suppressEvents?: boolean): void;
    getDefaultProperties: (imageId?: string) => StackViewportProperties;
    getProperties: () => StackViewportProperties;
    resetProperties(): void;
    private _resetProperties;
    resetToDefaultProperties(): void;
    private _setPropertiesFromCache;
    private getCameraCPU;
    private setCameraCPU;
    private getPanCPU;
    private setPanCPU;
    private getZoomCPU;
    private setZoomCPU;
    private setFlipCPU;
    private getRotationCPU;
    private getRotationGPU;
    protected setRotation: (rotation: number) => void;
    private setVOILUTFunction;
    private setRotationCPU;
    private setRotationGPU;
    private setInterpolationTypeGPU;
    private setInterpolationTypeCPU;
    private setInvertColorCPU;
    private setInvertColorGPU;
    private setVOICPU;
    private getTransferFunction;
    private setVOIGPU;
    private _addScalingToViewport;
    private _getNumCompsFromPhotometricInterpretation;
    getImageDataMetadata(image: IImage): ImageDataMetaData;
    private _getCameraOrientation;
    createVTKImageData({ origin, direction, dimensions, spacing, numComps, pixelArray, }: {
        origin: any;
        direction: any;
        dimensions: any;
        spacing: any;
        numComps: any;
        pixelArray: any;
    }): vtkImageDataType;
    private _createVTKImageData;
    setStack(imageIds: Array<string>, currentImageIdIndex?: number): Promise<string>;
    private _throwIfDestroyed;
    private _checkVTKImageDataMatchesCornerstoneImage;
    private _updateVTKImageDataFromCornerstoneImage;
    private _loadAndDisplayImage;
    private _loadAndDisplayImageCPU;
    successCallback(imageId: any, image: any): void;
    errorCallback(imageId: any, permanent: any, error: any): void;
    getLoaderImageOptions(imageId: string): {
        targetBuffer: {
            type: string;
        };
        preScale: {
            enabled: boolean;
        };
        useRGBA: boolean;
        transferSyntaxUID: any;
        useNativeDataType: boolean;
        priority: number;
        requestType: RequestType;
        additionalDetails: {
            imageId: string;
            imageIdIndex: number;
        };
    };
    loadImages(imageIds: string[], listener: ImageLoadListener): Promise<unknown>;
    private _loadAndDisplayImageGPU;
    renderImageObject: (image: any) => void;
    private _setCSImage;
    private _updateToDisplayImageCPU;
    addImages(stackInputs: Array<IStackInput>): Promise<void>;
    private _updateActorToDisplayImageId;
    private _getInitialVOIRange;
    private _getPTPreScaledRange;
    private _isCurrentImagePTPrescaled;
    private _getDefaultPTPrescaledVOIRange;
    private _getVOIRangeFromWindowLevel;
    private _setImageIdIndex;
    private resetCameraCPU;
    private resetCameraGPU;
    scroll(delta: number, debounce?: boolean, loop?: boolean): void;
    setImageIdIndex(imageIdIndex: number): Promise<string>;
    calibrateSpacing(imageId: string): void;
    private _restoreCameraProps;
    private triggerCameraEvent;
    private triggerCalibrationEvent;
    private canvasToWorldCPU;
    private worldToCanvasCPU;
    private canvasToWorldGPU;
    private worldToCanvasGPU;
    private _getVOIRangeForCurrentImage;
    private _getValidVOILUTFunction;
    getCurrentImageIdIndex: () => number;
    getSliceIndex: () => number;
    isReferenceViewable(viewRef: ViewReference, options?: ReferenceCompatibleOptions): boolean;
    getViewReference(viewRefSpecifier?: ViewReferenceSpecifier): ViewReference;
    setView(viewRef?: ViewReference, viewPres?: ViewPresentation): void;
    getReferenceId(specifier?: ViewReferenceSpecifier): string;
    getTargetImageIdIndex: () => number;
    getImageIds: () => Array<string>;
    getCurrentImageId: () => string;
    hasImageId: (imageId: string) => boolean;
    hasImageURI: (imageURI: string) => boolean;
    private getCPUFallbackError;
    private fillWithBackgroundColor;
    customRenderViewportToCanvas: () => {
        canvas: HTMLCanvasElement;
        element: HTMLDivElement;
        viewportId: string;
        renderingEngineId: string;
        viewportStatus: ViewportStatus;
    };
    private unsetColormapCPU;
    private setColormapCPU;
    private setColormapGPU;
    private unsetColormapGPU;
    private _getImagePlaneModule;
    private renderingPipelineFunctions;
}
export default StackViewport;
//# sourceMappingURL=StackViewport.d.ts.map