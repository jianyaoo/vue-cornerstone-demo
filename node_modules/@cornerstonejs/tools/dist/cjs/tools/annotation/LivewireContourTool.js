"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const gl_matrix_1 = require("gl-matrix");
const core_1 = require("@cornerstonejs/core");
const annotationState_1 = require("../../stateManagement/annotation/annotationState");
const drawingSvg_1 = require("../../drawingSvg");
const store_1 = require("../../store");
const enums_1 = require("../../enums");
const elementCursor_1 = require("../../cursors/elementCursor");
const utilities_1 = require("../../utilities");
const LivewireScissors_1 = require("../../utilities/livewire/LivewireScissors");
const LiveWirePath_1 = require("../../utilities/livewire/LiveWirePath");
const viewportFilters_1 = require("../../utilities/viewportFilters");
const ContourSegmentationBaseTool_1 = __importDefault(require("../base/ContourSegmentationBaseTool"));
const CLICK_CLOSE_CURVE_SQR_DIST = Math.pow(10, 2);
class LivewireContourTool extends ContourSegmentationBaseTool_1.default {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            preventHandleOutsideImage: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0, core_1.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const proximitySquared = proximity * proximity;
            const canvasPoints = annotation.data.contour.polyline.map((p) => viewport.worldToCanvas(p));
            let startPoint = canvasPoints[canvasPoints.length - 1];
            for (let i = 0; i < canvasPoints.length; i++) {
                const endPoint = canvasPoints[i];
                const distanceToPointSquared = utilities_1.math.lineSegment.distanceToPointSquared(startPoint, endPoint, canvasCoords);
                if (distanceToPointSquared <= proximitySquared) {
                    return true;
                }
                startPoint = endPoint;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0, viewportFilters_1.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
            };
            const enabledElement = (0, core_1.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            this._activateModify(element);
            (0, utilities_1.triggerAnnotationRenderForViewportIds)(renderingEngine, viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            const { points } = data.handles;
            const handleIndex = points.findIndex((p) => p === handle);
            const viewportIdsToRender = (0, viewportFilters_1.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
            };
            this._activateModify(element);
            const enabledElement = (0, core_1.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0, utilities_1.triggerAnnotationRenderForViewportIds)(renderingEngine, viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0, elementCursor_1.resetElementCursor)(element);
            const enabledElement = (0, core_1.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0, annotationState_1.removeAnnotation)(annotation.annotationUID);
            }
            (0, utilities_1.triggerAnnotationRenderForViewportIds)(renderingEngine, viewportIdsToRender);
            if (newAnnotation) {
                const eventType = enums_1.Events.ANNOTATION_COMPLETED;
                const eventDetail = {
                    annotation,
                };
                (0, core_1.triggerEvent)(core_1.eventTarget, eventType, eventDetail);
            }
            this.editData = null;
            this.scissors = null;
            this.isDrawing = false;
        };
        this._mouseDownCallback = (evt) => {
            const doubleClick = evt.type === enums_1.Events.MOUSE_DOUBLE_CLICK;
            const { annotation, viewportIdsToRender, worldToSlice, sliceToWorld } = this.editData;
            if (this.editData.closed) {
                return;
            }
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const { canvas: canvasPos, world: worldPos } = currentPoints;
            const enabledElement = (0, core_1.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            const controlPoints = this.editData.currentPath.getControlPoints();
            let closePath = controlPoints.length >= 2 && doubleClick;
            if (controlPoints.length >= 2) {
                const closestHandlePoint = {
                    index: -1,
                    distSquared: Infinity,
                };
                for (let i = 0, len = controlPoints.length; i < len; i++) {
                    const controlPoint = controlPoints[i];
                    const worldControlPoint = sliceToWorld(controlPoint);
                    const canvasControlPoint = viewport.worldToCanvas(worldControlPoint);
                    const distSquared = utilities_1.math.point.distanceToPointSquared(canvasPos, canvasControlPoint);
                    if (distSquared <= CLICK_CLOSE_CURVE_SQR_DIST &&
                        distSquared < closestHandlePoint.distSquared) {
                        closestHandlePoint.distSquared = distSquared;
                        closestHandlePoint.index = i;
                    }
                }
                if (closestHandlePoint.index === 0) {
                    closePath = true;
                }
            }
            this.editData.closed = this.editData.closed || closePath;
            this.editData.confirmedPath = this.editData.currentPath;
            this.editData.confirmedPath.addControlPoint(this.editData.currentPath.getLastPoint());
            this.scissors.startSearch(worldToSlice(worldPos));
            annotation.invalidated = true;
            (0, utilities_1.triggerAnnotationRenderForViewportIds)(renderingEngine, viewportIdsToRender);
            if (this.editData.closed) {
                this._updateAnnotation(element, this.editData.confirmedPath);
                this._endCallback(evt);
            }
            evt.preventDefault();
        };
        this._mouseMoveCallback = (evt) => {
            const { element, currentPoints } = evt.detail;
            const { world: worldPos, canvas: canvasPos } = currentPoints;
            const { renderingEngine } = (0, core_1.getEnabledElement)(element);
            const viewportIdsToRender = (0, viewportFilters_1.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData.lastCanvasPoint = canvasPos;
            const { width: imgWidth, height: imgHeight } = this.scissors;
            const { worldToSlice } = this.editData;
            const slicePoint = worldToSlice(worldPos);
            if (slicePoint[0] < 0 ||
                slicePoint[1] < 0 ||
                slicePoint[0] >= imgWidth ||
                slicePoint[1] >= imgHeight) {
                return;
            }
            const pathPoints = this.scissors.findPathToPoint(slicePoint);
            const currentPath = new LiveWirePath_1.LivewirePath();
            for (let i = 0, len = pathPoints.length; i < len; i++) {
                currentPath.addPoint(pathPoints[i]);
            }
            currentPath.prependPath(this.editData.confirmedPath);
            this.editData.currentPath = currentPath;
            (0, utilities_1.triggerAnnotationRenderForViewportIds)(renderingEngine, viewportIdsToRender);
            evt.preventDefault();
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex } = this.editData;
            const { data } = annotation;
            if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.contour.polyline;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0, core_1.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0, utilities_1.triggerAnnotationRenderForViewportIds)(renderingEngine, viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (!this.isDrawing) {
                return;
            }
            this.isDrawing = false;
            this._deactivateDraw(element);
            this._deactivateModify(element);
            (0, elementCursor_1.resetElementCursor)(element);
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            if (newAnnotation) {
                (0, annotationState_1.removeAnnotation)(annotation.annotationUID);
            }
            const enabledElement = (0, core_1.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0, utilities_1.triggerAnnotationRenderForViewportIds)(renderingEngine, viewportIdsToRender);
            this.editData = null;
            this.scissors = null;
            return annotation.annotationUID;
        };
        this.triggerAnnotationModified = (annotation, enabledElement) => {
            const { viewportId, renderingEngineId } = enabledElement;
            const eventType = enums_1.Events.ANNOTATION_MODIFIED;
            const eventDetail = {
                annotation,
                viewportId,
                renderingEngineId,
            };
            (0, core_1.triggerEvent)(core_1.eventTarget, eventType, eventDetail);
        };
        this._activateModify = (element) => {
            store_1.state.isInteractingWithTool = true;
            element.addEventListener(enums_1.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums_1.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums_1.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums_1.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums_1.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums_1.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            store_1.state.isInteractingWithTool = false;
            element.removeEventListener(enums_1.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums_1.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums_1.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums_1.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums_1.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums_1.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            store_1.state.isInteractingWithTool = true;
            element.addEventListener(enums_1.Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.addEventListener(enums_1.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.addEventListener(enums_1.Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.addEventListener(enums_1.Events.TOUCH_TAP, this._mouseDownCallback);
        };
        this._deactivateDraw = (element) => {
            store_1.state.isInteractingWithTool = false;
            element.removeEventListener(enums_1.Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.removeEventListener(enums_1.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.removeEventListener(enums_1.Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.removeEventListener(enums_1.Events.TOUCH_TAP, this._mouseDownCallback);
        };
    }
    addNewAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const { world: worldPos, canvas: canvasPos } = currentPoints;
        const enabledElement = (0, core_1.getEnabledElement)(element);
        const { viewport, renderingEngine } = enabledElement;
        this.isDrawing = true;
        const defaultActor = viewport.getDefaultActor();
        if (!defaultActor || !core_1.utilities.isImageActor(defaultActor)) {
            throw new Error('Default actor must be an image actor');
        }
        const viewportImageData = viewport.getImageData();
        const { imageData: vtkImageData } = viewportImageData;
        let worldToSlice;
        let sliceToWorld;
        let scalarData;
        let width;
        let height;
        if (viewport instanceof core_1.StackViewport) {
            scalarData = viewportImageData.scalarData;
            width = viewportImageData.dimensions[0];
            height = viewportImageData.dimensions[1];
            worldToSlice = (point) => {
                const ijkPoint = core_1.utilities.transformWorldToIndex(vtkImageData, point);
                return [ijkPoint[0], ijkPoint[1]];
            };
            sliceToWorld = (point) => core_1.utilities.transformIndexToWorld(vtkImageData, [point[0], point[1], 0]);
        }
        else if (viewport instanceof core_1.VolumeViewport) {
            const sliceImageData = core_1.utilities.getCurrentVolumeViewportSlice(viewport);
            const { sliceToIndexMatrix, indexToSliceMatrix } = sliceImageData;
            worldToSlice = (point) => {
                const ijkPoint = core_1.utilities.transformWorldToIndex(vtkImageData, point);
                const slicePoint = gl_matrix_1.vec3.transformMat4([0, 0, 0], ijkPoint, indexToSliceMatrix);
                return [slicePoint[0], slicePoint[1]];
            };
            sliceToWorld = (point) => {
                const ijkPoint = gl_matrix_1.vec3.transformMat4([0, 0, 0], [point[0], point[1], 0], sliceToIndexMatrix);
                return core_1.utilities.transformIndexToWorld(vtkImageData, ijkPoint);
            };
            scalarData = sliceImageData.scalarData;
            width = sliceImageData.width;
            height = sliceImageData.height;
        }
        else {
            throw new Error('Viewport not supported');
        }
        const { voiRange } = viewport.getProperties();
        const startPos = worldToSlice(worldPos);
        this.scissors = LivewireScissors_1.LivewireScissors.createInstanceFromRawPixelData(scalarData, width, height, voiRange);
        this.scissors.startSearch(startPos);
        const confirmedPath = new LiveWirePath_1.LivewirePath();
        const currentPath = new LiveWirePath_1.LivewirePath();
        confirmedPath.addPoint(startPos);
        confirmedPath.addControlPoint(startPos);
        const annotation = this.createAnnotation(evt);
        this.addAnnotation(annotation, element);
        const viewportIdsToRender = (0, viewportFilters_1.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            newAnnotation: true,
            hasMoved: false,
            lastCanvasPoint: canvasPos,
            confirmedPath: confirmedPath,
            currentPath: currentPath,
            closed: false,
            worldToSlice,
            sliceToWorld,
        };
        this._activateDraw(element);
        evt.preventDefault();
        (0, utilities_1.triggerAnnotationRenderForViewportIds)(renderingEngine, viewportIdsToRender);
        return annotation;
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        var _a;
        const { viewport } = enabledElement;
        const { element } = viewport;
        this._updateAnnotation(element, (_a = this.editData) === null || _a === void 0 ? void 0 : _a.currentPath);
        return super.renderAnnotation(enabledElement, svgDrawingHelper);
    }
    isContourSegmentationTool() {
        return false;
    }
    createAnnotation(evt) {
        const contourSegmentationAnnotation = super.createAnnotation(evt);
        const { world: worldPos } = evt.detail.currentPoints;
        return core_1.utilities.deepMerge(contourSegmentationAnnotation, {
            data: {
                handles: {
                    points: [[...worldPos]],
                },
            },
        });
    }
    renderAnnotationInstance(renderContext) {
        var _a, _b, _c;
        const { enabledElement, svgDrawingHelper, annotationStyle } = renderContext;
        const { viewport } = enabledElement;
        const { worldToCanvas } = viewport;
        const annotation = renderContext.annotation;
        const { annotationUID, data } = annotation;
        const { handles } = data;
        const newAnnotation = (_a = this.editData) === null || _a === void 0 ? void 0 : _a.newAnnotation;
        const { lineWidth, lineDash, color } = annotationStyle;
        if (newAnnotation &&
            annotation.annotationUID === ((_c = (_b = this.editData) === null || _b === void 0 ? void 0 : _b.annotation) === null || _c === void 0 ? void 0 : _c.annotationUID)) {
            const handleGroupUID = '0';
            const startPoint = worldToCanvas(handles.points[0]);
            (0, drawingSvg_1.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, [startPoint], {
                color,
                lineDash,
                lineWidth,
            });
        }
        super.renderAnnotationInstance(renderContext);
        return true;
    }
    _updateAnnotation(element, livewirePath) {
        if (!this.editData || !livewirePath) {
            return;
        }
        const { pointArray: imagePoints } = livewirePath;
        const worldPolylinePoints = [];
        const { annotation, sliceToWorld } = this.editData;
        for (let i = 0, len = imagePoints.length; i < len; i++) {
            const imagePoint = imagePoints[i];
            const worldPoint = sliceToWorld(imagePoint);
            worldPolylinePoints.push(worldPoint);
        }
        if (worldPolylinePoints.length > 1) {
            worldPolylinePoints.push([...worldPolylinePoints[0]]);
        }
        annotation.data.contour.polyline = worldPolylinePoints;
    }
}
LivewireContourTool.toolName = 'LivewireContour';
exports.default = LivewireContourTool;
//# sourceMappingURL=LivewireContourTool.js.map