{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUTypes from './Types.js';\nconst {\n  BufferUsage\n} = vtkWebGPUBufferManager;\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUUniformBuffer methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUUniformBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUUniformBuffer');\n  publicAPI.addEntry = (name, type) => {\n    if (model._bufferEntryNames.has(name)) {\n      vtkErrorMacro(`entry named ${name} already exists`);\n      return;\n    }\n    model.sortDirty = true;\n    model._bufferEntryNames.set(name, model.bufferEntries.length);\n    model.bufferEntries.push({\n      name,\n      type,\n      sizeInBytes: vtkWebGPUTypes.getByteStrideFromShaderFormat(type),\n      offset: -1,\n      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type),\n      packed: false\n    });\n  };\n\n  // UBOs have layout rules in terms of how memory is aligned so we\n  // have to be careful how we order the entries. For example a vec4<f32>\n  // must be aligned on a 16 byte offset, etc. See\n  // https://gpuweb.github.io/gpuweb/wgsl/#memory-layouts\n  // for more details. Right now you can create a situation that would fail\n  // in the future we could add dummy spacer entries where needed to\n  // handle alignment issues\n  publicAPI.sortBufferEntries = () => {\n    if (!model.sortDirty) {\n      return;\n    }\n    let currOffset = 0;\n    const newEntries = [];\n\n    // compute the max alignment, this is required as WebGPU defines a UBO to have\n    // a size that is a multiple of the maxAlignment\n    let maxAlignment = 4;\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (entry.sizeInBytes % 16 === 0) {\n        maxAlignment = Math.max(16, maxAlignment);\n      }\n      if (entry.sizeInBytes % 8 === 0) {\n        maxAlignment = Math.max(8, maxAlignment);\n      }\n    }\n\n    // pack anything whose size is a multiple of 16 bytes first\n    // this includes a couple types that don't require 16 byte alignment\n    // such as mat2x2<f32> but that is OK\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (entry.packed === false && entry.sizeInBytes % 16 === 0) {\n        entry.packed = true;\n        entry.offset = currOffset;\n        newEntries.push(entry);\n        currOffset += entry.sizeInBytes;\n      }\n    }\n\n    // now it gets tough, we have the following common types (f32, i32, u32)\n    // - vec2<f32> 8 byte size, 8 byte alignment\n    // - vec3<f32> 12 byte size, 16 byte alignment\n    // - f32 4 byte size, 4 byte alignment\n\n    // try adding 12 byte, 4 byte pairs\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (entry.packed === false && entry.sizeInBytes === 12) {\n        for (let i2 = 0; i2 < model.bufferEntries.length; i2++) {\n          const entry2 = model.bufferEntries[i2];\n          if (entry2.packed === false && entry2.sizeInBytes === 4) {\n            entry.packed = true;\n            entry.offset = currOffset;\n            newEntries.push(entry);\n            currOffset += entry.sizeInBytes;\n            entry2.packed = true;\n            entry2.offset = currOffset;\n            newEntries.push(entry2);\n            currOffset += entry2.sizeInBytes;\n            break;\n          }\n        }\n      }\n    }\n\n    // try adding 8 byte, 8 byte pairs\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (!entry.packed && entry.sizeInBytes % 8 === 0) {\n        for (let i2 = i + 1; i2 < model.bufferEntries.length; i2++) {\n          const entry2 = model.bufferEntries[i2];\n          if (!entry2.packed && entry2.sizeInBytes % 8 === 0) {\n            entry.packed = true;\n            entry.offset = currOffset;\n            newEntries.push(entry);\n            currOffset += entry.sizeInBytes;\n            entry2.packed = true;\n            entry2.offset = currOffset;\n            newEntries.push(entry2);\n            currOffset += entry2.sizeInBytes;\n            break;\n          }\n        }\n      }\n    }\n\n    // try adding 8 byte, 4 byte 4 byte triplets\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (!entry.packed && entry.sizeInBytes % 8 === 0) {\n        let found = false;\n        for (let i2 = 0; !found && i2 < model.bufferEntries.length; i2++) {\n          const entry2 = model.bufferEntries[i2];\n          if (!entry2.packed && entry2.sizeInBytes === 4) {\n            for (let i3 = i2 + 1; i3 < model.bufferEntries.length; i3++) {\n              const entry3 = model.bufferEntries[i3];\n              if (!entry3.packed && entry3.sizeInBytes === 4) {\n                entry.packed = true;\n                entry.offset = currOffset;\n                newEntries.push(entry);\n                currOffset += entry.sizeInBytes;\n                entry2.packed = true;\n                entry2.offset = currOffset;\n                newEntries.push(entry2);\n                currOffset += entry2.sizeInBytes;\n                entry3.packed = true;\n                entry3.offset = currOffset;\n                newEntries.push(entry3);\n                currOffset += entry3.sizeInBytes;\n                found = true;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Add anything remaining that is larger than 4 bytes and hope we get lucky.\n    // Likely if there is more than one item added here it will result\n    // in a failed UBO\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (!entry.packed && entry.sizeInBytes > 4) {\n        entry.packed = true;\n        entry.offset = currOffset;\n        newEntries.push(entry);\n        currOffset += entry.sizeInBytes;\n      }\n    }\n\n    // finally add remaining 4 byte items\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (!entry.packed) {\n        entry.packed = true;\n        entry.offset = currOffset;\n        newEntries.push(entry);\n        currOffset += entry.sizeInBytes;\n      }\n    }\n\n    // update entries and entryNames\n    model.bufferEntries = newEntries;\n    model._bufferEntryNames.clear();\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      model._bufferEntryNames.set(model.bufferEntries[i].name, i);\n    }\n    model.sizeInBytes = currOffset;\n    model.sizeInBytes = maxAlignment * Math.ceil(model.sizeInBytes / maxAlignment);\n    model.sortDirty = false;\n  };\n  publicAPI.sendIfNeeded = device => {\n    if (!model.UBO) {\n      const req = {\n        nativeArray: model.Float32Array,\n        usage: BufferUsage.UniformArray,\n        label: model.label\n      };\n      model.UBO = device.getBufferManager().getBuffer(req);\n      model.bindGroupTime.modified();\n      model.sendDirty = false;\n    }\n\n    // send data down if needed\n    if (model.sendDirty) {\n      device.getHandle().queue.writeBuffer(model.UBO.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes);\n      model.sendDirty = false;\n    }\n\n    // always updated as mappers depend on this time\n    // it is more of a sentIfNeededTime\n    model.sendTime.modified();\n  };\n  publicAPI.createView = type => {\n    if (type in model === false) {\n      if (!model.arrayBuffer) {\n        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes);\n      }\n      model[type] = macro.newTypedArray(type, model.arrayBuffer);\n    }\n  };\n  publicAPI.setValue = (name, val) => {\n    publicAPI.sortBufferEntries();\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    if (entry.lastValue !== val) {\n      view[entry.offset / view.BYTES_PER_ELEMENT] = val;\n      model.sendDirty = true;\n    }\n    entry.lastValue = val;\n  };\n  publicAPI.setArray = (name, arr) => {\n    publicAPI.sortBufferEntries();\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    let changed = false;\n    for (let i = 0; i < arr.length; i++) {\n      if (!entry.lastValue || entry.lastValue[i] !== arr[i]) {\n        view[entry.offset / view.BYTES_PER_ELEMENT + i] = arr[i];\n        changed = true;\n      }\n    }\n    if (changed) {\n      model.sendDirty = true;\n      entry.lastValue = [...arr];\n    }\n  };\n  publicAPI.getBindGroupEntry = () => {\n    const foo = {\n      resource: {\n        buffer: model.UBO.getHandle()\n      }\n    };\n    return foo;\n  };\n  publicAPI.getSendTime = () => model.sendTime.getMTime();\n  publicAPI.getShaderCode = (binding, group) => {\n    // sort the entries\n    publicAPI.sortBufferEntries();\n    const lines = [`struct ${model.label}Struct\\n{`];\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      lines.push(`  ${entry.name}: ${entry.type},`);\n    }\n    lines.push(`};\\n@binding(${binding}) @group(${group}) var<uniform> ${model.label}: ${model.label}Struct;`);\n    return lines.join('\\n');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  bufferEntries: null,\n  bufferEntryNames: null,\n  sizeInBytes: 0,\n  label: null,\n  bindGroupLayoutEntry: null,\n  bindGroupEntry: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n\n  // Internal objects\n  model._bufferEntryNames = new Map();\n  model.bufferEntries = [];\n\n  // default UBO desc\n  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {\n    buffer: {\n      type: 'uniform'\n    }\n  };\n  model.sendTime = {};\n  macro.obj(model.sendTime, {\n    mtime: 0\n  });\n  model.bindGroupTime = {};\n  macro.obj(model.bindGroupTime, {\n    mtime: 0\n  });\n  model.sendDirty = true;\n  model.sortDirty = true;\n  macro.get(publicAPI, model, ['binding', 'bindGroupTime']);\n  macro.setGet(publicAPI, model, ['bindGroupLayoutEntry', 'device', 'label', 'sizeInBytes']);\n\n  // Object methods\n  vtkWebGPUUniformBuffer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPUUniformBuffer');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUUniformBuffer$1 = {\n  newInstance,\n  extend\n};\nexport { vtkWebGPUUniformBuffer$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkWebGPUBufferManager","vtkWebGPUTypes","BufferUsage","vtkErrorMacro","vtkWebGPUUniformBuffer","publicAPI","model","classHierarchy","push","addEntry","name","type","_bufferEntryNames","has","sortDirty","set","bufferEntries","length","sizeInBytes","getByteStrideFromShaderFormat","offset","nativeType","getNativeTypeFromShaderFormat","packed","sortBufferEntries","currOffset","newEntries","maxAlignment","i","entry","Math","max","i2","entry2","found","i3","entry3","clear","ceil","sendIfNeeded","device","UBO","req","nativeArray","Float32Array","usage","UniformArray","label","getBufferManager","getBuffer","bindGroupTime","modified","sendDirty","getHandle","queue","writeBuffer","arrayBuffer","sendTime","createView","ArrayBuffer","newTypedArray","setValue","val","idx","get","undefined","view","lastValue","BYTES_PER_ELEMENT","setArray","arr","changed","getBindGroupEntry","foo","resource","buffer","getSendTime","getMTime","getShaderCode","binding","group","lines","join","DEFAULT_VALUES","bufferEntryNames","bindGroupLayoutEntry","bindGroupEntry","extend","initialValues","arguments","Object","assign","obj","Map","mtime","setGet","newInstance","vtkWebGPUUniformBuffer$1","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/WebGPU/UniformBuffer.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUTypes from './Types.js';\n\nconst {\n  BufferUsage\n} = vtkWebGPUBufferManager;\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUUniformBuffer methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUUniformBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUUniformBuffer');\n  publicAPI.addEntry = (name, type) => {\n    if (model._bufferEntryNames.has(name)) {\n      vtkErrorMacro(`entry named ${name} already exists`);\n      return;\n    }\n    model.sortDirty = true;\n    model._bufferEntryNames.set(name, model.bufferEntries.length);\n    model.bufferEntries.push({\n      name,\n      type,\n      sizeInBytes: vtkWebGPUTypes.getByteStrideFromShaderFormat(type),\n      offset: -1,\n      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type),\n      packed: false\n    });\n  };\n\n  // UBOs have layout rules in terms of how memory is aligned so we\n  // have to be careful how we order the entries. For example a vec4<f32>\n  // must be aligned on a 16 byte offset, etc. See\n  // https://gpuweb.github.io/gpuweb/wgsl/#memory-layouts\n  // for more details. Right now you can create a situation that would fail\n  // in the future we could add dummy spacer entries where needed to\n  // handle alignment issues\n  publicAPI.sortBufferEntries = () => {\n    if (!model.sortDirty) {\n      return;\n    }\n    let currOffset = 0;\n    const newEntries = [];\n\n    // compute the max alignment, this is required as WebGPU defines a UBO to have\n    // a size that is a multiple of the maxAlignment\n    let maxAlignment = 4;\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (entry.sizeInBytes % 16 === 0) {\n        maxAlignment = Math.max(16, maxAlignment);\n      }\n      if (entry.sizeInBytes % 8 === 0) {\n        maxAlignment = Math.max(8, maxAlignment);\n      }\n    }\n\n    // pack anything whose size is a multiple of 16 bytes first\n    // this includes a couple types that don't require 16 byte alignment\n    // such as mat2x2<f32> but that is OK\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (entry.packed === false && entry.sizeInBytes % 16 === 0) {\n        entry.packed = true;\n        entry.offset = currOffset;\n        newEntries.push(entry);\n        currOffset += entry.sizeInBytes;\n      }\n    }\n\n    // now it gets tough, we have the following common types (f32, i32, u32)\n    // - vec2<f32> 8 byte size, 8 byte alignment\n    // - vec3<f32> 12 byte size, 16 byte alignment\n    // - f32 4 byte size, 4 byte alignment\n\n    // try adding 12 byte, 4 byte pairs\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (entry.packed === false && entry.sizeInBytes === 12) {\n        for (let i2 = 0; i2 < model.bufferEntries.length; i2++) {\n          const entry2 = model.bufferEntries[i2];\n          if (entry2.packed === false && entry2.sizeInBytes === 4) {\n            entry.packed = true;\n            entry.offset = currOffset;\n            newEntries.push(entry);\n            currOffset += entry.sizeInBytes;\n            entry2.packed = true;\n            entry2.offset = currOffset;\n            newEntries.push(entry2);\n            currOffset += entry2.sizeInBytes;\n            break;\n          }\n        }\n      }\n    }\n\n    // try adding 8 byte, 8 byte pairs\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (!entry.packed && entry.sizeInBytes % 8 === 0) {\n        for (let i2 = i + 1; i2 < model.bufferEntries.length; i2++) {\n          const entry2 = model.bufferEntries[i2];\n          if (!entry2.packed && entry2.sizeInBytes % 8 === 0) {\n            entry.packed = true;\n            entry.offset = currOffset;\n            newEntries.push(entry);\n            currOffset += entry.sizeInBytes;\n            entry2.packed = true;\n            entry2.offset = currOffset;\n            newEntries.push(entry2);\n            currOffset += entry2.sizeInBytes;\n            break;\n          }\n        }\n      }\n    }\n\n    // try adding 8 byte, 4 byte 4 byte triplets\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (!entry.packed && entry.sizeInBytes % 8 === 0) {\n        let found = false;\n        for (let i2 = 0; !found && i2 < model.bufferEntries.length; i2++) {\n          const entry2 = model.bufferEntries[i2];\n          if (!entry2.packed && entry2.sizeInBytes === 4) {\n            for (let i3 = i2 + 1; i3 < model.bufferEntries.length; i3++) {\n              const entry3 = model.bufferEntries[i3];\n              if (!entry3.packed && entry3.sizeInBytes === 4) {\n                entry.packed = true;\n                entry.offset = currOffset;\n                newEntries.push(entry);\n                currOffset += entry.sizeInBytes;\n                entry2.packed = true;\n                entry2.offset = currOffset;\n                newEntries.push(entry2);\n                currOffset += entry2.sizeInBytes;\n                entry3.packed = true;\n                entry3.offset = currOffset;\n                newEntries.push(entry3);\n                currOffset += entry3.sizeInBytes;\n                found = true;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Add anything remaining that is larger than 4 bytes and hope we get lucky.\n    // Likely if there is more than one item added here it will result\n    // in a failed UBO\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (!entry.packed && entry.sizeInBytes > 4) {\n        entry.packed = true;\n        entry.offset = currOffset;\n        newEntries.push(entry);\n        currOffset += entry.sizeInBytes;\n      }\n    }\n\n    // finally add remaining 4 byte items\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (!entry.packed) {\n        entry.packed = true;\n        entry.offset = currOffset;\n        newEntries.push(entry);\n        currOffset += entry.sizeInBytes;\n      }\n    }\n\n    // update entries and entryNames\n    model.bufferEntries = newEntries;\n    model._bufferEntryNames.clear();\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      model._bufferEntryNames.set(model.bufferEntries[i].name, i);\n    }\n    model.sizeInBytes = currOffset;\n    model.sizeInBytes = maxAlignment * Math.ceil(model.sizeInBytes / maxAlignment);\n    model.sortDirty = false;\n  };\n  publicAPI.sendIfNeeded = device => {\n    if (!model.UBO) {\n      const req = {\n        nativeArray: model.Float32Array,\n        usage: BufferUsage.UniformArray,\n        label: model.label\n      };\n      model.UBO = device.getBufferManager().getBuffer(req);\n      model.bindGroupTime.modified();\n      model.sendDirty = false;\n    }\n\n    // send data down if needed\n    if (model.sendDirty) {\n      device.getHandle().queue.writeBuffer(model.UBO.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes);\n      model.sendDirty = false;\n    }\n\n    // always updated as mappers depend on this time\n    // it is more of a sentIfNeededTime\n    model.sendTime.modified();\n  };\n  publicAPI.createView = type => {\n    if (type in model === false) {\n      if (!model.arrayBuffer) {\n        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes);\n      }\n      model[type] = macro.newTypedArray(type, model.arrayBuffer);\n    }\n  };\n  publicAPI.setValue = (name, val) => {\n    publicAPI.sortBufferEntries();\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    if (entry.lastValue !== val) {\n      view[entry.offset / view.BYTES_PER_ELEMENT] = val;\n      model.sendDirty = true;\n    }\n    entry.lastValue = val;\n  };\n  publicAPI.setArray = (name, arr) => {\n    publicAPI.sortBufferEntries();\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    let changed = false;\n    for (let i = 0; i < arr.length; i++) {\n      if (!entry.lastValue || entry.lastValue[i] !== arr[i]) {\n        view[entry.offset / view.BYTES_PER_ELEMENT + i] = arr[i];\n        changed = true;\n      }\n    }\n    if (changed) {\n      model.sendDirty = true;\n      entry.lastValue = [...arr];\n    }\n  };\n  publicAPI.getBindGroupEntry = () => {\n    const foo = {\n      resource: {\n        buffer: model.UBO.getHandle()\n      }\n    };\n    return foo;\n  };\n  publicAPI.getSendTime = () => model.sendTime.getMTime();\n  publicAPI.getShaderCode = (binding, group) => {\n    // sort the entries\n    publicAPI.sortBufferEntries();\n    const lines = [`struct ${model.label}Struct\\n{`];\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      lines.push(`  ${entry.name}: ${entry.type},`);\n    }\n    lines.push(`};\\n@binding(${binding}) @group(${group}) var<uniform> ${model.label}: ${model.label}Struct;`);\n    return lines.join('\\n');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  bufferEntries: null,\n  bufferEntryNames: null,\n  sizeInBytes: 0,\n  label: null,\n  bindGroupLayoutEntry: null,\n  bindGroupEntry: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n\n  // Internal objects\n  model._bufferEntryNames = new Map();\n  model.bufferEntries = [];\n\n  // default UBO desc\n  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {\n    buffer: {\n      type: 'uniform'\n    }\n  };\n  model.sendTime = {};\n  macro.obj(model.sendTime, {\n    mtime: 0\n  });\n  model.bindGroupTime = {};\n  macro.obj(model.bindGroupTime, {\n    mtime: 0\n  });\n  model.sendDirty = true;\n  model.sortDirty = true;\n  macro.get(publicAPI, model, ['binding', 'bindGroupTime']);\n  macro.setGet(publicAPI, model, ['bindGroupLayoutEntry', 'device', 'label', 'sizeInBytes']);\n\n  // Object methods\n  vtkWebGPUUniformBuffer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPUUniformBuffer');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUUniformBuffer$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUUniformBuffer$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}