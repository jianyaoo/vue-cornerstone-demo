{"ast":null,"code":"import { point } from '../math';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\nexport function shouldInterpolate(configuration) {\n  return configuration?.interpolation?.interpolateOnAdd === true || configuration?.interpolation?.interpolateOnEdit === true;\n}\nfunction isEqualByProximity(pointA, pointB) {\n  return point.distanceToPoint(pointA, pointB) < 0.001;\n}\nfunction isEqual(pointA, pointB) {\n  return point.distanceToPoint(pointA, pointB) === 0;\n}\nfunction findMatchIndexes(points, otherPoints) {\n  for (let i = 0; i < points.length; i++) {\n    for (let j = 0; j < otherPoints.length; j++) {\n      if (isEqual(points[i], otherPoints[j])) {\n        return [i, j];\n      }\n    }\n  }\n}\nfunction followingIndex(index, size, direction) {\n  return (index + size + direction) % size;\n}\nfunction circularFindNextIndexBy(listParams, otherListParams, criteria, direction) {\n  const [, indexDelimiter, points] = listParams;\n  const [, otherIndexDelimiter, otherPoints] = otherListParams;\n  const pointsLength = points.length;\n  const otherPointsLength = otherPoints.length;\n  let startIndex = listParams[0];\n  let otherStartIndex = otherListParams[0];\n  if (!points[startIndex] || !otherPoints[otherStartIndex] || !points[indexDelimiter] || !otherPoints[otherIndexDelimiter]) {\n    return [undefined, undefined];\n  }\n  while (startIndex !== indexDelimiter && otherStartIndex !== otherIndexDelimiter) {\n    if (criteria(otherPoints[otherStartIndex], points[startIndex])) {\n      return [startIndex, otherStartIndex];\n    }\n    startIndex = followingIndex(startIndex, pointsLength, direction);\n    otherStartIndex = followingIndex(otherStartIndex, otherPointsLength, direction);\n  }\n  return [undefined, undefined];\n}\nfunction findChangedSegment(points, previousPoints) {\n  const [firstMatchIndex, previousFirstMatchIndex] = findMatchIndexes(points, previousPoints) || [];\n  const toBeNotEqualCriteria = (pointA, pointB) => isEqualByProximity(pointA, pointB) === false;\n  const [lowDiffIndex, lowOtherDiffIndex] = circularFindNextIndexBy([followingIndex(firstMatchIndex, points.length, 1), firstMatchIndex, points], [followingIndex(previousFirstMatchIndex, previousPoints.length, 1), previousFirstMatchIndex, previousPoints], toBeNotEqualCriteria, 1);\n  const [highIndex] = circularFindNextIndexBy([followingIndex(lowDiffIndex, points.length, -1), lowDiffIndex, points], [followingIndex(lowOtherDiffIndex, previousPoints.length, -1), lowOtherDiffIndex, previousPoints], toBeNotEqualCriteria, -1);\n  return [lowDiffIndex, highIndex];\n}\nexport function getInterpolatedPoints(configuration, points, pointsOfReference) {\n  const {\n    interpolation\n  } = configuration;\n  const result = points;\n  if (interpolation) {\n    const {\n      knotsRatioPercentageOnAdd,\n      knotsRatioPercentageOnEdit,\n      interpolateOnAdd = false,\n      interpolateOnEdit = false\n    } = interpolation;\n    const knotsRatioPercentage = pointsOfReference ? knotsRatioPercentageOnEdit : knotsRatioPercentageOnAdd;\n    const isEnabled = pointsOfReference ? interpolateOnEdit : interpolateOnAdd;\n    if (isEnabled) {\n      const [changedIniIndex, changedEndIndex] = pointsOfReference ? findChangedSegment(points, pointsOfReference) : [0, points.length - 1];\n      if (!points[changedIniIndex] || !points[changedEndIndex]) {\n        return points;\n      }\n      return interpolateSegmentPoints(points, changedIniIndex, changedEndIndex, knotsRatioPercentage);\n    }\n  }\n  return result;\n}","map":{"version":3,"names":["point","interpolateSegmentPoints","shouldInterpolate","configuration","interpolation","interpolateOnAdd","interpolateOnEdit","isEqualByProximity","pointA","pointB","distanceToPoint","isEqual","findMatchIndexes","points","otherPoints","i","length","j","followingIndex","index","size","direction","circularFindNextIndexBy","listParams","otherListParams","criteria","indexDelimiter","otherIndexDelimiter","pointsLength","otherPointsLength","startIndex","otherStartIndex","undefined","findChangedSegment","previousPoints","firstMatchIndex","previousFirstMatchIndex","toBeNotEqualCriteria","lowDiffIndex","lowOtherDiffIndex","highIndex","getInterpolatedPoints","pointsOfReference","result","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","knotsRatioPercentage","isEnabled","changedIniIndex","changedEndIndex"],"sources":["../../../../src/utilities/planarFreehandROITool/interpolatePoints.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}