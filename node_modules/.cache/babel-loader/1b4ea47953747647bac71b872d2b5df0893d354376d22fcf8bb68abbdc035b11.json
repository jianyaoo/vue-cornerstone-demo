{"ast":null,"code":"import { m as macro } from '../../macros2.js';\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkPiecewiseFunction methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPiecewiseFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPiecewiseFunction');\n\n  // Return the number of points which specify this function\n  publicAPI.getSize = () => model.nodes.length;\n\n  // Return the type of function stored in object:\n  // Function Types:\n  //    0 : Constant        (No change in slope between end points)\n  //    1 : NonDecreasing   (Always increasing or zero slope)\n  //    2 : NonIncreasing   (Always decreasing or zero slope)\n  //    3 : Varied          (Contains both decreasing and increasing slopes)\n  //    4 : Unknown         (Error condition)\n  //\n  publicAPI.getType = () => {\n    let value;\n    let prevValue = 0.0;\n    let functionType = 0;\n    if (model.nodes.length > 0) {\n      prevValue = model.nodes[0].y;\n    }\n    for (let i = 1; i < model.nodes.length; i++) {\n      value = model.nodes[i].y;\n\n      // Do not change the function type if equal\n      if (value !== prevValue) {\n        if (value > prevValue) {\n          switch (functionType) {\n            case 0:\n            case 1:\n              // NonDecreasing\n              functionType = 1;\n              break;\n            case 2:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        } else {\n          // value < prev_value\n          switch (functionType) {\n            case 0:\n            case 2:\n              // NonIncreasing\n              functionType = 2;\n              break;\n            case 1:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        }\n      }\n      prevValue = value;\n\n      // Exit loop if we find a Varied function\n      if (functionType === 3) {\n        break;\n      }\n    }\n    switch (functionType) {\n      case 0:\n        return 'Constant';\n      case 1:\n        return 'NonDecreasing';\n      case 2:\n        return 'NonIncreasing';\n      case 3:\n      default:\n        return 'Varied';\n    }\n  };\n\n  // Since we no longer store the data in an array, we must\n  // copy out of the vector into an array. No modified check -\n  // could be added if performance is a problem\n  publicAPI.getDataPointer = () => {\n    const size = model.nodes.length;\n    model.function = null;\n    if (size > 0) {\n      model.function = [];\n      for (let i = 0; i < size; i++) {\n        model.function[2 * i] = model.nodes[i].x;\n        model.function[2 * i + 1] = model.nodes[i].y;\n      }\n    }\n    return model.function;\n  };\n\n  // Returns the first point location which starts a non-zero segment of the\n  // function. Note that the value at this point may be zero.\n  publicAPI.getFirstNonZeroValue = () => {\n    // Check if no points specified\n    if (model.nodes.length === 0) {\n      return 0;\n    }\n    let allZero = 1;\n    let x = 0.0;\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].y !== 0.0) {\n        allZero = 0;\n        break;\n      }\n    }\n\n    // If every specified point has a zero value then return\n    // a large value\n    if (allZero) {\n      x = Number.MAX_VALUE;\n    } else if (i > 0) {\n      // A point was found with a non-zero value\n      // Return the value of the point that precedes this one\n      x = model.nodes[i - 1].x;\n    } else if (model.clamping) {\n      // If this is the first point in the function, return its\n      // value is clamping is off, otherwise VTK_DOUBLE_MIN if\n      // clamping is on.\n      x = -Number.MAX_VALUE;\n    } else {\n      x = model.nodes[0].x;\n    }\n    return x;\n  };\n\n  // For a specified index value, get the node parameters\n  publicAPI.getNodeValue = (index, val) => {\n    const size = model.nodes.length;\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].y;\n    val[2] = model.nodes[index].midpoint;\n    val[3] = model.nodes[index].sharpness;\n    return 1;\n  };\n\n  // For a specified index value, get the node parameters\n  publicAPI.setNodeValue = (index, val) => {\n    const size = model.nodes.length;\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    const oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].y = val[1];\n    model.nodes[index].midpoint = val[2];\n    model.nodes[index].sharpness = val[3];\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange();\n      // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n    return 1;\n  };\n\n  // Adds a point to the function. If a duplicate point is inserted\n  // then the function value at that location is set to the new value.\n  // This is the legacy version that assumes midpoint = 0.5 and\n  // sharpness = 0.0\n  publicAPI.addPoint = (x, y) => publicAPI.addPointLong(x, y, 0.5, 0.0);\n\n  // Adds a point to the function and returns the array index of the point.\n  publicAPI.addPointLong = (x, y, midpoint, sharpness) => {\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    // remove any node already at this X location\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    }\n\n    // Create the new node\n    const node = {\n      x,\n      y,\n      midpoint,\n      sharpness\n    };\n\n    // Add it, then sort to get everything in order\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange();\n\n    // Now find this node so we can return the index\n    let i;\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If we didn't find it, something went horribly wrong so\n    // return -1\n    if (i < model.nodes.length) {\n      return i;\n    }\n    return -1;\n  };\n  publicAPI.setNodes = nodes => {\n    if (model.nodes !== nodes) {\n      model.nodes = nodes;\n      publicAPI.sortAndUpdateRange();\n    }\n  };\n\n  // Sort the vector in increasing order, then fill in\n  // the Range\n  publicAPI.sortAndUpdateRange = () => {\n    model.nodes.sort((a, b) => a.x - b.x);\n    const modifiedInvoked = publicAPI.updateRange();\n    // If range is updated, Modified() has been called, don't call it again.\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.updateRange = () => {\n    const oldRange = model.range.slice();\n    const size = model.nodes.length;\n    if (size) {\n      model.range[0] = model.nodes[0].x;\n      model.range[1] = model.nodes[size - 1].x;\n    } else {\n      model.range[0] = 0;\n      model.range[1] = 0;\n    }\n    // If the rage is the same, then no need to call Modified()\n    if (oldRange[0] === model.range[0] && oldRange[1] === model.range[1]) {\n      return false;\n    }\n    publicAPI.modified();\n    return true;\n  };\n\n  // Removes a point from the function. If no point is found then function\n  // remains the same.\n  publicAPI.removePoint = x => {\n    // First find the node since we need to know its\n    // index as our return value\n    let i;\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If the node doesn't exist, we return -1\n    if (i >= model.nodes.length) {\n      return -1;\n    }\n    const retVal = i;\n\n    // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n    let modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n    return retVal;\n  };\n\n  // Removes all points from the function.\n  publicAPI.removeAllPoints = () => {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  };\n\n  // Add in end points of line and remove any points between them\n  // Legacy method with no way to specify midpoint and sharpness\n  publicAPI.addSegment = (x1, y1, x2, y2) => {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    // Now add the points\n    publicAPI.addPoint(x1, y1, 0.5, 0.0);\n    publicAPI.addPoint(x2, y2, 0.5, 0.0);\n  };\n\n  // Return the value of the function at a position\n  publicAPI.getValue = x => {\n    const table = [];\n    publicAPI.getTable(x, x, 1, table);\n    return table[0];\n  };\n\n  // Remove all points outside the range, and make sure a point\n  // exists at each end of the range. Used as a convenience method\n  // for transfer function editors\n  publicAPI.adjustRange = range => {\n    if (range.length < 2) {\n      return 0;\n    }\n    const functionRange = publicAPI.getRange();\n\n    // Make sure we have points at each end of the range\n    if (functionRange[0] < range[0]) {\n      publicAPI.addPoint(range[0], publicAPI.getValue(range[0]));\n    } else {\n      publicAPI.addPoint(range[0], publicAPI.getValue(functionRange[0]));\n    }\n    if (functionRange[1] > range[1]) {\n      publicAPI.addPoint(range[1], publicAPI.getValue(range[1]));\n    } else {\n      publicAPI.addPoint(range[1], publicAPI.getValue(functionRange[1]));\n    }\n\n    // Remove all points out-of-range\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n    publicAPI.sortAndUpdateRange();\n    return 1;\n  };\n\n  //--------------------------------------------------------------------------\n  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {\n    const d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.findMinimumXDistance = () => {\n    const size = model.nodes.length;\n    if (size < 2) {\n      return -1.0;\n    }\n    let distance = model.nodes[1].x - model.nodes[0].x;\n    for (let i = 0; i < size - 1; i++) {\n      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n    return distance;\n  };\n\n  // Returns a table of function values evaluated at regular intervals\n  /* eslint-disable prefer-destructuring */\n  /* eslint-disable no-continue */\n  publicAPI.getTable = function (xStart, xEnd, size, table) {\n    let stride = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    let i;\n    let idx = 0;\n    const numNodes = model.nodes.length;\n\n    // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n    let lastValue = 0.0;\n    if (numNodes !== 0) {\n      lastValue = model.nodes[numNodes - 1].y;\n    }\n    let x = 0.0;\n    let x1 = 0.0;\n    let x2 = 0.0;\n    let y1 = 0.0;\n    let y2 = 0.0;\n    let midpoint = 0.0;\n    let sharpness = 0.0;\n\n    // For each table entry\n    for (i = 0; i < size; i++) {\n      // Find our location in the table\n      const tidx = stride * i;\n\n      // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n      if (size > 1) {\n        x = xStart + i / (size - 1.0) * (xEnd - xStart);\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      }\n\n      // Do we need to move to the next node?\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++;\n        // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n          y1 = model.nodes[idx - 1].y;\n          y2 = model.nodes[idx].y;\n\n          // We only need the previous midpoint and sharpness\n          // since these control this region\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness;\n\n          // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      }\n\n      // Are we at the end? If so, just use the last value\n      if (idx >= numNodes) {\n        table[tidx] = model.clamping ? lastValue : 0.0;\n      } else if (idx === 0) {\n        // Are we before the first node? If so, duplicate this nodes values\n        table[tidx] = model.clamping ? model.nodes[0].y : 0.0;\n      } else {\n        // Otherwise, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        let s = (x - x1) / (x2 - x1);\n\n        // Readjust based on the midpoint - linear adjustment\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        }\n\n        // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = y1;\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = y2;\n            continue;\n          }\n        }\n\n        // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          table[tidx] = (1 - s) * y1 + s * y2;\n          continue;\n        }\n\n        // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n        if (s < 0.5) {\n          s = 0.5 * (s * 2) ** (1.0 + 10 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10 * sharpness);\n        }\n\n        // Compute some coefficients we will need for the hermite curve\n        const ss = s * s;\n        const sss = ss * s;\n        const h1 = 2 * sss - 3 * ss + 1;\n        const h2 = -2 * sss + 3 * ss;\n        const h3 = sss - 2 * ss + s;\n        const h4 = sss - ss;\n\n        // Use one slope for both end points\n        const slope = y2 - y1;\n        const t = (1.0 - sharpness) * slope;\n\n        // Compute the value\n        table[tidx] = h1 * y1 + h2 * y2 + h3 * t + h4 * t;\n\n        // Final error check to make sure we don't go outside\n        // the Y range\n        const min = y1 < y2 ? y1 : y2;\n        const max = y1 > y2 ? y1 : y2;\n        table[tidx] = table[tidx] < min ? min : table[tidx];\n        table[tidx] = table[tidx] > max ? max : table[tidx];\n      }\n    }\n  };\n}\n/* eslint-enable prefer-destructuring */\n/* eslint-enable no-continue */\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // model.function = NULL;\n  range: [0, 0],\n  clamping: true,\n  allowDuplicateScalars: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n\n  // Internal objects initialization\n  model.nodes = [];\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['allowDuplicateScalars', 'clamping']);\n  macro.setArray(publicAPI, model, ['range'], 2);\n\n  // Create get macros for array\n  macro.getArray(publicAPI, model, ['range']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkPiecewiseFunction(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPiecewiseFunction');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPiecewiseFunction$1 = {\n  newInstance,\n  extend\n};\nexport { vtkPiecewiseFunction$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkErrorMacro","vtkPiecewiseFunction","publicAPI","model","classHierarchy","push","getSize","nodes","length","getType","value","prevValue","functionType","y","i","getDataPointer","size","function","x","getFirstNonZeroValue","allZero","Number","MAX_VALUE","clamping","getNodeValue","index","val","midpoint","sharpness","setNodeValue","oldX","sortAndUpdateRange","modified","addPoint","addPointLong","allowDuplicateScalars","removePoint","node","setNodes","sort","a","b","modifiedInvoked","updateRange","oldRange","range","slice","retVal","splice","removeAllPoints","addSegment","x1","y1","x2","y2","getValue","table","getTable","adjustRange","functionRange","getRange","estimateMinNumberOfSamples","d","findMinimumXDistance","Math","ceil","distance","currentDist","xStart","xEnd","stride","arguments","undefined","idx","numNodes","lastValue","tidx","s","ss","sss","h1","h2","h3","h4","slope","t","min","max","DEFAULT_VALUES","extend","initialValues","Object","assign","obj","setGet","setArray","getArray","newInstance","vtkPiecewiseFunction$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Common/DataModel/PiecewiseFunction.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkPiecewiseFunction methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPiecewiseFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPiecewiseFunction');\n\n  // Return the number of points which specify this function\n  publicAPI.getSize = () => model.nodes.length;\n\n  // Return the type of function stored in object:\n  // Function Types:\n  //    0 : Constant        (No change in slope between end points)\n  //    1 : NonDecreasing   (Always increasing or zero slope)\n  //    2 : NonIncreasing   (Always decreasing or zero slope)\n  //    3 : Varied          (Contains both decreasing and increasing slopes)\n  //    4 : Unknown         (Error condition)\n  //\n  publicAPI.getType = () => {\n    let value;\n    let prevValue = 0.0;\n    let functionType = 0;\n    if (model.nodes.length > 0) {\n      prevValue = model.nodes[0].y;\n    }\n    for (let i = 1; i < model.nodes.length; i++) {\n      value = model.nodes[i].y;\n\n      // Do not change the function type if equal\n      if (value !== prevValue) {\n        if (value > prevValue) {\n          switch (functionType) {\n            case 0:\n            case 1:\n              // NonDecreasing\n              functionType = 1;\n              break;\n            case 2:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        } else {\n          // value < prev_value\n          switch (functionType) {\n            case 0:\n            case 2:\n              // NonIncreasing\n              functionType = 2;\n              break;\n            case 1:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        }\n      }\n      prevValue = value;\n\n      // Exit loop if we find a Varied function\n      if (functionType === 3) {\n        break;\n      }\n    }\n    switch (functionType) {\n      case 0:\n        return 'Constant';\n      case 1:\n        return 'NonDecreasing';\n      case 2:\n        return 'NonIncreasing';\n      case 3:\n      default:\n        return 'Varied';\n    }\n  };\n\n  // Since we no longer store the data in an array, we must\n  // copy out of the vector into an array. No modified check -\n  // could be added if performance is a problem\n  publicAPI.getDataPointer = () => {\n    const size = model.nodes.length;\n    model.function = null;\n    if (size > 0) {\n      model.function = [];\n      for (let i = 0; i < size; i++) {\n        model.function[2 * i] = model.nodes[i].x;\n        model.function[2 * i + 1] = model.nodes[i].y;\n      }\n    }\n    return model.function;\n  };\n\n  // Returns the first point location which starts a non-zero segment of the\n  // function. Note that the value at this point may be zero.\n  publicAPI.getFirstNonZeroValue = () => {\n    // Check if no points specified\n    if (model.nodes.length === 0) {\n      return 0;\n    }\n    let allZero = 1;\n    let x = 0.0;\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].y !== 0.0) {\n        allZero = 0;\n        break;\n      }\n    }\n\n    // If every specified point has a zero value then return\n    // a large value\n    if (allZero) {\n      x = Number.MAX_VALUE;\n    } else if (i > 0) {\n      // A point was found with a non-zero value\n      // Return the value of the point that precedes this one\n      x = model.nodes[i - 1].x;\n    } else if (model.clamping) {\n      // If this is the first point in the function, return its\n      // value is clamping is off, otherwise VTK_DOUBLE_MIN if\n      // clamping is on.\n      x = -Number.MAX_VALUE;\n    } else {\n      x = model.nodes[0].x;\n    }\n    return x;\n  };\n\n  // For a specified index value, get the node parameters\n  publicAPI.getNodeValue = (index, val) => {\n    const size = model.nodes.length;\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].y;\n    val[2] = model.nodes[index].midpoint;\n    val[3] = model.nodes[index].sharpness;\n    return 1;\n  };\n\n  // For a specified index value, get the node parameters\n  publicAPI.setNodeValue = (index, val) => {\n    const size = model.nodes.length;\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    const oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].y = val[1];\n    model.nodes[index].midpoint = val[2];\n    model.nodes[index].sharpness = val[3];\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange();\n      // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n    return 1;\n  };\n\n  // Adds a point to the function. If a duplicate point is inserted\n  // then the function value at that location is set to the new value.\n  // This is the legacy version that assumes midpoint = 0.5 and\n  // sharpness = 0.0\n  publicAPI.addPoint = (x, y) => publicAPI.addPointLong(x, y, 0.5, 0.0);\n\n  // Adds a point to the function and returns the array index of the point.\n  publicAPI.addPointLong = (x, y, midpoint, sharpness) => {\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    // remove any node already at this X location\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    }\n\n    // Create the new node\n    const node = {\n      x,\n      y,\n      midpoint,\n      sharpness\n    };\n\n    // Add it, then sort to get everything in order\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange();\n\n    // Now find this node so we can return the index\n    let i;\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If we didn't find it, something went horribly wrong so\n    // return -1\n    if (i < model.nodes.length) {\n      return i;\n    }\n    return -1;\n  };\n  publicAPI.setNodes = nodes => {\n    if (model.nodes !== nodes) {\n      model.nodes = nodes;\n      publicAPI.sortAndUpdateRange();\n    }\n  };\n\n  // Sort the vector in increasing order, then fill in\n  // the Range\n  publicAPI.sortAndUpdateRange = () => {\n    model.nodes.sort((a, b) => a.x - b.x);\n    const modifiedInvoked = publicAPI.updateRange();\n    // If range is updated, Modified() has been called, don't call it again.\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.updateRange = () => {\n    const oldRange = model.range.slice();\n    const size = model.nodes.length;\n    if (size) {\n      model.range[0] = model.nodes[0].x;\n      model.range[1] = model.nodes[size - 1].x;\n    } else {\n      model.range[0] = 0;\n      model.range[1] = 0;\n    }\n    // If the rage is the same, then no need to call Modified()\n    if (oldRange[0] === model.range[0] && oldRange[1] === model.range[1]) {\n      return false;\n    }\n    publicAPI.modified();\n    return true;\n  };\n\n  // Removes a point from the function. If no point is found then function\n  // remains the same.\n  publicAPI.removePoint = x => {\n    // First find the node since we need to know its\n    // index as our return value\n    let i;\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If the node doesn't exist, we return -1\n    if (i >= model.nodes.length) {\n      return -1;\n    }\n    const retVal = i;\n\n    // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n    let modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n    return retVal;\n  };\n\n  // Removes all points from the function.\n  publicAPI.removeAllPoints = () => {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  };\n\n  // Add in end points of line and remove any points between them\n  // Legacy method with no way to specify midpoint and sharpness\n  publicAPI.addSegment = (x1, y1, x2, y2) => {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    // Now add the points\n    publicAPI.addPoint(x1, y1, 0.5, 0.0);\n    publicAPI.addPoint(x2, y2, 0.5, 0.0);\n  };\n\n  // Return the value of the function at a position\n  publicAPI.getValue = x => {\n    const table = [];\n    publicAPI.getTable(x, x, 1, table);\n    return table[0];\n  };\n\n  // Remove all points outside the range, and make sure a point\n  // exists at each end of the range. Used as a convenience method\n  // for transfer function editors\n  publicAPI.adjustRange = range => {\n    if (range.length < 2) {\n      return 0;\n    }\n    const functionRange = publicAPI.getRange();\n\n    // Make sure we have points at each end of the range\n    if (functionRange[0] < range[0]) {\n      publicAPI.addPoint(range[0], publicAPI.getValue(range[0]));\n    } else {\n      publicAPI.addPoint(range[0], publicAPI.getValue(functionRange[0]));\n    }\n    if (functionRange[1] > range[1]) {\n      publicAPI.addPoint(range[1], publicAPI.getValue(range[1]));\n    } else {\n      publicAPI.addPoint(range[1], publicAPI.getValue(functionRange[1]));\n    }\n\n    // Remove all points out-of-range\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n    publicAPI.sortAndUpdateRange();\n    return 1;\n  };\n\n  //--------------------------------------------------------------------------\n  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {\n    const d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.findMinimumXDistance = () => {\n    const size = model.nodes.length;\n    if (size < 2) {\n      return -1.0;\n    }\n    let distance = model.nodes[1].x - model.nodes[0].x;\n    for (let i = 0; i < size - 1; i++) {\n      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n    return distance;\n  };\n\n  // Returns a table of function values evaluated at regular intervals\n  /* eslint-disable prefer-destructuring */\n  /* eslint-disable no-continue */\n  publicAPI.getTable = function (xStart, xEnd, size, table) {\n    let stride = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    let i;\n    let idx = 0;\n    const numNodes = model.nodes.length;\n\n    // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n    let lastValue = 0.0;\n    if (numNodes !== 0) {\n      lastValue = model.nodes[numNodes - 1].y;\n    }\n    let x = 0.0;\n    let x1 = 0.0;\n    let x2 = 0.0;\n    let y1 = 0.0;\n    let y2 = 0.0;\n    let midpoint = 0.0;\n    let sharpness = 0.0;\n\n    // For each table entry\n    for (i = 0; i < size; i++) {\n      // Find our location in the table\n      const tidx = stride * i;\n\n      // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n      if (size > 1) {\n        x = xStart + i / (size - 1.0) * (xEnd - xStart);\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      }\n\n      // Do we need to move to the next node?\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++;\n        // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n          y1 = model.nodes[idx - 1].y;\n          y2 = model.nodes[idx].y;\n\n          // We only need the previous midpoint and sharpness\n          // since these control this region\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness;\n\n          // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      }\n\n      // Are we at the end? If so, just use the last value\n      if (idx >= numNodes) {\n        table[tidx] = model.clamping ? lastValue : 0.0;\n      } else if (idx === 0) {\n        // Are we before the first node? If so, duplicate this nodes values\n        table[tidx] = model.clamping ? model.nodes[0].y : 0.0;\n      } else {\n        // Otherwise, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        let s = (x - x1) / (x2 - x1);\n\n        // Readjust based on the midpoint - linear adjustment\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        }\n\n        // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = y1;\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = y2;\n            continue;\n          }\n        }\n\n        // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          table[tidx] = (1 - s) * y1 + s * y2;\n          continue;\n        }\n\n        // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n        if (s < 0.5) {\n          s = 0.5 * (s * 2) ** (1.0 + 10 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10 * sharpness);\n        }\n\n        // Compute some coefficients we will need for the hermite curve\n        const ss = s * s;\n        const sss = ss * s;\n        const h1 = 2 * sss - 3 * ss + 1;\n        const h2 = -2 * sss + 3 * ss;\n        const h3 = sss - 2 * ss + s;\n        const h4 = sss - ss;\n\n        // Use one slope for both end points\n        const slope = y2 - y1;\n        const t = (1.0 - sharpness) * slope;\n\n        // Compute the value\n        table[tidx] = h1 * y1 + h2 * y2 + h3 * t + h4 * t;\n\n        // Final error check to make sure we don't go outside\n        // the Y range\n        const min = y1 < y2 ? y1 : y2;\n        const max = y1 > y2 ? y1 : y2;\n        table[tidx] = table[tidx] < min ? min : table[tidx];\n        table[tidx] = table[tidx] > max ? max : table[tidx];\n      }\n    }\n  };\n}\n/* eslint-enable prefer-destructuring */\n/* eslint-enable no-continue */\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // model.function = NULL;\n  range: [0, 0],\n  clamping: true,\n  allowDuplicateScalars: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n\n  // Internal objects initialization\n  model.nodes = [];\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['allowDuplicateScalars', 'clamping']);\n  macro.setArray(publicAPI, model, ['range'], 2);\n\n  // Create get macros for array\n  macro.getArray(publicAPI, model, ['range']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkPiecewiseFunction(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPiecewiseFunction');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPiecewiseFunction$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkPiecewiseFunction$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}