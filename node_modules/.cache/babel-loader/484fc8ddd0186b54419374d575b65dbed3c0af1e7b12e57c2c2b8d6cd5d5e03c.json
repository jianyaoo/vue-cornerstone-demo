{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { mat3, mat4 } from 'gl-matrix';\nimport { n as newInstance$1, o as obj, e as setGet, g as get, c as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkHelper from './Helper.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLSkybox methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLSkybox(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLSkybox');\n\n  // Builds myself.\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      const ren = model._openGLRenderer.getRenderable();\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());\n    }\n  };\n  publicAPI.queryPass = (prepass, renderPass) => {\n    if (prepass) {\n      if (!model.renderable || !model.renderable.getVisibility()) {\n        return;\n      }\n      renderPass.incrementOpaqueActorCount();\n    }\n  };\n  publicAPI.opaquePass = (prepass, renderPass) => {\n    if (prepass && !model._openGLRenderer.getSelector()) {\n      publicAPI.updateBufferObjects();\n      model.context.depthMask(true);\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.tris.getProgram());\n      model.openGLTexture.render(model._openGLRenderWindow);\n      const texUnit = model.openGLTexture.getTextureUnit();\n      model.tris.getProgram().setUniformi('sbtexture', texUnit);\n      const ren = model._openGLRenderer.getRenderable();\n      const keyMats = model.openGLCamera.getKeyMatrices(ren);\n      const imat = new Float64Array(16);\n      mat4.invert(imat, keyMats.wcpc);\n      model.tris.getProgram().setUniformMatrix('IMCPCMatrix', imat);\n      if (model.lastFormat === 'box') {\n        const camPos = ren.getActiveCamera().getPosition();\n        model.tris.getProgram().setUniform3f('camPos', camPos[0], camPos[1], camPos[2]);\n      }\n      model.tris.getVAO().bind();\n\n      // draw polygons\n      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n      model.tris.getVAO().release();\n      model.openGLTexture.deactivate();\n    }\n  };\n  publicAPI.updateBufferObjects = () => {\n    // build the VBO if needed, only happens once\n    if (!model.tris.getCABO().getElementCount()) {\n      const ptsArray = new Float32Array(12);\n      for (let i = 0; i < 4; i++) {\n        ptsArray[i * 3] = i % 2 * 2 - 1.0;\n        ptsArray[i * 3 + 1] = i > 1 ? 1.0 : -1.0;\n        ptsArray[i * 3 + 2] = 1.0;\n      }\n      const points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: ptsArray\n      });\n      points.setName('points');\n      const cellArray = new Uint16Array(8);\n      cellArray[0] = 3;\n      cellArray[1] = 0;\n      cellArray[2] = 1;\n      cellArray[3] = 3;\n      cellArray[4] = 3;\n      cellArray[5] = 0;\n      cellArray[6] = 3;\n      cellArray[7] = 2;\n      const cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: cellArray\n      });\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n        points,\n        cellOffset: 0\n      });\n    }\n\n    // update the program?\n    if (model.renderable.getFormat() !== model.lastFormat) {\n      model.lastFormat = model.renderable.getFormat();\n      if (model.lastFormat === 'box') {\n        // we invert Y below because opengl is messed up!\n        // Cube Maps have been specified to follow the RenderMan\n        // specification (for whatever reason), and RenderMan\n        // assumes the images' origin being in the upper left,\n        // contrary to the usual OpenGL behaviour of having the\n        // image origin in the lower left. That's why things get\n        // swapped in the Y direction. It totally breaks with the usual\n        // OpenGL semantics and doesn't make sense at all.\n        // But now we're stuck with it.  From\n        // https://stackoverflow.com/questions/11685608/convention-of-faces-in-opengl-cubemapping\n        //\n        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec3 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = wpos.xyz/wpos.w;\n             }`, `//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec3 TexCoords;\n             uniform samplerCube sbtexture;\n             uniform vec3 camPos;\n             void main () {\n               // skybox looks from inside out\n               // which means we have to adjust\n               // our tcoords. Otherwise text would\n               // be flipped\n               vec3 tc = normalize(TexCoords - camPos);\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\n               {\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\n               }\n               else\n               {\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\n               }\n               gl_FragData[0] = textureCube(sbtexture, tc);\n             }`, ''));\n      }\n      if (model.lastFormat === 'background') {\n        // maps the texture to the window\n        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec2 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\n             }`, `//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec2 TexCoords;\n             uniform sampler2D sbtexture;\n             void main () {\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\n             }`, ''));\n      }\n      model.tris.getShaderSourceTime().modified();\n      model.tris.getVAO().bind();\n      if (!model.tris.getVAO().addAttributeArray(model.tris.getProgram(), model.tris.getCABO(), 'vertexMC', model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n        vtkErrorMacro('Error setting vertexMC in shader VAO.');\n      }\n    }\n\n    // set/update the texture map if needed\n    const tmaps = model.renderable.getTextures();\n    if (!tmaps.length) {\n      vtkErrorMacro('vtkSkybox requires a texture map');\n    }\n    if (model.openGLTexture.getRenderable() !== tmaps[0]) {\n      model.openGLTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.openGLTexture.setRenderable(tmaps[0]);\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.openGLTexture = vtkOpenGLTexture.newInstance();\n  model.tris = vtkHelper.newInstance();\n  model.keyMatrixTime = {};\n  obj(model.keyMatrixTime, {\n    mtime: 0\n  });\n  model.keyMatrices = {\n    normalMatrix: mat3.identity(new Float64Array(9)),\n    mcwc: mat4.identity(new Float64Array(16))\n  };\n\n  // Build VTK API\n  setGet(publicAPI, model, ['context']);\n  get(publicAPI, model, ['activeTextures']);\n\n  // Object methods\n  vtkOpenGLSkybox(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkSkybox = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkSkybox', newInstance);\nexport { vtkSkybox as default, extend, newInstance };","map":{"version":3,"names":["mat3","mat4","n","newInstance$1","o","obj","e","setGet","g","get","c","macro","vtkDataArray","vtkHelper","vtkViewNode","vtkOpenGLTexture","Representation","registerOverride","vtkErrorMacro","vtkOpenGLSkybox","publicAPI","model","classHierarchy","push","buildPass","prepass","_openGLRenderer","getFirstAncestorOfType","_openGLRenderWindow","getParent","context","getContext","tris","setOpenGLRenderWindow","openGLTexture","ren","getRenderable","openGLCamera","getViewNodeFor","getActiveCamera","queryPass","renderPass","renderable","getVisibility","incrementOpaqueActorCount","opaquePass","getSelector","updateBufferObjects","depthMask","getShaderCache","readyShaderProgram","getProgram","render","texUnit","getTextureUnit","setUniformi","keyMats","getKeyMatrices","imat","Float64Array","invert","wcpc","setUniformMatrix","lastFormat","camPos","getPosition","setUniform3f","getVAO","bind","drawArrays","TRIANGLES","getCABO","getElementCount","release","deactivate","ptsArray","Float32Array","i","points","newInstance","numberOfComponents","values","setName","cellArray","Uint16Array","cells","createVBO","SURFACE","cellOffset","getFormat","setProgram","readyShaderProgramArray","getShaderSourceTime","modified","addAttributeArray","getVertexOffset","getStride","FLOAT","FALSE","tmaps","getTextures","length","releaseGraphicsResources","setRenderable","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","keyMatrixTime","mtime","keyMatrices","normalMatrix","identity","mcwc","vtkSkybox","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/OpenGL/Skybox.js"],"sourcesContent":["import { mat3, mat4 } from 'gl-matrix';\nimport { n as newInstance$1, o as obj, e as setGet, g as get, c as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkHelper from './Helper.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLSkybox methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLSkybox(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLSkybox');\n\n  // Builds myself.\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      const ren = model._openGLRenderer.getRenderable();\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());\n    }\n  };\n  publicAPI.queryPass = (prepass, renderPass) => {\n    if (prepass) {\n      if (!model.renderable || !model.renderable.getVisibility()) {\n        return;\n      }\n      renderPass.incrementOpaqueActorCount();\n    }\n  };\n  publicAPI.opaquePass = (prepass, renderPass) => {\n    if (prepass && !model._openGLRenderer.getSelector()) {\n      publicAPI.updateBufferObjects();\n      model.context.depthMask(true);\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.tris.getProgram());\n      model.openGLTexture.render(model._openGLRenderWindow);\n      const texUnit = model.openGLTexture.getTextureUnit();\n      model.tris.getProgram().setUniformi('sbtexture', texUnit);\n      const ren = model._openGLRenderer.getRenderable();\n      const keyMats = model.openGLCamera.getKeyMatrices(ren);\n      const imat = new Float64Array(16);\n      mat4.invert(imat, keyMats.wcpc);\n      model.tris.getProgram().setUniformMatrix('IMCPCMatrix', imat);\n      if (model.lastFormat === 'box') {\n        const camPos = ren.getActiveCamera().getPosition();\n        model.tris.getProgram().setUniform3f('camPos', camPos[0], camPos[1], camPos[2]);\n      }\n      model.tris.getVAO().bind();\n\n      // draw polygons\n      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n      model.tris.getVAO().release();\n      model.openGLTexture.deactivate();\n    }\n  };\n  publicAPI.updateBufferObjects = () => {\n    // build the VBO if needed, only happens once\n    if (!model.tris.getCABO().getElementCount()) {\n      const ptsArray = new Float32Array(12);\n      for (let i = 0; i < 4; i++) {\n        ptsArray[i * 3] = i % 2 * 2 - 1.0;\n        ptsArray[i * 3 + 1] = i > 1 ? 1.0 : -1.0;\n        ptsArray[i * 3 + 2] = 1.0;\n      }\n      const points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: ptsArray\n      });\n      points.setName('points');\n      const cellArray = new Uint16Array(8);\n      cellArray[0] = 3;\n      cellArray[1] = 0;\n      cellArray[2] = 1;\n      cellArray[3] = 3;\n      cellArray[4] = 3;\n      cellArray[5] = 0;\n      cellArray[6] = 3;\n      cellArray[7] = 2;\n      const cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: cellArray\n      });\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n        points,\n        cellOffset: 0\n      });\n    }\n\n    // update the program?\n    if (model.renderable.getFormat() !== model.lastFormat) {\n      model.lastFormat = model.renderable.getFormat();\n      if (model.lastFormat === 'box') {\n        // we invert Y below because opengl is messed up!\n        // Cube Maps have been specified to follow the RenderMan\n        // specification (for whatever reason), and RenderMan\n        // assumes the images' origin being in the upper left,\n        // contrary to the usual OpenGL behaviour of having the\n        // image origin in the lower left. That's why things get\n        // swapped in the Y direction. It totally breaks with the usual\n        // OpenGL semantics and doesn't make sense at all.\n        // But now we're stuck with it.  From\n        // https://stackoverflow.com/questions/11685608/convention-of-faces-in-opengl-cubemapping\n        //\n        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec3 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = wpos.xyz/wpos.w;\n             }`, `//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec3 TexCoords;\n             uniform samplerCube sbtexture;\n             uniform vec3 camPos;\n             void main () {\n               // skybox looks from inside out\n               // which means we have to adjust\n               // our tcoords. Otherwise text would\n               // be flipped\n               vec3 tc = normalize(TexCoords - camPos);\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\n               {\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\n               }\n               else\n               {\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\n               }\n               gl_FragData[0] = textureCube(sbtexture, tc);\n             }`, ''));\n      }\n      if (model.lastFormat === 'background') {\n        // maps the texture to the window\n        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec2 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\n             }`, `//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec2 TexCoords;\n             uniform sampler2D sbtexture;\n             void main () {\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\n             }`, ''));\n      }\n      model.tris.getShaderSourceTime().modified();\n      model.tris.getVAO().bind();\n      if (!model.tris.getVAO().addAttributeArray(model.tris.getProgram(), model.tris.getCABO(), 'vertexMC', model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n        vtkErrorMacro('Error setting vertexMC in shader VAO.');\n      }\n    }\n\n    // set/update the texture map if needed\n    const tmaps = model.renderable.getTextures();\n    if (!tmaps.length) {\n      vtkErrorMacro('vtkSkybox requires a texture map');\n    }\n    if (model.openGLTexture.getRenderable() !== tmaps[0]) {\n      model.openGLTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.openGLTexture.setRenderable(tmaps[0]);\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.openGLTexture = vtkOpenGLTexture.newInstance();\n  model.tris = vtkHelper.newInstance();\n  model.keyMatrixTime = {};\n  obj(model.keyMatrixTime, {\n    mtime: 0\n  });\n  model.keyMatrices = {\n    normalMatrix: mat3.identity(new Float64Array(9)),\n    mcwc: mat4.identity(new Float64Array(16))\n  };\n\n  // Build VTK API\n  setGet(publicAPI, model, ['context']);\n  get(publicAPI, model, ['activeTextures']);\n\n  // Object methods\n  vtkOpenGLSkybox(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkSkybox = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkSkybox', newInstance);\n\nexport { vtkSkybox as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}