{"ast":null,"code":"import vtkShaderProgram from './ShaderProgram.js';\nfunction implementReplaceShaderCoincidentOffset(publicAPI, model) {\n  publicAPI.replaceShaderCoincidentOffset = (shaders, ren, actor) => {\n    const cp = publicAPI.getCoincidentParameters(ren, actor);\n\n    // if we need an offset handle it here\n    // The value of .000016 is suitable for depth buffers\n    // of at least 16 bit depth. We do not query the depth\n    // right now because we would need some mechanism to\n    // cache the result taking into account FBO changes etc.\n    if (cp && (cp.factor !== 0.0 || cp.offset !== 0.0)) {\n      let FSSource = shaders.Fragment;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Coincident::Dec', ['uniform float cfactor;', 'uniform float coffset;']).result;\n      if (model.context.getExtension('EXT_frag_depth')) {\n        if (cp.factor !== 0.0) {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', ['float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));', '//VTK::UniformFlow::Impl'], false).result;\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;').result;\n        } else {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;').result;\n        }\n      }\n      if (model._openGLRenderWindow.getWebgl2()) {\n        if (cp.factor !== 0.0) {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', ['float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));', '//VTK::UniformFlow::Impl'], false).result;\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;').result;\n        } else {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;').result;\n        }\n      }\n      shaders.Fragment = FSSource;\n    }\n  };\n}\nfunction implementBuildShadersWithReplacements(publicAPI, model) {\n  publicAPI.applyShaderReplacements = (shaders, viewSpec, pre) => {\n    let shaderReplacements = null;\n    if (viewSpec) {\n      shaderReplacements = viewSpec.ShaderReplacements;\n    }\n    if (shaderReplacements) {\n      for (let i = 0; i < shaderReplacements.length; i++) {\n        const currReplacement = shaderReplacements[i];\n        if (pre && currReplacement.replaceFirst || !pre && !currReplacement.replaceFirst) {\n          const shaderType = currReplacement.shaderType;\n          const ssrc = shaders[shaderType];\n          const substituteRes = vtkShaderProgram.substitute(ssrc, currReplacement.originalValue, currReplacement.replacementValue, currReplacement.replaceAll);\n          shaders[shaderType] = substituteRes.result;\n        }\n      }\n    }\n  };\n  publicAPI.buildShaders = (shaders, ren, actor) => {\n    publicAPI.getReplacedShaderTemplate(shaders, ren, actor);\n    model.lastRenderPassShaderReplacement = model.currentRenderPass ? model.currentRenderPass.getShaderReplacement() : null;\n\n    // apply any renderPassReplacements\n    if (model.lastRenderPassShaderReplacement) {\n      model.lastRenderPassShaderReplacement(shaders);\n    }\n    const openGLSpec = model.renderable.getViewSpecificProperties().OpenGL;\n\n    // user specified pre replacements\n    publicAPI.applyShaderReplacements(shaders, openGLSpec, true);\n    publicAPI.replaceShaderValues(shaders, ren, actor);\n\n    // user specified post replacements\n    publicAPI.applyShaderReplacements(shaders, openGLSpec);\n  };\n  publicAPI.getReplacedShaderTemplate = (shaders, ren, actor) => {\n    const openGLSpecProp = model.renderable.getViewSpecificProperties().OpenGL;\n    publicAPI.getShaderTemplate(shaders, ren, actor);\n    let vertexShaderCode = shaders.Vertex;\n    if (openGLSpecProp) {\n      const vertexSpecProp = openGLSpecProp.VertexShaderCode;\n      if (vertexSpecProp !== undefined && vertexSpecProp !== '') {\n        vertexShaderCode = vertexSpecProp;\n      }\n    }\n    shaders.Vertex = vertexShaderCode;\n    let fragmentShaderCode = shaders.Fragment;\n    if (openGLSpecProp) {\n      const fragmentSpecProp = openGLSpecProp.FragmentShaderCode;\n      if (fragmentSpecProp !== undefined && fragmentSpecProp !== '') {\n        fragmentShaderCode = fragmentSpecProp;\n      }\n    }\n    shaders.Fragment = fragmentShaderCode;\n    let geometryShaderCode = shaders.Geometry;\n    if (openGLSpecProp) {\n      const geometrySpecProp = openGLSpecProp.GeometryShaderCode;\n      if (geometrySpecProp !== undefined) {\n        geometryShaderCode = geometrySpecProp;\n      }\n    }\n    shaders.Geometry = geometryShaderCode;\n  };\n}\nvar vtkReplacementShaderMapper = {\n  implementReplaceShaderCoincidentOffset,\n  implementBuildShadersWithReplacements\n};\nexport { vtkReplacementShaderMapper as default };","map":{"version":3,"names":["vtkShaderProgram","implementReplaceShaderCoincidentOffset","publicAPI","model","replaceShaderCoincidentOffset","shaders","ren","actor","cp","getCoincidentParameters","factor","offset","FSSource","Fragment","substitute","result","context","getExtension","_openGLRenderWindow","getWebgl2","implementBuildShadersWithReplacements","applyShaderReplacements","viewSpec","pre","shaderReplacements","ShaderReplacements","i","length","currReplacement","replaceFirst","shaderType","ssrc","substituteRes","originalValue","replacementValue","replaceAll","buildShaders","getReplacedShaderTemplate","lastRenderPassShaderReplacement","currentRenderPass","getShaderReplacement","openGLSpec","renderable","getViewSpecificProperties","OpenGL","replaceShaderValues","openGLSpecProp","getShaderTemplate","vertexShaderCode","Vertex","vertexSpecProp","VertexShaderCode","undefined","fragmentShaderCode","fragmentSpecProp","FragmentShaderCode","geometryShaderCode","Geometry","geometrySpecProp","GeometryShaderCode","vtkReplacementShaderMapper","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/OpenGL/ReplacementShaderMapper.js"],"sourcesContent":["import vtkShaderProgram from './ShaderProgram.js';\n\nfunction implementReplaceShaderCoincidentOffset(publicAPI, model) {\n  publicAPI.replaceShaderCoincidentOffset = (shaders, ren, actor) => {\n    const cp = publicAPI.getCoincidentParameters(ren, actor);\n\n    // if we need an offset handle it here\n    // The value of .000016 is suitable for depth buffers\n    // of at least 16 bit depth. We do not query the depth\n    // right now because we would need some mechanism to\n    // cache the result taking into account FBO changes etc.\n    if (cp && (cp.factor !== 0.0 || cp.offset !== 0.0)) {\n      let FSSource = shaders.Fragment;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Coincident::Dec', ['uniform float cfactor;', 'uniform float coffset;']).result;\n      if (model.context.getExtension('EXT_frag_depth')) {\n        if (cp.factor !== 0.0) {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', ['float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));', '//VTK::UniformFlow::Impl'], false).result;\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;').result;\n        } else {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;').result;\n        }\n      }\n      if (model._openGLRenderWindow.getWebgl2()) {\n        if (cp.factor !== 0.0) {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', ['float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));', '//VTK::UniformFlow::Impl'], false).result;\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;').result;\n        } else {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;').result;\n        }\n      }\n      shaders.Fragment = FSSource;\n    }\n  };\n}\nfunction implementBuildShadersWithReplacements(publicAPI, model) {\n  publicAPI.applyShaderReplacements = (shaders, viewSpec, pre) => {\n    let shaderReplacements = null;\n    if (viewSpec) {\n      shaderReplacements = viewSpec.ShaderReplacements;\n    }\n    if (shaderReplacements) {\n      for (let i = 0; i < shaderReplacements.length; i++) {\n        const currReplacement = shaderReplacements[i];\n        if (pre && currReplacement.replaceFirst || !pre && !currReplacement.replaceFirst) {\n          const shaderType = currReplacement.shaderType;\n          const ssrc = shaders[shaderType];\n          const substituteRes = vtkShaderProgram.substitute(ssrc, currReplacement.originalValue, currReplacement.replacementValue, currReplacement.replaceAll);\n          shaders[shaderType] = substituteRes.result;\n        }\n      }\n    }\n  };\n  publicAPI.buildShaders = (shaders, ren, actor) => {\n    publicAPI.getReplacedShaderTemplate(shaders, ren, actor);\n    model.lastRenderPassShaderReplacement = model.currentRenderPass ? model.currentRenderPass.getShaderReplacement() : null;\n\n    // apply any renderPassReplacements\n    if (model.lastRenderPassShaderReplacement) {\n      model.lastRenderPassShaderReplacement(shaders);\n    }\n    const openGLSpec = model.renderable.getViewSpecificProperties().OpenGL;\n\n    // user specified pre replacements\n    publicAPI.applyShaderReplacements(shaders, openGLSpec, true);\n    publicAPI.replaceShaderValues(shaders, ren, actor);\n\n    // user specified post replacements\n    publicAPI.applyShaderReplacements(shaders, openGLSpec);\n  };\n  publicAPI.getReplacedShaderTemplate = (shaders, ren, actor) => {\n    const openGLSpecProp = model.renderable.getViewSpecificProperties().OpenGL;\n    publicAPI.getShaderTemplate(shaders, ren, actor);\n    let vertexShaderCode = shaders.Vertex;\n    if (openGLSpecProp) {\n      const vertexSpecProp = openGLSpecProp.VertexShaderCode;\n      if (vertexSpecProp !== undefined && vertexSpecProp !== '') {\n        vertexShaderCode = vertexSpecProp;\n      }\n    }\n    shaders.Vertex = vertexShaderCode;\n    let fragmentShaderCode = shaders.Fragment;\n    if (openGLSpecProp) {\n      const fragmentSpecProp = openGLSpecProp.FragmentShaderCode;\n      if (fragmentSpecProp !== undefined && fragmentSpecProp !== '') {\n        fragmentShaderCode = fragmentSpecProp;\n      }\n    }\n    shaders.Fragment = fragmentShaderCode;\n    let geometryShaderCode = shaders.Geometry;\n    if (openGLSpecProp) {\n      const geometrySpecProp = openGLSpecProp.GeometryShaderCode;\n      if (geometrySpecProp !== undefined) {\n        geometryShaderCode = geometrySpecProp;\n      }\n    }\n    shaders.Geometry = geometryShaderCode;\n  };\n}\nvar vtkReplacementShaderMapper = {\n  implementReplaceShaderCoincidentOffset,\n  implementBuildShadersWithReplacements\n};\n\nexport { vtkReplacementShaderMapper as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}