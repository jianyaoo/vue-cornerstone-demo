"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEllipseInPoint = exports.thresholdInsideCircle = exports.fillInsideCircle = exports.CIRCLE_THRESHOLD_STRATEGY = exports.CIRCLE_STRATEGY = exports.fillOutsideCircle = void 0;
const gl_matrix_1 = require("gl-matrix");
const core_1 = require("@cornerstonejs/core");
const ellipse_1 = require("../../../utilities/math/ellipse");
const boundingBox_1 = require("../../../utilities/boundingBox");
const BrushStrategy_1 = __importDefault(require("./BrushStrategy"));
const enums_1 = require("../../../enums");
const compositions_1 = __importDefault(require("./compositions"));
const sphere_1 = require("../../../utilities/math/sphere");
const { transformWorldToIndex, isEqual } = core_1.utilities;
const initializeCircle = {
    [enums_1.StrategyCallbacks.Initialize]: (operationData) => {
        const { points, imageVoxelManager: imageVoxelManager, viewport, segmentationImageData, segmentationVoxelManager: segmentationVoxelManager, } = operationData;
        if (!points) {
            return;
        }
        const center = gl_matrix_1.vec3.fromValues(0, 0, 0);
        points.forEach((point) => {
            gl_matrix_1.vec3.add(center, center, point);
        });
        gl_matrix_1.vec3.scale(center, center, 1 / points.length);
        operationData.centerWorld = center;
        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        const [topLeftCanvas, bottomRightCanvas] = (0, ellipse_1.getCanvasEllipseCorners)(canvasCoordinates);
        const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
        const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
        const circleCornersIJK = points.map((world) => {
            return transformWorldToIndex(segmentationImageData, world);
        });
        const boundsIJK = (0, boundingBox_1.getBoundingBoxAroundShapeIJK)(circleCornersIJK, segmentationImageData.getDimensions());
        segmentationVoxelManager.boundsIJK = boundsIJK;
        imageVoxelManager.isInObject = createPointInEllipse({
            topLeftWorld,
            bottomRightWorld,
            center,
        });
    },
};
function createPointInEllipse(worldInfo) {
    const { topLeftWorld, bottomRightWorld, center } = worldInfo;
    const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;
    const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;
    const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;
    const radius = Math.max(xRadius, yRadius, zRadius);
    if (isEqual(xRadius, radius) &&
        isEqual(yRadius, radius) &&
        isEqual(zRadius, radius)) {
        const sphereObj = {
            center,
            radius,
            radius2: radius * radius,
        };
        return (pointLPS) => (0, sphere_1.pointInSphere)(sphereObj, pointLPS);
    }
    const ellipseObj = {
        center: center,
        xRadius,
        yRadius,
        zRadius,
    };
    const { precalculated } = (0, ellipse_1.precalculatePointInEllipse)(ellipseObj, {});
    return precalculated;
}
exports.createEllipseInPoint = createPointInEllipse;
const CIRCLE_STRATEGY = new BrushStrategy_1.default('Circle', compositions_1.default.regionFill, compositions_1.default.setValue, initializeCircle, compositions_1.default.determineSegmentIndex, compositions_1.default.preview);
exports.CIRCLE_STRATEGY = CIRCLE_STRATEGY;
const CIRCLE_THRESHOLD_STRATEGY = new BrushStrategy_1.default('CircleThreshold', compositions_1.default.regionFill, compositions_1.default.setValue, initializeCircle, compositions_1.default.determineSegmentIndex, compositions_1.default.dynamicThreshold, compositions_1.default.threshold, compositions_1.default.preview, compositions_1.default.islandRemoval);
exports.CIRCLE_THRESHOLD_STRATEGY = CIRCLE_THRESHOLD_STRATEGY;
const fillInsideCircle = CIRCLE_STRATEGY.strategyFunction;
exports.fillInsideCircle = fillInsideCircle;
const thresholdInsideCircle = CIRCLE_THRESHOLD_STRATEGY.strategyFunction;
exports.thresholdInsideCircle = thresholdInsideCircle;
function fillOutsideCircle() {
    throw new Error('Not yet implemented');
}
exports.fillOutsideCircle = fillOutsideCircle;
//# sourceMappingURL=fillCircle.js.map