import { getEnabledElement } from '@cornerstonejs/core';
import { BaseTool } from '../base';
import { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';
import triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';
import { getActiveSegmentationRepresentation } from '../../stateManagement/segmentation/activeSegmentation';
import RepresentationTypes from '../../enums/SegmentationRepresentations';
import { setActiveSegmentIndex } from '../../stateManagement/segmentation/segmentIndex';
import { getHoveredContourSegmentationAnnotation, getSegmentAtLabelmapBorder, getSegmentAtWorldPoint, } from '../../utilities/segmentation';
import { state } from '../../store';
import SegmentationRepresentations from '../../enums/SegmentationRepresentations';
class SegmentSelectTool extends BaseTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            hoverTimeout: 100,
            mode: SegmentSelectTool.SelectMode.Border,
            searchRadius: 6,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.mouseMoveCallback = (evt) => {
            if (this.hoverTimer) {
                clearTimeout(this.hoverTimer);
            }
            this.hoverTimer = setTimeout(() => {
                this._setActiveSegment(evt);
                this.hoverTimer = null;
            }, this.configuration.hoverTimeout);
            return true;
        };
        this.onSetToolEnabled = () => {
            this.onSetToolActive();
        };
        this.onSetToolActive = () => {
            this.hoverTimer = null;
        };
        this.onSetToolDisabled = () => {
            this.hoverTimer = null;
        };
        this.hoverTimer = null;
    }
    static { this.SelectMode = {
        Inside: 'Inside',
        Border: 'Border',
    }; }
    _setActiveSegment(evt = {}) {
        if (state.isInteractingWithTool) {
            return;
        }
        const { element, currentPoints } = evt.detail;
        const worldPoint = currentPoints.world;
        const enabledElement = getEnabledElement(element);
        if (!enabledElement) {
            return;
        }
        const { viewport } = enabledElement;
        const activeSegmentationReps = getActiveSegmentationRepresentation(this.toolGroupId);
        if (!activeSegmentationReps) {
            return;
        }
        const supportedTypes = [
            RepresentationTypes.Labelmap,
            RepresentationTypes.Contour,
        ];
        if (supportedTypes.includes(activeSegmentationReps.type)) {
            this._setActiveSegmentForType(activeSegmentationReps, worldPoint, viewport);
        }
        else {
            console.warn('SegmentSelectTool does not support the current segmentation type.');
        }
    }
    _setActiveSegmentForType(activeSegmentationReps, worldPoint, viewport) {
        const imageDataInfo = viewport.getImageData();
        if (!imageDataInfo) {
            return;
        }
        const { segmentationId, type } = activeSegmentationReps;
        let hoveredSegmentIndex;
        if (this.configuration.mode === SegmentSelectTool.SelectMode.Inside) {
            hoveredSegmentIndex = getSegmentAtWorldPoint(segmentationId, worldPoint, {
                viewport,
            });
        }
        else {
            switch (type) {
                case SegmentationRepresentations.Labelmap:
                    hoveredSegmentIndex = getSegmentAtLabelmapBorder(segmentationId, worldPoint, {
                        viewport,
                        searchRadius: this.configuration.searchRadius,
                    });
                    break;
                case SegmentationRepresentations.Contour:
                    hoveredSegmentIndex =
                        getHoveredContourSegmentationAnnotation(segmentationId);
                    break;
            }
        }
        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {
            return;
        }
        setActiveSegmentIndex(segmentationId, hoveredSegmentIndex);
        const renderingEngine = viewport.getRenderingEngine();
        const viewportIds = renderingEngine.getViewports().map((v) => v.id);
        triggerSegmentationModified(segmentationId);
        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);
    }
}
SegmentSelectTool.toolName = 'SegmentSelectTool';
export default SegmentSelectTool;
//# sourceMappingURL=SegmentSelectTool.js.map