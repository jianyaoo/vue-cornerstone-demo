{"ast":null,"code":"import { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { getVoxelOverlap, processVolumes } from './utilities';\nfunction thresholdSegmentationByRange(segmentationVolume, segmentationIndex, thresholdVolumeInformation, overlapType) {\n  const scalarData = segmentationVolume.getScalarData();\n  const {\n    baseVolumeIdx,\n    volumeInfoList\n  } = processVolumes(segmentationVolume, thresholdVolumeInformation);\n  volumeInfoList.forEach(volumeInfo => {\n    const {\n      volumeSize\n    } = volumeInfo;\n    if (volumeSize === scalarData.length) {\n      _handleSameSizeVolume(scalarData, segmentationIndex, volumeInfo);\n    } else {\n      _handleDifferentSizeVolume(scalarData, segmentationIndex, volumeInfo, volumeInfoList, baseVolumeIdx, overlapType);\n    }\n  });\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n  return segmentationVolume;\n}\nfunction _handleDifferentSizeVolume(scalarData, segmentationIndex, volumeInfo, volumeInfoList, baseVolumeIdx, overlapType) {\n  const {\n    imageData,\n    lower,\n    upper,\n    dimensions\n  } = volumeInfo;\n  let total, overlaps, range;\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const overlapBounds = getVoxelOverlap(imageData, dimensions, volumeInfoList[baseVolumeIdx].spacing, volumeInfoList[baseVolumeIdx].imageData.getPoint(i));\n      const callbackOverlap = ({\n        value\n      }) => {\n        total = total + 1;\n        if (value >= range.lower && value <= range.upper) {\n          overlaps = overlaps + 1;\n        }\n      };\n      total = 0;\n      overlaps = 0;\n      range = {\n        lower,\n        upper\n      };\n      let overlapTest = false;\n      pointInShapeCallback(imageData, () => true, callbackOverlap, overlapBounds);\n      overlapTest = overlapType === 0 ? overlaps > 0 : overlaps === total;\n      scalarData[i] = overlapTest ? segmentationIndex : 0;\n    }\n  }\n  return {\n    total,\n    range,\n    overlaps\n  };\n}\nfunction _handleSameSizeVolume(scalarData, segmentationIndex, volumeInfo) {\n  const {\n    referenceValues,\n    lower,\n    upper\n  } = volumeInfo;\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const value = referenceValues[i];\n      scalarData[i] = value >= lower && value <= upper ? segmentationIndex : 0;\n    }\n  }\n}\nexport default thresholdSegmentationByRange;","map":{"version":3,"names":["pointInShapeCallback","triggerSegmentationDataModified","getVoxelOverlap","processVolumes","thresholdSegmentationByRange","segmentationVolume","segmentationIndex","thresholdVolumeInformation","overlapType","scalarData","getScalarData","baseVolumeIdx","volumeInfoList","forEach","volumeInfo","volumeSize","length","_handleSameSizeVolume","_handleDifferentSizeVolume","volumeId","imageData","lower","upper","dimensions","total","overlaps","range","i","overlapBounds","spacing","getPoint","callbackOverlap","value","overlapTest","referenceValues"],"sources":["../../../../src/utilities/segmentation/thresholdSegmentationByRange.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}