{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { vec3, mat4 } from 'gl-matrix';\nimport * as d3 from 'd3-scale';\nimport { N as normalize2D, O as nearestPowerOfTwo } from '../../Common/Core/Math/index.js';\nimport { m as macro } from '../../macros2.js';\nimport vtkActor from './Actor.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkMapper from './Mapper.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkTexture from './Texture.js';\n\n// ----------------------------------------------------------------------------\n// vtkCubeAxesActor\n// ----------------------------------------------------------------------------\n// faces are -x x -y y -z z\n// point 0 is 0,0,0 and then +x fastest changing, +y then +z\nconst faceNormals = [[-1, 0, 0], [1, 0, 0], [0, -1, 0], [0, 1, 0], [0, 0, -1], [0, 0, 1]];\nconst faceEdges = [[8, 7, 11, 3], [9, 1, 10, 5], [4, 9, 0, 8], [2, 11, 6, 10], [0, 3, 2, 1], [4, 5, 6, 7]];\nconst edgePoints = [[0, 1], [1, 3], [2, 3], [0, 2], [4, 5], [5, 7], [6, 7], [4, 6], [0, 4], [1, 5], [3, 7], [2, 6]];\nconst edgeAxes = [0, 1, 0, 1, 0, 1, 0, 1, 2, 2, 2, 2];\nconst faceAxes = [[1, 2], [1, 2], [0, 2], [0, 2], [0, 1], [0, 1]];\n\n//\n// Developer note: This class is broken into the main class and a helper\n// class. The main class holds view independent properties (those properties\n// that do not change as the view's resolution/aspect ratio change). The\n// helper class is instantiated one per view and holds properties that can\n// depend on view specific values such as resolution. The helper class code\n// could have been left to the View specific implementation (such as\n// vtkWebGPUCubeAxesActor) but is instead placed here to it can be shared by\n// multiple rendering backends.\n//\n\n// some shared temp variables to reduce heap allocs\nconst ptv3 = new Float64Array(3);\nconst pt2v3 = new Float64Array(3);\nconst tmpv3 = new Float64Array(3);\nconst tmp2v3 = new Float64Array(3);\nconst xDir = new Float64Array(3);\nconst yDir = new Float64Array(3);\nconst invmat = new Float64Array(16);\nfunction applyTextStyle(ctx, style) {\n  ctx.strokeStyle = style.strokeColor;\n  ctx.lineWidth = style.strokeSize;\n  ctx.fillStyle = style.fontColor;\n  ctx.font = `${style.fontStyle} ${style.fontSize}px ${style.fontFamily}`;\n}\n\n// many properties of this actor depend on the API specific view The main\n// dependency being the resolution as that drives what font sizes to use.\n// Bacause of this we need to do some of the calculations in a API specific\n// subclass. But... we don't want a lot of duplicated code between WebGL and\n// WebGPU for example so we have this helper class, that is designed to be\n// fairly API independent so that API specific views can call this to do\n// most of the work.\nfunction vtkCubeAxesActorHelper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCubeAxesActorHelper');\n  publicAPI.setRenderable = renderable => {\n    if (model.renderable === renderable) {\n      return;\n    }\n    model.renderable = renderable;\n    model.tmActor.addTexture(model.renderable.getTmTexture());\n    model.tmActor.setProperty(renderable.getProperty());\n    model.tmActor.setParentProp(renderable);\n    publicAPI.modified();\n  };\n\n  // called by updateTexturePolyData\n  publicAPI.createPolyDataForOneLabel = (text, pos, cmat, imat, dir, offset, results) => {\n    const value = model.renderable.get_tmAtlas().get(text);\n    if (!value) {\n      return;\n    }\n    const coords = model.renderable.getTextPolyData().getPoints().getData();\n\n    // compute pixel to distance factors\n    const size = model.lastSize;\n    ptv3[0] = coords[pos * 3];\n    ptv3[1] = coords[pos * 3 + 1];\n    ptv3[2] = coords[pos * 3 + 2];\n    vec3.transformMat4(tmpv3, ptv3, cmat);\n    // moving 0.1 in NDC\n    tmpv3[0] += 0.1;\n    vec3.transformMat4(pt2v3, tmpv3, imat);\n    // results in WC move of\n    vec3.subtract(xDir, pt2v3, ptv3);\n    tmpv3[0] -= 0.1;\n    tmpv3[1] += 0.1;\n    vec3.transformMat4(pt2v3, tmpv3, imat);\n    // results in WC move of\n    vec3.subtract(yDir, pt2v3, ptv3);\n    for (let i = 0; i < 3; i++) {\n      xDir[i] /= 0.5 * 0.1 * size[0];\n      yDir[i] /= 0.5 * 0.1 * size[1];\n    }\n\n    // have to find the four corners of the texture polygon for this label\n    // convert anchor point to View Coords\n    let ptIdx = results.ptIdx;\n    let cellIdx = results.cellIdx;\n    ptv3[0] = coords[pos * 3];\n    ptv3[1] = coords[pos * 3 + 1];\n    ptv3[2] = coords[pos * 3 + 2];\n    // horizontal left, right, or middle alignment based on dir[0]\n    if (dir[0] < -0.5) {\n      vec3.scale(tmpv3, xDir, dir[0] * offset - value.width);\n    } else if (dir[0] > 0.5) {\n      vec3.scale(tmpv3, xDir, dir[0] * offset);\n    } else {\n      vec3.scale(tmpv3, xDir, dir[0] * offset - value.width / 2.0);\n    }\n    vec3.add(ptv3, ptv3, tmpv3);\n    vec3.scale(tmpv3, yDir, dir[1] * offset - value.height / 2.0);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[0];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];\n    ptIdx++;\n    vec3.scale(tmpv3, xDir, value.width);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[2];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];\n    ptIdx++;\n    vec3.scale(tmpv3, yDir, value.height);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[4];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];\n    ptIdx++;\n    vec3.scale(tmpv3, xDir, value.width);\n    vec3.subtract(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[6];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];\n    ptIdx++;\n\n    // add the two triangles to represent the quad\n    results.polys[cellIdx * 4] = 3;\n    results.polys[cellIdx * 4 + 1] = ptIdx - 4;\n    results.polys[cellIdx * 4 + 2] = ptIdx - 3;\n    results.polys[cellIdx * 4 + 3] = ptIdx - 2;\n    cellIdx++;\n    results.polys[cellIdx * 4] = 3;\n    results.polys[cellIdx * 4 + 1] = ptIdx - 4;\n    results.polys[cellIdx * 4 + 2] = ptIdx - 2;\n    results.polys[cellIdx * 4 + 3] = ptIdx - 1;\n    results.ptIdx += 4;\n    results.cellIdx += 2;\n  };\n\n  // update the polydata associated with drawing the text labels\n  // specifically the quads used for each label and their associated tcoords\n  // etc. This changes every time the camera viewpoint changes\n  publicAPI.updateTexturePolyData = () => {\n    const cmat = model.camera.getCompositeProjectionMatrix(model.lastAspectRatio, -1, 1);\n    mat4.transpose(cmat, cmat);\n\n    // update the polydata\n    const numLabels = model.renderable.getTextValues().length;\n    const numPts = numLabels * 4;\n    const numTris = numLabels * 2;\n    const points = new Float64Array(numPts * 3);\n    const polys = new Uint16Array(numTris * 4);\n    const tcoords = new Float32Array(numPts * 2);\n    mat4.invert(invmat, cmat);\n    const results = {\n      ptIdx: 0,\n      cellIdx: 0,\n      polys,\n      points,\n      tcoords\n    };\n    let ptIdx = 0;\n    let textIdx = 0;\n    let axisIdx = 0;\n    const coords = model.renderable.getTextPolyData().getPoints().getData();\n    const textValues = model.renderable.getTextValues();\n    while (ptIdx < coords.length / 3) {\n      // compute the direction to move out\n      ptv3[0] = coords[ptIdx * 3];\n      ptv3[1] = coords[ptIdx * 3 + 1];\n      ptv3[2] = coords[ptIdx * 3 + 2];\n      vec3.transformMat4(tmpv3, ptv3, cmat);\n      ptv3[0] = coords[ptIdx * 3 + 3];\n      ptv3[1] = coords[ptIdx * 3 + 4];\n      ptv3[2] = coords[ptIdx * 3 + 5];\n      vec3.transformMat4(tmp2v3, ptv3, cmat);\n      vec3.subtract(tmpv3, tmpv3, tmp2v3);\n      const dir = [tmpv3[0], tmpv3[1]];\n      normalize2D(dir);\n\n      // write the axis label\n      publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getAxisTitlePixelOffset(), results);\n      ptIdx += 2;\n      textIdx++;\n\n      // write the tick labels\n      for (let t = 0; t < model.renderable.getTickCounts()[axisIdx]; t++) {\n        publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getTickLabelPixelOffset(), results);\n        ptIdx++;\n        textIdx++;\n      }\n      axisIdx++;\n    }\n    const tcoordDA = vtkDataArray.newInstance({\n      numberOfComponents: 2,\n      values: tcoords,\n      name: 'TextureCoordinates'\n    });\n    model.tmPolyData.getPointData().setTCoords(tcoordDA);\n    model.tmPolyData.getPoints().setData(points, 3);\n    model.tmPolyData.getPoints().modified();\n    model.tmPolyData.getPolys().setData(polys, 1);\n    model.tmPolyData.getPolys().modified();\n    model.tmPolyData.modified();\n  };\n  publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {\n    // has the size changed?\n    if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {\n      model.lastSize[0] = size[0];\n      model.lastSize[1] = size[1];\n      model.lastAspectRatio = size[0] / size[1];\n      model.forceUpdate = true;\n    }\n    model.camera = camera;\n\n    // compute bounds for label quads whenever the camera changes\n    publicAPI.updateTexturePolyData();\n  };\n}\nconst newCubeAxesActorHelper = macro.newInstance(function (publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    renderable: null\n  };\n  Object.assign(model, {}, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  model.tmPolyData = vtkPolyData.newInstance();\n  model.tmMapper = vtkMapper.newInstance();\n  model.tmMapper.setInputData(model.tmPolyData);\n  model.tmActor = vtkActor.newInstance({\n    parentProp: publicAPI\n  });\n  model.tmActor.setMapper(model.tmMapper);\n  macro.setGet(publicAPI, model, ['renderable']);\n  macro.get(publicAPI, model, ['lastSize', 'lastAspectRatio', 'axisTextStyle', 'tickTextStyle', 'tmActor', 'ticks']);\n  model.forceUpdate = false;\n  model.lastRedrawTime = {};\n  macro.obj(model.lastRedrawTime, {\n    mtime: 0\n  });\n  model.lastRebuildTime = {};\n  macro.obj(model.lastRebuildTime, {\n    mtime: 0\n  });\n  model.lastSize = [-1, -1];\n\n  // internal variables\n  model.lastTickBounds = [];\n  vtkCubeAxesActorHelper(publicAPI, model);\n}, 'vtkCubeAxesActorHelper');\nfunction vtkCubeAxesActor(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCubeAxesActor');\n  publicAPI.setCamera = cam => {\n    if (model.camera === cam) {\n      return;\n    }\n    if (model.cameraModifiedSub) {\n      model.cameraModifiedSub.unsubscribe();\n      model.cameraModifiedSub = null;\n    }\n    model.camera = cam;\n    if (cam) {\n      model.cameraModifiedSub = cam.onModified(publicAPI.update);\n    }\n    publicAPI.update();\n    publicAPI.modified();\n  };\n\n  // estimate from a camera model what faces to draw\n  // return true if the list of faces to draw has changed\n  publicAPI.computeFacesToDraw = () => {\n    const cmat = model.camera.getViewMatrix();\n    mat4.transpose(cmat, cmat);\n    let changed = false;\n    const length = vtkBoundingBox.getDiagonalLength(model.dataBounds);\n    const faceDot = Math.sin(model.faceVisibilityAngle * Math.PI / 180.0);\n    for (let f = 0; f < 6; f++) {\n      let drawit = false;\n      const faceAxis = Math.floor(f / 2);\n      const otherAxis1 = (faceAxis + 1) % 3;\n      const otherAxis2 = (faceAxis + 2) % 3;\n      // only for non degenerate axes\n      if (model.dataBounds[otherAxis1 * 2] !== model.dataBounds[otherAxis1 * 2 + 1] && model.dataBounds[otherAxis2 * 2] !== model.dataBounds[otherAxis2 * 2 + 1]) {\n        // for each face transform the center and off center to get a direction vector\n        ptv3[faceAxis] = model.dataBounds[f] - 0.1 * length * faceNormals[f][faceAxis];\n        ptv3[otherAxis1] = 0.5 * (model.dataBounds[otherAxis1 * 2] + model.dataBounds[otherAxis1 * 2 + 1]);\n        ptv3[otherAxis2] = 0.5 * (model.dataBounds[otherAxis2 * 2] + model.dataBounds[otherAxis2 * 2 + 1]);\n        vec3.transformMat4(tmpv3, ptv3, cmat);\n        ptv3[faceAxis] = model.dataBounds[f];\n        vec3.transformMat4(tmp2v3, ptv3, cmat);\n        vec3.subtract(tmpv3, tmp2v3, tmpv3);\n        vec3.normalize(tmpv3, tmpv3);\n        // tmpv3 now holds the face normal vector\n        drawit = tmpv3[2] > faceDot;\n        // for perspctive we need the view direction to the plane\n        if (!model.camera.getParallelProjection()) {\n          vec3.normalize(tmp2v3, tmp2v3);\n          drawit = vec3.dot(tmp2v3, tmpv3) > faceDot;\n        }\n      }\n      if (drawit !== model.lastFacesToDraw[f]) {\n        model.lastFacesToDraw[f] = drawit;\n        changed = true;\n      }\n    }\n    return changed;\n  };\n\n  // update the polydata that represents the boundingd edges and gridlines\n  publicAPI.updatePolyData = (facesToDraw, edgesToDraw, ticks) => {\n    // compute the number of points and lines required\n    let numPts = 0;\n    let numLines = 0;\n    numPts += 8; // always start with the 8 cube points\n\n    // count edgesToDraw\n    let numEdgesToDraw = 0;\n    for (let e = 0; e < 12; e++) {\n      if (edgesToDraw[e] > 0) {\n        numEdgesToDraw++;\n      }\n    }\n    numLines += numEdgesToDraw;\n\n    // add values for gridlines\n    if (model.gridLines) {\n      for (let f = 0; f < 6; f++) {\n        if (facesToDraw[f]) {\n          numPts += ticks[faceAxes[f][0]].length * 2 + ticks[faceAxes[f][1]].length * 2;\n          numLines += ticks[faceAxes[f][0]].length + ticks[faceAxes[f][1]].length;\n        }\n      }\n    }\n\n    // now allocate the memory\n    const points = new Float64Array(numPts * 3);\n    const lines = new Uint32Array(numLines * 3);\n    let ptIdx = 0;\n    let lineIdx = 0;\n\n    // add the 8 corner points\n    for (let z = 0; z < 2; z++) {\n      for (let y = 0; y < 2; y++) {\n        for (let x = 0; x < 2; x++) {\n          points[ptIdx * 3] = model.dataBounds[x];\n          points[ptIdx * 3 + 1] = model.dataBounds[2 + y];\n          points[ptIdx * 3 + 2] = model.dataBounds[4 + z];\n          ptIdx++;\n        }\n      }\n    }\n\n    // draw the edges\n    for (let e = 0; e < 12; e++) {\n      if (edgesToDraw[e] > 0) {\n        lines[lineIdx * 3] = 2;\n        lines[lineIdx * 3 + 1] = edgePoints[e][0];\n        lines[lineIdx * 3 + 2] = edgePoints[e][1];\n        lineIdx++;\n      }\n    }\n\n    // now handle gridlines\n    // grid lines are tick[axis1] + ticks[axes2] lines each having two points\n    // for simplicity we don;t worry about duplicating points, this is tiny\n\n    if (model.gridLines) {\n      // for each visible face\n      // add the points\n      for (let f = 0; f < 6; f++) {\n        if (facesToDraw[f]) {\n          const faceIdx = Math.floor(f / 2);\n          let aticks = ticks[faceAxes[f][0]];\n          for (let t = 0; t < aticks.length; t++) {\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2];\n            ptIdx++;\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2 + 1];\n            ptIdx++;\n            lines[lineIdx * 3] = 2;\n            lines[lineIdx * 3 + 1] = ptIdx - 2;\n            lines[lineIdx * 3 + 2] = ptIdx - 1;\n            lineIdx++;\n          }\n          aticks = ticks[faceAxes[f][1]];\n          for (let t = 0; t < aticks.length; t++) {\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2];\n            ptIdx++;\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2 + 1];\n            ptIdx++;\n            lines[lineIdx * 3] = 2;\n            lines[lineIdx * 3 + 1] = ptIdx - 2;\n            lines[lineIdx * 3 + 2] = ptIdx - 1;\n            lineIdx++;\n          }\n        }\n      }\n    }\n    model.polyData.getPoints().setData(points, 3);\n    model.polyData.getPoints().modified();\n    model.polyData.getLines().setData(lines, 1);\n    model.polyData.getLines().modified();\n    model.polyData.modified();\n  };\n\n  // update the data that represents where to put the labels\n  // in world coordinates. This only changes when faces to draw changes\n  // of dataBounds changes\n  publicAPI.updateTextData = (facesToDraw, edgesToDraw, ticks, tickStrings) => {\n    // count outside edgesToDraw\n    let textPointCount = 0;\n    for (let e = 0; e < 12; e++) {\n      if (edgesToDraw[e] === 1) {\n        textPointCount += 2;\n        textPointCount += ticks[edgeAxes[e]].length;\n      }\n    }\n    const points = model.polyData.getPoints().getData();\n    const textPoints = new Float64Array(textPointCount * 3);\n    let ptIdx = 0;\n    let textIdx = 0;\n    let axisCount = 0;\n    for (let f = 0; f < 6; f++) {\n      if (facesToDraw[f]) {\n        for (let e = 0; e < 4; e++) {\n          const edgeIdx = faceEdges[f][e];\n          if (edgesToDraw[edgeIdx] === 1) {\n            const edgeAxis = edgeAxes[edgeIdx];\n            // add a middle point on the edge\n            const ptIdx1 = edgePoints[edgeIdx][0] * 3;\n            const ptIdx2 = edgePoints[edgeIdx][1] * 3;\n            textPoints[ptIdx * 3] = 0.5 * (points[ptIdx1] + points[ptIdx2]);\n            textPoints[ptIdx * 3 + 1] = 0.5 * (points[ptIdx1 + 1] + points[ptIdx2 + 1]);\n            textPoints[ptIdx * 3 + 2] = 0.5 * (points[ptIdx1 + 2] + points[ptIdx2 + 2]);\n            ptIdx++;\n            // add a middle face point, we use this to\n            // move the labels away from the edge in the right direction\n            const faceIdx = Math.floor(f / 2);\n            textPoints[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            textPoints[ptIdx * 3 + faceAxes[f][0]] = 0.5 * (model.dataBounds[faceAxes[f][0] * 2] + model.dataBounds[faceAxes[f][0] * 2 + 1]);\n            textPoints[ptIdx * 3 + faceAxes[f][1]] = 0.5 * (model.dataBounds[faceAxes[f][1] * 2] + model.dataBounds[faceAxes[f][1] * 2 + 1]);\n            ptIdx++;\n            // set the text\n            model.textValues[textIdx] = model.axisLabels[edgeAxis];\n            textIdx++;\n\n            // now add the tick marks along the edgeAxis\n            const otherAxis1 = (edgeAxis + 1) % 3;\n            const otherAxis2 = (edgeAxis + 2) % 3;\n            const aticks = ticks[edgeAxis];\n            const atickStrings = tickStrings[edgeAxis];\n            model.tickCounts[axisCount] = aticks.length;\n            for (let t = 0; t < aticks.length; t++) {\n              textPoints[ptIdx * 3 + edgeAxis] = aticks[t];\n              textPoints[ptIdx * 3 + otherAxis1] = points[ptIdx1 + otherAxis1];\n              textPoints[ptIdx * 3 + otherAxis2] = points[ptIdx1 + otherAxis2];\n              ptIdx++;\n              // set the text\n              model.textValues[textIdx] = atickStrings[t];\n              textIdx++;\n            }\n            axisCount++;\n          }\n        }\n      }\n    }\n    model.textPolyData.getPoints().setData(textPoints, 3);\n    model.textPolyData.modified();\n  };\n\n  // main method to rebuild the cube axes, gets called on camera modify\n  // and changes to key members\n  publicAPI.update = () => {\n    // Can't do anything if we don't have a camera...\n    if (!model.camera) {\n      return;\n    }\n\n    // compute what faces to draw\n    const facesChanged = publicAPI.computeFacesToDraw();\n    const facesToDraw = model.lastFacesToDraw;\n\n    // have the bounds changed?\n    let boundsChanged = false;\n    for (let i = 0; i < 6; i++) {\n      if (model.dataBounds[i] !== model.lastTickBounds[i]) {\n        boundsChanged = true;\n        model.lastTickBounds[i] = model.dataBounds[i];\n      }\n    }\n\n    // did something significant change? If so rebuild a lot of things\n    if (facesChanged || boundsChanged || model.forceUpdate) {\n      // compute the edges to draw\n      // for each drawn face, mark edges, all single mark edges we draw\n      const edgesToDraw = new Array(12).fill(0);\n      for (let f = 0; f < 6; f++) {\n        if (facesToDraw[f]) {\n          for (let e = 0; e < 4; e++) {\n            edgesToDraw[faceEdges[f][e]]++;\n          }\n        }\n      }\n\n      // compute tick marks for axes\n      const ticks = [];\n      const tickStrings = [];\n      for (let i = 0; i < 3; i++) {\n        const scale = d3.scaleLinear().domain([model.dataBounds[i * 2], model.dataBounds[i * 2 + 1]]);\n        ticks[i] = scale.ticks(5);\n        const format = scale.tickFormat(5);\n        tickStrings[i] = ticks[i].map(format);\n      }\n\n      // update gridlines / edge lines\n      publicAPI.updatePolyData(facesToDraw, edgesToDraw, ticks);\n\n      // compute label world coords and text\n      publicAPI.updateTextData(facesToDraw, edgesToDraw, ticks, tickStrings);\n\n      // rebuild the texture only when force or changed bounds, face\n      // visibility changes do to change the atlas\n      if (boundsChanged || model.forceUpdate) {\n        publicAPI.updateTextureAtlas(tickStrings);\n      }\n    }\n    model.forceUpdate = false;\n  };\n\n  // create the texture map atlas that contains the rendering of\n  // all the text strings. Only needs to be called when the text strings\n  // have changed (labels and ticks)\n  publicAPI.updateTextureAtlas = tickStrings => {\n    // compute the width and height we need\n\n    // set the text properties\n    model.tmContext.textBaseline = 'bottom';\n    model.tmContext.textAlign = 'left';\n\n    // first the three labels\n    model._tmAtlas.clear();\n    let maxWidth = 0;\n    let totalHeight = 1; // start one pixel in so we have a border\n    for (let i = 0; i < 3; i++) {\n      if (!model._tmAtlas.has(model.axisLabels[i])) {\n        applyTextStyle(model.tmContext, model.axisTextStyle);\n        const metrics = model.tmContext.measureText(model.axisLabels[i]);\n        const entry = {\n          height: metrics.actualBoundingBoxAscent + 2,\n          startingHeight: totalHeight,\n          width: metrics.width + 2,\n          textStyle: model.axisTextStyle\n        };\n        model._tmAtlas.set(model.axisLabels[i], entry);\n        totalHeight += entry.height;\n        if (maxWidth < entry.width) {\n          maxWidth = entry.width;\n        }\n      }\n      // and the ticks\n      applyTextStyle(model.tmContext, model.tickTextStyle);\n      for (let t = 0; t < tickStrings[i].length; t++) {\n        if (!model._tmAtlas.has(tickStrings[i][t])) {\n          const metrics = model.tmContext.measureText(tickStrings[i][t]);\n          const entry = {\n            height: metrics.actualBoundingBoxAscent + 2,\n            startingHeight: totalHeight,\n            width: metrics.width + 2,\n            textStyle: model.tickTextStyle\n          };\n          model._tmAtlas.set(tickStrings[i][t], entry);\n          totalHeight += entry.height;\n          if (maxWidth < entry.width) {\n            maxWidth = entry.width;\n          }\n        }\n      }\n    }\n\n    // always use power of two to avoid interpolation\n    // in cases where PO2 is required\n    maxWidth = nearestPowerOfTwo(maxWidth);\n    totalHeight = nearestPowerOfTwo(totalHeight);\n\n    // set the tcoord values\n    model._tmAtlas.forEach(value => {\n      value.tcoords = [0.0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0.0, (totalHeight - value.startingHeight) / totalHeight];\n    });\n\n    // make sure we have power of two dimensions\n    model.tmCanvas.width = maxWidth;\n    model.tmCanvas.height = totalHeight;\n    model.tmContext.textBaseline = 'bottom';\n    model.tmContext.textAlign = 'left';\n    model.tmContext.clearRect(0, 0, maxWidth, totalHeight);\n\n    // draw the text onto the texture\n    model._tmAtlas.forEach((value, key) => {\n      applyTextStyle(model.tmContext, value.textStyle);\n      model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);\n    });\n    model.tmTexture.setCanvas(model.tmCanvas);\n    model.tmTexture.modified();\n  };\n\n  // Make sure the data is correct\n  publicAPI.onModified(() => {\n    model.forceUpdate = true;\n    publicAPI.update();\n  });\n  publicAPI.setTickTextStyle = tickStyle => {\n    model.tickTextStyle = {\n      ...model.tickTextStyle,\n      ...tickStyle\n    };\n    publicAPI.modified();\n  };\n  publicAPI.setAxisTextStyle = axisStyle => {\n    model.axisTextStyle = {\n      ...model.axisTextStyle,\n      ...axisStyle\n    };\n    publicAPI.modified();\n  };\n  publicAPI.get_tmAtlas = () => model._tmAtlas;\n\n  // try to get the bounds for the annotation. This is complicated\n  // as it relies on the pixel size of the window. Every time the camera\n  // changes the bounds change. This method simplifies by just expanding\n  // the grid bounds by a user specified factor.\n  publicAPI.getBounds = () => {\n    publicAPI.update();\n    vtkBoundingBox.setBounds(model.bounds, model.gridActor.getBounds());\n    vtkBoundingBox.scaleAboutCenter(model.bounds, model.boundsScaleFactor, model.boundsScaleFactor, model.boundsScaleFactor);\n    return model.bounds;\n  };\n\n  // Make sure the grid share the actor property\n  const _setProp = macro.chain(publicAPI.setProperty, model.gridActor.setProperty);\n  publicAPI.setProperty = p => _setProp(p)[0];\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(initialValues) {\n  return {\n    boundsScaleFactor: 1.3,\n    camera: null,\n    dataBounds: [...vtkBoundingBox.INIT_BOUNDS],\n    faceVisibilityAngle: 8,\n    gridLines: true,\n    axisLabels: null,\n    axisTitlePixelOffset: 35.0,\n    axisTextStyle: {\n      fontColor: 'white',\n      fontStyle: 'normal',\n      fontSize: 18,\n      fontFamily: 'serif'\n    },\n    tickLabelPixelOffset: 12.0,\n    tickTextStyle: {\n      fontColor: 'white',\n      fontStyle: 'normal',\n      fontSize: 14,\n      fontFamily: 'serif'\n    },\n    ...initialValues\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, defaultValues(initialValues));\n\n  // Inheritance\n  vtkActor.extend(publicAPI, model, initialValues);\n\n  // internal variables\n  model.lastFacesToDraw = [false, false, false, false, false, false];\n  model.axisLabels = ['X-Axis', 'Y-Axis', 'Z-Axis'];\n  model.tickCounts = [];\n  model.textValues = [];\n  model.lastTickBounds = [];\n  model.tmCanvas = document.createElement('canvas');\n  model.tmContext = model.tmCanvas.getContext('2d');\n  model._tmAtlas = new Map();\n\n  // for texture atlas\n  model.tmTexture = vtkTexture.newInstance();\n  model.tmTexture.setInterpolate(false);\n  publicAPI.getProperty().setDiffuse(0.0);\n  publicAPI.getProperty().setAmbient(1.0);\n  model.gridMapper = vtkMapper.newInstance();\n  model.polyData = vtkPolyData.newInstance();\n  model.gridMapper.setInputData(model.polyData);\n  model.gridActor = vtkActor.newInstance();\n  model.gridActor.setMapper(model.gridMapper);\n  model.gridActor.setProperty(publicAPI.getProperty());\n  model.gridActor.setParentProp(publicAPI);\n  model.textPolyData = vtkPolyData.newInstance();\n  macro.setGet(publicAPI, model, ['axisTitlePixelOffset', 'boundsScaleFactor', 'faceVisibilityAngle', 'gridLines', 'tickLabelPixelOffset']);\n  macro.setGetArray(publicAPI, model, ['dataBounds'], 6);\n  macro.setGetArray(publicAPI, model, ['axisLabels'], 3);\n  macro.get(publicAPI, model, ['axisTextStyle', 'tickTextStyle', 'camera', 'tmTexture', 'textValues', 'textPolyData', 'tickCounts', 'gridActor']);\n\n  // Object methods\n  vtkCubeAxesActor(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCubeAxesActor');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCubeAxesActor$1 = {\n  newInstance,\n  extend,\n  newCubeAxesActorHelper\n};\nexport { vtkCubeAxesActor$1 as default, extend, newInstance };","map":{"version":3,"names":["vec3","mat4","d3","N","normalize2D","O","nearestPowerOfTwo","m","macro","vtkActor","vtkBoundingBox","vtkDataArray","vtkMapper","vtkPolyData","vtkTexture","faceNormals","faceEdges","edgePoints","edgeAxes","faceAxes","ptv3","Float64Array","pt2v3","tmpv3","tmp2v3","xDir","yDir","invmat","applyTextStyle","ctx","style","strokeStyle","strokeColor","lineWidth","strokeSize","fillStyle","fontColor","font","fontStyle","fontSize","fontFamily","vtkCubeAxesActorHelper","publicAPI","model","classHierarchy","push","setRenderable","renderable","tmActor","addTexture","getTmTexture","setProperty","getProperty","setParentProp","modified","createPolyDataForOneLabel","text","pos","cmat","imat","dir","offset","results","value","get_tmAtlas","get","coords","getTextPolyData","getPoints","getData","size","lastSize","transformMat4","subtract","i","ptIdx","cellIdx","scale","width","add","height","points","tcoords","polys","updateTexturePolyData","camera","getCompositeProjectionMatrix","lastAspectRatio","transpose","numLabels","getTextValues","length","numPts","numTris","Uint16Array","Float32Array","invert","textIdx","axisIdx","textValues","getAxisTitlePixelOffset","t","getTickCounts","getTickLabelPixelOffset","tcoordDA","newInstance","numberOfComponents","values","name","tmPolyData","getPointData","setTCoords","setData","getPolys","updateAPISpecificData","renderWindow","forceUpdate","newCubeAxesActorHelper","initialValues","arguments","undefined","Object","assign","obj","tmMapper","setInputData","parentProp","setMapper","setGet","lastRedrawTime","mtime","lastRebuildTime","lastTickBounds","vtkCubeAxesActor","setCamera","cam","cameraModifiedSub","unsubscribe","onModified","update","computeFacesToDraw","getViewMatrix","changed","getDiagonalLength","dataBounds","faceDot","Math","sin","faceVisibilityAngle","PI","f","drawit","faceAxis","floor","otherAxis1","otherAxis2","normalize","getParallelProjection","dot","lastFacesToDraw","updatePolyData","facesToDraw","edgesToDraw","ticks","numLines","numEdgesToDraw","e","gridLines","lines","Uint32Array","lineIdx","z","y","x","faceIdx","aticks","polyData","getLines","updateTextData","tickStrings","textPointCount","textPoints","axisCount","edgeIdx","edgeAxis","ptIdx1","ptIdx2","axisLabels","atickStrings","tickCounts","textPolyData","facesChanged","boundsChanged","Array","fill","scaleLinear","domain","format","tickFormat","map","updateTextureAtlas","tmContext","textBaseline","textAlign","_tmAtlas","clear","maxWidth","totalHeight","has","axisTextStyle","metrics","measureText","entry","actualBoundingBoxAscent","startingHeight","textStyle","set","tickTextStyle","forEach","tmCanvas","clearRect","key","fillText","tmTexture","setCanvas","setTickTextStyle","tickStyle","setAxisTextStyle","axisStyle","getBounds","setBounds","bounds","gridActor","scaleAboutCenter","boundsScaleFactor","_setProp","chain","p","defaultValues","INIT_BOUNDS","axisTitlePixelOffset","tickLabelPixelOffset","extend","document","createElement","getContext","Map","setInterpolate","setDiffuse","setAmbient","gridMapper","setGetArray","vtkCubeAxesActor$1","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/Core/CubeAxesActor.js"],"sourcesContent":["import { vec3, mat4 } from 'gl-matrix';\nimport * as d3 from 'd3-scale';\nimport { N as normalize2D, O as nearestPowerOfTwo } from '../../Common/Core/Math/index.js';\nimport { m as macro } from '../../macros2.js';\nimport vtkActor from './Actor.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkMapper from './Mapper.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkTexture from './Texture.js';\n\n// ----------------------------------------------------------------------------\n// vtkCubeAxesActor\n// ----------------------------------------------------------------------------\n// faces are -x x -y y -z z\n// point 0 is 0,0,0 and then +x fastest changing, +y then +z\nconst faceNormals = [[-1, 0, 0], [1, 0, 0], [0, -1, 0], [0, 1, 0], [0, 0, -1], [0, 0, 1]];\nconst faceEdges = [[8, 7, 11, 3], [9, 1, 10, 5], [4, 9, 0, 8], [2, 11, 6, 10], [0, 3, 2, 1], [4, 5, 6, 7]];\nconst edgePoints = [[0, 1], [1, 3], [2, 3], [0, 2], [4, 5], [5, 7], [6, 7], [4, 6], [0, 4], [1, 5], [3, 7], [2, 6]];\nconst edgeAxes = [0, 1, 0, 1, 0, 1, 0, 1, 2, 2, 2, 2];\nconst faceAxes = [[1, 2], [1, 2], [0, 2], [0, 2], [0, 1], [0, 1]];\n\n//\n// Developer note: This class is broken into the main class and a helper\n// class. The main class holds view independent properties (those properties\n// that do not change as the view's resolution/aspect ratio change). The\n// helper class is instantiated one per view and holds properties that can\n// depend on view specific values such as resolution. The helper class code\n// could have been left to the View specific implementation (such as\n// vtkWebGPUCubeAxesActor) but is instead placed here to it can be shared by\n// multiple rendering backends.\n//\n\n// some shared temp variables to reduce heap allocs\nconst ptv3 = new Float64Array(3);\nconst pt2v3 = new Float64Array(3);\nconst tmpv3 = new Float64Array(3);\nconst tmp2v3 = new Float64Array(3);\nconst xDir = new Float64Array(3);\nconst yDir = new Float64Array(3);\nconst invmat = new Float64Array(16);\nfunction applyTextStyle(ctx, style) {\n  ctx.strokeStyle = style.strokeColor;\n  ctx.lineWidth = style.strokeSize;\n  ctx.fillStyle = style.fontColor;\n  ctx.font = `${style.fontStyle} ${style.fontSize}px ${style.fontFamily}`;\n}\n\n// many properties of this actor depend on the API specific view The main\n// dependency being the resolution as that drives what font sizes to use.\n// Bacause of this we need to do some of the calculations in a API specific\n// subclass. But... we don't want a lot of duplicated code between WebGL and\n// WebGPU for example so we have this helper class, that is designed to be\n// fairly API independent so that API specific views can call this to do\n// most of the work.\nfunction vtkCubeAxesActorHelper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCubeAxesActorHelper');\n  publicAPI.setRenderable = renderable => {\n    if (model.renderable === renderable) {\n      return;\n    }\n    model.renderable = renderable;\n    model.tmActor.addTexture(model.renderable.getTmTexture());\n    model.tmActor.setProperty(renderable.getProperty());\n    model.tmActor.setParentProp(renderable);\n    publicAPI.modified();\n  };\n\n  // called by updateTexturePolyData\n  publicAPI.createPolyDataForOneLabel = (text, pos, cmat, imat, dir, offset, results) => {\n    const value = model.renderable.get_tmAtlas().get(text);\n    if (!value) {\n      return;\n    }\n    const coords = model.renderable.getTextPolyData().getPoints().getData();\n\n    // compute pixel to distance factors\n    const size = model.lastSize;\n    ptv3[0] = coords[pos * 3];\n    ptv3[1] = coords[pos * 3 + 1];\n    ptv3[2] = coords[pos * 3 + 2];\n    vec3.transformMat4(tmpv3, ptv3, cmat);\n    // moving 0.1 in NDC\n    tmpv3[0] += 0.1;\n    vec3.transformMat4(pt2v3, tmpv3, imat);\n    // results in WC move of\n    vec3.subtract(xDir, pt2v3, ptv3);\n    tmpv3[0] -= 0.1;\n    tmpv3[1] += 0.1;\n    vec3.transformMat4(pt2v3, tmpv3, imat);\n    // results in WC move of\n    vec3.subtract(yDir, pt2v3, ptv3);\n    for (let i = 0; i < 3; i++) {\n      xDir[i] /= 0.5 * 0.1 * size[0];\n      yDir[i] /= 0.5 * 0.1 * size[1];\n    }\n\n    // have to find the four corners of the texture polygon for this label\n    // convert anchor point to View Coords\n    let ptIdx = results.ptIdx;\n    let cellIdx = results.cellIdx;\n    ptv3[0] = coords[pos * 3];\n    ptv3[1] = coords[pos * 3 + 1];\n    ptv3[2] = coords[pos * 3 + 2];\n    // horizontal left, right, or middle alignment based on dir[0]\n    if (dir[0] < -0.5) {\n      vec3.scale(tmpv3, xDir, dir[0] * offset - value.width);\n    } else if (dir[0] > 0.5) {\n      vec3.scale(tmpv3, xDir, dir[0] * offset);\n    } else {\n      vec3.scale(tmpv3, xDir, dir[0] * offset - value.width / 2.0);\n    }\n    vec3.add(ptv3, ptv3, tmpv3);\n    vec3.scale(tmpv3, yDir, dir[1] * offset - value.height / 2.0);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[0];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];\n    ptIdx++;\n    vec3.scale(tmpv3, xDir, value.width);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[2];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];\n    ptIdx++;\n    vec3.scale(tmpv3, yDir, value.height);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[4];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];\n    ptIdx++;\n    vec3.scale(tmpv3, xDir, value.width);\n    vec3.subtract(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[6];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];\n    ptIdx++;\n\n    // add the two triangles to represent the quad\n    results.polys[cellIdx * 4] = 3;\n    results.polys[cellIdx * 4 + 1] = ptIdx - 4;\n    results.polys[cellIdx * 4 + 2] = ptIdx - 3;\n    results.polys[cellIdx * 4 + 3] = ptIdx - 2;\n    cellIdx++;\n    results.polys[cellIdx * 4] = 3;\n    results.polys[cellIdx * 4 + 1] = ptIdx - 4;\n    results.polys[cellIdx * 4 + 2] = ptIdx - 2;\n    results.polys[cellIdx * 4 + 3] = ptIdx - 1;\n    results.ptIdx += 4;\n    results.cellIdx += 2;\n  };\n\n  // update the polydata associated with drawing the text labels\n  // specifically the quads used for each label and their associated tcoords\n  // etc. This changes every time the camera viewpoint changes\n  publicAPI.updateTexturePolyData = () => {\n    const cmat = model.camera.getCompositeProjectionMatrix(model.lastAspectRatio, -1, 1);\n    mat4.transpose(cmat, cmat);\n\n    // update the polydata\n    const numLabels = model.renderable.getTextValues().length;\n    const numPts = numLabels * 4;\n    const numTris = numLabels * 2;\n    const points = new Float64Array(numPts * 3);\n    const polys = new Uint16Array(numTris * 4);\n    const tcoords = new Float32Array(numPts * 2);\n    mat4.invert(invmat, cmat);\n    const results = {\n      ptIdx: 0,\n      cellIdx: 0,\n      polys,\n      points,\n      tcoords\n    };\n    let ptIdx = 0;\n    let textIdx = 0;\n    let axisIdx = 0;\n    const coords = model.renderable.getTextPolyData().getPoints().getData();\n    const textValues = model.renderable.getTextValues();\n    while (ptIdx < coords.length / 3) {\n      // compute the direction to move out\n      ptv3[0] = coords[ptIdx * 3];\n      ptv3[1] = coords[ptIdx * 3 + 1];\n      ptv3[2] = coords[ptIdx * 3 + 2];\n      vec3.transformMat4(tmpv3, ptv3, cmat);\n      ptv3[0] = coords[ptIdx * 3 + 3];\n      ptv3[1] = coords[ptIdx * 3 + 4];\n      ptv3[2] = coords[ptIdx * 3 + 5];\n      vec3.transformMat4(tmp2v3, ptv3, cmat);\n      vec3.subtract(tmpv3, tmpv3, tmp2v3);\n      const dir = [tmpv3[0], tmpv3[1]];\n      normalize2D(dir);\n\n      // write the axis label\n      publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getAxisTitlePixelOffset(), results);\n      ptIdx += 2;\n      textIdx++;\n\n      // write the tick labels\n      for (let t = 0; t < model.renderable.getTickCounts()[axisIdx]; t++) {\n        publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getTickLabelPixelOffset(), results);\n        ptIdx++;\n        textIdx++;\n      }\n      axisIdx++;\n    }\n    const tcoordDA = vtkDataArray.newInstance({\n      numberOfComponents: 2,\n      values: tcoords,\n      name: 'TextureCoordinates'\n    });\n    model.tmPolyData.getPointData().setTCoords(tcoordDA);\n    model.tmPolyData.getPoints().setData(points, 3);\n    model.tmPolyData.getPoints().modified();\n    model.tmPolyData.getPolys().setData(polys, 1);\n    model.tmPolyData.getPolys().modified();\n    model.tmPolyData.modified();\n  };\n  publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {\n    // has the size changed?\n    if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {\n      model.lastSize[0] = size[0];\n      model.lastSize[1] = size[1];\n      model.lastAspectRatio = size[0] / size[1];\n      model.forceUpdate = true;\n    }\n    model.camera = camera;\n\n    // compute bounds for label quads whenever the camera changes\n    publicAPI.updateTexturePolyData();\n  };\n}\nconst newCubeAxesActorHelper = macro.newInstance(function (publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    renderable: null\n  };\n  Object.assign(model, {}, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  model.tmPolyData = vtkPolyData.newInstance();\n  model.tmMapper = vtkMapper.newInstance();\n  model.tmMapper.setInputData(model.tmPolyData);\n  model.tmActor = vtkActor.newInstance({\n    parentProp: publicAPI\n  });\n  model.tmActor.setMapper(model.tmMapper);\n  macro.setGet(publicAPI, model, ['renderable']);\n  macro.get(publicAPI, model, ['lastSize', 'lastAspectRatio', 'axisTextStyle', 'tickTextStyle', 'tmActor', 'ticks']);\n  model.forceUpdate = false;\n  model.lastRedrawTime = {};\n  macro.obj(model.lastRedrawTime, {\n    mtime: 0\n  });\n  model.lastRebuildTime = {};\n  macro.obj(model.lastRebuildTime, {\n    mtime: 0\n  });\n  model.lastSize = [-1, -1];\n\n  // internal variables\n  model.lastTickBounds = [];\n  vtkCubeAxesActorHelper(publicAPI, model);\n}, 'vtkCubeAxesActorHelper');\nfunction vtkCubeAxesActor(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCubeAxesActor');\n  publicAPI.setCamera = cam => {\n    if (model.camera === cam) {\n      return;\n    }\n    if (model.cameraModifiedSub) {\n      model.cameraModifiedSub.unsubscribe();\n      model.cameraModifiedSub = null;\n    }\n    model.camera = cam;\n    if (cam) {\n      model.cameraModifiedSub = cam.onModified(publicAPI.update);\n    }\n    publicAPI.update();\n    publicAPI.modified();\n  };\n\n  // estimate from a camera model what faces to draw\n  // return true if the list of faces to draw has changed\n  publicAPI.computeFacesToDraw = () => {\n    const cmat = model.camera.getViewMatrix();\n    mat4.transpose(cmat, cmat);\n    let changed = false;\n    const length = vtkBoundingBox.getDiagonalLength(model.dataBounds);\n    const faceDot = Math.sin(model.faceVisibilityAngle * Math.PI / 180.0);\n    for (let f = 0; f < 6; f++) {\n      let drawit = false;\n      const faceAxis = Math.floor(f / 2);\n      const otherAxis1 = (faceAxis + 1) % 3;\n      const otherAxis2 = (faceAxis + 2) % 3;\n      // only for non degenerate axes\n      if (model.dataBounds[otherAxis1 * 2] !== model.dataBounds[otherAxis1 * 2 + 1] && model.dataBounds[otherAxis2 * 2] !== model.dataBounds[otherAxis2 * 2 + 1]) {\n        // for each face transform the center and off center to get a direction vector\n        ptv3[faceAxis] = model.dataBounds[f] - 0.1 * length * faceNormals[f][faceAxis];\n        ptv3[otherAxis1] = 0.5 * (model.dataBounds[otherAxis1 * 2] + model.dataBounds[otherAxis1 * 2 + 1]);\n        ptv3[otherAxis2] = 0.5 * (model.dataBounds[otherAxis2 * 2] + model.dataBounds[otherAxis2 * 2 + 1]);\n        vec3.transformMat4(tmpv3, ptv3, cmat);\n        ptv3[faceAxis] = model.dataBounds[f];\n        vec3.transformMat4(tmp2v3, ptv3, cmat);\n        vec3.subtract(tmpv3, tmp2v3, tmpv3);\n        vec3.normalize(tmpv3, tmpv3);\n        // tmpv3 now holds the face normal vector\n        drawit = tmpv3[2] > faceDot;\n        // for perspctive we need the view direction to the plane\n        if (!model.camera.getParallelProjection()) {\n          vec3.normalize(tmp2v3, tmp2v3);\n          drawit = vec3.dot(tmp2v3, tmpv3) > faceDot;\n        }\n      }\n      if (drawit !== model.lastFacesToDraw[f]) {\n        model.lastFacesToDraw[f] = drawit;\n        changed = true;\n      }\n    }\n    return changed;\n  };\n\n  // update the polydata that represents the boundingd edges and gridlines\n  publicAPI.updatePolyData = (facesToDraw, edgesToDraw, ticks) => {\n    // compute the number of points and lines required\n    let numPts = 0;\n    let numLines = 0;\n    numPts += 8; // always start with the 8 cube points\n\n    // count edgesToDraw\n    let numEdgesToDraw = 0;\n    for (let e = 0; e < 12; e++) {\n      if (edgesToDraw[e] > 0) {\n        numEdgesToDraw++;\n      }\n    }\n    numLines += numEdgesToDraw;\n\n    // add values for gridlines\n    if (model.gridLines) {\n      for (let f = 0; f < 6; f++) {\n        if (facesToDraw[f]) {\n          numPts += ticks[faceAxes[f][0]].length * 2 + ticks[faceAxes[f][1]].length * 2;\n          numLines += ticks[faceAxes[f][0]].length + ticks[faceAxes[f][1]].length;\n        }\n      }\n    }\n\n    // now allocate the memory\n    const points = new Float64Array(numPts * 3);\n    const lines = new Uint32Array(numLines * 3);\n    let ptIdx = 0;\n    let lineIdx = 0;\n\n    // add the 8 corner points\n    for (let z = 0; z < 2; z++) {\n      for (let y = 0; y < 2; y++) {\n        for (let x = 0; x < 2; x++) {\n          points[ptIdx * 3] = model.dataBounds[x];\n          points[ptIdx * 3 + 1] = model.dataBounds[2 + y];\n          points[ptIdx * 3 + 2] = model.dataBounds[4 + z];\n          ptIdx++;\n        }\n      }\n    }\n\n    // draw the edges\n    for (let e = 0; e < 12; e++) {\n      if (edgesToDraw[e] > 0) {\n        lines[lineIdx * 3] = 2;\n        lines[lineIdx * 3 + 1] = edgePoints[e][0];\n        lines[lineIdx * 3 + 2] = edgePoints[e][1];\n        lineIdx++;\n      }\n    }\n\n    // now handle gridlines\n    // grid lines are tick[axis1] + ticks[axes2] lines each having two points\n    // for simplicity we don;t worry about duplicating points, this is tiny\n\n    if (model.gridLines) {\n      // for each visible face\n      // add the points\n      for (let f = 0; f < 6; f++) {\n        if (facesToDraw[f]) {\n          const faceIdx = Math.floor(f / 2);\n          let aticks = ticks[faceAxes[f][0]];\n          for (let t = 0; t < aticks.length; t++) {\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2];\n            ptIdx++;\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2 + 1];\n            ptIdx++;\n            lines[lineIdx * 3] = 2;\n            lines[lineIdx * 3 + 1] = ptIdx - 2;\n            lines[lineIdx * 3 + 2] = ptIdx - 1;\n            lineIdx++;\n          }\n          aticks = ticks[faceAxes[f][1]];\n          for (let t = 0; t < aticks.length; t++) {\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2];\n            ptIdx++;\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2 + 1];\n            ptIdx++;\n            lines[lineIdx * 3] = 2;\n            lines[lineIdx * 3 + 1] = ptIdx - 2;\n            lines[lineIdx * 3 + 2] = ptIdx - 1;\n            lineIdx++;\n          }\n        }\n      }\n    }\n    model.polyData.getPoints().setData(points, 3);\n    model.polyData.getPoints().modified();\n    model.polyData.getLines().setData(lines, 1);\n    model.polyData.getLines().modified();\n    model.polyData.modified();\n  };\n\n  // update the data that represents where to put the labels\n  // in world coordinates. This only changes when faces to draw changes\n  // of dataBounds changes\n  publicAPI.updateTextData = (facesToDraw, edgesToDraw, ticks, tickStrings) => {\n    // count outside edgesToDraw\n    let textPointCount = 0;\n    for (let e = 0; e < 12; e++) {\n      if (edgesToDraw[e] === 1) {\n        textPointCount += 2;\n        textPointCount += ticks[edgeAxes[e]].length;\n      }\n    }\n    const points = model.polyData.getPoints().getData();\n    const textPoints = new Float64Array(textPointCount * 3);\n    let ptIdx = 0;\n    let textIdx = 0;\n    let axisCount = 0;\n    for (let f = 0; f < 6; f++) {\n      if (facesToDraw[f]) {\n        for (let e = 0; e < 4; e++) {\n          const edgeIdx = faceEdges[f][e];\n          if (edgesToDraw[edgeIdx] === 1) {\n            const edgeAxis = edgeAxes[edgeIdx];\n            // add a middle point on the edge\n            const ptIdx1 = edgePoints[edgeIdx][0] * 3;\n            const ptIdx2 = edgePoints[edgeIdx][1] * 3;\n            textPoints[ptIdx * 3] = 0.5 * (points[ptIdx1] + points[ptIdx2]);\n            textPoints[ptIdx * 3 + 1] = 0.5 * (points[ptIdx1 + 1] + points[ptIdx2 + 1]);\n            textPoints[ptIdx * 3 + 2] = 0.5 * (points[ptIdx1 + 2] + points[ptIdx2 + 2]);\n            ptIdx++;\n            // add a middle face point, we use this to\n            // move the labels away from the edge in the right direction\n            const faceIdx = Math.floor(f / 2);\n            textPoints[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            textPoints[ptIdx * 3 + faceAxes[f][0]] = 0.5 * (model.dataBounds[faceAxes[f][0] * 2] + model.dataBounds[faceAxes[f][0] * 2 + 1]);\n            textPoints[ptIdx * 3 + faceAxes[f][1]] = 0.5 * (model.dataBounds[faceAxes[f][1] * 2] + model.dataBounds[faceAxes[f][1] * 2 + 1]);\n            ptIdx++;\n            // set the text\n            model.textValues[textIdx] = model.axisLabels[edgeAxis];\n            textIdx++;\n\n            // now add the tick marks along the edgeAxis\n            const otherAxis1 = (edgeAxis + 1) % 3;\n            const otherAxis2 = (edgeAxis + 2) % 3;\n            const aticks = ticks[edgeAxis];\n            const atickStrings = tickStrings[edgeAxis];\n            model.tickCounts[axisCount] = aticks.length;\n            for (let t = 0; t < aticks.length; t++) {\n              textPoints[ptIdx * 3 + edgeAxis] = aticks[t];\n              textPoints[ptIdx * 3 + otherAxis1] = points[ptIdx1 + otherAxis1];\n              textPoints[ptIdx * 3 + otherAxis2] = points[ptIdx1 + otherAxis2];\n              ptIdx++;\n              // set the text\n              model.textValues[textIdx] = atickStrings[t];\n              textIdx++;\n            }\n            axisCount++;\n          }\n        }\n      }\n    }\n    model.textPolyData.getPoints().setData(textPoints, 3);\n    model.textPolyData.modified();\n  };\n\n  // main method to rebuild the cube axes, gets called on camera modify\n  // and changes to key members\n  publicAPI.update = () => {\n    // Can't do anything if we don't have a camera...\n    if (!model.camera) {\n      return;\n    }\n\n    // compute what faces to draw\n    const facesChanged = publicAPI.computeFacesToDraw();\n    const facesToDraw = model.lastFacesToDraw;\n\n    // have the bounds changed?\n    let boundsChanged = false;\n    for (let i = 0; i < 6; i++) {\n      if (model.dataBounds[i] !== model.lastTickBounds[i]) {\n        boundsChanged = true;\n        model.lastTickBounds[i] = model.dataBounds[i];\n      }\n    }\n\n    // did something significant change? If so rebuild a lot of things\n    if (facesChanged || boundsChanged || model.forceUpdate) {\n      // compute the edges to draw\n      // for each drawn face, mark edges, all single mark edges we draw\n      const edgesToDraw = new Array(12).fill(0);\n      for (let f = 0; f < 6; f++) {\n        if (facesToDraw[f]) {\n          for (let e = 0; e < 4; e++) {\n            edgesToDraw[faceEdges[f][e]]++;\n          }\n        }\n      }\n\n      // compute tick marks for axes\n      const ticks = [];\n      const tickStrings = [];\n      for (let i = 0; i < 3; i++) {\n        const scale = d3.scaleLinear().domain([model.dataBounds[i * 2], model.dataBounds[i * 2 + 1]]);\n        ticks[i] = scale.ticks(5);\n        const format = scale.tickFormat(5);\n        tickStrings[i] = ticks[i].map(format);\n      }\n\n      // update gridlines / edge lines\n      publicAPI.updatePolyData(facesToDraw, edgesToDraw, ticks);\n\n      // compute label world coords and text\n      publicAPI.updateTextData(facesToDraw, edgesToDraw, ticks, tickStrings);\n\n      // rebuild the texture only when force or changed bounds, face\n      // visibility changes do to change the atlas\n      if (boundsChanged || model.forceUpdate) {\n        publicAPI.updateTextureAtlas(tickStrings);\n      }\n    }\n    model.forceUpdate = false;\n  };\n\n  // create the texture map atlas that contains the rendering of\n  // all the text strings. Only needs to be called when the text strings\n  // have changed (labels and ticks)\n  publicAPI.updateTextureAtlas = tickStrings => {\n    // compute the width and height we need\n\n    // set the text properties\n    model.tmContext.textBaseline = 'bottom';\n    model.tmContext.textAlign = 'left';\n\n    // first the three labels\n    model._tmAtlas.clear();\n    let maxWidth = 0;\n    let totalHeight = 1; // start one pixel in so we have a border\n    for (let i = 0; i < 3; i++) {\n      if (!model._tmAtlas.has(model.axisLabels[i])) {\n        applyTextStyle(model.tmContext, model.axisTextStyle);\n        const metrics = model.tmContext.measureText(model.axisLabels[i]);\n        const entry = {\n          height: metrics.actualBoundingBoxAscent + 2,\n          startingHeight: totalHeight,\n          width: metrics.width + 2,\n          textStyle: model.axisTextStyle\n        };\n        model._tmAtlas.set(model.axisLabels[i], entry);\n        totalHeight += entry.height;\n        if (maxWidth < entry.width) {\n          maxWidth = entry.width;\n        }\n      }\n      // and the ticks\n      applyTextStyle(model.tmContext, model.tickTextStyle);\n      for (let t = 0; t < tickStrings[i].length; t++) {\n        if (!model._tmAtlas.has(tickStrings[i][t])) {\n          const metrics = model.tmContext.measureText(tickStrings[i][t]);\n          const entry = {\n            height: metrics.actualBoundingBoxAscent + 2,\n            startingHeight: totalHeight,\n            width: metrics.width + 2,\n            textStyle: model.tickTextStyle\n          };\n          model._tmAtlas.set(tickStrings[i][t], entry);\n          totalHeight += entry.height;\n          if (maxWidth < entry.width) {\n            maxWidth = entry.width;\n          }\n        }\n      }\n    }\n\n    // always use power of two to avoid interpolation\n    // in cases where PO2 is required\n    maxWidth = nearestPowerOfTwo(maxWidth);\n    totalHeight = nearestPowerOfTwo(totalHeight);\n\n    // set the tcoord values\n    model._tmAtlas.forEach(value => {\n      value.tcoords = [0.0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0.0, (totalHeight - value.startingHeight) / totalHeight];\n    });\n\n    // make sure we have power of two dimensions\n    model.tmCanvas.width = maxWidth;\n    model.tmCanvas.height = totalHeight;\n    model.tmContext.textBaseline = 'bottom';\n    model.tmContext.textAlign = 'left';\n    model.tmContext.clearRect(0, 0, maxWidth, totalHeight);\n\n    // draw the text onto the texture\n    model._tmAtlas.forEach((value, key) => {\n      applyTextStyle(model.tmContext, value.textStyle);\n      model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);\n    });\n    model.tmTexture.setCanvas(model.tmCanvas);\n    model.tmTexture.modified();\n  };\n\n  // Make sure the data is correct\n  publicAPI.onModified(() => {\n    model.forceUpdate = true;\n    publicAPI.update();\n  });\n  publicAPI.setTickTextStyle = tickStyle => {\n    model.tickTextStyle = {\n      ...model.tickTextStyle,\n      ...tickStyle\n    };\n    publicAPI.modified();\n  };\n  publicAPI.setAxisTextStyle = axisStyle => {\n    model.axisTextStyle = {\n      ...model.axisTextStyle,\n      ...axisStyle\n    };\n    publicAPI.modified();\n  };\n  publicAPI.get_tmAtlas = () => model._tmAtlas;\n\n  // try to get the bounds for the annotation. This is complicated\n  // as it relies on the pixel size of the window. Every time the camera\n  // changes the bounds change. This method simplifies by just expanding\n  // the grid bounds by a user specified factor.\n  publicAPI.getBounds = () => {\n    publicAPI.update();\n    vtkBoundingBox.setBounds(model.bounds, model.gridActor.getBounds());\n    vtkBoundingBox.scaleAboutCenter(model.bounds, model.boundsScaleFactor, model.boundsScaleFactor, model.boundsScaleFactor);\n    return model.bounds;\n  };\n\n  // Make sure the grid share the actor property\n  const _setProp = macro.chain(publicAPI.setProperty, model.gridActor.setProperty);\n  publicAPI.setProperty = p => _setProp(p)[0];\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(initialValues) {\n  return {\n    boundsScaleFactor: 1.3,\n    camera: null,\n    dataBounds: [...vtkBoundingBox.INIT_BOUNDS],\n    faceVisibilityAngle: 8,\n    gridLines: true,\n    axisLabels: null,\n    axisTitlePixelOffset: 35.0,\n    axisTextStyle: {\n      fontColor: 'white',\n      fontStyle: 'normal',\n      fontSize: 18,\n      fontFamily: 'serif'\n    },\n    tickLabelPixelOffset: 12.0,\n    tickTextStyle: {\n      fontColor: 'white',\n      fontStyle: 'normal',\n      fontSize: 14,\n      fontFamily: 'serif'\n    },\n    ...initialValues\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, defaultValues(initialValues));\n\n  // Inheritance\n  vtkActor.extend(publicAPI, model, initialValues);\n\n  // internal variables\n  model.lastFacesToDraw = [false, false, false, false, false, false];\n  model.axisLabels = ['X-Axis', 'Y-Axis', 'Z-Axis'];\n  model.tickCounts = [];\n  model.textValues = [];\n  model.lastTickBounds = [];\n  model.tmCanvas = document.createElement('canvas');\n  model.tmContext = model.tmCanvas.getContext('2d');\n  model._tmAtlas = new Map();\n\n  // for texture atlas\n  model.tmTexture = vtkTexture.newInstance();\n  model.tmTexture.setInterpolate(false);\n  publicAPI.getProperty().setDiffuse(0.0);\n  publicAPI.getProperty().setAmbient(1.0);\n  model.gridMapper = vtkMapper.newInstance();\n  model.polyData = vtkPolyData.newInstance();\n  model.gridMapper.setInputData(model.polyData);\n  model.gridActor = vtkActor.newInstance();\n  model.gridActor.setMapper(model.gridMapper);\n  model.gridActor.setProperty(publicAPI.getProperty());\n  model.gridActor.setParentProp(publicAPI);\n  model.textPolyData = vtkPolyData.newInstance();\n  macro.setGet(publicAPI, model, ['axisTitlePixelOffset', 'boundsScaleFactor', 'faceVisibilityAngle', 'gridLines', 'tickLabelPixelOffset']);\n  macro.setGetArray(publicAPI, model, ['dataBounds'], 6);\n  macro.setGetArray(publicAPI, model, ['axisLabels'], 3);\n  macro.get(publicAPI, model, ['axisTextStyle', 'tickTextStyle', 'camera', 'tmTexture', 'textValues', 'textPolyData', 'tickCounts', 'gridActor']);\n\n  // Object methods\n  vtkCubeAxesActor(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCubeAxesActor');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCubeAxesActor$1 = {\n  newInstance,\n  extend,\n  newCubeAxesActorHelper\n};\n\nexport { vtkCubeAxesActor$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}