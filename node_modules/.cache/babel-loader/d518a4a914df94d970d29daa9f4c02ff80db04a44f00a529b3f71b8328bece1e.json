{"ast":null,"code":"import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkXMLReader from './XMLReader.js';\n\n// ----------------------------------------------------------------------------\n// Global method\n// ----------------------------------------------------------------------------\n\nfunction handleArray(polydata, cellType, piece, compressor, byteOrder, headerType, binaryBuffer) {\n  const size = Number(piece.getAttribute(`NumberOf${cellType}`));\n  if (size > 0) {\n    const dataArrayElem = piece.getElementsByTagName(cellType)[0].getElementsByTagName('DataArray')[0];\n    const {\n      values,\n      numberOfComponents\n    } = vtkXMLReader.processDataArray(size, dataArrayElem, compressor, byteOrder, headerType, binaryBuffer);\n    polydata[`get${cellType}`]().setData(values, numberOfComponents);\n  }\n  return size;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction handleCells(polydata, cellType, piece, compressor, byteOrder, headerType, binaryBuffer) {\n  const size = Number(piece.getAttribute(`NumberOf${cellType}`));\n  if (size > 0) {\n    const values = vtkXMLReader.processCells(size, piece.getElementsByTagName(cellType)[0], compressor, byteOrder, headerType, binaryBuffer);\n    polydata[`get${cellType}`]().setData(values);\n  }\n  return size;\n}\n\n// ----------------------------------------------------------------------------\n// vtkXMLPolyDataReader methods\n// ----------------------------------------------------------------------------\n\nfunction vtkXMLPolyDataReader(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkXMLPolyDataReader');\n  publicAPI.parseXML = (rootElem, type, compressor, byteOrder, headerType) => {\n    const datasetElem = rootElem.getElementsByTagName(model.dataType)[0];\n    const pieces = datasetElem.getElementsByTagName('Piece');\n    const nbPieces = pieces.length;\n    for (let outputIndex = 0; outputIndex < nbPieces; outputIndex++) {\n      // Create dataset\n      const polydata = vtkPolyData.newInstance();\n      const piece = pieces[outputIndex];\n\n      // Points\n      const nbPoints = handleArray(polydata, 'Points', piece, compressor, byteOrder, headerType, model.binaryBuffer);\n\n      // Cells\n      let nbCells = 0;\n      ['Verts', 'Lines', 'Strips', 'Polys'].forEach(cellType => {\n        nbCells += handleCells(polydata, cellType, piece, compressor, byteOrder, headerType, model.binaryBuffer);\n      });\n\n      // Fill data\n      vtkXMLReader.processFieldData(nbPoints, piece.getElementsByTagName('PointData')[0], polydata.getPointData(), compressor, byteOrder, headerType, model.binaryBuffer);\n      vtkXMLReader.processFieldData(nbCells, piece.getElementsByTagName('CellData')[0], polydata.getCellData(), compressor, byteOrder, headerType, model.binaryBuffer);\n\n      // Add new output\n      model.output[outputIndex] = polydata;\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  dataType: 'PolyData'\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkXMLReader.extend(publicAPI, model, initialValues);\n  vtkXMLPolyDataReader(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkXMLPolyDataReader');\n\n// ----------------------------------------------------------------------------\n\nvar vtkXMLPolyDataReader$1 = {\n  newInstance,\n  extend\n};\nexport { vtkXMLPolyDataReader$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkPolyData","vtkXMLReader","handleArray","polydata","cellType","piece","compressor","byteOrder","headerType","binaryBuffer","size","Number","getAttribute","dataArrayElem","getElementsByTagName","values","numberOfComponents","processDataArray","setData","handleCells","processCells","vtkXMLPolyDataReader","publicAPI","model","classHierarchy","push","parseXML","rootElem","type","datasetElem","dataType","pieces","nbPieces","length","outputIndex","newInstance","nbPoints","nbCells","forEach","processFieldData","getPointData","getCellData","output","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","vtkXMLPolyDataReader$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/IO/XML/XMLPolyDataReader.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkXMLReader from './XMLReader.js';\n\n// ----------------------------------------------------------------------------\n// Global method\n// ----------------------------------------------------------------------------\n\nfunction handleArray(polydata, cellType, piece, compressor, byteOrder, headerType, binaryBuffer) {\n  const size = Number(piece.getAttribute(`NumberOf${cellType}`));\n  if (size > 0) {\n    const dataArrayElem = piece.getElementsByTagName(cellType)[0].getElementsByTagName('DataArray')[0];\n    const {\n      values,\n      numberOfComponents\n    } = vtkXMLReader.processDataArray(size, dataArrayElem, compressor, byteOrder, headerType, binaryBuffer);\n    polydata[`get${cellType}`]().setData(values, numberOfComponents);\n  }\n  return size;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction handleCells(polydata, cellType, piece, compressor, byteOrder, headerType, binaryBuffer) {\n  const size = Number(piece.getAttribute(`NumberOf${cellType}`));\n  if (size > 0) {\n    const values = vtkXMLReader.processCells(size, piece.getElementsByTagName(cellType)[0], compressor, byteOrder, headerType, binaryBuffer);\n    polydata[`get${cellType}`]().setData(values);\n  }\n  return size;\n}\n\n// ----------------------------------------------------------------------------\n// vtkXMLPolyDataReader methods\n// ----------------------------------------------------------------------------\n\nfunction vtkXMLPolyDataReader(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkXMLPolyDataReader');\n  publicAPI.parseXML = (rootElem, type, compressor, byteOrder, headerType) => {\n    const datasetElem = rootElem.getElementsByTagName(model.dataType)[0];\n    const pieces = datasetElem.getElementsByTagName('Piece');\n    const nbPieces = pieces.length;\n    for (let outputIndex = 0; outputIndex < nbPieces; outputIndex++) {\n      // Create dataset\n      const polydata = vtkPolyData.newInstance();\n      const piece = pieces[outputIndex];\n\n      // Points\n      const nbPoints = handleArray(polydata, 'Points', piece, compressor, byteOrder, headerType, model.binaryBuffer);\n\n      // Cells\n      let nbCells = 0;\n      ['Verts', 'Lines', 'Strips', 'Polys'].forEach(cellType => {\n        nbCells += handleCells(polydata, cellType, piece, compressor, byteOrder, headerType, model.binaryBuffer);\n      });\n\n      // Fill data\n      vtkXMLReader.processFieldData(nbPoints, piece.getElementsByTagName('PointData')[0], polydata.getPointData(), compressor, byteOrder, headerType, model.binaryBuffer);\n      vtkXMLReader.processFieldData(nbCells, piece.getElementsByTagName('CellData')[0], polydata.getCellData(), compressor, byteOrder, headerType, model.binaryBuffer);\n\n      // Add new output\n      model.output[outputIndex] = polydata;\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  dataType: 'PolyData'\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkXMLReader.extend(publicAPI, model, initialValues);\n  vtkXMLPolyDataReader(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkXMLPolyDataReader');\n\n// ----------------------------------------------------------------------------\n\nvar vtkXMLPolyDataReader$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkXMLPolyDataReader$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}