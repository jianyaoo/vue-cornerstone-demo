"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContourSegmentationBaseTool = exports.default = void 0;
const core_1 = require("@cornerstonejs/core");
const segmentation_1 = require("../../stateManagement/segmentation");
const enums_1 = require("../../enums");
const ContourBaseTool_1 = __importDefault(require("./ContourBaseTool"));
const triggerSegmentationEvents_1 = require("../../stateManagement/segmentation/triggerSegmentationEvents");
const interpolation_1 = require("../../utilities/contours/interpolation");
const contourSegmentation_1 = require("../../utilities/contourSegmentation");
const segmentationState_1 = require("../../stateManagement/segmentation/segmentationState");
const utilities_1 = require("../../utilities");
class ContourSegmentationBaseTool extends ContourBaseTool_1.default {
    constructor(toolProps, defaultToolProps) {
        var _a;
        super(toolProps, defaultToolProps);
        if ((_a = this.configuration.interpolation) === null || _a === void 0 ? void 0 : _a.enabled) {
            interpolation_1.InterpolationManager.addTool(this.getToolName());
        }
    }
    isContourSegmentationTool() {
        return true;
    }
    createAnnotation(evt) {
        const { toolGroupId } = this;
        const contourAnnotation = super.createAnnotation(evt);
        if (!this.isContourSegmentationTool()) {
            return contourAnnotation;
        }
        const activeSegmentationRepresentation = segmentation_1.activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);
        if (!activeSegmentationRepresentation) {
            throw new Error('No active segmentation detected, create one before using scissors tool');
        }
        const { type: segmentationType } = activeSegmentationRepresentation;
        if (segmentationType !== enums_1.SegmentationRepresentations.Contour) {
            throw new Error(`A contour segmentation must be active`);
        }
        const { segmentationId } = activeSegmentationRepresentation;
        const segmentIndex = segmentation_1.segmentIndex.getActiveSegmentIndex(segmentationId);
        return core_1.utilities.deepMerge(contourAnnotation, {
            data: {
                segmentation: {
                    segmentationId,
                    segmentIndex,
                },
            },
        });
    }
    addAnnotation(annotation, element) {
        const annotationUID = super.addAnnotation(annotation, element);
        if (this.isContourSegmentationTool()) {
            const contourSegAnnotation = annotation;
            (0, contourSegmentation_1.addContourSegmentationAnnotation)(contourSegAnnotation);
        }
        return annotationUID;
    }
    cancelAnnotation(annotation) {
        if (this.isContourSegmentationTool()) {
            (0, contourSegmentation_1.removeContourSegmentationAnnotation)(annotation);
        }
        super.cancelAnnotation(annotation);
    }
    getAnnotationStyle(context) {
        const annotationStyle = super.getAnnotationStyle(context);
        if (!this.isContourSegmentationTool()) {
            return annotationStyle;
        }
        const contourSegmentationStyle = this._getContourSegmentationStyle(context);
        return core_1.utilities.deepMerge(annotationStyle, contourSegmentationStyle);
    }
    renderAnnotationInstance(renderContext) {
        const { annotation } = renderContext;
        const { invalidated } = annotation;
        const renderResult = super.renderAnnotationInstance(renderContext);
        if (invalidated && this.isContourSegmentationTool()) {
            const { segmentationId } = (annotation).data.segmentation;
            (0, triggerSegmentationEvents_1.triggerSegmentationDataModified)(segmentationId);
            const toolGroupIds = (0, segmentationState_1.getToolGroupIdsWithSegmentation)(segmentationId);
            (0, utilities_1.triggerAnnotationRenderForToolGroupIds)(toolGroupIds);
        }
        return renderResult;
    }
    _getContourSegmentationStyle(context) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        const { toolGroupId } = this;
        const annotation = context.annotation;
        const { segmentationId, segmentIndex } = annotation.data.segmentation;
        const segmentation = segmentation_1.state.getSegmentation(segmentationId);
        const segmentationRepresentation = this._getSegmentationRepresentation(segmentationId);
        if (!segmentationRepresentation) {
            return {};
        }
        const { segmentationRepresentationUID } = segmentationRepresentation;
        const { active } = segmentationRepresentation;
        const { autoGenerated } = annotation;
        const segmentsLocked = segmentation_1.segmentLocking.getLockedSegments(segmentationId);
        const annotationLocked = segmentsLocked.includes(segmentIndex);
        const segmentColor = segmentation_1.config.color.getColorForSegmentIndex(toolGroupId, segmentationRepresentationUID, segmentIndex);
        const segmentationVisible = segmentation_1.config.visibility.getSegmentationVisibility(toolGroupId, segmentationRepresentationUID);
        const globalConfig = segmentation_1.config.getGlobalConfig();
        const toolGroupConfig = segmentation_1.config.getToolGroupSpecificConfig(toolGroupId);
        const segmentationRepresentationConfig = segmentation_1.config.getSegmentationRepresentationSpecificConfig(toolGroupId, segmentationRepresentationUID);
        const segmentConfig = segmentation_1.config.getSegmentSpecificConfig(toolGroupId, segmentationRepresentationUID, segmentIndex);
        const segmentVisible = segmentation_1.config.visibility.getSegmentVisibility(toolGroupId, segmentationRepresentationUID, segmentIndex);
        const mergedConfig = Object.assign({}, (_b = (_a = globalConfig === null || globalConfig === void 0 ? void 0 : globalConfig.representations) === null || _a === void 0 ? void 0 : _a.CONTOUR) !== null && _b !== void 0 ? _b : {}, (_d = (_c = toolGroupConfig === null || toolGroupConfig === void 0 ? void 0 : toolGroupConfig.representations) === null || _c === void 0 ? void 0 : _c.CONTOUR) !== null && _d !== void 0 ? _d : {}, (_e = segmentationRepresentationConfig === null || segmentationRepresentationConfig === void 0 ? void 0 : segmentationRepresentationConfig.CONTOUR) !== null && _e !== void 0 ? _e : {}, (_f = segmentConfig === null || segmentConfig === void 0 ? void 0 : segmentConfig.CONTOUR) !== null && _f !== void 0 ? _f : {});
        let lineWidth = 1;
        let lineDash = undefined;
        let lineOpacity = 1;
        let fillOpacity = 0;
        if (autoGenerated) {
            lineWidth = (_g = mergedConfig.outlineWidthAutoGenerated) !== null && _g !== void 0 ? _g : lineWidth;
            lineDash = (_h = mergedConfig.outlineDashAutoGenerated) !== null && _h !== void 0 ? _h : lineDash;
            lineOpacity = (_j = mergedConfig.outlineOpacity) !== null && _j !== void 0 ? _j : lineOpacity;
            fillOpacity = (_k = mergedConfig.fillAlphaAutoGenerated) !== null && _k !== void 0 ? _k : fillOpacity;
        }
        else if (active) {
            lineWidth = (_l = mergedConfig.outlineWidthActive) !== null && _l !== void 0 ? _l : lineWidth;
            lineDash = (_m = mergedConfig.outlineDashActive) !== null && _m !== void 0 ? _m : lineDash;
            lineOpacity = (_o = mergedConfig.outlineOpacity) !== null && _o !== void 0 ? _o : lineOpacity;
            fillOpacity = (_p = mergedConfig.fillAlpha) !== null && _p !== void 0 ? _p : fillOpacity;
        }
        else {
            lineWidth = (_q = mergedConfig.outlineWidthInactive) !== null && _q !== void 0 ? _q : lineWidth;
            lineDash = (_r = mergedConfig.outlineDashInactive) !== null && _r !== void 0 ? _r : lineDash;
            lineOpacity = (_s = mergedConfig.outlineOpacityInactive) !== null && _s !== void 0 ? _s : lineOpacity;
            fillOpacity = (_t = mergedConfig.fillAlphaInactive) !== null && _t !== void 0 ? _t : fillOpacity;
        }
        if (segmentation.activeSegmentIndex === segmentIndex) {
            lineWidth += mergedConfig.activeSegmentOutlineWidthDelta;
        }
        lineWidth = mergedConfig.renderOutline ? lineWidth : 0;
        fillOpacity = mergedConfig.renderFill ? fillOpacity : 0;
        const color = `rgba(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]}, ${lineOpacity})`;
        const fillColor = `rgb(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]})`;
        return {
            color,
            fillColor,
            lineWidth,
            fillOpacity,
            lineDash,
            textbox: {
                color,
            },
            visibility: segmentationVisible && segmentVisible,
            locked: annotationLocked,
        };
    }
    _getSegmentationRepresentation(segmentationId) {
        const segmentationRepresentations = segmentation_1.state.getSegmentationRepresentations(this.toolGroupId);
        const validSegmentationRepresentations = segmentationRepresentations.filter((representation) => representation.segmentationId === segmentationId);
        if (!validSegmentationRepresentations) {
            console.warn(`No segmentation representation found for toolGroupId: ${this.toolGroupId}`);
            return;
        }
        if (segmentation_1.state.getSegmentationRepresentations(this.toolGroupId)
            .length > 1) {
            console.warn('Multiple segmentation representations detected for this tool group. The first one will be used.');
        }
        return validSegmentationRepresentations[0];
    }
}
exports.default = ContourSegmentationBaseTool;
exports.ContourSegmentationBaseTool = ContourSegmentationBaseTool;
//# sourceMappingURL=ContourSegmentationBaseTool.js.map