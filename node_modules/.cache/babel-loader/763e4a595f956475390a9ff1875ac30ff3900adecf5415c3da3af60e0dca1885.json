{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { m as macro } from '../../macros2.js';\nimport { mat4, vec3 } from 'gl-matrix';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport vtkHelper from './Helper.js';\nimport vtkReplacementShaderMapper from './ReplacementShaderMapper.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { Filter } from './Texture/Constants.js';\nimport { InterpolationType } from '../Core/ImageProperty/Constants.js';\nimport { v as vtkPolyDataVS } from './glsl/vtkPolyDataVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n\nfunction computeFnToString(property, fn, numberOfComponents) {\n  const pwfun = fn.apply(property);\n  if (pwfun) {\n    const iComps = property.getIndependentComponents();\n    return `${property.getMTime()}-${iComps}-${numberOfComponents}`;\n  }\n  return '0';\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLImageCPRMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLImageCPRMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLImageCPRMapper');\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model.openGLImageSlice = publicAPI.getFirstAncestorOfType('vtkOpenGLImageSlice');\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.context = model._openGLRenderWindow.getContext();\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.volumeTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n    }\n  };\n  publicAPI.opaquePass = (prepass, renderPass) => {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n  publicAPI.opaqueZBufferPass = prepass => {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n  publicAPI.getCoincidentParameters = (ren, actor) => {\n    if (model.renderable.getResolveCoincidentTopology()) {\n      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n    }\n    return null;\n  };\n  publicAPI.render = () => {\n    const prop = model.openGLImageSlice.getRenderable();\n    const ren = model._openGLRenderer.getRenderable();\n    publicAPI.renderPiece(ren, prop);\n  };\n  publicAPI.renderPiece = (ren, prop) => {\n    publicAPI.invokeEvent({\n      type: 'StartEvent'\n    });\n    model.renderable.update();\n    publicAPI.invokeEvent({\n      type: 'EndEvent'\n    });\n\n    // Check if the ImageCPRMapper has everything it needs to render\n    if (!model.renderable.preRenderCheck()) {\n      return;\n    }\n    model.currentImageDataInput = model.renderable.getInputData(0);\n    model.currentCenterlineInput = model.renderable.getOrientedCenterline();\n    publicAPI.renderPieceStart(ren, prop);\n    publicAPI.renderPieceDraw(ren, prop);\n    publicAPI.renderPieceFinish(ren, prop);\n  };\n  publicAPI.renderPieceStart = (ren, actor) => {\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor);\n  };\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const gl = model.context;\n\n    // activate the texture\n    model.volumeTexture.activate();\n    model.colorTexture.activate();\n    model.pwfTexture.activate();\n\n    // draw polygons\n    if (model.tris.getCABO().getElementCount()) {\n      // First we do the triangles, update the shader, set uniforms, etc.\n      publicAPI.updateShaders(model.tris, ren, actor);\n      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n      model.tris.getVAO().release();\n    }\n    model.volumeTexture.deactivate();\n    model.colorTexture.deactivate();\n    model.pwfTexture.deactivate();\n  };\n  publicAPI.renderPieceFinish = (ren, actor) => {};\n  publicAPI.updateBufferObjects = (ren, actor) => {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {\n    // first do a coarse check\n    // Note that the actor's mtime includes it's properties mtime\n    const vmtime = model.VBOBuildTime.getMTime();\n    if (vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentImageDataInput.getMTime() || vmtime < model.currentCenterlineInput.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const image = model.currentImageDataInput;\n    const centerline = model.currentCenterlineInput;\n    const actorProperty = actor.getProperty();\n\n    // Set interpolation on the texture based on property setting\n    if (actorProperty.getInterpolationType() === InterpolationType.NEAREST) {\n      model.volumeTexture.setMinificationFilter(Filter.NEAREST);\n      model.volumeTexture.setMagnificationFilter(Filter.NEAREST);\n      model.colorTexture.setMinificationFilter(Filter.NEAREST);\n      model.colorTexture.setMagnificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMinificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMagnificationFilter(Filter.NEAREST);\n    } else {\n      model.volumeTexture.setMinificationFilter(Filter.LINEAR);\n      model.volumeTexture.setMagnificationFilter(Filter.LINEAR);\n      model.colorTexture.setMinificationFilter(Filter.LINEAR);\n      model.colorTexture.setMagnificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMinificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMagnificationFilter(Filter.LINEAR);\n    }\n\n    // Rebuild the volumeTexture if the data has changed\n    const imageTime = image.getMTime();\n    if (model.volumeTextureTime !== imageTime) {\n      // Build the textures\n      const dims = image.getDimensions();\n      const scalars = image.getPointData().getScalars();\n      if (!scalars) {\n        return;\n      }\n      // Use norm16 for scalar texture if the extension is available\n      model.volumeTexture.setOglNorm16Ext(model.context.getExtension('EXT_texture_norm16'));\n      model.volumeTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.volumeTexture.resetFormatAndType();\n      model.volumeTexture.create3DFilterableFromRaw(dims[0], dims[1], dims[2], scalars.getNumberOfComponents(), scalars.getDataType(), scalars.getData(), model.renderable.getPreferSizeOverAccuracy());\n      model.volumeTextureTime = imageTime;\n    }\n\n    // Rebuild the color texture if needed\n    const scalars = image.getPointData() && image.getPointData().getScalars();\n    if (!scalars) {\n      return;\n    }\n    const numComp = scalars.getNumberOfComponents();\n    const ppty = actor.getProperty();\n    const iComps = ppty.getIndependentComponents();\n    const numIComps = iComps ? numComp : 1;\n    const textureHeight = iComps ? 2 * numIComps : 1;\n    const cfunToString = computeFnToString(ppty, ppty.getRGBTransferFunction, numIComps);\n    if (model.colorTextureString !== cfunToString) {\n      const cWidth = 1024;\n      const cSize = cWidth * textureHeight * 3;\n      const cTable = new Uint8Array(cSize);\n      let cfun = ppty.getRGBTransferFunction();\n      if (cfun) {\n        const tmpTable = new Float32Array(cWidth * 3);\n        for (let c = 0; c < numIComps; c++) {\n          cfun = ppty.getRGBTransferFunction(c);\n          const cRange = cfun.getRange();\n          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);\n          if (iComps) {\n            for (let i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];\n            }\n          } else {\n            for (let i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n            }\n          }\n        }\n        model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);\n        model.colorTexture.resetFormatAndType();\n        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      } else {\n        for (let i = 0; i < cWidth * 3; ++i) {\n          cTable[i] = 255.0 * i / ((cWidth - 1) * 3);\n          cTable[i + 1] = 255.0 * i / ((cWidth - 1) * 3);\n          cTable[i + 2] = 255.0 * i / ((cWidth - 1) * 3);\n        }\n        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      }\n      model.colorTextureString = cfunToString;\n    }\n\n    // Build piecewise function buffer.  This buffer is used either\n    // for component weighting or opacity, depending on whether we're\n    // rendering components independently or not.\n    const pwfunToString = computeFnToString(ppty, ppty.getPiecewiseFunction, numIComps);\n    if (model.pwfTextureString !== pwfunToString) {\n      const pwfWidth = 1024;\n      const pwfSize = pwfWidth * textureHeight;\n      const pwfTable = new Uint8Array(pwfSize);\n      let pwfun = ppty.getPiecewiseFunction();\n      // support case where pwfun is added/removed\n      model.pwfTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.pwfTexture.resetFormatAndType();\n      if (pwfun) {\n        const pwfFloatTable = new Float32Array(pwfSize);\n        const tmpTable = new Float32Array(pwfWidth);\n        for (let c = 0; c < numIComps; ++c) {\n          pwfun = ppty.getPiecewiseFunction(c);\n          if (pwfun === null) {\n            // Piecewise constant max if no function supplied for this component\n            pwfFloatTable.fill(1.0);\n          } else {\n            const pwfRange = pwfun.getRange();\n            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);\n            // adjust for sample distance etc\n            if (iComps) {\n              for (let i = 0; i < pwfWidth; i++) {\n                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];\n                pwfFloatTable[c * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];\n              }\n            } else {\n              for (let i = 0; i < pwfWidth; i++) {\n                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];\n              }\n            }\n          }\n        }\n        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);\n      } else {\n        // default is opaque\n        pwfTable.fill(255.0);\n        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);\n      }\n      model.pwfTextureString = pwfunToString;\n    }\n\n    // Rebuild the image vertices if needed\n    if (model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < centerline.getMTime()) {\n      const nPoints = centerline.getNumberOfPoints();\n      const nLines = nPoints <= 1 ? 0 : nPoints - 1;\n      const distances = centerline.getDistancesToFirstPoint();\n      const totalHeight = model.renderable.getHeight();\n      const nPts = 4 * nLines;\n\n      // Create the array of point: 4 points per segment\n      const ptsArray = new Float32Array(3 * nPts);\n      const widthMC = model.renderable.getWidth();\n      for (let lineIdx = 0, offset = 0; lineIdx < nLines; ++lineIdx) {\n        // Use model coordinates\n        // See \"setCameraShaderParameters\" to see how MCPCMatrix is built\n\n        // Top left\n        ptsArray.set([0, totalHeight - distances[lineIdx], 0], offset);\n        offset += 3;\n        // Top right\n        ptsArray.set([widthMC, totalHeight - distances[lineIdx], 0], offset);\n        offset += 3;\n        // Bottom right\n        ptsArray.set([widthMC, totalHeight - distances[lineIdx + 1], 0], offset);\n        offset += 3;\n        // Bottom left\n        ptsArray.set([0, totalHeight - distances[lineIdx + 1], 0], offset);\n        offset += 3;\n      }\n      const points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: ptsArray\n      });\n      points.setName('points');\n\n      // Create the array of cells: a quad per segment\n      const cellArray = new Uint16Array(5 * nLines);\n      for (let lineIdx = 0, offset = 0, ptIdx = 0; lineIdx < nLines; ++lineIdx) {\n        cellArray.set([4, ptIdx + 3, ptIdx + 2, ptIdx + 1, ptIdx], offset);\n        offset += 5;\n        ptIdx += 4;\n      }\n      const cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: cellArray\n      });\n\n      // Create the array of centerline positions (VBO custom attribute)\n      const pointsDataArray = centerline.getPoints();\n      const centerlinePositionArray = new Float32Array(3 * nPts);\n      const pa = new Array(3);\n      const pb = new Array(3);\n      for (let lineIdx = 0, offset = 0; lineIdx < nLines; ++lineIdx) {\n        pointsDataArray.getPoint(lineIdx, pa);\n        pointsDataArray.getPoint(lineIdx + 1, pb);\n\n        // Top left\n        centerlinePositionArray.set(pa, offset);\n        offset += 3;\n        // Top right\n        centerlinePositionArray.set(pa, offset);\n        offset += 3;\n        // Bottom right\n        centerlinePositionArray.set(pb, offset);\n        offset += 3;\n        // Bottom left\n        centerlinePositionArray.set(pb, offset);\n        offset += 3;\n      }\n      const centerlinePosition = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: centerlinePositionArray,\n        name: 'centerlinePosition'\n      });\n\n      // Create the array of quad index:\n      //   0 ____ 1\n      //    |    |\n      //    |____|\n      //   2      3\n      const quadIndexArray = new Float32Array(nPts);\n      for (let lineIdx = 0, offset = 0; lineIdx < nLines; ++lineIdx) {\n        quadIndexArray.set([0,\n        // Top left\n        1,\n        // Top right\n        3,\n        // Bottom right\n        2 // Bottom left\n        ], offset);\n        offset += 4;\n      }\n      const quadIndex = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: quadIndexArray,\n        name: 'quadIndex'\n      });\n      const customAttributes = [centerlinePosition, quadIndex];\n      if (!model.renderable.getUseUniformOrientation()) {\n        // For each {quad / centerline segment}, two vectors in directionDataArray give the orientation of the centerline\n        // Send these two vectors to each vertex and use flat interpolation to get them as is in the fragment shader\n        // The interpolation will occur in the fragment shader (slerp)\n        const directions = model.renderable.getCenterlineTangentDirections();\n        const centerlineTopDirectionArray = new Float32Array(3 * nPts);\n        const centerlineBotDirectionArray = new Float32Array(3 * nPts);\n        for (let lineIdx = 0, offset = 0; lineIdx < nLines; ++lineIdx) {\n          const baseDirectionIdx = 3 * lineIdx;\n\n          // Every vertex of each quad/segment have the same topDir and botDir\n          // Top left, Top right, Bottom right, Bottom left\n          for (let i = 0; i < 4; ++i) {\n            // Top array\n            centerlineTopDirectionArray[offset + 0] = directions[baseDirectionIdx + 0];\n            centerlineTopDirectionArray[offset + 1] = directions[baseDirectionIdx + 1];\n            centerlineTopDirectionArray[offset + 2] = directions[baseDirectionIdx + 2];\n            // Bot array\n            centerlineBotDirectionArray[offset + 0] = directions[baseDirectionIdx + 3];\n            centerlineBotDirectionArray[offset + 1] = directions[baseDirectionIdx + 4];\n            centerlineBotDirectionArray[offset + 2] = directions[baseDirectionIdx + 5];\n            offset += 3;\n          }\n        }\n        const centerlineTopDirection = vtkDataArray.newInstance({\n          numberOfComponents: 3,\n          values: centerlineTopDirectionArray,\n          name: 'centerlineTopDirection'\n        });\n        const centerlineBotDirection = vtkDataArray.newInstance({\n          numberOfComponents: 3,\n          values: centerlineBotDirectionArray,\n          name: 'centerlineBotDirection'\n        });\n        customAttributes.push(centerlineTopDirection, centerlineBotDirection);\n      }\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n        points,\n        customAttributes\n      });\n      model.VBOBuildTime.modified();\n    }\n  };\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // presence of centerPoint\n    // value of useUniformOrientation\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    // render pass shader replacement changed\n\n    const tNumComp = model.volumeTexture.getComponents();\n    const iComp = actor.getProperty().getIndependentComponents();\n    const useCenterPoint = !!model.renderable.getCenterPoint();\n    const useUniformOrientation = model.renderable.getUseUniformOrientation();\n    if (cellBO.getProgram() === 0 || model.lastUseCenterPoint !== useCenterPoint || model.lastUseUniformOrientation !== useUniformOrientation || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {\n      model.lastUseCenterPoint = useCenterPoint;\n      model.lastUseUniformOrientation = useUniformOrientation;\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      model.lastTextureComponents = tNumComp;\n      model.lastIndependentComponents = iComp;\n      return true;\n    }\n    return false;\n  };\n  publicAPI.buildShaders = (shaders, ren, actor) => {\n    publicAPI.getShaderTemplate(shaders, ren, actor);\n    publicAPI.replaceShaderValues(shaders, ren, actor);\n  };\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n\n    // Vertex shader main replacements\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;\n    const vsColorDec = ['attribute vec3 centerlinePosition;', 'attribute float quadIndex;', 'uniform float width;', 'out vec2 quadOffsetVSOutput;', 'out vec3 centerlinePosVSOutput;'];\n    const isDirectionUniform = model.renderable.getUseUniformOrientation();\n    if (isDirectionUniform) {\n      vsColorDec.push('out vec3 centerlineDirVSOutput;', 'uniform vec3 centerlineDirection;');\n    } else {\n      vsColorDec.push('out vec3 centerlineTopDirVSOutput;', 'out vec3 centerlineBotDirVSOutput;', 'out float centerlineAngleVSOutput;', 'attribute vec3 centerlineTopDirection;', 'attribute vec3 centerlineBotDirection;');\n    }\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Dec', vsColorDec).result;\n    const vsColorImpl = [\n    // quadOffsetVSOutput.x: left = -0.5* width; right = 0.5 * width\n    // quadOffsetVSOutput.y: bottom = 0.0; top = 1.0;\n    'quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);', 'centerlinePosVSOutput = centerlinePosition;'];\n    if (isDirectionUniform) {\n      vsColorImpl.push('centerlineDirVSOutput = centerlineDirection;');\n    } else {\n      vsColorImpl.push(\n      // When u and v are unit vectors: uvAngle = 2 * atan2(|| u - v ||, || u + v ||)\n      // When u != -v: || u + v || > 0\n      // When x > 0: atan2(y, x) = atan(y/x)\n      // Thus: dirAngle = 2 * atan(|| topDir - botDir || / || topDir + botDir ||)\n      // This is more stable and should not be to slow compared to acos(dot(u, v))\n      'vec3 sumVec = centerlineTopDirection + centerlineBotDirection;', 'float sumLen2 = dot(sumVec, sumVec);', 'float diffLen2 = 4.0 - sumLen2;', 'if (diffLen2 < 0.001) {', '  // vectors are too close to each other, use lerp', '  centerlineAngleVSOutput = -1.0; // use negative angle as a flag for lerp', '  centerlineTopDirVSOutput = centerlineTopDirection;', '  centerlineBotDirVSOutput = centerlineBotDirection;', '} else if (sumLen2 == 0.0) {', \"  // vector are opposite to each other, don't make a choice for the user\", '  // use slerp without direction, it will display the centerline color on each row of pixel', '  centerlineAngleVSOutput = 0.0;', '  centerlineTopDirVSOutput = vec3(0.0);', '  centerlineBotDirVSOutput = vec3(0.0);', '} else {', '  // use slerp', '  centerlineAngleVSOutput = 2.0 * atan(sqrt(diffLen2/sumLen2));', '  float sinAngle = sin(centerlineAngleVSOutput);', '  centerlineTopDirVSOutput = centerlineTopDirection / sinAngle;', '  centerlineBotDirVSOutput = centerlineBotDirection / sinAngle;', '}');\n    }\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Impl', vsColorImpl).result;\n\n    // Fragment shader main replacements\n    const tNumComp = model.volumeTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n    let tcoordFSDec = [\n    // used to compute texture coordinates of the sample\n    'uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates', 'in vec2 quadOffsetVSOutput;', 'in vec3 centerlinePosVSOutput;',\n    // volume texture\n    'uniform highp sampler3D volumeTexture;',\n    // color and pwf textures\n    'uniform sampler2D colorTexture1;', 'uniform sampler2D pwfTexture1;',\n    // opacity\n    'uniform float opacity;',\n    // background color (out of volume samples)\n    'uniform vec4 backgroundColor;',\n    // color shift and scale\n    `uniform float cshift0;`, `uniform float cscale0;`,\n    // weighting shift and scale\n    `uniform float pwfshift0;`, `uniform float pwfscale0;`];\n    if (isDirectionUniform) {\n      tcoordFSDec.push('in vec3 centerlineDirVSOutput;');\n    } else {\n      tcoordFSDec.push('in vec3 centerlineTopDirVSOutput;', 'in vec3 centerlineBotDirVSOutput;', 'in float centerlineAngleVSOutput;');\n    }\n    const centerPoint = model.renderable.getCenterPoint();\n    if (centerPoint) {\n      tcoordFSDec.push('uniform vec3 globalCenterPoint;');\n    }\n    if (iComps) {\n      for (let comp = 1; comp < tNumComp; comp++) {\n        tcoordFSDec = tcoordFSDec.concat([\n        // color shift and scale\n        `uniform float cshift${comp};`, `uniform float cscale${comp};`,\n        // weighting shift and scale\n        `uniform float pwfshift${comp};`, `uniform float pwfscale${comp};`]);\n      }\n      // the heights defined below are the locations\n      // for the up to four components of the tfuns\n      // the tfuns have a height of 2XnumComps pixels so the\n      // values are computed to hit the middle of the two rows\n      // for that component\n      switch (tNumComp) {\n        case 1:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', '#define height0 0.5']);\n          break;\n        case 2:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', '#define height0 0.25', '#define height1 0.75']);\n          break;\n        case 3:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', '#define height0 0.17', '#define height1 0.5', '#define height2 0.83']);\n          break;\n        case 4:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', 'uniform float mix3;', '#define height0 0.125', '#define height1 0.375', '#define height2 0.625', '#define height3 0.875']);\n          break;\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', tcoordFSDec).result;\n    let tcoordFSImpl = [];\n    if (isDirectionUniform) {\n      tcoordFSImpl.push('vec3 interpolatedCenterlineDir = centerlineDirVSOutput;');\n    } else {\n      // Slerp or lerp between centerlineTopDirVSOutput and centerlineBotDirVSOutput\n      // We use quadOffsetVSOutput.y: bottom = 0.0; top = 1.0;\n      tcoordFSImpl.push('vec3 interpolatedCenterlineDir;', 'if (centerlineAngleVSOutput < 0.0) {', '  // Lerp', '  interpolatedCenterlineDir = quadOffsetVSOutput.y * centerlineTopDirVSOutput + (1.0 - quadOffsetVSOutput.y) * centerlineBotDirVSOutput;', '} else {', '  // Slerp', '  float topInterpolationAngle = quadOffsetVSOutput.y * centerlineAngleVSOutput;', '  float botInterpolationAngle = centerlineAngleVSOutput - topInterpolationAngle;', '  interpolatedCenterlineDir = sin(topInterpolationAngle) * centerlineTopDirVSOutput + sin(botInterpolationAngle) * centerlineBotDirVSOutput;', '}', '// Slerp should give a normalized vector but when sin(angle) is small, rounding error occurs', '// Normalize for both lerp and slerp', 'interpolatedCenterlineDir = normalize(interpolatedCenterlineDir);');\n    }\n    if (centerPoint) {\n      tcoordFSImpl.push('float baseOffset = dot(interpolatedCenterlineDir, globalCenterPoint - centerlinePosVSOutput);', 'float horizontalOffset = quadOffsetVSOutput.x + baseOffset;');\n    } else {\n      tcoordFSImpl.push('float horizontalOffset = quadOffsetVSOutput.x;');\n    }\n    tcoordFSImpl.push('vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * interpolatedCenterlineDir;', 'vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;', 'if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))', '{', '  // set the background color and exit', '  gl_FragData[0] = backgroundColor;', '  return;', '}', 'vec4 tvalue = texture(volumeTexture, volumePosTC);');\n    if (iComps) {\n      const rgba = ['r', 'g', 'b', 'a'];\n      for (let comp = 0; comp < tNumComp; ++comp) {\n        tcoordFSImpl = tcoordFSImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);\n      }\n      switch (tNumComp) {\n        case 1:\n          tcoordFSImpl = tcoordFSImpl.concat(['gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);']);\n          break;\n        case 2:\n          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);']);\n          break;\n        case 3:\n          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);']);\n          break;\n        case 4:\n          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);']);\n          break;\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n    } else {\n      // dependent components\n      switch (tNumComp) {\n        case 1:\n          tcoordFSImpl = tcoordFSImpl.concat(['// Dependent components', 'float intensity = tvalue.r;', 'vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;', 'float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;', 'gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);']);\n          break;\n        case 2:\n          tcoordFSImpl = tcoordFSImpl.concat(['float intensity = tvalue.r*cscale0 + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);']);\n          break;\n        case 3:\n          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);']);\n          break;\n        default:\n          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);']);\n      }\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', tcoordFSImpl).result;\n\n    // Picking shader replacements\n    if (model.haveSeenDepthRequest) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    publicAPI.replaceShaderClip(shaders, ren, actor);\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n  };\n  publicAPI.replaceShaderClip = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      if (numClipPlanes > 6) {\n        macro.vtkErrorMacro('OpenGL has a limit of 6 clipping planes');\n        numClipPlanes = 6;\n      }\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'uniform vec4 clipPlanes[6];', 'varying float clipDistancesVSOutput[6];']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'varying float clipDistancesVSOutput[6];']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkPolyDataVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexMC in shader VAO.');\n        }\n      }\n      // Custom data of the CABO (centerlinePosition, centerlineTopDirection,\n      // centerlineBotDirection, quadIndex and user defined custom data)\n      cellBO.getCABO().getCustomData().forEach(data => {\n        if (data && cellBO.getProgram().isAttributeUsed(data.name) && !cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), data.name, data.offset, cellBO.getCABO().getStride(), model.context.FLOAT, data.components, model.context.FALSE)) {\n          vtkErrorMacro(`Error setting ${data.name} in shader VAO.`);\n        }\n      });\n      cellBO.getAttributeUpdateTime().modified();\n    }\n    const texUnit = model.volumeTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('volumeTexture', texUnit);\n    cellBO.getProgram().setUniformf('width', model.renderable.getWidth());\n    cellBO.getProgram().setUniform4f('backgroundColor', ...model.renderable.getBackgroundColor());\n    if (cellBO.getProgram().isUniformUsed('centerlineDirection')) {\n      const uniformDirection = model.renderable.getUniformDirection();\n      cellBO.getProgram().setUniform3fArray('centerlineDirection', uniformDirection);\n    }\n    if (cellBO.getProgram().isUniformUsed('globalCenterPoint')) {\n      const centerPoint = model.renderable.getCenterPoint();\n      cellBO.getProgram().setUniform3fArray('globalCenterPoint', centerPoint);\n    }\n\n    // Model coordinates to image space\n    // getWorldToIndex is badly named and is in fact modelToIndex\n    // MCIC -> Model coordinates to index coordinates\n    // MCTC -> Model coordinates to texture coordinates\n    const image = model.currentImageDataInput;\n    const MCICMatrix = image.getWorldToIndex();\n    const ICTCMatrix = mat4.fromScaling(new Float32Array(16), vec3.inverse([], image.getDimensions()));\n    const MCTCMatrix = mat4.mul(ICTCMatrix, ICTCMatrix, MCICMatrix);\n    cellBO.getProgram().setUniformMatrix('MCTCMatrix', MCTCMatrix);\n    if (model.haveSeenDepthRequest) {\n      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    }\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      // add all the clipping planes\n      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      if (numClipPlanes > 6) {\n        macro.vtkErrorMacro('OpenGL has a limit of 6 clipping planes');\n        numClipPlanes = 6;\n      }\n      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n      const mat = inverseShiftScaleMatrix ? mat4.copy(model.imagematinv, actor.getMatrix()) : actor.getMatrix();\n      if (inverseShiftScaleMatrix) {\n        mat4.transpose(mat, mat);\n        mat4.multiply(mat, mat, inverseShiftScaleMatrix);\n        mat4.transpose(mat, mat);\n      }\n\n      // transform crop plane normal with transpose(inverse(worldToIndex))\n      mat4.transpose(model.imagemat, model.currentImageDataInput.getIndexToWorld());\n      mat4.multiply(model.imagematinv, mat, model.imagemat);\n      const planeEquations = [];\n      for (let i = 0; i < numClipPlanes; i++) {\n        const planeEquation = [];\n        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, i, planeEquation);\n        for (let j = 0; j < 4; j++) {\n          planeEquations.push(planeEquation[j]);\n        }\n      }\n      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);\n      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);\n    }\n\n    // handle coincident\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      const cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset);\n      // cfactor isn't always used when coffset is.\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    }\n  };\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    const MCWCMatrix = model.openGLImageSlice.getKeyMatrices().mcwc;\n    const WCPCMatrix = model.openGLCamera.getKeyMatrices(ren).wcpc;\n    mat4.multiply(model.imagemat, WCPCMatrix, MCWCMatrix);\n    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {\n      const inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();\n      mat4.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);\n    }\n    cellBO.getProgram().setUniformMatrix('MCPCMatrix', model.imagemat);\n  };\n  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    const ppty = actor.getProperty();\n    const opacity = ppty.getOpacity();\n    program.setUniformf('opacity', opacity);\n\n    // Component mix\n    // Independent components: Mixed according to component weights\n    // Dependent components: Mixed using the following logic:\n    //    - 2 comps => LA\n    //    - 3 comps => RGB + opacity from pwf\n    //    - 4 comps => RGBA\n    const numComp = model.volumeTexture.getComponents();\n    const iComps = ppty.getIndependentComponents();\n    if (iComps) {\n      for (let i = 0; i < numComp; ++i) {\n        program.setUniformf(`mix${i}`, ppty.getComponentWeight(i));\n      }\n    }\n\n    // Color opacity map\n    const volInfo = model.volumeTexture.getVolumeInfo();\n\n    // three levels of shift scale combined into one\n    // for performance in the fragment shader\n    for (let i = 0; i < numComp; i++) {\n      let cw = ppty.getColorWindow();\n      let cl = ppty.getColorLevel();\n      const target = iComps ? i : 0;\n      const cfun = ppty.getRGBTransferFunction(target);\n      if (cfun && ppty.getUseLookupTableScalarRange()) {\n        const cRange = cfun.getRange();\n        cw = cRange[1] - cRange[0];\n        cl = 0.5 * (cRange[1] + cRange[0]);\n      }\n      const scale = volInfo.scale[i] / cw;\n      const shift = (volInfo.offset[i] - cl) / cw + 0.5;\n      program.setUniformf(`cshift${i}`, shift);\n      program.setUniformf(`cscale${i}`, scale);\n    }\n    const texColorUnit = model.colorTexture.getTextureUnit(); // TODO\n    program.setUniformi('colorTexture1', texColorUnit);\n\n    // pwf shift/scale\n    for (let i = 0; i < numComp; i++) {\n      let pwfScale = 1.0;\n      let pwfShift = 0.0;\n      const target = iComps ? i : 0;\n      const pwfun = ppty.getPiecewiseFunction(target);\n      if (pwfun) {\n        const pwfRange = pwfun.getRange();\n        const length = pwfRange[1] - pwfRange[0];\n        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);\n        pwfScale = volInfo.scale[i] / length;\n        pwfShift = (volInfo.offset[i] - mid) / length + 0.5;\n      }\n      program.setUniformf(`pwfshift${i}`, pwfShift);\n      program.setUniformf(`pwfscale${i}`, pwfScale);\n    }\n    const texOpacityUnit = model.pwfTexture.getTextureUnit(); // TODO\n    program.setUniformi('pwfTexture1', texOpacityUnit);\n  };\n  publicAPI.updateShaders = (cellBO, ren, actor) => {\n    // has something changed that would require us to recreate the shader?\n    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {\n      const shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      publicAPI.buildShaders(shaders, ren, actor);\n\n      // compile and bind the program if needed\n      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);\n\n      // if the shader changed reinitialize the VAO\n      if (newShader !== cellBO.getProgram()) {\n        cellBO.setProgram(newShader);\n        // reset the VAO as the shader has changed\n        cellBO.getVAO().releaseGraphicsResources();\n      }\n      cellBO.getShaderSourceTime().modified();\n    } else {\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());\n    }\n    cellBO.getVAO().bind();\n    publicAPI.setMapperShaderParameters(cellBO, ren, actor);\n    publicAPI.setCameraShaderParameters(cellBO, ren, actor);\n    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  currentRenderPass: null,\n  volumeTexture: null,\n  volumeTextureTime: 0,\n  colorTexture: null,\n  colorTextureString: null,\n  pwfTexture: null,\n  pwfTextureString: null,\n  tris: null,\n  lastHaveSeenDepthRequest: false,\n  haveSeenDepthRequest: false,\n  lastTextureComponents: 0,\n  lastIndependentComponents: 0,\n  imagemat: null,\n  imagematinv: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n\n  // Two inputs: one for the ImageData/Texture and one for the PolyData (centerline)\n  macro.algo(publicAPI, model, 2, 0);\n  model.tris = vtkHelper.newInstance();\n  model.volumeTexture = vtkOpenGLTexture.newInstance();\n  model.colorTexture = vtkOpenGLTexture.newInstance();\n  model.pwfTexture = vtkOpenGLTexture.newInstance();\n  model.imagemat = mat4.identity(new Float64Array(16));\n  model.imagematinv = mat4.identity(new Float64Array(16));\n  model.VBOBuildTime = {};\n  macro.obj(model.VBOBuildTime, {\n    mtime: 0\n  });\n\n  // Object methods\n  vtkOpenGLImageCPRMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkOpenGLImageCPRMapper');\nconst STATIC = {};\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkImageCPRMapper', newInstance);\nexport { STATIC, index as default, extend, newInstance };","map":{"version":3,"names":["m","macro","mat4","vec3","vtkViewNode","vtkHelper","vtkReplacementShaderMapper","vtkShaderProgram","vtkOpenGLTexture","vtkDataArray","VtkDataTypes","Representation","Filter","InterpolationType","v","vtkPolyDataVS","vtkPolyDataFS","registerOverride","vtkErrorMacro","computeFnToString","property","fn","numberOfComponents","pwfun","apply","iComps","getIndependentComponents","getMTime","vtkOpenGLImageCPRMapper","publicAPI","model","classHierarchy","push","buildPass","prepass","currentRenderPass","openGLImageSlice","getFirstAncestorOfType","_openGLRenderer","_openGLRenderWindow","getParent","context","getContext","openGLCamera","getViewNodeFor","getRenderable","getActiveCamera","tris","setOpenGLRenderWindow","volumeTexture","colorTexture","pwfTexture","opaquePass","renderPass","render","opaqueZBufferPass","haveSeenDepthRequest","renderDepth","getCoincidentParameters","ren","actor","renderable","getResolveCoincidentTopology","getCoincidentTopologyPolygonOffsetParameters","prop","renderPiece","invokeEvent","type","update","preRenderCheck","currentImageDataInput","getInputData","currentCenterlineInput","getOrientedCenterline","renderPieceStart","renderPieceDraw","renderPieceFinish","updateBufferObjects","gl","activate","getCABO","getElementCount","updateShaders","drawArrays","TRIANGLES","getVAO","release","deactivate","getNeedToRebuildBufferObjects","buildBufferObjects","vmtime","VBOBuildTime","image","centerline","actorProperty","getProperty","getInterpolationType","NEAREST","setMinificationFilter","setMagnificationFilter","LINEAR","imageTime","volumeTextureTime","dims","getDimensions","scalars","getPointData","getScalars","setOglNorm16Ext","getExtension","releaseGraphicsResources","resetFormatAndType","create3DFilterableFromRaw","getNumberOfComponents","getDataType","getData","getPreferSizeOverAccuracy","numComp","ppty","numIComps","textureHeight","cfunToString","getRGBTransferFunction","colorTextureString","cWidth","cSize","cTable","Uint8Array","cfun","tmpTable","Float32Array","c","cRange","getRange","getTable","i","create2DFromRaw","UNSIGNED_CHAR","pwfunToString","getPiecewiseFunction","pwfTextureString","pwfWidth","pwfSize","pwfTable","pwfFloatTable","fill","pwfRange","FLOAT","nPoints","getNumberOfPoints","nLines","distances","getDistancesToFirstPoint","totalHeight","getHeight","nPts","ptsArray","widthMC","getWidth","lineIdx","offset","set","points","newInstance","values","setName","cellArray","Uint16Array","ptIdx","cells","pointsDataArray","getPoints","centerlinePositionArray","pa","Array","pb","getPoint","centerlinePosition","name","quadIndexArray","quadIndex","customAttributes","getUseUniformOrientation","directions","getCenterlineTangentDirections","centerlineTopDirectionArray","centerlineBotDirectionArray","baseDirectionIdx","centerlineTopDirection","centerlineBotDirection","createVBO","SURFACE","modified","getNeedToRebuildShaders","cellBO","tNumComp","getComponents","iComp","useCenterPoint","getCenterPoint","useUniformOrientation","getProgram","lastUseCenterPoint","lastUseUniformOrientation","lastHaveSeenDepthRequest","lastTextureComponents","lastIndependentComponents","buildShaders","shaders","getShaderTemplate","replaceShaderValues","VSSource","Vertex","FSSource","Fragment","substitute","result","vsColorDec","isDirectionUniform","vsColorImpl","tcoordFSDec","centerPoint","comp","concat","tcoordFSImpl","rgba","replaceShaderClip","replaceShaderCoincidentOffset","getNumberOfClippingPlanes","numClipPlanes","Geometry","setMapperShaderParameters","getAttributeUpdateTime","getShaderSourceTime","isAttributeUsed","addAttributeArray","getVertexOffset","getStride","FALSE","getCustomData","forEach","data","components","texUnit","getTextureUnit","setUniformi","setUniformf","setUniform4f","getBackgroundColor","isUniformUsed","uniformDirection","getUniformDirection","setUniform3fArray","MCICMatrix","getWorldToIndex","ICTCMatrix","fromScaling","inverse","MCTCMatrix","mul","setUniformMatrix","shiftScaleEnabled","getCoordShiftAndScaleEnabled","inverseShiftScaleMatrix","getInverseShiftAndScaleMatrix","mat","copy","imagematinv","getMatrix","transpose","multiply","imagemat","getIndexToWorld","planeEquations","planeEquation","getClippingPlaneInDataCoords","j","setUniform4fv","cp","factor","setCameraShaderParameters","MCWCMatrix","getKeyMatrices","mcwc","WCPCMatrix","wcpc","inverseShiftScaleMat","setPropertyShaderParameters","program","opacity","getOpacity","getComponentWeight","volInfo","getVolumeInfo","cw","getColorWindow","cl","getColorLevel","target","getUseLookupTableScalarRange","scale","shift","texColorUnit","pwfScale","pwfShift","length","mid","texOpacityUnit","newShader","getShaderCache","readyShaderProgramArray","setProgram","readyShaderProgram","bind","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","implementReplaceShaderCoincidentOffset","algo","identity","Float64Array","obj","mtime","STATIC","index","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageCPRMapper.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport { mat4, vec3 } from 'gl-matrix';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport vtkHelper from './Helper.js';\nimport vtkReplacementShaderMapper from './ReplacementShaderMapper.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { Filter } from './Texture/Constants.js';\nimport { InterpolationType } from '../Core/ImageProperty/Constants.js';\nimport { v as vtkPolyDataVS } from './glsl/vtkPolyDataVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n\nfunction computeFnToString(property, fn, numberOfComponents) {\n  const pwfun = fn.apply(property);\n  if (pwfun) {\n    const iComps = property.getIndependentComponents();\n    return `${property.getMTime()}-${iComps}-${numberOfComponents}`;\n  }\n  return '0';\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLImageCPRMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLImageCPRMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLImageCPRMapper');\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model.openGLImageSlice = publicAPI.getFirstAncestorOfType('vtkOpenGLImageSlice');\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.context = model._openGLRenderWindow.getContext();\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.volumeTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n    }\n  };\n  publicAPI.opaquePass = (prepass, renderPass) => {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n  publicAPI.opaqueZBufferPass = prepass => {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n  publicAPI.getCoincidentParameters = (ren, actor) => {\n    if (model.renderable.getResolveCoincidentTopology()) {\n      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n    }\n    return null;\n  };\n  publicAPI.render = () => {\n    const prop = model.openGLImageSlice.getRenderable();\n    const ren = model._openGLRenderer.getRenderable();\n    publicAPI.renderPiece(ren, prop);\n  };\n  publicAPI.renderPiece = (ren, prop) => {\n    publicAPI.invokeEvent({\n      type: 'StartEvent'\n    });\n    model.renderable.update();\n    publicAPI.invokeEvent({\n      type: 'EndEvent'\n    });\n\n    // Check if the ImageCPRMapper has everything it needs to render\n    if (!model.renderable.preRenderCheck()) {\n      return;\n    }\n    model.currentImageDataInput = model.renderable.getInputData(0);\n    model.currentCenterlineInput = model.renderable.getOrientedCenterline();\n    publicAPI.renderPieceStart(ren, prop);\n    publicAPI.renderPieceDraw(ren, prop);\n    publicAPI.renderPieceFinish(ren, prop);\n  };\n  publicAPI.renderPieceStart = (ren, actor) => {\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor);\n  };\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const gl = model.context;\n\n    // activate the texture\n    model.volumeTexture.activate();\n    model.colorTexture.activate();\n    model.pwfTexture.activate();\n\n    // draw polygons\n    if (model.tris.getCABO().getElementCount()) {\n      // First we do the triangles, update the shader, set uniforms, etc.\n      publicAPI.updateShaders(model.tris, ren, actor);\n      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n      model.tris.getVAO().release();\n    }\n    model.volumeTexture.deactivate();\n    model.colorTexture.deactivate();\n    model.pwfTexture.deactivate();\n  };\n  publicAPI.renderPieceFinish = (ren, actor) => {};\n  publicAPI.updateBufferObjects = (ren, actor) => {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {\n    // first do a coarse check\n    // Note that the actor's mtime includes it's properties mtime\n    const vmtime = model.VBOBuildTime.getMTime();\n    if (vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentImageDataInput.getMTime() || vmtime < model.currentCenterlineInput.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const image = model.currentImageDataInput;\n    const centerline = model.currentCenterlineInput;\n    const actorProperty = actor.getProperty();\n\n    // Set interpolation on the texture based on property setting\n    if (actorProperty.getInterpolationType() === InterpolationType.NEAREST) {\n      model.volumeTexture.setMinificationFilter(Filter.NEAREST);\n      model.volumeTexture.setMagnificationFilter(Filter.NEAREST);\n      model.colorTexture.setMinificationFilter(Filter.NEAREST);\n      model.colorTexture.setMagnificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMinificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMagnificationFilter(Filter.NEAREST);\n    } else {\n      model.volumeTexture.setMinificationFilter(Filter.LINEAR);\n      model.volumeTexture.setMagnificationFilter(Filter.LINEAR);\n      model.colorTexture.setMinificationFilter(Filter.LINEAR);\n      model.colorTexture.setMagnificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMinificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMagnificationFilter(Filter.LINEAR);\n    }\n\n    // Rebuild the volumeTexture if the data has changed\n    const imageTime = image.getMTime();\n    if (model.volumeTextureTime !== imageTime) {\n      // Build the textures\n      const dims = image.getDimensions();\n      const scalars = image.getPointData().getScalars();\n      if (!scalars) {\n        return;\n      }\n      // Use norm16 for scalar texture if the extension is available\n      model.volumeTexture.setOglNorm16Ext(model.context.getExtension('EXT_texture_norm16'));\n      model.volumeTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.volumeTexture.resetFormatAndType();\n      model.volumeTexture.create3DFilterableFromRaw(dims[0], dims[1], dims[2], scalars.getNumberOfComponents(), scalars.getDataType(), scalars.getData(), model.renderable.getPreferSizeOverAccuracy());\n      model.volumeTextureTime = imageTime;\n    }\n\n    // Rebuild the color texture if needed\n    const scalars = image.getPointData() && image.getPointData().getScalars();\n    if (!scalars) {\n      return;\n    }\n    const numComp = scalars.getNumberOfComponents();\n    const ppty = actor.getProperty();\n    const iComps = ppty.getIndependentComponents();\n    const numIComps = iComps ? numComp : 1;\n    const textureHeight = iComps ? 2 * numIComps : 1;\n    const cfunToString = computeFnToString(ppty, ppty.getRGBTransferFunction, numIComps);\n    if (model.colorTextureString !== cfunToString) {\n      const cWidth = 1024;\n      const cSize = cWidth * textureHeight * 3;\n      const cTable = new Uint8Array(cSize);\n      let cfun = ppty.getRGBTransferFunction();\n      if (cfun) {\n        const tmpTable = new Float32Array(cWidth * 3);\n        for (let c = 0; c < numIComps; c++) {\n          cfun = ppty.getRGBTransferFunction(c);\n          const cRange = cfun.getRange();\n          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);\n          if (iComps) {\n            for (let i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];\n            }\n          } else {\n            for (let i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n            }\n          }\n        }\n        model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);\n        model.colorTexture.resetFormatAndType();\n        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      } else {\n        for (let i = 0; i < cWidth * 3; ++i) {\n          cTable[i] = 255.0 * i / ((cWidth - 1) * 3);\n          cTable[i + 1] = 255.0 * i / ((cWidth - 1) * 3);\n          cTable[i + 2] = 255.0 * i / ((cWidth - 1) * 3);\n        }\n        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      }\n      model.colorTextureString = cfunToString;\n    }\n\n    // Build piecewise function buffer.  This buffer is used either\n    // for component weighting or opacity, depending on whether we're\n    // rendering components independently or not.\n    const pwfunToString = computeFnToString(ppty, ppty.getPiecewiseFunction, numIComps);\n    if (model.pwfTextureString !== pwfunToString) {\n      const pwfWidth = 1024;\n      const pwfSize = pwfWidth * textureHeight;\n      const pwfTable = new Uint8Array(pwfSize);\n      let pwfun = ppty.getPiecewiseFunction();\n      // support case where pwfun is added/removed\n      model.pwfTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.pwfTexture.resetFormatAndType();\n      if (pwfun) {\n        const pwfFloatTable = new Float32Array(pwfSize);\n        const tmpTable = new Float32Array(pwfWidth);\n        for (let c = 0; c < numIComps; ++c) {\n          pwfun = ppty.getPiecewiseFunction(c);\n          if (pwfun === null) {\n            // Piecewise constant max if no function supplied for this component\n            pwfFloatTable.fill(1.0);\n          } else {\n            const pwfRange = pwfun.getRange();\n            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);\n            // adjust for sample distance etc\n            if (iComps) {\n              for (let i = 0; i < pwfWidth; i++) {\n                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];\n                pwfFloatTable[c * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];\n              }\n            } else {\n              for (let i = 0; i < pwfWidth; i++) {\n                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];\n              }\n            }\n          }\n        }\n        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);\n      } else {\n        // default is opaque\n        pwfTable.fill(255.0);\n        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);\n      }\n      model.pwfTextureString = pwfunToString;\n    }\n\n    // Rebuild the image vertices if needed\n    if (model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < centerline.getMTime()) {\n      const nPoints = centerline.getNumberOfPoints();\n      const nLines = nPoints <= 1 ? 0 : nPoints - 1;\n      const distances = centerline.getDistancesToFirstPoint();\n      const totalHeight = model.renderable.getHeight();\n      const nPts = 4 * nLines;\n\n      // Create the array of point: 4 points per segment\n      const ptsArray = new Float32Array(3 * nPts);\n      const widthMC = model.renderable.getWidth();\n      for (let lineIdx = 0, offset = 0; lineIdx < nLines; ++lineIdx) {\n        // Use model coordinates\n        // See \"setCameraShaderParameters\" to see how MCPCMatrix is built\n\n        // Top left\n        ptsArray.set([0, totalHeight - distances[lineIdx], 0], offset);\n        offset += 3;\n        // Top right\n        ptsArray.set([widthMC, totalHeight - distances[lineIdx], 0], offset);\n        offset += 3;\n        // Bottom right\n        ptsArray.set([widthMC, totalHeight - distances[lineIdx + 1], 0], offset);\n        offset += 3;\n        // Bottom left\n        ptsArray.set([0, totalHeight - distances[lineIdx + 1], 0], offset);\n        offset += 3;\n      }\n      const points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: ptsArray\n      });\n      points.setName('points');\n\n      // Create the array of cells: a quad per segment\n      const cellArray = new Uint16Array(5 * nLines);\n      for (let lineIdx = 0, offset = 0, ptIdx = 0; lineIdx < nLines; ++lineIdx) {\n        cellArray.set([4, ptIdx + 3, ptIdx + 2, ptIdx + 1, ptIdx], offset);\n        offset += 5;\n        ptIdx += 4;\n      }\n      const cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: cellArray\n      });\n\n      // Create the array of centerline positions (VBO custom attribute)\n      const pointsDataArray = centerline.getPoints();\n      const centerlinePositionArray = new Float32Array(3 * nPts);\n      const pa = new Array(3);\n      const pb = new Array(3);\n      for (let lineIdx = 0, offset = 0; lineIdx < nLines; ++lineIdx) {\n        pointsDataArray.getPoint(lineIdx, pa);\n        pointsDataArray.getPoint(lineIdx + 1, pb);\n\n        // Top left\n        centerlinePositionArray.set(pa, offset);\n        offset += 3;\n        // Top right\n        centerlinePositionArray.set(pa, offset);\n        offset += 3;\n        // Bottom right\n        centerlinePositionArray.set(pb, offset);\n        offset += 3;\n        // Bottom left\n        centerlinePositionArray.set(pb, offset);\n        offset += 3;\n      }\n      const centerlinePosition = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: centerlinePositionArray,\n        name: 'centerlinePosition'\n      });\n\n      // Create the array of quad index:\n      //   0 ____ 1\n      //    |    |\n      //    |____|\n      //   2      3\n      const quadIndexArray = new Float32Array(nPts);\n      for (let lineIdx = 0, offset = 0; lineIdx < nLines; ++lineIdx) {\n        quadIndexArray.set([0,\n        // Top left\n        1,\n        // Top right\n        3,\n        // Bottom right\n        2 // Bottom left\n        ], offset);\n        offset += 4;\n      }\n      const quadIndex = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: quadIndexArray,\n        name: 'quadIndex'\n      });\n      const customAttributes = [centerlinePosition, quadIndex];\n      if (!model.renderable.getUseUniformOrientation()) {\n        // For each {quad / centerline segment}, two vectors in directionDataArray give the orientation of the centerline\n        // Send these two vectors to each vertex and use flat interpolation to get them as is in the fragment shader\n        // The interpolation will occur in the fragment shader (slerp)\n        const directions = model.renderable.getCenterlineTangentDirections();\n        const centerlineTopDirectionArray = new Float32Array(3 * nPts);\n        const centerlineBotDirectionArray = new Float32Array(3 * nPts);\n        for (let lineIdx = 0, offset = 0; lineIdx < nLines; ++lineIdx) {\n          const baseDirectionIdx = 3 * lineIdx;\n\n          // Every vertex of each quad/segment have the same topDir and botDir\n          // Top left, Top right, Bottom right, Bottom left\n          for (let i = 0; i < 4; ++i) {\n            // Top array\n            centerlineTopDirectionArray[offset + 0] = directions[baseDirectionIdx + 0];\n            centerlineTopDirectionArray[offset + 1] = directions[baseDirectionIdx + 1];\n            centerlineTopDirectionArray[offset + 2] = directions[baseDirectionIdx + 2];\n            // Bot array\n            centerlineBotDirectionArray[offset + 0] = directions[baseDirectionIdx + 3];\n            centerlineBotDirectionArray[offset + 1] = directions[baseDirectionIdx + 4];\n            centerlineBotDirectionArray[offset + 2] = directions[baseDirectionIdx + 5];\n            offset += 3;\n          }\n        }\n        const centerlineTopDirection = vtkDataArray.newInstance({\n          numberOfComponents: 3,\n          values: centerlineTopDirectionArray,\n          name: 'centerlineTopDirection'\n        });\n        const centerlineBotDirection = vtkDataArray.newInstance({\n          numberOfComponents: 3,\n          values: centerlineBotDirectionArray,\n          name: 'centerlineBotDirection'\n        });\n        customAttributes.push(centerlineTopDirection, centerlineBotDirection);\n      }\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n        points,\n        customAttributes\n      });\n      model.VBOBuildTime.modified();\n    }\n  };\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // presence of centerPoint\n    // value of useUniformOrientation\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    // render pass shader replacement changed\n\n    const tNumComp = model.volumeTexture.getComponents();\n    const iComp = actor.getProperty().getIndependentComponents();\n    const useCenterPoint = !!model.renderable.getCenterPoint();\n    const useUniformOrientation = model.renderable.getUseUniformOrientation();\n    if (cellBO.getProgram() === 0 || model.lastUseCenterPoint !== useCenterPoint || model.lastUseUniformOrientation !== useUniformOrientation || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {\n      model.lastUseCenterPoint = useCenterPoint;\n      model.lastUseUniformOrientation = useUniformOrientation;\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      model.lastTextureComponents = tNumComp;\n      model.lastIndependentComponents = iComp;\n      return true;\n    }\n    return false;\n  };\n  publicAPI.buildShaders = (shaders, ren, actor) => {\n    publicAPI.getShaderTemplate(shaders, ren, actor);\n    publicAPI.replaceShaderValues(shaders, ren, actor);\n  };\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n\n    // Vertex shader main replacements\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;\n    const vsColorDec = ['attribute vec3 centerlinePosition;', 'attribute float quadIndex;', 'uniform float width;', 'out vec2 quadOffsetVSOutput;', 'out vec3 centerlinePosVSOutput;'];\n    const isDirectionUniform = model.renderable.getUseUniformOrientation();\n    if (isDirectionUniform) {\n      vsColorDec.push('out vec3 centerlineDirVSOutput;', 'uniform vec3 centerlineDirection;');\n    } else {\n      vsColorDec.push('out vec3 centerlineTopDirVSOutput;', 'out vec3 centerlineBotDirVSOutput;', 'out float centerlineAngleVSOutput;', 'attribute vec3 centerlineTopDirection;', 'attribute vec3 centerlineBotDirection;');\n    }\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Dec', vsColorDec).result;\n    const vsColorImpl = [\n    // quadOffsetVSOutput.x: left = -0.5* width; right = 0.5 * width\n    // quadOffsetVSOutput.y: bottom = 0.0; top = 1.0;\n    'quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);', 'centerlinePosVSOutput = centerlinePosition;'];\n    if (isDirectionUniform) {\n      vsColorImpl.push('centerlineDirVSOutput = centerlineDirection;');\n    } else {\n      vsColorImpl.push(\n      // When u and v are unit vectors: uvAngle = 2 * atan2(|| u - v ||, || u + v ||)\n      // When u != -v: || u + v || > 0\n      // When x > 0: atan2(y, x) = atan(y/x)\n      // Thus: dirAngle = 2 * atan(|| topDir - botDir || / || topDir + botDir ||)\n      // This is more stable and should not be to slow compared to acos(dot(u, v))\n      'vec3 sumVec = centerlineTopDirection + centerlineBotDirection;', 'float sumLen2 = dot(sumVec, sumVec);', 'float diffLen2 = 4.0 - sumLen2;', 'if (diffLen2 < 0.001) {', '  // vectors are too close to each other, use lerp', '  centerlineAngleVSOutput = -1.0; // use negative angle as a flag for lerp', '  centerlineTopDirVSOutput = centerlineTopDirection;', '  centerlineBotDirVSOutput = centerlineBotDirection;', '} else if (sumLen2 == 0.0) {', \"  // vector are opposite to each other, don't make a choice for the user\", '  // use slerp without direction, it will display the centerline color on each row of pixel', '  centerlineAngleVSOutput = 0.0;', '  centerlineTopDirVSOutput = vec3(0.0);', '  centerlineBotDirVSOutput = vec3(0.0);', '} else {', '  // use slerp', '  centerlineAngleVSOutput = 2.0 * atan(sqrt(diffLen2/sumLen2));', '  float sinAngle = sin(centerlineAngleVSOutput);', '  centerlineTopDirVSOutput = centerlineTopDirection / sinAngle;', '  centerlineBotDirVSOutput = centerlineBotDirection / sinAngle;', '}');\n    }\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Impl', vsColorImpl).result;\n\n    // Fragment shader main replacements\n    const tNumComp = model.volumeTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n    let tcoordFSDec = [\n    // used to compute texture coordinates of the sample\n    'uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates', 'in vec2 quadOffsetVSOutput;', 'in vec3 centerlinePosVSOutput;',\n    // volume texture\n    'uniform highp sampler3D volumeTexture;',\n    // color and pwf textures\n    'uniform sampler2D colorTexture1;', 'uniform sampler2D pwfTexture1;',\n    // opacity\n    'uniform float opacity;',\n    // background color (out of volume samples)\n    'uniform vec4 backgroundColor;',\n    // color shift and scale\n    `uniform float cshift0;`, `uniform float cscale0;`,\n    // weighting shift and scale\n    `uniform float pwfshift0;`, `uniform float pwfscale0;`];\n    if (isDirectionUniform) {\n      tcoordFSDec.push('in vec3 centerlineDirVSOutput;');\n    } else {\n      tcoordFSDec.push('in vec3 centerlineTopDirVSOutput;', 'in vec3 centerlineBotDirVSOutput;', 'in float centerlineAngleVSOutput;');\n    }\n    const centerPoint = model.renderable.getCenterPoint();\n    if (centerPoint) {\n      tcoordFSDec.push('uniform vec3 globalCenterPoint;');\n    }\n    if (iComps) {\n      for (let comp = 1; comp < tNumComp; comp++) {\n        tcoordFSDec = tcoordFSDec.concat([\n        // color shift and scale\n        `uniform float cshift${comp};`, `uniform float cscale${comp};`,\n        // weighting shift and scale\n        `uniform float pwfshift${comp};`, `uniform float pwfscale${comp};`]);\n      }\n      // the heights defined below are the locations\n      // for the up to four components of the tfuns\n      // the tfuns have a height of 2XnumComps pixels so the\n      // values are computed to hit the middle of the two rows\n      // for that component\n      switch (tNumComp) {\n        case 1:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', '#define height0 0.5']);\n          break;\n        case 2:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', '#define height0 0.25', '#define height1 0.75']);\n          break;\n        case 3:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', '#define height0 0.17', '#define height1 0.5', '#define height2 0.83']);\n          break;\n        case 4:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', 'uniform float mix3;', '#define height0 0.125', '#define height1 0.375', '#define height2 0.625', '#define height3 0.875']);\n          break;\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', tcoordFSDec).result;\n    let tcoordFSImpl = [];\n    if (isDirectionUniform) {\n      tcoordFSImpl.push('vec3 interpolatedCenterlineDir = centerlineDirVSOutput;');\n    } else {\n      // Slerp or lerp between centerlineTopDirVSOutput and centerlineBotDirVSOutput\n      // We use quadOffsetVSOutput.y: bottom = 0.0; top = 1.0;\n      tcoordFSImpl.push('vec3 interpolatedCenterlineDir;', 'if (centerlineAngleVSOutput < 0.0) {', '  // Lerp', '  interpolatedCenterlineDir = quadOffsetVSOutput.y * centerlineTopDirVSOutput + (1.0 - quadOffsetVSOutput.y) * centerlineBotDirVSOutput;', '} else {', '  // Slerp', '  float topInterpolationAngle = quadOffsetVSOutput.y * centerlineAngleVSOutput;', '  float botInterpolationAngle = centerlineAngleVSOutput - topInterpolationAngle;', '  interpolatedCenterlineDir = sin(topInterpolationAngle) * centerlineTopDirVSOutput + sin(botInterpolationAngle) * centerlineBotDirVSOutput;', '}', '// Slerp should give a normalized vector but when sin(angle) is small, rounding error occurs', '// Normalize for both lerp and slerp', 'interpolatedCenterlineDir = normalize(interpolatedCenterlineDir);');\n    }\n    if (centerPoint) {\n      tcoordFSImpl.push('float baseOffset = dot(interpolatedCenterlineDir, globalCenterPoint - centerlinePosVSOutput);', 'float horizontalOffset = quadOffsetVSOutput.x + baseOffset;');\n    } else {\n      tcoordFSImpl.push('float horizontalOffset = quadOffsetVSOutput.x;');\n    }\n    tcoordFSImpl.push('vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * interpolatedCenterlineDir;', 'vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;', 'if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))', '{', '  // set the background color and exit', '  gl_FragData[0] = backgroundColor;', '  return;', '}', 'vec4 tvalue = texture(volumeTexture, volumePosTC);');\n    if (iComps) {\n      const rgba = ['r', 'g', 'b', 'a'];\n      for (let comp = 0; comp < tNumComp; ++comp) {\n        tcoordFSImpl = tcoordFSImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);\n      }\n      switch (tNumComp) {\n        case 1:\n          tcoordFSImpl = tcoordFSImpl.concat(['gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);']);\n          break;\n        case 2:\n          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);']);\n          break;\n        case 3:\n          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);']);\n          break;\n        case 4:\n          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);']);\n          break;\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n    } else {\n      // dependent components\n      switch (tNumComp) {\n        case 1:\n          tcoordFSImpl = tcoordFSImpl.concat(['// Dependent components', 'float intensity = tvalue.r;', 'vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;', 'float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;', 'gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);']);\n          break;\n        case 2:\n          tcoordFSImpl = tcoordFSImpl.concat(['float intensity = tvalue.r*cscale0 + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);']);\n          break;\n        case 3:\n          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);']);\n          break;\n        default:\n          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);']);\n      }\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', tcoordFSImpl).result;\n\n    // Picking shader replacements\n    if (model.haveSeenDepthRequest) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    publicAPI.replaceShaderClip(shaders, ren, actor);\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n  };\n  publicAPI.replaceShaderClip = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      if (numClipPlanes > 6) {\n        macro.vtkErrorMacro('OpenGL has a limit of 6 clipping planes');\n        numClipPlanes = 6;\n      }\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'uniform vec4 clipPlanes[6];', 'varying float clipDistancesVSOutput[6];']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'varying float clipDistancesVSOutput[6];']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkPolyDataVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexMC in shader VAO.');\n        }\n      }\n      // Custom data of the CABO (centerlinePosition, centerlineTopDirection,\n      // centerlineBotDirection, quadIndex and user defined custom data)\n      cellBO.getCABO().getCustomData().forEach(data => {\n        if (data && cellBO.getProgram().isAttributeUsed(data.name) && !cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), data.name, data.offset, cellBO.getCABO().getStride(), model.context.FLOAT, data.components, model.context.FALSE)) {\n          vtkErrorMacro(`Error setting ${data.name} in shader VAO.`);\n        }\n      });\n      cellBO.getAttributeUpdateTime().modified();\n    }\n    const texUnit = model.volumeTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('volumeTexture', texUnit);\n    cellBO.getProgram().setUniformf('width', model.renderable.getWidth());\n    cellBO.getProgram().setUniform4f('backgroundColor', ...model.renderable.getBackgroundColor());\n    if (cellBO.getProgram().isUniformUsed('centerlineDirection')) {\n      const uniformDirection = model.renderable.getUniformDirection();\n      cellBO.getProgram().setUniform3fArray('centerlineDirection', uniformDirection);\n    }\n    if (cellBO.getProgram().isUniformUsed('globalCenterPoint')) {\n      const centerPoint = model.renderable.getCenterPoint();\n      cellBO.getProgram().setUniform3fArray('globalCenterPoint', centerPoint);\n    }\n\n    // Model coordinates to image space\n    // getWorldToIndex is badly named and is in fact modelToIndex\n    // MCIC -> Model coordinates to index coordinates\n    // MCTC -> Model coordinates to texture coordinates\n    const image = model.currentImageDataInput;\n    const MCICMatrix = image.getWorldToIndex();\n    const ICTCMatrix = mat4.fromScaling(new Float32Array(16), vec3.inverse([], image.getDimensions()));\n    const MCTCMatrix = mat4.mul(ICTCMatrix, ICTCMatrix, MCICMatrix);\n    cellBO.getProgram().setUniformMatrix('MCTCMatrix', MCTCMatrix);\n    if (model.haveSeenDepthRequest) {\n      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    }\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      // add all the clipping planes\n      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      if (numClipPlanes > 6) {\n        macro.vtkErrorMacro('OpenGL has a limit of 6 clipping planes');\n        numClipPlanes = 6;\n      }\n      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n      const mat = inverseShiftScaleMatrix ? mat4.copy(model.imagematinv, actor.getMatrix()) : actor.getMatrix();\n      if (inverseShiftScaleMatrix) {\n        mat4.transpose(mat, mat);\n        mat4.multiply(mat, mat, inverseShiftScaleMatrix);\n        mat4.transpose(mat, mat);\n      }\n\n      // transform crop plane normal with transpose(inverse(worldToIndex))\n      mat4.transpose(model.imagemat, model.currentImageDataInput.getIndexToWorld());\n      mat4.multiply(model.imagematinv, mat, model.imagemat);\n      const planeEquations = [];\n      for (let i = 0; i < numClipPlanes; i++) {\n        const planeEquation = [];\n        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, i, planeEquation);\n        for (let j = 0; j < 4; j++) {\n          planeEquations.push(planeEquation[j]);\n        }\n      }\n      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);\n      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);\n    }\n\n    // handle coincident\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      const cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset);\n      // cfactor isn't always used when coffset is.\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    }\n  };\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    const MCWCMatrix = model.openGLImageSlice.getKeyMatrices().mcwc;\n    const WCPCMatrix = model.openGLCamera.getKeyMatrices(ren).wcpc;\n    mat4.multiply(model.imagemat, WCPCMatrix, MCWCMatrix);\n    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {\n      const inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();\n      mat4.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);\n    }\n    cellBO.getProgram().setUniformMatrix('MCPCMatrix', model.imagemat);\n  };\n  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    const ppty = actor.getProperty();\n    const opacity = ppty.getOpacity();\n    program.setUniformf('opacity', opacity);\n\n    // Component mix\n    // Independent components: Mixed according to component weights\n    // Dependent components: Mixed using the following logic:\n    //    - 2 comps => LA\n    //    - 3 comps => RGB + opacity from pwf\n    //    - 4 comps => RGBA\n    const numComp = model.volumeTexture.getComponents();\n    const iComps = ppty.getIndependentComponents();\n    if (iComps) {\n      for (let i = 0; i < numComp; ++i) {\n        program.setUniformf(`mix${i}`, ppty.getComponentWeight(i));\n      }\n    }\n\n    // Color opacity map\n    const volInfo = model.volumeTexture.getVolumeInfo();\n\n    // three levels of shift scale combined into one\n    // for performance in the fragment shader\n    for (let i = 0; i < numComp; i++) {\n      let cw = ppty.getColorWindow();\n      let cl = ppty.getColorLevel();\n      const target = iComps ? i : 0;\n      const cfun = ppty.getRGBTransferFunction(target);\n      if (cfun && ppty.getUseLookupTableScalarRange()) {\n        const cRange = cfun.getRange();\n        cw = cRange[1] - cRange[0];\n        cl = 0.5 * (cRange[1] + cRange[0]);\n      }\n      const scale = volInfo.scale[i] / cw;\n      const shift = (volInfo.offset[i] - cl) / cw + 0.5;\n      program.setUniformf(`cshift${i}`, shift);\n      program.setUniformf(`cscale${i}`, scale);\n    }\n    const texColorUnit = model.colorTexture.getTextureUnit(); // TODO\n    program.setUniformi('colorTexture1', texColorUnit);\n\n    // pwf shift/scale\n    for (let i = 0; i < numComp; i++) {\n      let pwfScale = 1.0;\n      let pwfShift = 0.0;\n      const target = iComps ? i : 0;\n      const pwfun = ppty.getPiecewiseFunction(target);\n      if (pwfun) {\n        const pwfRange = pwfun.getRange();\n        const length = pwfRange[1] - pwfRange[0];\n        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);\n        pwfScale = volInfo.scale[i] / length;\n        pwfShift = (volInfo.offset[i] - mid) / length + 0.5;\n      }\n      program.setUniformf(`pwfshift${i}`, pwfShift);\n      program.setUniformf(`pwfscale${i}`, pwfScale);\n    }\n    const texOpacityUnit = model.pwfTexture.getTextureUnit(); // TODO\n    program.setUniformi('pwfTexture1', texOpacityUnit);\n  };\n  publicAPI.updateShaders = (cellBO, ren, actor) => {\n    // has something changed that would require us to recreate the shader?\n    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {\n      const shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      publicAPI.buildShaders(shaders, ren, actor);\n\n      // compile and bind the program if needed\n      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);\n\n      // if the shader changed reinitialize the VAO\n      if (newShader !== cellBO.getProgram()) {\n        cellBO.setProgram(newShader);\n        // reset the VAO as the shader has changed\n        cellBO.getVAO().releaseGraphicsResources();\n      }\n      cellBO.getShaderSourceTime().modified();\n    } else {\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());\n    }\n    cellBO.getVAO().bind();\n    publicAPI.setMapperShaderParameters(cellBO, ren, actor);\n    publicAPI.setCameraShaderParameters(cellBO, ren, actor);\n    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  currentRenderPass: null,\n  volumeTexture: null,\n  volumeTextureTime: 0,\n  colorTexture: null,\n  colorTextureString: null,\n  pwfTexture: null,\n  pwfTextureString: null,\n  tris: null,\n  lastHaveSeenDepthRequest: false,\n  haveSeenDepthRequest: false,\n  lastTextureComponents: 0,\n  lastIndependentComponents: 0,\n  imagemat: null,\n  imagematinv: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n\n  // Two inputs: one for the ImageData/Texture and one for the PolyData (centerline)\n  macro.algo(publicAPI, model, 2, 0);\n  model.tris = vtkHelper.newInstance();\n  model.volumeTexture = vtkOpenGLTexture.newInstance();\n  model.colorTexture = vtkOpenGLTexture.newInstance();\n  model.pwfTexture = vtkOpenGLTexture.newInstance();\n  model.imagemat = mat4.identity(new Float64Array(16));\n  model.imagematinv = mat4.identity(new Float64Array(16));\n  model.VBOBuildTime = {};\n  macro.obj(model.VBOBuildTime, {\n    mtime: 0\n  });\n\n  // Object methods\n  vtkOpenGLImageCPRMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkOpenGLImageCPRMapper');\nconst STATIC = {};\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkImageCPRMapper', newInstance);\n\nexport { STATIC, index as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}