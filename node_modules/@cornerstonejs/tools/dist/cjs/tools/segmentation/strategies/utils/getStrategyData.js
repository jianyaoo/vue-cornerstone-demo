"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStrategyData = void 0;
const core_1 = require("@cornerstonejs/core");
const stackVolumeCheck_1 = require("./stackVolumeCheck");
const { VoxelManager } = core_1.utilities;
function getStrategyData({ operationData, viewport }) {
    var _a;
    let segmentationImageData, segmentationScalarData, imageScalarData;
    let imageDimensions;
    let segmentationDimensions;
    let imageVoxelManager;
    let segmentationVoxelManager;
    if ((0, stackVolumeCheck_1.isVolumeSegmentation)(operationData, viewport)) {
        const { volumeId, referencedVolumeId } = operationData;
        const segmentationVolume = core_1.cache.getVolume(volumeId);
        if (!segmentationVolume) {
            return;
        }
        segmentationVoxelManager = segmentationVolume.voxelManager;
        if (referencedVolumeId) {
            const imageVolume = core_1.cache.getVolume(referencedVolumeId);
            imageScalarData = imageVolume.getScalarData();
            imageDimensions = imageVolume.dimensions;
        }
        ({ imageData: segmentationImageData } = segmentationVolume);
        segmentationScalarData = segmentationVolume.getScalarData();
        segmentationDimensions = segmentationVolume.dimensions;
    }
    else {
        const { imageIdReferenceMap, segmentationRepresentationUID } = operationData;
        if (!imageIdReferenceMap) {
            return;
        }
        const currentImageId = viewport.getCurrentImageId();
        if (!currentImageId) {
            return;
        }
        const actor = viewport.getActor(segmentationRepresentationUID);
        if (!actor) {
            return;
        }
        segmentationImageData = actor.actor.getMapper().getInputData();
        segmentationVoxelManager = segmentationImageData.voxelManager;
        const currentSegmentationImageId = imageIdReferenceMap.get(currentImageId);
        const segmentationImage = core_1.cache.getImage(currentSegmentationImageId);
        if (!segmentationImage) {
            return;
        }
        segmentationScalarData = (_a = segmentationImage.getPixelData) === null || _a === void 0 ? void 0 : _a.call(segmentationImage);
        const image = core_1.cache.getImage(currentImageId);
        const imageData = image ? null : viewport.getImageData();
        imageScalarData = (image === null || image === void 0 ? void 0 : image.getPixelData()) || imageData.getScalarData();
        imageDimensions = image
            ? [image.columns, image.rows, 1]
            : imageData.dimensions;
        segmentationDimensions = [
            segmentationImage.columns,
            segmentationImage.rows,
            1,
        ];
        imageVoxelManager = image === null || image === void 0 ? void 0 : image.voxelManager;
    }
    segmentationVoxelManager || (segmentationVoxelManager = VoxelManager.createVolumeVoxelManager(segmentationDimensions, segmentationScalarData));
    imageVoxelManager || (imageVoxelManager = imageDimensions &&
        VoxelManager.createVolumeVoxelManager(imageDimensions, imageScalarData));
    return {
        segmentationImageData,
        segmentationScalarData,
        segmentationVoxelManager,
        imageScalarData,
        imageVoxelManager,
    };
}
exports.getStrategyData = getStrategyData;
//# sourceMappingURL=getStrategyData.js.map