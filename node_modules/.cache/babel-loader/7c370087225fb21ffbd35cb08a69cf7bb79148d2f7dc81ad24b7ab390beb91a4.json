{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUTypes from './Types.js';\nconst {\n  BufferUsage\n} = vtkWebGPUBufferManager;\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUStorageBuffer - similar to the UniformBuffer class\n// but YOU are responsible for layout issues and alignment.\n// The order you add entries is the order they will be layed out\n// in memory. But you must follow layout rules.\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUStorageBuffer methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUStorageBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUStorageBuffer');\n  publicAPI.addEntry = (name, type) => {\n    if (model._bufferEntryNames.has(name)) {\n      vtkErrorMacro(`entry named ${name} already exists`);\n      return;\n    }\n    model._bufferEntryNames.set(name, model.bufferEntries.length);\n    const sizeInBytes = vtkWebGPUTypes.getByteStrideFromShaderFormat(type);\n    model.bufferEntries.push({\n      name,\n      type,\n      sizeInBytes,\n      offset: model.sizeInBytes,\n      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type)\n    });\n    model.sizeInBytes += sizeInBytes;\n  };\n  publicAPI.send = device => {\n    if (!model._buffer) {\n      const req = {\n        nativeArray: model.Float32Array,\n        usage: BufferUsage.Storage,\n        label: model.label\n      };\n      model._buffer = device.getBufferManager().getBuffer(req);\n      model.bindGroupTime.modified();\n      model._sendTime.modified();\n      return;\n    }\n    device.getHandle().queue.writeBuffer(model._buffer.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes * model.numberOfInstances);\n    model._sendTime.modified();\n  };\n  publicAPI.createView = type => {\n    if (type in model === false) {\n      if (!model.arrayBuffer) {\n        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes * model.numberOfInstances);\n      }\n      model[type] = macro.newTypedArray(type, model.arrayBuffer);\n    }\n  };\n  publicAPI.setValue = (name, instance, val) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    view[(entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT] = val;\n  };\n  publicAPI.setArray = (name, instance, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const ioffset = (entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n    for (let i = 0; i < arr.length; i++) {\n      view[ioffset + i] = arr[i];\n    }\n  };\n  publicAPI.setAllInstancesFromArray = (name, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const numComponents = arr.length / model.numberOfInstances;\n    for (let inst = 0; inst < model.numberOfInstances; inst++) {\n      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n      for (let i = 0; i < numComponents; i++) {\n        view[ioffset + i] = arr[inst * numComponents + i];\n      }\n    }\n  };\n  publicAPI.setAllInstancesFromArrayColorToFloat = (name, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const numComponents = arr.length / model.numberOfInstances;\n    for (let inst = 0; inst < model.numberOfInstances; inst++) {\n      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n      for (let i = 0; i < numComponents; i++) {\n        view[ioffset + i] = arr[inst * numComponents + i] / 255.0;\n      }\n    }\n  };\n  publicAPI.setAllInstancesFromArray3x3To4x4 = (name, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const numComponents = 9;\n    for (let inst = 0; inst < model.numberOfInstances; inst++) {\n      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n      for (let j = 0; j < 3; j++) {\n        for (let i = 0; i < 3; i++) {\n          view[ioffset + j * 4 + i] = arr[inst * numComponents + j * 3 + i];\n        }\n      }\n    }\n  };\n  publicAPI.getSendTime = () => model._sendTime.getMTime();\n  publicAPI.getShaderCode = (binding, group) => {\n    const lines = [`struct ${model.label}StructEntry\\n{`];\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      lines.push(`  ${entry.name}: ${entry.type},`);\n    }\n    lines.push(`\n};\nstruct ${model.label}Struct\n{\n  values: array<${model.label}StructEntry>,\n};\n@binding(${binding}) @group(${group}) var<storage, read> ${model.label}: ${model.label}Struct;\n`);\n    return lines.join('\\n');\n  };\n  publicAPI.getBindGroupEntry = () => {\n    const foo = {\n      resource: {\n        buffer: model._buffer.getHandle()\n      }\n    };\n    return foo;\n  };\n  publicAPI.clearData = () => {\n    model.numberOfInstances = 0;\n    model.sizeInBytes = 0;\n    model.bufferEntries = [];\n    model._bufferEntryNames = new Map();\n    model._buffer = null;\n    delete model.arrayBuffer;\n    delete model.Float32Array;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  bufferEntries: null,\n  bufferEntryNames: null,\n  sizeInBytes: 0,\n  label: null,\n  numberOfInstances: 1\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n\n  // Internal objects\n  model._bufferEntryNames = new Map();\n  model.bufferEntries = [];\n  model._sendTime = {};\n  macro.obj(model._sendTime, {\n    mtime: 0\n  });\n  model.bindGroupTime = {};\n  macro.obj(model.bindGroupTime, {\n    mtime: 0\n  });\n\n  // default SSBO desc\n  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {\n    buffer: {\n      type: 'read-only-storage'\n    }\n  };\n  macro.get(publicAPI, model, ['bindGroupTime']);\n  macro.setGet(publicAPI, model, ['device', 'bindGroupLayoutEntry', 'label', 'numberOfInstances', 'sizeInBytes']);\n\n  // Object methods\n  vtkWebGPUStorageBuffer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPUStorageBuffer');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUStorageBuffer$1 = {\n  newInstance,\n  extend\n};\nexport { vtkWebGPUStorageBuffer$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkWebGPUBufferManager","vtkWebGPUTypes","BufferUsage","vtkErrorMacro","vtkWebGPUStorageBuffer","publicAPI","model","classHierarchy","push","addEntry","name","type","_bufferEntryNames","has","set","bufferEntries","length","sizeInBytes","getByteStrideFromShaderFormat","offset","nativeType","getNativeTypeFromShaderFormat","send","device","_buffer","req","nativeArray","Float32Array","usage","Storage","label","getBufferManager","getBuffer","bindGroupTime","modified","_sendTime","getHandle","queue","writeBuffer","arrayBuffer","numberOfInstances","createView","ArrayBuffer","newTypedArray","setValue","instance","val","idx","get","undefined","entry","view","BYTES_PER_ELEMENT","setArray","arr","ioffset","i","setAllInstancesFromArray","numComponents","inst","setAllInstancesFromArrayColorToFloat","setAllInstancesFromArray3x3To4x4","j","getSendTime","getMTime","getShaderCode","binding","group","lines","join","getBindGroupEntry","foo","resource","buffer","clearData","Map","DEFAULT_VALUES","bufferEntryNames","extend","initialValues","arguments","Object","assign","obj","mtime","bindGroupLayoutEntry","setGet","newInstance","vtkWebGPUStorageBuffer$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/WebGPU/StorageBuffer.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUTypes from './Types.js';\n\nconst {\n  BufferUsage\n} = vtkWebGPUBufferManager;\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUStorageBuffer - similar to the UniformBuffer class\n// but YOU are responsible for layout issues and alignment.\n// The order you add entries is the order they will be layed out\n// in memory. But you must follow layout rules.\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUStorageBuffer methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUStorageBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUStorageBuffer');\n  publicAPI.addEntry = (name, type) => {\n    if (model._bufferEntryNames.has(name)) {\n      vtkErrorMacro(`entry named ${name} already exists`);\n      return;\n    }\n    model._bufferEntryNames.set(name, model.bufferEntries.length);\n    const sizeInBytes = vtkWebGPUTypes.getByteStrideFromShaderFormat(type);\n    model.bufferEntries.push({\n      name,\n      type,\n      sizeInBytes,\n      offset: model.sizeInBytes,\n      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type)\n    });\n    model.sizeInBytes += sizeInBytes;\n  };\n  publicAPI.send = device => {\n    if (!model._buffer) {\n      const req = {\n        nativeArray: model.Float32Array,\n        usage: BufferUsage.Storage,\n        label: model.label\n      };\n      model._buffer = device.getBufferManager().getBuffer(req);\n      model.bindGroupTime.modified();\n      model._sendTime.modified();\n      return;\n    }\n    device.getHandle().queue.writeBuffer(model._buffer.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes * model.numberOfInstances);\n    model._sendTime.modified();\n  };\n  publicAPI.createView = type => {\n    if (type in model === false) {\n      if (!model.arrayBuffer) {\n        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes * model.numberOfInstances);\n      }\n      model[type] = macro.newTypedArray(type, model.arrayBuffer);\n    }\n  };\n  publicAPI.setValue = (name, instance, val) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    view[(entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT] = val;\n  };\n  publicAPI.setArray = (name, instance, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const ioffset = (entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n    for (let i = 0; i < arr.length; i++) {\n      view[ioffset + i] = arr[i];\n    }\n  };\n  publicAPI.setAllInstancesFromArray = (name, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const numComponents = arr.length / model.numberOfInstances;\n    for (let inst = 0; inst < model.numberOfInstances; inst++) {\n      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n      for (let i = 0; i < numComponents; i++) {\n        view[ioffset + i] = arr[inst * numComponents + i];\n      }\n    }\n  };\n  publicAPI.setAllInstancesFromArrayColorToFloat = (name, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const numComponents = arr.length / model.numberOfInstances;\n    for (let inst = 0; inst < model.numberOfInstances; inst++) {\n      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n      for (let i = 0; i < numComponents; i++) {\n        view[ioffset + i] = arr[inst * numComponents + i] / 255.0;\n      }\n    }\n  };\n  publicAPI.setAllInstancesFromArray3x3To4x4 = (name, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const numComponents = 9;\n    for (let inst = 0; inst < model.numberOfInstances; inst++) {\n      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n      for (let j = 0; j < 3; j++) {\n        for (let i = 0; i < 3; i++) {\n          view[ioffset + j * 4 + i] = arr[inst * numComponents + j * 3 + i];\n        }\n      }\n    }\n  };\n  publicAPI.getSendTime = () => model._sendTime.getMTime();\n  publicAPI.getShaderCode = (binding, group) => {\n    const lines = [`struct ${model.label}StructEntry\\n{`];\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      lines.push(`  ${entry.name}: ${entry.type},`);\n    }\n    lines.push(`\n};\nstruct ${model.label}Struct\n{\n  values: array<${model.label}StructEntry>,\n};\n@binding(${binding}) @group(${group}) var<storage, read> ${model.label}: ${model.label}Struct;\n`);\n    return lines.join('\\n');\n  };\n  publicAPI.getBindGroupEntry = () => {\n    const foo = {\n      resource: {\n        buffer: model._buffer.getHandle()\n      }\n    };\n    return foo;\n  };\n  publicAPI.clearData = () => {\n    model.numberOfInstances = 0;\n    model.sizeInBytes = 0;\n    model.bufferEntries = [];\n    model._bufferEntryNames = new Map();\n    model._buffer = null;\n    delete model.arrayBuffer;\n    delete model.Float32Array;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  bufferEntries: null,\n  bufferEntryNames: null,\n  sizeInBytes: 0,\n  label: null,\n  numberOfInstances: 1\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n\n  // Internal objects\n  model._bufferEntryNames = new Map();\n  model.bufferEntries = [];\n  model._sendTime = {};\n  macro.obj(model._sendTime, {\n    mtime: 0\n  });\n  model.bindGroupTime = {};\n  macro.obj(model.bindGroupTime, {\n    mtime: 0\n  });\n\n  // default SSBO desc\n  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {\n    buffer: {\n      type: 'read-only-storage'\n    }\n  };\n  macro.get(publicAPI, model, ['bindGroupTime']);\n  macro.setGet(publicAPI, model, ['device', 'bindGroupLayoutEntry', 'label', 'numberOfInstances', 'sizeInBytes']);\n\n  // Object methods\n  vtkWebGPUStorageBuffer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPUStorageBuffer');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUStorageBuffer$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUStorageBuffer$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}