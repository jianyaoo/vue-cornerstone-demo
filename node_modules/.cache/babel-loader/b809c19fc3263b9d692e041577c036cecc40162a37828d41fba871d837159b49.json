{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { mat4, mat3 } from 'gl-matrix';\nimport { ObjectType } from './BufferObject/Constants.js';\nimport { n as newInstance$1, c as macro } from '../../macros2.js';\nimport vtkBufferObject from './BufferObject.js';\nimport { v as vtkStickMapperVS } from './glsl/vtkStickMapperVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkOpenGLPolyDataMapper from './PolyDataMapper.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLStickMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLStickMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLStickMapper');\n\n  // Capture 'parentClass' api for internal use\n  const superClass = {\n    ...publicAPI\n  };\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkStickMapperVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 VCPCMatrix;\\n', 'uniform mat4 MCVCMatrix;']).result;\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Dec', 'varying vec4 vertexVCVSOutput;').result;\n\n    // we create vertexVC below, so turn off the default\n    // implementation\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Impl', '  vec4 vertexVC = vertexVCVSOutput;\\n').result;\n\n    // for lights kit and positional the VCPC matrix is already defined\n    // so don't redefine it\n    const replacement = ['uniform int cameraParallel;\\n', 'varying float radiusVCVSOutput;\\n', 'varying vec3 orientVCVSOutput;\\n', 'varying float lengthVCVSOutput;\\n', 'varying vec3 centerVCVSOutput;\\n', 'uniform mat4 VCPCMatrix;\\n'];\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', replacement).result;\n    let fragString = '';\n    if (model.context.getExtension('EXT_frag_depth')) {\n      fragString = '  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n';\n    }\n    if (model._openGLRenderWindow.getWebgl2()) {\n      fragString = 'gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n';\n    }\n    // see https://www.cl.cam.ac.uk/teaching/1999/AGraphHCI/SMAG/node2.html\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', [\n    // compute the eye position and unit direction\n    '  vec3 EyePos;\\n', '  vec3 EyeDir;\\n', '  if (cameraParallel != 0) {\\n', '    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n', '    EyeDir = vec3(0.0,0.0,-1.0); }\\n', '  else {\\n', '    EyeDir = vertexVC.xyz;\\n', '    EyePos = vec3(0.0,0.0,0.0);\\n', '    float lengthED = length(EyeDir);\\n', '    EyeDir = normalize(EyeDir);\\n',\n    // we adjust the EyePos to be closer if it is too far away\n    // to prevent floating point precision noise\n    '    if (lengthED > radiusVCVSOutput*3.0) {\\n', '      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n', '    }\\n',\n    // translate to Stick center\n    '  EyePos = EyePos - centerVCVSOutput;\\n',\n    // rotate to new basis\n    // base1, base2, orientVC\n    '  vec3 base1;\\n', '  if (abs(orientVCVSOutput.z) < 0.99) {\\n', '    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\\n', '  else {\\n', '    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\\n', '  vec3 base2 = cross(orientVCVSOutput,base1);\\n', '  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\\n', '  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\\n',\n    // scale by radius\n    '  EyePos = EyePos/radiusVCVSOutput;\\n',\n    // find the intersection\n    '  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\\n', '  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\\n', '  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\\n', '  float d = b*b - 4.0*a*c;\\n', '  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n', '  if (d < 0.0) { discard; }\\n', '  else {\\n', '    float t =  (-b - sqrt(d))/(2.0*a);\\n', '    float tz = EyePos.z + t*EyeDir.z;\\n', '    vec3 iPoint = EyePos + t*EyeDir;\\n', '    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\\n',\n    // test for end cap\n    '      float t2 = (-b + sqrt(d))/(2.0*a);\\n', '      float tz2 = EyePos.z + t2*EyeDir.z;\\n', '      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\\n', '      else {\\n', '        normalVCVSOutput = orientVCVSOutput;\\n', '        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\\n', '        iPoint = EyePos + t3*EyeDir;\\n', '        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n', '        }\\n', '      }\\n', '    else {\\n',\n    // The normal is the iPoint.xy rotated back into VC\n    '      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\\n',\n    // rescale rerotate and translate\n    '      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n', '      }\\n', '    }\\n',\n    //    '  vec3 normalVC = vec3(0.0,0.0,1.0);\\n'\n    // compute the pixel's depth\n    '  vec4 pos = VCPCMatrix * vertexVC;\\n', fragString]).result;\n\n    // Strip out the normal line -- the normal is computed as part of the depth\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', '').result;\n    if (model.haveSeenDepthRequest) {\n      // special depth impl\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float computedZ = (pos.z / pos.w + 1.0) / 2.0;', 'float iz = floor(computedZ * 65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    superClass.replaceShaderValues(shaders, ren, actor);\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      if (cellBO.getProgram().isAttributeUsed('orientMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'orientMC', 12,\n        // after X Y Z\n        cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {\n          vtkErrorMacro(\"Error setting 'orientMC' in shader VAO.\");\n        }\n      }\n      if (cellBO.getProgram().isAttributeUsed('offsetMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), 'offsetMC', 0, cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 3, true)) {\n          vtkErrorMacro(\"Error setting 'offsetMC' in shader VAO.\");\n        }\n      }\n      if (cellBO.getProgram().isAttributeUsed('radiusMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'radiusMC', 24,\n        // X Y Z OX OY OZ\n        cellBO.getCABO().getStride(), model.context.FLOAT, 1, false)) {\n          vtkErrorMacro(\"Error setting 'radiusMC' in shader VAO.\");\n        }\n      }\n    }\n    superClass.setMapperShaderParameters(cellBO, ren, actor);\n  };\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    const cam = ren.getActiveCamera();\n    const keyMats = model.openGLCamera.getKeyMatrices(ren);\n    if (program.isUniformUsed('VCPCMatrix')) {\n      program.setUniformMatrix('VCPCMatrix', keyMats.vcpc);\n    }\n    if (!actor.getIsIdentity()) {\n      const actMats = model.openGLActor.getKeyMatrices();\n      if (program.isUniformUsed('MCVCMatrix')) {\n        const tmp4 = new Float64Array(16);\n        mat4.multiply(tmp4, keyMats.wcvc, actMats.mcwc);\n        program.setUniformMatrix('MCVCMatrix', tmp4);\n      }\n      if (program.isUniformUsed('normalMatrix')) {\n        const anorms = new Float64Array(9);\n        mat3.multiply(anorms, keyMats.normalMatrix, actMats.normalMatrix);\n        program.setUniformMatrix3x3('normalMatrix', anorms);\n      }\n    } else {\n      if (program.isUniformUsed('MCVCMatrix')) {\n        program.setUniformMatrix('MCVCMatrix', keyMats.wcvc);\n      }\n      if (program.isUniformUsed('normalMatrix')) {\n        program.setUniformMatrix3x3('normalMatrix', keyMats.normalMatrix);\n      }\n    }\n    if (program.isUniformUsed('cameraParallel')) {\n      cellBO.getProgram().setUniformi('cameraParallel', cam.getParallelProjection());\n    }\n  };\n  publicAPI.getOpenGLMode = (rep, type) => model.context.TRIANGLES;\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const poly = model.currentInput;\n    if (poly === null) {\n      return;\n    }\n    model.renderable.mapScalars(poly, 1.0);\n    const c = model.renderable.getColorMapColors();\n    const vbo = model.primitives[model.primTypes.Tris].getCABO();\n    const pointData = poly.getPointData();\n    const points = poly.getPoints();\n    const numPoints = points.getNumberOfPoints();\n    const pointArray = points.getData();\n    let pointSize = 3; // x,y,z\n\n    // three more floats for orientation + 1 for radius\n    pointSize += 4;\n    let colorData = null;\n    let colorComponents = 0;\n    vbo.setColorBOStride(4);\n    if (!vbo.getColorBO()) {\n      vbo.setColorBO(vtkBufferObject.newInstance());\n    }\n    vbo.getColorBO().setOpenGLRenderWindow(model._openGLRenderWindow);\n    if (c) {\n      colorComponents = c.getNumberOfComponents();\n      vbo.setColorOffset(4);\n      colorData = c.getData();\n      vbo.setColorBOStride(8);\n    }\n    vbo.setColorComponents(colorComponents);\n    vbo.setStride(pointSize * 4);\n\n    // Create a buffer, and copy the data over.\n    const packedVBO = new Float32Array(pointSize * numPoints * 12);\n    const packedUCVBO = new Uint8Array(12 * numPoints * (colorData ? 8 : 4));\n    let scales = null;\n    let orientationArray = null;\n    //\n    // Generate points and point data for sides\n    //\n    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n      scales = pointData.getArray(model.renderable.getScaleArray()).getData();\n    }\n    if (model.renderable.getOrientationArray() != null && pointData.hasArray(model.renderable.getOrientationArray())) {\n      orientationArray = pointData.getArray(model.renderable.getOrientationArray()).getData();\n    } else {\n      vtkErrorMacro(['Error setting orientationArray.\\n', 'You have to specify the stick orientation']);\n    }\n\n    // Vertices\n    // 013 - 032 - 324 - 453\n    //\n    //       _.4---_.5\n    //    .-*   .-*\n    //   2-----3\n    //   |    /|\n    //   |   / |\n    //   |  /  |\n    //   | /   |\n    //   |/    |\n    //   0-----1\n    //\n    // coord for each points\n    // 0: 000\n    // 1: 100\n    // 2: 001\n    // 3: 101\n    // 4: 011\n    // 5: 111\n\n    // prettier-ignore\n    const verticesArray = [0, 1, 3, 0, 3, 2, 2, 3, 5, 2, 5, 4];\n    let pointIdx = 0;\n    let colorIdx = 0;\n    let vboIdx = 0;\n    let ucIdx = 0;\n    for (let i = 0; i < numPoints; ++i) {\n      let length = model.renderable.getLength();\n      let radius = model.renderable.getRadius();\n      if (scales) {\n        length = scales[i * 2];\n        radius = scales[i * 2 + 1];\n      }\n      for (let j = 0; j < verticesArray.length; ++j) {\n        pointIdx = i * 3;\n        packedVBO[vboIdx++] = pointArray[pointIdx++];\n        packedVBO[vboIdx++] = pointArray[pointIdx++];\n        packedVBO[vboIdx++] = pointArray[pointIdx++];\n        pointIdx = i * 3;\n        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;\n        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;\n        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;\n        packedVBO[vboIdx++] = radius;\n        packedUCVBO[ucIdx++] = 255 * (verticesArray[j] % 2);\n        packedUCVBO[ucIdx++] = verticesArray[j] >= 4 ? 255 : 0;\n        packedUCVBO[ucIdx++] = verticesArray[j] >= 2 ? 255 : 0;\n        packedUCVBO[ucIdx++] = 255;\n        colorIdx = i * colorComponents;\n        if (colorData) {\n          packedUCVBO[ucIdx++] = colorData[colorIdx];\n          packedUCVBO[ucIdx++] = colorData[colorIdx + 1];\n          packedUCVBO[ucIdx++] = colorData[colorIdx + 2];\n          packedUCVBO[ucIdx++] = colorData[colorIdx + 3];\n        }\n      }\n    }\n    vbo.setElementCount(vboIdx / pointSize);\n    vbo.upload(packedVBO, ObjectType.ARRAY_BUFFER);\n    vbo.getColorBO().upload(packedUCVBO, ObjectType.ARRAY_BUFFER);\n    model.VBOBuildTime.modified();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkOpenGLPolyDataMapper.extend(publicAPI, model, initialValues);\n\n  // Object methods\n  vtkOpenGLStickMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLStickMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkStickMapper = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkStickMapper', newInstance);\nexport { vtkStickMapper as default, extend, newInstance };","map":{"version":3,"names":["mat4","mat3","ObjectType","n","newInstance$1","c","macro","vtkBufferObject","v","vtkStickMapperVS","vtkPolyDataFS","vtkShaderProgram","vtkOpenGLPolyDataMapper","registerOverride","vtkErrorMacro","vtkOpenGLStickMapper","publicAPI","model","classHierarchy","push","superClass","getShaderTemplate","shaders","ren","actor","Vertex","Fragment","Geometry","replaceShaderValues","VSSource","FSSource","substitute","result","replacement","fragString","context","getExtension","_openGLRenderWindow","getWebgl2","haveSeenDepthRequest","setMapperShaderParameters","cellBO","getCABO","getElementCount","VBOBuildTime","getAttributeUpdateTime","getMTime","getShaderSourceTime","getProgram","isAttributeUsed","getVAO","addAttributeArray","getStride","FLOAT","getColorBO","getColorBOStride","UNSIGNED_BYTE","setCameraShaderParameters","program","cam","getActiveCamera","keyMats","openGLCamera","getKeyMatrices","isUniformUsed","setUniformMatrix","vcpc","getIsIdentity","actMats","openGLActor","tmp4","Float64Array","multiply","wcvc","mcwc","anorms","normalMatrix","setUniformMatrix3x3","setUniformi","getParallelProjection","getOpenGLMode","rep","type","TRIANGLES","buildBufferObjects","poly","currentInput","renderable","mapScalars","getColorMapColors","vbo","primitives","primTypes","Tris","pointData","getPointData","points","getPoints","numPoints","getNumberOfPoints","pointArray","getData","pointSize","colorData","colorComponents","setColorBOStride","setColorBO","newInstance","setOpenGLRenderWindow","getNumberOfComponents","setColorOffset","setColorComponents","setStride","packedVBO","Float32Array","packedUCVBO","Uint8Array","scales","orientationArray","getScaleArray","hasArray","getArray","getOrientationArray","verticesArray","pointIdx","colorIdx","vboIdx","ucIdx","i","length","getLength","radius","getRadius","j","setElementCount","upload","ARRAY_BUFFER","modified","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","vtkStickMapper","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/OpenGL/StickMapper.js"],"sourcesContent":["import { mat4, mat3 } from 'gl-matrix';\nimport { ObjectType } from './BufferObject/Constants.js';\nimport { n as newInstance$1, c as macro } from '../../macros2.js';\nimport vtkBufferObject from './BufferObject.js';\nimport { v as vtkStickMapperVS } from './glsl/vtkStickMapperVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkOpenGLPolyDataMapper from './PolyDataMapper.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLStickMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLStickMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLStickMapper');\n\n  // Capture 'parentClass' api for internal use\n  const superClass = {\n    ...publicAPI\n  };\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkStickMapperVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 VCPCMatrix;\\n', 'uniform mat4 MCVCMatrix;']).result;\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Dec', 'varying vec4 vertexVCVSOutput;').result;\n\n    // we create vertexVC below, so turn off the default\n    // implementation\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Impl', '  vec4 vertexVC = vertexVCVSOutput;\\n').result;\n\n    // for lights kit and positional the VCPC matrix is already defined\n    // so don't redefine it\n    const replacement = ['uniform int cameraParallel;\\n', 'varying float radiusVCVSOutput;\\n', 'varying vec3 orientVCVSOutput;\\n', 'varying float lengthVCVSOutput;\\n', 'varying vec3 centerVCVSOutput;\\n', 'uniform mat4 VCPCMatrix;\\n'];\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', replacement).result;\n    let fragString = '';\n    if (model.context.getExtension('EXT_frag_depth')) {\n      fragString = '  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n';\n    }\n    if (model._openGLRenderWindow.getWebgl2()) {\n      fragString = 'gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n';\n    }\n    // see https://www.cl.cam.ac.uk/teaching/1999/AGraphHCI/SMAG/node2.html\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', [\n    // compute the eye position and unit direction\n    '  vec3 EyePos;\\n', '  vec3 EyeDir;\\n', '  if (cameraParallel != 0) {\\n', '    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n', '    EyeDir = vec3(0.0,0.0,-1.0); }\\n', '  else {\\n', '    EyeDir = vertexVC.xyz;\\n', '    EyePos = vec3(0.0,0.0,0.0);\\n', '    float lengthED = length(EyeDir);\\n', '    EyeDir = normalize(EyeDir);\\n',\n    // we adjust the EyePos to be closer if it is too far away\n    // to prevent floating point precision noise\n    '    if (lengthED > radiusVCVSOutput*3.0) {\\n', '      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n', '    }\\n',\n    // translate to Stick center\n    '  EyePos = EyePos - centerVCVSOutput;\\n',\n    // rotate to new basis\n    // base1, base2, orientVC\n    '  vec3 base1;\\n', '  if (abs(orientVCVSOutput.z) < 0.99) {\\n', '    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\\n', '  else {\\n', '    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\\n', '  vec3 base2 = cross(orientVCVSOutput,base1);\\n', '  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\\n', '  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\\n',\n    // scale by radius\n    '  EyePos = EyePos/radiusVCVSOutput;\\n',\n    // find the intersection\n    '  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\\n', '  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\\n', '  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\\n', '  float d = b*b - 4.0*a*c;\\n', '  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n', '  if (d < 0.0) { discard; }\\n', '  else {\\n', '    float t =  (-b - sqrt(d))/(2.0*a);\\n', '    float tz = EyePos.z + t*EyeDir.z;\\n', '    vec3 iPoint = EyePos + t*EyeDir;\\n', '    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\\n',\n    // test for end cap\n    '      float t2 = (-b + sqrt(d))/(2.0*a);\\n', '      float tz2 = EyePos.z + t2*EyeDir.z;\\n', '      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\\n', '      else {\\n', '        normalVCVSOutput = orientVCVSOutput;\\n', '        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\\n', '        iPoint = EyePos + t3*EyeDir;\\n', '        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n', '        }\\n', '      }\\n', '    else {\\n',\n    // The normal is the iPoint.xy rotated back into VC\n    '      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\\n',\n    // rescale rerotate and translate\n    '      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n', '      }\\n', '    }\\n',\n    //    '  vec3 normalVC = vec3(0.0,0.0,1.0);\\n'\n    // compute the pixel's depth\n    '  vec4 pos = VCPCMatrix * vertexVC;\\n', fragString]).result;\n\n    // Strip out the normal line -- the normal is computed as part of the depth\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', '').result;\n    if (model.haveSeenDepthRequest) {\n      // special depth impl\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float computedZ = (pos.z / pos.w + 1.0) / 2.0;', 'float iz = floor(computedZ * 65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    superClass.replaceShaderValues(shaders, ren, actor);\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      if (cellBO.getProgram().isAttributeUsed('orientMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'orientMC', 12,\n        // after X Y Z\n        cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {\n          vtkErrorMacro(\"Error setting 'orientMC' in shader VAO.\");\n        }\n      }\n      if (cellBO.getProgram().isAttributeUsed('offsetMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), 'offsetMC', 0, cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 3, true)) {\n          vtkErrorMacro(\"Error setting 'offsetMC' in shader VAO.\");\n        }\n      }\n      if (cellBO.getProgram().isAttributeUsed('radiusMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'radiusMC', 24,\n        // X Y Z OX OY OZ\n        cellBO.getCABO().getStride(), model.context.FLOAT, 1, false)) {\n          vtkErrorMacro(\"Error setting 'radiusMC' in shader VAO.\");\n        }\n      }\n    }\n    superClass.setMapperShaderParameters(cellBO, ren, actor);\n  };\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    const cam = ren.getActiveCamera();\n    const keyMats = model.openGLCamera.getKeyMatrices(ren);\n    if (program.isUniformUsed('VCPCMatrix')) {\n      program.setUniformMatrix('VCPCMatrix', keyMats.vcpc);\n    }\n    if (!actor.getIsIdentity()) {\n      const actMats = model.openGLActor.getKeyMatrices();\n      if (program.isUniformUsed('MCVCMatrix')) {\n        const tmp4 = new Float64Array(16);\n        mat4.multiply(tmp4, keyMats.wcvc, actMats.mcwc);\n        program.setUniformMatrix('MCVCMatrix', tmp4);\n      }\n      if (program.isUniformUsed('normalMatrix')) {\n        const anorms = new Float64Array(9);\n        mat3.multiply(anorms, keyMats.normalMatrix, actMats.normalMatrix);\n        program.setUniformMatrix3x3('normalMatrix', anorms);\n      }\n    } else {\n      if (program.isUniformUsed('MCVCMatrix')) {\n        program.setUniformMatrix('MCVCMatrix', keyMats.wcvc);\n      }\n      if (program.isUniformUsed('normalMatrix')) {\n        program.setUniformMatrix3x3('normalMatrix', keyMats.normalMatrix);\n      }\n    }\n    if (program.isUniformUsed('cameraParallel')) {\n      cellBO.getProgram().setUniformi('cameraParallel', cam.getParallelProjection());\n    }\n  };\n  publicAPI.getOpenGLMode = (rep, type) => model.context.TRIANGLES;\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const poly = model.currentInput;\n    if (poly === null) {\n      return;\n    }\n    model.renderable.mapScalars(poly, 1.0);\n    const c = model.renderable.getColorMapColors();\n    const vbo = model.primitives[model.primTypes.Tris].getCABO();\n    const pointData = poly.getPointData();\n    const points = poly.getPoints();\n    const numPoints = points.getNumberOfPoints();\n    const pointArray = points.getData();\n    let pointSize = 3; // x,y,z\n\n    // three more floats for orientation + 1 for radius\n    pointSize += 4;\n    let colorData = null;\n    let colorComponents = 0;\n    vbo.setColorBOStride(4);\n    if (!vbo.getColorBO()) {\n      vbo.setColorBO(vtkBufferObject.newInstance());\n    }\n    vbo.getColorBO().setOpenGLRenderWindow(model._openGLRenderWindow);\n    if (c) {\n      colorComponents = c.getNumberOfComponents();\n      vbo.setColorOffset(4);\n      colorData = c.getData();\n      vbo.setColorBOStride(8);\n    }\n    vbo.setColorComponents(colorComponents);\n    vbo.setStride(pointSize * 4);\n\n    // Create a buffer, and copy the data over.\n    const packedVBO = new Float32Array(pointSize * numPoints * 12);\n    const packedUCVBO = new Uint8Array(12 * numPoints * (colorData ? 8 : 4));\n    let scales = null;\n    let orientationArray = null;\n    //\n    // Generate points and point data for sides\n    //\n    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n      scales = pointData.getArray(model.renderable.getScaleArray()).getData();\n    }\n    if (model.renderable.getOrientationArray() != null && pointData.hasArray(model.renderable.getOrientationArray())) {\n      orientationArray = pointData.getArray(model.renderable.getOrientationArray()).getData();\n    } else {\n      vtkErrorMacro(['Error setting orientationArray.\\n', 'You have to specify the stick orientation']);\n    }\n\n    // Vertices\n    // 013 - 032 - 324 - 453\n    //\n    //       _.4---_.5\n    //    .-*   .-*\n    //   2-----3\n    //   |    /|\n    //   |   / |\n    //   |  /  |\n    //   | /   |\n    //   |/    |\n    //   0-----1\n    //\n    // coord for each points\n    // 0: 000\n    // 1: 100\n    // 2: 001\n    // 3: 101\n    // 4: 011\n    // 5: 111\n\n    // prettier-ignore\n    const verticesArray = [0, 1, 3, 0, 3, 2, 2, 3, 5, 2, 5, 4];\n    let pointIdx = 0;\n    let colorIdx = 0;\n    let vboIdx = 0;\n    let ucIdx = 0;\n    for (let i = 0; i < numPoints; ++i) {\n      let length = model.renderable.getLength();\n      let radius = model.renderable.getRadius();\n      if (scales) {\n        length = scales[i * 2];\n        radius = scales[i * 2 + 1];\n      }\n      for (let j = 0; j < verticesArray.length; ++j) {\n        pointIdx = i * 3;\n        packedVBO[vboIdx++] = pointArray[pointIdx++];\n        packedVBO[vboIdx++] = pointArray[pointIdx++];\n        packedVBO[vboIdx++] = pointArray[pointIdx++];\n        pointIdx = i * 3;\n        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;\n        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;\n        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;\n        packedVBO[vboIdx++] = radius;\n        packedUCVBO[ucIdx++] = 255 * (verticesArray[j] % 2);\n        packedUCVBO[ucIdx++] = verticesArray[j] >= 4 ? 255 : 0;\n        packedUCVBO[ucIdx++] = verticesArray[j] >= 2 ? 255 : 0;\n        packedUCVBO[ucIdx++] = 255;\n        colorIdx = i * colorComponents;\n        if (colorData) {\n          packedUCVBO[ucIdx++] = colorData[colorIdx];\n          packedUCVBO[ucIdx++] = colorData[colorIdx + 1];\n          packedUCVBO[ucIdx++] = colorData[colorIdx + 2];\n          packedUCVBO[ucIdx++] = colorData[colorIdx + 3];\n        }\n      }\n    }\n    vbo.setElementCount(vboIdx / pointSize);\n    vbo.upload(packedVBO, ObjectType.ARRAY_BUFFER);\n    vbo.getColorBO().upload(packedUCVBO, ObjectType.ARRAY_BUFFER);\n    model.VBOBuildTime.modified();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkOpenGLPolyDataMapper.extend(publicAPI, model, initialValues);\n\n  // Object methods\n  vtkOpenGLStickMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLStickMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkStickMapper = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkStickMapper', newInstance);\n\nexport { vtkStickMapper as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}