{"ast":null,"code":"import { mat4, vec4 } from 'gl-matrix';\nimport Constants from '../Core/ImageMapper/Constants.js';\nimport { n as newInstance$1, o as obj } from '../../macros2.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUFullScreenQuad from './FullScreenQuad.js';\nimport vtkWebGPUUniformBuffer from './UniformBuffer.js';\nimport vtkWebGPUSampler from './Sampler.js';\nimport { InterpolationType } from '../Core/ImageProperty/Constants.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// const { vtkErrorMacro } = macro;\nconst {\n  SlicingMode\n} = Constants;\nconst imgFragTemplate = `\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Image::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  //VTK::Image::Sample\n\n  // var computedColor: vec4<f32> = vec4<f32>(1.0,0.7, 0.5, 1.0);\n\n//VTK::RenderEncoder::Impl\n\n  return output;\n}\n`;\n\n// ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n\nfunction computeFnToString(property, fn, numberOfComponents) {\n  const pwfun = fn.apply(property);\n  if (pwfun) {\n    const iComps = property.getIndependentComponents();\n    return `${property.getMTime()}-${iComps}-${numberOfComponents}`;\n  }\n  return '0';\n}\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUImageMapper methods\n// ----------------------------------------------------------------------------\n\nconst tmpMat4 = new Float64Array(16);\nconst tmp2Mat4 = new Float64Array(16);\nconst tmp3Mat4 = new Float64Array(16);\nconst ptsArray1 = new Float64Array(4);\nconst ptsArray2 = new Float64Array(4);\nfunction vtkWebGPUImageMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUImageMapper');\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.WebGPUImageSlice = publicAPI.getFirstAncestorOfType('vtkWebGPUImageSlice');\n      model.WebGPURenderer = model.WebGPUImageSlice.getFirstAncestorOfType('vtkWebGPURenderer');\n      model.WebGPURenderWindow = model.WebGPURenderer.getParent();\n      model.device = model.WebGPURenderWindow.getDevice();\n      const ren = model.WebGPURenderer.getRenderable();\n      // is slice set by the camera\n      if (model.renderable.getSliceAtFocalPoint()) {\n        model.renderable.setSliceFromCamera(ren.getActiveCamera());\n      }\n    }\n  };\n\n  // Renders myself\n  publicAPI.translucentPass = prepass => {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n  publicAPI.opaquePass = prepass => {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n  publicAPI.render = () => {\n    model.renderable.update();\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());\n    model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n  };\n  publicAPI.computePipelineHash = () => {\n    const ext = model.currentInput.getExtent();\n    if (ext[0] === ext[1] || ext[2] === ext[3] || ext[4] === ext[5]) {\n      model.dimensions = 2;\n      model.pipelineHash = 'img2';\n    } else {\n      model.dimensions = 3;\n      model.pipelineHash = 'img3';\n    }\n  };\n  publicAPI.updateUBO = () => {\n    const utime = model.UBO.getSendTime();\n    const actor = model.WebGPUImageSlice.getRenderable();\n    const volMapr = actor.getMapper();\n    if (publicAPI.getMTime() > utime || model.renderable.getMTime() > utime || actor.getProperty().getMTime() > utime) {\n      // compute the SCTCMatrix\n      const image = volMapr.getInputData();\n      const center = model.WebGPURenderer.getStabilizedCenterByReference();\n      mat4.identity(tmpMat4);\n      mat4.translate(tmpMat4, tmpMat4, center);\n      // tmpMat4 is now SC->World\n\n      const mcwcmat = actor.getMatrix();\n      mat4.transpose(tmp2Mat4, mcwcmat);\n      mat4.invert(tmp2Mat4, tmp2Mat4);\n      // tmp2Mat4 is now world to model\n\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4);\n      // tmp4Mat is now SC->Model\n\n      // the method on the data is world to index but the volume is in\n      // model coordinates so really in this context it is model to index\n      const modelToIndex = image.getWorldToIndex();\n      mat4.multiply(tmpMat4, modelToIndex, tmpMat4);\n      // tmpMat4 is now SC -> Index, save this as we need it later\n      mat4.invert(tmp3Mat4, tmpMat4);\n\n      // need translation and scale\n      mat4.fromTranslation(tmp2Mat4, [0.5, 0.5, 0.5]);\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4);\n      const dims = image.getDimensions();\n      mat4.identity(tmp2Mat4);\n      mat4.scale(tmp2Mat4, tmp2Mat4, [1.0 / dims[0], 1.0 / dims[1], 1.0 / dims[2]]);\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4);\n      // tmpMat4 is now SC -> Tcoord\n\n      model.UBO.setArray('SCTCMatrix', tmpMat4);\n\n      // need to compute the plane here in world coordinates\n      // then pass that down in the UBO\n      const ext = model.currentInput.getExtent();\n\n      // Find what IJK axis and what direction to slice along\n      const {\n        ijkMode\n      } = model.renderable.getClosestIJKAxis();\n\n      // Find the IJK slice\n      let nSlice = model.renderable.getSlice();\n      if (ijkMode !== model.renderable.getSlicingMode()) {\n        // If not IJK slicing, get the IJK slice from the XYZ position/slice\n        nSlice = model.renderable.getSliceAtPosition(nSlice);\n      }\n      let axis0 = 2;\n      let axis1 = 0;\n      let axis2 = 1;\n      if (ijkMode === SlicingMode.I) {\n        axis0 = 0;\n        axis1 = 1;\n        axis2 = 2;\n      } else if (ijkMode === SlicingMode.J) {\n        axis0 = 1;\n        axis1 = 2;\n        axis2 = 0;\n      }\n      ptsArray1[axis0] = nSlice;\n      ptsArray1[axis1] = ext[axis1 * 2] - 0.5;\n      ptsArray1[axis2] = ext[axis2 * 2] - 0.5;\n      ptsArray1[3] = 1.0;\n      vec4.transformMat4(ptsArray1, ptsArray1, tmp3Mat4);\n      model.UBO.setArray('Origin', ptsArray1);\n      ptsArray2[axis0] = nSlice;\n      ptsArray2[axis1] = ext[axis1 * 2 + 1] + 0.5;\n      ptsArray2[axis2] = ext[axis2 * 2] - 0.5;\n      ptsArray2[3] = 1.0;\n      vec4.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);\n      vec4.subtract(ptsArray2, ptsArray2, ptsArray1);\n      ptsArray2[3] = 1.0;\n      model.UBO.setArray('Axis1', ptsArray2);\n      ptsArray2[axis0] = nSlice;\n      ptsArray2[axis1] = ext[axis1 * 2] - 0.5;\n      ptsArray2[axis2] = ext[axis2 * 2 + 1] + 0.5;\n      ptsArray2[3] = 1.0;\n      vec4.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);\n      vec4.subtract(ptsArray2, ptsArray2, ptsArray1);\n      ptsArray2[3] = 1.0;\n      model.UBO.setArray('Axis2', ptsArray2);\n\n      // three levels of shift scale combined into one\n      // for performance in the fragment shader\n      const cScale = [1, 1, 1, 1];\n      const cShift = [0, 0, 0, 0];\n      const tView = model.textureViews[0];\n      const tScale = tView.getTexture().getScale();\n      const numComp = tView.getTexture().getNumberOfComponents();\n      for (let i = 0; i < numComp; i++) {\n        let cw = actor.getProperty().getColorWindow();\n        let cl = actor.getProperty().getColorLevel();\n        const target = 0;\n        const cfun = actor.getProperty().getRGBTransferFunction(target);\n        if (cfun) {\n          const cRange = cfun.getRange();\n          cw = cRange[1] - cRange[0];\n          cl = 0.5 * (cRange[1] + cRange[0]);\n        }\n        cScale[i] = tScale / cw;\n        cShift[i] = -cl / cw + 0.5;\n      }\n      model.UBO.setArray('cScale', cScale);\n      model.UBO.setArray('cShift', cShift);\n      model.UBO.sendIfNeeded(model.device);\n    }\n  };\n  publicAPI.updateLUTImage = () => {\n    const actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();\n    const tView = publicAPI.getTextureViews()[0];\n    tView.getTexture().getNumberOfComponents();\n    const numIComps = 1;\n    const cfunToString = computeFnToString(actorProperty, actorProperty.getRGBTransferFunction, numIComps);\n    if (model.colorTextureString !== cfunToString) {\n      model.numRows = numIComps;\n      const colorArray = new Uint8Array(model.numRows * 2 * model.rowLength * 4);\n      let cfun = actorProperty.getRGBTransferFunction();\n      if (cfun) {\n        const tmpTable = new Float32Array(model.rowLength * 3);\n        for (let c = 0; c < numIComps; c++) {\n          cfun = actorProperty.getRGBTransferFunction(c);\n          const cRange = cfun.getRange();\n          cfun.getTable(cRange[0], cRange[1], model.rowLength, tmpTable, 1);\n          {\n            for (let i = 0; i < model.rowLength; i++) {\n              const idx = c * model.rowLength * 8 + i * 4;\n              colorArray[idx] = 255.0 * tmpTable[i * 3];\n              colorArray[idx + 1] = 255.0 * tmpTable[i * 3 + 1];\n              colorArray[idx + 2] = 255.0 * tmpTable[i * 3 + 2];\n              colorArray[idx + 3] = 255.0;\n              for (let j = 0; j < 4; j++) {\n                colorArray[idx + model.rowLength * 4 + j] = colorArray[idx + j];\n              }\n            }\n          }\n        }\n      } else {\n        for (let i = 0; i < model.rowLength; ++i) {\n          const grey = 255.0 * i / (model.rowLength - 1);\n          colorArray[i * 4] = grey;\n          colorArray[i * 4 + 1] = grey;\n          colorArray[i * 4 + 2] = grey;\n          colorArray[i * 4 + 3] = 255.0;\n          for (let j = 0; j < 4; j++) {\n            colorArray[i * 4 + model.rowLength * 4 + j] = colorArray[i * 4 + j];\n          }\n        }\n      }\n      {\n        const treq = {\n          nativeArray: colorArray,\n          width: model.rowLength,\n          height: model.numRows * 2,\n          depth: 1,\n          format: 'rgba8unorm'\n        };\n        const newTex = model.device.getTextureManager().getTexture(treq);\n        const tview = newTex.createView('tfunTexture');\n        model.textureViews[1] = tview;\n      }\n      model.colorTextureString = cfunToString;\n    }\n  };\n  const superClassUpdateBuffers = publicAPI.updateBuffers;\n  publicAPI.updateBuffers = () => {\n    superClassUpdateBuffers();\n    const newTex = model.device.getTextureManager().getTextureForImageData(model.currentInput);\n    const tViews = model.textureViews;\n    if (!tViews[0] || tViews[0].getTexture() !== newTex) {\n      const tview = newTex.createView('imgTexture');\n      tViews[0] = tview;\n    }\n    publicAPI.updateLUTImage();\n    publicAPI.updateUBO();\n\n    // set interpolation on the texture based on property setting\n    const actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();\n    const iType = actorProperty.getInterpolationType() === InterpolationType.NEAREST ? 'nearest' : 'linear';\n    if (!model.clampSampler || iType !== model.clampSampler.getOptions().minFilter) {\n      model.clampSampler = vtkWebGPUSampler.newInstance({\n        label: 'clampSampler'\n      });\n      model.clampSampler.create(model.device, {\n        minFilter: iType,\n        magFilter: iType\n      });\n      model.additionalBindables = [model.clampSampler];\n    }\n  };\n  const sr = publicAPI.getShaderReplacements();\n  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    let code = vDesc.getCode();\n    const lines = ['var pos: vec4<f32> = mapperUBO.Origin +', '   (vertexBC.x * 0.5 + 0.5) * mapperUBO.Axis1 + (vertexBC.y * 0.5 + 0.5) * mapperUBO.Axis2;', 'pos.w = 1.0;'];\n    if (model.dimensions === 2) {\n      lines.push('var tcoord : vec2<f32> = (mapperUBO.SCTCMatrix * pos).xy;');\n    } else {\n      lines.push('var tcoord : vec3<f32> = (mapperUBO.SCTCMatrix * pos).xyz;');\n    }\n    lines.push('output.tcoordVS = tcoord;', 'output.Position = rendererUBO.SCPCMatrix * pos;');\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', lines).result;\n    vDesc.setCode(code);\n  };\n  sr.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    if (model.dimensions === 2) {\n      vDesc.addOutput('vec2<f32>', 'tcoordVS');\n    } else {\n      vDesc.addOutput('vec3<f32>', 'tcoordVS');\n    }\n  };\n  sr.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);\n  publicAPI.replaceShaderImage = (hash, pipeline, vertexInput) => {\n    const fDesc = pipeline.getShaderDescription('fragment');\n    let code = fDesc.getCode();\n    if (model.dimensions === 3) {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Image::Sample', [`    var computedColor: vec4<f32> =`, `      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);`, `//VTK::Image::Sample`]).result;\n    } else {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Image::Sample', [`    var computedColor: vec4<f32> =`, `      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);`, `//VTK::Image::Sample`]).result;\n    }\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Image::Sample', [`    var coord: vec2<f32> =`, `      vec2<f32>(computedColor.r * mapperUBO.cScale.r + mapperUBO.cShift.r, 0.5);`, `    computedColor = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);`]).result;\n    fDesc.setCode(code);\n  };\n  sr.set('replaceShaderImage', publicAPI.replaceShaderImage);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  rowLength: 1024\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkWebGPUFullScreenQuad.extend(publicAPI, model, initialValues);\n  publicAPI.setFragmentShaderTemplate(imgFragTemplate);\n  model.UBO = vtkWebGPUUniformBuffer.newInstance({\n    label: 'mapperUBO'\n  });\n  model.UBO.addEntry('SCTCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('Origin', 'vec4<f32>');\n  model.UBO.addEntry('Axis2', 'vec4<f32>');\n  model.UBO.addEntry('Axis1', 'vec4<f32>');\n  model.UBO.addEntry('cScale', 'vec4<f32>');\n  model.UBO.addEntry('cShift', 'vec4<f32>');\n  model.lutBuildTime = {};\n  obj(model.lutBuildTime, {\n    mtime: 0\n  });\n  model.imagemat = mat4.identity(new Float64Array(16));\n  model.imagematinv = mat4.identity(new Float64Array(16));\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime);\n\n  // Object methods\n  vtkWebGPUImageMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkWebGPUImageMapper');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\n// Register ourself to WebGPU backend if imported\nregisterOverride('vtkImageMapper', newInstance);\nexport { index as default, extend, newInstance };","map":{"version":3,"names":["mat4","vec4","Constants","n","newInstance$1","o","obj","vtkWebGPUShaderCache","vtkWebGPUFullScreenQuad","vtkWebGPUUniformBuffer","vtkWebGPUSampler","InterpolationType","registerOverride","SlicingMode","imgFragTemplate","computeFnToString","property","fn","numberOfComponents","pwfun","apply","iComps","getIndependentComponents","getMTime","tmpMat4","Float64Array","tmp2Mat4","tmp3Mat4","ptsArray1","ptsArray2","vtkWebGPUImageMapper","publicAPI","model","classHierarchy","push","buildPass","prepass","WebGPUImageSlice","getFirstAncestorOfType","WebGPURenderer","WebGPURenderWindow","getParent","device","getDevice","ren","getRenderable","renderable","getSliceAtFocalPoint","setSliceFromCamera","getActiveCamera","translucentPass","render","opaquePass","update","currentInput","getInputData","prepareToDraw","getRenderEncoder","renderEncoder","registerDrawCallback","pipeline","draw","computePipelineHash","ext","getExtent","dimensions","pipelineHash","updateUBO","utime","UBO","getSendTime","actor","volMapr","getMapper","getProperty","image","center","getStabilizedCenterByReference","identity","translate","mcwcmat","getMatrix","transpose","invert","multiply","modelToIndex","getWorldToIndex","fromTranslation","dims","getDimensions","scale","setArray","ijkMode","getClosestIJKAxis","nSlice","getSlice","getSlicingMode","getSliceAtPosition","axis0","axis1","axis2","I","J","transformMat4","subtract","cScale","cShift","tView","textureViews","tScale","getTexture","getScale","numComp","getNumberOfComponents","i","cw","getColorWindow","cl","getColorLevel","target","cfun","getRGBTransferFunction","cRange","getRange","sendIfNeeded","updateLUTImage","actorProperty","getTextureViews","numIComps","cfunToString","colorTextureString","numRows","colorArray","Uint8Array","rowLength","tmpTable","Float32Array","c","getTable","idx","j","grey","treq","nativeArray","width","height","depth","format","newTex","getTextureManager","tview","createView","superClassUpdateBuffers","updateBuffers","getTextureForImageData","tViews","iType","getInterpolationType","NEAREST","clampSampler","getOptions","minFilter","newInstance","label","create","magFilter","additionalBindables","sr","getShaderReplacements","replaceShaderPosition","hash","vertexInput","vDesc","getShaderDescription","addBuiltinOutput","code","getCode","lines","substitute","result","setCode","set","replaceShaderTCoord","addOutput","replaceShaderImage","fDesc","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","setFragmentShaderTemplate","addEntry","lutBuildTime","mtime","imagemat","imagematinv","VBOBuildTime","index","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/WebGPU/ImageMapper.js"],"sourcesContent":["import { mat4, vec4 } from 'gl-matrix';\nimport Constants from '../Core/ImageMapper/Constants.js';\nimport { n as newInstance$1, o as obj } from '../../macros2.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUFullScreenQuad from './FullScreenQuad.js';\nimport vtkWebGPUUniformBuffer from './UniformBuffer.js';\nimport vtkWebGPUSampler from './Sampler.js';\nimport { InterpolationType } from '../Core/ImageProperty/Constants.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// const { vtkErrorMacro } = macro;\nconst {\n  SlicingMode\n} = Constants;\nconst imgFragTemplate = `\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Image::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  //VTK::Image::Sample\n\n  // var computedColor: vec4<f32> = vec4<f32>(1.0,0.7, 0.5, 1.0);\n\n//VTK::RenderEncoder::Impl\n\n  return output;\n}\n`;\n\n// ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n\nfunction computeFnToString(property, fn, numberOfComponents) {\n  const pwfun = fn.apply(property);\n  if (pwfun) {\n    const iComps = property.getIndependentComponents();\n    return `${property.getMTime()}-${iComps}-${numberOfComponents}`;\n  }\n  return '0';\n}\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUImageMapper methods\n// ----------------------------------------------------------------------------\n\nconst tmpMat4 = new Float64Array(16);\nconst tmp2Mat4 = new Float64Array(16);\nconst tmp3Mat4 = new Float64Array(16);\nconst ptsArray1 = new Float64Array(4);\nconst ptsArray2 = new Float64Array(4);\nfunction vtkWebGPUImageMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUImageMapper');\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.WebGPUImageSlice = publicAPI.getFirstAncestorOfType('vtkWebGPUImageSlice');\n      model.WebGPURenderer = model.WebGPUImageSlice.getFirstAncestorOfType('vtkWebGPURenderer');\n      model.WebGPURenderWindow = model.WebGPURenderer.getParent();\n      model.device = model.WebGPURenderWindow.getDevice();\n      const ren = model.WebGPURenderer.getRenderable();\n      // is slice set by the camera\n      if (model.renderable.getSliceAtFocalPoint()) {\n        model.renderable.setSliceFromCamera(ren.getActiveCamera());\n      }\n    }\n  };\n\n  // Renders myself\n  publicAPI.translucentPass = prepass => {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n  publicAPI.opaquePass = prepass => {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n  publicAPI.render = () => {\n    model.renderable.update();\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());\n    model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n  };\n  publicAPI.computePipelineHash = () => {\n    const ext = model.currentInput.getExtent();\n    if (ext[0] === ext[1] || ext[2] === ext[3] || ext[4] === ext[5]) {\n      model.dimensions = 2;\n      model.pipelineHash = 'img2';\n    } else {\n      model.dimensions = 3;\n      model.pipelineHash = 'img3';\n    }\n  };\n  publicAPI.updateUBO = () => {\n    const utime = model.UBO.getSendTime();\n    const actor = model.WebGPUImageSlice.getRenderable();\n    const volMapr = actor.getMapper();\n    if (publicAPI.getMTime() > utime || model.renderable.getMTime() > utime || actor.getProperty().getMTime() > utime) {\n      // compute the SCTCMatrix\n      const image = volMapr.getInputData();\n      const center = model.WebGPURenderer.getStabilizedCenterByReference();\n      mat4.identity(tmpMat4);\n      mat4.translate(tmpMat4, tmpMat4, center);\n      // tmpMat4 is now SC->World\n\n      const mcwcmat = actor.getMatrix();\n      mat4.transpose(tmp2Mat4, mcwcmat);\n      mat4.invert(tmp2Mat4, tmp2Mat4);\n      // tmp2Mat4 is now world to model\n\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4);\n      // tmp4Mat is now SC->Model\n\n      // the method on the data is world to index but the volume is in\n      // model coordinates so really in this context it is model to index\n      const modelToIndex = image.getWorldToIndex();\n      mat4.multiply(tmpMat4, modelToIndex, tmpMat4);\n      // tmpMat4 is now SC -> Index, save this as we need it later\n      mat4.invert(tmp3Mat4, tmpMat4);\n\n      // need translation and scale\n      mat4.fromTranslation(tmp2Mat4, [0.5, 0.5, 0.5]);\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4);\n      const dims = image.getDimensions();\n      mat4.identity(tmp2Mat4);\n      mat4.scale(tmp2Mat4, tmp2Mat4, [1.0 / dims[0], 1.0 / dims[1], 1.0 / dims[2]]);\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4);\n      // tmpMat4 is now SC -> Tcoord\n\n      model.UBO.setArray('SCTCMatrix', tmpMat4);\n\n      // need to compute the plane here in world coordinates\n      // then pass that down in the UBO\n      const ext = model.currentInput.getExtent();\n\n      // Find what IJK axis and what direction to slice along\n      const {\n        ijkMode\n      } = model.renderable.getClosestIJKAxis();\n\n      // Find the IJK slice\n      let nSlice = model.renderable.getSlice();\n      if (ijkMode !== model.renderable.getSlicingMode()) {\n        // If not IJK slicing, get the IJK slice from the XYZ position/slice\n        nSlice = model.renderable.getSliceAtPosition(nSlice);\n      }\n      let axis0 = 2;\n      let axis1 = 0;\n      let axis2 = 1;\n      if (ijkMode === SlicingMode.I) {\n        axis0 = 0;\n        axis1 = 1;\n        axis2 = 2;\n      } else if (ijkMode === SlicingMode.J) {\n        axis0 = 1;\n        axis1 = 2;\n        axis2 = 0;\n      }\n      ptsArray1[axis0] = nSlice;\n      ptsArray1[axis1] = ext[axis1 * 2] - 0.5;\n      ptsArray1[axis2] = ext[axis2 * 2] - 0.5;\n      ptsArray1[3] = 1.0;\n      vec4.transformMat4(ptsArray1, ptsArray1, tmp3Mat4);\n      model.UBO.setArray('Origin', ptsArray1);\n      ptsArray2[axis0] = nSlice;\n      ptsArray2[axis1] = ext[axis1 * 2 + 1] + 0.5;\n      ptsArray2[axis2] = ext[axis2 * 2] - 0.5;\n      ptsArray2[3] = 1.0;\n      vec4.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);\n      vec4.subtract(ptsArray2, ptsArray2, ptsArray1);\n      ptsArray2[3] = 1.0;\n      model.UBO.setArray('Axis1', ptsArray2);\n      ptsArray2[axis0] = nSlice;\n      ptsArray2[axis1] = ext[axis1 * 2] - 0.5;\n      ptsArray2[axis2] = ext[axis2 * 2 + 1] + 0.5;\n      ptsArray2[3] = 1.0;\n      vec4.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);\n      vec4.subtract(ptsArray2, ptsArray2, ptsArray1);\n      ptsArray2[3] = 1.0;\n      model.UBO.setArray('Axis2', ptsArray2);\n\n      // three levels of shift scale combined into one\n      // for performance in the fragment shader\n      const cScale = [1, 1, 1, 1];\n      const cShift = [0, 0, 0, 0];\n      const tView = model.textureViews[0];\n      const tScale = tView.getTexture().getScale();\n      const numComp = tView.getTexture().getNumberOfComponents();\n      for (let i = 0; i < numComp; i++) {\n        let cw = actor.getProperty().getColorWindow();\n        let cl = actor.getProperty().getColorLevel();\n        const target = 0;\n        const cfun = actor.getProperty().getRGBTransferFunction(target);\n        if (cfun) {\n          const cRange = cfun.getRange();\n          cw = cRange[1] - cRange[0];\n          cl = 0.5 * (cRange[1] + cRange[0]);\n        }\n        cScale[i] = tScale / cw;\n        cShift[i] = -cl / cw + 0.5;\n      }\n      model.UBO.setArray('cScale', cScale);\n      model.UBO.setArray('cShift', cShift);\n      model.UBO.sendIfNeeded(model.device);\n    }\n  };\n  publicAPI.updateLUTImage = () => {\n    const actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();\n    const tView = publicAPI.getTextureViews()[0];\n    tView.getTexture().getNumberOfComponents();\n    const numIComps = 1;\n    const cfunToString = computeFnToString(actorProperty, actorProperty.getRGBTransferFunction, numIComps);\n    if (model.colorTextureString !== cfunToString) {\n      model.numRows = numIComps;\n      const colorArray = new Uint8Array(model.numRows * 2 * model.rowLength * 4);\n      let cfun = actorProperty.getRGBTransferFunction();\n      if (cfun) {\n        const tmpTable = new Float32Array(model.rowLength * 3);\n        for (let c = 0; c < numIComps; c++) {\n          cfun = actorProperty.getRGBTransferFunction(c);\n          const cRange = cfun.getRange();\n          cfun.getTable(cRange[0], cRange[1], model.rowLength, tmpTable, 1);\n          {\n            for (let i = 0; i < model.rowLength; i++) {\n              const idx = c * model.rowLength * 8 + i * 4;\n              colorArray[idx] = 255.0 * tmpTable[i * 3];\n              colorArray[idx + 1] = 255.0 * tmpTable[i * 3 + 1];\n              colorArray[idx + 2] = 255.0 * tmpTable[i * 3 + 2];\n              colorArray[idx + 3] = 255.0;\n              for (let j = 0; j < 4; j++) {\n                colorArray[idx + model.rowLength * 4 + j] = colorArray[idx + j];\n              }\n            }\n          }\n        }\n      } else {\n        for (let i = 0; i < model.rowLength; ++i) {\n          const grey = 255.0 * i / (model.rowLength - 1);\n          colorArray[i * 4] = grey;\n          colorArray[i * 4 + 1] = grey;\n          colorArray[i * 4 + 2] = grey;\n          colorArray[i * 4 + 3] = 255.0;\n          for (let j = 0; j < 4; j++) {\n            colorArray[i * 4 + model.rowLength * 4 + j] = colorArray[i * 4 + j];\n          }\n        }\n      }\n      {\n        const treq = {\n          nativeArray: colorArray,\n          width: model.rowLength,\n          height: model.numRows * 2,\n          depth: 1,\n          format: 'rgba8unorm'\n        };\n        const newTex = model.device.getTextureManager().getTexture(treq);\n        const tview = newTex.createView('tfunTexture');\n        model.textureViews[1] = tview;\n      }\n      model.colorTextureString = cfunToString;\n    }\n  };\n  const superClassUpdateBuffers = publicAPI.updateBuffers;\n  publicAPI.updateBuffers = () => {\n    superClassUpdateBuffers();\n    const newTex = model.device.getTextureManager().getTextureForImageData(model.currentInput);\n    const tViews = model.textureViews;\n    if (!tViews[0] || tViews[0].getTexture() !== newTex) {\n      const tview = newTex.createView('imgTexture');\n      tViews[0] = tview;\n    }\n    publicAPI.updateLUTImage();\n    publicAPI.updateUBO();\n\n    // set interpolation on the texture based on property setting\n    const actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();\n    const iType = actorProperty.getInterpolationType() === InterpolationType.NEAREST ? 'nearest' : 'linear';\n    if (!model.clampSampler || iType !== model.clampSampler.getOptions().minFilter) {\n      model.clampSampler = vtkWebGPUSampler.newInstance({\n        label: 'clampSampler'\n      });\n      model.clampSampler.create(model.device, {\n        minFilter: iType,\n        magFilter: iType\n      });\n      model.additionalBindables = [model.clampSampler];\n    }\n  };\n  const sr = publicAPI.getShaderReplacements();\n  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    let code = vDesc.getCode();\n    const lines = ['var pos: vec4<f32> = mapperUBO.Origin +', '   (vertexBC.x * 0.5 + 0.5) * mapperUBO.Axis1 + (vertexBC.y * 0.5 + 0.5) * mapperUBO.Axis2;', 'pos.w = 1.0;'];\n    if (model.dimensions === 2) {\n      lines.push('var tcoord : vec2<f32> = (mapperUBO.SCTCMatrix * pos).xy;');\n    } else {\n      lines.push('var tcoord : vec3<f32> = (mapperUBO.SCTCMatrix * pos).xyz;');\n    }\n    lines.push('output.tcoordVS = tcoord;', 'output.Position = rendererUBO.SCPCMatrix * pos;');\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', lines).result;\n    vDesc.setCode(code);\n  };\n  sr.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    if (model.dimensions === 2) {\n      vDesc.addOutput('vec2<f32>', 'tcoordVS');\n    } else {\n      vDesc.addOutput('vec3<f32>', 'tcoordVS');\n    }\n  };\n  sr.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);\n  publicAPI.replaceShaderImage = (hash, pipeline, vertexInput) => {\n    const fDesc = pipeline.getShaderDescription('fragment');\n    let code = fDesc.getCode();\n    if (model.dimensions === 3) {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Image::Sample', [`    var computedColor: vec4<f32> =`, `      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);`, `//VTK::Image::Sample`]).result;\n    } else {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Image::Sample', [`    var computedColor: vec4<f32> =`, `      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);`, `//VTK::Image::Sample`]).result;\n    }\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Image::Sample', [`    var coord: vec2<f32> =`, `      vec2<f32>(computedColor.r * mapperUBO.cScale.r + mapperUBO.cShift.r, 0.5);`, `    computedColor = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);`]).result;\n    fDesc.setCode(code);\n  };\n  sr.set('replaceShaderImage', publicAPI.replaceShaderImage);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  rowLength: 1024\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkWebGPUFullScreenQuad.extend(publicAPI, model, initialValues);\n  publicAPI.setFragmentShaderTemplate(imgFragTemplate);\n  model.UBO = vtkWebGPUUniformBuffer.newInstance({\n    label: 'mapperUBO'\n  });\n  model.UBO.addEntry('SCTCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('Origin', 'vec4<f32>');\n  model.UBO.addEntry('Axis2', 'vec4<f32>');\n  model.UBO.addEntry('Axis1', 'vec4<f32>');\n  model.UBO.addEntry('cScale', 'vec4<f32>');\n  model.UBO.addEntry('cShift', 'vec4<f32>');\n  model.lutBuildTime = {};\n  obj(model.lutBuildTime, {\n    mtime: 0\n  });\n  model.imagemat = mat4.identity(new Float64Array(16));\n  model.imagematinv = mat4.identity(new Float64Array(16));\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime);\n\n  // Object methods\n  vtkWebGPUImageMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkWebGPUImageMapper');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\n// Register ourself to WebGPU backend if imported\nregisterOverride('vtkImageMapper', newInstance);\n\nexport { index as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}