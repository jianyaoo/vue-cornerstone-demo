import { getRenderingEngine, utilities } from '@cornerstonejs/core';
import * as SegmentationConfig from './config/segmentationConfig';
import { addSegmentationRepresentation as addSegmentationRepresentationToState, getNextColorLUTIndex, addColorLUT, } from './segmentationState';
import { getRepresentationSpecificConfig } from './helpers/getRepresentationSpecificConfig';
import CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';
import { getToolGroup } from '../../store/ToolGroupManager';
import { triggerAnnotationRenderForViewportIds } from '../../utilities';
import { SegmentationRepresentations } from '../../enums';
async function addSegmentationRepresentation(toolGroupId, representationInput, toolGroupSpecificConfig) {
    const { segmentationId, options = {} } = representationInput;
    const segmentationRepresentationUID = representationInput.options?.segmentationRepresentationUID ||
        utilities.uuidv4();
    const segmentsHidden = new Set();
    const colorLUTIndexToUse = getColorLUTIndex(options);
    const toolGroupSpecificRepresentation = {
        segmentationId,
        segmentationRepresentationUID,
        type: representationInput.type,
        segmentsHidden,
        colorLUTIndex: colorLUTIndexToUse,
        active: true,
        segmentationRepresentationSpecificConfig: {},
        segmentSpecificConfig: {},
        config: getRepresentationSpecificConfig(representationInput),
        polySeg: options.polySeg,
    };
    if (toolGroupSpecificConfig) {
        const currentToolGroupConfig = SegmentationConfig.getToolGroupSpecificConfig(toolGroupId);
        const mergedConfig = utilities.deepMerge(currentToolGroupConfig, toolGroupSpecificConfig);
        SegmentationConfig.setToolGroupSpecificConfig(toolGroupId, {
            renderInactiveSegmentations: mergedConfig.renderInactiveSegmentations || true,
            representations: {
                ...mergedConfig.representations,
            },
        });
    }
    addSegmentationRepresentationToState(toolGroupId, toolGroupSpecificRepresentation);
    if (representationInput.type === SegmentationRepresentations.Contour) {
        getToolGroup(toolGroupId)
            .getViewportsInfo()
            .forEach(({ viewportId, renderingEngineId }) => {
            const renderingEngine = getRenderingEngine(renderingEngineId);
            triggerAnnotationRenderForViewportIds(renderingEngine, [viewportId]);
        });
    }
    return segmentationRepresentationUID;
}
function getColorLUTIndex(options = {}) {
    const colorLUTOrIndexInput = options.colorLUTOrIndex;
    let colorLUTIndexToUse;
    if (typeof colorLUTOrIndexInput === 'number') {
        colorLUTIndexToUse = colorLUTOrIndexInput;
    }
    else {
        const nextIndex = getNextColorLUTIndex();
        const colorLUTToAdd = Array.isArray(colorLUTOrIndexInput)
            ? colorLUTOrIndexInput
            : CORNERSTONE_COLOR_LUT;
        addColorLUT(colorLUTToAdd, nextIndex);
        colorLUTIndexToUse = nextIndex;
    }
    return colorLUTIndexToUse;
}
export { addSegmentationRepresentation };
//# sourceMappingURL=addSegmentationRepresentation.js.map