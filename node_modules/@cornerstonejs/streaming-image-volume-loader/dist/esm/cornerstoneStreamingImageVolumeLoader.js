import { Enums, imageLoader, imageLoadPoolManager, utilities as csUtils, } from '@cornerstonejs/core';
import StreamingImageVolume from './StreamingImageVolume';
function cornerstoneStreamingImageVolumeLoader(volumeId, options) {
    if (!options || !options.imageIds || !options.imageIds.length) {
        throw new Error('ImageIds must be provided to create a streaming image volume');
    }
    async function getStreamingImageVolume() {
        if (options.imageIds[0].split(':')[0] === 'wadouri') {
            const [middleImageIndex, lastImageIndex] = [
                Math.floor(options.imageIds.length / 2),
                options.imageIds.length - 1,
            ];
            const indexesToPrefetch = [0, middleImageIndex, lastImageIndex];
            await Promise.all(indexesToPrefetch.map((index) => {
                return new Promise((resolve, reject) => {
                    const imageId = options.imageIds[index];
                    imageLoadPoolManager.addRequest(async () => {
                        imageLoader
                            .loadImage(imageId)
                            .then(() => {
                            console.log(`Prefetched imageId: ${imageId}`);
                            resolve(true);
                        })
                            .catch((err) => {
                            reject(err);
                        });
                    }, Enums.RequestType.Prefetch, { volumeId }, 1);
                });
            })).catch(console.error);
        }
        const { dimensions, spacing, origin, scalarData, direction, sizeInBytes, metadata, imageIds, } = csUtils.generateVolumePropsFromImageIds(options.imageIds, volumeId);
        const streamingImageVolume = new StreamingImageVolume({
            volumeId,
            metadata,
            dimensions,
            spacing,
            origin,
            direction,
            scalarData,
            sizeInBytes,
            imageIds,
        }, {
            imageIds,
            loadStatus: {
                loaded: false,
                loading: false,
                cancelled: false,
                cachedFrames: [],
                callbacks: [],
            },
        });
        return streamingImageVolume;
    }
    const streamingImageVolumePromise = getStreamingImageVolume();
    return {
        promise: streamingImageVolumePromise,
        decache: () => {
            streamingImageVolumePromise.then((streamingImageVolume) => {
                streamingImageVolume.destroy();
                streamingImageVolume = null;
            });
        },
        cancel: () => {
            streamingImageVolumePromise.then((streamingImageVolume) => {
                streamingImageVolume.cancelLoading();
            });
        },
    };
}
export default cornerstoneStreamingImageVolumeLoader;
//# sourceMappingURL=cornerstoneStreamingImageVolumeLoader.js.map