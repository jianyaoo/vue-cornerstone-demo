{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/* eslint-disable no-bitwise */\n\nconst floatView = new Float32Array(1);\nconst int32View = new Int32Array(floatView.buffer);\n\n/* eslint-disable no-bitwise */\n/* This method is faster than the OpenEXR implementation (very often\n * used, eg. in Ogre), with the additional benefit of rounding, inspired\n * by James Tursa?s half-precision code. */\nfunction toHalf(val) {\n  floatView[0] = val;\n  const x = int32View[0];\n  let bits = x >> 16 & 0x8000; /* Get the sign */\n  let m = x >> 12 & 0x07ff; /* Keep one extra bit for rounding */\n  const e = x >> 23 & 0xff; /* Using int is faster here */\n\n  /* If zero, or denormal, or exponent underflows too much for a denormal\n   * half, return signed zero. */\n  if (e < 103) {\n    return bits;\n  }\n\n  /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n  if (e > 142) {\n    bits |= 0x7c00;\n    /* If exponent was 0xff and one mantissa bit was set, it means NaN,\n     * not Inf, so make sure we set one mantissa bit too. */\n    bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;\n    return bits;\n  }\n\n  /* If exponent underflows but not too much, return a denormal */\n  if (e < 113) {\n    m |= 0x0800;\n    /* Extra rounding may overflow and set mantissa to 0 and exponent\n     * to 1, which is OK. */\n    bits |= (m >> 114 - e) + (m >> 113 - e & 1);\n    return bits;\n  }\n  bits |= e - 112 << 10 | m >> 1;\n  /* Extra rounding. An overflow will set mantissa to 0 and increment\n   * the exponent, which is OK. */\n  bits += m & 1;\n  return bits;\n}\nfunction fromHalf(h) {\n  const s = (h & 0x8000) >> 15;\n  const e = (h & 0x7c00) >> 10;\n  const f = h & 0x03ff;\n  if (e === 0) {\n    return (s ? -1 : 1) * 2 ** -14 * (f / 2 ** 10);\n  }\n  if (e === 0x1f) {\n    return f ? NaN : (s ? -1 : 1) * Infinity;\n  }\n  return (s ? -1 : 1) * 2 ** (e - 15) * (1 + f / 2 ** 10);\n}\nvar HalfFloat = {\n  fromHalf,\n  toHalf\n};\nexport { HalfFloat as default };","map":{"version":3,"names":["floatView","Float32Array","int32View","Int32Array","buffer","toHalf","val","x","bits","m","e","fromHalf","h","s","f","NaN","Infinity","HalfFloat","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Common/Core/HalfFloat.js"],"sourcesContent":["/* eslint-disable no-bitwise */\n\nconst floatView = new Float32Array(1);\nconst int32View = new Int32Array(floatView.buffer);\n\n/* eslint-disable no-bitwise */\n/* This method is faster than the OpenEXR implementation (very often\n * used, eg. in Ogre), with the additional benefit of rounding, inspired\n * by James Tursa?s half-precision code. */\nfunction toHalf(val) {\n  floatView[0] = val;\n  const x = int32View[0];\n  let bits = x >> 16 & 0x8000; /* Get the sign */\n  let m = x >> 12 & 0x07ff; /* Keep one extra bit for rounding */\n  const e = x >> 23 & 0xff; /* Using int is faster here */\n\n  /* If zero, or denormal, or exponent underflows too much for a denormal\n   * half, return signed zero. */\n  if (e < 103) {\n    return bits;\n  }\n\n  /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n  if (e > 142) {\n    bits |= 0x7c00;\n    /* If exponent was 0xff and one mantissa bit was set, it means NaN,\n     * not Inf, so make sure we set one mantissa bit too. */\n    bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;\n    return bits;\n  }\n\n  /* If exponent underflows but not too much, return a denormal */\n  if (e < 113) {\n    m |= 0x0800;\n    /* Extra rounding may overflow and set mantissa to 0 and exponent\n     * to 1, which is OK. */\n    bits |= (m >> 114 - e) + (m >> 113 - e & 1);\n    return bits;\n  }\n  bits |= e - 112 << 10 | m >> 1;\n  /* Extra rounding. An overflow will set mantissa to 0 and increment\n   * the exponent, which is OK. */\n  bits += m & 1;\n  return bits;\n}\nfunction fromHalf(h) {\n  const s = (h & 0x8000) >> 15;\n  const e = (h & 0x7c00) >> 10;\n  const f = h & 0x03ff;\n  if (e === 0) {\n    return (s ? -1 : 1) * 2 ** -14 * (f / 2 ** 10);\n  }\n  if (e === 0x1f) {\n    return f ? NaN : (s ? -1 : 1) * Infinity;\n  }\n  return (s ? -1 : 1) * 2 ** (e - 15) * (1 + f / 2 ** 10);\n}\nvar HalfFloat = {\n  fromHalf,\n  toHalf\n};\n\nexport { HalfFloat as default };\n"],"mappings":";;;AAAA;;AAEA,MAAMA,SAAS,GAAG,IAAIC,YAAY,CAAC,CAAC,CAAC;AACrC,MAAMC,SAAS,GAAG,IAAIC,UAAU,CAACH,SAAS,CAACI,MAAM,CAAC;;AAElD;AACA;AACA;AACA;AACA,SAASC,MAAMA,CAACC,GAAG,EAAE;EACnBN,SAAS,CAAC,CAAC,CAAC,GAAGM,GAAG;EAClB,MAAMC,CAAC,GAAGL,SAAS,CAAC,CAAC,CAAC;EACtB,IAAIM,IAAI,GAAGD,CAAC,IAAI,EAAE,GAAG,MAAM,CAAC,CAAC;EAC7B,IAAIE,CAAC,GAAGF,CAAC,IAAI,EAAE,GAAG,MAAM,CAAC,CAAC;EAC1B,MAAMG,CAAC,GAAGH,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC,CAAC;;EAE1B;AACF;EACE,IAAIG,CAAC,GAAG,GAAG,EAAE;IACX,OAAOF,IAAI;EACb;;EAEA;EACA,IAAIE,CAAC,GAAG,GAAG,EAAE;IACXF,IAAI,IAAI,MAAM;IACd;AACJ;IACIA,IAAI,IAAI,CAACE,CAAC,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC,KAAKH,CAAC,GAAG,UAAU;IAC7C,OAAOC,IAAI;EACb;;EAEA;EACA,IAAIE,CAAC,GAAG,GAAG,EAAE;IACXD,CAAC,IAAI,MAAM;IACX;AACJ;IACID,IAAI,IAAI,CAACC,CAAC,IAAI,GAAG,GAAGC,CAAC,KAAKD,CAAC,IAAI,GAAG,GAAGC,CAAC,GAAG,CAAC,CAAC;IAC3C,OAAOF,IAAI;EACb;EACAA,IAAI,IAAIE,CAAC,GAAG,GAAG,IAAI,EAAE,GAAGD,CAAC,IAAI,CAAC;EAC9B;AACF;EACED,IAAI,IAAIC,CAAC,GAAG,CAAC;EACb,OAAOD,IAAI;AACb;AACA,SAASG,QAAQA,CAACC,CAAC,EAAE;EACnB,MAAMC,CAAC,GAAG,CAACD,CAAC,GAAG,MAAM,KAAK,EAAE;EAC5B,MAAMF,CAAC,GAAG,CAACE,CAAC,GAAG,MAAM,KAAK,EAAE;EAC5B,MAAME,CAAC,GAAGF,CAAC,GAAG,MAAM;EACpB,IAAIF,CAAC,KAAK,CAAC,EAAE;IACX,OAAO,CAACG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,IAAIC,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC;EAChD;EACA,IAAIJ,CAAC,KAAK,IAAI,EAAE;IACd,OAAOI,CAAC,GAAGC,GAAG,GAAG,CAACF,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,IAAIG,QAAQ;EAC1C;EACA,OAAO,CAACH,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,KAAKH,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,GAAGI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC;AACzD;AACA,IAAIG,SAAS,GAAG;EACdN,QAAQ;EACRN;AACF,CAAC;AAED,SAASY,SAAS,IAAIC,OAAO"},"metadata":{},"sourceType":"module","externalDependencies":[]}