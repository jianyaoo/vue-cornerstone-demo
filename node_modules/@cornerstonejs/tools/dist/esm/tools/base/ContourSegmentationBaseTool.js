import { utilities } from '@cornerstonejs/core';
import { config as segmentationConfig, state as segmentationState, segmentLocking, segmentIndex as segmentIndexController, activeSegmentation, } from '../../stateManagement/segmentation';
import { SegmentationRepresentations } from '../../enums';
import ContourBaseTool from './ContourBaseTool';
class ContourSegmentationBaseTool extends ContourBaseTool {
    constructor(toolProps, defaultToolProps) {
        super(toolProps, defaultToolProps);
    }
    isContourSegmentationTool() {
        return true;
    }
    createAnnotation(evt) {
        const { toolGroupId } = this;
        const contourAnnotation = super.createAnnotation(evt);
        if (!this.isContourSegmentationTool()) {
            return contourAnnotation;
        }
        const activeSegmentationRepresentation = activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);
        if (!activeSegmentationRepresentation) {
            throw new Error('No active segmentation detected, create one before using scissors tool');
        }
        const { type: segmentationType } = activeSegmentationRepresentation;
        if (segmentationType !== SegmentationRepresentations.Contour) {
            throw new Error(`A contour segmentation must be active`);
        }
        const { segmentationId, segmentationRepresentationUID } = activeSegmentationRepresentation;
        const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);
        return utilities.deepMerge(contourAnnotation, {
            data: {
                segmentation: {
                    segmentationId,
                    segmentIndex,
                    segmentationRepresentationUID,
                },
            },
        });
    }
    addAnnotation(annotation, element) {
        const annotationUID = super.addAnnotation(annotation, element);
        if (this.isContourSegmentationTool()) {
            this._registerContourSegmentationAnnotation(annotation);
        }
        return annotationUID;
    }
    cancelAnnotation(annotation) {
        if (this.isContourSegmentationTool()) {
            this._unregisterContourSegmentationAnnotation(annotation);
        }
        super.cancelAnnotation(annotation);
    }
    getAnnotationStyle(context) {
        const annotationStyle = super.getAnnotationStyle(context);
        if (!this.isContourSegmentationTool()) {
            return annotationStyle;
        }
        const contourSegmentationStyle = this._getContourSegmentationStyle(context);
        return utilities.deepMerge(annotationStyle, contourSegmentationStyle);
    }
    _getContourSegmentationStyle(context) {
        const { toolGroupId } = this;
        const annotation = context.annotation;
        const { segmentationRepresentationUID, segmentationId, segmentIndex } = annotation.data.segmentation;
        const segmentationRepresentation = segmentationState.getSegmentationRepresentationByUID(toolGroupId, segmentationRepresentationUID);
        const { active } = segmentationRepresentation;
        const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);
        const annotationLocked = segmentsLocked.includes(segmentIndex);
        const segmentColor = segmentationConfig.color.getColorForSegmentIndex(toolGroupId, segmentationRepresentationUID, segmentIndex);
        const segmentationVisible = segmentationConfig.visibility.getSegmentationVisibility(toolGroupId, segmentationRepresentationUID);
        const globalConfig = segmentationConfig.getGlobalConfig();
        const toolGroupConfig = segmentationConfig.getToolGroupSpecificConfig(toolGroupId);
        const segmentationRepresentationConfig = segmentationConfig.getSegmentationRepresentationSpecificConfig(toolGroupId, segmentationRepresentationUID);
        const segmentConfig = segmentationConfig.getSegmentSpecificConfig(toolGroupId, segmentationRepresentationUID, segmentIndex);
        const segmentVisible = segmentationConfig.visibility.getSegmentVisibility(toolGroupId, segmentationRepresentationUID, segmentIndex);
        const mergedConfig = Object.assign({}, globalConfig?.representations?.CONTOUR ?? {}, toolGroupConfig?.representations?.CONTOUR ?? {}, segmentationRepresentationConfig?.CONTOUR ?? {}, segmentConfig?.CONTOUR ?? {});
        let lineWidth = 1;
        let lineDash = undefined;
        let lineOpacity = 1;
        let fillOpacity = 0;
        if (active) {
            lineWidth = mergedConfig.outlineWidthActive ?? lineWidth;
            lineDash = mergedConfig.outlineDashActive ?? lineDash;
            lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;
            fillOpacity = mergedConfig.fillAlpha ?? fillOpacity;
        }
        else {
            lineWidth = mergedConfig.outlineWidthInactive ?? lineWidth;
            lineDash = mergedConfig.outlineDashInactive ?? lineDash;
            lineOpacity = mergedConfig.outlineOpacityInactive ?? lineOpacity;
            fillOpacity = mergedConfig.fillAlphaInactive ?? fillOpacity;
        }
        lineWidth = mergedConfig.renderOutline ? lineWidth : 0;
        fillOpacity = mergedConfig.renderFill ? fillOpacity : 0;
        const color = `rgba(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]}, ${lineOpacity})`;
        const fillColor = `rgb(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]})`;
        return {
            color,
            fillColor,
            lineWidth,
            fillOpacity,
            lineDash,
            textbox: {
                color,
            },
            visibility: segmentationVisible && segmentVisible,
            locked: annotationLocked,
        };
    }
    _registerContourSegmentationAnnotation(annotation) {
        const { segmentationId, segmentIndex } = annotation.data.segmentation;
        const segmentation = segmentationState.getSegmentation(segmentationId);
        const { annotationUIDsMap } = segmentation.representationData.CONTOUR;
        let annotationsUIDsSet = annotationUIDsMap.get(segmentIndex);
        if (!annotationsUIDsSet) {
            annotationsUIDsSet = new Set();
            annotationUIDsMap.set(segmentIndex, annotationsUIDsSet);
        }
        annotationsUIDsSet.add(annotation.annotationUID);
    }
    _unregisterContourSegmentationAnnotation(annotation) {
        const { segmentationId, segmentIndex } = annotation.data.segmentation;
        const segmentation = segmentationState.getSegmentation(segmentationId);
        const { annotationUIDsMap } = segmentation.representationData.CONTOUR;
        const annotationsUIDsSet = annotationUIDsMap.get(segmentIndex);
        annotationsUIDsSet.delete(annotation.annotationUID);
        if (!annotationsUIDsSet.size) {
            annotationUIDsMap.delete(segmentIndex);
        }
    }
}
export { ContourSegmentationBaseTool as default, ContourSegmentationBaseTool };
//# sourceMappingURL=ContourSegmentationBaseTool.js.map