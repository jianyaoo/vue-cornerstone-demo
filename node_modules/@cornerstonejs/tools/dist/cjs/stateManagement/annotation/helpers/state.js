"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.triggerContourAnnotationCompleted = exports.triggerAnnotationCompleted = exports.triggerAnnotationModified = exports.triggerAnnotationRemoved = exports.triggerAnnotationAddedForFOR = exports.triggerAnnotationAddedForElement = void 0;
const core_1 = require("@cornerstonejs/core");
const enums_1 = require("../../../enums");
const ToolGroupManager_1 = require("../../../store/ToolGroupManager");
function triggerAnnotationAddedForElement(annotation, element) {
    const enabledElement = (0, core_1.getEnabledElement)(element);
    const { renderingEngine, viewportId } = enabledElement;
    const eventType = enums_1.Events.ANNOTATION_ADDED;
    const eventDetail = {
        annotation,
        viewportId,
        renderingEngineId: renderingEngine.id,
    };
    (0, core_1.triggerEvent)(core_1.eventTarget, eventType, eventDetail);
}
exports.triggerAnnotationAddedForElement = triggerAnnotationAddedForElement;
function triggerAnnotationAddedForFOR(annotation) {
    const { toolName } = annotation.metadata;
    const toolGroups = (0, ToolGroupManager_1.getToolGroupsWithToolName)(toolName);
    if (!toolGroups.length) {
        return;
    }
    const viewportsToRender = [];
    toolGroups.forEach((toolGroup) => {
        toolGroup.viewportsInfo.forEach((viewportInfo) => {
            const { renderingEngineId, viewportId } = viewportInfo;
            const { FrameOfReferenceUID } = (0, core_1.getEnabledElementByIds)(viewportId, renderingEngineId);
            if (annotation.metadata.FrameOfReferenceUID === FrameOfReferenceUID) {
                viewportsToRender.push(viewportInfo);
            }
        });
    });
    const eventType = enums_1.Events.ANNOTATION_ADDED;
    const eventDetail = { annotation };
    if (!viewportsToRender.length) {
        (0, core_1.triggerEvent)(core_1.eventTarget, eventType, eventDetail);
        return;
    }
    viewportsToRender.forEach(({ renderingEngineId, viewportId }) => {
        eventDetail.viewportId = viewportId;
        eventDetail.renderingEngineId = renderingEngineId;
        (0, core_1.triggerEvent)(core_1.eventTarget, eventType, eventDetail);
    });
}
exports.triggerAnnotationAddedForFOR = triggerAnnotationAddedForFOR;
function triggerAnnotationRemoved(eventDetail) {
    const eventType = enums_1.Events.ANNOTATION_REMOVED;
    (0, core_1.triggerEvent)(core_1.eventTarget, eventType, eventDetail);
}
exports.triggerAnnotationRemoved = triggerAnnotationRemoved;
function triggerAnnotationModified(annotation, element, changeType = enums_1.ChangeTypes.HandlesUpdated) {
    const enabledElement = (0, core_1.getEnabledElement)(element);
    const { viewportId, renderingEngineId } = enabledElement;
    const eventType = enums_1.Events.ANNOTATION_MODIFIED;
    const eventDetail = {
        annotation,
        viewportId,
        renderingEngineId,
        changeType,
    };
    (0, core_1.triggerEvent)(core_1.eventTarget, eventType, eventDetail);
}
exports.triggerAnnotationModified = triggerAnnotationModified;
function triggerAnnotationCompleted(annotation) {
    const eventDetail = {
        annotation,
    };
    _triggerAnnotationCompleted(eventDetail);
}
exports.triggerAnnotationCompleted = triggerAnnotationCompleted;
function triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled = false) {
    const eventDetail = {
        annotation,
        contourHoleProcessingEnabled,
    };
    _triggerAnnotationCompleted(eventDetail);
}
exports.triggerContourAnnotationCompleted = triggerContourAnnotationCompleted;
function _triggerAnnotationCompleted(eventDetail) {
    const eventType = enums_1.Events.ANNOTATION_COMPLETED;
    (0, core_1.triggerEvent)(core_1.eventTarget, eventType, eventDetail);
}
//# sourceMappingURL=state.js.map