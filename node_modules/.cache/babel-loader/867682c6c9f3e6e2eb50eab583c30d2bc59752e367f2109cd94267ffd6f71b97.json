{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { mat3, mat4 } from 'gl-matrix';\nimport { n as newInstance$1, e as setGet } from '../../macros2.js';\nimport vtkMapper from '../Core/Mapper.js';\nimport vtkProp from '../Core/Prop.js';\nimport vtkProperty from '../Core/Property.js';\nimport vtkProperty2D from '../Core/Property2D.js';\nimport vtkTexture from '../Core/Texture.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUUniformBuffer from './UniformBuffer.js';\nimport vtkWebGPUSimpleMapper from './SimpleMapper.js';\nimport vtkWebGPUTypes from './Types.js';\nconst {\n  BufferUsage,\n  PrimitiveTypes\n} = vtkWebGPUBufferManager;\nconst {\n  Representation\n} = vtkProperty;\nconst {\n  ScalarMode\n} = vtkMapper;\nconst {\n  CoordinateSystem\n} = vtkProp;\nconst {\n  DisplayLocation\n} = vtkProperty2D;\nconst vtkWebGPUPolyDataVS = `\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n`;\nconst vtkWebGPUPolyDataFS = `\nstruct PBRData {\n  diffuse: vec3<f32>,\n  specular: vec3<f32>,\n}\n\n// Dot product with the max already in it\nfn mdot(a: vec3<f32>, b: vec3<f32>) -> f32 {\n  return max(0.0, dot(a, b));\n}\n// Dot product with a max in it that does not allow for negative values\n// Physically based rendering is accurate as long as normals are accurate,\n// however this is pretty often not the case. In order to prevent negative\n// values from ruining light calculations and creating zones of zero light,\n// this remapping is used, which smoothly clamps the dot product between\n// zero and one while still maintaining a good amount of accuracy.\nfn cdot(a: vec3<f32>, b: vec3<f32>) -> f32 {\n  var d: f32 = max(0.0, dot(a, b));\n  d = pow((d + 1) / 2.0, 2.6);\n  return d;\n}\n\n// Lambertian diffuse model\nfn lambertDiffuse(base: vec3<f32>, N: vec3<f32>, L: vec3<f32>) -> vec3<f32> {\n  var pi: f32 = 3.14159265359; \n  var NdotL: f32 = mdot(N, L);\n  NdotL = pow(NdotL, 1.5);\n  return (base/pi)*NdotL;\n}\n\n// Yasuhiro Fujii improvement on the Oren-Nayar model\n// https://mimosa-pudica.net/improved-oren-nayar.html\n// p is surface color, o is roughness\nfn fujiiOrenNayar(p: vec3<f32>, o: f32, N: vec3<f32>, L: vec3<f32>, V: vec3<f32>) -> vec3<f32> {\n  var invpi: f32 = 0.31830988618; // 1/pi\n\n  var o2 = o*o;\n  var NdotL: f32 = mdot(N, L);\n  NdotL = pow(NdotL, 1.5); // Less physically accurate, but hides the \"seams\" between lights better\n\n  var NdotV: f32 = mdot(N, V);\n  var LdotV: f32 = mdot(L, V);\n\n  var s: f32 = LdotV - NdotL*NdotV;\n  var t: f32 = mix(1, max(NdotL, NdotV), step(0, s)); // Mix with step is the equivalent of an if statement\n  var A: vec3<f32> = 0.5*(o2 / (o2 + 0.33)) + 0.17*p*(o2 / (o2 + 0.13));\n  A = invpi*(1 - A);\n  var B: f32 = 0.45*(o2 / (o2 + 0.09));\n  B = invpi*B;\n\n  return p*NdotL*(A + B*(s/t));\n}\n\n// Fresnel portion of BRDF (IOR only, simplified)\nfn schlickFresnelIOR(V: vec3<f32>, N: vec3<f32>, ior: f32, k: f32) -> f32 {\n  var NdotV: f32 = mdot(V, N);\n  var F0: f32 = (pow((ior - 1.0), 2) + k*k) / (pow((ior + 1.0), 2) + k*k); // This takes into account the roughness, which the other one does not\n  return F0 + (1 - F0) * pow((1-NdotV), 5); \n}\n\n// Fresnel portion of BRDF (Color ior, better)\nfn schlickFresnelRGB(V: vec3<f32>, N: vec3<f32>, F0: vec3<f32>) -> vec3<f32> {\n  var NdotV: f32 = mdot(V, N);\n  return F0 + (1 - F0) * pow((1-NdotV), 5); \n}\n\n// Normal portion of BRDF\n// https://learnopengl.com/PBR/Theory\n// Trowbridge-Reitz GGX functions: normal, halfway, roughness^2\nfn trGGX(N: vec3<f32>, H: vec3<f32>, a: f32) -> f32 {\n  var pi: f32 = 3.14159265359; \n\n  var a2: f32 = a*a;\n  var NdotH = mdot(N, H);\n  var NdotH2 = NdotH*NdotH;\n  \n  var denom: f32 = NdotH2 * (a2 - 1.0) + 1.0;\n\n  return a2 / max((pi*denom*denom), 0.000001);\n}\n\n// A VERY bad approximation of anisotropy. Real anisotropic calculations require tangent and bitangent\nfn anisotrophicTrGGX(N: vec3<f32>, H: vec3<f32>, O: vec3<f32>, s: f32, a: f32) -> f32 {\n  var Op: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(O) * s, 0.)).xyz;\n\n  var ggx1: f32 = trGGX(N + Op*s, H, a);\n  var ggx2: f32 = trGGX(N - Op*s, H, a);\n  return (0.5 * ggx1 + 0.5 * ggx2);\n}\n\n// Geometry portion of BRDF\nfn schlickGGX(N: vec3<f32>, X: vec3<f32>, k: f32) -> f32 {\n  var NdotX = cdot(N, X);\n  return NdotX / max(0.000001, (NdotX*(1-k) + k));\n}\n\nfn smithSurfaceRoughness(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, k: f32) -> f32 {\n  var ggx1: f32 = min(1, schlickGGX(N, V, k));\n  var ggx2: f32 = min(1, schlickGGX(N, L, k));\n  return ggx1*ggx2;\n}\n\n// BRDF Combination\nfn cookTorrance(D: f32, F: f32, G: f32, N: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> f32 {\n  var num: f32 = D*F*G;\n  var denom: f32 = 4*cdot(V, N)*cdot(L, N);\n\n  return num / max(denom, 0.000001);\n}\n\n// Different lighting calculations for different light sources\nfn calcDirectionalLight(N: vec3<f32>, V: vec3<f32>, ior: f32, roughness: f32, metallic: f32, direction: vec3<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {  \n  var L: vec3<f32> = normalize(direction); // Light Vector\n  var H: vec3<f32> = normalize(L + V); // Halfway Vector\n\n  var alpha = roughness*roughness;\n  var k: f32 = alpha*alpha / 2;\n\n  var D: f32 = trGGX(N, H, alpha); // Distribution\n  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel\n  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry\n\n  var brdf: f32 = cookTorrance(D, 1, G, N, V, L); // Fresnel term is replaced with 1 because it is added later\n  var incoming: vec3<f32> = color;\n  var angle: f32 = mdot(L, N);\n  angle = pow(angle, 1.5);\n\n  var specular: vec3<f32> = brdf*incoming*angle;\n  // Oren-Nayar gives a clay-like effect when fully rough which some people may not want, so it might be better to give a separate\n  // control property for the diffuse vs specular roughness\n  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V); \n  // Stores the specular and diffuse separately to allow for finer post processing\n  var out = PBRData(diffuse, specular);\n  \n  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)\n}\n\n// TODO: find some way to reduce the number of arguments going in here\nfn calcPointLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, ior: f32, roughness: f32, metallic: f32, position: vec3<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {\n  var L: vec3<f32> = normalize(position - fragPos); // Light Vector\n  var H: vec3<f32> = normalize(L + V); // Halfway Vector\n  var dist = distance(position, fragPos);\n\n  var alpha = roughness*roughness;\n  var k: f32 = alpha*alpha / 2; // could also be pow(alpha + 1.0, 2) / 8\n\n  var D: f32 = trGGX(N, H, alpha); // Distribution\n  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel\n  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry\n\n  var brdf: f32 = cookTorrance(D, 1, G, N, V, L);  \n  var incoming: vec3<f32> = color * (1. / (dist*dist));\n  var angle: f32 = mdot(L, N);\n  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly \"seams\" bewteen light sources\n\n  var specular: vec3<f32> = brdf*incoming*angle;\n  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V);\n\n  // Stores the specular and diffuse separately to allow for finer post processing\n  // Could also be done (propably more properly) with a struct\n  var out = PBRData(diffuse, specular);\n  \n  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)\n}\n\n// For a reason unknown to me, spheres dont seem to behave propperly with head-on spot lights\nfn calcSpotLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, ior: f32, roughness: f32, metallic: f32, position: vec3<f32>, direction: vec3<f32>, cones: vec2<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {\n  var L: vec3<f32> = normalize(position - fragPos);\n  var H: vec3<f32> = normalize(L + V); // Halfway Vector\n  var dist = distance(position, fragPos);\n\n  var alpha = roughness*roughness;\n  var k: f32 = alpha*alpha / 2; // could also be pow(alpha + 1.0, 2) / 8\n\n  var D: f32 = trGGX(N, H, alpha); // Distribution\n  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel\n  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry\n\n  var brdf: f32 = cookTorrance(D, 1, G, N, V, L);  \n  \n  // Cones.x is the inner phi and cones.y is the outer phi\n  var theta: f32 = mdot(normalize(direction), L);\n  var epsilon: f32 = cones.x - cones.y;\n  var intensity: f32 = (theta - cones.y) / epsilon;\n  intensity = clamp(intensity, 0.0, 1.0);\n  intensity /= dist*dist;\n\n  var incoming: vec3<f32> = color * intensity;\n\n  var angle: f32 = mdot(L, N);\n  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly \"seams\" bewteen light sources\n\n  var specular: vec3<f32> = brdf*incoming*angle;\n  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V);\n\n  // Stores the specular and diffuse separately to allow for finer post processing\n  // Could also be done (propably more properly) with a struct\n  var out = PBRData(diffuse, specular);\n  \n  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)\n}\n\n// Environment mapping stuff\n// Takes in a vector and converts it to an equivalent coordinate in a rectilinear texture. Should be replaced with cubemaps at some point\nfn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {\n  var tau: f32 = 6.28318530718;\n  var pi: f32 = 3.14159265359;\n  var out: vec2<f32> = vec2<f32>(0.0);\n\n  out.x = atan2(dir.z, dir.x) / tau;\n  out.x += 0.5;\n\n  var phix: f32 = length(vec2(dir.x, dir.z));\n  out.y = atan2(dir.y, phix) / pi + 0.5;\n\n  return out;\n}\n\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::TCoord::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  // Temporary ambient, diffuse, and opacity\n  var ambientColor: vec4<f32> = mapperUBO.AmbientColor;\n  var diffuseColor: vec4<f32> = mapperUBO.DiffuseColor;\n  var opacity: f32 = mapperUBO.Opacity;\n\n  // This should be declared somewhere else\n  var _diffuseMap: vec4<f32> = vec4<f32>(1);\n  var _roughnessMap: vec4<f32> = vec4<f32>(1);\n  var _metallicMap: vec4<f32> = vec4<f32>(1);\n  var _normalMap: vec4<f32> = vec4<f32>(0, 0, 1, 0); // normal map was setting off the normal vector detection in fragment\n  var _ambientOcclusionMap: vec4<f32> = vec4<f32>(1);\n  var _emissionMap: vec4<f32> = vec4<f32>(0);\n\n  //VTK::Color::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Normal::Impl\n\n  var computedColor: vec4<f32> = vec4<f32>(diffuseColor.rgb, 1.0);\n\n  //VTK::Light::Impl\n\n  //VTK::Select::Impl\n\n  if (computedColor.a == 0.0) { discard; };\n\n  //VTK::Position::Impl\n\n  //VTK::RenderEncoder::Impl\n\n  return output;\n}\n`;\nfunction isEdges(hash) {\n  // edge pipelines have \"edge\" in them\n  return hash.indexOf('edge') >= 0;\n}\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUCellArrayMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUCellArrayMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUCellArrayMapper');\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      if (model.is2D) {\n        model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor2D');\n        model.forceZValue = true;\n      } else {\n        model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor');\n        model.forceZValue = false;\n      }\n      model.coordinateSystem = model.WebGPUActor.getRenderable().getCoordinateSystem();\n      model.useRendererMatrix = model.coordinateSystem !== CoordinateSystem.DISPLAY;\n      model.WebGPURenderer = model.WebGPUActor.getFirstAncestorOfType('vtkWebGPURenderer');\n      model.WebGPURenderWindow = model.WebGPURenderer.getParent();\n      model.device = model.WebGPURenderWindow.getDevice();\n    }\n  };\n\n  // Renders myself\n  publicAPI.translucentPass = prepass => {\n    if (prepass) {\n      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());\n      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n    }\n  };\n  publicAPI.opaquePass = prepass => {\n    if (prepass) {\n      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());\n      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n    }\n  };\n  publicAPI.updateUBO = () => {\n    // make sure the data is up to date\n    const actor = model.WebGPUActor.getRenderable();\n    const ppty = actor.getProperty();\n    const utime = model.UBO.getSendTime();\n    if (publicAPI.getMTime() > utime || ppty.getMTime() > utime || model.renderable.getMTime() > utime) {\n      // Matricies\n      const keyMats = model.WebGPUActor.getKeyMatrices(model.WebGPURenderer);\n      model.UBO.setArray('BCWCMatrix', keyMats.bcwc);\n      model.UBO.setArray('BCSCMatrix', keyMats.bcsc);\n      model.UBO.setArray('MCWCNormals', keyMats.normalMatrix);\n      if (model.is2D) {\n        model.UBO.setValue('ZValue', model.WebGPUActor.getRenderable().getProperty().getDisplayLocation() === DisplayLocation.FOREGROUND ? 1.0 : 0.0);\n        const aColor = ppty.getColorByReference();\n        model.UBO.setValue('AmbientIntensity', 1.0);\n        model.UBO.setArray('DiffuseColor', [aColor[0], aColor[1], aColor[2], 1.0]);\n        model.UBO.setValue('DiffuseIntensity', 0.0);\n        model.UBO.setValue('SpecularIntensity', 0.0);\n      } else {\n        // Base Colors\n        let aColor = ppty.getAmbientColorByReference();\n        model.UBO.setValue('AmbientIntensity', ppty.getAmbient());\n        model.UBO.setArray('AmbientColor', [aColor[0], aColor[1], aColor[2], 1.0]);\n        model.UBO.setValue('DiffuseIntensity', ppty.getDiffuse());\n        aColor = ppty.getDiffuseColorByReference();\n        model.UBO.setArray('DiffuseColor', [aColor[0], aColor[1], aColor[2], 1.0]);\n        // Roughness\n        model.UBO.setValue('Roughness', ppty.getRoughness());\n        model.UBO.setValue('BaseIOR', ppty.getBaseIOR());\n        // Metallic\n        model.UBO.setValue('Metallic', ppty.getMetallic());\n        // Normal\n        model.UBO.setValue('NormalStrength', ppty.getNormalStrength());\n        // Emission\n        model.UBO.setValue('Emission', ppty.getEmission());\n        // Specular\n        model.UBO.setValue('SpecularIntensity', ppty.getSpecular());\n        aColor = ppty.getSpecularColorByReference();\n        model.UBO.setArray('SpecularColor', [aColor[0], aColor[1], aColor[2], 1.0]);\n      }\n      // Edge and line rendering\n      const aColor = ppty.getEdgeColorByReference?.();\n      if (aColor) {\n        model.UBO.setArray('EdgeColor', [aColor[0], aColor[1], aColor[2], 1.0]);\n      }\n      model.UBO.setValue('LineWidth', ppty.getLineWidth());\n      model.UBO.setValue('Opacity', ppty.getOpacity());\n      model.UBO.setValue('PropID', model.WebGPUActor.getPropID());\n      const device = model.WebGPURenderWindow.getDevice();\n      model.UBO.sendIfNeeded(device);\n    }\n  };\n  publicAPI.haveWideLines = () => {\n    const actor = model.WebGPUActor.getRenderable();\n    const representation = actor.getProperty().getRepresentation();\n    if (actor.getProperty().getLineWidth() <= 1.0) {\n      return false;\n    }\n    if (model.primitiveType === PrimitiveTypes.Verts) {\n      return false;\n    }\n    if (model.primitiveType === PrimitiveTypes.Triangles || model.primitiveType === PrimitiveTypes.TriangleStrips) {\n      return representation === Representation.WIREFRAME;\n    }\n    return true;\n  };\n  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');\n    let code = vDesc.getCode();\n    if (model.useRendererMatrix) {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    var pCoord: vec4<f32> = rendererUBO.SCPCMatrix*mapperUBO.BCSCMatrix*vertexBC;', '    output.vertexVC = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);', '//VTK::Position::Impl']).result;\n      if (model.forceZValue) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['pCoord = vec4<f32>(pCoord.xyz/pCoord.w, 1.0);', 'pCoord.z = mapperUBO.ZValue;', '//VTK::Position::Impl']).result;\n      }\n    } else {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    var pCoord: vec4<f32> = mapperUBO.BCSCMatrix*vertexBC;', '    pCoord.x = 2.0* pCoord.x / rendererUBO.viewportSize.x - 1.0;', '    pCoord.y = 2.0* pCoord.y / rendererUBO.viewportSize.y - 1.0;', '    pCoord.z = 0.5 - 0.5 * pCoord.z;', '//VTK::Position::Impl']).result;\n      if (model.forceZValue) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    pCoord.z = mapperUBO.ZValue;', '//VTK::Position::Impl']).result;\n      }\n    }\n    if (publicAPI.haveWideLines()) {\n      vDesc.addBuiltinInput('u32', '@builtin(instance_index) instanceIndex');\n      // widen the edge\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    var tmpPos: vec4<f32> = pCoord;', '    var numSteps: f32 = ceil(mapperUBO.LineWidth - 1.0);', '    var offset: f32 = (mapperUBO.LineWidth - 1.0) * (f32(input.instanceIndex / 2u) - numSteps/2.0) / numSteps;', '    var tmpPos2: vec3<f32> = tmpPos.xyz / tmpPos.w;', '    tmpPos2.x = tmpPos2.x + 2.0 * (f32(input.instanceIndex) % 2.0) * offset / rendererUBO.viewportSize.x;', '    tmpPos2.y = tmpPos2.y + 2.0 * (f32(input.instanceIndex + 1u) % 2.0) * offset / rendererUBO.viewportSize.y;', '    tmpPos2.z = min(1.0, tmpPos2.z + 0.00001);',\n      // could become a setting\n      '    pCoord = vec4<f32>(tmpPos2.xyz * tmpPos.w, tmpPos.w);', '//VTK::Position::Impl']).result;\n    }\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    output.Position = pCoord;']).result;\n    vDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  publicAPI.replaceShaderNormal = (hash, pipeline, vertexInput) => {\n    const normalBuffer = vertexInput.getBuffer('normalMC');\n    const actor = model.WebGPUActor.getRenderable();\n    if (normalBuffer) {\n      const vDesc = pipeline.getShaderDescription('vertex');\n      if (!vDesc.hasOutput('normalVC')) {\n        vDesc.addOutput('vec3<f32>', 'normalVC', normalBuffer.getArrayInformation()[0].interpolation);\n      }\n      if (!vDesc.hasOutput('tangentVC')) {\n        vDesc.addOutput('vec3<f32>', 'tangentVC', normalBuffer.getArrayInformation()[0].interpolation);\n      }\n      if (!vDesc.hasOutput('bitangentVC')) {\n        vDesc.addOutput('vec3<f32>', 'bitangentVC', normalBuffer.getArrayInformation()[0].interpolation);\n      }\n      let code = vDesc.getCode();\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', ['  output.normalVC = normalize((rendererUBO.WCVCNormals * mapperUBO.MCWCNormals * normalMC).xyz);',\n      // This is just an approximation, but it happens to work extremely well\n      // It only works well for normals that are head on and not super angled though\n      // Definitely needs to be replaced\n      '  var c1: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 0, 1));', '  var c2: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 1, 0));', '  var tangent: vec3<f32> = mix(c1, c2, distance(c1, c2));', '  output.tangentVC = normalize(tangent);', '  output.bitangentVC = normalize(cross(output.normalVC, tangent));']).result;\n      vDesc.setCode(code);\n      const fDesc = pipeline.getShaderDescription('fragment');\n      code = fDesc.getCode();\n      if (actor.getProperty().getNormalTexture()) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', ['  var normal: vec3<f32> = input.normalVC;', '  if (!input.frontFacing) { normal = -normal; }', '  var tangent: vec3<f32> = input.tangentVC;', '  var bitangent: vec3<f32> = input.bitangentVC;', '  var TCVCMatrix: mat3x3<f32> = mat3x3<f32>(', '    tangent.x, bitangent.x, normal.x,', '    tangent.y, bitangent.y, normal.y,', '    tangent.z, bitangent.z, normal.z,', '  );', '  var mappedNormal: vec3<f32> = TCVCMatrix * (_normalMap.xyz * 2 - 1);', '  normal = mix(normal, mappedNormal, mapperUBO.NormalStrength);', '  normal = normalize(normal);']).result;\n      } else {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', ['  var normal: vec3<f32> = input.normalVC;', '  if (!input.frontFacing) { normal = -normal; }', '  normal = normalize(normal);']).result;\n      }\n      fDesc.setCode(code);\n    }\n  };\n  model.shaderReplacements.set('replaceShaderNormal', publicAPI.replaceShaderNormal);\n\n  // we only apply lighting when there is a \"var normal\" declaration in the\n  // fragment shader code. That is the lighting trigger.\n  publicAPI.replaceShaderLight = (hash, pipeline, vertexInput) => {\n    if (hash.includes('sel')) return;\n    const vDesc = pipeline.getShaderDescription('vertex');\n    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');\n    const renderer = model.WebGPURenderer.getRenderable();\n    const fDesc = pipeline.getShaderDescription('fragment');\n    let code = fDesc.getCode();\n\n    // Code that runs if the fragment shader includes normals\n    if (code.includes('var normal:') && model.useRendererMatrix && !isEdges(hash) && !model.is2D && !hash.includes('sel')) {\n      const lightingCode = [\n      // Constants\n      '  var pi: f32 = 3.14159265359;',\n      // Vectors needed for light calculations\n      '  var fragPos: vec3<f32> = vec3<f32>(input.vertexVC.xyz);', '  var V: vec3<f32> = mix(normalize(-fragPos), vec3<f32>(0, 0, 1), f32(rendererUBO.cameraParallel)); // View Vector',\n      // Values needed for light calculations\n      '  var baseColor: vec3<f32> = _diffuseMap.rgb * diffuseColor.rgb;', '  var roughness: f32 = max(0.000001, mapperUBO.Roughness * _roughnessMap.r);',\n      // Need to have a different way of sampling greyscale values aside from .r\n      '  var metallic: f32 = mapperUBO.Metallic * _metallicMap.r;', '  var alpha: f32 = roughness*roughness;', '  var ior: f32 = mapperUBO.BaseIOR;', '  var k: f32 = alpha*alpha / 2;',\n      // Split diffuse and specular components\n      '  var diffuse: vec3<f32> = vec3<f32>(0.);', '  var specular: vec3<f32> = vec3<f32>(0.);', '  var emission: vec3<f32> = _emissionMap.rgb * mapperUBO.Emission;',\n      // Summing diffuse and specular components of directional lights\n      '  {', '    var i: i32 = 0;', '    loop {', '      if !(i < rendererUBO.LightCount) { break; }', '      switch (i32(rendererLightSSBO.values[i].LightData.x)) {', '         // Point Light', '         case 0 {', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var pos: vec3<f32> = (rendererLightSSBO.values[i].LightPos).xyz;', '           var calculated: PBRData = calcPointLight(normal, V, fragPos, ior, roughness, metallic, pos, color, baseColor);', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '          }', '         // Directional light', '         case 1 {', '           var dir: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz;', '           dir = normalize(dir);', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var calculated: PBRData = calcDirectionalLight(normal, V, ior, roughness, metallic, dir, color, baseColor); // diffuseColor.rgb needs to be fixed with a more dynamic diffuse color', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '         }', '         // Spot Light', '         case 2 {', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var pos: vec3<f32> = (rendererLightSSBO.values[i].LightPos).xyz;', '           var dir: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz;', '           dir = normalize(dir);', '           var cones: vec2<f32> = vec2<f32>(rendererLightSSBO.values[i].LightData.y, rendererLightSSBO.values[i].LightData.z);', '           var calculated: PBRData = calcSpotLight(normal, V, fragPos, ior, roughness, metallic, pos, dir, cones, color, baseColor);', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '         }', '         default { continue; }', '       }', '      continuing { i++; }', '    }', '  }',\n      // Final variables for combining specular and diffuse\n      '  var fresnel: f32 = schlickFresnelIOR(V, normal, ior, k); // Fresnel', '  fresnel = min(1, fresnel);', '  // This could be controlled with its own variable (that isnt base color) for better artistic control', '  var fresnelMetallic: vec3<f32> = schlickFresnelRGB(V, normal, baseColor); // Fresnel for metal, takes color into account', '  var kS: vec3<f32> = mix(vec3<f32>(fresnel), fresnelMetallic, metallic);', '  kS = min(vec3<f32>(1), kS);', '  var kD: vec3<f32> = (1.0 - kS) * (1.0 - metallic);', '  var PBR: vec3<f32> = mapperUBO.DiffuseIntensity*kD*diffuse + kS*specular;', '  PBR += emission;', '  computedColor = vec4<f32>(PBR, mapperUBO.Opacity);'];\n      if (renderer.getEnvironmentTexture()?.getImageLoaded()) {\n        lightingCode.push('  // To get diffuse IBL, the texture is sampled with normals in worldspace', '  var diffuseIBLCoords: vec3<f32> = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(normal, 1.)).xyz;', '  var diffuseCoords: vec2<f32> = vecToRectCoord(diffuseIBLCoords);', '  // To get specular IBL, the texture is sampled as the worldspace reflection between the normal and view vectors', '  // Reflections are first calculated in viewspace, then converted to worldspace to sample the environment', '  var VreflN: vec3<f32> = normalize(reflect(-V, normal));', '  var reflectionIBLCoords = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(VreflN, 1.)).xyz;', '  var specularCoords: vec2<f32> = vecToRectCoord(reflectionIBLCoords);', '  var diffuseIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, diffuseCoords, rendererUBO.MaxEnvironmentMipLevel);',\n        // Level multiplier should be set by UBO\n        '  var level = roughness * rendererUBO.MaxEnvironmentMipLevel;', '  var specularIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, specularCoords, level);',\n        // Manual mip smoothing since not all formats support smooth level sampling\n        '  var specularIBLContribution: vec3<f32> = specularIBL.rgb*rendererUBO.BackgroundSpecularStrength;', '  computedColor += vec4<f32>(specularIBLContribution*kS, 0);', '  var diffuseIBLContribution: vec3<f32> = diffuseIBL.rgb*rendererUBO.BackgroundDiffuseStrength;', '  diffuseIBLContribution *= baseColor * _ambientOcclusionMap.rgb;',\n        // Multipy by baseColor may be changed\n        '  computedColor += vec4<f32>(diffuseIBLContribution*kD, 0);');\n      }\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Light::Impl', lightingCode).result;\n      fDesc.setCode(code);\n      // If theres no normals, just set the specular color to be flat\n    } else {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Light::Impl', ['  var diffuse: vec3<f32> = diffuseColor.rgb;', '  var specular: vec3<f32> = mapperUBO.SpecularColor.rgb * mapperUBO.SpecularColor.a;', '  computedColor = vec4<f32>(diffuse * _diffuseMap.rgb, mapperUBO.Opacity);']).result;\n      fDesc.setCode(code);\n    }\n  };\n  model.shaderReplacements.set('replaceShaderLight', publicAPI.replaceShaderLight);\n  publicAPI.replaceShaderColor = (hash, pipeline, vertexInput) => {\n    // By default, set the colors to be flat\n    if (isEdges(hash)) {\n      const fDesc = pipeline.getShaderDescription('fragment');\n      let code = fDesc.getCode();\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Color::Impl', ['ambientColor = mapperUBO.EdgeColor;', 'diffuseColor = mapperUBO.EdgeColor;']).result;\n      fDesc.setCode(code);\n      return;\n    }\n\n    // If there's no vertex color buffer return the shader as is\n    const colorBuffer = vertexInput.getBuffer('colorVI');\n    if (!colorBuffer) return;\n\n    // Modifies the vertex shader to include the vertex colors and interpolation in the outputs\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addOutput('vec4<f32>', 'color', colorBuffer.getArrayInformation()[0].interpolation);\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Color::Impl', ['  output.color = colorVI;']).result;\n    vDesc.setCode(code);\n\n    // Sets the fragment shader to accept the color inputs from the vertex shader\n    const fDesc = pipeline.getShaderDescription('fragment');\n    code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Color::Impl', ['ambientColor = input.color;', 'diffuseColor = input.color;', 'opacity = mapperUBO.Opacity * input.color.a;']).result;\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderColor', publicAPI.replaceShaderColor);\n  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {\n    if (!vertexInput.hasAttribute('tcoord')) return;\n    const vDesc = pipeline.getShaderDescription('vertex');\n    const tcoords = vertexInput.getBuffer('tcoord');\n    const numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);\n    let code = vDesc.getCode();\n    vDesc.addOutput(`vec${numComp}<f32>`, 'tcoordVS');\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::TCoord::Impl', ['  output.tcoordVS = tcoord;']).result;\n    vDesc.setCode(code);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    code = fDesc.getCode();\n    const actor = model.WebGPUActor.getRenderable();\n    const checkDims = texture => {\n      if (!texture) return false;\n      const dims = texture.getDimensionality();\n      return dims === numComp;\n    };\n    const usedTextures = [];\n    if (actor.getProperty().getDiffuseTexture?.()?.getImageLoaded() || actor.getTextures()[0] || model.colorTexture) {\n      if (\n      // Chained or statements here are questionable\n      checkDims(actor.getProperty().getDiffuseTexture?.()) || checkDims(actor.getTextures()[0]) || checkDims(model.colorTexture)) {\n        usedTextures.push('_diffuseMap = textureSample(DiffuseTexture, DiffuseTextureSampler, input.tcoordVS);');\n      }\n    }\n    if (actor.getProperty().getRoughnessTexture?.()?.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getRoughnessTexture())) {\n        usedTextures.push('_roughnessMap = textureSample(RoughnessTexture, RoughnessTextureSampler, input.tcoordVS);');\n      }\n    }\n    if (actor.getProperty().getMetallicTexture?.()?.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getMetallicTexture())) {\n        usedTextures.push('_metallicMap = textureSample(MetallicTexture, MetallicTextureSampler, input.tcoordVS);');\n      }\n    }\n    if (actor.getProperty().getNormalTexture?.()?.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getNormalTexture())) {\n        usedTextures.push('_normalMap = textureSample(NormalTexture, NormalTextureSampler, input.tcoordVS);');\n      }\n    }\n    if (actor.getProperty().getAmbientOcclusionTexture?.()?.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getAmbientOcclusionTexture())) {\n        usedTextures.push('_ambientOcclusionMap = textureSample(AmbientOcclusionTexture, AmbientOcclusionTextureSampler, input.tcoordVS);');\n      }\n    }\n    if (actor.getProperty().getEmissionTexture?.()?.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getEmissionTexture())) {\n        usedTextures.push('_emissionMap = textureSample(EmissionTexture, EmissionTextureSampler, input.tcoordVS);');\n      }\n    }\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::TCoord::Impl', usedTextures).result;\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);\n  publicAPI.replaceShaderSelect = (hash, pipeline, vertexInput) => {\n    if (hash.includes('sel')) {\n      const fDesc = pipeline.getShaderDescription('fragment');\n      let code = fDesc.getCode();\n      // by default there are no composites, so just 0\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Select::Impl', ['  var compositeID: u32 = 0u;']).result;\n      fDesc.setCode(code);\n    }\n  };\n  model.shaderReplacements.set('replaceShaderSelect', publicAPI.replaceShaderSelect);\n  publicAPI.getUsage = (rep, i) => {\n    if (rep === Representation.POINTS || i === PrimitiveTypes.Points) {\n      return BufferUsage.Verts;\n    }\n    if (i === PrimitiveTypes.Lines) {\n      return BufferUsage.Lines;\n    }\n    if (rep === Representation.WIREFRAME) {\n      if (i === PrimitiveTypes.Triangles) {\n        return BufferUsage.LinesFromTriangles;\n      }\n      return BufferUsage.LinesFromStrips;\n    }\n    if (i === PrimitiveTypes.Triangles) {\n      return BufferUsage.Triangles;\n    }\n    if (i === PrimitiveTypes.TriangleStrips) {\n      return BufferUsage.Strips;\n    }\n    if (i === PrimitiveTypes.TriangleEdges) {\n      return BufferUsage.LinesFromTriangles;\n    }\n\n    // only strip edges left which are lines\n    return BufferUsage.LinesFromStrips;\n  };\n  publicAPI.getHashFromUsage = usage => `pt${usage}`;\n  publicAPI.getTopologyFromUsage = usage => {\n    switch (usage) {\n      case BufferUsage.Triangles:\n        return 'triangle-list';\n      case BufferUsage.Verts:\n        return 'point-list';\n      case BufferUsage.Lines:\n      default:\n        return 'line-list';\n    }\n  };\n\n  // TODO: calculate tangents\n  publicAPI.buildVertexInput = () => {\n    const pd = model.currentInput;\n    const cells = model.cellArray;\n    const primType = model.primitiveType;\n    const actor = model.WebGPUActor.getRenderable();\n    let representation = actor.getProperty().getRepresentation();\n    const device = model.WebGPURenderWindow.getDevice();\n    let edges = false;\n    if (primType === PrimitiveTypes.TriangleEdges) {\n      edges = true;\n      representation = Representation.WIREFRAME;\n    }\n    const vertexInput = model.vertexInput;\n    const points = pd.getPoints();\n    let indexBuffer;\n\n    // get the flat mapping indexBuffer for the cells\n    if (cells) {\n      const buffRequest = {\n        hash: `R${representation}P${primType}${cells.getMTime()}`,\n        usage: BufferUsage.Index,\n        cells,\n        numberOfPoints: points.getNumberOfPoints(),\n        primitiveType: primType,\n        representation\n      };\n      indexBuffer = device.getBufferManager().getBuffer(buffRequest);\n      vertexInput.setIndexBuffer(indexBuffer);\n    } else {\n      vertexInput.setIndexBuffer(null);\n    }\n\n    // hash = all things that can change the values on the buffer\n    // since mtimes are unique we can use\n    // - indexBuffer mtime - because cells drive how we pack\n    // - relevant dataArray mtime - the source data\n    // - shift - not currently captured\n    // - scale - not currently captured\n    // - format\n    // - usage\n    // - packExtra - covered by format\n\n    // points\n    if (points) {\n      const shift = model.WebGPUActor.getBufferShift(model.WebGPURenderer);\n      const buffRequest = {\n        hash: `${points.getMTime()}I${indexBuffer.getMTime()}${shift.join()}float32x4`,\n        usage: BufferUsage.PointArray,\n        format: 'float32x4',\n        dataArray: points,\n        indexBuffer,\n        shift,\n        packExtra: true\n      };\n      const buff = device.getBufferManager().getBuffer(buffRequest);\n      vertexInput.addBuffer(buff, ['vertexBC']);\n    } else {\n      vertexInput.removeBufferIfPresent('vertexBC');\n    }\n\n    // normals, only used for surface rendering\n    const usage = publicAPI.getUsage(representation, primType);\n    model._usesCellNormals = false;\n    if (!model.is2D && (\n    // no lighting on Property2D\n    usage === BufferUsage.Triangles || usage === BufferUsage.Strips)) {\n      const normals = pd.getPointData().getNormals();\n      // https://vtk.org/doc/nightly/html/classvtkPolyDataTangents.html\n      // Need to find some way of using precomputed tangents (or computing new ones)\n      const buffRequest = {\n        format: 'snorm8x4',\n        indexBuffer,\n        packExtra: true,\n        shift: 0,\n        scale: 127\n      };\n      if (normals) {\n        buffRequest.hash = `${normals.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;\n        buffRequest.dataArray = normals;\n        buffRequest.usage = BufferUsage.PointArray;\n        const buff = device.getBufferManager().getBuffer(buffRequest);\n        vertexInput.addBuffer(buff, ['normalMC']);\n      } else if (primType === PrimitiveTypes.Triangles) {\n        model._usesCellNormals = true;\n        buffRequest.hash = `PFN${points.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;\n        buffRequest.dataArray = points;\n        buffRequest.cells = cells;\n        buffRequest.usage = BufferUsage.NormalsFromPoints;\n        const buff = device.getBufferManager().getBuffer(buffRequest);\n        vertexInput.addBuffer(buff, ['normalMC']);\n      } else {\n        vertexInput.removeBufferIfPresent('normalMC');\n      }\n    } else {\n      vertexInput.removeBufferIfPresent('normalMC');\n    }\n\n    // deal with colors but only if modified\n    let haveColors = false;\n    if (model.renderable.getScalarVisibility()) {\n      const c = model.renderable.getColorMapColors();\n      if (c && !edges) {\n        const scalarMode = model.renderable.getScalarMode();\n        let haveCellScalars = false;\n        // We must figure out how the scalars should be mapped to the polydata.\n        if ((scalarMode === ScalarMode.USE_CELL_DATA || scalarMode === ScalarMode.USE_CELL_FIELD_DATA || scalarMode === ScalarMode.USE_FIELD_DATA || !pd.getPointData().getScalars()) && scalarMode !== ScalarMode.USE_POINT_FIELD_DATA && c) {\n          haveCellScalars = true;\n        }\n        const buffRequest = {\n          usage: BufferUsage.PointArray,\n          format: 'unorm8x4',\n          hash: `${haveCellScalars}${c.getMTime()}I${indexBuffer.getMTime()}unorm8x4`,\n          dataArray: c,\n          indexBuffer,\n          cellData: haveCellScalars,\n          cellOffset: 0\n        };\n        const buff = device.getBufferManager().getBuffer(buffRequest);\n        vertexInput.addBuffer(buff, ['colorVI']);\n        haveColors = true;\n      }\n    }\n    if (!haveColors) {\n      vertexInput.removeBufferIfPresent('colorVI');\n    }\n    let tcoords = null;\n    if (model.renderable.getInterpolateScalarsBeforeMapping?.() && model.renderable.getColorCoordinates()) {\n      tcoords = model.renderable.getColorCoordinates();\n    } else {\n      tcoords = pd.getPointData().getTCoords();\n    }\n    if (tcoords && !edges) {\n      const buff = device.getBufferManager().getBufferForPointArray(tcoords, vertexInput.getIndexBuffer());\n      vertexInput.addBuffer(buff, ['tcoord']);\n    } else {\n      vertexInput.removeBufferIfPresent('tcoord');\n    }\n  };\n  publicAPI.updateTextures = () => {\n    // we keep track of new and used textures so\n    // that we can clean up any unused textures so we don't hold onto them\n    const usedTextures = [];\n    const newTextures = [];\n\n    // do we have a scalar color texture\n    const idata = model.renderable.getColorTextureMap?.();\n    if (idata) {\n      if (!model.colorTexture) {\n        model.colorTexture = vtkTexture.newInstance({\n          label: 'polyDataColor'\n        });\n      }\n      model.colorTexture.setInputData(idata);\n      newTextures.push(['Diffuse', model.colorTexture]);\n    }\n\n    // actor textures?\n    const actor = model.WebGPUActor.getRenderable();\n    const renderer = model.WebGPURenderer.getRenderable();\n\n    // Reusing the old code for new and old textures, just loading in from properties instead of actor.getTextures()\n    const textures = [];\n\n    // Feels like there should be a better way than individually adding all\n    if (actor.getProperty().getDiffuseTexture?.()) {\n      const pair = ['Diffuse', actor.getProperty().getDiffuseTexture()];\n      textures.push(pair);\n    }\n    if (actor.getTextures()[0]) {\n      const pair = ['Diffuse', actor.getTextures()[0]];\n      textures.push(pair);\n    }\n    if (model.colorTexture) {\n      const pair = ['Diffuse', model.colorTexture];\n      textures.push(pair);\n    }\n    if (actor.getProperty().getRoughnessTexture?.()) {\n      const pair = ['Roughness', actor.getProperty().getRoughnessTexture()];\n      textures.push(pair);\n    }\n    if (actor.getProperty().getMetallicTexture?.()) {\n      const pair = ['Metallic', actor.getProperty().getMetallicTexture()];\n      textures.push(pair);\n    }\n    if (actor.getProperty().getNormalTexture?.()) {\n      const pair = ['Normal', actor.getProperty().getNormalTexture()];\n      textures.push(pair);\n    }\n    if (actor.getProperty().getAmbientOcclusionTexture?.()) {\n      const pair = ['AmbientOcclusion', actor.getProperty().getAmbientOcclusionTexture()];\n      textures.push(pair);\n    }\n    if (actor.getProperty().getEmissionTexture?.()) {\n      const pair = ['Emission', actor.getProperty().getEmissionTexture()];\n      textures.push(pair);\n    }\n    if (renderer.getEnvironmentTexture?.()) {\n      const pair = ['Environment', renderer.getEnvironmentTexture()];\n      textures.push(pair);\n    }\n    for (let i = 0; i < textures.length; i++) {\n      if (textures[i][1].getInputData() || textures[i][1].getJsImageData() || textures[i][1].getCanvas()) {\n        newTextures.push(textures[i]);\n      }\n      if (textures[i][1].getImage() && textures[i][1].getImageLoaded()) {\n        newTextures.push(textures[i]);\n      }\n    }\n    for (let i = 0; i < newTextures.length; i++) {\n      const srcTexture = newTextures[i][1];\n      const textureName = newTextures[i][0];\n      const newTex = model.device.getTextureManager().getTextureForVTKTexture(srcTexture); // Generates hash\n      if (newTex.getReady()) {\n        // is this a new texture\n        let found = false;\n        for (let t = 0; t < model.textures.length; t++) {\n          if (model.textures[t] === newTex) {\n            found = true;\n            usedTextures[t] = true;\n          }\n        }\n        if (!found) {\n          usedTextures[model.textures.length] = true;\n          const tview = newTex.createView(`${textureName}Texture`);\n          model.textures.push(newTex);\n          model.textureViews.push(tview);\n          const interpolate = srcTexture.getInterpolate() ? 'linear' : 'nearest';\n          let addressMode = null;\n          if (!addressMode && srcTexture.getEdgeClamp() && srcTexture.getRepeat()) addressMode = 'mirror-repeat';\n          if (!addressMode && srcTexture.getEdgeClamp()) addressMode = 'clamp-to-edge';\n          if (!addressMode && srcTexture.getRepeat()) addressMode = 'repeat';\n          if (textureName !== 'Environment') {\n            tview.addSampler(model.device, {\n              addressModeU: addressMode,\n              addressModeV: addressMode,\n              addressModeW: addressMode,\n              minFilter: interpolate,\n              magFilter: interpolate\n            });\n          } else {\n            tview.addSampler(model.device, {\n              addressModeU: 'repeat',\n              addressModeV: 'clamp-to-edge',\n              addressModeW: 'repeat',\n              minFilter: interpolate,\n              magFilter: interpolate,\n              mipmapFilter: 'linear'\n            });\n          }\n        }\n      }\n    }\n\n    // remove unused textures\n    for (let i = model.textures.length - 1; i >= 0; i--) {\n      if (!usedTextures[i]) {\n        model.textures.splice(i, 1);\n        model.textureViews.splice(i, 1);\n      }\n    }\n  };\n\n  // compute a unique hash for a pipeline, this needs to be unique enough to\n  // capture any pipeline code changes (which includes shader changes)\n  // or vertex input changes/ bind groups/ etc\n  publicAPI.computePipelineHash = () => {\n    let pipelineHash = `pd${model.useRendererMatrix ? 'r' : ''}${model.forceZValue ? 'z' : ''}`;\n    if (model.primitiveType === PrimitiveTypes.TriangleEdges || model.primitiveType === PrimitiveTypes.TriangleStripEdges) {\n      pipelineHash += 'edge';\n    } else {\n      if (model.vertexInput.hasAttribute(`normalMC`)) {\n        pipelineHash += `n`;\n      }\n      if (model.vertexInput.hasAttribute(`colorVI`)) {\n        pipelineHash += `c`;\n      }\n      if (model.vertexInput.hasAttribute(`tcoord`)) {\n        const tcoords = model.vertexInput.getBuffer('tcoord');\n        const numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);\n        pipelineHash += `t${numComp}`;\n      }\n      if (model.textures.length) {\n        pipelineHash += `tx${model.textures.length}`;\n      }\n    }\n    if (model._usesCellNormals) {\n      pipelineHash += `cn`;\n    }\n    if (model.SSBO) {\n      pipelineHash += `ssbo`;\n    }\n    const uhash = publicAPI.getHashFromUsage(model.usage);\n    pipelineHash += uhash;\n    pipelineHash += model.renderEncoder.getPipelineHash();\n    model.pipelineHash = pipelineHash;\n  };\n  publicAPI.updateBuffers = () => {\n    // handle textures if not edges\n    if (model.primitiveType !== PrimitiveTypes.TriangleEdges && model.primitiveType !== PrimitiveTypes.TriangleStripEdges) {\n      publicAPI.updateTextures();\n    }\n    const actor = model.WebGPUActor.getRenderable();\n    const rep = actor.getProperty().getRepresentation();\n\n    // handle per primitive type\n    model.usage = publicAPI.getUsage(rep, model.primitiveType);\n    publicAPI.buildVertexInput();\n    const vbo = model.vertexInput.getBuffer('vertexBC');\n    publicAPI.setNumberOfVertices(vbo.getSizeInBytes() / vbo.getStrideInBytes());\n    publicAPI.setTopology(publicAPI.getTopologyFromUsage(model.usage));\n    publicAPI.updateUBO();\n    if (publicAPI.haveWideLines()) {\n      const ppty = actor.getProperty();\n      publicAPI.setNumberOfInstances(Math.ceil(ppty.getLineWidth() * 2.0));\n    } else {\n      publicAPI.setNumberOfInstances(1);\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  is2D: false,\n  cellArray: null,\n  currentInput: null,\n  cellOffset: 0,\n  primitiveType: 0,\n  colorTexture: null,\n  renderEncoder: null,\n  textures: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initiaLalues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initiaLalues);\n\n  // Inheritance\n  vtkWebGPUSimpleMapper.extend(publicAPI, model, initiaLalues);\n  model.fragmentShaderTemplate = vtkWebGPUPolyDataFS;\n  model.vertexShaderTemplate = vtkWebGPUPolyDataVS;\n  model._tmpMat3 = mat3.identity(new Float64Array(9));\n  model._tmpMat4 = mat4.identity(new Float64Array(16));\n\n  // UBO\n  model.UBO = vtkWebGPUUniformBuffer.newInstance({\n    label: 'mapperUBO'\n  });\n  model.UBO.addEntry('BCWCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('BCSCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('MCWCNormals', 'mat4x4<f32>');\n  model.UBO.addEntry('AmbientColor', 'vec4<f32>');\n  model.UBO.addEntry('DiffuseColor', 'vec4<f32>');\n  model.UBO.addEntry('EdgeColor', 'vec4<f32>');\n  model.UBO.addEntry('SpecularColor', 'vec4<f32>');\n  model.UBO.addEntry('AmbientIntensity', 'f32');\n  model.UBO.addEntry('DiffuseIntensity', 'f32');\n  model.UBO.addEntry('Roughness', 'f32');\n  model.UBO.addEntry('Metallic', 'f32');\n  model.UBO.addEntry('Ambient', 'f32');\n  model.UBO.addEntry('Normal', 'f32');\n  model.UBO.addEntry('Emission', 'f32');\n  model.UBO.addEntry('NormalStrength', 'f32');\n  model.UBO.addEntry('BaseIOR', 'f32');\n  model.UBO.addEntry('SpecularIntensity', 'f32');\n  model.UBO.addEntry('LineWidth', 'f32');\n  model.UBO.addEntry('Opacity', 'f32');\n  model.UBO.addEntry('ZValue', 'f32');\n  model.UBO.addEntry('PropID', 'u32');\n  model.UBO.addEntry('ClipNear', 'f32');\n  model.UBO.addEntry('ClipFar', 'f32');\n  model.UBO.addEntry('Time', 'u32');\n\n  // Build VTK API\n  setGet(publicAPI, model, ['cellArray', 'currentInput', 'cellOffset', 'is2D', 'primitiveType', 'renderEncoder']);\n  model.textures = [];\n\n  // Object methods\n  vtkWebGPUCellArrayMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkWebGPUCellArrayMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUCellArrayMapper$1 = {\n  newInstance,\n  extend\n};\nexport { vtkWebGPUCellArrayMapper$1 as default, extend, newInstance };","map":{"version":3,"names":["mat3","mat4","n","newInstance$1","e","setGet","vtkMapper","vtkProp","vtkProperty","vtkProperty2D","vtkTexture","vtkWebGPUBufferManager","vtkWebGPUShaderCache","vtkWebGPUUniformBuffer","vtkWebGPUSimpleMapper","vtkWebGPUTypes","BufferUsage","PrimitiveTypes","Representation","ScalarMode","CoordinateSystem","DisplayLocation","vtkWebGPUPolyDataVS","vtkWebGPUPolyDataFS","isEdges","hash","indexOf","vtkWebGPUCellArrayMapper","publicAPI","model","classHierarchy","push","buildPass","prepass","is2D","WebGPUActor","getFirstAncestorOfType","forceZValue","coordinateSystem","getRenderable","getCoordinateSystem","useRendererMatrix","DISPLAY","WebGPURenderer","WebGPURenderWindow","getParent","device","getDevice","translucentPass","prepareToDraw","getRenderEncoder","renderEncoder","registerDrawCallback","pipeline","draw","opaquePass","updateUBO","actor","ppty","getProperty","utime","UBO","getSendTime","getMTime","renderable","keyMats","getKeyMatrices","setArray","bcwc","bcsc","normalMatrix","setValue","getDisplayLocation","FOREGROUND","aColor","getColorByReference","getAmbientColorByReference","getAmbient","getDiffuse","getDiffuseColorByReference","getRoughness","getBaseIOR","getMetallic","getNormalStrength","getEmission","getSpecular","getSpecularColorByReference","getEdgeColorByReference","getLineWidth","getOpacity","getPropID","sendIfNeeded","haveWideLines","representation","getRepresentation","primitiveType","Verts","Triangles","TriangleStrips","WIREFRAME","replaceShaderPosition","vertexInput","vDesc","getShaderDescription","addBuiltinOutput","hasOutput","addOutput","code","getCode","substitute","result","addBuiltinInput","setCode","shaderReplacements","set","replaceShaderNormal","normalBuffer","getBuffer","getArrayInformation","interpolation","fDesc","getNormalTexture","replaceShaderLight","includes","renderer","lightingCode","getEnvironmentTexture","getImageLoaded","replaceShaderColor","colorBuffer","replaceShaderTCoord","hasAttribute","tcoords","numComp","getNumberOfComponentsFromBufferFormat","format","checkDims","texture","dims","getDimensionality","usedTextures","getDiffuseTexture","getTextures","colorTexture","getRoughnessTexture","getMetallicTexture","getAmbientOcclusionTexture","getEmissionTexture","replaceShaderSelect","getUsage","rep","i","POINTS","Points","Lines","LinesFromTriangles","LinesFromStrips","Strips","TriangleEdges","getHashFromUsage","usage","getTopologyFromUsage","buildVertexInput","pd","currentInput","cells","cellArray","primType","edges","points","getPoints","indexBuffer","buffRequest","Index","numberOfPoints","getNumberOfPoints","getBufferManager","setIndexBuffer","shift","getBufferShift","join","PointArray","dataArray","packExtra","buff","addBuffer","removeBufferIfPresent","_usesCellNormals","normals","getPointData","getNormals","scale","NormalsFromPoints","haveColors","getScalarVisibility","c","getColorMapColors","scalarMode","getScalarMode","haveCellScalars","USE_CELL_DATA","USE_CELL_FIELD_DATA","USE_FIELD_DATA","getScalars","USE_POINT_FIELD_DATA","cellData","cellOffset","getInterpolateScalarsBeforeMapping","getColorCoordinates","getTCoords","getBufferForPointArray","getIndexBuffer","updateTextures","newTextures","idata","getColorTextureMap","newInstance","label","setInputData","textures","pair","length","getInputData","getJsImageData","getCanvas","getImage","srcTexture","textureName","newTex","getTextureManager","getTextureForVTKTexture","getReady","found","t","tview","createView","textureViews","interpolate","getInterpolate","addressMode","getEdgeClamp","getRepeat","addSampler","addressModeU","addressModeV","addressModeW","minFilter","magFilter","mipmapFilter","splice","computePipelineHash","pipelineHash","TriangleStripEdges","SSBO","uhash","getPipelineHash","updateBuffers","vbo","setNumberOfVertices","getSizeInBytes","getStrideInBytes","setTopology","setNumberOfInstances","Math","ceil","DEFAULT_VALUES","extend","initiaLalues","arguments","undefined","Object","assign","fragmentShaderTemplate","vertexShaderTemplate","_tmpMat3","identity","Float64Array","_tmpMat4","addEntry","vtkWebGPUCellArrayMapper$1","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/WebGPU/CellArrayMapper.js"],"sourcesContent":["import { mat3, mat4 } from 'gl-matrix';\nimport { n as newInstance$1, e as setGet } from '../../macros2.js';\nimport vtkMapper from '../Core/Mapper.js';\nimport vtkProp from '../Core/Prop.js';\nimport vtkProperty from '../Core/Property.js';\nimport vtkProperty2D from '../Core/Property2D.js';\nimport vtkTexture from '../Core/Texture.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUUniformBuffer from './UniformBuffer.js';\nimport vtkWebGPUSimpleMapper from './SimpleMapper.js';\nimport vtkWebGPUTypes from './Types.js';\n\nconst {\n  BufferUsage,\n  PrimitiveTypes\n} = vtkWebGPUBufferManager;\nconst {\n  Representation\n} = vtkProperty;\nconst {\n  ScalarMode\n} = vtkMapper;\nconst {\n  CoordinateSystem\n} = vtkProp;\nconst {\n  DisplayLocation\n} = vtkProperty2D;\nconst vtkWebGPUPolyDataVS = `\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n`;\nconst vtkWebGPUPolyDataFS = `\nstruct PBRData {\n  diffuse: vec3<f32>,\n  specular: vec3<f32>,\n}\n\n// Dot product with the max already in it\nfn mdot(a: vec3<f32>, b: vec3<f32>) -> f32 {\n  return max(0.0, dot(a, b));\n}\n// Dot product with a max in it that does not allow for negative values\n// Physically based rendering is accurate as long as normals are accurate,\n// however this is pretty often not the case. In order to prevent negative\n// values from ruining light calculations and creating zones of zero light,\n// this remapping is used, which smoothly clamps the dot product between\n// zero and one while still maintaining a good amount of accuracy.\nfn cdot(a: vec3<f32>, b: vec3<f32>) -> f32 {\n  var d: f32 = max(0.0, dot(a, b));\n  d = pow((d + 1) / 2.0, 2.6);\n  return d;\n}\n\n// Lambertian diffuse model\nfn lambertDiffuse(base: vec3<f32>, N: vec3<f32>, L: vec3<f32>) -> vec3<f32> {\n  var pi: f32 = 3.14159265359; \n  var NdotL: f32 = mdot(N, L);\n  NdotL = pow(NdotL, 1.5);\n  return (base/pi)*NdotL;\n}\n\n// Yasuhiro Fujii improvement on the Oren-Nayar model\n// https://mimosa-pudica.net/improved-oren-nayar.html\n// p is surface color, o is roughness\nfn fujiiOrenNayar(p: vec3<f32>, o: f32, N: vec3<f32>, L: vec3<f32>, V: vec3<f32>) -> vec3<f32> {\n  var invpi: f32 = 0.31830988618; // 1/pi\n\n  var o2 = o*o;\n  var NdotL: f32 = mdot(N, L);\n  NdotL = pow(NdotL, 1.5); // Less physically accurate, but hides the \"seams\" between lights better\n\n  var NdotV: f32 = mdot(N, V);\n  var LdotV: f32 = mdot(L, V);\n\n  var s: f32 = LdotV - NdotL*NdotV;\n  var t: f32 = mix(1, max(NdotL, NdotV), step(0, s)); // Mix with step is the equivalent of an if statement\n  var A: vec3<f32> = 0.5*(o2 / (o2 + 0.33)) + 0.17*p*(o2 / (o2 + 0.13));\n  A = invpi*(1 - A);\n  var B: f32 = 0.45*(o2 / (o2 + 0.09));\n  B = invpi*B;\n\n  return p*NdotL*(A + B*(s/t));\n}\n\n// Fresnel portion of BRDF (IOR only, simplified)\nfn schlickFresnelIOR(V: vec3<f32>, N: vec3<f32>, ior: f32, k: f32) -> f32 {\n  var NdotV: f32 = mdot(V, N);\n  var F0: f32 = (pow((ior - 1.0), 2) + k*k) / (pow((ior + 1.0), 2) + k*k); // This takes into account the roughness, which the other one does not\n  return F0 + (1 - F0) * pow((1-NdotV), 5); \n}\n\n// Fresnel portion of BRDF (Color ior, better)\nfn schlickFresnelRGB(V: vec3<f32>, N: vec3<f32>, F0: vec3<f32>) -> vec3<f32> {\n  var NdotV: f32 = mdot(V, N);\n  return F0 + (1 - F0) * pow((1-NdotV), 5); \n}\n\n// Normal portion of BRDF\n// https://learnopengl.com/PBR/Theory\n// Trowbridge-Reitz GGX functions: normal, halfway, roughness^2\nfn trGGX(N: vec3<f32>, H: vec3<f32>, a: f32) -> f32 {\n  var pi: f32 = 3.14159265359; \n\n  var a2: f32 = a*a;\n  var NdotH = mdot(N, H);\n  var NdotH2 = NdotH*NdotH;\n  \n  var denom: f32 = NdotH2 * (a2 - 1.0) + 1.0;\n\n  return a2 / max((pi*denom*denom), 0.000001);\n}\n\n// A VERY bad approximation of anisotropy. Real anisotropic calculations require tangent and bitangent\nfn anisotrophicTrGGX(N: vec3<f32>, H: vec3<f32>, O: vec3<f32>, s: f32, a: f32) -> f32 {\n  var Op: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(O) * s, 0.)).xyz;\n\n  var ggx1: f32 = trGGX(N + Op*s, H, a);\n  var ggx2: f32 = trGGX(N - Op*s, H, a);\n  return (0.5 * ggx1 + 0.5 * ggx2);\n}\n\n// Geometry portion of BRDF\nfn schlickGGX(N: vec3<f32>, X: vec3<f32>, k: f32) -> f32 {\n  var NdotX = cdot(N, X);\n  return NdotX / max(0.000001, (NdotX*(1-k) + k));\n}\n\nfn smithSurfaceRoughness(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, k: f32) -> f32 {\n  var ggx1: f32 = min(1, schlickGGX(N, V, k));\n  var ggx2: f32 = min(1, schlickGGX(N, L, k));\n  return ggx1*ggx2;\n}\n\n// BRDF Combination\nfn cookTorrance(D: f32, F: f32, G: f32, N: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> f32 {\n  var num: f32 = D*F*G;\n  var denom: f32 = 4*cdot(V, N)*cdot(L, N);\n\n  return num / max(denom, 0.000001);\n}\n\n// Different lighting calculations for different light sources\nfn calcDirectionalLight(N: vec3<f32>, V: vec3<f32>, ior: f32, roughness: f32, metallic: f32, direction: vec3<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {  \n  var L: vec3<f32> = normalize(direction); // Light Vector\n  var H: vec3<f32> = normalize(L + V); // Halfway Vector\n\n  var alpha = roughness*roughness;\n  var k: f32 = alpha*alpha / 2;\n\n  var D: f32 = trGGX(N, H, alpha); // Distribution\n  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel\n  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry\n\n  var brdf: f32 = cookTorrance(D, 1, G, N, V, L); // Fresnel term is replaced with 1 because it is added later\n  var incoming: vec3<f32> = color;\n  var angle: f32 = mdot(L, N);\n  angle = pow(angle, 1.5);\n\n  var specular: vec3<f32> = brdf*incoming*angle;\n  // Oren-Nayar gives a clay-like effect when fully rough which some people may not want, so it might be better to give a separate\n  // control property for the diffuse vs specular roughness\n  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V); \n  // Stores the specular and diffuse separately to allow for finer post processing\n  var out = PBRData(diffuse, specular);\n  \n  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)\n}\n\n// TODO: find some way to reduce the number of arguments going in here\nfn calcPointLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, ior: f32, roughness: f32, metallic: f32, position: vec3<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {\n  var L: vec3<f32> = normalize(position - fragPos); // Light Vector\n  var H: vec3<f32> = normalize(L + V); // Halfway Vector\n  var dist = distance(position, fragPos);\n\n  var alpha = roughness*roughness;\n  var k: f32 = alpha*alpha / 2; // could also be pow(alpha + 1.0, 2) / 8\n\n  var D: f32 = trGGX(N, H, alpha); // Distribution\n  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel\n  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry\n\n  var brdf: f32 = cookTorrance(D, 1, G, N, V, L);  \n  var incoming: vec3<f32> = color * (1. / (dist*dist));\n  var angle: f32 = mdot(L, N);\n  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly \"seams\" bewteen light sources\n\n  var specular: vec3<f32> = brdf*incoming*angle;\n  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V);\n\n  // Stores the specular and diffuse separately to allow for finer post processing\n  // Could also be done (propably more properly) with a struct\n  var out = PBRData(diffuse, specular);\n  \n  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)\n}\n\n// For a reason unknown to me, spheres dont seem to behave propperly with head-on spot lights\nfn calcSpotLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, ior: f32, roughness: f32, metallic: f32, position: vec3<f32>, direction: vec3<f32>, cones: vec2<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {\n  var L: vec3<f32> = normalize(position - fragPos);\n  var H: vec3<f32> = normalize(L + V); // Halfway Vector\n  var dist = distance(position, fragPos);\n\n  var alpha = roughness*roughness;\n  var k: f32 = alpha*alpha / 2; // could also be pow(alpha + 1.0, 2) / 8\n\n  var D: f32 = trGGX(N, H, alpha); // Distribution\n  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel\n  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry\n\n  var brdf: f32 = cookTorrance(D, 1, G, N, V, L);  \n  \n  // Cones.x is the inner phi and cones.y is the outer phi\n  var theta: f32 = mdot(normalize(direction), L);\n  var epsilon: f32 = cones.x - cones.y;\n  var intensity: f32 = (theta - cones.y) / epsilon;\n  intensity = clamp(intensity, 0.0, 1.0);\n  intensity /= dist*dist;\n\n  var incoming: vec3<f32> = color * intensity;\n\n  var angle: f32 = mdot(L, N);\n  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly \"seams\" bewteen light sources\n\n  var specular: vec3<f32> = brdf*incoming*angle;\n  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V);\n\n  // Stores the specular and diffuse separately to allow for finer post processing\n  // Could also be done (propably more properly) with a struct\n  var out = PBRData(diffuse, specular);\n  \n  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)\n}\n\n// Environment mapping stuff\n// Takes in a vector and converts it to an equivalent coordinate in a rectilinear texture. Should be replaced with cubemaps at some point\nfn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {\n  var tau: f32 = 6.28318530718;\n  var pi: f32 = 3.14159265359;\n  var out: vec2<f32> = vec2<f32>(0.0);\n\n  out.x = atan2(dir.z, dir.x) / tau;\n  out.x += 0.5;\n\n  var phix: f32 = length(vec2(dir.x, dir.z));\n  out.y = atan2(dir.y, phix) / pi + 0.5;\n\n  return out;\n}\n\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::TCoord::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  // Temporary ambient, diffuse, and opacity\n  var ambientColor: vec4<f32> = mapperUBO.AmbientColor;\n  var diffuseColor: vec4<f32> = mapperUBO.DiffuseColor;\n  var opacity: f32 = mapperUBO.Opacity;\n\n  // This should be declared somewhere else\n  var _diffuseMap: vec4<f32> = vec4<f32>(1);\n  var _roughnessMap: vec4<f32> = vec4<f32>(1);\n  var _metallicMap: vec4<f32> = vec4<f32>(1);\n  var _normalMap: vec4<f32> = vec4<f32>(0, 0, 1, 0); // normal map was setting off the normal vector detection in fragment\n  var _ambientOcclusionMap: vec4<f32> = vec4<f32>(1);\n  var _emissionMap: vec4<f32> = vec4<f32>(0);\n\n  //VTK::Color::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Normal::Impl\n\n  var computedColor: vec4<f32> = vec4<f32>(diffuseColor.rgb, 1.0);\n\n  //VTK::Light::Impl\n\n  //VTK::Select::Impl\n\n  if (computedColor.a == 0.0) { discard; };\n\n  //VTK::Position::Impl\n\n  //VTK::RenderEncoder::Impl\n\n  return output;\n}\n`;\nfunction isEdges(hash) {\n  // edge pipelines have \"edge\" in them\n  return hash.indexOf('edge') >= 0;\n}\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUCellArrayMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUCellArrayMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUCellArrayMapper');\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      if (model.is2D) {\n        model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor2D');\n        model.forceZValue = true;\n      } else {\n        model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor');\n        model.forceZValue = false;\n      }\n      model.coordinateSystem = model.WebGPUActor.getRenderable().getCoordinateSystem();\n      model.useRendererMatrix = model.coordinateSystem !== CoordinateSystem.DISPLAY;\n      model.WebGPURenderer = model.WebGPUActor.getFirstAncestorOfType('vtkWebGPURenderer');\n      model.WebGPURenderWindow = model.WebGPURenderer.getParent();\n      model.device = model.WebGPURenderWindow.getDevice();\n    }\n  };\n\n  // Renders myself\n  publicAPI.translucentPass = prepass => {\n    if (prepass) {\n      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());\n      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n    }\n  };\n  publicAPI.opaquePass = prepass => {\n    if (prepass) {\n      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());\n      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n    }\n  };\n  publicAPI.updateUBO = () => {\n    // make sure the data is up to date\n    const actor = model.WebGPUActor.getRenderable();\n    const ppty = actor.getProperty();\n    const utime = model.UBO.getSendTime();\n    if (publicAPI.getMTime() > utime || ppty.getMTime() > utime || model.renderable.getMTime() > utime) {\n      // Matricies\n      const keyMats = model.WebGPUActor.getKeyMatrices(model.WebGPURenderer);\n      model.UBO.setArray('BCWCMatrix', keyMats.bcwc);\n      model.UBO.setArray('BCSCMatrix', keyMats.bcsc);\n      model.UBO.setArray('MCWCNormals', keyMats.normalMatrix);\n      if (model.is2D) {\n        model.UBO.setValue('ZValue', model.WebGPUActor.getRenderable().getProperty().getDisplayLocation() === DisplayLocation.FOREGROUND ? 1.0 : 0.0);\n        const aColor = ppty.getColorByReference();\n        model.UBO.setValue('AmbientIntensity', 1.0);\n        model.UBO.setArray('DiffuseColor', [aColor[0], aColor[1], aColor[2], 1.0]);\n        model.UBO.setValue('DiffuseIntensity', 0.0);\n        model.UBO.setValue('SpecularIntensity', 0.0);\n      } else {\n        // Base Colors\n        let aColor = ppty.getAmbientColorByReference();\n        model.UBO.setValue('AmbientIntensity', ppty.getAmbient());\n        model.UBO.setArray('AmbientColor', [aColor[0], aColor[1], aColor[2], 1.0]);\n        model.UBO.setValue('DiffuseIntensity', ppty.getDiffuse());\n        aColor = ppty.getDiffuseColorByReference();\n        model.UBO.setArray('DiffuseColor', [aColor[0], aColor[1], aColor[2], 1.0]);\n        // Roughness\n        model.UBO.setValue('Roughness', ppty.getRoughness());\n        model.UBO.setValue('BaseIOR', ppty.getBaseIOR());\n        // Metallic\n        model.UBO.setValue('Metallic', ppty.getMetallic());\n        // Normal\n        model.UBO.setValue('NormalStrength', ppty.getNormalStrength());\n        // Emission\n        model.UBO.setValue('Emission', ppty.getEmission());\n        // Specular\n        model.UBO.setValue('SpecularIntensity', ppty.getSpecular());\n        aColor = ppty.getSpecularColorByReference();\n        model.UBO.setArray('SpecularColor', [aColor[0], aColor[1], aColor[2], 1.0]);\n      }\n      // Edge and line rendering\n      const aColor = ppty.getEdgeColorByReference?.();\n      if (aColor) {\n        model.UBO.setArray('EdgeColor', [aColor[0], aColor[1], aColor[2], 1.0]);\n      }\n      model.UBO.setValue('LineWidth', ppty.getLineWidth());\n      model.UBO.setValue('Opacity', ppty.getOpacity());\n      model.UBO.setValue('PropID', model.WebGPUActor.getPropID());\n      const device = model.WebGPURenderWindow.getDevice();\n      model.UBO.sendIfNeeded(device);\n    }\n  };\n  publicAPI.haveWideLines = () => {\n    const actor = model.WebGPUActor.getRenderable();\n    const representation = actor.getProperty().getRepresentation();\n    if (actor.getProperty().getLineWidth() <= 1.0) {\n      return false;\n    }\n    if (model.primitiveType === PrimitiveTypes.Verts) {\n      return false;\n    }\n    if (model.primitiveType === PrimitiveTypes.Triangles || model.primitiveType === PrimitiveTypes.TriangleStrips) {\n      return representation === Representation.WIREFRAME;\n    }\n    return true;\n  };\n  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');\n    let code = vDesc.getCode();\n    if (model.useRendererMatrix) {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    var pCoord: vec4<f32> = rendererUBO.SCPCMatrix*mapperUBO.BCSCMatrix*vertexBC;', '    output.vertexVC = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);', '//VTK::Position::Impl']).result;\n      if (model.forceZValue) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['pCoord = vec4<f32>(pCoord.xyz/pCoord.w, 1.0);', 'pCoord.z = mapperUBO.ZValue;', '//VTK::Position::Impl']).result;\n      }\n    } else {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    var pCoord: vec4<f32> = mapperUBO.BCSCMatrix*vertexBC;', '    pCoord.x = 2.0* pCoord.x / rendererUBO.viewportSize.x - 1.0;', '    pCoord.y = 2.0* pCoord.y / rendererUBO.viewportSize.y - 1.0;', '    pCoord.z = 0.5 - 0.5 * pCoord.z;', '//VTK::Position::Impl']).result;\n      if (model.forceZValue) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    pCoord.z = mapperUBO.ZValue;', '//VTK::Position::Impl']).result;\n      }\n    }\n    if (publicAPI.haveWideLines()) {\n      vDesc.addBuiltinInput('u32', '@builtin(instance_index) instanceIndex');\n      // widen the edge\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    var tmpPos: vec4<f32> = pCoord;', '    var numSteps: f32 = ceil(mapperUBO.LineWidth - 1.0);', '    var offset: f32 = (mapperUBO.LineWidth - 1.0) * (f32(input.instanceIndex / 2u) - numSteps/2.0) / numSteps;', '    var tmpPos2: vec3<f32> = tmpPos.xyz / tmpPos.w;', '    tmpPos2.x = tmpPos2.x + 2.0 * (f32(input.instanceIndex) % 2.0) * offset / rendererUBO.viewportSize.x;', '    tmpPos2.y = tmpPos2.y + 2.0 * (f32(input.instanceIndex + 1u) % 2.0) * offset / rendererUBO.viewportSize.y;', '    tmpPos2.z = min(1.0, tmpPos2.z + 0.00001);',\n      // could become a setting\n      '    pCoord = vec4<f32>(tmpPos2.xyz * tmpPos.w, tmpPos.w);', '//VTK::Position::Impl']).result;\n    }\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    output.Position = pCoord;']).result;\n    vDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  publicAPI.replaceShaderNormal = (hash, pipeline, vertexInput) => {\n    const normalBuffer = vertexInput.getBuffer('normalMC');\n    const actor = model.WebGPUActor.getRenderable();\n    if (normalBuffer) {\n      const vDesc = pipeline.getShaderDescription('vertex');\n      if (!vDesc.hasOutput('normalVC')) {\n        vDesc.addOutput('vec3<f32>', 'normalVC', normalBuffer.getArrayInformation()[0].interpolation);\n      }\n      if (!vDesc.hasOutput('tangentVC')) {\n        vDesc.addOutput('vec3<f32>', 'tangentVC', normalBuffer.getArrayInformation()[0].interpolation);\n      }\n      if (!vDesc.hasOutput('bitangentVC')) {\n        vDesc.addOutput('vec3<f32>', 'bitangentVC', normalBuffer.getArrayInformation()[0].interpolation);\n      }\n      let code = vDesc.getCode();\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', ['  output.normalVC = normalize((rendererUBO.WCVCNormals * mapperUBO.MCWCNormals * normalMC).xyz);',\n      // This is just an approximation, but it happens to work extremely well\n      // It only works well for normals that are head on and not super angled though\n      // Definitely needs to be replaced\n      '  var c1: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 0, 1));', '  var c2: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 1, 0));', '  var tangent: vec3<f32> = mix(c1, c2, distance(c1, c2));', '  output.tangentVC = normalize(tangent);', '  output.bitangentVC = normalize(cross(output.normalVC, tangent));']).result;\n      vDesc.setCode(code);\n      const fDesc = pipeline.getShaderDescription('fragment');\n      code = fDesc.getCode();\n      if (actor.getProperty().getNormalTexture()) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', ['  var normal: vec3<f32> = input.normalVC;', '  if (!input.frontFacing) { normal = -normal; }', '  var tangent: vec3<f32> = input.tangentVC;', '  var bitangent: vec3<f32> = input.bitangentVC;', '  var TCVCMatrix: mat3x3<f32> = mat3x3<f32>(', '    tangent.x, bitangent.x, normal.x,', '    tangent.y, bitangent.y, normal.y,', '    tangent.z, bitangent.z, normal.z,', '  );', '  var mappedNormal: vec3<f32> = TCVCMatrix * (_normalMap.xyz * 2 - 1);', '  normal = mix(normal, mappedNormal, mapperUBO.NormalStrength);', '  normal = normalize(normal);']).result;\n      } else {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', ['  var normal: vec3<f32> = input.normalVC;', '  if (!input.frontFacing) { normal = -normal; }', '  normal = normalize(normal);']).result;\n      }\n      fDesc.setCode(code);\n    }\n  };\n  model.shaderReplacements.set('replaceShaderNormal', publicAPI.replaceShaderNormal);\n\n  // we only apply lighting when there is a \"var normal\" declaration in the\n  // fragment shader code. That is the lighting trigger.\n  publicAPI.replaceShaderLight = (hash, pipeline, vertexInput) => {\n    if (hash.includes('sel')) return;\n    const vDesc = pipeline.getShaderDescription('vertex');\n    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');\n    const renderer = model.WebGPURenderer.getRenderable();\n    const fDesc = pipeline.getShaderDescription('fragment');\n    let code = fDesc.getCode();\n\n    // Code that runs if the fragment shader includes normals\n    if (code.includes('var normal:') && model.useRendererMatrix && !isEdges(hash) && !model.is2D && !hash.includes('sel')) {\n      const lightingCode = [\n      // Constants\n      '  var pi: f32 = 3.14159265359;',\n      // Vectors needed for light calculations\n      '  var fragPos: vec3<f32> = vec3<f32>(input.vertexVC.xyz);', '  var V: vec3<f32> = mix(normalize(-fragPos), vec3<f32>(0, 0, 1), f32(rendererUBO.cameraParallel)); // View Vector',\n      // Values needed for light calculations\n      '  var baseColor: vec3<f32> = _diffuseMap.rgb * diffuseColor.rgb;', '  var roughness: f32 = max(0.000001, mapperUBO.Roughness * _roughnessMap.r);',\n      // Need to have a different way of sampling greyscale values aside from .r\n      '  var metallic: f32 = mapperUBO.Metallic * _metallicMap.r;', '  var alpha: f32 = roughness*roughness;', '  var ior: f32 = mapperUBO.BaseIOR;', '  var k: f32 = alpha*alpha / 2;',\n      // Split diffuse and specular components\n      '  var diffuse: vec3<f32> = vec3<f32>(0.);', '  var specular: vec3<f32> = vec3<f32>(0.);', '  var emission: vec3<f32> = _emissionMap.rgb * mapperUBO.Emission;',\n      // Summing diffuse and specular components of directional lights\n      '  {', '    var i: i32 = 0;', '    loop {', '      if !(i < rendererUBO.LightCount) { break; }', '      switch (i32(rendererLightSSBO.values[i].LightData.x)) {', '         // Point Light', '         case 0 {', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var pos: vec3<f32> = (rendererLightSSBO.values[i].LightPos).xyz;', '           var calculated: PBRData = calcPointLight(normal, V, fragPos, ior, roughness, metallic, pos, color, baseColor);', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '          }', '         // Directional light', '         case 1 {', '           var dir: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz;', '           dir = normalize(dir);', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var calculated: PBRData = calcDirectionalLight(normal, V, ior, roughness, metallic, dir, color, baseColor); // diffuseColor.rgb needs to be fixed with a more dynamic diffuse color', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '         }', '         // Spot Light', '         case 2 {', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var pos: vec3<f32> = (rendererLightSSBO.values[i].LightPos).xyz;', '           var dir: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz;', '           dir = normalize(dir);', '           var cones: vec2<f32> = vec2<f32>(rendererLightSSBO.values[i].LightData.y, rendererLightSSBO.values[i].LightData.z);', '           var calculated: PBRData = calcSpotLight(normal, V, fragPos, ior, roughness, metallic, pos, dir, cones, color, baseColor);', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '         }', '         default { continue; }', '       }', '      continuing { i++; }', '    }', '  }',\n      // Final variables for combining specular and diffuse\n      '  var fresnel: f32 = schlickFresnelIOR(V, normal, ior, k); // Fresnel', '  fresnel = min(1, fresnel);', '  // This could be controlled with its own variable (that isnt base color) for better artistic control', '  var fresnelMetallic: vec3<f32> = schlickFresnelRGB(V, normal, baseColor); // Fresnel for metal, takes color into account', '  var kS: vec3<f32> = mix(vec3<f32>(fresnel), fresnelMetallic, metallic);', '  kS = min(vec3<f32>(1), kS);', '  var kD: vec3<f32> = (1.0 - kS) * (1.0 - metallic);', '  var PBR: vec3<f32> = mapperUBO.DiffuseIntensity*kD*diffuse + kS*specular;', '  PBR += emission;', '  computedColor = vec4<f32>(PBR, mapperUBO.Opacity);'];\n      if (renderer.getEnvironmentTexture()?.getImageLoaded()) {\n        lightingCode.push('  // To get diffuse IBL, the texture is sampled with normals in worldspace', '  var diffuseIBLCoords: vec3<f32> = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(normal, 1.)).xyz;', '  var diffuseCoords: vec2<f32> = vecToRectCoord(diffuseIBLCoords);', '  // To get specular IBL, the texture is sampled as the worldspace reflection between the normal and view vectors', '  // Reflections are first calculated in viewspace, then converted to worldspace to sample the environment', '  var VreflN: vec3<f32> = normalize(reflect(-V, normal));', '  var reflectionIBLCoords = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(VreflN, 1.)).xyz;', '  var specularCoords: vec2<f32> = vecToRectCoord(reflectionIBLCoords);', '  var diffuseIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, diffuseCoords, rendererUBO.MaxEnvironmentMipLevel);',\n        // Level multiplier should be set by UBO\n        '  var level = roughness * rendererUBO.MaxEnvironmentMipLevel;', '  var specularIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, specularCoords, level);',\n        // Manual mip smoothing since not all formats support smooth level sampling\n        '  var specularIBLContribution: vec3<f32> = specularIBL.rgb*rendererUBO.BackgroundSpecularStrength;', '  computedColor += vec4<f32>(specularIBLContribution*kS, 0);', '  var diffuseIBLContribution: vec3<f32> = diffuseIBL.rgb*rendererUBO.BackgroundDiffuseStrength;', '  diffuseIBLContribution *= baseColor * _ambientOcclusionMap.rgb;',\n        // Multipy by baseColor may be changed\n        '  computedColor += vec4<f32>(diffuseIBLContribution*kD, 0);');\n      }\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Light::Impl', lightingCode).result;\n      fDesc.setCode(code);\n      // If theres no normals, just set the specular color to be flat\n    } else {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Light::Impl', ['  var diffuse: vec3<f32> = diffuseColor.rgb;', '  var specular: vec3<f32> = mapperUBO.SpecularColor.rgb * mapperUBO.SpecularColor.a;', '  computedColor = vec4<f32>(diffuse * _diffuseMap.rgb, mapperUBO.Opacity);']).result;\n      fDesc.setCode(code);\n    }\n  };\n  model.shaderReplacements.set('replaceShaderLight', publicAPI.replaceShaderLight);\n  publicAPI.replaceShaderColor = (hash, pipeline, vertexInput) => {\n    // By default, set the colors to be flat\n    if (isEdges(hash)) {\n      const fDesc = pipeline.getShaderDescription('fragment');\n      let code = fDesc.getCode();\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Color::Impl', ['ambientColor = mapperUBO.EdgeColor;', 'diffuseColor = mapperUBO.EdgeColor;']).result;\n      fDesc.setCode(code);\n      return;\n    }\n\n    // If there's no vertex color buffer return the shader as is\n    const colorBuffer = vertexInput.getBuffer('colorVI');\n    if (!colorBuffer) return;\n\n    // Modifies the vertex shader to include the vertex colors and interpolation in the outputs\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addOutput('vec4<f32>', 'color', colorBuffer.getArrayInformation()[0].interpolation);\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Color::Impl', ['  output.color = colorVI;']).result;\n    vDesc.setCode(code);\n\n    // Sets the fragment shader to accept the color inputs from the vertex shader\n    const fDesc = pipeline.getShaderDescription('fragment');\n    code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Color::Impl', ['ambientColor = input.color;', 'diffuseColor = input.color;', 'opacity = mapperUBO.Opacity * input.color.a;']).result;\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderColor', publicAPI.replaceShaderColor);\n  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {\n    if (!vertexInput.hasAttribute('tcoord')) return;\n    const vDesc = pipeline.getShaderDescription('vertex');\n    const tcoords = vertexInput.getBuffer('tcoord');\n    const numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);\n    let code = vDesc.getCode();\n    vDesc.addOutput(`vec${numComp}<f32>`, 'tcoordVS');\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::TCoord::Impl', ['  output.tcoordVS = tcoord;']).result;\n    vDesc.setCode(code);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    code = fDesc.getCode();\n    const actor = model.WebGPUActor.getRenderable();\n    const checkDims = texture => {\n      if (!texture) return false;\n      const dims = texture.getDimensionality();\n      return dims === numComp;\n    };\n    const usedTextures = [];\n    if (actor.getProperty().getDiffuseTexture?.()?.getImageLoaded() || actor.getTextures()[0] || model.colorTexture) {\n      if (\n      // Chained or statements here are questionable\n      checkDims(actor.getProperty().getDiffuseTexture?.()) || checkDims(actor.getTextures()[0]) || checkDims(model.colorTexture)) {\n        usedTextures.push('_diffuseMap = textureSample(DiffuseTexture, DiffuseTextureSampler, input.tcoordVS);');\n      }\n    }\n    if (actor.getProperty().getRoughnessTexture?.()?.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getRoughnessTexture())) {\n        usedTextures.push('_roughnessMap = textureSample(RoughnessTexture, RoughnessTextureSampler, input.tcoordVS);');\n      }\n    }\n    if (actor.getProperty().getMetallicTexture?.()?.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getMetallicTexture())) {\n        usedTextures.push('_metallicMap = textureSample(MetallicTexture, MetallicTextureSampler, input.tcoordVS);');\n      }\n    }\n    if (actor.getProperty().getNormalTexture?.()?.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getNormalTexture())) {\n        usedTextures.push('_normalMap = textureSample(NormalTexture, NormalTextureSampler, input.tcoordVS);');\n      }\n    }\n    if (actor.getProperty().getAmbientOcclusionTexture?.()?.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getAmbientOcclusionTexture())) {\n        usedTextures.push('_ambientOcclusionMap = textureSample(AmbientOcclusionTexture, AmbientOcclusionTextureSampler, input.tcoordVS);');\n      }\n    }\n    if (actor.getProperty().getEmissionTexture?.()?.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getEmissionTexture())) {\n        usedTextures.push('_emissionMap = textureSample(EmissionTexture, EmissionTextureSampler, input.tcoordVS);');\n      }\n    }\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::TCoord::Impl', usedTextures).result;\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);\n  publicAPI.replaceShaderSelect = (hash, pipeline, vertexInput) => {\n    if (hash.includes('sel')) {\n      const fDesc = pipeline.getShaderDescription('fragment');\n      let code = fDesc.getCode();\n      // by default there are no composites, so just 0\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Select::Impl', ['  var compositeID: u32 = 0u;']).result;\n      fDesc.setCode(code);\n    }\n  };\n  model.shaderReplacements.set('replaceShaderSelect', publicAPI.replaceShaderSelect);\n  publicAPI.getUsage = (rep, i) => {\n    if (rep === Representation.POINTS || i === PrimitiveTypes.Points) {\n      return BufferUsage.Verts;\n    }\n    if (i === PrimitiveTypes.Lines) {\n      return BufferUsage.Lines;\n    }\n    if (rep === Representation.WIREFRAME) {\n      if (i === PrimitiveTypes.Triangles) {\n        return BufferUsage.LinesFromTriangles;\n      }\n      return BufferUsage.LinesFromStrips;\n    }\n    if (i === PrimitiveTypes.Triangles) {\n      return BufferUsage.Triangles;\n    }\n    if (i === PrimitiveTypes.TriangleStrips) {\n      return BufferUsage.Strips;\n    }\n    if (i === PrimitiveTypes.TriangleEdges) {\n      return BufferUsage.LinesFromTriangles;\n    }\n\n    // only strip edges left which are lines\n    return BufferUsage.LinesFromStrips;\n  };\n  publicAPI.getHashFromUsage = usage => `pt${usage}`;\n  publicAPI.getTopologyFromUsage = usage => {\n    switch (usage) {\n      case BufferUsage.Triangles:\n        return 'triangle-list';\n      case BufferUsage.Verts:\n        return 'point-list';\n      case BufferUsage.Lines:\n      default:\n        return 'line-list';\n    }\n  };\n\n  // TODO: calculate tangents\n  publicAPI.buildVertexInput = () => {\n    const pd = model.currentInput;\n    const cells = model.cellArray;\n    const primType = model.primitiveType;\n    const actor = model.WebGPUActor.getRenderable();\n    let representation = actor.getProperty().getRepresentation();\n    const device = model.WebGPURenderWindow.getDevice();\n    let edges = false;\n    if (primType === PrimitiveTypes.TriangleEdges) {\n      edges = true;\n      representation = Representation.WIREFRAME;\n    }\n    const vertexInput = model.vertexInput;\n    const points = pd.getPoints();\n    let indexBuffer;\n\n    // get the flat mapping indexBuffer for the cells\n    if (cells) {\n      const buffRequest = {\n        hash: `R${representation}P${primType}${cells.getMTime()}`,\n        usage: BufferUsage.Index,\n        cells,\n        numberOfPoints: points.getNumberOfPoints(),\n        primitiveType: primType,\n        representation\n      };\n      indexBuffer = device.getBufferManager().getBuffer(buffRequest);\n      vertexInput.setIndexBuffer(indexBuffer);\n    } else {\n      vertexInput.setIndexBuffer(null);\n    }\n\n    // hash = all things that can change the values on the buffer\n    // since mtimes are unique we can use\n    // - indexBuffer mtime - because cells drive how we pack\n    // - relevant dataArray mtime - the source data\n    // - shift - not currently captured\n    // - scale - not currently captured\n    // - format\n    // - usage\n    // - packExtra - covered by format\n\n    // points\n    if (points) {\n      const shift = model.WebGPUActor.getBufferShift(model.WebGPURenderer);\n      const buffRequest = {\n        hash: `${points.getMTime()}I${indexBuffer.getMTime()}${shift.join()}float32x4`,\n        usage: BufferUsage.PointArray,\n        format: 'float32x4',\n        dataArray: points,\n        indexBuffer,\n        shift,\n        packExtra: true\n      };\n      const buff = device.getBufferManager().getBuffer(buffRequest);\n      vertexInput.addBuffer(buff, ['vertexBC']);\n    } else {\n      vertexInput.removeBufferIfPresent('vertexBC');\n    }\n\n    // normals, only used for surface rendering\n    const usage = publicAPI.getUsage(representation, primType);\n    model._usesCellNormals = false;\n    if (!model.is2D && (\n    // no lighting on Property2D\n    usage === BufferUsage.Triangles || usage === BufferUsage.Strips)) {\n      const normals = pd.getPointData().getNormals();\n      // https://vtk.org/doc/nightly/html/classvtkPolyDataTangents.html\n      // Need to find some way of using precomputed tangents (or computing new ones)\n      const buffRequest = {\n        format: 'snorm8x4',\n        indexBuffer,\n        packExtra: true,\n        shift: 0,\n        scale: 127\n      };\n      if (normals) {\n        buffRequest.hash = `${normals.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;\n        buffRequest.dataArray = normals;\n        buffRequest.usage = BufferUsage.PointArray;\n        const buff = device.getBufferManager().getBuffer(buffRequest);\n        vertexInput.addBuffer(buff, ['normalMC']);\n      } else if (primType === PrimitiveTypes.Triangles) {\n        model._usesCellNormals = true;\n        buffRequest.hash = `PFN${points.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;\n        buffRequest.dataArray = points;\n        buffRequest.cells = cells;\n        buffRequest.usage = BufferUsage.NormalsFromPoints;\n        const buff = device.getBufferManager().getBuffer(buffRequest);\n        vertexInput.addBuffer(buff, ['normalMC']);\n      } else {\n        vertexInput.removeBufferIfPresent('normalMC');\n      }\n    } else {\n      vertexInput.removeBufferIfPresent('normalMC');\n    }\n\n    // deal with colors but only if modified\n    let haveColors = false;\n    if (model.renderable.getScalarVisibility()) {\n      const c = model.renderable.getColorMapColors();\n      if (c && !edges) {\n        const scalarMode = model.renderable.getScalarMode();\n        let haveCellScalars = false;\n        // We must figure out how the scalars should be mapped to the polydata.\n        if ((scalarMode === ScalarMode.USE_CELL_DATA || scalarMode === ScalarMode.USE_CELL_FIELD_DATA || scalarMode === ScalarMode.USE_FIELD_DATA || !pd.getPointData().getScalars()) && scalarMode !== ScalarMode.USE_POINT_FIELD_DATA && c) {\n          haveCellScalars = true;\n        }\n        const buffRequest = {\n          usage: BufferUsage.PointArray,\n          format: 'unorm8x4',\n          hash: `${haveCellScalars}${c.getMTime()}I${indexBuffer.getMTime()}unorm8x4`,\n          dataArray: c,\n          indexBuffer,\n          cellData: haveCellScalars,\n          cellOffset: 0\n        };\n        const buff = device.getBufferManager().getBuffer(buffRequest);\n        vertexInput.addBuffer(buff, ['colorVI']);\n        haveColors = true;\n      }\n    }\n    if (!haveColors) {\n      vertexInput.removeBufferIfPresent('colorVI');\n    }\n    let tcoords = null;\n    if (model.renderable.getInterpolateScalarsBeforeMapping?.() && model.renderable.getColorCoordinates()) {\n      tcoords = model.renderable.getColorCoordinates();\n    } else {\n      tcoords = pd.getPointData().getTCoords();\n    }\n    if (tcoords && !edges) {\n      const buff = device.getBufferManager().getBufferForPointArray(tcoords, vertexInput.getIndexBuffer());\n      vertexInput.addBuffer(buff, ['tcoord']);\n    } else {\n      vertexInput.removeBufferIfPresent('tcoord');\n    }\n  };\n  publicAPI.updateTextures = () => {\n    // we keep track of new and used textures so\n    // that we can clean up any unused textures so we don't hold onto them\n    const usedTextures = [];\n    const newTextures = [];\n\n    // do we have a scalar color texture\n    const idata = model.renderable.getColorTextureMap?.();\n    if (idata) {\n      if (!model.colorTexture) {\n        model.colorTexture = vtkTexture.newInstance({\n          label: 'polyDataColor'\n        });\n      }\n      model.colorTexture.setInputData(idata);\n      newTextures.push(['Diffuse', model.colorTexture]);\n    }\n\n    // actor textures?\n    const actor = model.WebGPUActor.getRenderable();\n    const renderer = model.WebGPURenderer.getRenderable();\n\n    // Reusing the old code for new and old textures, just loading in from properties instead of actor.getTextures()\n    const textures = [];\n\n    // Feels like there should be a better way than individually adding all\n    if (actor.getProperty().getDiffuseTexture?.()) {\n      const pair = ['Diffuse', actor.getProperty().getDiffuseTexture()];\n      textures.push(pair);\n    }\n    if (actor.getTextures()[0]) {\n      const pair = ['Diffuse', actor.getTextures()[0]];\n      textures.push(pair);\n    }\n    if (model.colorTexture) {\n      const pair = ['Diffuse', model.colorTexture];\n      textures.push(pair);\n    }\n    if (actor.getProperty().getRoughnessTexture?.()) {\n      const pair = ['Roughness', actor.getProperty().getRoughnessTexture()];\n      textures.push(pair);\n    }\n    if (actor.getProperty().getMetallicTexture?.()) {\n      const pair = ['Metallic', actor.getProperty().getMetallicTexture()];\n      textures.push(pair);\n    }\n    if (actor.getProperty().getNormalTexture?.()) {\n      const pair = ['Normal', actor.getProperty().getNormalTexture()];\n      textures.push(pair);\n    }\n    if (actor.getProperty().getAmbientOcclusionTexture?.()) {\n      const pair = ['AmbientOcclusion', actor.getProperty().getAmbientOcclusionTexture()];\n      textures.push(pair);\n    }\n    if (actor.getProperty().getEmissionTexture?.()) {\n      const pair = ['Emission', actor.getProperty().getEmissionTexture()];\n      textures.push(pair);\n    }\n    if (renderer.getEnvironmentTexture?.()) {\n      const pair = ['Environment', renderer.getEnvironmentTexture()];\n      textures.push(pair);\n    }\n    for (let i = 0; i < textures.length; i++) {\n      if (textures[i][1].getInputData() || textures[i][1].getJsImageData() || textures[i][1].getCanvas()) {\n        newTextures.push(textures[i]);\n      }\n      if (textures[i][1].getImage() && textures[i][1].getImageLoaded()) {\n        newTextures.push(textures[i]);\n      }\n    }\n    for (let i = 0; i < newTextures.length; i++) {\n      const srcTexture = newTextures[i][1];\n      const textureName = newTextures[i][0];\n      const newTex = model.device.getTextureManager().getTextureForVTKTexture(srcTexture); // Generates hash\n      if (newTex.getReady()) {\n        // is this a new texture\n        let found = false;\n        for (let t = 0; t < model.textures.length; t++) {\n          if (model.textures[t] === newTex) {\n            found = true;\n            usedTextures[t] = true;\n          }\n        }\n        if (!found) {\n          usedTextures[model.textures.length] = true;\n          const tview = newTex.createView(`${textureName}Texture`);\n          model.textures.push(newTex);\n          model.textureViews.push(tview);\n          const interpolate = srcTexture.getInterpolate() ? 'linear' : 'nearest';\n          let addressMode = null;\n          if (!addressMode && srcTexture.getEdgeClamp() && srcTexture.getRepeat()) addressMode = 'mirror-repeat';\n          if (!addressMode && srcTexture.getEdgeClamp()) addressMode = 'clamp-to-edge';\n          if (!addressMode && srcTexture.getRepeat()) addressMode = 'repeat';\n          if (textureName !== 'Environment') {\n            tview.addSampler(model.device, {\n              addressModeU: addressMode,\n              addressModeV: addressMode,\n              addressModeW: addressMode,\n              minFilter: interpolate,\n              magFilter: interpolate\n            });\n          } else {\n            tview.addSampler(model.device, {\n              addressModeU: 'repeat',\n              addressModeV: 'clamp-to-edge',\n              addressModeW: 'repeat',\n              minFilter: interpolate,\n              magFilter: interpolate,\n              mipmapFilter: 'linear'\n            });\n          }\n        }\n      }\n    }\n\n    // remove unused textures\n    for (let i = model.textures.length - 1; i >= 0; i--) {\n      if (!usedTextures[i]) {\n        model.textures.splice(i, 1);\n        model.textureViews.splice(i, 1);\n      }\n    }\n  };\n\n  // compute a unique hash for a pipeline, this needs to be unique enough to\n  // capture any pipeline code changes (which includes shader changes)\n  // or vertex input changes/ bind groups/ etc\n  publicAPI.computePipelineHash = () => {\n    let pipelineHash = `pd${model.useRendererMatrix ? 'r' : ''}${model.forceZValue ? 'z' : ''}`;\n    if (model.primitiveType === PrimitiveTypes.TriangleEdges || model.primitiveType === PrimitiveTypes.TriangleStripEdges) {\n      pipelineHash += 'edge';\n    } else {\n      if (model.vertexInput.hasAttribute(`normalMC`)) {\n        pipelineHash += `n`;\n      }\n      if (model.vertexInput.hasAttribute(`colorVI`)) {\n        pipelineHash += `c`;\n      }\n      if (model.vertexInput.hasAttribute(`tcoord`)) {\n        const tcoords = model.vertexInput.getBuffer('tcoord');\n        const numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);\n        pipelineHash += `t${numComp}`;\n      }\n      if (model.textures.length) {\n        pipelineHash += `tx${model.textures.length}`;\n      }\n    }\n    if (model._usesCellNormals) {\n      pipelineHash += `cn`;\n    }\n    if (model.SSBO) {\n      pipelineHash += `ssbo`;\n    }\n    const uhash = publicAPI.getHashFromUsage(model.usage);\n    pipelineHash += uhash;\n    pipelineHash += model.renderEncoder.getPipelineHash();\n    model.pipelineHash = pipelineHash;\n  };\n  publicAPI.updateBuffers = () => {\n    // handle textures if not edges\n    if (model.primitiveType !== PrimitiveTypes.TriangleEdges && model.primitiveType !== PrimitiveTypes.TriangleStripEdges) {\n      publicAPI.updateTextures();\n    }\n    const actor = model.WebGPUActor.getRenderable();\n    const rep = actor.getProperty().getRepresentation();\n\n    // handle per primitive type\n    model.usage = publicAPI.getUsage(rep, model.primitiveType);\n    publicAPI.buildVertexInput();\n    const vbo = model.vertexInput.getBuffer('vertexBC');\n    publicAPI.setNumberOfVertices(vbo.getSizeInBytes() / vbo.getStrideInBytes());\n    publicAPI.setTopology(publicAPI.getTopologyFromUsage(model.usage));\n    publicAPI.updateUBO();\n    if (publicAPI.haveWideLines()) {\n      const ppty = actor.getProperty();\n      publicAPI.setNumberOfInstances(Math.ceil(ppty.getLineWidth() * 2.0));\n    } else {\n      publicAPI.setNumberOfInstances(1);\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  is2D: false,\n  cellArray: null,\n  currentInput: null,\n  cellOffset: 0,\n  primitiveType: 0,\n  colorTexture: null,\n  renderEncoder: null,\n  textures: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initiaLalues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initiaLalues);\n\n  // Inheritance\n  vtkWebGPUSimpleMapper.extend(publicAPI, model, initiaLalues);\n  model.fragmentShaderTemplate = vtkWebGPUPolyDataFS;\n  model.vertexShaderTemplate = vtkWebGPUPolyDataVS;\n  model._tmpMat3 = mat3.identity(new Float64Array(9));\n  model._tmpMat4 = mat4.identity(new Float64Array(16));\n\n  // UBO\n  model.UBO = vtkWebGPUUniformBuffer.newInstance({\n    label: 'mapperUBO'\n  });\n  model.UBO.addEntry('BCWCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('BCSCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('MCWCNormals', 'mat4x4<f32>');\n  model.UBO.addEntry('AmbientColor', 'vec4<f32>');\n  model.UBO.addEntry('DiffuseColor', 'vec4<f32>');\n  model.UBO.addEntry('EdgeColor', 'vec4<f32>');\n  model.UBO.addEntry('SpecularColor', 'vec4<f32>');\n  model.UBO.addEntry('AmbientIntensity', 'f32');\n  model.UBO.addEntry('DiffuseIntensity', 'f32');\n  model.UBO.addEntry('Roughness', 'f32');\n  model.UBO.addEntry('Metallic', 'f32');\n  model.UBO.addEntry('Ambient', 'f32');\n  model.UBO.addEntry('Normal', 'f32');\n  model.UBO.addEntry('Emission', 'f32');\n  model.UBO.addEntry('NormalStrength', 'f32');\n  model.UBO.addEntry('BaseIOR', 'f32');\n  model.UBO.addEntry('SpecularIntensity', 'f32');\n  model.UBO.addEntry('LineWidth', 'f32');\n  model.UBO.addEntry('Opacity', 'f32');\n  model.UBO.addEntry('ZValue', 'f32');\n  model.UBO.addEntry('PropID', 'u32');\n  model.UBO.addEntry('ClipNear', 'f32');\n  model.UBO.addEntry('ClipFar', 'f32');\n  model.UBO.addEntry('Time', 'u32');\n\n  // Build VTK API\n  setGet(publicAPI, model, ['cellArray', 'currentInput', 'cellOffset', 'is2D', 'primitiveType', 'renderEncoder']);\n  model.textures = [];\n\n  // Object methods\n  vtkWebGPUCellArrayMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkWebGPUCellArrayMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUCellArrayMapper$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUCellArrayMapper$1 as default, extend, newInstance };\n"],"mappings":";;;;AAAA,SAASA,IAAI,EAAEC,IAAI,QAAQ,WAAW;AACtC,SAASC,CAAC,IAAIC,aAAa,EAAEC,CAAC,IAAIC,MAAM,QAAQ,kBAAkB;AAClE,OAAOC,SAAS,MAAM,mBAAmB;AACzC,OAAOC,OAAO,MAAM,iBAAiB;AACrC,OAAOC,WAAW,MAAM,qBAAqB;AAC7C,OAAOC,aAAa,MAAM,uBAAuB;AACjD,OAAOC,UAAU,MAAM,oBAAoB;AAC3C,OAAOC,sBAAsB,MAAM,oBAAoB;AACvD,OAAOC,oBAAoB,MAAM,kBAAkB;AACnD,OAAOC,sBAAsB,MAAM,oBAAoB;AACvD,OAAOC,qBAAqB,MAAM,mBAAmB;AACrD,OAAOC,cAAc,MAAM,YAAY;AAEvC,MAAM;EACJC,WAAW;EACXC;AACF,CAAC,GAAGN,sBAAsB;AAC1B,MAAM;EACJO;AACF,CAAC,GAAGV,WAAW;AACf,MAAM;EACJW;AACF,CAAC,GAAGb,SAAS;AACb,MAAM;EACJc;AACF,CAAC,GAAGb,OAAO;AACX,MAAM;EACJc;AACF,CAAC,GAAGZ,aAAa;AACjB,MAAMa,mBAAmB,GAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,MAAMC,mBAAmB,GAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,SAASC,OAAOA,CAACC,IAAI,EAAE;EACrB;EACA,OAAOA,IAAI,CAACC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC;AAClC;;AAEA;AACA;AACA;;AAEA,SAASC,wBAAwBA,CAACC,SAAS,EAAEC,KAAK,EAAE;EAClD;EACAA,KAAK,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"},"metadata":{},"sourceType":"module","externalDependencies":[]}