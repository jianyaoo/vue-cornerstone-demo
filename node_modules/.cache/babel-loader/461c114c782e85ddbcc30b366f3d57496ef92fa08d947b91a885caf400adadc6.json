{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkPoints from '../../Common/Core/Points.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport { DesiredOutputPrecision } from '../../Common/DataModel/DataSetAttributes/Constants.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nconst {\n  vtkErrorMacro\n} = macro;\nfunction offsetCellArray(typedArray, offset) {\n  let currentIdx = 0;\n  return typedArray.map((value, index) => {\n    if (index === currentIdx) {\n      currentIdx += value + 1;\n      return value;\n    }\n    return value + offset;\n  });\n}\nfunction appendCellData(dest, src, ptOffset, cellOffset) {\n  dest.set(offsetCellArray(src, ptOffset), cellOffset);\n}\n\n// ----------------------------------------------------------------------------\n// vtkAppendPolyData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkAppendPolyData(publicAPI, model) {\n  // Set our classname\n  model.classHierarchy.push('vtkAppendPolyData');\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const numberOfInputs = publicAPI.getNumberOfInputPorts();\n    if (!numberOfInputs) {\n      vtkErrorMacro('No input specified.');\n      return;\n    }\n    if (numberOfInputs === 1) {\n      // pass through filter\n      outData[0] = inData[0];\n      return;\n    }\n\n    // Allocate output\n    const output = vtkPolyData.newInstance();\n    let numPts = 0;\n    let pointType = 0;\n    let ttype = 1;\n    let firstType = 1;\n    let numVerts = 0;\n    let numLines = 0;\n    let numStrips = 0;\n    let numPolys = 0;\n\n    // Field data is propagated to output only if present in all inputs\n    let hasPtNormals = true; // assume present by default\n    let hasPtTCoords = true;\n    let hasPtScalars = true;\n    for (let i = 0; i < numberOfInputs; i++) {\n      const ds = inData[i];\n      if (!ds) {\n        // eslint-disable-next-line\n        continue;\n      }\n      const dsNumPts = ds.getPoints().getNumberOfPoints();\n      numPts += dsNumPts;\n      numVerts += ds.getVerts().getNumberOfValues();\n      numLines += ds.getLines().getNumberOfValues();\n      numStrips += ds.getStrips().getNumberOfValues();\n      numPolys += ds.getPolys().getNumberOfValues();\n      if (dsNumPts) {\n        if (firstType) {\n          firstType = 0;\n          pointType = ds.getPoints().getDataType();\n        }\n        ttype = ds.getPoints().getDataType();\n        pointType = pointType > ttype ? pointType : ttype;\n      }\n      const ptD = ds.getPointData();\n      if (ptD) {\n        hasPtNormals = hasPtNormals && ptD.getNormals() !== null;\n        hasPtTCoords = hasPtTCoords && ptD.getTCoords() !== null;\n        hasPtScalars = hasPtScalars && ptD.getScalars() !== null;\n      } else {\n        hasPtNormals = false;\n        hasPtTCoords = false;\n        hasPtScalars = false;\n      }\n    }\n    if (model.outputPointsPrecision === DesiredOutputPrecision.SINGLE) {\n      pointType = VtkDataTypes.FLOAT;\n    } else if (model.outputPointsPrecision === DesiredOutputPrecision.DOUBLE) {\n      pointType = VtkDataTypes.DOUBLE;\n    }\n    const points = vtkPoints.newInstance({\n      dataType: pointType\n    });\n    points.setNumberOfPoints(numPts);\n    const pointData = points.getData();\n    const vertData = new Uint32Array(numVerts);\n    const lineData = new Uint32Array(numLines);\n    const stripData = new Uint32Array(numStrips);\n    const polyData = new Uint32Array(numPolys);\n    let newPtNormals = null;\n    let newPtTCoords = null;\n    let newPtScalars = null;\n    const lds = inData[numberOfInputs - 1];\n    if (hasPtNormals) {\n      const dsNormals = lds.getPointData().getNormals();\n      newPtNormals = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        numberOfTuples: numPts,\n        size: 3 * numPts,\n        dataType: dsNormals.getDataType(),\n        name: dsNormals.getName()\n      });\n    }\n    if (hasPtTCoords) {\n      const dsTCoords = lds.getPointData().getTCoords();\n      newPtTCoords = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        numberOfTuples: numPts,\n        size: 2 * numPts,\n        dataType: dsTCoords.getDataType(),\n        name: dsTCoords.getName()\n      });\n    }\n    if (hasPtScalars) {\n      const dsScalars = lds.getPointData().getScalars();\n      newPtScalars = vtkDataArray.newInstance({\n        numberOfComponents: dsScalars.getNumberOfComponents(),\n        numberOfTuples: numPts,\n        size: numPts * dsScalars.getNumberOfComponents(),\n        dataType: dsScalars.getDataType(),\n        name: dsScalars.getName()\n      });\n    }\n    numPts = 0;\n    numVerts = 0;\n    numLines = 0;\n    numStrips = 0;\n    numPolys = 0;\n    for (let i = 0; i < numberOfInputs; i++) {\n      const ds = inData[i];\n      pointData.set(ds.getPoints().getData(), numPts * 3);\n      appendCellData(vertData, ds.getVerts().getData(), numPts, numVerts);\n      numVerts += ds.getVerts().getNumberOfValues();\n      appendCellData(lineData, ds.getLines().getData(), numPts, numLines);\n      numLines += ds.getLines().getNumberOfValues();\n      appendCellData(stripData, ds.getStrips().getData(), numPts, numStrips);\n      numStrips += ds.getStrips().getNumberOfValues();\n      appendCellData(polyData, ds.getPolys().getData(), numPts, numPolys);\n      numPolys += ds.getPolys().getNumberOfValues();\n      const dsPD = ds.getPointData();\n      if (hasPtNormals) {\n        const ptNorms = dsPD.getNormals();\n        newPtNormals.getData().set(ptNorms.getData(), numPts * 3);\n      }\n      if (hasPtTCoords) {\n        const ptTCoords = dsPD.getTCoords();\n        newPtTCoords.getData().set(ptTCoords.getData(), numPts * 2);\n      }\n      if (hasPtScalars) {\n        const ptScalars = dsPD.getScalars();\n        newPtScalars.getData().set(ptScalars.getData(), numPts * newPtScalars.getNumberOfComponents());\n      }\n      numPts += ds.getPoints().getNumberOfPoints();\n    }\n    output.setPoints(points);\n    output.getVerts().setData(vertData);\n    output.getLines().setData(lineData);\n    output.getStrips().setData(stripData);\n    output.getPolys().setData(polyData);\n    if (newPtNormals) {\n      output.getPointData().setNormals(newPtNormals);\n    }\n    if (newPtTCoords) {\n      output.getPointData().setTCoords(newPtTCoords);\n    }\n    if (newPtScalars) {\n      output.getPointData().setScalars(newPtScalars);\n    }\n    outData[0] = output;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  outputPointsPrecision: DesiredOutputPrecision.DEFAULT\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.setGet(publicAPI, model, ['outputPointsPrecision']);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n\n  // Object specific methods\n  vtkAppendPolyData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkAppendPolyData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkAppendPolyData$1 = {\n  newInstance,\n  extend\n};\nexport { vtkAppendPolyData$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkDataArray","vtkPoints","vtkPolyData","DesiredOutputPrecision","VtkDataTypes","vtkErrorMacro","offsetCellArray","typedArray","offset","currentIdx","map","value","index","appendCellData","dest","src","ptOffset","cellOffset","set","vtkAppendPolyData","publicAPI","model","classHierarchy","push","requestData","inData","outData","numberOfInputs","getNumberOfInputPorts","output","newInstance","numPts","pointType","ttype","firstType","numVerts","numLines","numStrips","numPolys","hasPtNormals","hasPtTCoords","hasPtScalars","i","ds","dsNumPts","getPoints","getNumberOfPoints","getVerts","getNumberOfValues","getLines","getStrips","getPolys","getDataType","ptD","getPointData","getNormals","getTCoords","getScalars","outputPointsPrecision","SINGLE","FLOAT","DOUBLE","points","dataType","setNumberOfPoints","pointData","getData","vertData","Uint32Array","lineData","stripData","polyData","newPtNormals","newPtTCoords","newPtScalars","lds","dsNormals","numberOfComponents","numberOfTuples","size","name","getName","dsTCoords","dsScalars","getNumberOfComponents","dsPD","ptNorms","ptTCoords","ptScalars","setPoints","setData","setNormals","setTCoords","setScalars","DEFAULT_VALUES","DEFAULT","extend","initialValues","arguments","length","undefined","Object","assign","setGet","obj","algo","vtkAppendPolyData$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Filters/General/AppendPolyData.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkPoints from '../../Common/Core/Points.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport { DesiredOutputPrecision } from '../../Common/DataModel/DataSetAttributes/Constants.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nfunction offsetCellArray(typedArray, offset) {\n  let currentIdx = 0;\n  return typedArray.map((value, index) => {\n    if (index === currentIdx) {\n      currentIdx += value + 1;\n      return value;\n    }\n    return value + offset;\n  });\n}\nfunction appendCellData(dest, src, ptOffset, cellOffset) {\n  dest.set(offsetCellArray(src, ptOffset), cellOffset);\n}\n\n// ----------------------------------------------------------------------------\n// vtkAppendPolyData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkAppendPolyData(publicAPI, model) {\n  // Set our classname\n  model.classHierarchy.push('vtkAppendPolyData');\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const numberOfInputs = publicAPI.getNumberOfInputPorts();\n    if (!numberOfInputs) {\n      vtkErrorMacro('No input specified.');\n      return;\n    }\n    if (numberOfInputs === 1) {\n      // pass through filter\n      outData[0] = inData[0];\n      return;\n    }\n\n    // Allocate output\n    const output = vtkPolyData.newInstance();\n    let numPts = 0;\n    let pointType = 0;\n    let ttype = 1;\n    let firstType = 1;\n    let numVerts = 0;\n    let numLines = 0;\n    let numStrips = 0;\n    let numPolys = 0;\n\n    // Field data is propagated to output only if present in all inputs\n    let hasPtNormals = true; // assume present by default\n    let hasPtTCoords = true;\n    let hasPtScalars = true;\n    for (let i = 0; i < numberOfInputs; i++) {\n      const ds = inData[i];\n      if (!ds) {\n        // eslint-disable-next-line\n        continue;\n      }\n      const dsNumPts = ds.getPoints().getNumberOfPoints();\n      numPts += dsNumPts;\n      numVerts += ds.getVerts().getNumberOfValues();\n      numLines += ds.getLines().getNumberOfValues();\n      numStrips += ds.getStrips().getNumberOfValues();\n      numPolys += ds.getPolys().getNumberOfValues();\n      if (dsNumPts) {\n        if (firstType) {\n          firstType = 0;\n          pointType = ds.getPoints().getDataType();\n        }\n        ttype = ds.getPoints().getDataType();\n        pointType = pointType > ttype ? pointType : ttype;\n      }\n      const ptD = ds.getPointData();\n      if (ptD) {\n        hasPtNormals = hasPtNormals && ptD.getNormals() !== null;\n        hasPtTCoords = hasPtTCoords && ptD.getTCoords() !== null;\n        hasPtScalars = hasPtScalars && ptD.getScalars() !== null;\n      } else {\n        hasPtNormals = false;\n        hasPtTCoords = false;\n        hasPtScalars = false;\n      }\n    }\n    if (model.outputPointsPrecision === DesiredOutputPrecision.SINGLE) {\n      pointType = VtkDataTypes.FLOAT;\n    } else if (model.outputPointsPrecision === DesiredOutputPrecision.DOUBLE) {\n      pointType = VtkDataTypes.DOUBLE;\n    }\n    const points = vtkPoints.newInstance({\n      dataType: pointType\n    });\n    points.setNumberOfPoints(numPts);\n    const pointData = points.getData();\n    const vertData = new Uint32Array(numVerts);\n    const lineData = new Uint32Array(numLines);\n    const stripData = new Uint32Array(numStrips);\n    const polyData = new Uint32Array(numPolys);\n    let newPtNormals = null;\n    let newPtTCoords = null;\n    let newPtScalars = null;\n    const lds = inData[numberOfInputs - 1];\n    if (hasPtNormals) {\n      const dsNormals = lds.getPointData().getNormals();\n      newPtNormals = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        numberOfTuples: numPts,\n        size: 3 * numPts,\n        dataType: dsNormals.getDataType(),\n        name: dsNormals.getName()\n      });\n    }\n    if (hasPtTCoords) {\n      const dsTCoords = lds.getPointData().getTCoords();\n      newPtTCoords = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        numberOfTuples: numPts,\n        size: 2 * numPts,\n        dataType: dsTCoords.getDataType(),\n        name: dsTCoords.getName()\n      });\n    }\n    if (hasPtScalars) {\n      const dsScalars = lds.getPointData().getScalars();\n      newPtScalars = vtkDataArray.newInstance({\n        numberOfComponents: dsScalars.getNumberOfComponents(),\n        numberOfTuples: numPts,\n        size: numPts * dsScalars.getNumberOfComponents(),\n        dataType: dsScalars.getDataType(),\n        name: dsScalars.getName()\n      });\n    }\n    numPts = 0;\n    numVerts = 0;\n    numLines = 0;\n    numStrips = 0;\n    numPolys = 0;\n    for (let i = 0; i < numberOfInputs; i++) {\n      const ds = inData[i];\n      pointData.set(ds.getPoints().getData(), numPts * 3);\n      appendCellData(vertData, ds.getVerts().getData(), numPts, numVerts);\n      numVerts += ds.getVerts().getNumberOfValues();\n      appendCellData(lineData, ds.getLines().getData(), numPts, numLines);\n      numLines += ds.getLines().getNumberOfValues();\n      appendCellData(stripData, ds.getStrips().getData(), numPts, numStrips);\n      numStrips += ds.getStrips().getNumberOfValues();\n      appendCellData(polyData, ds.getPolys().getData(), numPts, numPolys);\n      numPolys += ds.getPolys().getNumberOfValues();\n      const dsPD = ds.getPointData();\n      if (hasPtNormals) {\n        const ptNorms = dsPD.getNormals();\n        newPtNormals.getData().set(ptNorms.getData(), numPts * 3);\n      }\n      if (hasPtTCoords) {\n        const ptTCoords = dsPD.getTCoords();\n        newPtTCoords.getData().set(ptTCoords.getData(), numPts * 2);\n      }\n      if (hasPtScalars) {\n        const ptScalars = dsPD.getScalars();\n        newPtScalars.getData().set(ptScalars.getData(), numPts * newPtScalars.getNumberOfComponents());\n      }\n      numPts += ds.getPoints().getNumberOfPoints();\n    }\n    output.setPoints(points);\n    output.getVerts().setData(vertData);\n    output.getLines().setData(lineData);\n    output.getStrips().setData(stripData);\n    output.getPolys().setData(polyData);\n    if (newPtNormals) {\n      output.getPointData().setNormals(newPtNormals);\n    }\n    if (newPtTCoords) {\n      output.getPointData().setTCoords(newPtTCoords);\n    }\n    if (newPtScalars) {\n      output.getPointData().setScalars(newPtScalars);\n    }\n    outData[0] = output;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  outputPointsPrecision: DesiredOutputPrecision.DEFAULT\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.setGet(publicAPI, model, ['outputPointsPrecision']);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n\n  // Object specific methods\n  vtkAppendPolyData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkAppendPolyData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkAppendPolyData$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkAppendPolyData$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}