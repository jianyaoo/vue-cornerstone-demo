{"ast":null,"code":"/**\r\n * Javascript object that handles dates and compute the time.\r\n *\r\n * @export\r\n * @class FullDateInterface\r\n */\nclass FullDateInterface {\n  /**\r\n   * Creates an instance of FullDateInterface.\r\n   * @param {string} date formatted as yyyy-mm-ddTHH:MM:SS.FFFFFFZ\r\n   * @memberof FullDateInterface\r\n   */\n  constructor(date) {\n    this.fullDate = date;\n  }\n  /**\r\n   * returns time since 1 january 1970\r\n   *\r\n   * @returns {number} time in sec\r\n   * @memberof FullDateInterface\r\n   */\n\n  getTimeInSec() {\n    // yyyy-mm-ddTHH:MM:SS.FFFFFFZ\n    const dateString = this.fullDate.substring(0, 10);\n    const timeString = this.fullDate.substring(11, 28); // yyyy-mm-dd\n\n    const yyyy = parseInt(dateString.substring(0, 4), 10);\n    const mm = dateString.length >= 7 ? parseInt(dateString.substring(5, 7), 10) : undefined;\n    const dd = dateString.length >= 10 ? parseInt(dateString.substring(8, 10), 10) : undefined;\n    if (isNaN(yyyy) || mm !== undefined && isNaN(mm) || dd !== undefined && isNaN(dd) || yyyy > 3000 || mm && (mm < 1 || mm > 12) || dd && (dd < 1 || dd > 31)) {\n      throw new Error(`invalid date '${dateString}'`);\n    }\n    const dateJS = new Date(`${dateString}T00:00:00.000000Z`); // HHMMSS.FFFFFF\n\n    const HH = parseInt(timeString.substring(0, 2), 10);\n    const MM = timeString.length >= 5 ? parseInt(timeString.substring(3, 5), 10) : undefined;\n    const SS = timeString.length >= 8 ? parseInt(timeString.substring(6, 8), 10) : undefined;\n    const fractionalStr = timeString.substring(9, 15);\n    const FFFFFF = fractionalStr ? parseInt(fractionalStr, 10) * Math.pow(10, -fractionalStr.length) : undefined;\n    if (isNaN(HH) || MM !== undefined && isNaN(MM) || SS !== undefined && isNaN(SS) || FFFFFF !== undefined && isNaN(FFFFFF) || HH < 0 || HH > 23 || MM && (MM < 0 || MM > 59) || SS && (SS < 0 || SS > 59) || FFFFFF && (FFFFFF < 0 || FFFFFF > 999999)) {\n      throw new Error(`invalid time '${timeString}'`);\n    }\n    let timeInSec = dateJS.getTime() / 1000;\n    timeInSec += HH * 3600;\n    if (MM !== undefined) {\n      timeInSec += MM * 60;\n    }\n    if (SS !== undefined) {\n      timeInSec += SS;\n    }\n    if (FFFFFF !== undefined) {\n      timeInSec += FFFFFF;\n    }\n    return timeInSec;\n  }\n  /**\r\n   * returns time since 1 january 1970\r\n   *\r\n   * @returns {number} time in microsec\r\n   * @memberof FullDateInterface\r\n   */\n\n  getTimeInMicroSec() {\n    const timeInMicroSec = this.getTimeInSec() * 1e6;\n    return timeInMicroSec;\n  }\n}\n/**\r\n * Combines two javascript objects containing the date and time information\r\n *\r\n * @export\r\n * @param {DateInterface} date\r\n * @param {TimeInterface} time\r\n * @returns {FullDateInterface}\r\n */\n\nfunction combineDateTime(date, time) {\n  const hours = `${time.hours || '00'}`.padStart(2, '0');\n  const minutes = `${time.minutes || '00'}`.padStart(2, '0');\n  const seconds = `${time.seconds || '00'}`.padStart(2, '0');\n  const month = `${date.month}`.padStart(2, '0');\n  const day = `${date.day}`.padStart(2, '0');\n  const fractionalSeconds = `${time.fractionalSeconds || '000000'}`.padEnd(6, '0');\n  const dateString = `${date.year}-${month}-${day}`;\n  const timeString = `T${hours}:${minutes}:${seconds}.${fractionalSeconds}Z`;\n  const fullDateString = `${dateString}${timeString}`;\n  return new FullDateInterface(fullDateString);\n}\n\n/**\r\n * Check the number of days for a picked month and year\r\n * algorithm based on http://stackoverflow.com/questions/1433030/validate-number-of-days-in-a-given-month\r\n *\r\n * @param {number} m\r\n * @param {number} y\r\n * @returns {number} number of days\r\n */\nfunction daysInMonth(m, y) {\n  // m is 0 indexed: 0-11\n  switch (m) {\n    case 2:\n      return y % 4 === 0 && y % 100 || y % 400 === 0 ? 29 : 28;\n    case 9:\n    case 4:\n    case 6:\n    case 11:\n      return 30;\n    default:\n      return 31;\n  }\n}\n/**\r\n * Check if the date is valid\r\n *\r\n * @param {number} d\r\n * @param {number} m\r\n * @param {number} y\r\n * @returns {boolean} boolean result\r\n */\n\nfunction isValidDate(d, m, y) {\n  // make year is a number\n  if (isNaN(y)) {\n    return false;\n  }\n  return m > 0 && m <= 12 && d > 0 && d <= daysInMonth(m, y);\n}\n/**\r\n * Parses a DA formatted string into a Javascript object\r\n * @param {string} date a string in the DA VR format\r\n * @param {boolean} [validate] - true if an exception should be thrown if the date is invalid\r\n * @returns {DateInterface} Javascript object with properties year, month and day or undefined if not present or not 8 bytes long\r\n */\n\nfunction parseDA(date) {\n  if (date === undefined || date === null || date.length !== 8 || typeof date !== 'string') {\n    throw new Error(`invalid DA '${date}'`);\n  }\n  const yyyy = parseInt(date.substring(0, 4), 10);\n  const mm = parseInt(date.substring(4, 6), 10);\n  const dd = parseInt(date.substring(6, 8), 10);\n  if (isValidDate(dd, mm, yyyy) !== true) {\n    throw new Error(`invalid DA '${date}'`);\n  }\n  return {\n    year: yyyy,\n    month: mm,\n    day: dd\n  };\n}\n\n/**\r\n * Parses a TM formatted string into a javascript object with properties for hours, minutes, seconds and fractionalSeconds\r\n * @param {string} time - a string in the TM VR format\r\n * @returns {string} javascript object with properties for hours, minutes, seconds and fractionalSeconds or undefined if no element or data.  Missing fields are set to undefined\r\n */\nfunction parseTM(time) {\n  if (time === null || time === undefined || time.length < 2 || typeof time !== 'string') {\n    // must at least have HH\n    throw new Error(`invalid TM '${time}'`);\n  } // 0123456789\n  // HHMMSS.FFFFFF\n\n  const hh = parseInt(time.substring(0, 2), 10);\n  const mm = time.length >= 4 ? parseInt(time.substring(2, 4), 10) : undefined;\n  const ss = time.length >= 6 ? parseInt(time.substring(4, 6), 10) : undefined;\n  const fractionalStr = time.length >= 8 ? time.substring(7, 13) : undefined;\n  const ffffff = fractionalStr ? parseInt(fractionalStr, 10) * Math.pow(10, 6 - fractionalStr.length) : undefined;\n  if (isNaN(hh) || mm !== undefined && isNaN(mm) || ss !== undefined && isNaN(ss) || ffffff !== undefined && isNaN(ffffff) || hh < 0 || hh > 23 || mm && (mm < 0 || mm > 59) || ss && (ss < 0 || ss > 59) || ffffff && (ffffff < 0 || ffffff > 999999)) {\n    throw new Error(`invalid TM '${time}'`);\n  }\n  return {\n    hours: hh,\n    minutes: mm,\n    seconds: ss,\n    fractionalSeconds: ffffff\n  };\n}\n\n/**\r\n * Utility to create a FullDateInterface object given a string formatted as yyyy-mm-ddTHH:MM:SS.FFFFFFZ\r\n *\r\n * @export\r\n * @param {string} dateTime\r\n * @returns {FullDateInterface}\r\n */\n\nfunction dateTimeToFullDateInterface(dateTime) {\n  if (dateTime === undefined || dateTime === null) {\n    throw new Error('dateTimeToFullDateInterface : dateTime not defined.');\n  }\n  const date = parseDA(dateTime.substring(0, 8));\n  const time = parseTM(dateTime.substring(8));\n  return combineDateTime(date, time);\n}\n\n/**\r\n * Calculate the scan times\r\n *\r\n * @export\r\n * @param {InstanceMetadataForScanTimes[]} instances\r\n * @returns {FullDateInterface[]}\r\n */\n\nfunction calculateScanTimes(instances) {\n  const {\n    SeriesDate,\n    SeriesTime,\n    GEPrivatePostInjectionDateTime\n  } = instances[0];\n  const results = new Array(instances.length);\n  const seriesDate = parseDA(SeriesDate);\n  const seriesTime = parseTM(SeriesTime);\n  const seriesDateTime = combineDateTime(seriesDate, seriesTime);\n  let earliestAcquisitionDateTime = new FullDateInterface(`3000-01-01T00:00:00.000000Z`);\n  let timeError = earliestAcquisitionDateTime.getTimeInSec();\n  instances.forEach(instance => {\n    const {\n      AcquisitionDate,\n      AcquisitionTime\n    } = instance;\n    const acquisitionDate = parseDA(AcquisitionDate);\n    const acquisitionTime = parseTM(AcquisitionTime);\n    const acquisitionDateTime = combineDateTime(acquisitionDate, acquisitionTime);\n    if (earliestAcquisitionDateTime.getTimeInSec() >= timeError) {\n      earliestAcquisitionDateTime = acquisitionDateTime;\n    } else {\n      earliestAcquisitionDateTime = acquisitionDateTime.getTimeInSec() < earliestAcquisitionDateTime.getTimeInSec() ? acquisitionDateTime : earliestAcquisitionDateTime;\n    }\n  });\n  if (earliestAcquisitionDateTime.getTimeInSec() >= timeError) {\n    throw new Error('Earliest acquisition time or date could not be parsed.');\n  }\n  if (seriesDateTime.getTimeInSec() <= earliestAcquisitionDateTime.getTimeInSec()) {\n    return results.fill(seriesDateTime);\n  } else {\n    if (GEPrivatePostInjectionDateTime) {\n      // GE Private scan\n      return results.fill(dateTimeToFullDateInterface(GEPrivatePostInjectionDateTime));\n    } else {\n      /*const hasValidFrameTimes = instances.every(instance => {\r\n        return (\r\n          instance.FrameReferenceTime &&\r\n          instance.FrameReferenceTime > 0 &&\r\n          instance.ActualFrameDuration &&\r\n          instance.ActualFrameDuration > 0\r\n        );\r\n      });*/\n      // TODO: Temporarily commented out the checks and logic below to\n      // investigate the BQML_AC_DT_lessThan_S_DT_SIEMENS-instances case\n      //if (!hasValidFrameTimes) {\n      return results.fill(earliestAcquisitionDateTime); //}\n\n      /* Siemens PETsyngo\t3.x\tmulti-injection logic\r\n      - backcompute\tfrom\tcenter\t(average\tcount\trate\t)\tof\ttime\twindow\tfor\tbed\tposition\t(frame)\tin\tseries (reliable\tin\tall\tcases)\r\n      - Acquisition\tDate\t(0x0008,0x0022)\tand\tTime\t(0x0008,0x0032) are\tthe\tstart\tof\tthe\tbed\tposition\t(frame)\r\n      - Frame\tReference\tTime\t(0x0054,0x1300) is\tthe\toffset\t(ms)\tfrom\tthe\tscan\tDate\tand\tTime we\twant\tto\tthe\taverage\tcount\trate\ttime\r\n      */\n\n      /*return instances.map(instance => {\r\n        const {\r\n          FrameReferenceTime,\r\n          ActualFrameDuration,\r\n          RadionuclideHalfLife,\r\n          AcquisitionDate,\r\n          AcquisitionTime,\r\n        } = instance;\r\n        // Some of these checks are only here because the compiler is complaining\r\n        // We could potentially use the ! operator instead\r\n        if (!FrameReferenceTime || FrameReferenceTime <= 0) {\r\n          throw new Error(\r\n            `FrameReferenceTime is invalid: ${FrameReferenceTime}`\r\n          );\r\n        }\r\n               if (!ActualFrameDuration || ActualFrameDuration <= 0) {\r\n          throw new Error(\r\n            `ActualFrameDuration is invalid: ${ActualFrameDuration}`\r\n          );\r\n        }\r\n               if (!RadionuclideHalfLife) {\r\n          throw new Error('RadionuclideHalfLife is required');\r\n        }\r\n               if (!AcquisitionDate) {\r\n          throw new Error('AcquisitionDate is required');\r\n        }\r\n               if (!AcquisitionTime) {\r\n          throw new Error('AcquisitionTime is required');\r\n        }\r\n               const acquisitionDate: DateInterface = parseDA(AcquisitionDate);\r\n        const acquisitionTime: TimeInterface = parseTM(AcquisitionTime);\r\n        const acquisitionDateTime: FullDateInterface = combineDateTime(\r\n          acquisitionDate,\r\n          acquisitionTime\r\n        );\r\n               const frameDurationInSec = ActualFrameDuration / 1000;\r\n        const decayConstant = Math.log(2) / RadionuclideHalfLife;\r\n        const decayDuringFrame = decayConstant * frameDurationInSec;\r\n        // TODO: double check this is correctly copied from QIBA pseudocode\r\n        const averageCountRateTimeWithinFrameInSec =\r\n          (1 / decayConstant) *\r\n          Math.log(decayDuringFrame / (1 - Math.exp(-decayConstant)));\r\n        const scanDateTimeAsNumber =\r\n          Number(acquisitionDateTime) -\r\n          FrameReferenceTime / 1000 +\r\n          averageCountRateTimeWithinFrameInSec;\r\n               const scanDate = new Date(scanDateTimeAsNumber);\r\n        console.log('SIEMENS PATH');\r\n        console.log(new Date(scanDateTimeAsNumber));\r\n        return scanDate;\r\n      });*/\n    }\n  }\n}\nfunction calculateSUVlbmScalingFactor(inputs) {\n  const {\n    PatientSex,\n    PatientWeight,\n    PatientSize\n  } = inputs;\n  let LBM;\n  const weightSizeFactor = Math.pow(PatientWeight / (PatientSize * 100), 2); // reference: https://www.medicalconnections.co.uk/kb/calculating-suv-from-pet-images/\n\n  if (PatientSex === 'F') {\n    LBM = 1.07 * PatientWeight - 148 * weightSizeFactor;\n  } else if (PatientSex === 'M') {\n    LBM = 1.1 * PatientWeight - 120 * weightSizeFactor;\n  } else {\n    throw new Error(`PatientSex is an invalid value: ${PatientSex}`);\n  }\n  return LBM * 1000; // convert in gr\n}\n/**\r\n * From https://link.springer.com/article/10.1007/s00259-014-2961-x\r\n * and https://link.springer.com/article/10.2165/00003088-200544100-00004\r\n * and\r\n * @param inputs\r\n * @returns\r\n */\n\nfunction calculateSUVlbmJanmahasatianScalingFactor(inputs) {\n  const {\n    PatientSex,\n    PatientWeight,\n    PatientSize\n  } = inputs;\n  let LBM;\n  const bodyMassIndex = PatientWeight / Math.pow(PatientSize, 2);\n  if (PatientSex === 'F') {\n    LBM = 9270 * PatientWeight / (8780 + 244 * bodyMassIndex);\n  } else if (PatientSex === 'M') {\n    LBM = 9270 * PatientWeight / (6680 + 216 * bodyMassIndex);\n  } else {\n    throw new Error(`PatientSex is an invalid value: ${PatientSex}`);\n  }\n  return LBM * 1000; // convert in gr\n}\nfunction calculateSUVbsaScalingFactor(inputs) {\n  const {\n    PatientWeight,\n    PatientSize\n  } = inputs;\n  let BSA = Math.pow(PatientWeight, 0.425) * Math.pow(PatientSize * 100, 0.725) * 71.84;\n  return BSA;\n}\n\n/**\r\n * Calculate start time\r\n *\r\n * @export\r\n * @param {{\r\n *   RadiopharmaceuticalStartDateTime?: string;\r\n *   RadiopharmaceuticalStartTime?: string;\r\n *   SeriesDate?: string;\r\n * }} input\r\n * @returns {FullDateInterface}\r\n */\n\nfunction calculateStartTime(input) {\n  const {\n    RadiopharmaceuticalStartDateTime,\n    RadiopharmaceuticalStartTime,\n    SeriesDate\n  } = input;\n  let time;\n  let date;\n  if (RadiopharmaceuticalStartDateTime) {\n    return dateTimeToFullDateInterface(RadiopharmaceuticalStartDateTime);\n  } else if (RadiopharmaceuticalStartTime && SeriesDate) {\n    // start Date\tis not explicit - assume\tsame as\tSeries Date;\n    // but consider\tspanning midnight\n    // TODO: do we need some logic to check if the scan went over midnight?\n    time = parseTM(RadiopharmaceuticalStartTime);\n    date = parseDA(SeriesDate);\n    return combineDateTime(date, time);\n  }\n  throw new Error(`Invalid input: ${input}`);\n}\n\n/**\r\n * The injected dose used to calculate SUV is corrected for the\r\n * decay that occurs between the time of injection and the start of the scan\r\n *\r\n * @param {InstanceMetadata[]} instances\r\n * @returns {number[]}\r\n */\n\nfunction calculateDecayCorrection(instances) {\n  const {\n    RadionuclideTotalDose,\n    RadionuclideHalfLife,\n    RadiopharmaceuticalStartDateTime,\n    RadiopharmaceuticalStartTime,\n    SeriesDate\n  } = instances[0];\n  if (RadionuclideTotalDose === undefined || RadionuclideTotalDose === null) {\n    throw new Error('calculateDecayCorrection : RadionuclideTotalDose value not found.');\n  }\n  if (RadionuclideHalfLife === undefined || RadionuclideHalfLife === null) {\n    throw new Error('calculateDecayCorrection : RadionuclideHalfLife value not found.');\n  }\n  const scanTimes = calculateScanTimes(instances);\n  const startTime = calculateStartTime({\n    RadiopharmaceuticalStartDateTime,\n    RadiopharmaceuticalStartTime,\n    SeriesDate\n  });\n  return instances.map((_, index) => {\n    const scanTime = scanTimes[index];\n    const decayTimeInSec = scanTime.getTimeInSec() - startTime.getTimeInSec();\n    if (decayTimeInSec < 0) {\n      throw new Error('Decay time cannot be less than zero');\n    }\n    const decayedDose = RadionuclideTotalDose * Math.pow(2, -decayTimeInSec / RadionuclideHalfLife);\n    return 1 / decayedDose;\n  });\n}\n/**\r\n *\r\n * @param a Simple value or array of simple values\r\n * @param b Simple value or array of simple values\r\n * @returns boolean true if the values are equal.\r\n */\n\nconst deepEquals = (a, b) => {\n  return a === b || Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]);\n};\n/**\r\n * Calculate the SUV factor\r\n *\r\n * Note: Rescale Slope / Intercept must still be applied. These must be applied\r\n *       on a per-Frame basis, since some scanners may have different values per Frame.\r\n *\r\n * @export\r\n * @param {InstanceMetadata[]} instances\r\n * @returns {ScalingFactorResult[]}\r\n */\n\nfunction calculateSUVScalingFactors(instances) {\n  const {\n    CorrectedImage,\n    Units,\n    PhilipsPETPrivateGroup,\n    PatientWeight,\n    PatientSex,\n    PatientSize\n  } = instances[0];\n  if (!CorrectedImage.includes('ATTN') || !CorrectedImage.includes('DECY')) {\n    throw new Error(`CorrectedImage must contain \"ATTN\" and \"DECY\": ${CorrectedImage}`);\n  } // Sanity check that every instance provided has identical\n  // values for series-level metadata. If not, the provided\n  // data is invalid.\n\n  const isSingleSeries = instances.every(instance => {\n    return instance.Units === Units && deepEquals(instance.CorrectedImage, CorrectedImage) && instance.PatientWeight === PatientWeight && instance.PatientSex === PatientSex && instance.PatientSize === PatientSize && instance.RadionuclideHalfLife === instances[0].RadionuclideHalfLife && instance.RadionuclideTotalDose === instances[0].RadionuclideTotalDose && instance.DecayCorrection === instances[0].DecayCorrection && instance.SeriesDate === instances[0].SeriesDate && instance.SeriesTime === instances[0].SeriesTime;\n  });\n  if (!isSingleSeries) {\n    throw new Error('The set of instances does not appear to come from one Series. Every instance must have identical values for series-level metadata properties');\n  } // Treat null, undefined and zero as a missing PatientWeight.\n\n  if (!PatientWeight) {\n    throw new Error('PatientWeight value is missing. It is not possible to calculate the SUV factors');\n  }\n  let decayCorrectionArray = new Array(instances.length);\n  decayCorrectionArray = calculateDecayCorrection(instances);\n  let results = new Array(instances.length);\n  const weightInGrams = PatientWeight * 1000;\n  if (Units === 'BQML') {\n    results = decayCorrectionArray.map(function (value) {\n      return value * weightInGrams;\n    });\n  } else if (Units === 'CNTS') {\n    const hasValidSUVScaleFactor = instances.every(instance => {\n      var _instance$PhilipsPETP, _instance$PhilipsPETP2, _instance$PhilipsPETP3;\n      return instance.PhilipsPETPrivateGroup && ((_instance$PhilipsPETP = instance.PhilipsPETPrivateGroup) === null || _instance$PhilipsPETP === void 0 ? void 0 : _instance$PhilipsPETP.SUVScaleFactor) !== null && ((_instance$PhilipsPETP2 = instance.PhilipsPETPrivateGroup) === null || _instance$PhilipsPETP2 === void 0 ? void 0 : _instance$PhilipsPETP2.SUVScaleFactor) !== undefined && ((_instance$PhilipsPETP3 = instance.PhilipsPETPrivateGroup) === null || _instance$PhilipsPETP3 === void 0 ? void 0 : _instance$PhilipsPETP3.SUVScaleFactor) !== 0;\n    });\n    const hasValidActivityConcentrationScaleFactor = instances.every(instance => {\n      var _instance$PhilipsPETP4, _instance$PhilipsPETP5, _instance$PhilipsPETP6;\n      return instance.PhilipsPETPrivateGroup && !((_instance$PhilipsPETP4 = instance.PhilipsPETPrivateGroup) !== null && _instance$PhilipsPETP4 !== void 0 && _instance$PhilipsPETP4.SUVScaleFactor) && ((_instance$PhilipsPETP5 = instance.PhilipsPETPrivateGroup) === null || _instance$PhilipsPETP5 === void 0 ? void 0 : _instance$PhilipsPETP5.ActivityConcentrationScaleFactor) !== undefined && ((_instance$PhilipsPETP6 = instance.PhilipsPETPrivateGroup) === null || _instance$PhilipsPETP6 === void 0 ? void 0 : _instance$PhilipsPETP6.ActivityConcentrationScaleFactor) !== 0;\n    }); //console.log(`hasValidSUVScaleFactor: ${hasValidSUVScaleFactor}`);\n    //console.log(`hasValidActivityConcentrationScaleFactor: ${hasValidActivityConcentrationScaleFactor}`);\n\n    if (hasValidSUVScaleFactor) {\n      results = instances.map(\n      // Added ! to tell Typescript that this can't be undefined, since we are testing it\n      // in the .every loop above.\n      instance => instance.PhilipsPETPrivateGroup.SUVScaleFactor);\n    } else if (hasValidActivityConcentrationScaleFactor) {\n      // if (0x7053,0x1000) not present, but (0x7053,0x1009) is present, then (0x7053,0x1009) * Rescale Slope,\n      // scales pixels to Bq/ml, and proceed as if Units are BQML\n      results = instances.map((instance, index) => {\n        // Added ! to tell Typescript that this can't be undefined, since we are testing it\n        // in the .every loop above.\n        return instance.PhilipsPETPrivateGroup.ActivityConcentrationScaleFactor * decayCorrectionArray[index] * weightInGrams;\n      });\n    } else {\n      throw new Error(`Units are in CNTS, but PhilipsPETPrivateGroup has invalid values: ${JSON.stringify(PhilipsPETPrivateGroup)}`);\n    }\n  } else if (Units === 'GML') {\n    // assumes that GML indicates SUVbw instead of SUVlbm\n    results.fill(1);\n  } else {\n    throw new Error(`Units has an invalid value: ${Units}`);\n  } // get BSA\n\n  let suvbsaFactor;\n  if (PatientSize === null || PatientSize === undefined) {\n    console.warn('PatientSize value is missing. It is not possible to calculate the SUV bsa factors');\n  } else {\n    const sulInputs = {\n      PatientWeight,\n      PatientSize\n    };\n    suvbsaFactor = calculateSUVbsaScalingFactor(sulInputs);\n  } // get LBM\n\n  let suvlbmFactor;\n  let suvlbmJenmaFactor;\n  if (PatientSize === null || PatientSize === undefined) {\n    console.warn('PatientSize value is missing. It is not possible to calculate the SUV lbm factors');\n  } else if (PatientSex === null || PatientSex === undefined) {\n    console.warn('PatientSex value is missing. It is not possible to calculate the SUV lbm factors');\n  } else {\n    const suvlbmInputs = {\n      PatientWeight,\n      PatientSex,\n      PatientSize\n    };\n    suvlbmFactor = calculateSUVlbmScalingFactor(suvlbmInputs);\n    suvlbmJenmaFactor = calculateSUVlbmJanmahasatianScalingFactor(suvlbmInputs);\n  }\n  return results.map(function (result, index) {\n    const factors = {\n      suvbw: result\n    };\n    if (suvbsaFactor) {\n      // multiply for BSA\n      factors.suvbsa = decayCorrectionArray[index] * suvbsaFactor;\n    }\n    if (suvlbmFactor) {\n      // multiply for LBM\n      factors.suvlbm = decayCorrectionArray[index] * suvlbmFactor;\n    }\n    if (suvlbmJenmaFactor) {\n      factors.suvlbmJanma = decayCorrectionArray[index] * suvlbmJenmaFactor;\n    } // factor formulaes taken from:\n    // https://www.medicalconnections.co.uk/kb/calculating-suv-from-pet-images/\n\n    return factors;\n  });\n}\nexport { calculateSUVScalingFactors };","map":{"version":3,"names":["FullDateInterface","constructor","date","fullDate","getTimeInSec","dateString","substring","timeString","yyyy","parseInt","mm","length","undefined","dd","isNaN","Error","dateJS","Date","HH","MM","SS","fractionalStr","FFFFFF","Math","pow","timeInSec","getTime","getTimeInMicroSec","timeInMicroSec","combineDateTime","time","hours","padStart","minutes","seconds","month","day","fractionalSeconds","padEnd","year","fullDateString","daysInMonth","m","y","isValidDate","d","parseDA","parseTM","hh","ss","ffffff","dateTimeToFullDateInterface","dateTime","calculateScanTimes","instances","SeriesDate","SeriesTime","GEPrivatePostInjectionDateTime","results","Array","seriesDate","seriesTime","seriesDateTime","earliestAcquisitionDateTime","timeError","forEach","instance","AcquisitionDate","AcquisitionTime","acquisitionDate","acquisitionTime","acquisitionDateTime","fill","calculateSUVlbmScalingFactor","inputs","PatientSex","PatientWeight","PatientSize","LBM","weightSizeFactor","calculateSUVlbmJanmahasatianScalingFactor","bodyMassIndex","calculateSUVbsaScalingFactor","BSA","calculateStartTime","input","RadiopharmaceuticalStartDateTime","RadiopharmaceuticalStartTime","calculateDecayCorrection","RadionuclideTotalDose","RadionuclideHalfLife","scanTimes","startTime","map","_","index","scanTime","decayTimeInSec","decayedDose","deepEquals","a","b","isArray","every","val","calculateSUVScalingFactors","CorrectedImage","Units","PhilipsPETPrivateGroup","includes","isSingleSeries","DecayCorrection","decayCorrectionArray","weightInGrams","value","hasValidSUVScaleFactor","_instance$PhilipsPETP","SUVScaleFactor","_instance$PhilipsPETP2","_instance$PhilipsPETP3","hasValidActivityConcentrationScaleFactor","_instance$PhilipsPETP4","_instance$PhilipsPETP5","ActivityConcentrationScaleFactor","_instance$PhilipsPETP6","JSON","stringify","suvbsaFactor","console","warn","sulInputs","suvlbmFactor","suvlbmJenmaFactor","suvlbmInputs","result","factors","suvbw","suvbsa","suvlbm","suvlbmJanma"],"sources":["../src/combineDateTime.ts","../src/parseDA.ts","../src/parseTM.ts","../src/dateTimeToFullDateInterface.ts","../src/calculateScanTimes.ts","../src/calculateSUVlbmScalingFactor.ts","../src/calculateSUVbsaScalingFactor.ts","../src/calculateStartTime.ts","../src/calculateSUVScalingFactors.ts"],"sourcesContent":["import { DateInterface } from './parseDA';\nimport { TimeInterface } from './parseTM';\n\n/**\n * Javascript object that handles dates and compute the time.\n *\n * @export\n * @class FullDateInterface\n */\nexport class FullDateInterface {\n  fullDate: string;\n\n  /**\n   * Creates an instance of FullDateInterface.\n   * @param {string} date formatted as yyyy-mm-ddTHH:MM:SS.FFFFFFZ\n   * @memberof FullDateInterface\n   */\n  constructor(date: string) {\n    this.fullDate = date;\n  }\n\n  /**\n   * returns time since 1 january 1970\n   *\n   * @returns {number} time in sec\n   * @memberof FullDateInterface\n   */\n  getTimeInSec(): number {\n    // yyyy-mm-ddTHH:MM:SS.FFFFFFZ\n    const dateString = this.fullDate.substring(0, 10);\n    const timeString = this.fullDate.substring(11, 28);\n\n    // yyyy-mm-dd\n    const yyyy = parseInt(dateString.substring(0, 4), 10);\n    const mm =\n      dateString.length >= 7\n        ? parseInt(dateString.substring(5, 7), 10)\n        : undefined;\n    const dd =\n      dateString.length >= 10\n        ? parseInt(dateString.substring(8, 10), 10)\n        : undefined;\n\n    if (\n      isNaN(yyyy) ||\n      (mm !== undefined && isNaN(mm)) ||\n      (dd !== undefined && isNaN(dd)) ||\n      yyyy > 3000 ||\n      (mm && (mm < 1 || mm > 12)) ||\n      (dd && (dd < 1 || dd > 31))\n    ) {\n      throw new Error(`invalid date '${dateString}'`);\n    }\n\n    const dateJS = new Date(`${dateString}T00:00:00.000000Z`);\n\n    // HHMMSS.FFFFFF\n    const HH = parseInt(timeString.substring(0, 2), 10);\n    const MM =\n      timeString.length >= 5\n        ? parseInt(timeString.substring(3, 5), 10)\n        : undefined;\n    const SS =\n      timeString.length >= 8\n        ? parseInt(timeString.substring(6, 8), 10)\n        : undefined;\n    const fractionalStr = timeString.substring(9, 15);\n    const FFFFFF = fractionalStr\n      ? parseInt(fractionalStr, 10) * Math.pow(10, -fractionalStr.length)\n      : undefined;\n\n    if (\n      isNaN(HH) ||\n      (MM !== undefined && isNaN(MM)) ||\n      (SS !== undefined && isNaN(SS)) ||\n      (FFFFFF !== undefined && isNaN(FFFFFF)) ||\n      HH < 0 ||\n      HH > 23 ||\n      (MM && (MM < 0 || MM > 59)) ||\n      (SS && (SS < 0 || SS > 59)) ||\n      (FFFFFF && (FFFFFF < 0 || FFFFFF > 999999))\n    ) {\n      throw new Error(`invalid time '${timeString}'`);\n    }\n\n    let timeInSec = dateJS.getTime() / 1000;\n\n    timeInSec += HH * 3600;\n    if (MM !== undefined) {\n      timeInSec += MM * 60;\n    }\n    if (SS !== undefined) {\n      timeInSec += SS;\n    }\n    if (FFFFFF !== undefined) {\n      timeInSec += FFFFFF;\n    }\n\n    return timeInSec;\n  }\n\n  /**\n   * returns time since 1 january 1970\n   *\n   * @returns {number} time in microsec\n   * @memberof FullDateInterface\n   */\n  getTimeInMicroSec(): number {\n    const timeInMicroSec = this.getTimeInSec() * 1e6;\n    return timeInMicroSec;\n  }\n}\n\nexport interface FullDateInterface {\n  date: string;\n}\n\n/**\n * Combines two javascript objects containing the date and time information\n *\n * @export\n * @param {DateInterface} date\n * @param {TimeInterface} time\n * @returns {FullDateInterface}\n */\nexport default function combineDateTime(\n  date: DateInterface,\n  time: TimeInterface\n): FullDateInterface {\n  const hours = `${time.hours || '00'}`.padStart(2, '0');\n  const minutes = `${time.minutes || '00'}`.padStart(2, '0');\n  const seconds = `${time.seconds || '00'}`.padStart(2, '0');\n  const month = `${date.month}`.padStart(2, '0');\n  const day = `${date.day}`.padStart(2, '0');\n  const fractionalSeconds = `${time.fractionalSeconds || '000000'}`.padEnd(\n    6,\n    '0'\n  );\n  const dateString = `${date.year}-${month}-${day}`;\n  const timeString = `T${hours}:${minutes}:${seconds}.${fractionalSeconds}Z`;\n  const fullDateString = `${dateString}${timeString}`;\n\n  return new FullDateInterface(fullDateString);\n}\n\nexport { combineDateTime };\n","/**\n * Check the number of days for a picked month and year\n * algorithm based on http://stackoverflow.com/questions/1433030/validate-number-of-days-in-a-given-month\n *\n * @param {number} m\n * @param {number} y\n * @returns {number} number of days\n */\nfunction daysInMonth(m: number, y: number): number {\n  // m is 0 indexed: 0-11\n  switch (m) {\n    case 2:\n      return (y % 4 === 0 && y % 100) || y % 400 === 0 ? 29 : 28;\n    case 9:\n    case 4:\n    case 6:\n    case 11:\n      return 30;\n    default:\n      return 31;\n  }\n}\n\n/**\n * Check if the date is valid\n *\n * @param {number} d\n * @param {number} m\n * @param {number} y\n * @returns {boolean} boolean result\n */\nfunction isValidDate(d: number, m: number, y: number): boolean {\n  // make year is a number\n  if (isNaN(y)) {\n    return false;\n  }\n\n  return m > 0 && m <= 12 && d > 0 && d <= daysInMonth(m, y);\n}\n\n/**\n * Javascript object with properties year, month and day\n *\n * @export\n * @interface DateInterface\n */\nexport interface DateInterface {\n  year: number;\n  month: number;\n  day: number;\n}\n\n/**\n * Parses a DA formatted string into a Javascript object\n * @param {string} date a string in the DA VR format\n * @param {boolean} [validate] - true if an exception should be thrown if the date is invalid\n * @returns {DateInterface} Javascript object with properties year, month and day or undefined if not present or not 8 bytes long\n */\nexport default function parseDA(date: string): DateInterface {\n  if (\n    date === undefined ||\n    date === null ||\n    date.length !== 8 ||\n    typeof date !== 'string'\n  ) {\n    throw new Error(`invalid DA '${date}'`);\n  }\n\n  const yyyy = parseInt(date.substring(0, 4), 10);\n  const mm = parseInt(date.substring(4, 6), 10);\n  const dd = parseInt(date.substring(6, 8), 10);\n\n  if (isValidDate(dd, mm, yyyy) !== true) {\n    throw new Error(`invalid DA '${date}'`);\n  }\n\n  return {\n    year: yyyy,\n    month: mm,\n    day: dd,\n  };\n}\n\nexport { parseDA };\n","/**\n * Javascript object with properties for hours, minutes, seconds and fractionalSeconds\n *\n * @export\n * @interface TimeInterface\n */\nexport interface TimeInterface {\n  hours?: number;\n  minutes?: number;\n  seconds?: number;\n  fractionalSeconds?: number;\n}\n\n/**\n * Parses a TM formatted string into a javascript object with properties for hours, minutes, seconds and fractionalSeconds\n * @param {string} time - a string in the TM VR format\n * @returns {string} javascript object with properties for hours, minutes, seconds and fractionalSeconds or undefined if no element or data.  Missing fields are set to undefined\n */\nexport default function parseTM(time: string): TimeInterface {\n  if (\n    time === null ||\n    time === undefined ||\n    time.length < 2 ||\n    typeof time !== 'string'\n  ) {\n    // must at least have HH\n    throw new Error(`invalid TM '${time}'`);\n  }\n\n  // 0123456789\n  // HHMMSS.FFFFFF\n  const hh = parseInt(time.substring(0, 2), 10);\n  const mm = time.length >= 4 ? parseInt(time.substring(2, 4), 10) : undefined;\n  const ss = time.length >= 6 ? parseInt(time.substring(4, 6), 10) : undefined;\n  const fractionalStr = time.length >= 8 ? time.substring(7, 13) : undefined;\n  const ffffff = fractionalStr\n    ? parseInt(fractionalStr, 10) * Math.pow(10, 6 - fractionalStr.length)\n    : undefined;\n\n  if (\n    isNaN(hh) ||\n    (mm !== undefined && isNaN(mm)) ||\n    (ss !== undefined && isNaN(ss)) ||\n    (ffffff !== undefined && isNaN(ffffff)) ||\n    hh < 0 ||\n    hh > 23 ||\n    (mm && (mm < 0 || mm > 59)) ||\n    (ss && (ss < 0 || ss > 59)) ||\n    (ffffff && (ffffff < 0 || ffffff > 999999))\n  ) {\n    throw new Error(`invalid TM '${time}'`);\n  }\n\n  return {\n    hours: hh,\n    minutes: mm,\n    seconds: ss,\n    fractionalSeconds: ffffff,\n  };\n}\n\nexport { parseTM };\n","import combineDateTime, { FullDateInterface } from './combineDateTime';\nimport parseDA from './parseDA';\nimport parseTM from './parseTM';\n\n/**\n * Utility to create a FullDateInterface object given a string formatted as yyyy-mm-ddTHH:MM:SS.FFFFFFZ\n *\n * @export\n * @param {string} dateTime\n * @returns {FullDateInterface}\n */\nexport default function dateTimeToFullDateInterface(\n  dateTime: string\n): FullDateInterface {\n  if (dateTime === undefined || dateTime === null) {\n    throw new Error('dateTimeToFullDateInterface : dateTime not defined.');\n  }\n\n  const date = parseDA(dateTime.substring(0, 8));\n  const time = parseTM(dateTime.substring(8));\n  return combineDateTime(date, time);\n}\n\nexport { dateTimeToFullDateInterface };\n","import combineDateTime, { FullDateInterface } from './combineDateTime';\nimport parseDA, { DateInterface } from './parseDA';\nimport parseTM, { TimeInterface } from './parseTM';\nimport dateTimeToFullDateInterface from './dateTimeToFullDateInterface';\n\n/**\n * Javascript object with scan properties\n *\n * @interface InstanceMetadataForScanTimes\n */\ninterface InstanceMetadataForScanTimes {\n  SeriesDate: string;\n  SeriesTime: string;\n  AcquisitionDate: string;\n  AcquisitionTime: string;\n\n  GEPrivatePostInjectionDateTime?: string;\n\n  // Only used in Siemens case\n  RadionuclideHalfLife?: number; // \tRadionuclideHalfLife(0x0018,0x1075)\tin\tRadiopharmaceutical\tInformation\tSequence(0x0054,0x0016)\n  RadionuclideTotalDose?: number;\n  FrameReferenceTime?: number;\n  ActualFrameDuration?: number;\n}\n\n/**\n * Calculate the scan times\n *\n * @export\n * @param {InstanceMetadataForScanTimes[]} instances\n * @returns {FullDateInterface[]}\n */\nexport default function calculateScanTimes(\n  instances: InstanceMetadataForScanTimes[]\n): FullDateInterface[] {\n  const {\n    SeriesDate,\n    SeriesTime,\n    GEPrivatePostInjectionDateTime,\n  } = instances[0];\n  const results = new Array(instances.length);\n  const seriesDate: DateInterface = parseDA(SeriesDate);\n  const seriesTime: TimeInterface = parseTM(SeriesTime);\n  const seriesDateTime: FullDateInterface = combineDateTime(\n    seriesDate,\n    seriesTime\n  );\n\n  let earliestAcquisitionDateTime = new FullDateInterface(\n    `3000-01-01T00:00:00.000000Z`\n  );\n  let timeError = earliestAcquisitionDateTime.getTimeInSec();\n  instances.forEach(instance => {\n    const { AcquisitionDate, AcquisitionTime } = instance;\n\n    const acquisitionDate: DateInterface = parseDA(AcquisitionDate);\n    const acquisitionTime: TimeInterface = parseTM(AcquisitionTime);\n    const acquisitionDateTime: FullDateInterface = combineDateTime(\n      acquisitionDate,\n      acquisitionTime\n    );\n\n    if (earliestAcquisitionDateTime.getTimeInSec() >= timeError) {\n      earliestAcquisitionDateTime = acquisitionDateTime;\n    } else {\n      earliestAcquisitionDateTime =\n        acquisitionDateTime.getTimeInSec() <\n        earliestAcquisitionDateTime.getTimeInSec()\n          ? acquisitionDateTime\n          : earliestAcquisitionDateTime;\n    }\n  });\n\n  if (earliestAcquisitionDateTime.getTimeInSec() >= timeError) {\n    throw new Error('Earliest acquisition time or date could not be parsed.');\n  }\n\n  if (\n    seriesDateTime.getTimeInSec() <= earliestAcquisitionDateTime.getTimeInSec()\n  ) {\n    return results.fill(seriesDateTime);\n  } else {\n    if (GEPrivatePostInjectionDateTime) {\n      // GE Private scan\n      return results.fill(\n        dateTimeToFullDateInterface(GEPrivatePostInjectionDateTime)\n      );\n    } else {\n      /*const hasValidFrameTimes = instances.every(instance => {\n        return (\n          instance.FrameReferenceTime &&\n          instance.FrameReferenceTime > 0 &&\n          instance.ActualFrameDuration &&\n          instance.ActualFrameDuration > 0\n        );\n      });*/\n\n      // TODO: Temporarily commented out the checks and logic below to\n      // investigate the BQML_AC_DT_lessThan_S_DT_SIEMENS-instances case\n      //if (!hasValidFrameTimes) {\n      return results.fill(earliestAcquisitionDateTime);\n      //}\n\n      /* Siemens PETsyngo\t3.x\tmulti-injection logic\n      - backcompute\tfrom\tcenter\t(average\tcount\trate\t)\tof\ttime\twindow\tfor\tbed\tposition\t(frame)\tin\tseries (reliable\tin\tall\tcases)\n      - Acquisition\tDate\t(0x0008,0x0022)\tand\tTime\t(0x0008,0x0032) are\tthe\tstart\tof\tthe\tbed\tposition\t(frame)\n      - Frame\tReference\tTime\t(0x0054,0x1300) is\tthe\toffset\t(ms)\tfrom\tthe\tscan\tDate\tand\tTime we\twant\tto\tthe\taverage\tcount\trate\ttime\n      */\n      /*return instances.map(instance => {\n        const {\n          FrameReferenceTime,\n          ActualFrameDuration,\n          RadionuclideHalfLife,\n          AcquisitionDate,\n          AcquisitionTime,\n        } = instance;\n        // Some of these checks are only here because the compiler is complaining\n        // We could potentially use the ! operator instead\n        if (!FrameReferenceTime || FrameReferenceTime <= 0) {\n          throw new Error(\n            `FrameReferenceTime is invalid: ${FrameReferenceTime}`\n          );\n        }\n\n        if (!ActualFrameDuration || ActualFrameDuration <= 0) {\n          throw new Error(\n            `ActualFrameDuration is invalid: ${ActualFrameDuration}`\n          );\n        }\n\n        if (!RadionuclideHalfLife) {\n          throw new Error('RadionuclideHalfLife is required');\n        }\n\n        if (!AcquisitionDate) {\n          throw new Error('AcquisitionDate is required');\n        }\n\n        if (!AcquisitionTime) {\n          throw new Error('AcquisitionTime is required');\n        }\n\n        const acquisitionDate: DateInterface = parseDA(AcquisitionDate);\n        const acquisitionTime: TimeInterface = parseTM(AcquisitionTime);\n        const acquisitionDateTime: FullDateInterface = combineDateTime(\n          acquisitionDate,\n          acquisitionTime\n        );\n\n        const frameDurationInSec = ActualFrameDuration / 1000;\n        const decayConstant = Math.log(2) / RadionuclideHalfLife;\n        const decayDuringFrame = decayConstant * frameDurationInSec;\n        // TODO: double check this is correctly copied from QIBA pseudocode\n        const averageCountRateTimeWithinFrameInSec =\n          (1 / decayConstant) *\n          Math.log(decayDuringFrame / (1 - Math.exp(-decayConstant)));\n        const scanDateTimeAsNumber =\n          Number(acquisitionDateTime) -\n          FrameReferenceTime / 1000 +\n          averageCountRateTimeWithinFrameInSec;\n\n        const scanDate = new Date(scanDateTimeAsNumber);\n        console.log('SIEMENS PATH');\n        console.log(new Date(scanDateTimeAsNumber));\n        return scanDate;\n      });*/\n    }\n  }\n}\n\nexport { calculateScanTimes };\n","/**\n * Javascript object with patient properties size, sez, weight\n *\n * @export\n * @interface SUVlbmScalingFactorInput\n */\ninterface SUVlbmScalingFactorInput {\n  PatientSize: number; // m\n  PatientSex: string; //'M' | 'F' | 'O';\n  PatientWeight: number; // Kg\n}\n\nfunction calculateSUVlbmScalingFactor(\n  inputs: SUVlbmScalingFactorInput\n): number {\n  const { PatientSex, PatientWeight, PatientSize } = inputs;\n\n  let LBM;\n  const weightSizeFactor = Math.pow(PatientWeight / (PatientSize * 100), 2);\n  // reference: https://www.medicalconnections.co.uk/kb/calculating-suv-from-pet-images/\n  if (PatientSex === 'F') {\n    LBM = 1.07 * PatientWeight - 148 * weightSizeFactor;\n  } else if (PatientSex === 'M') {\n    LBM = 1.1 * PatientWeight - 120 * weightSizeFactor;\n  } else {\n    throw new Error(`PatientSex is an invalid value: ${PatientSex}`);\n  }\n\n  return LBM * 1000; // convert in gr\n}\n\n/**\n * From https://link.springer.com/article/10.1007/s00259-014-2961-x\n * and https://link.springer.com/article/10.2165/00003088-200544100-00004\n * and\n * @param inputs\n * @returns\n */\nfunction calculateSUVlbmJanmahasatianScalingFactor(\n  inputs: SUVlbmScalingFactorInput\n): number {\n  const { PatientSex, PatientWeight, PatientSize } = inputs;\n\n  let LBM;\n  const bodyMassIndex = PatientWeight / Math.pow(PatientSize, 2);\n\n  if (PatientSex === 'F') {\n    LBM = (9270 * PatientWeight) / (8780 + 244 * bodyMassIndex);\n  } else if (PatientSex === 'M') {\n    LBM = (9270 * PatientWeight) / (6680 + 216 * bodyMassIndex);\n  } else {\n    throw new Error(`PatientSex is an invalid value: ${PatientSex}`);\n  }\n  return LBM * 1000; // convert in gr\n}\n\nexport {\n  calculateSUVlbmScalingFactor,\n  calculateSUVlbmJanmahasatianScalingFactor,\n  SUVlbmScalingFactorInput,\n};\n","/**\n * Javascript object with patient properties size, sez, weight\n *\n * @export\n * @interface SUVbsaScalingFactorInput\n */\ninterface SUVbsaScalingFactorInput {\n  PatientSize: number;\n  PatientWeight: number;\n}\n\nfunction calculateSUVbsaScalingFactor(\n  inputs: SUVbsaScalingFactorInput\n): number {\n  const { PatientWeight, PatientSize } = inputs;\n\n  let BSA =\n    Math.pow(PatientWeight, 0.425) * Math.pow(PatientSize * 100, 0.725) * 71.84;\n\n  return BSA;\n}\n\nexport { calculateSUVbsaScalingFactor, SUVbsaScalingFactorInput };\n","import combineDateTime, { FullDateInterface } from './combineDateTime';\nimport { parseDA, DateInterface } from './parseDA';\nimport { parseTM, TimeInterface } from './parseTM';\nimport dateTimeToFullDateInterface from './dateTimeToFullDateInterface';\n\n/**\n * Calculate start time\n *\n * @export\n * @param {{\n *   RadiopharmaceuticalStartDateTime?: string;\n *   RadiopharmaceuticalStartTime?: string;\n *   SeriesDate?: string;\n * }} input\n * @returns {FullDateInterface}\n */\nexport default function calculateStartTime(input: {\n  RadiopharmaceuticalStartDateTime?: string;\n  RadiopharmaceuticalStartTime?: string;\n  SeriesDate?: string;\n}): FullDateInterface {\n  const {\n    RadiopharmaceuticalStartDateTime,\n    RadiopharmaceuticalStartTime,\n    SeriesDate,\n  } = input;\n\n  let time: TimeInterface;\n  let date: DateInterface;\n  if (RadiopharmaceuticalStartDateTime) {\n    return dateTimeToFullDateInterface(RadiopharmaceuticalStartDateTime);\n  } else if (RadiopharmaceuticalStartTime && SeriesDate) {\n    // start Date\tis not explicit - assume\tsame as\tSeries Date;\n    // but consider\tspanning midnight\n    // TODO: do we need some logic to check if the scan went over midnight?\n    time = parseTM(RadiopharmaceuticalStartTime);\n    date = parseDA(SeriesDate);\n\n    return combineDateTime(date, time);\n  }\n\n  throw new Error(`Invalid input: ${input}`);\n}\n\nexport { calculateStartTime };\n","import { FullDateInterface } from './combineDateTime';\nimport { calculateScanTimes } from './calculateScanTimes';\nimport {\n  calculateSUVlbmJanmahasatianScalingFactor,\n  calculateSUVlbmScalingFactor,\n  SUVlbmScalingFactorInput,\n} from './calculateSUVlbmScalingFactor';\nimport {\n  calculateSUVbsaScalingFactor,\n  SUVbsaScalingFactorInput,\n} from './calculateSUVbsaScalingFactor';\nimport { calculateStartTime } from './calculateStartTime';\nimport { InstanceMetadata } from './types';\n\n/**\n * Javascript object containing the SUV and SUL factors.\n * TODO, the result property names may changes\n *\n * @interface ScalingFactorResult\n */\ninterface ScalingFactorResult {\n  suvbw: number;\n  suvlbm?: number;\n  suvlbmJanma?: number;\n  suvbsa?: number;\n}\n\n/**\n * The injected dose used to calculate SUV is corrected for the\n * decay that occurs between the time of injection and the start of the scan\n *\n * @param {InstanceMetadata[]} instances\n * @returns {number[]}\n */\nfunction calculateDecayCorrection(instances: InstanceMetadata[]): number[] {\n  const {\n    RadionuclideTotalDose,\n    RadionuclideHalfLife,\n    RadiopharmaceuticalStartDateTime,\n    RadiopharmaceuticalStartTime,\n    SeriesDate,\n  } = instances[0];\n\n  if (RadionuclideTotalDose === undefined || RadionuclideTotalDose === null) {\n    throw new Error(\n      'calculateDecayCorrection : RadionuclideTotalDose value not found.'\n    );\n  }\n\n  if (RadionuclideHalfLife === undefined || RadionuclideHalfLife === null) {\n    throw new Error(\n      'calculateDecayCorrection : RadionuclideHalfLife value not found.'\n    );\n  }\n\n  const scanTimes: FullDateInterface[] = calculateScanTimes(instances);\n  const startTime: FullDateInterface = calculateStartTime({\n    RadiopharmaceuticalStartDateTime,\n    RadiopharmaceuticalStartTime,\n    SeriesDate,\n  });\n\n  return instances.map((_, index) => {\n    const scanTime = scanTimes[index];\n    const decayTimeInSec: number =\n      scanTime.getTimeInSec() - startTime.getTimeInSec();\n    if (decayTimeInSec < 0) {\n      throw new Error('Decay time cannot be less than zero');\n    }\n\n    const decayedDose: number =\n      RadionuclideTotalDose *\n      Math.pow(2, -decayTimeInSec / RadionuclideHalfLife);\n\n    return 1 / decayedDose;\n  });\n}\n\n/**\n *\n * @param a Simple value or array of simple values\n * @param b Simple value or array of simple values\n * @returns boolean true if the values are equal.\n */\nconst deepEquals = (\n  a: string | number | any[],\n  b: string | number | any[]\n): boolean => {\n  return (\n    a === b ||\n    (Array.isArray(a) &&\n      Array.isArray(b) &&\n      a.length === b.length &&\n      a.every((val, index) => val === b[index]))\n  );\n};\n\n/**\n * Calculate the SUV factor\n *\n * Note: Rescale Slope / Intercept must still be applied. These must be applied\n *       on a per-Frame basis, since some scanners may have different values per Frame.\n *\n * @export\n * @param {InstanceMetadata[]} instances\n * @returns {ScalingFactorResult[]}\n */\nexport default function calculateSUVScalingFactors(\n  instances: InstanceMetadata[]\n): ScalingFactorResult[] {\n  const {\n    CorrectedImage,\n    Units,\n    PhilipsPETPrivateGroup,\n    PatientWeight,\n    PatientSex,\n    PatientSize,\n  } = instances[0];\n\n  if (!CorrectedImage.includes('ATTN') || !CorrectedImage.includes('DECY')) {\n    throw new Error(\n      `CorrectedImage must contain \"ATTN\" and \"DECY\": ${CorrectedImage}`\n    );\n  }\n\n  // Sanity check that every instance provided has identical\n  // values for series-level metadata. If not, the provided\n  // data is invalid.\n  const isSingleSeries = instances.every(instance => {\n    return (\n      instance.Units === Units &&\n      deepEquals(instance.CorrectedImage, CorrectedImage) &&\n      instance.PatientWeight === PatientWeight &&\n      instance.PatientSex === PatientSex &&\n      instance.PatientSize === PatientSize &&\n      instance.RadionuclideHalfLife === instances[0].RadionuclideHalfLife &&\n      instance.RadionuclideTotalDose === instances[0].RadionuclideTotalDose &&\n      instance.DecayCorrection === instances[0].DecayCorrection &&\n      instance.SeriesDate === instances[0].SeriesDate &&\n      instance.SeriesTime === instances[0].SeriesTime\n    );\n  });\n\n  if (!isSingleSeries) {\n    throw new Error(\n      'The set of instances does not appear to come from one Series. Every instance must have identical values for series-level metadata properties'\n    );\n  }\n\n  // Treat null, undefined and zero as a missing PatientWeight.\n  if (!PatientWeight) {\n    throw new Error(\n      'PatientWeight value is missing. It is not possible to calculate the SUV factors'\n    );\n  }\n\n  let decayCorrectionArray: number[] = new Array(instances.length);\n  decayCorrectionArray = calculateDecayCorrection(instances);\n\n  let results: number[] = new Array(instances.length);\n  const weightInGrams: number = PatientWeight * 1000;\n\n  if (Units === 'BQML') {\n    results = decayCorrectionArray.map(function(value) {\n      return value * weightInGrams;\n    });\n  } else if (Units === 'CNTS') {\n    const hasValidSUVScaleFactor: boolean = instances.every(instance => {\n      return (\n        instance.PhilipsPETPrivateGroup &&\n        instance.PhilipsPETPrivateGroup?.SUVScaleFactor !== null &&\n        instance.PhilipsPETPrivateGroup?.SUVScaleFactor !== undefined &&\n        instance.PhilipsPETPrivateGroup?.SUVScaleFactor !== 0\n      );\n    });\n\n    const hasValidActivityConcentrationScaleFactor: boolean = instances.every(\n      instance => {\n        return (\n          instance.PhilipsPETPrivateGroup &&\n          !instance.PhilipsPETPrivateGroup?.SUVScaleFactor &&\n          instance.PhilipsPETPrivateGroup?.ActivityConcentrationScaleFactor !==\n            undefined &&\n          instance.PhilipsPETPrivateGroup?.ActivityConcentrationScaleFactor !==\n            0\n        );\n      }\n    );\n\n    //console.log(`hasValidSUVScaleFactor: ${hasValidSUVScaleFactor}`);\n    //console.log(`hasValidActivityConcentrationScaleFactor: ${hasValidActivityConcentrationScaleFactor}`);\n\n    if (hasValidSUVScaleFactor) {\n      results = instances.map(\n        // Added ! to tell Typescript that this can't be undefined, since we are testing it\n        // in the .every loop above.\n        instance => instance.PhilipsPETPrivateGroup!.SUVScaleFactor!\n      );\n    } else if (hasValidActivityConcentrationScaleFactor) {\n      // if (0x7053,0x1000) not present, but (0x7053,0x1009) is present, then (0x7053,0x1009) * Rescale Slope,\n      // scales pixels to Bq/ml, and proceed as if Units are BQML\n      results = instances.map((instance, index) => {\n        // Added ! to tell Typescript that this can't be undefined, since we are testing it\n        // in the .every loop above.\n        return (\n          instance.PhilipsPETPrivateGroup!.ActivityConcentrationScaleFactor! *\n          decayCorrectionArray[index] *\n          weightInGrams\n        );\n      });\n    } else {\n      throw new Error(\n        `Units are in CNTS, but PhilipsPETPrivateGroup has invalid values: ${JSON.stringify(\n          PhilipsPETPrivateGroup\n        )}`\n      );\n    }\n  } else if (Units === 'GML') {\n    // assumes that GML indicates SUVbw instead of SUVlbm\n    results.fill(1);\n  } else {\n    throw new Error(`Units has an invalid value: ${Units}`);\n  }\n\n  // get BSA\n  let suvbsaFactor: number | undefined;\n  if (PatientSize === null || PatientSize === undefined) {\n    console.warn(\n      'PatientSize value is missing. It is not possible to calculate the SUV bsa factors'\n    );\n  } else {\n    const sulInputs: SUVbsaScalingFactorInput = {\n      PatientWeight,\n      PatientSize,\n    };\n\n    suvbsaFactor = calculateSUVbsaScalingFactor(sulInputs);\n  }\n\n  // get LBM\n  let suvlbmFactor: number | undefined;\n  let suvlbmJenmaFactor: number | undefined;\n  if (PatientSize === null || PatientSize === undefined) {\n    console.warn(\n      'PatientSize value is missing. It is not possible to calculate the SUV lbm factors'\n    );\n  } else if (PatientSex === null || PatientSex === undefined) {\n    console.warn(\n      'PatientSex value is missing. It is not possible to calculate the SUV lbm factors'\n    );\n  } else {\n    const suvlbmInputs: SUVlbmScalingFactorInput = {\n      PatientWeight,\n      PatientSex,\n      PatientSize,\n    };\n\n    suvlbmFactor = calculateSUVlbmScalingFactor(suvlbmInputs);\n    suvlbmJenmaFactor = calculateSUVlbmJanmahasatianScalingFactor(suvlbmInputs);\n  }\n\n  return results.map(function(result, index) {\n    const factors: ScalingFactorResult = {\n      suvbw: result,\n    };\n\n    if (suvbsaFactor) {\n      // multiply for BSA\n      factors.suvbsa = decayCorrectionArray[index] * suvbsaFactor;\n    }\n\n    if (suvlbmFactor) {\n      // multiply for LBM\n      factors.suvlbm = decayCorrectionArray[index] * suvlbmFactor;\n    }\n\n    if (suvlbmJenmaFactor) {\n      factors.suvlbmJanma = decayCorrectionArray[index] * suvlbmJenmaFactor;\n    }\n\n    // factor formulaes taken from:\n    // https://www.medicalconnections.co.uk/kb/calculating-suv-from-pet-images/\n\n    return factors;\n  });\n}\n\nexport { calculateSUVScalingFactors };\n"],"mappings":"AAGA;;;;;;MAMaA,iBAAA;EAGX;;;;;EAKAC,YAAYC,IAAA;IACV,KAAKC,QAAL,GAAgBD,IAAhB;EACD;EAED;;;;;;;EAMAE,YAAYA,CAAA;IACV;IACA,MAAMC,UAAU,GAAG,KAAKF,QAAL,CAAcG,SAAd,CAAwB,CAAxB,EAA2B,EAA3B,CAAnB;IACA,MAAMC,UAAU,GAAG,KAAKJ,QAAL,CAAcG,SAAd,CAAwB,EAAxB,EAA4B,EAA5B,CAAnB;;IAGA,MAAME,IAAI,GAAGC,QAAQ,CAACJ,UAAU,CAACC,SAAX,CAAqB,CAArB,EAAwB,CAAxB,CAAD,EAA6B,EAA7B,CAArB;IACA,MAAMI,EAAE,GACNL,UAAU,CAACM,MAAX,IAAqB,CAArB,GACIF,QAAQ,CAACJ,UAAU,CAACC,SAAX,CAAqB,CAArB,EAAwB,CAAxB,CAAD,EAA6B,EAA7B,CADZ,GAEIM,SAHN;IAIA,MAAMC,EAAE,GACNR,UAAU,CAACM,MAAX,IAAqB,EAArB,GACIF,QAAQ,CAACJ,UAAU,CAACC,SAAX,CAAqB,CAArB,EAAwB,EAAxB,CAAD,EAA8B,EAA9B,CADZ,GAEIM,SAHN;IAKA,IACEE,KAAK,CAACN,IAAD,CAAL,IACCE,EAAE,KAAKE,SAAP,IAAoBE,KAAK,CAACJ,EAAD,CAD1B,IAECG,EAAE,KAAKD,SAAP,IAAoBE,KAAK,CAACD,EAAD,CAF1B,IAGAL,IAAI,GAAG,IAHP,IAICE,EAAE,KAAKA,EAAE,GAAG,CAAL,IAAUA,EAAE,GAAG,EAApB,CAJH,IAKCG,EAAE,KAAKA,EAAE,GAAG,CAAL,IAAUA,EAAE,GAAG,EAApB,CANL,EAOE;MACA,MAAM,IAAIE,KAAJ,kBAA2BV,UAAA,GAA3B,CAAN;IACD;IAED,MAAMW,MAAM,GAAG,IAAIC,IAAJ,IAAYZ,UAAA,mBAAZ,CAAf;;IAGA,MAAMa,EAAE,GAAGT,QAAQ,CAACF,UAAU,CAACD,SAAX,CAAqB,CAArB,EAAwB,CAAxB,CAAD,EAA6B,EAA7B,CAAnB;IACA,MAAMa,EAAE,GACNZ,UAAU,CAACI,MAAX,IAAqB,CAArB,GACIF,QAAQ,CAACF,UAAU,CAACD,SAAX,CAAqB,CAArB,EAAwB,CAAxB,CAAD,EAA6B,EAA7B,CADZ,GAEIM,SAHN;IAIA,MAAMQ,EAAE,GACNb,UAAU,CAACI,MAAX,IAAqB,CAArB,GACIF,QAAQ,CAACF,UAAU,CAACD,SAAX,CAAqB,CAArB,EAAwB,CAAxB,CAAD,EAA6B,EAA7B,CADZ,GAEIM,SAHN;IAIA,MAAMS,aAAa,GAAGd,UAAU,CAACD,SAAX,CAAqB,CAArB,EAAwB,EAAxB,CAAtB;IACA,MAAMgB,MAAM,GAAGD,aAAa,GACxBZ,QAAQ,CAACY,aAAD,EAAgB,EAAhB,CAAR,GAA8BE,IAAI,CAACC,GAAL,CAAS,EAAT,EAAa,CAACH,aAAa,CAACV,MAA5B,CADN,GAExBC,SAFJ;IAIA,IACEE,KAAK,CAACI,EAAD,CAAL,IACCC,EAAE,KAAKP,SAAP,IAAoBE,KAAK,CAACK,EAAD,CAD1B,IAECC,EAAE,KAAKR,SAAP,IAAoBE,KAAK,CAACM,EAAD,CAF1B,IAGCE,MAAM,KAAKV,SAAX,IAAwBE,KAAK,CAACQ,MAAD,CAH9B,IAIAJ,EAAE,GAAG,CAJL,IAKAA,EAAE,GAAG,EALL,IAMCC,EAAE,KAAKA,EAAE,GAAG,CAAL,IAAUA,EAAE,GAAG,EAApB,CANH,IAOCC,EAAE,KAAKA,EAAE,GAAG,CAAL,IAAUA,EAAE,GAAG,EAApB,CAPH,IAQCE,MAAM,KAAKA,MAAM,GAAG,CAAT,IAAcA,MAAM,GAAG,MAA5B,CATT,EAUE;MACA,MAAM,IAAIP,KAAJ,kBAA2BR,UAAA,GAA3B,CAAN;IACD;IAED,IAAIkB,SAAS,GAAGT,MAAM,CAACU,OAAP,KAAmB,IAAnC;IAEAD,SAAS,IAAIP,EAAE,GAAG,IAAlB;IACA,IAAIC,EAAE,KAAKP,SAAX,EAAsB;MACpBa,SAAS,IAAIN,EAAE,GAAG,EAAlB;IACD;IACD,IAAIC,EAAE,KAAKR,SAAX,EAAsB;MACpBa,SAAS,IAAIL,EAAb;IACD;IACD,IAAIE,MAAM,KAAKV,SAAf,EAA0B;MACxBa,SAAS,IAAIH,MAAb;IACD;IAED,OAAOG,SAAP;EACD;EAED;;;;;;;EAMAE,iBAAiBA,CAAA;IACf,MAAMC,cAAc,GAAG,KAAKxB,YAAL,KAAsB,GAA7C;IACA,OAAOwB,cAAP;EACD;;AAOH;;;;;;;;;SAQwBC,gBACtB3B,IAAA,EACA4B,IAAA;EAEA,MAAMC,KAAK,MAAMD,IAAI,CAACC,KAAL,IAAc,MAAjB,CAAwBC,QAAxB,CAAiC,CAAjC,EAAoC,GAApC,CAAd;EACA,MAAMC,OAAO,MAAMH,IAAI,CAACG,OAAL,IAAgB,MAAnB,CAA0BD,QAA1B,CAAmC,CAAnC,EAAsC,GAAtC,CAAhB;EACA,MAAME,OAAO,MAAMJ,IAAI,CAACI,OAAL,IAAgB,MAAnB,CAA0BF,QAA1B,CAAmC,CAAnC,EAAsC,GAAtC,CAAhB;EACA,MAAMG,KAAK,MAAMjC,IAAI,CAACiC,KAAA,EAAR,CAAgBH,QAAhB,CAAyB,CAAzB,EAA4B,GAA5B,CAAd;EACA,MAAMI,GAAG,MAAMlC,IAAI,CAACkC,GAAA,EAAR,CAAcJ,QAAd,CAAuB,CAAvB,EAA0B,GAA1B,CAAZ;EACA,MAAMK,iBAAiB,MAAMP,IAAI,CAACO,iBAAL,IAA0B,UAA7B,CAAwCC,MAAxC,CACxB,CADwB,EAExB,GAFwB,CAA1B;EAIA,MAAMjC,UAAU,MAAMH,IAAI,CAACqC,IAAA,IAAQJ,KAAA,IAASC,GAAA,EAA5C;EACA,MAAM7B,UAAU,OAAOwB,KAAA,IAASE,OAAA,IAAWC,OAAA,IAAWG,iBAAA,GAAtD;EACA,MAAMG,cAAc,MAAMnC,UAAA,GAAaE,UAAA,EAAvC;EAEA,OAAO,IAAIP,iBAAJ,CAAsBwC,cAAtB,CAAP;AACD;;AC/ID;;;;;;;;AAQA,SAASC,WAATA,CAAqBC,CAArB,EAAgCC,CAAhC;EACE;EACA,QAAQD,CAAR;IACE,KAAK,CAAL;MACE,OAAQC,CAAC,GAAG,CAAJ,KAAU,CAAV,IAAeA,CAAC,GAAG,GAApB,IAA4BA,CAAC,GAAG,GAAJ,KAAY,CAAxC,GAA4C,EAA5C,GAAiD,EAAxD;IACF,KAAK,CAAL;IACA,KAAK,CAAL;IACA,KAAK,CAAL;IACA,KAAK,EAAL;MACE,OAAO,EAAP;IACF;MACE,OAAO,EAAP;EATJ;AAWD;AAED;;;;;;;;;AAQA,SAASC,WAATA,CAAqBC,CAArB,EAAgCH,CAAhC,EAA2CC,CAA3C;EACE;EACA,IAAI7B,KAAK,CAAC6B,CAAD,CAAT,EAAc;IACZ,OAAO,KAAP;EACD;EAED,OAAOD,CAAC,GAAG,CAAJ,IAASA,CAAC,IAAI,EAAd,IAAoBG,CAAC,GAAG,CAAxB,IAA6BA,CAAC,IAAIJ,WAAW,CAACC,CAAD,EAAIC,CAAJ,CAApD;AACD;AAcD;;;;;;;AAMA,SAAwBG,QAAQ5C,IAAA;EAC9B,IACEA,IAAI,KAAKU,SAAT,IACAV,IAAI,KAAK,IADT,IAEAA,IAAI,CAACS,MAAL,KAAgB,CAFhB,IAGA,OAAOT,IAAP,KAAgB,QAJlB,EAKE;IACA,MAAM,IAAIa,KAAJ,gBAAyBb,IAAA,GAAzB,CAAN;EACD;EAED,MAAMM,IAAI,GAAGC,QAAQ,CAACP,IAAI,CAACI,SAAL,CAAe,CAAf,EAAkB,CAAlB,CAAD,EAAuB,EAAvB,CAArB;EACA,MAAMI,EAAE,GAAGD,QAAQ,CAACP,IAAI,CAACI,SAAL,CAAe,CAAf,EAAkB,CAAlB,CAAD,EAAuB,EAAvB,CAAnB;EACA,MAAMO,EAAE,GAAGJ,QAAQ,CAACP,IAAI,CAACI,SAAL,CAAe,CAAf,EAAkB,CAAlB,CAAD,EAAuB,EAAvB,CAAnB;EAEA,IAAIsC,WAAW,CAAC/B,EAAD,EAAKH,EAAL,EAASF,IAAT,CAAX,KAA8B,IAAlC,EAAwC;IACtC,MAAM,IAAIO,KAAJ,gBAAyBb,IAAA,GAAzB,CAAN;EACD;EAED,OAAO;IACLqC,IAAI,EAAE/B,IADD;IAEL2B,KAAK,EAAEzB,EAFF;IAGL0B,GAAG,EAAEvB;EAHA,CAAP;AAKD;;ACpED;;;;;AAKA,SAAwBkC,QAAQjB,IAAA;EAC9B,IACEA,IAAI,KAAK,IAAT,IACAA,IAAI,KAAKlB,SADT,IAEAkB,IAAI,CAACnB,MAAL,GAAc,CAFd,IAGA,OAAOmB,IAAP,KAAgB,QAJlB,EAKE;IACA;IACA,MAAM,IAAIf,KAAJ,gBAAyBe,IAAA,GAAzB,CAAN;EACD;EAGD;;EACA,MAAMkB,EAAE,GAAGvC,QAAQ,CAACqB,IAAI,CAACxB,SAAL,CAAe,CAAf,EAAkB,CAAlB,CAAD,EAAuB,EAAvB,CAAnB;EACA,MAAMI,EAAE,GAAGoB,IAAI,CAACnB,MAAL,IAAe,CAAf,GAAmBF,QAAQ,CAACqB,IAAI,CAACxB,SAAL,CAAe,CAAf,EAAkB,CAAlB,CAAD,EAAuB,EAAvB,CAA3B,GAAwDM,SAAnE;EACA,MAAMqC,EAAE,GAAGnB,IAAI,CAACnB,MAAL,IAAe,CAAf,GAAmBF,QAAQ,CAACqB,IAAI,CAACxB,SAAL,CAAe,CAAf,EAAkB,CAAlB,CAAD,EAAuB,EAAvB,CAA3B,GAAwDM,SAAnE;EACA,MAAMS,aAAa,GAAGS,IAAI,CAACnB,MAAL,IAAe,CAAf,GAAmBmB,IAAI,CAACxB,SAAL,CAAe,CAAf,EAAkB,EAAlB,CAAnB,GAA2CM,SAAjE;EACA,MAAMsC,MAAM,GAAG7B,aAAa,GACxBZ,QAAQ,CAACY,aAAD,EAAgB,EAAhB,CAAR,GAA8BE,IAAI,CAACC,GAAL,CAAS,EAAT,EAAa,IAAIH,aAAa,CAACV,MAA/B,CADN,GAExBC,SAFJ;EAIA,IACEE,KAAK,CAACkC,EAAD,CAAL,IACCtC,EAAE,KAAKE,SAAP,IAAoBE,KAAK,CAACJ,EAAD,CAD1B,IAECuC,EAAE,KAAKrC,SAAP,IAAoBE,KAAK,CAACmC,EAAD,CAF1B,IAGCC,MAAM,KAAKtC,SAAX,IAAwBE,KAAK,CAACoC,MAAD,CAH9B,IAIAF,EAAE,GAAG,CAJL,IAKAA,EAAE,GAAG,EALL,IAMCtC,EAAE,KAAKA,EAAE,GAAG,CAAL,IAAUA,EAAE,GAAG,EAApB,CANH,IAOCuC,EAAE,KAAKA,EAAE,GAAG,CAAL,IAAUA,EAAE,GAAG,EAApB,CAPH,IAQCC,MAAM,KAAKA,MAAM,GAAG,CAAT,IAAcA,MAAM,GAAG,MAA5B,CATT,EAUE;IACA,MAAM,IAAInC,KAAJ,gBAAyBe,IAAA,GAAzB,CAAN;EACD;EAED,OAAO;IACLC,KAAK,EAAEiB,EADF;IAELf,OAAO,EAAEvB,EAFJ;IAGLwB,OAAO,EAAEe,EAHJ;IAILZ,iBAAiB,EAAEa;EAJd,CAAP;AAMD;;ACvDD;;;;;;;;AAOA,SAAwBC,4BACtBC,QAAA;EAEA,IAAIA,QAAQ,KAAKxC,SAAb,IAA0BwC,QAAQ,KAAK,IAA3C,EAAiD;IAC/C,MAAM,IAAIrC,KAAJ,CAAU,qDAAV,CAAN;EACD;EAED,MAAMb,IAAI,GAAG4C,OAAO,CAACM,QAAQ,CAAC9C,SAAT,CAAmB,CAAnB,EAAsB,CAAtB,CAAD,CAApB;EACA,MAAMwB,IAAI,GAAGiB,OAAO,CAACK,QAAQ,CAAC9C,SAAT,CAAmB,CAAnB,CAAD,CAApB;EACA,OAAOuB,eAAe,CAAC3B,IAAD,EAAO4B,IAAP,CAAtB;AACD;;ACID;;;;;;;;AAOA,SAAwBuB,mBACtBC,SAAA;EAEA,MAAM;IACJC,UADI;IAEJC,UAFI;IAGJC;EAHI,IAIFH,SAAS,CAAC,CAAD,CAJb;EAKA,MAAMI,OAAO,GAAG,IAAIC,KAAJ,CAAUL,SAAS,CAAC3C,MAApB,CAAhB;EACA,MAAMiD,UAAU,GAAkBd,OAAO,CAACS,UAAD,CAAzC;EACA,MAAMM,UAAU,GAAkBd,OAAO,CAACS,UAAD,CAAzC;EACA,MAAMM,cAAc,GAAsBjC,eAAe,CACvD+B,UADuD,EAEvDC,UAFuD,CAAzD;EAKA,IAAIE,2BAA2B,GAAG,IAAI/D,iBAAJ,+BAAlC;EAGA,IAAIgE,SAAS,GAAGD,2BAA2B,CAAC3D,YAA5B,EAAhB;EACAkD,SAAS,CAACW,OAAV,CAAkBC,QAAQ;IACxB,MAAM;MAAEC,eAAF;MAAmBC;IAAnB,IAAuCF,QAA7C;IAEA,MAAMG,eAAe,GAAkBvB,OAAO,CAACqB,eAAD,CAA9C;IACA,MAAMG,eAAe,GAAkBvB,OAAO,CAACqB,eAAD,CAA9C;IACA,MAAMG,mBAAmB,GAAsB1C,eAAe,CAC5DwC,eAD4D,EAE5DC,eAF4D,CAA9D;IAKA,IAAIP,2BAA2B,CAAC3D,YAA5B,MAA8C4D,SAAlD,EAA6D;MAC3DD,2BAA2B,GAAGQ,mBAA9B;IACD,CAFD,MAEO;MACLR,2BAA2B,GACzBQ,mBAAmB,CAACnE,YAApB,KACA2D,2BAA2B,CAAC3D,YAA5B,EADA,GAEImE,mBAFJ,GAGIR,2BAJN;IAKD;EACF,CAnBD;EAqBA,IAAIA,2BAA2B,CAAC3D,YAA5B,MAA8C4D,SAAlD,EAA6D;IAC3D,MAAM,IAAIjD,KAAJ,CAAU,wDAAV,CAAN;EACD;EAED,IACE+C,cAAc,CAAC1D,YAAf,MAAiC2D,2BAA2B,CAAC3D,YAA5B,EADnC,EAEE;IACA,OAAOsD,OAAO,CAACc,IAAR,CAAaV,cAAb,CAAP;EACD,CAJD,MAIO;IACL,IAAIL,8BAAJ,EAAoC;MAClC;MACA,OAAOC,OAAO,CAACc,IAAR,CACLrB,2BAA2B,CAACM,8BAAD,CADtB,CAAP;IAGD,CALD,MAKO;MACL;;;;;;;;MASA;MACA;MACA;MACA,OAAOC,OAAO,CAACc,IAAR,CAAaT,2BAAb,CAAP,CAbK;;MAgBL;;;;;;MAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA0DD;EACF;AACF;AC5JD,SAASU,4BAATA,CACEC,MADF;EAGE,MAAM;IAAEC,UAAF;IAAcC,aAAd;IAA6BC;EAA7B,IAA6CH,MAAnD;EAEA,IAAII,GAAJ;EACA,MAAMC,gBAAgB,GAAGxD,IAAI,CAACC,GAAL,CAASoD,aAAa,IAAIC,WAAW,GAAG,GAAlB,CAAtB,EAA8C,CAA9C,CAAzB;;EAEA,IAAIF,UAAU,KAAK,GAAnB,EAAwB;IACtBG,GAAG,GAAG,OAAOF,aAAP,GAAuB,MAAMG,gBAAnC;EACD,CAFD,MAEO,IAAIJ,UAAU,KAAK,GAAnB,EAAwB;IAC7BG,GAAG,GAAG,MAAMF,aAAN,GAAsB,MAAMG,gBAAlC;EACD,CAFM,MAEA;IACL,MAAM,IAAIhE,KAAJ,oCAA6C4D,UAAA,EAA7C,CAAN;EACD;EAED,OAAOG,GAAG,GAAG,IAAb;AACD;AAED;;;;;;;;AAOA,SAASE,yCAATA,CACEN,MADF;EAGE,MAAM;IAAEC,UAAF;IAAcC,aAAd;IAA6BC;EAA7B,IAA6CH,MAAnD;EAEA,IAAII,GAAJ;EACA,MAAMG,aAAa,GAAGL,aAAa,GAAGrD,IAAI,CAACC,GAAL,CAASqD,WAAT,EAAsB,CAAtB,CAAtC;EAEA,IAAIF,UAAU,KAAK,GAAnB,EAAwB;IACtBG,GAAG,GAAI,OAAOF,aAAR,IAA0B,OAAO,MAAMK,aAAvC,CAAN;EACD,CAFD,MAEO,IAAIN,UAAU,KAAK,GAAnB,EAAwB;IAC7BG,GAAG,GAAI,OAAOF,aAAR,IAA0B,OAAO,MAAMK,aAAvC,CAAN;EACD,CAFM,MAEA;IACL,MAAM,IAAIlE,KAAJ,oCAA6C4D,UAAA,EAA7C,CAAN;EACD;EACD,OAAOG,GAAG,GAAG,IAAb;AACD;AC3CD,SAASI,4BAATA,CACER,MADF;EAGE,MAAM;IAAEE,aAAF;IAAiBC;EAAjB,IAAiCH,MAAvC;EAEA,IAAIS,GAAG,GACL5D,IAAI,CAACC,GAAL,CAASoD,aAAT,EAAwB,KAAxB,IAAiCrD,IAAI,CAACC,GAAL,CAASqD,WAAW,GAAG,GAAvB,EAA4B,KAA5B,CAAjC,GAAsE,KADxE;EAGA,OAAOM,GAAP;AACD;;ACfD;;;;;;;;;;;;AAWA,SAAwBC,mBAAmBC,KAAA;EAKzC,MAAM;IACJC,gCADI;IAEJC,4BAFI;IAGJhC;EAHI,IAIF8B,KAJJ;EAMA,IAAIvD,IAAJ;EACA,IAAI5B,IAAJ;EACA,IAAIoF,gCAAJ,EAAsC;IACpC,OAAOnC,2BAA2B,CAACmC,gCAAD,CAAlC;EACD,CAFD,MAEO,IAAIC,4BAA4B,IAAIhC,UAApC,EAAgD;IACrD;IACA;IACA;IACAzB,IAAI,GAAGiB,OAAO,CAACwC,4BAAD,CAAd;IACArF,IAAI,GAAG4C,OAAO,CAACS,UAAD,CAAd;IAEA,OAAO1B,eAAe,CAAC3B,IAAD,EAAO4B,IAAP,CAAtB;EACD;EAED,MAAM,IAAIf,KAAJ,mBAA4BsE,KAAA,EAA5B,CAAN;AACD;;ACfD;;;;;;;;AAOA,SAASG,wBAATA,CAAkClC,SAAlC;EACE,MAAM;IACJmC,qBADI;IAEJC,oBAFI;IAGJJ,gCAHI;IAIJC,4BAJI;IAKJhC;EALI,IAMFD,SAAS,CAAC,CAAD,CANb;EAQA,IAAImC,qBAAqB,KAAK7E,SAA1B,IAAuC6E,qBAAqB,KAAK,IAArE,EAA2E;IACzE,MAAM,IAAI1E,KAAJ,CACJ,mEADI,CAAN;EAGD;EAED,IAAI2E,oBAAoB,KAAK9E,SAAzB,IAAsC8E,oBAAoB,KAAK,IAAnE,EAAyE;IACvE,MAAM,IAAI3E,KAAJ,CACJ,kEADI,CAAN;EAGD;EAED,MAAM4E,SAAS,GAAwBtC,kBAAkB,CAACC,SAAD,CAAzD;EACA,MAAMsC,SAAS,GAAsBR,kBAAkB,CAAC;IACtDE,gCADsD;IAEtDC,4BAFsD;IAGtDhC;EAHsD,CAAD,CAAvD;EAMA,OAAOD,SAAS,CAACuC,GAAV,CAAc,CAACC,CAAD,EAAIC,KAAJ;IACnB,MAAMC,QAAQ,GAAGL,SAAS,CAACI,KAAD,CAA1B;IACA,MAAME,cAAc,GAClBD,QAAQ,CAAC5F,YAAT,KAA0BwF,SAAS,CAACxF,YAAV,EAD5B;IAEA,IAAI6F,cAAc,GAAG,CAArB,EAAwB;MACtB,MAAM,IAAIlF,KAAJ,CAAU,qCAAV,CAAN;IACD;IAED,MAAMmF,WAAW,GACfT,qBAAqB,GACrBlE,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,CAACyE,cAAD,GAAkBP,oBAA9B,CAFF;IAIA,OAAO,IAAIQ,WAAX;EACD,CAbM,CAAP;AAcD;AAED;;;;;;;AAMA,MAAMC,UAAU,GAAGA,CACjBC,CADiB,EAEjBC,CAFiB;EAIjB,OACED,CAAC,KAAKC,CAAN,IACC1C,KAAK,CAAC2C,OAAN,CAAcF,CAAd,KACCzC,KAAK,CAAC2C,OAAN,CAAcD,CAAd,CADD,IAECD,CAAC,CAACzF,MAAF,KAAa0F,CAAC,CAAC1F,MAFhB,IAGCyF,CAAC,CAACG,KAAF,CAAQ,CAACC,GAAD,EAAMT,KAAN,KAAgBS,GAAG,KAAKH,CAAC,CAACN,KAAD,CAAjC,CALJ;AAOD,CAXD;AAaA;;;;;;;;;;;AAUA,SAAwBU,2BACtBnD,SAAA;EAEA,MAAM;IACJoD,cADI;IAEJC,KAFI;IAGJC,sBAHI;IAIJhC,aAJI;IAKJD,UALI;IAMJE;EANI,IAOFvB,SAAS,CAAC,CAAD,CAPb;EASA,IAAI,CAACoD,cAAc,CAACG,QAAf,CAAwB,MAAxB,CAAD,IAAoC,CAACH,cAAc,CAACG,QAAf,CAAwB,MAAxB,CAAzC,EAA0E;IACxE,MAAM,IAAI9F,KAAJ,mDAC8C2F,cAAA,EAD9C,CAAN;EAGD;EAGD;EACA;;EACA,MAAMI,cAAc,GAAGxD,SAAS,CAACiD,KAAV,CAAgBrC,QAAQ;IAC7C,OACEA,QAAQ,CAACyC,KAAT,KAAmBA,KAAnB,IACAR,UAAU,CAACjC,QAAQ,CAACwC,cAAV,EAA0BA,cAA1B,CADV,IAEAxC,QAAQ,CAACU,aAAT,KAA2BA,aAF3B,IAGAV,QAAQ,CAACS,UAAT,KAAwBA,UAHxB,IAIAT,QAAQ,CAACW,WAAT,KAAyBA,WAJzB,IAKAX,QAAQ,CAACwB,oBAAT,KAAkCpC,SAAS,CAAC,CAAD,CAAT,CAAaoC,oBAL/C,IAMAxB,QAAQ,CAACuB,qBAAT,KAAmCnC,SAAS,CAAC,CAAD,CAAT,CAAamC,qBANhD,IAOAvB,QAAQ,CAAC6C,eAAT,KAA6BzD,SAAS,CAAC,CAAD,CAAT,CAAayD,eAP1C,IAQA7C,QAAQ,CAACX,UAAT,KAAwBD,SAAS,CAAC,CAAD,CAAT,CAAaC,UARrC,IASAW,QAAQ,CAACV,UAAT,KAAwBF,SAAS,CAAC,CAAD,CAAT,CAAaE,UAVvC;EAYD,CAbsB,CAAvB;EAeA,IAAI,CAACsD,cAAL,EAAqB;IACnB,MAAM,IAAI/F,KAAJ,CACJ,8IADI,CAAN;EAGD;;EAGD,IAAI,CAAC6D,aAAL,EAAoB;IAClB,MAAM,IAAI7D,KAAJ,CACJ,iFADI,CAAN;EAGD;EAED,IAAIiG,oBAAoB,GAAa,IAAIrD,KAAJ,CAAUL,SAAS,CAAC3C,MAApB,CAArC;EACAqG,oBAAoB,GAAGxB,wBAAwB,CAAClC,SAAD,CAA/C;EAEA,IAAII,OAAO,GAAa,IAAIC,KAAJ,CAAUL,SAAS,CAAC3C,MAApB,CAAxB;EACA,MAAMsG,aAAa,GAAWrC,aAAa,GAAG,IAA9C;EAEA,IAAI+B,KAAK,KAAK,MAAd,EAAsB;IACpBjD,OAAO,GAAGsD,oBAAoB,CAACnB,GAArB,CAAyB,UAASqB,KAAT;MACjC,OAAOA,KAAK,GAAGD,aAAf;IACD,CAFS,CAAV;EAGD,CAJD,MAIO,IAAIN,KAAK,KAAK,MAAd,EAAsB;IAC3B,MAAMQ,sBAAsB,GAAY7D,SAAS,CAACiD,KAAV,CAAgBrC,QAAQ;;MAC9D,OACEA,QAAQ,CAAC0C,sBAAT,IACA,EAAAQ,qBAAA,GAAAlD,QAAQ,CAAC0C,sBAAT,cAAAQ,qBAAA,uBAAAA,qBAAA,CAAiCC,cAAjC,MAAoD,IADpD,IAEA,EAAAC,sBAAA,GAAApD,QAAQ,CAAC0C,sBAAT,cAAAU,sBAAA,uBAAAA,sBAAA,CAAiCD,cAAjC,MAAoDzG,SAFpD,IAGA,EAAA2G,sBAAA,GAAArD,QAAQ,CAAC0C,sBAAT,cAAAW,sBAAA,uBAAAA,sBAAA,CAAiCF,cAAjC,MAAoD,CAJtD;IAMD,CAPuC,CAAxC;IASA,MAAMG,wCAAwC,GAAYlE,SAAS,CAACiD,KAAV,CACxDrC,QAAQ;;MACN,OACEA,QAAQ,CAAC0C,sBAAT,IACA,GAAAa,sBAAA,GAACvD,QAAQ,CAAC0C,sBAAV,cAAAa,sBAAA,eAACA,sBAAA,CAAiCJ,cAAlC,CADA,IAEA,EAAAK,sBAAA,GAAAxD,QAAQ,CAAC0C,sBAAT,cAAAc,sBAAA,uBAAAA,sBAAA,CAAiCC,gCAAjC,MACE/G,SAHF,IAIA,EAAAgH,sBAAA,GAAA1D,QAAQ,CAAC0C,sBAAT,cAAAgB,sBAAA,uBAAAA,sBAAA,CAAiCD,gCAAjC,MACE,CANJ;IAQD,CAVuD,CAA1D,CAV2B;IAwB3B;;IAEA,IAAIR,sBAAJ,EAA4B;MAC1BzD,OAAO,GAAGJ,SAAS,CAACuC,GAAV;MAAA;MAER;MACA3B,QAAQ,IAAIA,QAAQ,CAAC0C,sBAAT,CAAiCS,cAHrC,CAAV;IAKD,CAND,MAMO,IAAIG,wCAAJ,EAA8C;MACnD;MACA;MACA9D,OAAO,GAAGJ,SAAS,CAACuC,GAAV,CAAc,CAAC3B,QAAD,EAAW6B,KAAX;QACtB;QACA;QACA,OACE7B,QAAQ,CAAC0C,sBAAT,CAAiCe,gCAAjC,GACAX,oBAAoB,CAACjB,KAAD,CADpB,GAEAkB,aAHF;MAKD,CARS,CAAV;IASD,CAZM,MAYA;MACL,MAAM,IAAIlG,KAAJ,sEACiE8G,IAAI,CAACC,SAAL,CACnElB,sBADmE,GADjE,CAAN;IAKD;EACF,CAnDM,MAmDA,IAAID,KAAK,KAAK,KAAd,EAAqB;IAC1B;IACAjD,OAAO,CAACc,IAAR,CAAa,CAAb;EACD,CAHM,MAGA;IACL,MAAM,IAAIzD,KAAJ,gCAAyC4F,KAAA,EAAzC,CAAN;EACD;;EAGD,IAAIoB,YAAJ;EACA,IAAIlD,WAAW,KAAK,IAAhB,IAAwBA,WAAW,KAAKjE,SAA5C,EAAuD;IACrDoH,OAAO,CAACC,IAAR,CACE,mFADF;EAGD,CAJD,MAIO;IACL,MAAMC,SAAS,GAA6B;MAC1CtD,aAD0C;MAE1CC;IAF0C,CAA5C;IAKAkD,YAAY,GAAG7C,4BAA4B,CAACgD,SAAD,CAA3C;EACD;;EAGD,IAAIC,YAAJ;EACA,IAAIC,iBAAJ;EACA,IAAIvD,WAAW,KAAK,IAAhB,IAAwBA,WAAW,KAAKjE,SAA5C,EAAuD;IACrDoH,OAAO,CAACC,IAAR,CACE,mFADF;EAGD,CAJD,MAIO,IAAItD,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK/D,SAA1C,EAAqD;IAC1DoH,OAAO,CAACC,IAAR,CACE,kFADF;EAGD,CAJM,MAIA;IACL,MAAMI,YAAY,GAA6B;MAC7CzD,aAD6C;MAE7CD,UAF6C;MAG7CE;IAH6C,CAA/C;IAMAsD,YAAY,GAAG1D,4BAA4B,CAAC4D,YAAD,CAA3C;IACAD,iBAAiB,GAAGpD,yCAAyC,CAACqD,YAAD,CAA7D;EACD;EAED,OAAO3E,OAAO,CAACmC,GAAR,CAAY,UAASyC,MAAT,EAAiBvC,KAAjB;IACjB,MAAMwC,OAAO,GAAwB;MACnCC,KAAK,EAAEF;IAD4B,CAArC;IAIA,IAAIP,YAAJ,EAAkB;MAChB;MACAQ,OAAO,CAACE,MAAR,GAAiBzB,oBAAoB,CAACjB,KAAD,CAApB,GAA8BgC,YAA/C;IACD;IAED,IAAII,YAAJ,EAAkB;MAChB;MACAI,OAAO,CAACG,MAAR,GAAiB1B,oBAAoB,CAACjB,KAAD,CAApB,GAA8BoC,YAA/C;IACD;IAED,IAAIC,iBAAJ,EAAuB;MACrBG,OAAO,CAACI,WAAR,GAAsB3B,oBAAoB,CAACjB,KAAD,CAApB,GAA8BqC,iBAApD;IACD;IAGD;;IAEA,OAAOG,OAAP;EACD,CAvBM,CAAP;AAwBD"},"metadata":{},"sourceType":"module","externalDependencies":[]}