"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const contours_1 = require("../contours");
const SegmentationRepresentations_1 = __importDefault(require("../../enums/SegmentationRepresentations"));
const findLargestBidirectional_1 = __importDefault(require("./findLargestBidirectional"));
const { Labelmap } = SegmentationRepresentations_1.default;
function contourAndFindLargestBidirectional(segmentation) {
    const contours = (0, contours_1.generateContourSetsFromLabelmap)({
        segmentations: segmentation,
    });
    if (!(contours === null || contours === void 0 ? void 0 : contours.length) || !contours[0].sliceContours.length) {
        return;
    }
    const { representationData, segments = [
        null,
        { label: 'Unspecified', color: null, containedSegmentIndices: null },
    ], } = segmentation;
    const { volumeId: segVolumeId } = representationData[Labelmap];
    const segmentIndex = segments.findIndex((it) => !!it);
    if (segmentIndex === -1) {
        return;
    }
    segments[segmentIndex].segmentIndex = segmentIndex;
    return (0, findLargestBidirectional_1.default)(contours[0], segVolumeId, segments[segmentIndex]);
}
exports.default = contourAndFindLargestBidirectional;
//# sourceMappingURL=contourAndFindLargestBidirectional.js.map