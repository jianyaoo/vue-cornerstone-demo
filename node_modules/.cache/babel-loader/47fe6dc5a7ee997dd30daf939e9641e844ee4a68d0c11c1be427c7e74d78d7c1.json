{"ast":null,"code":"import { triggerSegmentationDataModified } from '../../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { config as segmentationConfig } from '../../../../stateManagement/segmentation';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n  [StrategyCallbacks.Preview]: function (operationData) {\n    const {\n      previewColors,\n      strategySpecificConfiguration,\n      enabledElement\n    } = operationData;\n    if (!previewColors || !strategySpecificConfiguration) {\n      return;\n    }\n    if (operationData.preview) {\n      delete operationData.preview;\n    }\n    delete strategySpecificConfiguration.centerSegmentIndex;\n    this.onInteractionStart?.(enabledElement, operationData);\n    const preview = this.fill(enabledElement, operationData);\n    if (preview) {\n      preview.isPreviewFromHover = true;\n      operationData.preview = preview;\n      this.onInteractionEnd?.(enabledElement, operationData);\n    }\n    return preview;\n  },\n  [StrategyCallbacks.Initialize]: operationData => {\n    const {\n      toolGroupId,\n      segmentIndex,\n      segmentationRepresentationUID,\n      previewSegmentIndex,\n      previewColors,\n      preview\n    } = operationData;\n    if (previewColors === undefined) {\n      return;\n    }\n    if (preview) {\n      preview.previewVoxelManager.sourceVoxelManager = operationData.segmentationVoxelManager;\n      operationData.previewVoxelManager = preview.previewVoxelManager;\n    }\n    if (segmentIndex === null || !previewSegmentIndex) {\n      return;\n    }\n    const configColor = previewColors?.[segmentIndex];\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(toolGroupId, segmentationRepresentationUID, segmentIndex);\n    if (!configColor && !segmentColor) {\n      return;\n    }\n    const previewColor = configColor || segmentColor.map(it => it * 0.9);\n    segmentationConfig.color.setColorForSegmentIndex(toolGroupId, segmentationRepresentationUID, previewSegmentIndex, previewColor);\n  },\n  [StrategyCallbacks.AcceptPreview]: operationData => {\n    const {\n      segmentationVoxelManager: segmentationVoxelManager,\n      previewVoxelManager: previewVoxelManager,\n      previewSegmentIndex,\n      preview\n    } = operationData;\n    if (previewSegmentIndex === undefined) {\n      return;\n    }\n    const segmentIndex = preview?.segmentIndex ?? operationData.segmentIndex;\n    const tracking = previewVoxelManager;\n    if (!tracking || tracking.modifiedSlices.size === 0) {\n      return;\n    }\n    const callback = ({\n      index\n    }) => {\n      const oldValue = segmentationVoxelManager.getAtIndex(index);\n      if (oldValue === previewSegmentIndex) {\n        segmentationVoxelManager.setAtIndex(index, segmentIndex);\n      }\n    };\n    tracking.forEach(callback, {});\n    triggerSegmentationDataModified(operationData.segmentationId, tracking.getArrayOfSlices());\n    tracking.clear();\n  },\n  [StrategyCallbacks.RejectPreview]: operationData => {\n    const {\n      previewVoxelManager: previewVoxelManager,\n      segmentationVoxelManager: segmentationVoxelManager\n    } = operationData;\n    if (previewVoxelManager.modifiedSlices.size === 0) {\n      return;\n    }\n    const callback = ({\n      index,\n      value\n    }) => {\n      segmentationVoxelManager.setAtIndex(index, value);\n    };\n    previewVoxelManager.forEach(callback);\n    triggerSegmentationDataModified(operationData.segmentationId, previewVoxelManager.getArrayOfSlices());\n    previewVoxelManager.clear();\n  }\n};","map":{"version":3,"names":["triggerSegmentationDataModified","config","segmentationConfig","StrategyCallbacks","Preview","operationData","previewColors","strategySpecificConfiguration","enabledElement","preview","centerSegmentIndex","onInteractionStart","fill","isPreviewFromHover","onInteractionEnd","Initialize","toolGroupId","segmentIndex","segmentationRepresentationUID","previewSegmentIndex","undefined","previewVoxelManager","sourceVoxelManager","segmentationVoxelManager","configColor","segmentColor","color","getColorForSegmentIndex","previewColor","map","it","setColorForSegmentIndex","AcceptPreview","tracking","modifiedSlices","size","callback","index","oldValue","getAtIndex","setAtIndex","forEach","segmentationId","getArrayOfSlices","clear","RejectPreview","value"],"sources":["../../../../../../src/tools/segmentation/strategies/compositions/preview.ts"],"sourcesContent":[null],"mappings":"AAEA,SAASA,+BAA+B,QAAQ,oEAAoE;AACpH,SAASC,MAAM,IAAIC,kBAAkB,QAAQ,0CAA0C;AACvF,OAAOC,iBAAiB,MAAM,qCAAqC;AASnE,eAAe;EACb,CAACA,iBAAiB,CAACC,OAAO,GAAG,UAC3BC,aAAuC;IAEvC,MAAM;MAAEC,aAAa;MAAEC,6BAA6B;MAAEC;IAAc,CAAE,GACpEH,aAAa;IACf,IAAI,CAACC,aAAa,IAAI,CAACC,6BAA6B,EAAE;MACpD;;IAIF,IAAIF,aAAa,CAACI,OAAO,EAAE;MACzB,OAAOJ,aAAa,CAACI,OAAO;;IAE9B,OAAOF,6BAA6B,CAACG,kBAAkB;IAGvD,IAAI,CAACC,kBAAkB,GAAGH,cAAc,EAAEH,aAAa,CAAC;IACxD,MAAMI,OAAO,GAAG,IAAI,CAACG,IAAI,CAACJ,cAAc,EAAEH,aAAa,CAAC;IACxD,IAAII,OAAO,EAAE;MACXA,OAAO,CAACI,kBAAkB,GAAG,IAAI;MACjCR,aAAa,CAACI,OAAO,GAAGA,OAAO;MAC/B,IAAI,CAACK,gBAAgB,GAAGN,cAAc,EAAEH,aAAa,CAAC;;IAExD,OAAOI,OAAO;EAChB,CAAC;EAED,CAACN,iBAAiB,CAACY,UAAU,GAAIV,aAAuC,IAAI;IAC1E,MAAM;MACJW,WAAW;MACXC,YAAY;MACZC,6BAA6B;MAC7BC,mBAAmB;MACnBb,aAAa;MACbG;IAAO,CACR,GAAGJ,aAAa;IACjB,IAAIC,aAAa,KAAKc,SAAS,EAAE;MAC/B;;IAEF,IAAIX,OAAO,EAAE;MACXA,OAAO,CAACY,mBAAmB,CAACC,kBAAkB,GAC5CjB,aAAa,CAACkB,wBAAwB;MAExClB,aAAa,CAACgB,mBAAmB,GAAGZ,OAAO,CAACY,mBAAmB;;IAGjE,IAAIJ,YAAY,KAAK,IAAI,IAAI,CAACE,mBAAmB,EAAE;MAEjD;;IAGF,MAAMK,WAAW,GAAGlB,aAAa,GAAGW,YAAY,CAAC;IACjD,MAAMQ,YAAY,GAAGvB,kBAAkB,CAACwB,KAAK,CAACC,uBAAuB,CACnEX,WAAW,EACXE,6BAA6B,EAC7BD,YAAY,CACb;IACD,IAAI,CAACO,WAAW,IAAI,CAACC,YAAY,EAAE;MACjC;;IAEF,MAAMG,YAAY,GAAGJ,WAAW,IAAIC,YAAY,CAACI,GAAG,CAAEC,EAAE,IAAKA,EAAE,GAAG,GAAG,CAAC;IACtE5B,kBAAkB,CAACwB,KAAK,CAACK,uBAAuB,CAC9Cf,WAAW,EACXE,6BAA6B,EAC7BC,mBAAmB,EACnBS,YAA2B,CAC5B;EACH,CAAC;EAED,CAACzB,iBAAiB,CAAC6B,aAAa,GAC9B3B,aAAuC,IACrC;IACF,MAAM;MACJkB,wBAAwB,EAAEA,wBAAwB;MAClDF,mBAAmB,EAAEA,mBAAmB;MACxCF,mBAAmB;MACnBV;IAAO,CACR,GAAGJ,aAAa;IACjB,IAAIc,mBAAmB,KAAKC,SAAS,EAAE;MACrC;;IAEF,MAAMH,YAAY,GAAGR,OAAO,EAAEQ,YAAY,IAAIZ,aAAa,CAACY,YAAY;IACxE,MAAMgB,QAAQ,GAAGZ,mBAAmB;IACpC,IAAI,CAACY,QAAQ,IAAIA,QAAQ,CAACC,cAAc,CAACC,IAAI,KAAK,CAAC,EAAE;MACnD;;IAGF,MAAMC,QAAQ,GAAGA,CAAC;MAAEC;IAAK,CAAE,KAAI;MAC7B,MAAMC,QAAQ,GAAGf,wBAAwB,CAACgB,UAAU,CAACF,KAAK,CAAC;MAC3D,IAAIC,QAAQ,KAAKnB,mBAAmB,EAAE;QACpCI,wBAAwB,CAACiB,UAAU,CAACH,KAAK,EAAEpB,YAAY,CAAC;;IAE5D,CAAC;IACDgB,QAAQ,CAACQ,OAAO,CAACL,QAAQ,EAAE,EAAE,CAAC;IAE9BpC,+BAA+B,CAC7BK,aAAa,CAACqC,cAAc,EAC5BT,QAAQ,CAACU,gBAAgB,EAAE,CAC5B;IACDV,QAAQ,CAACW,KAAK,EAAE;EAClB,CAAC;EAED,CAACzC,iBAAiB,CAAC0C,aAAa,GAC9BxC,aAAuC,IACrC;IACF,MAAM;MACJgB,mBAAmB,EAAEA,mBAAmB;MACxCE,wBAAwB,EAAEA;IAAwB,CACnD,GAAGlB,aAAa;IACjB,IAAIgB,mBAAmB,CAACa,cAAc,CAACC,IAAI,KAAK,CAAC,EAAE;MACjD;;IAGF,MAAMC,QAAQ,GAAGA,CAAC;MAAEC,KAAK;MAAES;IAAK,CAAE,KAAI;MACpCvB,wBAAwB,CAACiB,UAAU,CAACH,KAAK,EAAES,KAAK,CAAC;IACnD,CAAC;IACDzB,mBAAmB,CAACoB,OAAO,CAACL,QAAQ,CAAC;IAErCpC,+BAA+B,CAC7BK,aAAa,CAACqC,cAAc,EAC5BrB,mBAAmB,CAACsB,gBAAgB,EAAE,CACvC;IACDtB,mBAAmB,CAACuB,KAAK,EAAE;EAC7B;CACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}