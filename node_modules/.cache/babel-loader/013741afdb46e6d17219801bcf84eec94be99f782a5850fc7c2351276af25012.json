{"ast":null,"code":"import Constants from './DataArray/Constants.js';\nimport { n as newInstance$1, a as newTypedArray, b as newTypedArrayFrom, o as obj, s as set, c as macro } from '../../macros2.js';\nimport { n as norm } from './Math/index.js';\nconst {\n  vtkErrorMacro\n} = macro;\nconst {\n  DefaultDataType\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\nconst EPSILON = 1e-6;\n\n// Original source from https://www.npmjs.com/package/compute-range\n// Modified to accept type arrays\nfunction fastComputeRange(arr, offset, numberOfComponents) {\n  const len = arr.length;\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let x;\n  let i;\n\n  // find first non-NaN value\n  for (i = offset; i < len; i += numberOfComponents) {\n    if (!Number.isNaN(arr[i])) {\n      min = arr[i];\n      max = min;\n      break;\n    }\n  }\n  for (; i < len; i += numberOfComponents) {\n    x = arr[i];\n    if (x < min) {\n      min = x;\n    } else if (x > max) {\n      max = x;\n    }\n  }\n  return {\n    min,\n    max\n  };\n}\n\n/**\n * @deprecated please use fastComputeRange instead\n */\nfunction createRangeHelper() {\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let count = 0;\n  let sum = 0;\n  return {\n    add(value) {\n      if (min > value) {\n        min = value;\n      }\n      if (max < value) {\n        max = value;\n      }\n      count++;\n      sum += value;\n    },\n    get() {\n      return {\n        min,\n        max,\n        count,\n        sum,\n        mean: sum / count\n      };\n    },\n    getRange() {\n      return {\n        min,\n        max\n      };\n    }\n  };\n}\nfunction computeRange(values) {\n  let component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let numberOfComponents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (component < 0 && numberOfComponents > 1) {\n    // Compute magnitude\n    const size = values.length;\n    const numberOfValues = size / numberOfComponents;\n    const data = new Float64Array(numberOfValues);\n    for (let i = 0, j = 0; i < numberOfValues; ++i) {\n      for (let nextJ = j + numberOfComponents; j < nextJ; ++j) {\n        data[i] += values[j] * values[j];\n      }\n      data[i] **= 0.5;\n    }\n    return fastComputeRange(data, 0, 1);\n  }\n  return fastComputeRange(values, component < 0 ? 0 : component, numberOfComponents);\n}\nfunction ensureRangeSize(rangeArray) {\n  let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const ranges = rangeArray || [];\n  // Pad ranges with null value to get the\n  while (ranges.length <= size) {\n    ranges.push(null);\n  }\n  return ranges;\n}\nfunction getDataType(typedArray) {\n  // Expects toString() to return \"[object ...Array]\"\n  return Object.prototype.toString.call(typedArray).slice(8, -1);\n}\nfunction getMaxNorm(normArray) {\n  const numComps = normArray.getNumberOfComponents();\n  let maxNorm = 0.0;\n  const tuple = new Array(numComps);\n  for (let i = 0; i < normArray.getNumberOfTuples(); ++i) {\n    normArray.getTuple(i, tuple);\n    const norm$1 = norm(tuple, numComps);\n    if (norm$1 > maxNorm) {\n      maxNorm = norm$1;\n    }\n  }\n  return maxNorm;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  computeRange,\n  createRangeHelper,\n  fastComputeRange,\n  getDataType,\n  getMaxNorm\n};\n\n// ----------------------------------------------------------------------------\n// vtkDataArray methods\n// ----------------------------------------------------------------------------\n\nfunction vtkDataArray(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkDataArray');\n\n  /**\n   * Resize model.values and copy the old values to the new array.\n   * @param {Number} requestedNumTuples Final expected number of tuples; must be >= 0\n   * @returns {Boolean} True if a resize occured, false otherwise\n   */\n  function resize(requestedNumTuples) {\n    if (requestedNumTuples < 0) {\n      return false;\n    }\n    const numComps = publicAPI.getNumberOfComponents();\n    const curNumTuples = model.values.length / (numComps > 0 ? numComps : 1);\n    if (requestedNumTuples === curNumTuples) {\n      return true;\n    }\n    if (requestedNumTuples > curNumTuples) {\n      // Requested size is bigger than current size.  Allocate enough\n      // memory to fit the requested size and be more than double the\n      // currently allocated memory.\n      const oldValues = model.values;\n      model.values = newTypedArray(model.dataType, (requestedNumTuples + curNumTuples) * numComps);\n      model.values.set(oldValues);\n      return true;\n    }\n\n    // Requested size is smaller than currently allocated size\n    if (model.size > requestedNumTuples * numComps) {\n      model.size = requestedNumTuples * numComps;\n      publicAPI.dataChange();\n    }\n    return true;\n  }\n  publicAPI.dataChange = () => {\n    model.ranges = null;\n    publicAPI.modified();\n  };\n  publicAPI.resize = requestedNumTuples => {\n    resize(requestedNumTuples);\n    const newSize = requestedNumTuples * publicAPI.getNumberOfComponents();\n    if (model.size !== newSize) {\n      model.size = newSize;\n      publicAPI.dataChange();\n      return true;\n    }\n    return false;\n  };\n\n  // FIXME, to rename into \"clear()\" or \"reset()\"\n  publicAPI.initialize = () => {\n    publicAPI.resize(0);\n  };\n  publicAPI.getElementComponentSize = () => model.values.BYTES_PER_ELEMENT;\n\n  // Description:\n  // Return the data component at the location specified by tupleIdx and\n  // compIdx.\n  publicAPI.getComponent = function (tupleIdx) {\n    let compIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return model.values[tupleIdx * model.numberOfComponents + compIdx];\n  };\n\n  // Description:\n  // Set the data component at the location specified by tupleIdx and compIdx\n  // to value.\n  // Note that i is less than NumberOfTuples and j is less than\n  //  NumberOfComponents. Make sure enough memory has been allocated\n  // (use SetNumberOfTuples() and SetNumberOfComponents()).\n  publicAPI.setComponent = (tupleIdx, compIdx, value) => {\n    if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {\n      model.values[tupleIdx * model.numberOfComponents + compIdx] = value;\n      publicAPI.dataChange();\n    }\n  };\n  publicAPI.getValue = valueIdx => {\n    const idx = valueIdx / model.numberOfComponents;\n    const comp = valueIdx % model.numberOfComponents;\n    return publicAPI.getComponent(idx, comp);\n  };\n  publicAPI.setValue = (valueIdx, value) => {\n    const idx = valueIdx / model.numberOfComponents;\n    const comp = valueIdx % model.numberOfComponents;\n    publicAPI.setComponent(idx, comp, value);\n  };\n  publicAPI.getData = () => model.size === model.values.length ? model.values : model.values.subarray(0, model.size);\n  publicAPI.getRange = function () {\n    let componentIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n    let rangeIdx = componentIndex;\n    if (rangeIdx < 0) {\n      // If scalar data, then store in slot 0 (same as componentIndex = 0).\n      // If vector data, then store in last slot.\n      rangeIdx = model.numberOfComponents === 1 ? 0 : model.numberOfComponents;\n    }\n    let range = null;\n    if (!model.ranges) {\n      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);\n    }\n    range = model.ranges[rangeIdx];\n    if (range) {\n      model.rangeTuple[0] = range.min;\n      model.rangeTuple[1] = range.max;\n      return model.rangeTuple;\n    }\n\n    // Need to compute ranges...\n    range = computeRange(publicAPI.getData(), componentIndex, model.numberOfComponents);\n    model.ranges[rangeIdx] = range;\n    model.rangeTuple[0] = range.min;\n    model.rangeTuple[1] = range.max;\n    return model.rangeTuple;\n  };\n  publicAPI.setRange = (rangeValue, componentIndex) => {\n    if (!model.ranges) {\n      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);\n    }\n    const range = {\n      min: rangeValue.min,\n      max: rangeValue.max\n    };\n    model.ranges[componentIndex] = range;\n    model.rangeTuple[0] = range.min;\n    model.rangeTuple[1] = range.max;\n    return model.rangeTuple;\n  };\n  publicAPI.setTuple = (idx, tuple) => {\n    const offset = idx * model.numberOfComponents;\n    for (let i = 0; i < model.numberOfComponents; i++) {\n      model.values[offset + i] = tuple[i];\n    }\n  };\n  publicAPI.setTuples = (idx, tuples) => {\n    let i = idx * model.numberOfComponents;\n    const last = Math.min(tuples.length, model.size - i);\n    for (let j = 0; j < last;) {\n      model.values[i++] = tuples[j++];\n    }\n  };\n  publicAPI.insertTuple = (idx, tuple) => {\n    if (model.size <= idx * model.numberOfComponents) {\n      model.size = (idx + 1) * model.numberOfComponents;\n      resize(idx + 1);\n    }\n    publicAPI.setTuple(idx, tuple);\n    return idx;\n  };\n  publicAPI.insertTuples = (idx, tuples) => {\n    const end = idx + tuples.length / model.numberOfComponents;\n    if (model.size < end * model.numberOfComponents) {\n      model.size = end * model.numberOfComponents;\n      resize(end);\n    }\n    publicAPI.setTuples(idx, tuples);\n    return end;\n  };\n  publicAPI.insertNextTuple = tuple => {\n    const idx = model.size / model.numberOfComponents;\n    return publicAPI.insertTuple(idx, tuple);\n  };\n  publicAPI.insertNextTuples = tuples => {\n    const idx = model.size / model.numberOfComponents;\n    return publicAPI.insertTuples(idx, tuples);\n  };\n  publicAPI.findTuple = function (tuple) {\n    let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSILON;\n    for (let i = 0; i < model.size; i += model.numberOfComponents) {\n      if (Math.abs(tuple[0] - model.values[i]) <= precision) {\n        let match = true;\n        for (let j = 1; j < model.numberOfComponents; ++j) {\n          if (Math.abs(tuple[j] - model.values[i + j]) > precision) {\n            match = false;\n            break;\n          }\n        }\n        if (match) {\n          return i / model.numberOfComponents;\n        }\n      }\n    }\n    return -1;\n  };\n  publicAPI.getTuple = function (idx) {\n    let tupleToFill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const numberOfComponents = model.numberOfComponents || 1;\n    const offset = idx * numberOfComponents;\n    // Check most common component sizes first\n    // to avoid doing a for loop if possible\n    switch (numberOfComponents) {\n      case 4:\n        tupleToFill[3] = model.values[offset + 3];\n      // eslint-disable-next-line no-fallthrough\n      case 3:\n        tupleToFill[2] = model.values[offset + 2];\n      // eslint-disable-next-line no-fallthrough\n      case 2:\n        tupleToFill[1] = model.values[offset + 1];\n      // eslint-disable-next-line no-fallthrough\n      case 1:\n        tupleToFill[0] = model.values[offset];\n        break;\n      default:\n        for (let i = numberOfComponents - 1; i >= 0; --i) {\n          tupleToFill[i] = model.values[offset + i];\n        }\n    }\n    return tupleToFill;\n  };\n  publicAPI.getTuples = (fromId, toId) => {\n    const from = (fromId ?? 0) * model.numberOfComponents;\n    const to = (toId ?? publicAPI.getNumberOfTuples()) * model.numberOfComponents;\n    const arr = publicAPI.getData().subarray(from, to);\n    return arr.length > 0 ? arr : null;\n  };\n  publicAPI.getTupleLocation = function () {\n    let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return idx * model.numberOfComponents;\n  };\n  publicAPI.getNumberOfComponents = () => model.numberOfComponents;\n  publicAPI.getNumberOfValues = () => model.size;\n  publicAPI.getNumberOfTuples = () => model.size / model.numberOfComponents;\n  publicAPI.getDataType = () => model.dataType;\n  /* eslint-disable no-use-before-define */\n  publicAPI.newClone = () => newInstance({\n    empty: true,\n    name: model.name,\n    dataType: model.dataType,\n    numberOfComponents: model.numberOfComponents\n  });\n  /* eslint-enable no-use-before-define */\n\n  publicAPI.getName = () => {\n    if (!model.name) {\n      publicAPI.modified();\n      model.name = `vtkDataArray${publicAPI.getMTime()}`;\n    }\n    return model.name;\n  };\n  publicAPI.setData = (typedArray, numberOfComponents) => {\n    model.values = typedArray;\n    model.size = typedArray.length;\n    model.dataType = getDataType(typedArray);\n    if (numberOfComponents) {\n      model.numberOfComponents = numberOfComponents;\n    }\n    if (model.size % model.numberOfComponents !== 0) {\n      model.numberOfComponents = 1;\n    }\n    publicAPI.dataChange();\n  };\n\n  // Override serialization support\n  publicAPI.getState = () => {\n    if (model.deleted) {\n      return null;\n    }\n    const jsonArchive = {\n      ...model,\n      vtkClass: publicAPI.getClassName()\n    };\n\n    // Convert typed array to regular array\n    jsonArchive.values = Array.from(jsonArchive.values);\n    delete jsonArchive.buffer;\n\n    // Clean any empty data\n    Object.keys(jsonArchive).forEach(keyName => {\n      if (!jsonArchive[keyName]) {\n        delete jsonArchive[keyName];\n      }\n    });\n\n    // Sort resulting object by key name\n    const sortedObj = {};\n    Object.keys(jsonArchive).sort().forEach(name => {\n      sortedObj[name] = jsonArchive[name];\n    });\n\n    // Remove mtime\n    if (sortedObj.mtime) {\n      delete sortedObj.mtime;\n    }\n    return sortedObj;\n  };\n  publicAPI.deepCopy = other => {\n    // Retain current dataType and array reference before shallowCopy call.\n    const currentType = publicAPI.getDataType();\n    const currentArray = model.values;\n    publicAPI.shallowCopy(other);\n\n    // Avoid array reallocation if size already sufficient\n    // and dataTypes match.\n    if (currentArray?.length >= other.getNumberOfValues() && currentType === other.getDataType()) {\n      currentArray.set(other.getData());\n      model.values = currentArray;\n      publicAPI.dataChange();\n    } else {\n      publicAPI.setData(other.getData().slice());\n    }\n  };\n  publicAPI.interpolateTuple = (idx, source1, source1Idx, source2, source2Idx, t) => {\n    const numberOfComponents = model.numberOfComponents || 1;\n    if (numberOfComponents !== source1.getNumberOfComponents() || numberOfComponents !== source2.getNumberOfComponents()) {\n      vtkErrorMacro('numberOfComponents must match');\n    }\n    const tuple1 = source1.getTuple(source1Idx);\n    const tuple2 = source2.getTuple(source2Idx);\n    const out = [];\n    out.length = numberOfComponents;\n\n    // Check most common component sizes first\n    // to avoid doing a for loop if possible\n    switch (numberOfComponents) {\n      case 4:\n        out[3] = tuple1[3] + (tuple2[3] - tuple1[3]) * t;\n      // eslint-disable-next-line no-fallthrough\n      case 3:\n        out[2] = tuple1[2] + (tuple2[2] - tuple1[2]) * t;\n      // eslint-disable-next-line no-fallthrough\n      case 2:\n        out[1] = tuple1[1] + (tuple2[1] - tuple1[1]) * t;\n      // eslint-disable-next-line no-fallthrough\n      case 1:\n        out[0] = tuple1[0] + (tuple2[0] - tuple1[0]) * t;\n        break;\n      default:\n        for (let i = 0; i < numberOfComponents; i++) {\n          out[i] = tuple1[i] + (tuple2[i] - tuple1[i]) * t;\n        }\n    }\n    return publicAPI.insertTuple(idx, out);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n// size: The current size of the dataArray.\n// NOTE: The underlying typed array may be larger than 'size'.\nconst DEFAULT_VALUES = {\n  name: '',\n  numberOfComponents: 1,\n  dataType: DefaultDataType,\n  rangeTuple: [0, 0]\n  // size: undefined,\n  // values: null,\n  // ranges: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  if (!model.empty && !model.values && !model.size) {\n    throw new TypeError('Cannot create vtkDataArray object without: size > 0, values');\n  }\n  if (!model.values) {\n    model.values = newTypedArray(model.dataType, model.size);\n  } else if (Array.isArray(model.values)) {\n    model.values = newTypedArrayFrom(model.dataType, model.values);\n  }\n  if (model.values) {\n    // Takes the size if provided (can be lower than `model.values`) otherwise the actual length of `values`.\n    model.size = model.size ?? model.values.length;\n    model.dataType = getDataType(model.values);\n  }\n\n  // Object methods\n  obj(publicAPI, model);\n  set(publicAPI, model, ['name', 'numberOfComponents']);\n  if (model.size % model.numberOfComponents !== 0) {\n    throw new RangeError('model.size is not a multiple of model.numberOfComponents');\n  }\n\n  // Object specific methods\n  vtkDataArray(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkDataArray');\n\n// ----------------------------------------------------------------------------\n\nvar vtkDataArray$1 = {\n  newInstance,\n  extend,\n  ...STATIC,\n  ...Constants\n};\nexport { STATIC, vtkDataArray$1 as default, extend, newInstance };","map":{"version":3,"names":["Constants","n","newInstance$1","a","newTypedArray","b","newTypedArrayFrom","o","obj","s","set","c","macro","norm","vtkErrorMacro","DefaultDataType","EPSILON","fastComputeRange","arr","offset","numberOfComponents","len","length","min","Number","MAX_VALUE","max","x","i","isNaN","createRangeHelper","count","sum","add","value","get","mean","getRange","computeRange","values","component","arguments","undefined","size","numberOfValues","data","Float64Array","j","nextJ","ensureRangeSize","rangeArray","ranges","push","getDataType","typedArray","Object","prototype","toString","call","slice","getMaxNorm","normArray","numComps","getNumberOfComponents","maxNorm","tuple","Array","getNumberOfTuples","getTuple","norm$1","STATIC","vtkDataArray","publicAPI","model","classHierarchy","resize","requestedNumTuples","curNumTuples","oldValues","dataType","dataChange","modified","newSize","initialize","getElementComponentSize","BYTES_PER_ELEMENT","getComponent","tupleIdx","compIdx","setComponent","getValue","valueIdx","idx","comp","setValue","getData","subarray","componentIndex","rangeIdx","range","rangeTuple","setRange","rangeValue","setTuple","setTuples","tuples","last","Math","insertTuple","insertTuples","end","insertNextTuple","insertNextTuples","findTuple","precision","abs","match","tupleToFill","getTuples","fromId","toId","from","to","getTupleLocation","getNumberOfValues","newClone","newInstance","empty","name","getName","getMTime","setData","getState","deleted","jsonArchive","vtkClass","getClassName","buffer","keys","forEach","keyName","sortedObj","sort","mtime","deepCopy","other","currentType","currentArray","shallowCopy","interpolateTuple","source1","source1Idx","source2","source2Idx","t","tuple1","tuple2","out","DEFAULT_VALUES","extend","initialValues","assign","TypeError","isArray","RangeError","vtkDataArray$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Common/Core/DataArray.js"],"sourcesContent":["import Constants from './DataArray/Constants.js';\nimport { n as newInstance$1, a as newTypedArray, b as newTypedArrayFrom, o as obj, s as set, c as macro } from '../../macros2.js';\nimport { n as norm } from './Math/index.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nconst {\n  DefaultDataType\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\nconst EPSILON = 1e-6;\n\n// Original source from https://www.npmjs.com/package/compute-range\n// Modified to accept type arrays\nfunction fastComputeRange(arr, offset, numberOfComponents) {\n  const len = arr.length;\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let x;\n  let i;\n\n  // find first non-NaN value\n  for (i = offset; i < len; i += numberOfComponents) {\n    if (!Number.isNaN(arr[i])) {\n      min = arr[i];\n      max = min;\n      break;\n    }\n  }\n  for (; i < len; i += numberOfComponents) {\n    x = arr[i];\n    if (x < min) {\n      min = x;\n    } else if (x > max) {\n      max = x;\n    }\n  }\n  return {\n    min,\n    max\n  };\n}\n\n/**\n * @deprecated please use fastComputeRange instead\n */\nfunction createRangeHelper() {\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let count = 0;\n  let sum = 0;\n  return {\n    add(value) {\n      if (min > value) {\n        min = value;\n      }\n      if (max < value) {\n        max = value;\n      }\n      count++;\n      sum += value;\n    },\n    get() {\n      return {\n        min,\n        max,\n        count,\n        sum,\n        mean: sum / count\n      };\n    },\n    getRange() {\n      return {\n        min,\n        max\n      };\n    }\n  };\n}\nfunction computeRange(values) {\n  let component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let numberOfComponents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (component < 0 && numberOfComponents > 1) {\n    // Compute magnitude\n    const size = values.length;\n    const numberOfValues = size / numberOfComponents;\n    const data = new Float64Array(numberOfValues);\n    for (let i = 0, j = 0; i < numberOfValues; ++i) {\n      for (let nextJ = j + numberOfComponents; j < nextJ; ++j) {\n        data[i] += values[j] * values[j];\n      }\n      data[i] **= 0.5;\n    }\n    return fastComputeRange(data, 0, 1);\n  }\n  return fastComputeRange(values, component < 0 ? 0 : component, numberOfComponents);\n}\nfunction ensureRangeSize(rangeArray) {\n  let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const ranges = rangeArray || [];\n  // Pad ranges with null value to get the\n  while (ranges.length <= size) {\n    ranges.push(null);\n  }\n  return ranges;\n}\nfunction getDataType(typedArray) {\n  // Expects toString() to return \"[object ...Array]\"\n  return Object.prototype.toString.call(typedArray).slice(8, -1);\n}\nfunction getMaxNorm(normArray) {\n  const numComps = normArray.getNumberOfComponents();\n  let maxNorm = 0.0;\n  const tuple = new Array(numComps);\n  for (let i = 0; i < normArray.getNumberOfTuples(); ++i) {\n    normArray.getTuple(i, tuple);\n    const norm$1 = norm(tuple, numComps);\n    if (norm$1 > maxNorm) {\n      maxNorm = norm$1;\n    }\n  }\n  return maxNorm;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  computeRange,\n  createRangeHelper,\n  fastComputeRange,\n  getDataType,\n  getMaxNorm\n};\n\n// ----------------------------------------------------------------------------\n// vtkDataArray methods\n// ----------------------------------------------------------------------------\n\nfunction vtkDataArray(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkDataArray');\n\n  /**\n   * Resize model.values and copy the old values to the new array.\n   * @param {Number} requestedNumTuples Final expected number of tuples; must be >= 0\n   * @returns {Boolean} True if a resize occured, false otherwise\n   */\n  function resize(requestedNumTuples) {\n    if (requestedNumTuples < 0) {\n      return false;\n    }\n    const numComps = publicAPI.getNumberOfComponents();\n    const curNumTuples = model.values.length / (numComps > 0 ? numComps : 1);\n    if (requestedNumTuples === curNumTuples) {\n      return true;\n    }\n    if (requestedNumTuples > curNumTuples) {\n      // Requested size is bigger than current size.  Allocate enough\n      // memory to fit the requested size and be more than double the\n      // currently allocated memory.\n      const oldValues = model.values;\n      model.values = newTypedArray(model.dataType, (requestedNumTuples + curNumTuples) * numComps);\n      model.values.set(oldValues);\n      return true;\n    }\n\n    // Requested size is smaller than currently allocated size\n    if (model.size > requestedNumTuples * numComps) {\n      model.size = requestedNumTuples * numComps;\n      publicAPI.dataChange();\n    }\n    return true;\n  }\n  publicAPI.dataChange = () => {\n    model.ranges = null;\n    publicAPI.modified();\n  };\n  publicAPI.resize = requestedNumTuples => {\n    resize(requestedNumTuples);\n    const newSize = requestedNumTuples * publicAPI.getNumberOfComponents();\n    if (model.size !== newSize) {\n      model.size = newSize;\n      publicAPI.dataChange();\n      return true;\n    }\n    return false;\n  };\n\n  // FIXME, to rename into \"clear()\" or \"reset()\"\n  publicAPI.initialize = () => {\n    publicAPI.resize(0);\n  };\n  publicAPI.getElementComponentSize = () => model.values.BYTES_PER_ELEMENT;\n\n  // Description:\n  // Return the data component at the location specified by tupleIdx and\n  // compIdx.\n  publicAPI.getComponent = function (tupleIdx) {\n    let compIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return model.values[tupleIdx * model.numberOfComponents + compIdx];\n  };\n\n  // Description:\n  // Set the data component at the location specified by tupleIdx and compIdx\n  // to value.\n  // Note that i is less than NumberOfTuples and j is less than\n  //  NumberOfComponents. Make sure enough memory has been allocated\n  // (use SetNumberOfTuples() and SetNumberOfComponents()).\n  publicAPI.setComponent = (tupleIdx, compIdx, value) => {\n    if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {\n      model.values[tupleIdx * model.numberOfComponents + compIdx] = value;\n      publicAPI.dataChange();\n    }\n  };\n  publicAPI.getValue = valueIdx => {\n    const idx = valueIdx / model.numberOfComponents;\n    const comp = valueIdx % model.numberOfComponents;\n    return publicAPI.getComponent(idx, comp);\n  };\n  publicAPI.setValue = (valueIdx, value) => {\n    const idx = valueIdx / model.numberOfComponents;\n    const comp = valueIdx % model.numberOfComponents;\n    publicAPI.setComponent(idx, comp, value);\n  };\n  publicAPI.getData = () => model.size === model.values.length ? model.values : model.values.subarray(0, model.size);\n  publicAPI.getRange = function () {\n    let componentIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n    let rangeIdx = componentIndex;\n    if (rangeIdx < 0) {\n      // If scalar data, then store in slot 0 (same as componentIndex = 0).\n      // If vector data, then store in last slot.\n      rangeIdx = model.numberOfComponents === 1 ? 0 : model.numberOfComponents;\n    }\n    let range = null;\n    if (!model.ranges) {\n      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);\n    }\n    range = model.ranges[rangeIdx];\n    if (range) {\n      model.rangeTuple[0] = range.min;\n      model.rangeTuple[1] = range.max;\n      return model.rangeTuple;\n    }\n\n    // Need to compute ranges...\n    range = computeRange(publicAPI.getData(), componentIndex, model.numberOfComponents);\n    model.ranges[rangeIdx] = range;\n    model.rangeTuple[0] = range.min;\n    model.rangeTuple[1] = range.max;\n    return model.rangeTuple;\n  };\n  publicAPI.setRange = (rangeValue, componentIndex) => {\n    if (!model.ranges) {\n      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);\n    }\n    const range = {\n      min: rangeValue.min,\n      max: rangeValue.max\n    };\n    model.ranges[componentIndex] = range;\n    model.rangeTuple[0] = range.min;\n    model.rangeTuple[1] = range.max;\n    return model.rangeTuple;\n  };\n  publicAPI.setTuple = (idx, tuple) => {\n    const offset = idx * model.numberOfComponents;\n    for (let i = 0; i < model.numberOfComponents; i++) {\n      model.values[offset + i] = tuple[i];\n    }\n  };\n  publicAPI.setTuples = (idx, tuples) => {\n    let i = idx * model.numberOfComponents;\n    const last = Math.min(tuples.length, model.size - i);\n    for (let j = 0; j < last;) {\n      model.values[i++] = tuples[j++];\n    }\n  };\n  publicAPI.insertTuple = (idx, tuple) => {\n    if (model.size <= idx * model.numberOfComponents) {\n      model.size = (idx + 1) * model.numberOfComponents;\n      resize(idx + 1);\n    }\n    publicAPI.setTuple(idx, tuple);\n    return idx;\n  };\n  publicAPI.insertTuples = (idx, tuples) => {\n    const end = idx + tuples.length / model.numberOfComponents;\n    if (model.size < end * model.numberOfComponents) {\n      model.size = end * model.numberOfComponents;\n      resize(end);\n    }\n    publicAPI.setTuples(idx, tuples);\n    return end;\n  };\n  publicAPI.insertNextTuple = tuple => {\n    const idx = model.size / model.numberOfComponents;\n    return publicAPI.insertTuple(idx, tuple);\n  };\n  publicAPI.insertNextTuples = tuples => {\n    const idx = model.size / model.numberOfComponents;\n    return publicAPI.insertTuples(idx, tuples);\n  };\n  publicAPI.findTuple = function (tuple) {\n    let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSILON;\n    for (let i = 0; i < model.size; i += model.numberOfComponents) {\n      if (Math.abs(tuple[0] - model.values[i]) <= precision) {\n        let match = true;\n        for (let j = 1; j < model.numberOfComponents; ++j) {\n          if (Math.abs(tuple[j] - model.values[i + j]) > precision) {\n            match = false;\n            break;\n          }\n        }\n        if (match) {\n          return i / model.numberOfComponents;\n        }\n      }\n    }\n    return -1;\n  };\n  publicAPI.getTuple = function (idx) {\n    let tupleToFill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const numberOfComponents = model.numberOfComponents || 1;\n    const offset = idx * numberOfComponents;\n    // Check most common component sizes first\n    // to avoid doing a for loop if possible\n    switch (numberOfComponents) {\n      case 4:\n        tupleToFill[3] = model.values[offset + 3];\n      // eslint-disable-next-line no-fallthrough\n      case 3:\n        tupleToFill[2] = model.values[offset + 2];\n      // eslint-disable-next-line no-fallthrough\n      case 2:\n        tupleToFill[1] = model.values[offset + 1];\n      // eslint-disable-next-line no-fallthrough\n      case 1:\n        tupleToFill[0] = model.values[offset];\n        break;\n      default:\n        for (let i = numberOfComponents - 1; i >= 0; --i) {\n          tupleToFill[i] = model.values[offset + i];\n        }\n    }\n    return tupleToFill;\n  };\n  publicAPI.getTuples = (fromId, toId) => {\n    const from = (fromId ?? 0) * model.numberOfComponents;\n    const to = (toId ?? publicAPI.getNumberOfTuples()) * model.numberOfComponents;\n    const arr = publicAPI.getData().subarray(from, to);\n    return arr.length > 0 ? arr : null;\n  };\n  publicAPI.getTupleLocation = function () {\n    let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return idx * model.numberOfComponents;\n  };\n  publicAPI.getNumberOfComponents = () => model.numberOfComponents;\n  publicAPI.getNumberOfValues = () => model.size;\n  publicAPI.getNumberOfTuples = () => model.size / model.numberOfComponents;\n  publicAPI.getDataType = () => model.dataType;\n  /* eslint-disable no-use-before-define */\n  publicAPI.newClone = () => newInstance({\n    empty: true,\n    name: model.name,\n    dataType: model.dataType,\n    numberOfComponents: model.numberOfComponents\n  });\n  /* eslint-enable no-use-before-define */\n\n  publicAPI.getName = () => {\n    if (!model.name) {\n      publicAPI.modified();\n      model.name = `vtkDataArray${publicAPI.getMTime()}`;\n    }\n    return model.name;\n  };\n  publicAPI.setData = (typedArray, numberOfComponents) => {\n    model.values = typedArray;\n    model.size = typedArray.length;\n    model.dataType = getDataType(typedArray);\n    if (numberOfComponents) {\n      model.numberOfComponents = numberOfComponents;\n    }\n    if (model.size % model.numberOfComponents !== 0) {\n      model.numberOfComponents = 1;\n    }\n    publicAPI.dataChange();\n  };\n\n  // Override serialization support\n  publicAPI.getState = () => {\n    if (model.deleted) {\n      return null;\n    }\n    const jsonArchive = {\n      ...model,\n      vtkClass: publicAPI.getClassName()\n    };\n\n    // Convert typed array to regular array\n    jsonArchive.values = Array.from(jsonArchive.values);\n    delete jsonArchive.buffer;\n\n    // Clean any empty data\n    Object.keys(jsonArchive).forEach(keyName => {\n      if (!jsonArchive[keyName]) {\n        delete jsonArchive[keyName];\n      }\n    });\n\n    // Sort resulting object by key name\n    const sortedObj = {};\n    Object.keys(jsonArchive).sort().forEach(name => {\n      sortedObj[name] = jsonArchive[name];\n    });\n\n    // Remove mtime\n    if (sortedObj.mtime) {\n      delete sortedObj.mtime;\n    }\n    return sortedObj;\n  };\n  publicAPI.deepCopy = other => {\n    // Retain current dataType and array reference before shallowCopy call.\n    const currentType = publicAPI.getDataType();\n    const currentArray = model.values;\n    publicAPI.shallowCopy(other);\n\n    // Avoid array reallocation if size already sufficient\n    // and dataTypes match.\n    if (currentArray?.length >= other.getNumberOfValues() && currentType === other.getDataType()) {\n      currentArray.set(other.getData());\n      model.values = currentArray;\n      publicAPI.dataChange();\n    } else {\n      publicAPI.setData(other.getData().slice());\n    }\n  };\n  publicAPI.interpolateTuple = (idx, source1, source1Idx, source2, source2Idx, t) => {\n    const numberOfComponents = model.numberOfComponents || 1;\n    if (numberOfComponents !== source1.getNumberOfComponents() || numberOfComponents !== source2.getNumberOfComponents()) {\n      vtkErrorMacro('numberOfComponents must match');\n    }\n    const tuple1 = source1.getTuple(source1Idx);\n    const tuple2 = source2.getTuple(source2Idx);\n    const out = [];\n    out.length = numberOfComponents;\n\n    // Check most common component sizes first\n    // to avoid doing a for loop if possible\n    switch (numberOfComponents) {\n      case 4:\n        out[3] = tuple1[3] + (tuple2[3] - tuple1[3]) * t;\n      // eslint-disable-next-line no-fallthrough\n      case 3:\n        out[2] = tuple1[2] + (tuple2[2] - tuple1[2]) * t;\n      // eslint-disable-next-line no-fallthrough\n      case 2:\n        out[1] = tuple1[1] + (tuple2[1] - tuple1[1]) * t;\n      // eslint-disable-next-line no-fallthrough\n      case 1:\n        out[0] = tuple1[0] + (tuple2[0] - tuple1[0]) * t;\n        break;\n      default:\n        for (let i = 0; i < numberOfComponents; i++) {\n          out[i] = tuple1[i] + (tuple2[i] - tuple1[i]) * t;\n        }\n    }\n    return publicAPI.insertTuple(idx, out);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n// size: The current size of the dataArray.\n// NOTE: The underlying typed array may be larger than 'size'.\nconst DEFAULT_VALUES = {\n  name: '',\n  numberOfComponents: 1,\n  dataType: DefaultDataType,\n  rangeTuple: [0, 0]\n  // size: undefined,\n  // values: null,\n  // ranges: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  if (!model.empty && !model.values && !model.size) {\n    throw new TypeError('Cannot create vtkDataArray object without: size > 0, values');\n  }\n  if (!model.values) {\n    model.values = newTypedArray(model.dataType, model.size);\n  } else if (Array.isArray(model.values)) {\n    model.values = newTypedArrayFrom(model.dataType, model.values);\n  }\n  if (model.values) {\n    // Takes the size if provided (can be lower than `model.values`) otherwise the actual length of `values`.\n    model.size = model.size ?? model.values.length;\n    model.dataType = getDataType(model.values);\n  }\n\n  // Object methods\n  obj(publicAPI, model);\n  set(publicAPI, model, ['name', 'numberOfComponents']);\n  if (model.size % model.numberOfComponents !== 0) {\n    throw new RangeError('model.size is not a multiple of model.numberOfComponents');\n  }\n\n  // Object specific methods\n  vtkDataArray(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkDataArray');\n\n// ----------------------------------------------------------------------------\n\nvar vtkDataArray$1 = {\n  newInstance,\n  extend,\n  ...STATIC,\n  ...Constants\n};\n\nexport { STATIC, vtkDataArray$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}