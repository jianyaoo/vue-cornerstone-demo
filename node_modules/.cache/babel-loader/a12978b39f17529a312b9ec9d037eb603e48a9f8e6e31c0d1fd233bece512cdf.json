{"ast":null,"code":"import { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { getVoxelOverlap, processVolumes } from './utilities';\nfunction thresholdVolumeByRange(segmentationVolume, thresholdVolumeInformation, options) {\n  const {\n    imageData: segmentationImageData\n  } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n  const {\n    overwrite,\n    boundsIJK\n  } = options;\n  const overlapType = options?.overlapType || 0;\n  if (overwrite) {\n    for (let i = 0; i < scalarData.length; i++) {\n      scalarData[i] = 0;\n    }\n  }\n  const {\n    baseVolumeIdx,\n    volumeInfoList\n  } = processVolumes(segmentationVolume, thresholdVolumeInformation);\n  let overlaps, total, range;\n  const testOverlapRange = (volumeInfo, voxelSpacing, voxelCenter) => {\n    const callbackOverlap = ({\n      value\n    }) => {\n      total = total + 1;\n      if (value >= range.lower && value <= range.upper) {\n        overlaps = overlaps + 1;\n      }\n    };\n    const {\n      imageData,\n      dimensions,\n      lower,\n      upper\n    } = volumeInfo;\n    const overlapBounds = getVoxelOverlap(imageData, dimensions, voxelSpacing, voxelCenter);\n    total = 0;\n    overlaps = 0;\n    range = {\n      lower,\n      upper\n    };\n    let overlapTest = false;\n    pointInShapeCallback(imageData, () => true, callbackOverlap, overlapBounds);\n    if (overlapType === 0) {\n      overlapTest = overlaps > 0;\n    } else if (overlapType == 1) {\n      overlapTest = overlaps === total;\n    }\n    return overlapTest;\n  };\n  const testRange = (volumeInfo, pointIJK) => {\n    const {\n      imageData,\n      referenceValues,\n      lower,\n      upper\n    } = volumeInfo;\n    const offset = imageData.computeOffsetIndex(pointIJK);\n    const value = referenceValues[offset];\n    if (value <= lower || value >= upper) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n  const callback = ({\n    index,\n    pointIJK,\n    pointLPS\n  }) => {\n    let insert = volumeInfoList.length > 0;\n    for (let i = 0; i < volumeInfoList.length; i++) {\n      if (volumeInfoList[i].volumeSize === scalarData.length) {\n        insert = testRange(volumeInfoList[i], pointIJK);\n      } else {\n        insert = testOverlapRange(volumeInfoList[i], volumeInfoList[baseVolumeIdx].spacing, pointLPS);\n      }\n      if (!insert) {\n        break;\n      }\n    }\n    if (insert) {\n      scalarData[index] = 1;\n    }\n  };\n  pointInShapeCallback(segmentationImageData, () => true, callback, boundsIJK);\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n  return segmentationVolume;\n}\nexport default thresholdVolumeByRange;","map":{"version":3,"names":["pointInShapeCallback","triggerSegmentationDataModified","getVoxelOverlap","processVolumes","thresholdVolumeByRange","segmentationVolume","thresholdVolumeInformation","options","imageData","segmentationImageData","scalarData","getScalarData","overwrite","boundsIJK","overlapType","i","length","baseVolumeIdx","volumeInfoList","overlaps","total","range","testOverlapRange","volumeInfo","voxelSpacing","voxelCenter","callbackOverlap","value","lower","upper","dimensions","overlapBounds","overlapTest","testRange","pointIJK","referenceValues","offset","computeOffsetIndex","callback","index","pointLPS","insert","volumeSize","spacing","volumeId"],"sources":["../../../../src/utilities/segmentation/thresholdVolumeByRange.ts"],"sourcesContent":[null],"mappings":"AACA,SAASA,oBAAoB,QAAQ,iBAAiB;AACtD,SAASC,+BAA+B,QAAQ,8DAA8D;AAE9G,SACEC,eAAe,EACfC,cAAc,QAET,aAAa;AA2BpB,SAASC,sBAAsBA,CAC7BC,kBAAsC,EACtCC,0BAAkD,EAClDC,OAA8B;EAE9B,MAAM;IAAEC,SAAS,EAAEC;EAAqB,CAAE,GAAGJ,kBAAkB;EAC/D,MAAMK,UAAU,GAAGL,kBAAkB,CAACM,aAAa,EAAE;EAErD,MAAM;IAAEC,SAAS;IAAEC;EAAS,CAAE,GAAGN,OAAO;EACxC,MAAMO,WAAW,GAAGP,OAAO,EAAEO,WAAW,IAAI,CAAC;EAG7C,IAAIF,SAAS,EAAE;IACb,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,UAAU,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;MAC1CL,UAAU,CAACK,CAAC,CAAC,GAAG,CAAC;;;EAIrB,MAAM;IAAEE,aAAa;IAAEC;EAAc,CAAE,GAAGf,cAAc,CACtDE,kBAAkB,EAClBC,0BAA0B,CAC3B;EAGD,IAAIa,QAAQ,EAAEC,KAAK,EAAEC,KAAK;EAE1B,MAAMC,gBAAgB,GAAGA,CAACC,UAAU,EAAEC,YAAY,EAAEC,WAAW,KAAI;IAMjE,MAAMC,eAAe,GAAGA,CAAC;MAAEC;IAAK,CAAE,KAAI;MACpCP,KAAK,GAAGA,KAAK,GAAG,CAAC;MACjB,IAAIO,KAAK,IAAIN,KAAK,CAACO,KAAK,IAAID,KAAK,IAAIN,KAAK,CAACQ,KAAK,EAAE;QAChDV,QAAQ,GAAGA,QAAQ,GAAG,CAAC;;IAE3B,CAAC;IAED,MAAM;MAAEX,SAAS;MAAEsB,UAAU;MAAEF,KAAK;MAAEC;IAAK,CAAE,GAAGN,UAAU;IAE1D,MAAMQ,aAAa,GAAG7B,eAAe,CACnCM,SAAS,EACTsB,UAAU,EACVN,YAAY,EACZC,WAAW,CACZ;IAGDL,KAAK,GAAG,CAAC;IACTD,QAAQ,GAAG,CAAC;IACZE,KAAK,GAAG;MAAEO,KAAK;MAAEC;IAAK,CAAE;IAExB,IAAIG,WAAW,GAAG,KAAK;IAGvBhC,oBAAoB,CAACQ,SAAS,EAAE,MAAM,IAAI,EAAEkB,eAAe,EAAEK,aAAa,CAAC;IAE3E,IAAIjB,WAAW,KAAK,CAAC,EAAE;MACrBkB,WAAW,GAAGb,QAAQ,GAAG,CAAC;KAC3B,MAAM,IAAIL,WAAW,IAAI,CAAC,EAAE;MAC3BkB,WAAW,GAAGb,QAAQ,KAAKC,KAAK;;IAElC,OAAOY,WAAW;EACpB,CAAC;EAGD,MAAMC,SAAS,GAAGA,CAACV,UAAU,EAAEW,QAAQ,KAAI;IACzC,MAAM;MAAE1B,SAAS;MAAE2B,eAAe;MAAEP,KAAK;MAAEC;IAAK,CAAE,GAAGN,UAAU;IAC/D,MAAMa,MAAM,GAAG5B,SAAS,CAAC6B,kBAAkB,CAACH,QAAQ,CAAC;IAErD,MAAMP,KAAK,GAAGQ,eAAe,CAACC,MAAM,CAAC;IACrC,IAAIT,KAAK,IAAIC,KAAK,IAAID,KAAK,IAAIE,KAAK,EAAE;MACpC,OAAO,KAAK;KACb,MAAM;MACL,OAAO,IAAI;;EAEf,CAAC;EAOD,MAAMS,QAAQ,GAAGA,CAAC;IAAEC,KAAK;IAAEL,QAAQ;IAAEM;EAAQ,CAAE,KAAI;IACjD,IAAIC,MAAM,GAAGvB,cAAc,CAACF,MAAM,GAAG,CAAC;IACtC,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGG,cAAc,CAACF,MAAM,EAAED,CAAC,EAAE,EAAE;MAE9C,IAAIG,cAAc,CAACH,CAAC,CAAC,CAAC2B,UAAU,KAAKhC,UAAU,CAACM,MAAM,EAAE;QACtDyB,MAAM,GAAGR,SAAS,CAACf,cAAc,CAACH,CAAC,CAAC,EAAEmB,QAAQ,CAAC;OAChD,MAAM;QAELO,MAAM,GAAGnB,gBAAgB,CACvBJ,cAAc,CAACH,CAAC,CAAC,EACjBG,cAAc,CAACD,aAAa,CAAC,CAAC0B,OAAO,EACrCH,QAAQ,CACT;;MAEH,IAAI,CAACC,MAAM,EAAE;QACX;;;IAKJ,IAAIA,MAAM,EAAE;MACV/B,UAAU,CAAC6B,KAAK,CAAC,GAAG,CAAC;;EAEzB,CAAC;EAEDvC,oBAAoB,CAACS,qBAAqB,EAAE,MAAM,IAAI,EAAE6B,QAAQ,EAAEzB,SAAS,CAAC;EAE5EZ,+BAA+B,CAACI,kBAAkB,CAACuC,QAAQ,CAAC;EAE5D,OAAOvC,kBAAkB;AAC3B;AAEA,eAAeD,sBAAsB"},"metadata":{},"sourceType":"module","externalDependencies":[]}