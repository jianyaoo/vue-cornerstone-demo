{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkCellArray from '../../Common/Core/CellArray.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nconst {\n  vtkErrorMacro\n} = macro;\nclass SegmentAgregator {\n  constructor() {\n    this.segmentMapping = {};\n    this.segments = [null]; // to force first id to be 1\n    this.faces = [];\n  }\n  addSegment(segment) {\n    const first = segment[0];\n    const last = segment[segment.length - 1];\n    if (first === last || segment.length < 2) {\n      return;\n    }\n    const mappingFirst = this.segmentMapping[first];\n    const mappingLast = this.segmentMapping[last];\n    if (mappingFirst !== undefined && mappingLast !== undefined) {\n      if (Math.abs(mappingFirst) === Math.abs(mappingLast)) {\n        // This make a closing loop\n        const idx = mappingFirst < mappingLast ? mappingLast : mappingFirst;\n        const seg = this.segments[idx];\n        if (mappingFirst > 0) {\n          for (let i = 1; i < segment.length - 1; i++) {\n            seg.push(segment[i]);\n          }\n        } else {\n          for (let i = 1; i < segment.length - 1; i++) {\n            seg.unshift(segment[segment.length - 1 - i]);\n          }\n        }\n        this.faces.push(seg);\n        this.segments[idx] = null;\n        this.segmentMapping[first] = undefined;\n        this.segmentMapping[last] = undefined;\n      } else {\n        // we need to merge segments\n        // strategie:\n        // => remove and add them again in special order to induce merge\n        const idxHead = Math.abs(mappingFirst);\n        const idxTail = Math.abs(mappingLast);\n        const segHead = this.segments[idxHead];\n        const segTail = this.segments[idxTail];\n        this.segments[idxHead] = null;\n        this.segments[idxTail] = null;\n        this.segmentMapping[segHead[0]] = undefined;\n        this.segmentMapping[segTail[0]] = undefined;\n        this.segmentMapping[segHead[segHead.length - 1]] = undefined;\n        this.segmentMapping[segTail[segTail.length - 1]] = undefined;\n\n        // This will lead to a single segment\n        this.addSegment(segment);\n        this.addSegment(segHead);\n        this.addSegment(segTail);\n      }\n    } else if (mappingFirst !== undefined) {\n      if (mappingFirst > 0) {\n        // The head of our segment match the tail of the existing one\n        const seg = this.segments[mappingFirst];\n        for (let i = 1; i < segment.length; i++) {\n          seg.push(segment[i]);\n        }\n        // record new tail\n        this.segmentMapping[last] = mappingFirst;\n      } else {\n        // our segment should be reverted and put on the front of the existing one\n        const seg = this.segments[-mappingFirst];\n        // record new head\n        this.segmentMapping[last] = mappingFirst;\n        for (let i = 1; i < segment.length; i++) {\n          seg.unshift(segment[i]);\n        }\n      }\n      // Erase used connection\n      this.segmentMapping[first] = undefined;\n    } else if (mappingLast !== undefined) {\n      if (mappingLast > 0) {\n        // The tail of our segment match the tail of the existing one\n        const seg = this.segments[mappingLast];\n        for (let i = 1; i < segment.length; i++) {\n          seg.push(segment[segment.length - 1 - i]);\n        }\n        // record new tail\n        this.segmentMapping[first] = mappingLast;\n      } else {\n        // our segment should be reverted and put on the front of the existing one\n        const seg = this.segments[-mappingLast];\n\n        // record new head\n        this.segmentMapping[first] = mappingLast;\n        for (let i = 1; i < segment.length; i++) {\n          seg.unshift(segment[segment.length - i - 1]);\n        }\n      }\n      // Erase used connection\n      this.segmentMapping[last] = undefined;\n    } else {\n      // store segment for now\n      const id = this.segments.length;\n      this.segments.push(segment);\n      this.segmentMapping[first] = -id;\n      this.segmentMapping[last] = id;\n    }\n  }\n}\n\n// ----------------------------------------------------------------------------\n// vtkClosedPolyLineToSurfaceFilter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkClosedPolyLineToSurfaceFilter(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkClosedPolyLineToSurfaceFilter');\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    const output = vtkPolyData.newInstance();\n    output.shallowCopy(input);\n\n    // Extract faces\n    const agregator = new SegmentAgregator();\n    const lines = input.getLines().getData();\n    let offset = 0;\n    while (offset < lines.length) {\n      const lineSize = lines[offset++];\n      const lineSegment = [];\n      for (let i = 0; i < lineSize; i++) {\n        lineSegment.push(lines[offset + i]);\n      }\n      agregator.addSegment(lineSegment);\n      offset += lineSize;\n    }\n\n    // Create CellArray for polys\n    const {\n      faces\n    } = agregator;\n    let cellArraySize = faces.length;\n    for (let i = 0; i < faces.length; i++) {\n      cellArraySize += faces[i].length;\n    }\n    const cellArray = new Uint16Array(cellArraySize);\n    offset = 0;\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      cellArray[offset++] = face.length;\n      for (let j = 0; j < face.length; j++) {\n        cellArray[offset++] = face[j];\n      }\n    }\n    output.setPolys(vtkCellArray.newInstance({\n      values: cellArray,\n      name: 'faces'\n    }));\n    outData[0] = output;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n\n  // Object specific methods\n  vtkClosedPolyLineToSurfaceFilter(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkClosedPolyLineToSurfaceFilter');\n\n// ----------------------------------------------------------------------------\n\nvar vtkClosedPolyLineToSurfaceFilter$1 = {\n  newInstance,\n  extend\n};\nexport { vtkClosedPolyLineToSurfaceFilter$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkCellArray","vtkPolyData","vtkErrorMacro","SegmentAgregator","constructor","segmentMapping","segments","faces","addSegment","segment","first","last","length","mappingFirst","mappingLast","undefined","Math","abs","idx","seg","i","push","unshift","idxHead","idxTail","segHead","segTail","id","vtkClosedPolyLineToSurfaceFilter","publicAPI","model","classHierarchy","requestData","inData","outData","input","output","newInstance","shallowCopy","agregator","lines","getLines","getData","offset","lineSize","lineSegment","cellArraySize","cellArray","Uint16Array","face","j","setPolys","values","name","DEFAULT_VALUES","extend","initialValues","arguments","Object","assign","obj","algo","vtkClosedPolyLineToSurfaceFilter$1","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Filters/General/ClosedPolyLineToSurfaceFilter.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkCellArray from '../../Common/Core/CellArray.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nclass SegmentAgregator {\n  constructor() {\n    this.segmentMapping = {};\n    this.segments = [null]; // to force first id to be 1\n    this.faces = [];\n  }\n  addSegment(segment) {\n    const first = segment[0];\n    const last = segment[segment.length - 1];\n    if (first === last || segment.length < 2) {\n      return;\n    }\n    const mappingFirst = this.segmentMapping[first];\n    const mappingLast = this.segmentMapping[last];\n    if (mappingFirst !== undefined && mappingLast !== undefined) {\n      if (Math.abs(mappingFirst) === Math.abs(mappingLast)) {\n        // This make a closing loop\n        const idx = mappingFirst < mappingLast ? mappingLast : mappingFirst;\n        const seg = this.segments[idx];\n        if (mappingFirst > 0) {\n          for (let i = 1; i < segment.length - 1; i++) {\n            seg.push(segment[i]);\n          }\n        } else {\n          for (let i = 1; i < segment.length - 1; i++) {\n            seg.unshift(segment[segment.length - 1 - i]);\n          }\n        }\n        this.faces.push(seg);\n        this.segments[idx] = null;\n        this.segmentMapping[first] = undefined;\n        this.segmentMapping[last] = undefined;\n      } else {\n        // we need to merge segments\n        // strategie:\n        // => remove and add them again in special order to induce merge\n        const idxHead = Math.abs(mappingFirst);\n        const idxTail = Math.abs(mappingLast);\n        const segHead = this.segments[idxHead];\n        const segTail = this.segments[idxTail];\n        this.segments[idxHead] = null;\n        this.segments[idxTail] = null;\n        this.segmentMapping[segHead[0]] = undefined;\n        this.segmentMapping[segTail[0]] = undefined;\n        this.segmentMapping[segHead[segHead.length - 1]] = undefined;\n        this.segmentMapping[segTail[segTail.length - 1]] = undefined;\n\n        // This will lead to a single segment\n        this.addSegment(segment);\n        this.addSegment(segHead);\n        this.addSegment(segTail);\n      }\n    } else if (mappingFirst !== undefined) {\n      if (mappingFirst > 0) {\n        // The head of our segment match the tail of the existing one\n        const seg = this.segments[mappingFirst];\n        for (let i = 1; i < segment.length; i++) {\n          seg.push(segment[i]);\n        }\n        // record new tail\n        this.segmentMapping[last] = mappingFirst;\n      } else {\n        // our segment should be reverted and put on the front of the existing one\n        const seg = this.segments[-mappingFirst];\n        // record new head\n        this.segmentMapping[last] = mappingFirst;\n        for (let i = 1; i < segment.length; i++) {\n          seg.unshift(segment[i]);\n        }\n      }\n      // Erase used connection\n      this.segmentMapping[first] = undefined;\n    } else if (mappingLast !== undefined) {\n      if (mappingLast > 0) {\n        // The tail of our segment match the tail of the existing one\n        const seg = this.segments[mappingLast];\n        for (let i = 1; i < segment.length; i++) {\n          seg.push(segment[segment.length - 1 - i]);\n        }\n        // record new tail\n        this.segmentMapping[first] = mappingLast;\n      } else {\n        // our segment should be reverted and put on the front of the existing one\n        const seg = this.segments[-mappingLast];\n\n        // record new head\n        this.segmentMapping[first] = mappingLast;\n        for (let i = 1; i < segment.length; i++) {\n          seg.unshift(segment[segment.length - i - 1]);\n        }\n      }\n      // Erase used connection\n      this.segmentMapping[last] = undefined;\n    } else {\n      // store segment for now\n      const id = this.segments.length;\n      this.segments.push(segment);\n      this.segmentMapping[first] = -id;\n      this.segmentMapping[last] = id;\n    }\n  }\n}\n\n// ----------------------------------------------------------------------------\n// vtkClosedPolyLineToSurfaceFilter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkClosedPolyLineToSurfaceFilter(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkClosedPolyLineToSurfaceFilter');\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    const output = vtkPolyData.newInstance();\n    output.shallowCopy(input);\n\n    // Extract faces\n    const agregator = new SegmentAgregator();\n    const lines = input.getLines().getData();\n    let offset = 0;\n    while (offset < lines.length) {\n      const lineSize = lines[offset++];\n      const lineSegment = [];\n      for (let i = 0; i < lineSize; i++) {\n        lineSegment.push(lines[offset + i]);\n      }\n      agregator.addSegment(lineSegment);\n      offset += lineSize;\n    }\n\n    // Create CellArray for polys\n    const {\n      faces\n    } = agregator;\n    let cellArraySize = faces.length;\n    for (let i = 0; i < faces.length; i++) {\n      cellArraySize += faces[i].length;\n    }\n    const cellArray = new Uint16Array(cellArraySize);\n    offset = 0;\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      cellArray[offset++] = face.length;\n      for (let j = 0; j < face.length; j++) {\n        cellArray[offset++] = face[j];\n      }\n    }\n    output.setPolys(vtkCellArray.newInstance({\n      values: cellArray,\n      name: 'faces'\n    }));\n    outData[0] = output;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n\n  // Object specific methods\n  vtkClosedPolyLineToSurfaceFilter(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkClosedPolyLineToSurfaceFilter');\n\n// ----------------------------------------------------------------------------\n\nvar vtkClosedPolyLineToSurfaceFilter$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkClosedPolyLineToSurfaceFilter$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}