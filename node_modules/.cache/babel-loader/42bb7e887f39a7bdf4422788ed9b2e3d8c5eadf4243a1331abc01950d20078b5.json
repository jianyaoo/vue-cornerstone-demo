{"ast":null,"code":"import { m as macro } from '../../macros2.js';\nimport { f as vtkMath } from '../Core/Math/index.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkIncrementalOctreeNode from './IncrementalOctreeNode.js';\nimport vtkAbstractPointLocator from './AbstractPointLocator.js';\nimport { VtkDataTypes } from '../Core/DataArray/Constants.js';\nconst {\n  vtkErrorMacro\n} = macro;\nfunction vtkIncrementalOctreePointLocator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkIncrementalOctreePointLocator');\n  function getLeafContainer(node, pnt) {\n    return node.isLeaf() ? node : getLeafContainer(node.getChild(node.getChildIndex(pnt)), pnt);\n  }\n\n  //------------------------------------------------------------------------------\n  publicAPI.freeSearchStructure = () => {\n    model.octreeRootNode = null;\n    model.numberOfNodes = 0;\n    model.locatorPoints = null;\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.findClosestPointInLeafNode = (leafNode, point) => {\n    // NOTE: dist2 MUST be initiated with a very huge value below, but instead of\n    // model.octreeMaxDimSize * model.octreeMaxDimSize * 4.0, because the point\n    // under check may be outside the octree and hence the squared distance can\n    // be greater than the latter or other similar octree-based specific values.\n    let dist2 = Number.MAX_VALUE;\n    if (leafNode.getPointIdSet() == null) {\n      return [-1, dist2];\n    }\n    let numPts = 0;\n    let tmpDst = 0.0;\n    const tmpPnt = [];\n    let tmpIdx = -1;\n    let pntIdx = -1;\n    let idList = leafNode.getPointIdSet();\n    numPts = idList.length;\n    for (let i = 0; i < numPts; i++) {\n      tmpIdx = idList[i];\n      model.locatorPoints.getPoint(tmpIdx, tmpPnt);\n      tmpDst = vtkMath.distance2BetweenPoints(tmpPnt, point);\n      if (tmpDst < dist2) {\n        dist2 = tmpDst;\n        pntIdx = tmpIdx;\n      }\n      if (dist2 === 0.0) {\n        break;\n      }\n    }\n    idList = null;\n    return [pntIdx, dist2];\n  };\n  publicAPI.findClosestPointInSphere = (point, radius2, maskNode, refDist2) => {\n    let pointIndx = -1;\n    let minDist2 = Number.MAX_VALUE;\n    const nodesBase = [];\n    nodesBase.push(model.octreeRootNode);\n    let checkNode;\n    let childNode;\n    let distToData;\n    let tempDist2;\n    let tempPntId;\n    while (!nodesBase.length === 0 && minDist2 > 0.0) {\n      checkNode = nodesBase.top();\n      nodesBase.pop();\n      if (!checkNode.isLeaf()) {\n        for (let i = 0; i < 8; i++) {\n          childNode = checkNode.getChild(i);\n\n          // use ( radius2 + radius2 ) to skip empty nodes\n          distToData = childNode.getNumberOfPoints() ? childNode.getDistance2ToBoundary(point, model.octreeRootNode, 1) : radius2 + radius2;\n\n          // If a child node is not the mask node AND its distance, specifically\n          // the data bounding box (determined by the points inside or under) to\n          // the point, is less than the threshold radius (one exception is the\n          // point's container nodes), it is pushed to the stack as a suspect.\n          if (childNode !== maskNode && (distToData <= refDist2 || childNode.containsPoint(point) === 1)) {\n            nodesBase.push(childNode);\n          }\n          childNode = null;\n        }\n      } else {\n        // now that the node under check is a leaf, let's find the closest\n        // point therein and the minimum distance\n\n        [tempPntId, tempDist2] = publicAPI.findClosestPointInLeafNode(checkNode, point);\n        if (tempDist2 < minDist2) {\n          minDist2 = tempDist2;\n          pointIndx = tempPntId;\n        }\n      }\n      checkNode = null;\n    }\n    return [minDist2 <= radius2 ? pointIndx : -1, minDist2];\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.initPointInsertion = function (points, bounds) {\n    let i = 0;\n    let bbIndex = 0;\n    if (points == null) {\n      vtkErrorMacro('a valid vtkPoints object required for point insertion');\n      return false;\n    }\n\n    // destroy the existing octree, if any\n    publicAPI.freeSearchStructure();\n    model.locatorPoints = points;\n\n    // obtain the threshold squared distance\n    model.insertTolerance2 = model.tolerance * model.tolerance;\n\n    // Fix bounds\n    // (1) push out a little bit if the original volume is too flat --- a slab\n    // (2) pull back the x, y, and z's lower bounds a little bit such that\n    //     points are clearly \"inside\" the spatial region.  Point p is taken as\n    //     \"inside\" range r = [r1, r2] if and only if r1 < p <= r2.\n    model.octreeMaxDimSize = 0.0;\n    const tmpBbox = [...bounds];\n    const dimDiff = vtkBoundingBox.getLengths(bounds);\n    model.octreeMaxDimSize = Math.max(...dimDiff);\n    if (model.buildCubicOctree) {\n      // make the bounding box a cube and hence descendant octants cubes too\n      for (i = 0; i < 3; i++) {\n        if (dimDiff[i] !== model.octreeMaxDimSize) {\n          const delta = model.octreeMaxDimSize - dimDiff[i];\n          tmpBbox[2 * i] -= 0.5 * delta;\n          tmpBbox[2 * i + 1] += 0.5 * delta;\n          dimDiff[i] = model.octreeMaxDimSize;\n        }\n      }\n    }\n    model.fudgeFactor = model.octreeMaxDimSize * 10e-6;\n    const minSideSize = model.octreeMaxDimSize * 10e-2;\n    for (i = 0; i < 3; i++) {\n      if (dimDiff[i] < minSideSize) {\n        // case (1) above\n        bbIndex = 2 * i;\n        const tempVal = tmpBbox[bbIndex];\n        tmpBbox[bbIndex] = tmpBbox[bbIndex + 1] - minSideSize;\n        tmpBbox[bbIndex + 1] = tempVal + minSideSize;\n      } else {\n        // case (2) above\n        tmpBbox[2 * i] -= model.fudgeFactor;\n      }\n    }\n\n    // init the octree with an empty leaf node\n    model.octreeRootNode = vtkIncrementalOctreeNode.newInstance();\n    ++model.numberOfNodes;\n\n    // this call internally inits the middle (center) and data range, too\n    model.octreeRootNode.setBounds(...tmpBbox);\n    return true;\n  };\n  publicAPI.findClosestPointInSphereWithTolerance = (point, radius2, maskNode) => publicAPI.findClosestPointInSphere(point, radius2, maskNode, model.octreeMaxDimSize * model.octreeMaxDimSize * 4.0, radius2);\n\n  //------------------------------------------------------------------------------\n  publicAPI.findDuplicateFloatTypePointInVisitedLeafNode = (leafNode, point) => {\n    let tmpPnt;\n    let tmpIdx = -1;\n    let pntIdx = -1;\n\n    // float thePnt[3]; // TODO\n    // thePnt[0] = static_cast<float>(point[0]);\n    // thePnt[1] = static_cast<float>(point[1]);\n    // thePnt[2] = static_cast<float>(point[2]);\n\n    const idList = leafNode.getPointIdSet();\n    // float* pFloat = (static_cast<vtkFloatArray*>(model.locatorPoints.getData())).getPointer(0);\n    const values = model.locatorPoints.getData();\n    for (let i = 0; i < idList.length; i++) {\n      tmpIdx = idList[i];\n      // eslint-disable-next-line no-bitwise\n      tmpPnt = (tmpIdx << 1) + tmpIdx;\n      if (point[0] === values[tmpPnt] && point[1] === values[tmpPnt + 1] && point[2] === values[tmpPnt + 2]) {\n        pntIdx = tmpIdx;\n        break;\n      }\n    }\n    return pntIdx;\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.findDuplicateDoubleTypePointInVisitedLeafNode = (leafNode, point) => {\n    let tmpPnt;\n    let tmpIdx = -1;\n    let pntIdx = -1;\n    const idList = leafNode.getPointIdSet();\n    const values = model.locatorPoints.getData();\n    for (let i = 0; i < idList.length; i++) {\n      tmpIdx = idList[i];\n      // eslint-disable-next-line no-bitwise\n      tmpPnt = (tmpIdx << 1) + tmpIdx;\n      if (point[0] === values[tmpPnt] && point[1] === values[tmpPnt + 1] && point[2] === values[tmpPnt + 2]) {\n        pntIdx = tmpIdx;\n        break;\n      }\n    }\n    return pntIdx;\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.findDuplicatePointInLeafNode = (leafNode, point) => {\n    if (leafNode.getPointIdSet() == null) {\n      return -1;\n    }\n    return model.locatorPoints.getDataType() === VtkDataTypes.FLOAT ? publicAPI.findDuplicateFloatTypePointInVisitedLeafNode(leafNode, point) : publicAPI.findDuplicateDoubleTypePointInVisitedLeafNode(leafNode, point);\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.insertPoint = (ptId, x) => {\n    const leafcontainer = getLeafContainer(model.octreeRootNode, x);\n    ({\n      numberOfNodes: model.numberOfNodes\n    } = leafcontainer.insertPoint(model.locatorPoints, x, model.maxPointsPerLeaf, ptId, 1, model.numberOfNodes));\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.insertUniquePoint = point => {\n    // TODO: We have a mix of let and const here.\n    // eslint-disable-next-line prefer-const\n    let {\n      pointIdx,\n      leafContainer\n    } = publicAPI.isInsertedPoint(point);\n    if (pointIdx > -1) {\n      return {\n        success: false,\n        idx: pointIdx\n      };\n    }\n    // TODO: pointIdx\n    let numberOfNodes;\n    // eslint-disable-next-line prefer-const\n    ({\n      numberOfNodes,\n      pointIdx\n    } = leafContainer.insertPoint(model.locatorPoints, point, model.maxPointsPerLeaf, pointIdx, 2, model.numberOfNodes));\n    model.numberOfNodes = numberOfNodes;\n    return {\n      success: true,\n      idx: pointIdx\n    };\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.insertNextPoint = x => {\n    const leafContainer = getLeafContainer(model.octreeRootNode, x);\n    const {\n      numberOfNodes,\n      pointIdx\n    } = leafContainer.insertPoint(model.locatorPoints, x, model.maxPointsPerLeaf, -1, 2, model.numberOfNodes);\n    model.numberOfNodes = numberOfNodes;\n    return pointIdx;\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.isInsertedPointForZeroTolerance = x => {\n    // the target leaf node always exists there since the root node of the\n    // octree has been initialized to cover all possible points to be inserted\n    // and therefore we do not need to check it here\n    const leafContainer = getLeafContainer(model.octreeRootNode, x);\n    const pointIdx = publicAPI.findDuplicatePointInLeafNode(leafContainer, x);\n    return {\n      pointIdx,\n      leafContainer\n    };\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.isInsertedPointForNonZeroTolerance = x => {\n    // minDist2 // min distance to ALL existing points\n    // elseDst2 // min distance to other nodes (inner boundaries)\n    let dist2Ext; // min distance to an EXTended set of nodes\n    let pntIdExt;\n\n    // the target leaf node always exists there since the root node of the\n    // octree has been initialized to cover all possible points to be inserted\n    // and therefore we do not need to check it here\n    const leafContainer = getLeafContainer(model.octreeRootNode, x);\n    let [pointIdx, minDist2] = publicAPI.findClosestPointInLeafNode(leafContainer, x);\n    if (minDist2 === 0.0) {\n      return {\n        pointIdx,\n        leafContainer\n      };\n    }\n\n    // As no any 'duplicate' point exists in this leaf node, we need to expand\n    // the search scope to capture possible closer points in other nodes.\n    const elseDst2 = leafContainer.getDistance2ToInnerBoundary(x, model.octreeRootNode);\n    if (elseDst2 < model.insertTolerance2) {\n      // one or multiple closer points might exist in the neighboring nodes\n      // TODO: dist2Ext\n      pntIdExt = publicAPI.findClosestPointInSphereWithTolerance(x, model.insertTolerance2, leafContainer, dist2Ext);\n      if (dist2Ext < minDist2) {\n        minDist2 = dist2Ext;\n        pointIdx = pntIdExt;\n      }\n    }\n    pointIdx = minDist2 <= model.insertTolerance2 ? pointIdx : -1;\n    return {\n      pointIdx,\n      leafContainer\n    };\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.isInsertedPoint = (x, leafContainer) => model.insertTolerance2 === 0.0 ? publicAPI.isInsertedPointForZeroTolerance(x, leafContainer) : publicAPI.isInsertedPointForNonZeroTolerance(x, leafContainer);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(initialValues) {\n  return {\n    fudgeFactor: 0,\n    octreeMaxDimSize: 0,\n    buildCubicOctree: false,\n    maxPointsPerLeaf: 128,\n    insertTolerance2: 0.000001,\n    locatorPoints: null,\n    octreeRootNode: null,\n    numberOfNodes: 0,\n    ...initialValues\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  vtkAbstractPointLocator.extend(publicAPI, model, defaultValues(initialValues));\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['fudgeFactor', 'octreeMaxDimSize', 'buildCubicOctree', 'maxPointsPerLeaf', 'insertTolerance2', 'locatorPoints', 'octreeRootNode', 'numberOfNodes']);\n\n  // Object specific methods\n  vtkIncrementalOctreePointLocator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkIncrementalOctreePointLocator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkIncrementalOctreePointLocator$1 = {\n  newInstance,\n  extend\n};\nexport { vtkIncrementalOctreePointLocator$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","f","vtkMath","vtkBoundingBox","vtkIncrementalOctreeNode","vtkAbstractPointLocator","VtkDataTypes","vtkErrorMacro","vtkIncrementalOctreePointLocator","publicAPI","model","classHierarchy","push","getLeafContainer","node","pnt","isLeaf","getChild","getChildIndex","freeSearchStructure","octreeRootNode","numberOfNodes","locatorPoints","findClosestPointInLeafNode","leafNode","point","dist2","Number","MAX_VALUE","getPointIdSet","numPts","tmpDst","tmpPnt","tmpIdx","pntIdx","idList","length","i","getPoint","distance2BetweenPoints","findClosestPointInSphere","radius2","maskNode","refDist2","pointIndx","minDist2","nodesBase","checkNode","childNode","distToData","tempDist2","tempPntId","top","pop","getNumberOfPoints","getDistance2ToBoundary","containsPoint","initPointInsertion","points","bounds","bbIndex","insertTolerance2","tolerance","octreeMaxDimSize","tmpBbox","dimDiff","getLengths","Math","max","buildCubicOctree","delta","fudgeFactor","minSideSize","tempVal","newInstance","setBounds","findClosestPointInSphereWithTolerance","findDuplicateFloatTypePointInVisitedLeafNode","values","getData","findDuplicateDoubleTypePointInVisitedLeafNode","findDuplicatePointInLeafNode","getDataType","FLOAT","insertPoint","ptId","x","leafcontainer","maxPointsPerLeaf","insertUniquePoint","pointIdx","leafContainer","isInsertedPoint","success","idx","insertNextPoint","isInsertedPointForZeroTolerance","isInsertedPointForNonZeroTolerance","dist2Ext","pntIdExt","elseDst2","getDistance2ToInnerBoundary","defaultValues","initialValues","extend","arguments","undefined","obj","setGet","vtkIncrementalOctreePointLocator$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Common/DataModel/IncrementalOctreePointLocator.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport { f as vtkMath } from '../Core/Math/index.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkIncrementalOctreeNode from './IncrementalOctreeNode.js';\nimport vtkAbstractPointLocator from './AbstractPointLocator.js';\nimport { VtkDataTypes } from '../Core/DataArray/Constants.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nfunction vtkIncrementalOctreePointLocator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkIncrementalOctreePointLocator');\n  function getLeafContainer(node, pnt) {\n    return node.isLeaf() ? node : getLeafContainer(node.getChild(node.getChildIndex(pnt)), pnt);\n  }\n\n  //------------------------------------------------------------------------------\n  publicAPI.freeSearchStructure = () => {\n    model.octreeRootNode = null;\n    model.numberOfNodes = 0;\n    model.locatorPoints = null;\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.findClosestPointInLeafNode = (leafNode, point) => {\n    // NOTE: dist2 MUST be initiated with a very huge value below, but instead of\n    // model.octreeMaxDimSize * model.octreeMaxDimSize * 4.0, because the point\n    // under check may be outside the octree and hence the squared distance can\n    // be greater than the latter or other similar octree-based specific values.\n    let dist2 = Number.MAX_VALUE;\n    if (leafNode.getPointIdSet() == null) {\n      return [-1, dist2];\n    }\n    let numPts = 0;\n    let tmpDst = 0.0;\n    const tmpPnt = [];\n    let tmpIdx = -1;\n    let pntIdx = -1;\n    let idList = leafNode.getPointIdSet();\n    numPts = idList.length;\n    for (let i = 0; i < numPts; i++) {\n      tmpIdx = idList[i];\n      model.locatorPoints.getPoint(tmpIdx, tmpPnt);\n      tmpDst = vtkMath.distance2BetweenPoints(tmpPnt, point);\n      if (tmpDst < dist2) {\n        dist2 = tmpDst;\n        pntIdx = tmpIdx;\n      }\n      if (dist2 === 0.0) {\n        break;\n      }\n    }\n    idList = null;\n    return [pntIdx, dist2];\n  };\n  publicAPI.findClosestPointInSphere = (point, radius2, maskNode, refDist2) => {\n    let pointIndx = -1;\n    let minDist2 = Number.MAX_VALUE;\n    const nodesBase = [];\n    nodesBase.push(model.octreeRootNode);\n    let checkNode;\n    let childNode;\n    let distToData;\n    let tempDist2;\n    let tempPntId;\n    while (!nodesBase.length === 0 && minDist2 > 0.0) {\n      checkNode = nodesBase.top();\n      nodesBase.pop();\n      if (!checkNode.isLeaf()) {\n        for (let i = 0; i < 8; i++) {\n          childNode = checkNode.getChild(i);\n\n          // use ( radius2 + radius2 ) to skip empty nodes\n          distToData = childNode.getNumberOfPoints() ? childNode.getDistance2ToBoundary(point, model.octreeRootNode, 1) : radius2 + radius2;\n\n          // If a child node is not the mask node AND its distance, specifically\n          // the data bounding box (determined by the points inside or under) to\n          // the point, is less than the threshold radius (one exception is the\n          // point's container nodes), it is pushed to the stack as a suspect.\n          if (childNode !== maskNode && (distToData <= refDist2 || childNode.containsPoint(point) === 1)) {\n            nodesBase.push(childNode);\n          }\n          childNode = null;\n        }\n      } else {\n        // now that the node under check is a leaf, let's find the closest\n        // point therein and the minimum distance\n\n        [tempPntId, tempDist2] = publicAPI.findClosestPointInLeafNode(checkNode, point);\n        if (tempDist2 < minDist2) {\n          minDist2 = tempDist2;\n          pointIndx = tempPntId;\n        }\n      }\n      checkNode = null;\n    }\n    return [minDist2 <= radius2 ? pointIndx : -1, minDist2];\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.initPointInsertion = function (points, bounds) {\n    let i = 0;\n    let bbIndex = 0;\n    if (points == null) {\n      vtkErrorMacro('a valid vtkPoints object required for point insertion');\n      return false;\n    }\n\n    // destroy the existing octree, if any\n    publicAPI.freeSearchStructure();\n    model.locatorPoints = points;\n\n    // obtain the threshold squared distance\n    model.insertTolerance2 = model.tolerance * model.tolerance;\n\n    // Fix bounds\n    // (1) push out a little bit if the original volume is too flat --- a slab\n    // (2) pull back the x, y, and z's lower bounds a little bit such that\n    //     points are clearly \"inside\" the spatial region.  Point p is taken as\n    //     \"inside\" range r = [r1, r2] if and only if r1 < p <= r2.\n    model.octreeMaxDimSize = 0.0;\n    const tmpBbox = [...bounds];\n    const dimDiff = vtkBoundingBox.getLengths(bounds);\n    model.octreeMaxDimSize = Math.max(...dimDiff);\n    if (model.buildCubicOctree) {\n      // make the bounding box a cube and hence descendant octants cubes too\n      for (i = 0; i < 3; i++) {\n        if (dimDiff[i] !== model.octreeMaxDimSize) {\n          const delta = model.octreeMaxDimSize - dimDiff[i];\n          tmpBbox[2 * i] -= 0.5 * delta;\n          tmpBbox[2 * i + 1] += 0.5 * delta;\n          dimDiff[i] = model.octreeMaxDimSize;\n        }\n      }\n    }\n    model.fudgeFactor = model.octreeMaxDimSize * 10e-6;\n    const minSideSize = model.octreeMaxDimSize * 10e-2;\n    for (i = 0; i < 3; i++) {\n      if (dimDiff[i] < minSideSize) {\n        // case (1) above\n        bbIndex = 2 * i;\n        const tempVal = tmpBbox[bbIndex];\n        tmpBbox[bbIndex] = tmpBbox[bbIndex + 1] - minSideSize;\n        tmpBbox[bbIndex + 1] = tempVal + minSideSize;\n      } else {\n        // case (2) above\n        tmpBbox[2 * i] -= model.fudgeFactor;\n      }\n    }\n\n    // init the octree with an empty leaf node\n    model.octreeRootNode = vtkIncrementalOctreeNode.newInstance();\n    ++model.numberOfNodes;\n\n    // this call internally inits the middle (center) and data range, too\n    model.octreeRootNode.setBounds(...tmpBbox);\n    return true;\n  };\n  publicAPI.findClosestPointInSphereWithTolerance = (point, radius2, maskNode) => publicAPI.findClosestPointInSphere(point, radius2, maskNode, model.octreeMaxDimSize * model.octreeMaxDimSize * 4.0, radius2);\n\n  //------------------------------------------------------------------------------\n  publicAPI.findDuplicateFloatTypePointInVisitedLeafNode = (leafNode, point) => {\n    let tmpPnt;\n    let tmpIdx = -1;\n    let pntIdx = -1;\n\n    // float thePnt[3]; // TODO\n    // thePnt[0] = static_cast<float>(point[0]);\n    // thePnt[1] = static_cast<float>(point[1]);\n    // thePnt[2] = static_cast<float>(point[2]);\n\n    const idList = leafNode.getPointIdSet();\n    // float* pFloat = (static_cast<vtkFloatArray*>(model.locatorPoints.getData())).getPointer(0);\n    const values = model.locatorPoints.getData();\n    for (let i = 0; i < idList.length; i++) {\n      tmpIdx = idList[i];\n      // eslint-disable-next-line no-bitwise\n      tmpPnt = (tmpIdx << 1) + tmpIdx;\n      if (point[0] === values[tmpPnt] && point[1] === values[tmpPnt + 1] && point[2] === values[tmpPnt + 2]) {\n        pntIdx = tmpIdx;\n        break;\n      }\n    }\n    return pntIdx;\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.findDuplicateDoubleTypePointInVisitedLeafNode = (leafNode, point) => {\n    let tmpPnt;\n    let tmpIdx = -1;\n    let pntIdx = -1;\n    const idList = leafNode.getPointIdSet();\n    const values = model.locatorPoints.getData();\n    for (let i = 0; i < idList.length; i++) {\n      tmpIdx = idList[i];\n      // eslint-disable-next-line no-bitwise\n      tmpPnt = (tmpIdx << 1) + tmpIdx;\n      if (point[0] === values[tmpPnt] && point[1] === values[tmpPnt + 1] && point[2] === values[tmpPnt + 2]) {\n        pntIdx = tmpIdx;\n        break;\n      }\n    }\n    return pntIdx;\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.findDuplicatePointInLeafNode = (leafNode, point) => {\n    if (leafNode.getPointIdSet() == null) {\n      return -1;\n    }\n    return model.locatorPoints.getDataType() === VtkDataTypes.FLOAT ? publicAPI.findDuplicateFloatTypePointInVisitedLeafNode(leafNode, point) : publicAPI.findDuplicateDoubleTypePointInVisitedLeafNode(leafNode, point);\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.insertPoint = (ptId, x) => {\n    const leafcontainer = getLeafContainer(model.octreeRootNode, x);\n    ({\n      numberOfNodes: model.numberOfNodes\n    } = leafcontainer.insertPoint(model.locatorPoints, x, model.maxPointsPerLeaf, ptId, 1, model.numberOfNodes));\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.insertUniquePoint = point => {\n    // TODO: We have a mix of let and const here.\n    // eslint-disable-next-line prefer-const\n    let {\n      pointIdx,\n      leafContainer\n    } = publicAPI.isInsertedPoint(point);\n    if (pointIdx > -1) {\n      return {\n        success: false,\n        idx: pointIdx\n      };\n    }\n    // TODO: pointIdx\n    let numberOfNodes;\n    // eslint-disable-next-line prefer-const\n    ({\n      numberOfNodes,\n      pointIdx\n    } = leafContainer.insertPoint(model.locatorPoints, point, model.maxPointsPerLeaf, pointIdx, 2, model.numberOfNodes));\n    model.numberOfNodes = numberOfNodes;\n    return {\n      success: true,\n      idx: pointIdx\n    };\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.insertNextPoint = x => {\n    const leafContainer = getLeafContainer(model.octreeRootNode, x);\n    const {\n      numberOfNodes,\n      pointIdx\n    } = leafContainer.insertPoint(model.locatorPoints, x, model.maxPointsPerLeaf, -1, 2, model.numberOfNodes);\n    model.numberOfNodes = numberOfNodes;\n    return pointIdx;\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.isInsertedPointForZeroTolerance = x => {\n    // the target leaf node always exists there since the root node of the\n    // octree has been initialized to cover all possible points to be inserted\n    // and therefore we do not need to check it here\n    const leafContainer = getLeafContainer(model.octreeRootNode, x);\n    const pointIdx = publicAPI.findDuplicatePointInLeafNode(leafContainer, x);\n    return {\n      pointIdx,\n      leafContainer\n    };\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.isInsertedPointForNonZeroTolerance = x => {\n    // minDist2 // min distance to ALL existing points\n    // elseDst2 // min distance to other nodes (inner boundaries)\n    let dist2Ext; // min distance to an EXTended set of nodes\n    let pntIdExt;\n\n    // the target leaf node always exists there since the root node of the\n    // octree has been initialized to cover all possible points to be inserted\n    // and therefore we do not need to check it here\n    const leafContainer = getLeafContainer(model.octreeRootNode, x);\n    let [pointIdx, minDist2] = publicAPI.findClosestPointInLeafNode(leafContainer, x);\n    if (minDist2 === 0.0) {\n      return {\n        pointIdx,\n        leafContainer\n      };\n    }\n\n    // As no any 'duplicate' point exists in this leaf node, we need to expand\n    // the search scope to capture possible closer points in other nodes.\n    const elseDst2 = leafContainer.getDistance2ToInnerBoundary(x, model.octreeRootNode);\n    if (elseDst2 < model.insertTolerance2) {\n      // one or multiple closer points might exist in the neighboring nodes\n      // TODO: dist2Ext\n      pntIdExt = publicAPI.findClosestPointInSphereWithTolerance(x, model.insertTolerance2, leafContainer, dist2Ext);\n      if (dist2Ext < minDist2) {\n        minDist2 = dist2Ext;\n        pointIdx = pntIdExt;\n      }\n    }\n    pointIdx = minDist2 <= model.insertTolerance2 ? pointIdx : -1;\n    return {\n      pointIdx,\n      leafContainer\n    };\n  };\n\n  //------------------------------------------------------------------------------\n  publicAPI.isInsertedPoint = (x, leafContainer) => model.insertTolerance2 === 0.0 ? publicAPI.isInsertedPointForZeroTolerance(x, leafContainer) : publicAPI.isInsertedPointForNonZeroTolerance(x, leafContainer);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(initialValues) {\n  return {\n    fudgeFactor: 0,\n    octreeMaxDimSize: 0,\n    buildCubicOctree: false,\n    maxPointsPerLeaf: 128,\n    insertTolerance2: 0.000001,\n    locatorPoints: null,\n    octreeRootNode: null,\n    numberOfNodes: 0,\n    ...initialValues\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  vtkAbstractPointLocator.extend(publicAPI, model, defaultValues(initialValues));\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['fudgeFactor', 'octreeMaxDimSize', 'buildCubicOctree', 'maxPointsPerLeaf', 'insertTolerance2', 'locatorPoints', 'octreeRootNode', 'numberOfNodes']);\n\n  // Object specific methods\n  vtkIncrementalOctreePointLocator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkIncrementalOctreePointLocator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkIncrementalOctreePointLocator$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkIncrementalOctreePointLocator$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}