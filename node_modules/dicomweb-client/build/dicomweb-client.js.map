{"version":3,"file":"dicomweb-client.js","sources":["../src/message.js","../src/api.js","../src/utils.js","../src/version.js","../src/dicomweb-client.js"],"sourcesContent":["/**\n * Converts a Uint8Array to a String.\n * @param {Uint8Array} array that should be converted\n * @param {Number} offset array offset in case only subset of array items should\n                   be extracted (default: 0)\n * @param {Number} limit maximum number of array items that should be extracted\n                   (defaults to length of array)\n * @returns {String}\n */\nfunction uint8ArrayToString(arr, offset = 0, limit) {\n  const itemLimit = limit || arr.length - offset;\n  let str = '';\n  for (let i = offset; i < offset + itemLimit; i++) {\n    str += String.fromCharCode(arr[i]);\n  }\n  return str;\n}\n\n/**\n * Converts a String to a Uint8Array.\n * @param {String} str string that should be converted\n * @returns {Uint8Array}\n */\nfunction stringToUint8Array(str) {\n  const arr = new Uint8Array(str.length);\n  for (let i = 0, j = str.length; i < j; i++) {\n    arr[i] = str.charCodeAt(i);\n  }\n  return arr;\n}\n\n/**\n * Identifies the boundary in a multipart/related message header.\n * @param {String} header message header\n * @returns {String} boundary\n */\nfunction identifyBoundary(header) {\n  const parts = header.split('\\r\\n');\n\n  for (let i = 0; i < parts.length; i++) {\n    if (parts[i].substr(0, 2) === '--') {\n      return parts[i];\n    }\n  }\n\n  return null;\n}\n\n/**\n * Checks whether a given token is contained by a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be present\n * @param {Number} offset offset in message content from where search should start\n * @returns {Boolean} whether message contains token at offset\n */\nfunction containsToken(message, token, offset = 0) {\n  if (offset + token.length > message.length) {\n    return false;\n  }\n\n  let index = offset;\n  for (let i = 0; i < token.length; i++) {\n    if (token[i] !== message[index]) {\n      return false;\n    }\n\n    index += 1;\n  }\n  return true;\n}\n\n/**\n * Finds a given token in a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be found\n * @param {String} offset message body offset from where search should start\n * @returns {Boolean} whether message has a part at given offset or not\n */\nfunction findToken(message, token, offset = 0, maxSearchLength) {\n  let searchLength = message.length;\n  if (maxSearchLength) {\n    searchLength = Math.min(offset + maxSearchLength, message.length);\n  }\n\n  for (let i = offset; i < searchLength; i++) {\n    // If the first value of the message matches\n    // the first value of the token, check if\n    // this is the full token.\n    if (message[i] === token[0]) {\n      if (containsToken(message, token, i)) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Create a random GUID\n *\n * @return {string}\n */\nfunction guid() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  }\n  return `${s4() + s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;\n}\n\n/**\n * @typedef {Object} MultipartEncodedData\n * @property {ArrayBuffer} data The encoded Multipart Data\n * @property {String} boundary The boundary used to divide pieces of the encoded data\n */\n\n/**\n * Encode one or more DICOM datasets into a single body so it can be\n * sent using the Multipart Content-Type.\n *\n * @param {ArrayBuffer[]} datasets Array containing each file to be encoded in the\n                          multipart body, passed as ArrayBuffers.\n * @param {String} [boundary] Optional string to define a boundary between each part\n                              of the multipart body. If this is not specified, a random\n                              GUID will be generated.\n * @return {MultipartEncodedData} The Multipart encoded data returned as an Object. This\n                                  contains both the data itself, and the boundary string\n                                  used to divide it.\n */\nfunction multipartEncode(\n  datasets,\n  boundary = guid(),\n  contentType = 'application/dicom',\n) {\n  const contentTypeString = `Content-Type: ${contentType}`;\n  const header = `\\r\\n--${boundary}\\r\\n${contentTypeString}\\r\\n\\r\\n`;\n  const footer = `\\r\\n--${boundary}--`;\n  const headerArray = stringToUint8Array(header);\n  const footerArray = stringToUint8Array(footer);\n  const headerLength = headerArray.length;\n  const footerLength = footerArray.length;\n\n  let length = 0;\n\n  // Calculate the total length for the final array\n  const contentArrays = datasets.map(datasetBuffer => {\n    const contentArray = new Uint8Array(datasetBuffer);\n    const contentLength = contentArray.length;\n\n    length += headerLength + contentLength + footerLength;\n\n    return contentArray;\n  });\n\n  // Allocate the array\n  const multipartArray = new Uint8Array(length);\n\n  // Set the initial header\n  multipartArray.set(headerArray, 0);\n\n  // Write each dataset into the multipart array\n  let position = 0;\n  contentArrays.forEach(contentArray => {\n    multipartArray.set(headerArray, position);\n    multipartArray.set(contentArray, position + headerLength);\n\n    position += headerLength + contentArray.length;\n  });\n\n  multipartArray.set(footerArray, position);\n\n  return {\n    data: multipartArray.buffer,\n    boundary,\n  };\n}\n\n/**\n * Decode a Multipart encoded ArrayBuffer and return the components as an Array.\n *\n * @param {ArrayBuffer} response Data encoded as a 'multipart/related' message\n * @returns {Array} The content\n */\nfunction multipartDecode(response) {\n  // Use the raw data if it is provided in an appropriate format\n  const message = ArrayBuffer.isView(response) ? response : new Uint8Array(response);\n\n  /* Set a maximum length to search for the header boundaries, otherwise\n       findToken can run for a long time\n    */\n  const maxSearchLength = 1000;\n\n  // First look for the multipart mime header\n  const separator = stringToUint8Array('\\r\\n\\r\\n');\n  const headerIndex = findToken(message, separator, 0, maxSearchLength);\n  if (headerIndex === -1) {\n    throw new Error('Response message has no multipart mime header');\n  }\n\n  const header = uint8ArrayToString(message, 0, headerIndex);\n  const boundaryString = identifyBoundary(header);\n  if (!boundaryString) {\n    throw new Error('Header of response message does not specify boundary');\n  }\n\n  const boundary = stringToUint8Array(boundaryString);\n  const boundaryLength = boundary.length;\n  const components = [];\n\n  let offset = boundaryLength;\n\n  // Loop until we cannot find any more boundaries\n  let boundaryIndex;\n\n  while (boundaryIndex !== -1) {\n    // Search for the next boundary in the message, starting\n    // from the current offset position\n    boundaryIndex = findToken(message, boundary, offset);\n\n    // If no further boundaries are found, stop here.\n    if (boundaryIndex === -1) {\n      break;\n    }\n\n    const headerTokenIndex = findToken(\n      message,\n      separator,\n      offset,\n      maxSearchLength,\n    );\n    if (headerTokenIndex === -1) {\n      throw new Error('Response message part has no mime header');\n    }\n    offset = headerTokenIndex + separator.length;\n\n    // Extract data from response message, excluding \"\\r\\n\"\n    const spacingLength = 2;\n    const data = response.slice(offset, boundaryIndex - spacingLength);\n\n    // Add the data to the array of results\n    components.push(data);\n\n    // Move the offset to the end of the current section,\n    // plus the identified boundary\n    offset = boundaryIndex + boundaryLength;\n  }\n\n  return components;\n}\n\nexport {\n  containsToken,\n  findToken,\n  identifyBoundary,\n  uint8ArrayToString,\n  stringToUint8Array,\n  multipartEncode,\n  multipartDecode,\n  guid,\n};\n","import { multipartEncode, multipartDecode } from './message.js';\n\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null;\n}\n\nfunction isEmptyObject(obj) {\n  return Object.keys(obj).length === 0 && obj.constructor === Object;\n}\n\nfunction areValidRequestHooks(requestHooks) {\n  const isValid =\n    Array.isArray(requestHooks) &&\n    requestHooks.every(\n      requestHook =>\n        typeof requestHook === 'function' && requestHook.length === 2,\n    );\n\n  if (!isValid) {\n    console.warn(\n      'Request hooks should have the following signature: ' +\n        'function requestHook(request, metadata) { return request; }',\n    );\n  }\n\n  return isValid;\n}\n\nconst getFirstResult = result => result[0];\n\nconst MEDIATYPES = {\n  DICOM: 'application/dicom',\n  DICOM_JSON: 'application/dicom+json',\n  OCTET_STREAM: 'application/octet-stream',\n  PDF: 'application/pdf',\n  JPEG: 'image/jpeg',\n  PNG: 'image/png',\n};\n\n/**\n * debugLog is a function that can be called with console.log arguments, and will\n * be conditionally displayed, only when debug logging is enabled.\n */\nlet debugLog = () => {};\n\n/**\n * @typedef { import(\"../types/types\").InstanceMetadata } InstanceMetadata\n */\n\n/**\n * A callback with the request instance and metadata information\n * of the currently request being executed that should necessarily\n * return the given request optionally modified.\n * @typedef {function} RequestHook\n * @param {XMLHttpRequest} request - The original XMLHttpRequest instance.\n * @param {object} metadata - The metadata used by the request.\n */\n\n/**\n * Class for interacting with DICOMweb RESTful services.\n */\nclass DICOMwebClient {\n  /**\n   * @constructor\n   * @param {Object} options\n   * @param {String} options.url - URL of the DICOMweb RESTful Service endpoint\n   * @param {String=} options.qidoURLPrefix - URL path prefix for QIDO-RS\n   * @param {String=} options.wadoURLPrefix - URL path prefix for WADO-RS\n   * @param {String=} options.stowURLPrefix - URL path prefix for STOW-RS\n   * @param {String=} options.username - Username\n   * @param {String=} options.password - Password\n   * @param {Object=} options.headers - HTTP headers\n   * @param {Array.<RequestHook>=} options.requestHooks - Request hooks.\n   * @param {Object=} options.verbose - print to console request warnings and errors, default true\n   * @param {Object=} options.debug - print to the console debug level information/status updates.\n   * @param {boolean|String} options.singlepart - retrieve singlepart for the named types.\n   * The available types are:  bulkdata, video, image.  true means all.\n   */\n  constructor(options) {\n    this.baseURL = options.url;\n    if (!this.baseURL) {\n      console.error('no DICOMweb base url provided - calls that require a URL will fail');\n    }\n\n    if ('username' in options) {\n      this.username = options.username;\n      if (!('password' in options)) {\n        console.error(\n          'no password provided to authenticate with DICOMweb service',\n        );\n      }\n      this.password = options.password;\n    }\n\n    if ('qidoURLPrefix' in options) {\n      debugLog(`use URL prefix for QIDO-RS: ${options.qidoURLPrefix}`);\n      this.qidoURL = `${this.baseURL}/${options.qidoURLPrefix}`;\n    } else {\n      this.qidoURL = this.baseURL;\n    }\n\n    if ('wadoURLPrefix' in options) {\n      debugLog(`use URL prefix for WADO-RS: ${options.wadoURLPrefix}`);\n      this.wadoURL = `${this.baseURL}/${options.wadoURLPrefix}`;\n    } else {\n      this.wadoURL = this.baseURL;\n    }\n\n    if ('stowURLPrefix' in options) {\n      debugLog(`use URL prefix for STOW-RS: ${options.stowURLPrefix}`);\n      this.stowURL = `${this.baseURL}/${options.stowURLPrefix}`;\n    } else {\n      this.stowURL = this.baseURL;\n    }\n\n    if (options.singlepart) {\n      debugLog('use singlepart', options.singlepart);\n      this.singlepart = options.singlepart === true ? 'bulkdata,video,image' : options.singlepart;\n    } else {\n      this.singlepart = '';\n    }\n\n    if ('requestHooks' in options) {\n      this.requestHooks = options.requestHooks;\n    }\n\n    // Headers to pass to requests.\n    this.headers = options.headers || {};\n\n    // Optional error interceptor callback to handle any failed request.\n    this.errorInterceptor = options.errorInterceptor || (() => undefined);\n\n    // Verbose - print to console request warnings and errors, default true\n    this.verbose = options.verbose !== false;\n\n    this.setDebug(options.debug);\n \n\n  }\n\n  /**\n   * Allows setting the debug log information. \n   * Note this is different from verbose in that verbose is whether to include warning/error information, defaulting to true\n   * \n   * @param {boolean} debugLevel \n   * @param {function} debugLogFunction to call with the debug output arguments. \n   */\n  setDebug(debugLevel = false, debugLogFunction = null) {\n    this.debugLevel = !!debugLevel;\n    debugLog = debugLogFunction || debugLevel ? console.log : () => {};\n  }\n\n  /**\n   * Gets debug flag\n   * \n   * @returns true if debug logging is enabled\n   */\n  getDebug() {\n    return this.debugLevel;\n  }\n \n  /**\n   * Sets verbose flag.\n   *\n   * @param {Boolean} verbose\n   */\n  setVerbose(verbose) {\n    this.verbose = verbose;\n  }\n\n  /**\n   * Gets verbose flag.\n   *\n   * @return {Boolean} verbose\n   */\n  getVerbose() {\n    return this.verbose;\n  }\n\n  static _parseQueryParameters(params = {}) {\n    let queryString = '?';\n    Object.keys(params).forEach((key, index) => {\n      if (index !== 0) {\n        queryString += '&';\n      }\n      queryString += `${key}=${encodeURIComponent(params[key])}`;\n    });\n    return queryString;\n  }\n\n  /**\n   * Performs an HTTP request.\n   *\n   * @param {String} url\n   * @param {String} method\n   * @param {Object} headers\n   * @param {Object} options\n   * @param {Array.<RequestHook>} options.requestHooks - Request hooks.\n   * @param {XMLHttpRequest} [options.request] - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n   * @return {*}\n   * @private\n   */\n  _httpRequest(url, method, headers = {}, options = {}) {\n    const { errorInterceptor, requestHooks } = this;\n\n    return new Promise((resolve, reject) => {\n      let request = options.request ? options.request : new XMLHttpRequest();\n\n      request.open(method, url, true);\n      if ('responseType' in options) {\n        request.responseType = options.responseType;\n      }\n\n      if (typeof headers === 'object') {\n        Object.keys(headers).forEach(key => {\n          request.setRequestHeader(key, headers[key]);\n        });\n      }\n\n      // now add custom headers from the user\n      // (e.g. access tokens)\n      const userHeaders = this.headers;\n      Object.keys(userHeaders).forEach(key => {\n        request.setRequestHeader(key, userHeaders[key]);\n      });\n\n      // Event triggered when upload starts\n      request.onloadstart = function onloadstart() {\n        debugLog('upload started: ', url)\n      };\n\n      // Event triggered when upload ends\n      request.onloadend = function onloadend() {\n        debugLog('upload finished')\n      };\n\n      // Handle response message\n      request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n          if (request.status === 200) {\n            const contentType = request.getResponseHeader('Content-Type');\n            // Automatically distinguishes between multipart and singlepart in an array buffer, and\n            // converts them into a consistent type.\n            if (contentType && contentType.indexOf('multipart') !== -1) {\n              resolve(multipartDecode(request.response));\n            } else if (request.responseType === 'arraybuffer') {\n              resolve([request.response]);\n            } else {\n              resolve(request.response);\n            }\n          } else if (request.status === 202) {\n            if (this.verbose) {\n              console.warn('some resources already existed: ', request);\n            }\n            resolve(request.response);\n          } else if (request.status === 204) {\n            if (this.verbose) {\n              console.warn('empty response for request: ', request);\n            }\n            resolve([]);\n          } else {\n            const error = new Error('request failed');\n            error.request = request;\n            error.response = request.response;\n            error.status = request.status;\n            if (this.verbose) {\n              console.error('request failed: ', request);\n              console.error(error);\n              console.error(error.response);\n            }\n\n            errorInterceptor(error);\n\n            reject(error);\n          }\n        }\n      };\n\n      // Event triggered while download progresses\n      if ('progressCallback' in options) {\n        if (typeof options.progressCallback === 'function') {\n          request.onprogress = options.progressCallback;\n        }\n      }\n\n      if (requestHooks && areValidRequestHooks(requestHooks)) {\n        const combinedHeaders = Object.assign({}, headers, this.headers);\n        const metadata = { method, url, headers: combinedHeaders };\n        const pipeRequestHooks = functions => args =>\n          functions.reduce((props, fn) => fn(props, metadata), args);\n        const pipedRequest = pipeRequestHooks(requestHooks);\n        request = pipedRequest(request);\n      }\n\n      // Add withCredentials to request if needed\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          request.withCredentials = true;\n        }\n      }\n\n      if ('data' in options) {\n        request.send(options.data);\n      } else {\n        request.send();\n      }\n    });\n  }\n\n  /**\n   * Performs an HTTP GET request.\n   *\n   * @param {String} url\n   * @param {Object} headers\n   * @param {Object} responseType\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGet(url, headers, responseType, progressCallback, withCredentials) {\n    return this._httpRequest(url, 'get', headers, {\n      responseType,\n      progressCallback,\n      withCredentials,\n    });\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with application/json\n   * media type.\n   *\n   * @param {String} url\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetApplicationJson(url, params = {}, progressCallback, withCredentials) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n    const headers = { Accept: MEDIATYPES.DICOM_JSON };\n    const responseType = 'json';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with application/pdf\n   * media type.\n   *\n   * @param {String} url\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetApplicationPdf(url, params = {}, progressCallback, withCredentials) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n    const headers = { Accept: MEDIATYPES.PDF };\n    const responseType = 'json';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with an image\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetImage(\n    url,\n    mediaTypes,\n    params = {},\n    progressCallback,\n    withCredentials,\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'image/',\n      'image/*',\n      'image/jpeg',\n      'image/jp2',\n      'image/gif',\n      'image/png',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = 'arraybuffer';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with a text\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetText(\n    url,\n    mediaTypes,\n    params = {},\n    progressCallback,\n    withCredentials,\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'text/',\n      'text/*',\n      'text/html',\n      'text/plain',\n      'text/rtf',\n      'text/xml',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = 'arraybuffer';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with a video\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetVideo(\n    url,\n    mediaTypes,\n    params = {},\n    progressCallback,\n    withCredentials,\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'video/',\n      'video/*',\n      'video/mpeg',\n      'video/mp4',\n      'video/H265',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = 'arraybuffer';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Asserts that a given media type is valid.\n   *\n   * @params {String} mediaType media type\n   */\n  static _assertMediaTypeIsValid(mediaType) {\n    if (!mediaType) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    const sepIndex = mediaType.indexOf('/');\n    if (sepIndex === -1) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    const mediaTypeType = mediaType.slice(0, sepIndex);\n    const types = ['application', 'image', 'text', 'video'];\n    if (!types.includes(mediaTypeType)) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    if (mediaType.slice(sepIndex + 1).includes('/')) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message with an image media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange - Start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartImage(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    rendered = false,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    let supportedMediaTypes;\n    if (rendered) {\n      supportedMediaTypes = [\n        'image/jpeg',\n        'image/gif',\n        'image/png',\n        'image/jp2',\n      ];\n    } else {\n      supportedMediaTypes = {\n        '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],\n        '1.2.840.10008.1.2.4.50': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.51': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.57': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.70': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.90': ['image/jp2'],\n        '1.2.840.10008.1.2.4.91': ['image/jp2'],\n        '1.2.840.10008.1.2.4.92': ['image/jpx'],\n        '1.2.840.10008.1.2.4.93': ['image/jpx'],\n      };\n\n      if (byteRange) {\n        headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n      }\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message with a video media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange - Start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartVideo(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    rendered = false,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    let supportedMediaTypes;\n    if (rendered) {\n      supportedMediaTypes = [\n        'video/',\n        'video/*',\n        'video/mpeg2',\n        'video/mp4',\n        'video/H265',\n      ];\n    } else {\n      supportedMediaTypes = {\n        '1.2.840.10008.1.2.4.100': ['video/mpeg2'],\n        '1.2.840.10008.1.2.4.101': ['video/mpeg2'],\n        '1.2.840.10008.1.2.4.102': ['video/mp4'],\n        '1.2.840.10008.1.2.4.103': ['video/mp4'],\n        '1.2.840.10008.1.2.4.104': ['video/mp4'],\n        '1.2.840.10008.1.2.4.105': ['video/mp4'],\n        '1.2.840.10008.1.2.4.106': ['video/mp4'],\n      };\n\n      if (byteRange) {\n        headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n      }\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message\n   * with a application/dicom media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartApplicationDicom(\n    url,\n    mediaTypes,\n    params,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    const defaultMediaType = 'application/dicom';\n    const supportedMediaTypes = {\n      '1.2.840.10008.1.2.1': [defaultMediaType],\n      '1.2.840.10008.1.2.5': [defaultMediaType],\n      '1.2.840.10008.1.2.4.50': [defaultMediaType],\n      '1.2.840.10008.1.2.4.51': [defaultMediaType],\n      '1.2.840.10008.1.2.4.57': [defaultMediaType],\n      '1.2.840.10008.1.2.4.70': [defaultMediaType],\n      '1.2.840.10008.1.2.4.80': [defaultMediaType],\n      '1.2.840.10008.1.2.4.81': [defaultMediaType],\n      '1.2.840.10008.1.2.4.90': [defaultMediaType],\n      '1.2.840.10008.1.2.4.91': [defaultMediaType],\n      '1.2.840.10008.1.2.4.92': [defaultMediaType],\n      '1.2.840.10008.1.2.4.93': [defaultMediaType],\n      '1.2.840.10008.1.2.4.100': [defaultMediaType],\n      '1.2.840.10008.1.2.4.101': [defaultMediaType],\n      '1.2.840.10008.1.2.4.102': [defaultMediaType],\n      '1.2.840.10008.1.2.4.103': [defaultMediaType],\n      '1.2.840.10008.1.2.4.104': [defaultMediaType],\n      '1.2.840.10008.1.2.4.105': [defaultMediaType],\n      '1.2.840.10008.1.2.4.106': [defaultMediaType],\n    };\n\n    let acceptableMediaTypes = mediaTypes;\n    if (!mediaTypes) {\n      acceptableMediaTypes = [{ mediaType: defaultMediaType }];\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      acceptableMediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message\n   * with a application/octet-stream, OR any of the equivalencies for that (eg\n   * application/pdf etc)\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartApplicationOctetStream(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    const defaultMediaType = 'application/octet-stream';\n    const supportedMediaTypes = {\n      '1.2.840.10008.1.2.1': [...Object.values(MEDIATYPES)],\n    };\n\n    let acceptableMediaTypes = mediaTypes;\n    if (!mediaTypes) {\n      acceptableMediaTypes = [{ mediaType: defaultMediaType }];\n    }\n\n    if (byteRange) {\n      headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      acceptableMediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP POST request.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object} headers - HTTP header fields\n   * @param {Array} data - Data that should be stored\n   * @param {Function} progressCallback\n   * @param {Function} progressCallback\n   * @param {XMLHttpRequest} request - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n   * @private\n   * @returns {Promise} Response\n   */\n  _httpPost(url, headers, data, progressCallback, withCredentials, request) {\n    return this._httpRequest(url, 'post', headers, {\n      data,\n      progressCallback,\n      withCredentials,\n      request,\n    });\n  }\n\n  /**\n   * Performs an HTTP POST request with content-type application/dicom+json.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object} headers - HTTP header fields\n   * @param {Array} data - Data that should be stored\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise} Response\n   */\n  _httpPostApplicationJson(url, data, progressCallback, withCredentials) {\n    const headers = { 'Content-Type': MEDIATYPES.DICOM_JSON };\n    return this._httpPost(\n      url,\n      headers,\n      data,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Parses media type and extracts its type and subtype.\n   *\n   * @param {String} mediaType - HTTP media type (e.g. image/jpeg)\n   * @private\n   * @returns {String[]} Media type and subtype\n   */\n  static _parseMediaType(mediaType) {\n    DICOMwebClient._assertMediaTypeIsValid(mediaType);\n\n    return mediaType.split('/');\n  }\n\n  /**\n   * Builds an accept header field value for HTTP GET request messages.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types\n   * @param {Object[]} supportedMediaTypes - Supported media types\n   * @return {*}\n   * @private\n   */\n  static _buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes) {\n    if (!Array.isArray(mediaTypes)) {\n      throw new Error('Acceptable media types must be provided as an Array');\n    }\n\n    const fieldValueParts = mediaTypes.map(item => {\n      const { mediaType } = item;\n\n      DICOMwebClient._assertMediaTypeIsValid(mediaType);\n      if (!supportedMediaTypes.includes(mediaType)) {\n        throw new Error(\n          `Media type ${mediaType} is not supported for requested resource`,\n        );\n      }\n\n      return mediaType;\n    });\n\n    return fieldValueParts.join(', ');\n  }\n\n  /**\n   * Builds an accept header field value for HTTP GET multipart request\n   * messages.  Will throw an exception if no media types are found which are acceptable,\n   * but will only log a verbose level message when types are specified which are\n   * not acceptable.  This allows requesting several types with having to know\n   * whether they are all acceptable or not.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types\n   * @param {Object[]} supportedMediaTypes - Supported media types\n   * @private\n   */\n  static _buildMultipartAcceptHeaderFieldValue(\n    mediaTypes,\n    supportedMediaTypes,\n  ) {\n    if (!Array.isArray(mediaTypes)) {\n      throw new Error('Acceptable media types must be provided as an Array');\n    }\n\n    if (!Array.isArray(supportedMediaTypes) && !isObject(supportedMediaTypes)) {\n      throw new Error(\n        'Supported media types must be provided as an Array or an Object',\n      );\n    }\n\n    const fieldValueParts = [];\n\n    mediaTypes.forEach(item => {\n      const { transferSyntaxUID, mediaType } = item;\n      DICOMwebClient._assertMediaTypeIsValid(mediaType);\n      let fieldValue = `multipart/related; type=\"${mediaType}\"`;\n\n      if (isObject(supportedMediaTypes)) {\n        // SupportedMediaTypes is a lookup table that maps Transfer Syntax UID\n        // to one or more Media Types\n        if (\n          !Object.values(supportedMediaTypes)\n            .flat(1)\n            .includes(mediaType)\n        ) {\n          if (!mediaType.endsWith('/*') || !mediaType.endsWith('/')) {\n            debugLog(\n              `Media type ${mediaType} is not supported for requested resource`,\n            );\n            return;\n          }\n        }\n\n        if (transferSyntaxUID) {\n          if (transferSyntaxUID !== '*') {\n            if (!Object.keys(supportedMediaTypes).includes(transferSyntaxUID)) {\n              throw new Error(\n                `Transfer syntax ${transferSyntaxUID} is not supported for requested resource`,\n              );\n            }\n\n            const expectedMediaTypes = supportedMediaTypes[transferSyntaxUID];\n\n            if (!expectedMediaTypes.includes(mediaType)) {\n              const actualType = DICOMwebClient._parseMediaType(mediaType)[0];\n              expectedMediaTypes.map(expectedMediaType => {\n                const expectedType = DICOMwebClient._parseMediaType(\n                  expectedMediaType,\n                )[0];\n                const haveSameType = actualType === expectedType;\n\n                if (\n                  haveSameType &&\n                  (mediaType.endsWith('/*') || mediaType.endsWith('/'))\n                ) {\n                  return;\n                }\n\n                throw new Error(\n                  `Transfer syntax ${transferSyntaxUID} is not supported for requested resource`,\n                );\n              });\n            }\n          }\n\n          fieldValue += `; transfer-syntax=${transferSyntaxUID}`;\n        }\n      } else if (\n        Array.isArray(supportedMediaTypes) &&\n        !supportedMediaTypes.includes(mediaType)\n      ) {\n        if( this.verbose ) {\n          console.warn(\n            `Media type ${mediaType} is not supported for requested resource`,\n          );\n        }\n        return;\n      }\n\n      fieldValueParts.push(fieldValue);\n    });\n\n    if( !fieldValueParts.length ) {\n      throw new Error(`No acceptable media types found among ${JSON.stringify(mediaTypes)}`);\n    }\n\n    return fieldValueParts.join(', ');\n  }\n\n  /**\n   * Builds a range header field value for HTTP GET request messages.\n   *\n   * @param {Array} byteRange - Start and end of byte range\n   * @returns {String} Range header field value\n   * @private\n   */\n  static _buildRangeHeaderFieldValue(byteRange = []) {\n    if (byteRange.length === 1) {\n      return `bytes=${byteRange[0]}-`;\n    }\n    if (byteRange.length === 2) {\n      return `bytes=${byteRange[0]}-${byteRange[1]}`;\n    }\n\n    return 'bytes=0-';\n  }\n\n  /**\n   * Gets types that are shared among acceptable media types.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @private\n   * @returns {String[]} Types that are shared among acceptable media types\n   */\n  static _getSharedMediaTypes(mediaTypes) {\n    const types = new Set();\n\n    if (!mediaTypes || !mediaTypes.length) {\n      return types;\n    }\n\n    mediaTypes.forEach(item => {\n      const { mediaType } = item;\n      const type = DICOMwebClient._parseMediaType(mediaType)[0];\n      types.add(`${type}/`);\n    });\n\n    return Array.from(types);\n  }\n\n  /**\n   * Gets common base type of acceptable media types and asserts that only\n   one type is specified. For example, ``(\"image/jpeg\", \"image/jp2\")``\n   will pass, but ``(\"image/jpeg\", \"video/mpeg2\")`` will raise an\n   exception.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @private\n   * @returns {String[]} Common media type, eg `image/` for the above example.\n   */\n  static _getCommonMediaType(mediaTypes) {\n    if (!mediaTypes || !mediaTypes.length) {\n      throw new Error('No acceptable media types provided');\n    }\n\n    const sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n    if (sharedMediaTypes.length === 0) {\n      throw new Error('No common acceptable media type could be identified.');\n    } else if (sharedMediaTypes.length > 1) {\n      throw new Error('Acceptable media types must have the same type.');\n    }\n\n    return sharedMediaTypes[0];\n  }\n\n  /**\n   * Searches for DICOM studies.\n   *\n   * @param {Object} options\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @return {Object[]} Study representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2)\n   */\n  searchForStudies(options = {}) {\n    debugLog('search for studies');\n    let withCredentials = false;\n    let url = `${this.qidoURL}/studies`;\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves metadata for a DICOM study.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance\n                      belonging to the study\n   */\n  retrieveStudyMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of study metadata',\n      );\n    }\n    debugLog(`retrieve metadata of study ${options.studyInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/metadata`;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Searches for DICOM series.\n   *\n   * @param {Object} options\n   * @param {Object} [options.studyInstanceUID] - Study Instance UID\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Object[]} Series representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2a)\n   */\n  searchForSeries(options = {}) {\n    let url = this.qidoURL;\n    if ('studyInstanceUID' in options) {\n      debugLog(`search series of study ${options.studyInstanceUID}`);\n      url += `/studies/${options.studyInstanceUID}`;\n    }\n    url += '/series';\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves metadata for a DICOM series.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance\n                      belonging to the series\n   */\n  retrieveSeriesMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of series metadata',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of series metadata',\n      );\n    }\n\n    debugLog(`retrieve metadata of series ${options.seriesInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/metadata`;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Searches for DICOM Instances.\n   *\n   * @param {Object} options\n   * @param {String} [options.studyInstanceUID] - Study Instance UID\n   * @param {String} [options.seriesInstanceUID] - Series Instance UID\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Object[]} Instance representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2b)\n   */\n  searchForInstances(options = {}) {\n    let url = this.qidoURL;\n    let withCredentials = false;\n    if ('studyInstanceUID' in options) {\n      url += `/studies/${options.studyInstanceUID}`;\n      if ('seriesInstanceUID' in options) {\n        debugLog(\n          `search for instances of series ${options.seriesInstanceUID}`,\n        );\n        url += `/series/${options.seriesInstanceUID}`;\n      } else {\n        debugLog(\n          `search for instances of study ${options.studyInstanceUID}`,\n        );\n      }\n    } else {\n      debugLog('search for instances');\n    }\n    url += '/instances';\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /** Returns a WADO-URI URL for an instance\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {String} WADO-URI URL\n   */\n  buildInstanceWadoURIUrl(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required.');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required.');\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error('SOP Instance UID is required.');\n    }\n\n    const contentType = options.contentType || MEDIATYPES.DICOM;\n    const transferSyntax = options.transferSyntax || '*';\n    const params = [];\n\n    params.push('requestType=WADO');\n    params.push(`studyUID=${options.studyInstanceUID}`);\n    params.push(`seriesUID=${options.seriesInstanceUID}`);\n    params.push(`objectUID=${options.sopInstanceUID}`);\n    params.push(`contentType=${contentType}`);\n    params.push(`transferSyntax=${transferSyntax}`);\n\n    const paramString = params.join('&');\n\n    return `${this.wadoURL}?${paramString}`;\n  }\n\n  /**\n   * Retrieves metadata for a DICOM Instance.\n   *\n   * @param {Object} options object\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {Promise<InstanceMetadata>} metadata elements in DICOM JSON format\n   */\n  retrieveInstanceMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    debugLog(`retrieve metadata of instance ${options.sopInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/metadata`;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves frames for a DICOM Instance.\n   * @param {Object} options options object\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @returns {Array} frame items as byte arrays of the pixel data element\n   */\n  retrieveInstanceFrames(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of instance frames',\n      );\n    }\n    debugLog(\n      `retrieve frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}`;\n\n    const { mediaTypes } = options;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url,\n        false,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n    if (sharedMediaTypes.length > 1) {\n      /**\n       * Enable request of frames that are stored either compressed\n       * (image/* media type) or uncompressed (application/octet-stream\n       * media type).\n       */\n      const supportedMediaTypes = {\n        '1.2.840.10008.1.2.1': ['application/octet-stream'],\n        '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],\n        '1.2.840.10008.1.2.4.50': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.51': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.57': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.70': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.90': ['image/jp2'],\n        '1.2.840.10008.1.2.4.91': ['image/jp2'],\n        '1.2.840.10008.1.2.4.92': ['image/jpx'],\n        '1.2.840.10008.1.2.4.93': ['image/jpx'],\n        '1.2.840.10008.1.2.4.201': ['image/jhc'],\n        '1.2.840.10008.1.2.4.202': ['image/jhc'],\n      };\n\n      const headers = {\n        Accept: DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n          mediaTypes,\n          supportedMediaTypes,\n        ),\n      };\n      return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n\n    if (commonMediaType.startsWith('application')) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url,\n        mediaTypes,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetMultipartImage(\n        url,\n        mediaTypes,\n        false,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetMultipartVideo(\n        url,\n        mediaTypes,\n        false,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of frames.`,\n    );\n  }\n\n /**\n * Element in mediaTypes parameter\n * @typedef {Object} MediaType\n * @param {String} [MediaType.mediaType] - ie 'image/jpeg', 'image/png'...\n */\n\n  /**\n   * Retrieves an individual, server-side rendered DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Promise<ArrayBuffer>} Rendered DICOM Instance\n   */\n  retrieveInstanceRendered(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance',\n      );\n    }\n\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/rendered`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        responseType,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetVideo(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('text')) {\n      return this._httpGetText(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType === MEDIATYPES.PDF) {\n      return this._httpGetApplicationPdf(\n        url,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered instance.',\n    );\n  }\n\n  /**\n   * Retrieves a thumbnail of an DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer} Thumbnail\n   */\n  retrieveInstanceThumbnail(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance',\n      );\n    }\n\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/thumbnail`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        responseType,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered instance.',\n    );\n  }\n\n  /**\n   * Retrieves rendered frames for a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n   */\n  retrieveInstanceFramesRendered(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of rendered instance frames',\n      );\n    }\n\n    debugLog(\n      `retrieve rendered frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}/rendered`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(url, headers, responseType, false, withCredentials);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetVideo(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered frame.',\n    );\n  }\n\n  /**\n   * Retrieves thumbnail of frames for a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n   */\n  retrieveInstanceFramesThumbnail(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of rendered instance frames',\n      );\n    }\n\n    console.debug(\n      `retrieve rendered frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}/thumbnail`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        responseType,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered frame.',\n    );\n  }\n\n  /**\n   * Retrieves a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {Promise<ArrayBuffer>} DICOM Part 10 file as Arraybuffer\n   */\n  retrieveInstance(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required');\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error('SOP Instance UID is required');\n    }\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}`;\n\n    const { mediaTypes } = options;\n    const { withCredentials = false } = options;\n    const { progressCallback = false } = options;\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      ).then(getFirstResult);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        progressCallback,\n        withCredentials,\n      ).then(getFirstResult);\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of instance.`,\n    );\n  }\n\n  /**\n   * Retrieves all DICOM Instances of a Series.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {Function} options.progressCallback\n   * @returns {Promise<ArrayBuffer[]>} DICOM Instances\n   */\n  retrieveSeries(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required');\n    }\n\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}`;\n\n    const { mediaTypes } = options;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of series.`,\n    );\n  }\n\n  /**\n   * Retrieves all DICOM Instances of a Study.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @returns {ArrayBuffer[]} DICOM Instances\n   */\n  retrieveStudy(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}`;\n\n    const { mediaTypes } = options;\n    const { withCredentials = false } = options;\n    const { progressCallback = false } = options;\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of study.`,\n    );\n  }\n\n  /**\n   * Retrieves and parses BulkData from a BulkDataURI location.\n   * Decodes the multipart encoded data and returns the resulting data\n   * as an ArrayBuffer.\n   *\n   * See http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.5.5.html\n   *\n   * @param {Object} options\n   * @param {string} options.BulkDataURI to retrieve\n   * @param {Array}  options.mediaTypes to use to fetch the URI\n   * @param {string} options.byteRange to request a sub-range (only valid on single part)\n   * @returns {Promise<Array>} Bulkdata parts\n   */\n  retrieveBulkData(options) {\n    if (!('BulkDataURI' in options)) {\n      throw new Error('BulkDataURI is required.');\n    }\n\n    const url = options.BulkDataURI;\n    const { mediaTypes, byteRange } = options;\n    const { withCredentials = false } = options;\n    const { progressCallback = false } = options;\n\n    if (this.singlepart.indexOf('bulkdata') !== -1) {\n      return this._httpGet(url, options.headers, 'arraybuffer', null, withCredentials);\n    }\n\n    if (mediaTypes) {\n      try {\n        const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n\n        if (commonMediaType==='image/') {\n          return this._httpGetMultipartImage(\n            url,\n            mediaTypes,\n            byteRange,\n            false,\n            false,\n            progressCallback,\n            withCredentials,\n          );\n        }\n      } catch(e) {\n        // No-op - this happens sometimes if trying to fetch the specific desired type but want to fallback to octet-stream\n      }\n    }\n\n    // Just use the media types provided\n    return this._httpGetMultipartApplicationOctetStream(\n      url,\n      mediaTypes,\n      byteRange,\n      false,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Stores DICOM Instances.\n   *\n   * @param {Object} options\n   * @param {ArrayBuffer[]} options.datasets - DICOM Instances in PS3.10 format\n   * @param {String} [options.studyInstanceUID] - Study Instance UID\n   * @param {XMLHttpRequest} [options.request] - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n   * @returns {Promise} Response message\n   */\n  storeInstances(options) {\n    if (!('datasets' in options)) {\n      throw new Error('datasets are required for storing');\n    }\n\n    let url = `${this.stowURL}/studies`;\n    if ('studyInstanceUID' in options) {\n      url += `/${options.studyInstanceUID}`;\n    }\n\n    const { data, boundary } = multipartEncode(options.datasets);\n    const headers = {\n      'Content-Type': `multipart/related; type=\"application/dicom\"; boundary=\"${boundary}\"`,\n    };\n    const { withCredentials = false } = options;\n    return this._httpPost(\n      url,\n      headers,\n      data,\n      options.progressCallback,\n      withCredentials,\n      options.request,\n    );\n  }\n\n  \n}\n\n\nexport { DICOMwebClient };\nexport default DICOMwebClient;\n","function findSubstring(str, before, after) {\n  const beforeIndex = str.lastIndexOf(before) + before.length;\n  if (beforeIndex < before.length) {\n    return null;\n  }\n  if (after !== undefined) {\n    const afterIndex = str.lastIndexOf(after);\n    if (afterIndex < 0) {\n      return null;\n    }\n    return str.substring(beforeIndex, afterIndex);\n  }\n  return str.substring(beforeIndex);\n}\n\nfunction getStudyInstanceUIDFromUri(uri) {\n  let uid = findSubstring(uri, 'studies/', '/series');\n  if (!uid) {\n    uid = findSubstring(uri, 'studies/');\n  }\n  if (!uid) {\n    console.debug(\n      `Study Instance UID could not be dertermined from URI \"${uri}\"`,\n    );\n  }\n  return uid;\n}\n\nfunction getSeriesInstanceUIDFromUri(uri) {\n  let uid = findSubstring(uri, 'series/', '/instances');\n  if (!uid) {\n    uid = findSubstring(uri, 'series/');\n  }\n  if (!uid) {\n    console.debug(\n      `Series Instance UID could not be dertermined from URI \"${uri}\"`,\n    );\n  }\n  return uid;\n}\n\nfunction getSOPInstanceUIDFromUri(uri) {\n  let uid = findSubstring(uri, '/instances/', '/frames');\n  if (!uid) {\n    uid = findSubstring(uri, '/instances/', '/metadata');\n  }\n  if (!uid) {\n    uid = findSubstring(uri, '/instances/');\n  }\n  if (!uid) {\n    console.debug(`SOP Instance UID could not be dertermined from URI\"${uri}\"`);\n  }\n  return uid;\n}\n\n\nfunction getFrameNumbersFromUri(uri) {\n  let numbers = findSubstring(uri, '/frames/', '/rendered');\n  if (!numbers) {\n    numbers = findSubstring(uri, '/frames/');\n  }\n  if (numbers === undefined) {\n    console.debug(`Frame Numbers could not be dertermined from URI\"${uri}\"`);\n  }\n  return numbers.split(',');\n}\n\nexport {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri,\n};\n","export default '0.5.2';\n","import { DICOMwebClient } from './api.js';\nimport {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri,\n} from './utils.js';\n\nconst api = {\n  DICOMwebClient,\n};\nconst utils = {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri,\n};\n\nexport { default as version } from './version.js';\n\nexport { api, utils };\n"],"names":["uint8ArrayToString","arr","offset","limit","itemLimit","length","str","i","String","fromCharCode","stringToUint8Array","Uint8Array","j","charCodeAt","identifyBoundary","header","parts","split","substr","containsToken","message","token","index","findToken","maxSearchLength","searchLength","Math","min","guid","s4","floor","random","toString","substring","multipartEncode","datasets","boundary","contentType","contentTypeString","footer","headerArray","footerArray","headerLength","footerLength","contentArrays","map","datasetBuffer","contentArray","contentLength","multipartArray","set","position","forEach","data","buffer","multipartDecode","response","ArrayBuffer","isView","separator","headerIndex","Error","boundaryString","boundaryLength","components","boundaryIndex","headerTokenIndex","spacingLength","slice","push","isObject","obj","isEmptyObject","Object","keys","constructor","areValidRequestHooks","requestHooks","isValid","Array","isArray","every","requestHook","console","warn","getFirstResult","result","MEDIATYPES","DICOM","DICOM_JSON","OCTET_STREAM","PDF","JPEG","PNG","debugLog","DICOMwebClient","options","baseURL","url","error","username","password","qidoURLPrefix","qidoURL","wadoURLPrefix","wadoURL","stowURLPrefix","stowURL","singlepart","headers","errorInterceptor","undefined","verbose","setDebug","debug","debugLevel","debugLogFunction","log","method","Promise","resolve","reject","request","XMLHttpRequest","open","responseType","key","setRequestHeader","userHeaders","onloadstart","onloadend","onreadystatechange","readyState","status","getResponseHeader","indexOf","progressCallback","onprogress","combinedHeaders","assign","metadata","pipeRequestHooks","functions","args","reduce","props","fn","pipedRequest","withCredentials","send","_httpRequest","params","urlWithQueryParams","_parseQueryParameters","Accept","_httpGet","mediaTypes","supportedMediaTypes","acceptHeaderFieldValue","_buildAcceptHeaderFieldValue","byteRange","rendered","Range","_buildRangeHeaderFieldValue","_buildMultipartAcceptHeaderFieldValue","defaultMediaType","acceptableMediaTypes","mediaType","values","_httpPost","queryParams","_httpGetApplicationJson","studyInstanceUID","seriesInstanceUID","transferSyntax","sopInstanceUID","paramString","join","frameNumbers","_httpGetMultipartApplicationOctetStream","sharedMediaTypes","_getSharedMediaTypes","commonMediaType","_getCommonMediaType","startsWith","_httpGetMultipartImage","_httpGetMultipartVideo","_httpGetImage","_httpGetVideo","_httpGetText","_httpGetApplicationPdf","_httpGetMultipartApplicationDicom","then","BulkDataURI","e","queryString","encodeURIComponent","sepIndex","mediaTypeType","types","includes","_assertMediaTypeIsValid","fieldValueParts","item","transferSyntaxUID","fieldValue","flat","endsWith","expectedMediaTypes","actualType","_parseMediaType","expectedMediaType","expectedType","haveSameType","JSON","stringify","Set","type","add","from","findSubstring","before","after","beforeIndex","lastIndexOf","afterIndex","getStudyInstanceUIDFromUri","uri","uid","getSeriesInstanceUIDFromUri","getSOPInstanceUIDFromUri","getFrameNumbersFromUri","numbers","api","utils"],"mappings":"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"}