{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { m as macro } from '../../macros2.js';\nimport Constants from './Line/Constants.js';\nimport vtkCell from './Cell.js';\nimport { d as dot, e as distance2BetweenPoints, s as subtract, g as solveLinearSystem } from '../Core/Math/index.js';\nimport { quat } from 'gl-matrix';\nconst {\n  IntersectionState\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\nfunction distanceToLine(x, p1, p2) {\n  let closestPoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  const outObj = {\n    t: Number.MIN_VALUE,\n    distance: 0\n  };\n  const p21 = [];\n  let closest;\n  // Determine appropriate vector\n  p21[0] = p2[0] - p1[0];\n  p21[1] = p2[1] - p1[1];\n  p21[2] = p2[2] - p1[2];\n\n  // Get parametric location\n  const num = p21[0] * (x[0] - p1[0]) + p21[1] * (x[1] - p1[1]) + p21[2] * (x[2] - p1[2]);\n  const denom = dot(p21, p21);\n\n  // trying to avoid an expensive fabs\n  let tolerance = 1e-5 * num;\n  if (denom !== 0.0) {\n    outObj.t = num / denom;\n  }\n  if (tolerance < 0.0) {\n    tolerance = -tolerance;\n  }\n  if (-tolerance < denom && denom < tolerance) {\n    closest = p1;\n  } else if (denom <= 0.0 || outObj.t < 0.0) {\n    // If parametric coordinate is within 0<=p<=1, then the point is closest to\n    // the line.  Otherwise, it's closest to a point at the end of the line.\n    closest = p1;\n  } else if (outObj.t > 1.0) {\n    closest = p2;\n  } else {\n    closest = p21;\n    p21[0] = p1[0] + outObj.t * p21[0];\n    p21[1] = p1[1] + outObj.t * p21[1];\n    p21[2] = p1[2] + outObj.t * p21[2];\n  }\n  if (closestPoint) {\n    closestPoint[0] = closest[0];\n    closestPoint[1] = closest[1];\n    closestPoint[2] = closest[2];\n  }\n  outObj.distance = distance2BetweenPoints(closest, x);\n  return outObj;\n}\nfunction intersection(a1, a2, b1, b2, u, v) {\n  const a21 = [];\n  const b21 = [];\n  const b1a1 = [];\n  u[0] = 0.0;\n  v[0] = 0.0;\n\n  // Determine line vectors.\n  subtract(a2, a1, a21);\n  subtract(b2, b1, b21);\n  subtract(b1, a1, b1a1);\n\n  // Compute the system (least squares) matrix.\n  const A = [dot(a21, a21), -dot(a21, b21), -dot(a21, b21), dot(b21, b21)];\n\n  // Compute the least squares system constant term.\n  const c = [];\n  c[0] = dot(a21, b1a1);\n  c[1] = -dot(b21, b1a1);\n  // Solve the system of equations\n  if (solveLinearSystem(A, c, 2) === 0) {\n    // The lines are colinear. Therefore, one of the four endpoints is the\n    // point of closest approach\n    let minDist = Number.MAX_VALUE;\n    const p = [a1, a2, b1, b2];\n    const l1 = [b1, b1, a1, a1];\n    const l2 = [b2, b2, a2, a2];\n    [v[0], v[0], u[0], u[0]];\n    [u[0], u[0], v[0], v[0]];\n    let obj;\n    for (let i = 0; i < 4; i++) {\n      obj = distanceToLine(p[i], l1[i], l2[i]);\n      if (obj.distance < minDist) {\n        minDist = obj.distance;\n      }\n    }\n    return IntersectionState.ON_LINE;\n  }\n  u[0] = c[0];\n  v[0] = c[1];\n\n  // Check parametric coordinates for intersection.\n  if (u[0] >= 0.0 && u[0] <= 1.0 && v[0] >= 0.0 && v[0] <= 1.0) {\n    return IntersectionState.YES_INTERSECTION;\n  }\n  return IntersectionState.NO_INTERSECTION;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  distanceToLine,\n  intersection\n};\n\n// ----------------------------------------------------------------------------\n// vtkLine methods\n// ----------------------------------------------------------------------------\n\nfunction vtkLine(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkLine');\n  function isBetweenPoints(t) {\n    return t >= 0.0 && t <= 1.0;\n  }\n  publicAPI.getCellDimension = () => 1;\n  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {\n    const outObj = {\n      intersect: 0,\n      t: Number.MAX_VALUE,\n      subId: 0,\n      betweenPoints: null\n    };\n    pcoords[1] = 0.0;\n    pcoords[2] = 0.0;\n    const projXYZ = [];\n    const a1 = [];\n    const a2 = [];\n    model.points.getPoint(0, a1);\n    model.points.getPoint(1, a2);\n    const u = [];\n    const v = [];\n    const intersect = intersection(p1, p2, a1, a2, u, v);\n    outObj.t = u[0];\n    outObj.betweenPoints = isBetweenPoints(outObj.t);\n    pcoords[0] = v[0];\n    if (intersect === IntersectionState.YES_INTERSECTION) {\n      // make sure we are within tolerance\n      for (let i = 0; i < 3; i++) {\n        x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);\n        projXYZ[i] = p1[i] + outObj.t * (p2[i] - p1[i]);\n      }\n      if (distance2BetweenPoints(x, projXYZ) <= tol * tol) {\n        outObj.intersect = 1;\n        return outObj;\n      }\n    } else {\n      let outDistance;\n      // check to see if it lies within tolerance\n      // one of the parametric coords must be outside 0-1\n      if (outObj.t < 0.0) {\n        outDistance = distanceToLine(p1, a1, a2, x);\n        if (outDistance.distance <= tol * tol) {\n          outObj.t = 0.0;\n          outObj.intersect = 1;\n          outObj.betweenPoints = true; // Intersection is near p1\n          return outObj;\n        }\n        return outObj;\n      }\n      if (outObj.t > 1.0) {\n        outDistance = distanceToLine(p2, a1, a2, x);\n        if (outDistance.distance <= tol * tol) {\n          outObj.t = 1.0;\n          outObj.intersect = 1;\n          outObj.betweenPoints = true; // Intersection is near p2\n          return outObj;\n        }\n        return outObj;\n      }\n      if (pcoords[0] < 0.0) {\n        pcoords[0] = 0.0;\n        outDistance = distanceToLine(a1, p1, p2, x);\n        outObj.t = outDistance.t;\n        if (outDistance.distance <= tol * tol) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n        return outObj;\n      }\n      if (pcoords[0] > 1.0) {\n        pcoords[0] = 1.0;\n        outDistance = distanceToLine(a2, p1, p2, x);\n        outObj.t = outDistance.t;\n        if (outDistance.distance <= tol * tol) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n        return outObj;\n      }\n    }\n    return outObj;\n  };\n  publicAPI.evaluateLocation = (pcoords, x, weights) => {\n    const a1 = [];\n    const a2 = [];\n    model.points.getPoint(0, a1);\n    model.points.getPoint(1, a2);\n    for (let i = 0; i < 3; i++) {\n      x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);\n    }\n    weights[0] = 1.0 - pcoords[0];\n    weights[1] = pcoords[0];\n  };\n  publicAPI.evaluateOrientation = (pcoords, q, weights) => {\n    if (model.orientations) {\n      quat.slerp(q, model.orientations[0], model.orientations[1], pcoords[0]);\n      weights[0] = 1.0 - pcoords[0];\n      weights[1] = pcoords[0];\n      return true;\n    }\n    return false;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  orientations: null // an array of two quat or null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['orientations']);\n  vtkLine(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkLine');\n\n// ----------------------------------------------------------------------------\n\nvar vtkLine$1 = {\n  newInstance,\n  extend,\n  ...STATIC,\n  ...Constants\n};\nexport { STATIC, vtkLine$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","Constants","vtkCell","d","dot","e","distance2BetweenPoints","s","subtract","g","solveLinearSystem","quat","IntersectionState","distanceToLine","x","p1","p2","closestPoint","arguments","length","undefined","outObj","t","Number","MIN_VALUE","distance","p21","closest","num","denom","tolerance","intersection","a1","a2","b1","b2","u","v","a21","b21","b1a1","A","c","minDist","MAX_VALUE","p","l1","l2","obj","i","ON_LINE","YES_INTERSECTION","NO_INTERSECTION","STATIC","vtkLine","publicAPI","model","classHierarchy","push","isBetweenPoints","getCellDimension","intersectWithLine","tol","pcoords","intersect","subId","betweenPoints","projXYZ","points","getPoint","outDistance","evaluateLocation","weights","evaluateOrientation","q","orientations","slerp","DEFAULT_VALUES","extend","initialValues","Object","assign","setGet","newInstance","vtkLine$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Common/DataModel/Line.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport Constants from './Line/Constants.js';\nimport vtkCell from './Cell.js';\nimport { d as dot, e as distance2BetweenPoints, s as subtract, g as solveLinearSystem } from '../Core/Math/index.js';\nimport { quat } from 'gl-matrix';\n\nconst {\n  IntersectionState\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\nfunction distanceToLine(x, p1, p2) {\n  let closestPoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  const outObj = {\n    t: Number.MIN_VALUE,\n    distance: 0\n  };\n  const p21 = [];\n  let closest;\n  // Determine appropriate vector\n  p21[0] = p2[0] - p1[0];\n  p21[1] = p2[1] - p1[1];\n  p21[2] = p2[2] - p1[2];\n\n  // Get parametric location\n  const num = p21[0] * (x[0] - p1[0]) + p21[1] * (x[1] - p1[1]) + p21[2] * (x[2] - p1[2]);\n  const denom = dot(p21, p21);\n\n  // trying to avoid an expensive fabs\n  let tolerance = 1e-5 * num;\n  if (denom !== 0.0) {\n    outObj.t = num / denom;\n  }\n  if (tolerance < 0.0) {\n    tolerance = -tolerance;\n  }\n  if (-tolerance < denom && denom < tolerance) {\n    closest = p1;\n  } else if (denom <= 0.0 || outObj.t < 0.0) {\n    // If parametric coordinate is within 0<=p<=1, then the point is closest to\n    // the line.  Otherwise, it's closest to a point at the end of the line.\n    closest = p1;\n  } else if (outObj.t > 1.0) {\n    closest = p2;\n  } else {\n    closest = p21;\n    p21[0] = p1[0] + outObj.t * p21[0];\n    p21[1] = p1[1] + outObj.t * p21[1];\n    p21[2] = p1[2] + outObj.t * p21[2];\n  }\n  if (closestPoint) {\n    closestPoint[0] = closest[0];\n    closestPoint[1] = closest[1];\n    closestPoint[2] = closest[2];\n  }\n  outObj.distance = distance2BetweenPoints(closest, x);\n  return outObj;\n}\nfunction intersection(a1, a2, b1, b2, u, v) {\n  const a21 = [];\n  const b21 = [];\n  const b1a1 = [];\n  u[0] = 0.0;\n  v[0] = 0.0;\n\n  // Determine line vectors.\n  subtract(a2, a1, a21);\n  subtract(b2, b1, b21);\n  subtract(b1, a1, b1a1);\n\n  // Compute the system (least squares) matrix.\n  const A = [dot(a21, a21), -dot(a21, b21), -dot(a21, b21), dot(b21, b21)];\n\n  // Compute the least squares system constant term.\n  const c = [];\n  c[0] = dot(a21, b1a1);\n  c[1] = -dot(b21, b1a1);\n  // Solve the system of equations\n  if (solveLinearSystem(A, c, 2) === 0) {\n    // The lines are colinear. Therefore, one of the four endpoints is the\n    // point of closest approach\n    let minDist = Number.MAX_VALUE;\n    const p = [a1, a2, b1, b2];\n    const l1 = [b1, b1, a1, a1];\n    const l2 = [b2, b2, a2, a2];\n    [v[0], v[0], u[0], u[0]];\n    [u[0], u[0], v[0], v[0]];\n    let obj;\n    for (let i = 0; i < 4; i++) {\n      obj = distanceToLine(p[i], l1[i], l2[i]);\n      if (obj.distance < minDist) {\n        minDist = obj.distance;\n      }\n    }\n    return IntersectionState.ON_LINE;\n  }\n  u[0] = c[0];\n  v[0] = c[1];\n\n  // Check parametric coordinates for intersection.\n  if (u[0] >= 0.0 && u[0] <= 1.0 && v[0] >= 0.0 && v[0] <= 1.0) {\n    return IntersectionState.YES_INTERSECTION;\n  }\n  return IntersectionState.NO_INTERSECTION;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  distanceToLine,\n  intersection\n};\n\n// ----------------------------------------------------------------------------\n// vtkLine methods\n// ----------------------------------------------------------------------------\n\nfunction vtkLine(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkLine');\n  function isBetweenPoints(t) {\n    return t >= 0.0 && t <= 1.0;\n  }\n  publicAPI.getCellDimension = () => 1;\n  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {\n    const outObj = {\n      intersect: 0,\n      t: Number.MAX_VALUE,\n      subId: 0,\n      betweenPoints: null\n    };\n    pcoords[1] = 0.0;\n    pcoords[2] = 0.0;\n    const projXYZ = [];\n    const a1 = [];\n    const a2 = [];\n    model.points.getPoint(0, a1);\n    model.points.getPoint(1, a2);\n    const u = [];\n    const v = [];\n    const intersect = intersection(p1, p2, a1, a2, u, v);\n    outObj.t = u[0];\n    outObj.betweenPoints = isBetweenPoints(outObj.t);\n    pcoords[0] = v[0];\n    if (intersect === IntersectionState.YES_INTERSECTION) {\n      // make sure we are within tolerance\n      for (let i = 0; i < 3; i++) {\n        x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);\n        projXYZ[i] = p1[i] + outObj.t * (p2[i] - p1[i]);\n      }\n      if (distance2BetweenPoints(x, projXYZ) <= tol * tol) {\n        outObj.intersect = 1;\n        return outObj;\n      }\n    } else {\n      let outDistance;\n      // check to see if it lies within tolerance\n      // one of the parametric coords must be outside 0-1\n      if (outObj.t < 0.0) {\n        outDistance = distanceToLine(p1, a1, a2, x);\n        if (outDistance.distance <= tol * tol) {\n          outObj.t = 0.0;\n          outObj.intersect = 1;\n          outObj.betweenPoints = true; // Intersection is near p1\n          return outObj;\n        }\n        return outObj;\n      }\n      if (outObj.t > 1.0) {\n        outDistance = distanceToLine(p2, a1, a2, x);\n        if (outDistance.distance <= tol * tol) {\n          outObj.t = 1.0;\n          outObj.intersect = 1;\n          outObj.betweenPoints = true; // Intersection is near p2\n          return outObj;\n        }\n        return outObj;\n      }\n      if (pcoords[0] < 0.0) {\n        pcoords[0] = 0.0;\n        outDistance = distanceToLine(a1, p1, p2, x);\n        outObj.t = outDistance.t;\n        if (outDistance.distance <= tol * tol) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n        return outObj;\n      }\n      if (pcoords[0] > 1.0) {\n        pcoords[0] = 1.0;\n        outDistance = distanceToLine(a2, p1, p2, x);\n        outObj.t = outDistance.t;\n        if (outDistance.distance <= tol * tol) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n        return outObj;\n      }\n    }\n    return outObj;\n  };\n  publicAPI.evaluateLocation = (pcoords, x, weights) => {\n    const a1 = [];\n    const a2 = [];\n    model.points.getPoint(0, a1);\n    model.points.getPoint(1, a2);\n    for (let i = 0; i < 3; i++) {\n      x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);\n    }\n    weights[0] = 1.0 - pcoords[0];\n    weights[1] = pcoords[0];\n  };\n  publicAPI.evaluateOrientation = (pcoords, q, weights) => {\n    if (model.orientations) {\n      quat.slerp(q, model.orientations[0], model.orientations[1], pcoords[0]);\n      weights[0] = 1.0 - pcoords[0];\n      weights[1] = pcoords[0];\n      return true;\n    }\n    return false;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  orientations: null // an array of two quat or null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['orientations']);\n  vtkLine(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkLine');\n\n// ----------------------------------------------------------------------------\n\nvar vtkLine$1 = {\n  newInstance,\n  extend,\n  ...STATIC,\n  ...Constants\n};\n\nexport { STATIC, vtkLine$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}