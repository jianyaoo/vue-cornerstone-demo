"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SPHERE_STRATEGY = exports.thresholdInsideSphere = exports.fillInsideSphere = exports.fillOutsideSphere = void 0;
const core_1 = require("@cornerstonejs/core");
const gl_matrix_1 = require("gl-matrix");
const BrushStrategy_1 = __importDefault(require("./BrushStrategy"));
const compositions_1 = __importDefault(require("./compositions"));
const StrategyCallbacks_1 = __importDefault(require("../../../enums/StrategyCallbacks"));
const fillCircle_1 = require("./fillCircle");
const { transformWorldToIndex } = core_1.utilities;
const getSphereBoundsInfo_1 = require("../../../utilities/getSphereBoundsInfo");
const sphereComposition = {
    [StrategyCallbacks_1.default.Initialize]: (operationData) => {
        const { points, imageVoxelManager: imageVoxelManager, viewport, segmentationImageData, segmentationVoxelManager: segmentationVoxelManager, } = operationData;
        if (!points) {
            return;
        }
        const center = gl_matrix_1.vec3.fromValues(0, 0, 0);
        points.forEach((point) => {
            gl_matrix_1.vec3.add(center, center, point);
        });
        gl_matrix_1.vec3.scale(center, center, 1 / points.length);
        operationData.centerWorld = center;
        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);
        const { boundsIJK: newBoundsIJK, topLeftWorld, bottomRightWorld, } = (0, getSphereBoundsInfo_1.getSphereBoundsInfo)(points.slice(0, 2), segmentationImageData, viewport);
        segmentationVoxelManager.boundsIJK = newBoundsIJK;
        if (imageVoxelManager) {
            imageVoxelManager.isInObject = (0, fillCircle_1.createEllipseInPoint)({
                topLeftWorld,
                bottomRightWorld,
                center,
            });
        }
        else {
            segmentationVoxelManager.isInObject = (0, fillCircle_1.createEllipseInPoint)({
                topLeftWorld,
                bottomRightWorld,
                center,
            });
        }
    },
};
const SPHERE_STRATEGY = new BrushStrategy_1.default('Sphere', compositions_1.default.regionFill, compositions_1.default.setValue, sphereComposition, compositions_1.default.determineSegmentIndex, compositions_1.default.preview);
exports.SPHERE_STRATEGY = SPHERE_STRATEGY;
const fillInsideSphere = SPHERE_STRATEGY.strategyFunction;
exports.fillInsideSphere = fillInsideSphere;
const SPHERE_THRESHOLD_STRATEGY = new BrushStrategy_1.default('SphereThreshold', ...SPHERE_STRATEGY.compositions, compositions_1.default.dynamicThreshold, compositions_1.default.threshold, compositions_1.default.islandRemoval);
const thresholdInsideSphere = SPHERE_THRESHOLD_STRATEGY.strategyFunction;
exports.thresholdInsideSphere = thresholdInsideSphere;
function fillOutsideSphere() {
    throw new Error('fill outside sphere not implemented');
}
exports.fillOutsideSphere = fillOutsideSphere;
//# sourceMappingURL=fillSphere.js.map