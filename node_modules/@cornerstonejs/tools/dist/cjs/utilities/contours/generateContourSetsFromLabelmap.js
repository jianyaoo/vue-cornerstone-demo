"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateContourSetsFromLabelmap = void 0;
const core_1 = require("@cornerstonejs/core");
const ImageMarchingSquares_1 = __importDefault(require("@kitware/vtk.js/Filters/General/ImageMarchingSquares"));
const DataArray_1 = __importDefault(require("@kitware/vtk.js/Common/Core/DataArray"));
const ImageData_1 = __importDefault(require("@kitware/vtk.js/Common/DataModel/ImageData"));
const contours_1 = require("../contours");
const contourFinder_1 = require("./contourFinder");
const SegmentationRepresentations_1 = __importDefault(require("../../enums/SegmentationRepresentations"));
const { Labelmap } = SegmentationRepresentations_1.default;
function generateContourSetsFromLabelmap({ segmentations }) {
    var _a;
    const { representationData, segments = [0, 1] } = segmentations;
    const { volumeId: segVolumeId } = representationData[Labelmap];
    const vol = core_1.cache.getVolume(segVolumeId);
    if (!vol) {
        console.warn(`No volume found for ${segVolumeId}`);
        return;
    }
    const numSlices = vol.dimensions[2];
    const segData = vol.imageData.getPointData().getScalars().getData();
    const pixelsPerSlice = vol.dimensions[0] * vol.dimensions[1];
    for (let z = 0; z < numSlices; z++) {
        for (let y = 0; y < vol.dimensions[1]; y++) {
            const index = y * vol.dimensions[0] + z * pixelsPerSlice;
            segData[index] = 0;
            segData[index + vol.dimensions[0] - 1] = 0;
        }
    }
    const ContourSets = [];
    const { FrameOfReferenceUID } = vol.metadata;
    const numSegments = segments.length;
    for (let segIndex = 0; segIndex < numSegments; segIndex++) {
        const segment = segments[segIndex];
        if (!segment) {
            continue;
        }
        const sliceContours = [];
        const scalars = DataArray_1.default.newInstance({
            name: 'Scalars',
            numberOfComponents: 1,
            size: pixelsPerSlice * numSlices,
            dataType: 'Uint8Array',
        });
        const { containedSegmentIndices } = segment;
        for (let sliceIndex = 0; sliceIndex < numSlices; sliceIndex++) {
            if (isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex)) {
                continue;
            }
            const frameStart = sliceIndex * pixelsPerSlice;
            try {
                for (let i = 0; i < pixelsPerSlice; i++) {
                    const value = segData[i + frameStart];
                    if (value === segIndex || (containedSegmentIndices === null || containedSegmentIndices === void 0 ? void 0 : containedSegmentIndices.has(value))) {
                        scalars.setValue(i + frameStart, 1);
                    }
                    else {
                        scalars.setValue(i, 0);
                    }
                }
                const mSquares = ImageMarchingSquares_1.default.newInstance({
                    slice: sliceIndex,
                });
                const imageDataCopy = ImageData_1.default.newInstance();
                imageDataCopy.shallowCopy(vol.imageData);
                imageDataCopy.getPointData().setScalars(scalars);
                mSquares.setInputData(imageDataCopy);
                const cValues = [1];
                mSquares.setContourValues(cValues);
                mSquares.setMergePoints(false);
                const msOutput = mSquares.getOutputData();
                const reducedSet = (0, contours_1.getDeduplicatedVTKPolyDataPoints)(msOutput);
                if ((_a = reducedSet.points) === null || _a === void 0 ? void 0 : _a.length) {
                    const contours = (0, contourFinder_1.findContoursFromReducedSet)(reducedSet.lines);
                    sliceContours.push({
                        contours,
                        polyData: reducedSet,
                        FrameNumber: sliceIndex + 1,
                        sliceIndex,
                        FrameOfReferenceUID,
                    });
                }
            }
            catch (e) {
                console.warn(sliceIndex);
                console.warn(e);
            }
        }
        const metadata = {
            FrameOfReferenceUID,
        };
        const ContourSet = {
            label: segment.label,
            color: segment.color,
            metadata,
            sliceContours,
        };
        ContourSets.push(ContourSet);
    }
    return ContourSets;
}
exports.generateContourSetsFromLabelmap = generateContourSetsFromLabelmap;
function isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex) {
    const startIdx = sliceIndex * pixelsPerSlice;
    const endIdx = startIdx + pixelsPerSlice;
    for (let i = startIdx; i < endIdx; i++) {
        if (segData[i] === segIndex) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=generateContourSetsFromLabelmap.js.map