"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const DataArray_1 = __importDefault(require("@kitware/vtk.js/Common/Core/DataArray"));
const ImageData_1 = __importDefault(require("@kitware/vtk.js/Common/DataModel/ImageData"));
const core_1 = require("@cornerstonejs/core");
const ToolGroupManager_1 = require("../../store/ToolGroupManager");
const SegmentationRepresentations_1 = __importDefault(require("../../enums/SegmentationRepresentations"));
const SegmentationState = __importStar(require("../../stateManagement/segmentation/segmentationState"));
const stackVolumeCheck_1 = require("../../tools/segmentation/strategies/utils/stackVolumeCheck");
const triggerSegmentationRender_1 = __importDefault(require("../../utilities/segmentation/triggerSegmentationRender"));
const enable = function (element) {
    const { viewport } = (0, core_1.getEnabledElement)(element);
    if (viewport instanceof core_1.BaseVolumeViewport) {
        return;
    }
    element.addEventListener(core_1.Enums.Events.STACK_NEW_IMAGE, _imageChangeEventListener);
    element.addEventListener(core_1.Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);
};
const disable = function (element) {
    element.removeEventListener(core_1.Enums.Events.STACK_NEW_IMAGE, _imageChangeEventListener);
    element.removeEventListener(core_1.Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);
};
const perToolGroupManualTriggers = new Map();
function _imageChangeEventListener(evt) {
    const eventData = evt.detail;
    const { viewportId, renderingEngineId } = eventData;
    const { viewport } = (0, core_1.getEnabledElementByIds)(viewportId, renderingEngineId);
    const toolGroup = (0, ToolGroupManager_1.getToolGroupForViewport)(viewportId, renderingEngineId);
    if (!toolGroup) {
        return;
    }
    let toolGroupSegmentationRepresentations = SegmentationState.getSegmentationRepresentations(toolGroup.id) || [];
    toolGroupSegmentationRepresentations =
        toolGroupSegmentationRepresentations.filter((representation) => representation.type === SegmentationRepresentations_1.default.Labelmap);
    if (!(toolGroupSegmentationRepresentations === null || toolGroupSegmentationRepresentations === void 0 ? void 0 : toolGroupSegmentationRepresentations.length)) {
        return;
    }
    const segmentationRepresentations = {};
    toolGroupSegmentationRepresentations.forEach((representation) => {
        var _a;
        const segmentation = SegmentationState.getSegmentation(representation.segmentationId);
        if (!segmentation || !((_a = segmentation.representationData) === null || _a === void 0 ? void 0 : _a.LABELMAP)) {
            return;
        }
        const labelmapData = segmentation.representationData.LABELMAP;
        if ((0, stackVolumeCheck_1.isVolumeSegmentation)(labelmapData, viewport)) {
            return;
        }
        const { imageIdReferenceMap } = labelmapData;
        segmentationRepresentations[representation.segmentationRepresentationUID] =
            {
                imageIdReferenceMap,
            };
    });
    const representationList = Object.keys(segmentationRepresentations);
    const currentImageId = viewport.getCurrentImageId();
    const actors = viewport.getActors();
    const segmentationFound = actors.find((actor) => {
        if (!representationList.includes(actor.uid)) {
            return false;
        }
        return true;
    });
    if (!segmentationFound) {
        if (!perToolGroupManualTriggers.has(toolGroup.id)) {
            perToolGroupManualTriggers.set(toolGroup.id, true);
            (0, triggerSegmentationRender_1.default)(toolGroup.id);
        }
        return;
    }
    actors.forEach((actor) => {
        if (!representationList.includes(actor.uid)) {
            return;
        }
        const segmentationActor = actor.actor;
        const { imageIdReferenceMap } = segmentationRepresentations[actor.uid];
        const derivedImageId = imageIdReferenceMap.get(currentImageId);
        const segmentationImageData = segmentationActor.getMapper().getInputData();
        if (!derivedImageId) {
            if (segmentationImageData.setDerivedImage) {
                segmentationImageData.setDerivedImage(null);
                return;
            }
            const scalarArray = DataArray_1.default.newInstance({
                name: 'Pixels',
                numberOfComponents: 1,
                values: new Uint8Array(segmentationImageData.getNumberOfPoints()),
            });
            const imageData = ImageData_1.default.newInstance();
            imageData.getPointData().setScalars(scalarArray);
            segmentationActor.getMapper().setInputData(imageData);
            return;
        }
        const derivedImage = core_1.cache.getImage(derivedImageId);
        const { dimensions, spacing, direction } = viewport.getImageDataMetadata(derivedImage);
        const currentImage = core_1.cache.getImage(currentImageId) ||
            {
                imageId: currentImageId,
            };
        const { origin: currentOrigin } = viewport.getImageDataMetadata(currentImage);
        const originToUse = currentOrigin;
        segmentationImageData.setOrigin(originToUse);
        segmentationImageData.modified();
        if (segmentationImageData.getDimensions()[0] !== dimensions[0] ||
            segmentationImageData.getDimensions()[1] !== dimensions[1]) {
            viewport.removeActors([actor.uid]);
            viewport.addImages([
                {
                    imageId: derivedImageId,
                    actorUID: actor.uid,
                    callback: ({ imageActor }) => {
                        const scalarArray = DataArray_1.default.newInstance({
                            name: 'Pixels',
                            numberOfComponents: 1,
                            values: [...derivedImage.getPixelData()],
                        });
                        const imageData = ImageData_1.default.newInstance();
                        imageData.setDimensions(dimensions[0], dimensions[1], 1);
                        imageData.setSpacing(spacing);
                        imageData.setDirection(direction);
                        imageData.setOrigin(originToUse);
                        imageData.getPointData().setScalars(scalarArray);
                        imageActor.getMapper().setInputData(imageData);
                    },
                },
            ]);
            (0, triggerSegmentationRender_1.default)(toolGroup.id);
            return;
        }
        if (segmentationImageData.setDerivedImage) {
            segmentationImageData.setDerivedImage(derivedImage);
        }
        else {
            core_1.utilities.updateVTKImageDataWithCornerstoneImage(segmentationImageData, derivedImage);
        }
        viewport.render();
        if (evt.type === core_1.Enums.Events.IMAGE_RENDERED) {
            viewport.element.removeEventListener(core_1.Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);
        }
    });
}
exports.default = {
    enable,
    disable,
};
//# sourceMappingURL=imageChangeEventListener.js.map