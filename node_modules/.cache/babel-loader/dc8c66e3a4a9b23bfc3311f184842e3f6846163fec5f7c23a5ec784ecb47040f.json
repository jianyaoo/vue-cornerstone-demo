{"ast":null,"code":"import { mat3, mat4, vec3 } from 'gl-matrix';\nimport { n as newInstance$1, e as setGet, o as obj, c as macro } from '../../macros2.js';\nimport vtkHelper from './Helper.js';\nimport vtkMapper from '../Core/Mapper.js';\nimport { l as normalize, u as uninitializeBounds } from '../../Common/Core/Math/index.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkProp from '../Core/Prop.js';\nimport vtkProperty from '../Core/Property.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { v as vtkPolyDataVS } from './glsl/vtkPolyDataVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport vtkReplacementShaderMapper from './ReplacementShaderMapper.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nimport { PassTypes } from './HardwareSelector/Constants.js';\nimport vtkDataSet from '../../Common/DataModel/DataSet.js';\nconst {\n  FieldAssociations\n} = vtkDataSet;\n\n/* eslint-disable no-lonely-if */\n\nconst {\n  primTypes\n} = vtkHelper;\nconst {\n  Representation,\n  Shading\n} = vtkProperty;\nconst {\n  ScalarMode\n} = vtkMapper;\nconst {\n  Filter,\n  Wrap\n} = vtkOpenGLTexture;\nconst {\n  vtkErrorMacro\n} = macro;\nconst StartEvent = {\n  type: 'StartEvent'\n};\nconst EndEvent = {\n  type: 'EndEvent'\n};\nconst {\n  CoordinateSystem\n} = vtkProp;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLPolyDataMapper methods\n// ----------------------------------------------------------------------------\n\nfunction getPickState(renderer) {\n  const selector = renderer.getSelector();\n  if (selector) {\n    return selector.getCurrentPass();\n  }\n  return PassTypes.MIN_KNOWN_PASS - 1;\n}\nfunction vtkOpenGLPolyDataMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLPolyDataMapper');\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model.openGLActor = publicAPI.getFirstAncestorOfType('vtkOpenGLActor');\n      model._openGLRenderer = model.openGLActor.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());\n    }\n  };\n\n  // Renders myself\n  publicAPI.translucentPass = (prepass, renderPass) => {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n  publicAPI.zBufferPass = prepass => {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n  publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);\n  publicAPI.opaquePass = prepass => {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n  publicAPI.render = () => {\n    const ctx = model._openGLRenderWindow.getContext();\n    if (model.context !== ctx) {\n      model.context = ctx;\n      for (let i = primTypes.Start; i < primTypes.End; i++) {\n        model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n    }\n    const actor = model.openGLActor.getRenderable();\n    const ren = model._openGLRenderer.getRenderable();\n    publicAPI.renderPiece(ren, actor);\n  };\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkPolyDataVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderColor = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let GSSource = shaders.Geometry;\n    let FSSource = shaders.Fragment;\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n\n    // create the material/color property declarations, and VS implementation\n    // these are always defined\n    let colorDec = ['uniform float ambient;', 'uniform float diffuse;', 'uniform float specular;', 'uniform float opacityUniform; // the fragment opacity', 'uniform vec3 ambientColorUniform;', 'uniform vec3 diffuseColorUniform;'];\n    // add more for specular\n    if (lastLightComplexity) {\n      colorDec = colorDec.concat(['uniform vec3 specularColorUniform;', 'uniform float specularPowerUniform;']);\n    }\n\n    // now handle the more complex fragment shader implementation\n    // the following are always defined variables.  We start\n    // by assigning a default value from the uniform\n    let colorImpl = ['vec3 ambientColor;', '  vec3 diffuseColor;', '  float opacity;'];\n    if (lastLightComplexity) {\n      colorImpl = colorImpl.concat(['  vec3 specularColor;', '  float specularPower;']);\n    }\n    colorImpl = colorImpl.concat(['  ambientColor = ambientColorUniform;', '  diffuseColor = diffuseColorUniform;', '  opacity = opacityUniform;']);\n    if (lastLightComplexity) {\n      colorImpl = colorImpl.concat(['  specularColor = specularColorUniform;', '  specularPower = specularPowerUniform;']);\n    }\n\n    // add scalar vertex coloring\n    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {\n      colorDec = colorDec.concat(['varying vec4 vertexColorVSOutput;']);\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Dec', ['attribute vec4 scalarColor;', 'varying vec4 vertexColorVSOutput;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Impl', ['vertexColorVSOutput =  scalarColor;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Dec', ['in vec4 vertexColorVSOutput[];', 'out vec4 vertexColorGSOutput;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Impl', ['vertexColorGSOutput = vertexColorVSOutput[i];']).result;\n    }\n    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  diffuseColor = vertexColorVSOutput.rgb;', '  ambientColor = vertexColorVSOutput.rgb;', '  opacity = opacity*vertexColorVSOutput.a;'])).result;\n    } else {\n      if (model.renderable.getInterpolateScalarsBeforeMapping() && model.renderable.getColorCoordinates() && !model.drawingEdges) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);', '  diffuseColor = texColor.rgb;', '  ambientColor = texColor.rgb;', '  opacity = opacity*texColor.a;'])).result;\n      } else {\n        if (actor.getBackfaceProperty() && !model.drawingEdges) {\n          colorDec = colorDec.concat(['uniform float opacityUniformBF; // the fragment opacity', 'uniform float ambientIntensityBF; // the material ambient', 'uniform float diffuseIntensityBF; // the material diffuse', 'uniform vec3 ambientColorUniformBF; // ambient material color', 'uniform vec3 diffuseColorUniformBF; // diffuse material color']);\n          if (lastLightComplexity) {\n            colorDec = colorDec.concat(['uniform float specularIntensityBF; // the material specular intensity', 'uniform vec3 specularColorUniformBF; // intensity weighted color', 'uniform float specularPowerUniformBF;']);\n            colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  specularColor = specularIntensityBF * specularColorUniformBF;', '  specularPower = specularPowerUniformBF;', '  opacity = opacityUniformBF; }']);\n          } else {\n            colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  opacity = opacityUniformBF; }']);\n          }\n        }\n        if (model.haveCellScalars && !model.drawingEdges) {\n          colorDec = colorDec.concat(['uniform samplerBuffer texture1;']);\n        }\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl).result;\n      }\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Dec', colorDec).result;\n    shaders.Vertex = VSSource;\n    shaders.Geometry = GSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderLight = (shaders, ren, actor) => {\n    let FSSource = shaders.Fragment;\n\n    // check for shadow maps\n    const shadowFactor = '';\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    const lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');\n    let sstring = [];\n    switch (lastLightComplexity) {\n      case 0:\n        // no lighting or RENDER_VALUES\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', ['  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);', '  //VTK::Light::Impl'], false).result;\n        break;\n      case 1:\n        // headlight\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', ['  float df = max(0.0, normalVCVSOutput.z);', '  float sf = pow(df, specularPower);', '  vec3 diffuseL = df * diffuseColor;', '  vec3 specularL = sf * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl'], false).result;\n        break;\n      case 2:\n        // light kit\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`]);\n        }\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', sstring).result;\n        sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  float df;'];\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${lc}));`, `  diffuseL += ((df${shadowFactor}) * lightColor${lc});`, `  if (dot(normalVCVSOutput, lightDirectionVC${lc}) < 0.0)`, '    {', `    float sf = sign(df)*pow(max(1e-5,\n                                              dot(reflect(lightDirectionVC${lc},normalVCVSOutput),\n                                                  normalize(-vertexVC.xyz))),\n                                         specularPower);`, `    specularL += (sf${shadowFactor} * lightColor${lc});`, '    }']);\n        }\n        sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;\n        break;\n      case 3:\n        // positional\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`, `uniform vec3 lightPositionVC${lc};`, `uniform vec3 lightAttenuation${lc};`, `uniform float lightConeAngle${lc};`, `uniform float lightExponent${lc};`, `uniform int lightPositional${lc};`]);\n        }\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', sstring).result;\n        sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  vec3 vertLightDirectionVC;', '  float attenuation;', '  float df;'];\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat(['  attenuation = 1.0;', `  if (lightPositional${lc} == 0)`, '    {', `      vertLightDirectionVC = lightDirectionVC${lc};`, '    }', '  else', '    {', `    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${lc};`, '    float distanceVC = length(vertLightDirectionVC);', '    vertLightDirectionVC = normalize(vertLightDirectionVC);', '    attenuation = 1.0 /', `      (lightAttenuation${lc}.x`, `       + lightAttenuation${lc}.y * distanceVC`, `       + lightAttenuation${lc}.z * distanceVC * distanceVC);`, '    // per OpenGL standard cone angle is 90 or less for a spot light', `    if (lightConeAngle${lc} <= 90.0)`, '      {', `      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${lc});`, '      // if inside the cone', `      if (coneDot >= cos(radians(lightConeAngle${lc})))`, '        {', `        attenuation = attenuation * pow(coneDot, lightExponent${lc});`, '        }', '      else', '        {', '        attenuation = 0.0;', '        }', '      }', '    }', '    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));', `    diffuseL += ((df${shadowFactor}) * lightColor${lc});`, '    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)', '      {', `      float sf = sign(df)*attenuation*pow(max(1e-5,\n                                                           dot(reflect(lightDirectionVC${lc},\n                                                                       normalVCVSOutput),\n                                                               normalize(-vertexVC.xyz))),\n                                                       specularPower);`, `    specularL += ((sf${shadowFactor}) * lightColor${lc});`, '    }']);\n        }\n        sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;\n        break;\n      default:\n        vtkErrorMacro('bad light complexity');\n    }\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderNormal = (shaders, ren, actor) => {\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity > 0) {\n      let VSSource = shaders.Vertex;\n      let GSSource = shaders.Geometry;\n      let FSSource = shaders.Fragment;\n      if (model.lastBoundBO.getCABO().getNormalOffset()) {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Normal::Dec', ['attribute vec3 normalMC;', 'uniform mat3 normalMatrix;', 'varying vec3 normalVCVSOutput;']).result;\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Normal::Impl', ['normalVCVSOutput = normalMatrix * normalMC;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Normal::Dec', ['in vec3 normalVCVSOutput[];', 'out vec3 normalVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Normal::Impl', ['normalVCGSOutput = normalVCVSOutput[i];']).result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['varying vec3 normalVCVSOutput;']).result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalVCVSOutput);',\n        //  if (!gl_FrontFacing) does not work in intel hd4000 mac\n        //  if (int(gl_FrontFacing) == 0) does not work on mesa\n        '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;\n      } else {\n        if (model.haveCellNormals) {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['uniform mat3 normalMatrix;', 'uniform samplerBuffer textureN;']).result;\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalMatrix *', '    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);', '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;\n        } else {\n          if (model.lastBoundBO.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES) {\n            // generate a normal for lines, it will be perpendicular to the line\n            // and maximally aligned with the camera view direction\n            // no clue if this is the best way to do this.\n            // the code below has been optimized a bit so what follows is\n            // an explanation of the basic approach. Compute the gradient of the line\n            // with respect to x and y, the the larger of the two\n            // cross that with the camera view direction. That gives a vector\n            // orthogonal to the camera view and the line. Note that the line and the camera\n            // view are probably not orthogonal. Which is why when we cross result that with\n            // the line gradient again we get a reasonable normal. It will be othogonal to\n            // the line (which is a plane but maximally aligned with the camera view.\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', ['  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements\n            ).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput;', '  if (abs(fdx.x) > 0.0)', '    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }', '  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}']).result;\n          } else {\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['uniform int cameraParallel;']).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', [\n            // '  vec3 fdx = vec3(dFdx(vertexVC.x),dFdx(vertexVC.y),dFdx(vertexVC.z));',\n            // '  vec3 fdy = vec3(dFdy(vertexVC.x),dFdy(vertexVC.y),dFdy(vertexVC.z));',\n            '  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements\n            ).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['  fdx = normalize(fdx);', '  fdy = normalize(fdy);', '  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));',\n            // the code below is faster, but does not work on some devices\n            // 'vec3 normalVC = normalize(cross(dFdx(vertexVC.xyz), dFdy(vertexVC.xyz)));',\n            '  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }', '  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }']).result;\n          }\n        }\n      }\n      shaders.Vertex = VSSource;\n      shaders.Geometry = GSSource;\n      shaders.Fragment = FSSource;\n    }\n  };\n  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {\n    // replace common shader code\n    model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);\n    let VSSource = shaders.Vertex;\n    let GSSource = shaders.Geometry;\n    let FSSource = shaders.Fragment;\n\n    // do we need the vertex in the shader in View Coordinates\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity > 0) {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['vertexVCVSOutput = MCVCMatrix * vertexMC;', '  gl_Position = MCPCMatrix * vertexMC;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::PositionVC::Dec', ['in vec4 vertexVCVSOutput[];', 'out vec4 vertexVCGSOutput;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::PositionVC::Impl', ['vertexVCGSOutput = vertexVCVSOutput[i];']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Impl', ['vec4 vertexVC = vertexVCVSOutput;']).result;\n    } else {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Geometry = GSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {\n    if (model.lastBoundBO.getCABO().getTCoordOffset()) {\n      let VSSource = shaders.Vertex;\n      let GSSource = shaders.Geometry;\n      let FSSource = shaders.Fragment;\n      if (model.drawingEdges) {\n        return;\n      }\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', 'tcoordVCVSOutput = tcoordMC;').result;\n\n      // we only handle the first texture by default\n      // additional textures are activated and we set the uniform\n      // for the texture unit they are assigned to, but you have to\n      // add in the shader code to do something with them\n      const tus = model.openGLActor.getActiveTextures();\n      let tNumComp = 2;\n      let tcdim = 2;\n      if (tus && tus.length > 0) {\n        tNumComp = tus[0].getComponents();\n        if (tus[0].getTarget() === model.context.TEXTURE_CUBE_MAP) {\n          tcdim = 3;\n        }\n      }\n      if (model.renderable.getColorTextureMap()) {\n        tNumComp = model.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents();\n        tcdim = 2;\n      }\n      if (tcdim === 2) {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;').result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordVCVSOutput[];', 'out vec2 tcoordVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec2 tcoordVCVSOutput;', 'uniform sampler2D texture1;']).result;\n        if (tus && tus.length >= 1) {\n          switch (tNumComp) {\n            case 1:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;\n              break;\n            case 2:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;\n              break;\n            default:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;\n          }\n        }\n      } else {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;').result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec3 tcoordVCVSOutput[];', 'out vec3 tcoordVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec3 tcoordVCVSOutput;', 'uniform samplerCube texture1;']).result;\n        switch (tNumComp) {\n          case 1:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;\n            break;\n          case 2:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;\n            break;\n          default:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;\n        }\n      }\n      shaders.Vertex = VSSource;\n      shaders.Geometry = GSSource;\n      shaders.Fragment = FSSource;\n    }\n  };\n  publicAPI.replaceShaderClip = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', `uniform vec4 clipPlanes[${numClipPlanes}];`, `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Impl', [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Impl', [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.getCoincidentParameters = (ren, actor) => {\n    // 1. ResolveCoincidentTopology is On and non zero for this primitive\n    // type\n    let cp = {\n      factor: 0.0,\n      offset: 0.0\n    };\n    const prop = actor.getProperty();\n    if (model.renderable.getResolveCoincidentTopology() || prop.getEdgeVisibility() && prop.getRepresentation() === Representation.SURFACE) {\n      const primType = model.lastBoundBO.getPrimitiveType();\n      if (primType === primTypes.Points || prop.getRepresentation() === Representation.POINTS) {\n        cp = model.renderable.getCoincidentTopologyPointOffsetParameter();\n      } else if (primType === primTypes.Lines || prop.getRepresentation() === Representation.WIREFRAME) {\n        cp = model.renderable.getCoincidentTopologyLineOffsetParameters();\n      } else if (primType === primTypes.Tris || primType === primTypes.TriStrips) {\n        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n      }\n      if (primType === primTypes.TrisEdges || primType === primTypes.TriStripsEdges) {\n        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n        cp.factor /= 2.0;\n        cp.offset /= 2.0;\n      }\n    }\n\n    // hardware picking always offset due to saved zbuffer\n    // This gets you above the saved surface depth buffer.\n    const selector = model._openGLRenderer.getSelector();\n    if (selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      cp.offset -= 2.0;\n    }\n    return cp;\n  };\n  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {\n    let FSSource = shaders.Fragment;\n    let VSSource = shaders.Vertex;\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', ['uniform int picking;', '//VTK::Picking::Dec']).result;\n    if (!model._openGLRenderer.getSelector()) {\n      return;\n    }\n    if (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24) {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Picking::Dec', ['flat out int vertexIDVSOutput;\\n', 'uniform int VertexIDOffset;\\n']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Picking::Impl', '  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\\n').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', 'flat in int vertexIDVSOutput;\\n').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', ['  int idx = vertexIDVSOutput;', '//VTK::Picking::Impl']).result;\n    }\n    switch (model.lastSelectionState) {\n      case PassTypes.ID_LOW24:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);').result;\n        break;\n      case PassTypes.ID_HIGH24:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float(idx)/255.0, 0.0, 0.0, 1.0);').result;\n        break;\n      default:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', 'uniform vec3 mapperIndex;').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];').result;\n    }\n    shaders.Fragment = FSSource;\n    shaders.Vertex = VSSource;\n  };\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    publicAPI.replaceShaderColor(shaders, ren, actor);\n    publicAPI.replaceShaderNormal(shaders, ren, actor);\n    publicAPI.replaceShaderLight(shaders, ren, actor);\n    publicAPI.replaceShaderTCoord(shaders, ren, actor);\n    publicAPI.replaceShaderPicking(shaders, ren, actor);\n    publicAPI.replaceShaderClip(shaders, ren, actor);\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n    publicAPI.replaceShaderPositionVC(shaders, ren, actor);\n    if (model.haveSeenDepthRequest) {\n      let FSSource = shaders.Fragment;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n      shaders.Fragment = FSSource;\n    }\n  };\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    let lightComplexity = 0;\n    let numberOfLights = 0;\n    const primType = cellBO.getPrimitiveType();\n    const poly = model.currentInput;\n\n    // different algo from C++ as of 5/2019\n    let needLighting = false;\n    const pointNormals = poly.getPointData().getNormals();\n    const cellNormals = poly.getCellData().getNormals();\n    const flat = actor.getProperty().getInterpolation() === Shading.FLAT;\n    const representation = actor.getProperty().getRepresentation();\n    const mode = cellBO.getOpenGLMode(representation, primType);\n    // 1) all surfaces need lighting\n    if (mode === model.context.TRIANGLES) {\n      needLighting = true;\n      // 2) all cell normals without point normals need lighting\n    } else if (cellNormals && !pointNormals) {\n      needLighting = true;\n      // 3) Phong + pointNormals need lighting\n    } else if (!flat && pointNormals) {\n      needLighting = true;\n      // 4) Phong Lines need lighting\n    } else if (!flat && mode === model.context.LINES) {\n      needLighting = true;\n    }\n    // 5) everything else is unlit\n\n    // do we need lighting?\n    if (actor.getProperty().getLighting() && needLighting) {\n      // consider the lighting complexity to determine which case applies\n      // simple headlight, Light Kit, the whole feature set of VTK\n      lightComplexity = 0;\n      const lights = ren.getLightsByReference();\n      for (let index = 0; index < lights.length; ++index) {\n        const light = lights[index];\n        const status = light.getSwitch();\n        if (status > 0) {\n          numberOfLights++;\n          if (lightComplexity === 0) {\n            lightComplexity = 1;\n          }\n        }\n        if (lightComplexity === 1 && (numberOfLights > 1 || light.getIntensity() !== 1.0 || !light.lightTypeIsHeadLight())) {\n          lightComplexity = 2;\n        }\n        if (lightComplexity < 3 && light.getPositional()) {\n          lightComplexity = 3;\n        }\n      }\n    }\n    let needRebuild = false;\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    const lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');\n    if (lastLightComplexity !== lightComplexity || lastLightCount !== numberOfLights) {\n      model.lastBoundBO.set({\n        lastLightComplexity: lightComplexity\n      }, true);\n      model.lastBoundBO.set({\n        lastLightCount: numberOfLights\n      }, true);\n      needRebuild = true;\n    }\n\n    // has the render pass shader replacement changed? Two options\n    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {\n      needRebuild = true;\n    }\n\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    // render pass shader replacement changed\n    if (model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.selectionStateChanged.getMTime() || needRebuild) {\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      return true;\n    }\n    return false;\n  };\n  publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {\n    const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;\n    if (listCallbacks) {\n      listCallbacks.forEach(object => {\n        object.callback(object.userData, cellBO, ren, actor);\n      });\n    }\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    // Now to update the VAO too, if necessary.\n    if (cellBO.getProgram().isUniformUsed('PrimitiveIDOffset')) {\n      cellBO.getProgram().setUniformi('PrimitiveIDOffset', model.primitiveIDOffset);\n    }\n    if (cellBO.getProgram().isUniformUsed('VertexIDOffset')) {\n      cellBO.getProgram().setUniformi('VertexIDOffset', model.vertexIDOffset);\n    }\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {\n          vtkErrorMacro('Error setting vertexMC in shader VAO.');\n        }\n      }\n      if (cellBO.getProgram().isAttributeUsed('normalMC') && cellBO.getCABO().getNormalOffset() && lastLightComplexity > 0) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'normalMC', cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {\n          vtkErrorMacro('Error setting normalMC in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('normalMC');\n      }\n      model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {\n        if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {\n          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {\n            vtkErrorMacro(`Error setting ${attrName}MC in shader VAO.`);\n          }\n        }\n      });\n      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {\n          vtkErrorMacro('Error setting tcoordMC in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('tcoordMC');\n      }\n      if (cellBO.getProgram().isAttributeUsed('scalarColor') && cellBO.getCABO().getColorComponents()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), 'scalarColor', cellBO.getCABO().getColorOffset(), cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 4, true)) {\n          vtkErrorMacro('Error setting scalarColor in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('scalarColor');\n      }\n      cellBO.getAttributeUpdateTime().modified();\n    }\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      // add all the clipping planes\n      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      const planeEquations = [];\n      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n      const mat = inverseShiftScaleMatrix ? mat4.copy(model.tmpMat4, actor.getMatrix()) : actor.getMatrix();\n      if (inverseShiftScaleMatrix) {\n        mat4.transpose(mat, mat);\n        mat4.multiply(mat, mat, inverseShiftScaleMatrix);\n        mat4.transpose(mat, mat);\n      }\n      for (let i = 0; i < numClipPlanes; i++) {\n        const planeEquation = [];\n        model.renderable.getClippingPlaneInDataCoords(mat, i, planeEquation);\n        for (let j = 0; j < 4; j++) {\n          planeEquations.push(planeEquation[j]);\n        }\n      }\n      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);\n      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);\n    }\n    if (model.internalColorTexture && cellBO.getProgram().isUniformUsed('texture1')) {\n      cellBO.getProgram().setUniformi('texture1', model.internalColorTexture.getTextureUnit());\n    }\n    const tus = model.openGLActor.getActiveTextures();\n    if (tus) {\n      for (let index = 0; index < tus.length; ++index) {\n        const tex = tus[index];\n        const texUnit = tex.getTextureUnit();\n        const tname = `texture${texUnit + 1}`;\n        if (cellBO.getProgram().isUniformUsed(tname)) {\n          cellBO.getProgram().setUniformi(tname, texUnit);\n        }\n      }\n    }\n\n    // handle depth requests\n    if (model.haveSeenDepthRequest) {\n      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    }\n\n    // handle coincident\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      const cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset);\n      // cfactor isn't always used when coffset is.\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    }\n\n    // handle wide lines\n    cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());\n    const selector = model._openGLRenderer.getSelector();\n    cellBO.getProgram().setUniform3fArray('mapperIndex', selector ? selector.getPropColorValue() : [0.0, 0.0, 0.0]);\n    cellBO.getProgram().setUniformi('picking', selector ? selector.getCurrentPass() + 1 : 0);\n  };\n  publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {\n    // for unlit and headlight there are no lighting parameters\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity < 2) {\n      return;\n    }\n    const program = cellBO.getProgram();\n\n    // bind some light settings\n    let numberOfLights = 0;\n    const lights = ren.getLightsByReference();\n    for (let index = 0; index < lights.length; ++index) {\n      const light = lights[index];\n      const status = light.getSwitch();\n      if (status > 0.0) {\n        const dColor = light.getColorByReference();\n        const intensity = light.getIntensity();\n        model.lightColor[0] = dColor[0] * intensity;\n        model.lightColor[1] = dColor[1] * intensity;\n        model.lightColor[2] = dColor[2] * intensity;\n        // get required info from light\n        const ld = light.getDirection();\n        const transform = ren.getActiveCamera().getViewMatrix();\n        const newLightDirection = [...ld];\n        if (light.lightTypeIsSceneLight()) {\n          newLightDirection[0] = transform[0] * ld[0] + transform[1] * ld[1] + transform[2] * ld[2];\n          newLightDirection[1] = transform[4] * ld[0] + transform[5] * ld[1] + transform[6] * ld[2];\n          newLightDirection[2] = transform[8] * ld[0] + transform[9] * ld[1] + transform[10] * ld[2];\n          normalize(newLightDirection);\n        }\n        model.lightDirection[0] = newLightDirection[0];\n        model.lightDirection[1] = newLightDirection[1];\n        model.lightDirection[2] = newLightDirection[2];\n        normalize(model.lightDirection);\n        program.setUniform3fArray(`lightColor${numberOfLights}`, model.lightColor);\n        program.setUniform3fArray(`lightDirectionVC${numberOfLights}`, model.lightDirection);\n        numberOfLights++;\n      }\n    }\n\n    // we are done unless we have positional lights\n    if (lastLightComplexity < 3) {\n      return;\n    }\n\n    // for lightkit case there are some parameters to set\n    const cam = ren.getActiveCamera();\n    const viewTF = cam.getViewMatrix();\n    mat4.transpose(viewTF, viewTF);\n    numberOfLights = 0;\n    for (let index = 0; index < lights.length; ++index) {\n      const light = lights[index];\n      const status = light.getSwitch();\n      if (status > 0.0) {\n        const lp = light.getTransformedPosition();\n        const np = new Float64Array(3);\n        vec3.transformMat4(np, lp, viewTF);\n        program.setUniform3fArray(`lightAttenuation${numberOfLights}`, light.getAttenuationValuesByReference());\n        program.setUniformi(`lightPositional${numberOfLights}`, light.getPositional());\n        program.setUniformf(`lightExponent${numberOfLights}`, light.getExponent());\n        program.setUniformf(`lightConeAngle${numberOfLights}`, light.getConeAngle());\n        program.setUniform3fArray(`lightPositionVC${numberOfLights}`, [np[0], np[1], np[2]]);\n        numberOfLights++;\n      }\n    }\n  };\n  function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {\n    matrixType.identity(tmpMat);\n    return matrixArray.reduce((res, matrix, index) => {\n      if (index === 0) {\n        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);\n      }\n      return matrix ? matrixType.multiply(res, res, matrix) : res;\n    }, tmpMat);\n  }\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n\n    // [WMVP]C == {world, model, view, projection} coordinates\n    // E.g., WCPC == world to projection coordinate transformation\n    const keyMats = model.openGLCamera.getKeyMatrices(ren);\n    const cam = ren.getActiveCamera();\n    const camm = model.openGLCamera.getKeyMatrixTime().getMTime();\n    const progm = program.getLastCameraMTime();\n    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n    const actorIsIdentity = actor.getIsIdentity();\n    const actMats = actorIsIdentity ? {\n      mcwc: null,\n      normalMatrix: null\n    } : model.openGLActor.getKeyMatrices();\n    if (actor.getCoordinateSystem() === CoordinateSystem.DISPLAY) {\n      const size = model._openGLRenderer.getTiledSizeAndOrigin();\n      mat4.identity(model.tmpMat4);\n      model.tmpMat4[0] = 2.0 / size.usize;\n      model.tmpMat4[12] = -1.0;\n      model.tmpMat4[5] = 2.0 / size.vsize;\n      model.tmpMat4[13] = -1.0;\n      mat4.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);\n      program.setUniformMatrix('MCPCMatrix', model.tmpMat4);\n    } else {\n      program.setUniformMatrix('MCPCMatrix', safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n    if (program.isUniformUsed('MCVCMatrix')) {\n      program.setUniformMatrix('MCVCMatrix', safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n    if (program.isUniformUsed('normalMatrix')) {\n      program.setUniformMatrix3x3('normalMatrix', safeMatrixMultiply([keyMats.normalMatrix, actMats.normalMatrix], mat3, model.tmpMat3));\n    }\n    if (progm !== camm) {\n      if (program.isUniformUsed('cameraParallel')) {\n        program.setUniformi('cameraParallel', cam.getParallelProjection());\n      }\n      program.setLastCameraMTime(camm);\n    }\n    if (!actorIsIdentity) {\n      // reset the cam mtime as actor modified the shader values\n      program.setLastCameraMTime(0);\n    }\n  };\n  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    let ppty = actor.getProperty();\n    let opacity = ppty.getOpacity();\n    let aColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getAmbientColorByReference();\n    let dColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getDiffuseColorByReference();\n    let aIntensity = model.drawingEdges ? 1.0 : ppty.getAmbient();\n    let dIntensity = model.drawingEdges ? 0.0 : ppty.getDiffuse();\n    let sIntensity = model.drawingEdges ? 0.0 : ppty.getSpecular();\n    const specularPower = ppty.getSpecularPower();\n    program.setUniformf('opacityUniform', opacity);\n    program.setUniform3fArray('ambientColorUniform', aColor);\n    program.setUniform3fArray('diffuseColorUniform', dColor);\n    program.setUniformf('ambient', aIntensity);\n    program.setUniformf('diffuse', dIntensity);\n\n    // we are done unless we have lighting\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity < 1) {\n      return;\n    }\n    let sColor = ppty.getSpecularColorByReference();\n    program.setUniform3fArray('specularColorUniform', sColor);\n    program.setUniformf('specularPowerUniform', specularPower);\n    program.setUniformf('specular', sIntensity);\n\n    // now set the backface properties if we have them\n    if (program.isUniformUsed('ambientIntensityBF')) {\n      ppty = actor.getBackfaceProperty();\n      opacity = ppty.getOpacity();\n      aColor = ppty.getAmbientColor();\n      aIntensity = ppty.getAmbient();\n      dColor = ppty.getDiffuseColor();\n      dIntensity = ppty.getDiffuse();\n      sColor = ppty.getSpecularColor();\n      sIntensity = ppty.getSpecular();\n      program.setUniformf('ambientIntensityBF', aIntensity);\n      program.setUniformf('diffuseIntensityBF', dIntensity);\n      program.setUniformf('opacityUniformBF', opacity);\n      program.setUniform3fArray('ambientColorUniformBF', aColor);\n      program.setUniform3fArray('diffuseColorUniformBF', dColor);\n\n      // we are done unless we have lighting\n      if (lastLightComplexity < 1) {\n        return;\n      }\n      program.setUniformf('specularIntensityBF', sIntensity);\n      program.setUniform3fArray('specularColorUniformBF', sColor);\n      program.setUniformf('specularPowerUniformBF', specularPower);\n    }\n  };\n  publicAPI.updateMaximumPointCellIds = (ren, actor) => {\n    const selector = model._openGLRenderer.getSelector();\n    if (!selector) {\n      return;\n    }\n    if (model.selectionWebGLIdsToVTKIds?.points?.length) {\n      const length = model.selectionWebGLIdsToVTKIds.points.length;\n      selector.setMaximumPointId(length - 1);\n    }\n    if (model.selectionWebGLIdsToVTKIds?.cells?.length) {\n      const length = model.selectionWebGLIdsToVTKIds.cells.length;\n      selector.setMaximumCellId(length - 1);\n    }\n    const fieldAssociation = selector.getFieldAssociation();\n    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      model.pointPicking = true;\n    }\n  };\n  publicAPI.renderPieceStart = (ren, actor) => {\n    model.primitiveIDOffset = 0;\n    model.vertexIDOffset = 0;\n    const picking = getPickState(model._openGLRenderer);\n    if (model.lastSelectionState !== picking) {\n      model.selectionStateChanged.modified();\n      model.lastSelectionState = picking;\n    }\n    if (model._openGLRenderer.getSelector()) {\n      switch (picking) {\n        default:\n          model._openGLRenderer.getSelector().renderProp(actor);\n      }\n    }\n\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor);\n\n    // If we are coloring by texture, then load the texture map.\n    // Use Map as indicator, because texture hangs around.\n    if (model.renderable.getColorTextureMap()) {\n      model.internalColorTexture.activate();\n    }\n\n    // Bind the OpenGL, this is shared between the different primitive/cell types.\n    model.lastBoundBO = null;\n  };\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const representation = actor.getProperty().getRepresentation();\n    const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;\n    const selector = model._openGLRenderer.getSelector();\n    // If we are picking points, we need to tell it to the helper\n    const pointPicking = selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS && (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24);\n\n    // for every primitive type\n    for (let i = primTypes.Start; i < primTypes.End; i++) {\n      model.primitives[i].setPointPicking(pointPicking);\n      const cabo = model.primitives[i].getCABO();\n      if (cabo.getElementCount()) {\n        // are we drawing edges\n        model.drawingEdges = drawSurfaceWithEdges && (i === primTypes.TrisEdges || i === primTypes.TriStripsEdges);\n        // don't draw edges when rendering depth or rendering for picking\n        if (!model.drawingEdges || !(model.renderDepth || model.lastSelectionState >= 0)) {\n          model.lastBoundBO = model.primitives[i];\n          model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);\n          model.vertexIDOffset += model.primitives[i].getCABO().getElementCount();\n        }\n      }\n    }\n  };\n  publicAPI.renderPieceFinish = (ren, actor) => {\n    if (model.LastBoundBO) {\n      model.LastBoundBO.getVAO().release();\n    }\n    if (model.renderable.getColorTextureMap()) {\n      model.internalColorTexture.deactivate();\n    }\n  };\n  publicAPI.renderPiece = (ren, actor) => {\n    // Make sure that we have been properly initialized.\n    // if (ren.getRenderWindow().checkAbortStatus()) {\n    //   return;\n    // }\n\n    publicAPI.invokeEvent(StartEvent);\n    if (!model.renderable.getStatic()) {\n      model.renderable.update();\n    }\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.invokeEvent(EndEvent);\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n\n    // if there are no points then we are done\n    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {\n      return;\n    }\n\n    // apply faceCulling\n    const gl = model.context;\n    const backfaceCulling = actor.getProperty().getBackfaceCulling();\n    const frontfaceCulling = actor.getProperty().getFrontfaceCulling();\n    if (!backfaceCulling && !frontfaceCulling) {\n      model._openGLRenderWindow.disableCullFace();\n    } else if (frontfaceCulling) {\n      model._openGLRenderWindow.enableCullFace();\n      gl.cullFace(gl.FRONT);\n    } else {\n      model._openGLRenderWindow.enableCullFace();\n      gl.cullFace(gl.BACK);\n    }\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n  publicAPI.computeBounds = (ren, actor) => {\n    if (!publicAPI.getInput()) {\n      uninitializeBounds(model.bounds);\n      return;\n    }\n    model.bounds = publicAPI.getInput().getBounds();\n  };\n  publicAPI.updateBufferObjects = (ren, actor) => {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {\n    // first do a coarse check\n    // Note that the actor's mtime includes it's properties mtime\n    const vmtime = model.VBOBuildTime.getMTime();\n    if (vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const poly = model.currentInput;\n    if (poly === null) {\n      return;\n    }\n    model.renderable.mapScalars(poly, 1.0);\n    const c = model.renderable.getColorMapColors();\n    model.haveCellScalars = false;\n    const scalarMode = model.renderable.getScalarMode();\n    if (model.renderable.getScalarVisibility()) {\n      // We must figure out how the scalars should be mapped to the polydata.\n      if ((scalarMode === ScalarMode.USE_CELL_DATA || scalarMode === ScalarMode.USE_CELL_FIELD_DATA || scalarMode === ScalarMode.USE_FIELD_DATA || !poly.getPointData().getScalars()) && scalarMode !== ScalarMode.USE_POINT_FIELD_DATA && c) {\n        model.haveCellScalars = true;\n      }\n    }\n\n    // Do we have normals?\n    let n = actor.getProperty().getInterpolation() !== Shading.FLAT ? poly.getPointData().getNormals() : null;\n    if (n === null && poly.getCellData().getNormals()) {\n      model.haveCellNormals = true;\n      n = poly.getCellData().getNormals();\n    }\n\n    // rebuild the VBO if the data has changed we create a string for the VBO what\n    // can change the VBO? points normals tcoords colors so what can change those?\n    // the input data is clearly one as it can change all four items tcoords may\n    // haveTextures or not colors may change based on quite a few mapping\n    // parameters in the mapper\n\n    const representation = actor.getProperty().getRepresentation();\n    let tcoords = poly.getPointData().getTCoords();\n    if (!model.openGLActor.getActiveTextures()) {\n      tcoords = null;\n    }\n\n    // handle color mapping via texture\n    if (model.renderable.getColorCoordinates()) {\n      tcoords = model.renderable.getColorCoordinates();\n      if (!model.internalColorTexture) {\n        model.internalColorTexture = vtkOpenGLTexture.newInstance({\n          resizable: true\n        });\n      }\n      const tex = model.internalColorTexture;\n      // the following 4 lines allow for NPOT textures\n      tex.setMinificationFilter(Filter.NEAREST);\n      tex.setMagnificationFilter(Filter.NEAREST);\n      tex.setWrapS(Wrap.CLAMP_TO_EDGE);\n      tex.setWrapT(Wrap.CLAMP_TO_EDGE);\n      tex.setOpenGLRenderWindow(model._openGLRenderWindow);\n      const input = model.renderable.getColorTextureMap();\n      const ext = input.getExtent();\n      const inScalars = input.getPointData().getScalars();\n      tex.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());\n      tex.activate();\n      tex.sendParameters();\n      tex.deactivate();\n    }\n    const toString = `${poly.getMTime()}A${representation}B${poly.getMTime()}` + `C${n ? n.getMTime() : 1}D${c ? c.getMTime() : 1}` + `E${actor.getProperty().getEdgeVisibility()}` + `F${tcoords ? tcoords.getMTime() : 1}`;\n    if (model.VBOBuildString !== toString) {\n      // Build the VBOs\n      const points = poly.getPoints();\n      const options = {\n        points,\n        normals: n,\n        tcoords,\n        colors: c,\n        cellOffset: 0,\n        vertexOffset: 0,\n        // Used to keep track of vertex ids across primitives for selection\n        haveCellScalars: model.haveCellScalars,\n        haveCellNormals: model.haveCellNormals,\n        customAttributes: model.renderable.getCustomShaderAttributes().map(arrayName => poly.getPointData().getArrayByName(arrayName))\n      };\n      if (model.renderable.getPopulateSelectionSettings()) {\n        model.selectionWebGLIdsToVTKIds = {\n          points: null,\n          cells: null\n        };\n      }\n      const primitives = [{\n        inRep: 'verts',\n        cells: poly.getVerts()\n      }, {\n        inRep: 'lines',\n        cells: poly.getLines()\n      }, {\n        inRep: 'polys',\n        cells: poly.getPolys()\n      }, {\n        inRep: 'strips',\n        cells: poly.getStrips()\n      }, {\n        inRep: 'polys',\n        cells: poly.getPolys()\n      }, {\n        inRep: 'strips',\n        cells: poly.getStrips()\n      }];\n      const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;\n      for (let i = primTypes.Start; i < primTypes.End; i++) {\n        if (i !== primTypes.TrisEdges && i !== primTypes.TriStripsEdges) {\n          options.cellOffset += model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, representation, options, model.selectionWebGLIdsToVTKIds);\n          options.vertexOffset += model.primitives[i].getCABO().getElementCount();\n        } else {\n          // if we have edge visibility build the edge VBOs\n          if (drawSurfaceWithEdges) {\n            // VBOs for edges in \"surface with edges\" are the last to be built,\n            // they are not used when picking with a hardware selector so they\n            // don't need selectionWebGLIdsToVTKIds and don't update cellOffset and vertexOffset\n            model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, Representation.WIREFRAME, {\n              ...options,\n              tcoords: null,\n              colors: null,\n              haveCellScalars: false,\n              haveCellNormals: false\n            });\n          } else {\n            // otherwise free them\n            model.primitives[i].releaseGraphicsResources();\n          }\n        }\n      }\n      if (model.renderable.getPopulateSelectionSettings()) {\n        model.renderable.setSelectionWebGLIdsToVTKIds(model.selectionWebGLIdsToVTKIds);\n        publicAPI.updateMaximumPointCellIds();\n      }\n      model.VBOBuildTime.modified();\n      model.VBOBuildString = toString;\n    }\n  };\n  publicAPI.getAllocatedGPUMemoryInBytes = () => {\n    let memUsed = 0;\n    model.primitives.forEach(prim => {\n      memUsed += prim.getAllocatedGPUMemoryInBytes();\n    });\n    // Return in MB\n    return memUsed;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  VBOBuildTime: 0,\n  VBOBuildString: null,\n  primitives: null,\n  primTypes: null,\n  shaderRebuildString: null,\n  tmpMat4: null,\n  ambientColor: [],\n  // used internally\n  diffuseColor: [],\n  // used internally\n  specularColor: [],\n  // used internally\n  lightColor: [],\n  // used internally\n  lightDirection: [],\n  // used internally\n  lastHaveSeenDepthRequest: false,\n  haveSeenDepthRequest: false,\n  lastSelectionState: PassTypes.MIN_KNOWN_PASS - 1,\n  selectionStateChanged: null,\n  selectionWebGLIdsToVTKIds: null,\n  pointPicking: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);\n  model.primitives = [];\n  model.primTypes = primTypes;\n  model.tmpMat3 = mat3.identity(new Float64Array(9));\n  model.tmpMat4 = mat4.identity(new Float64Array(16));\n  for (let i = primTypes.Start; i < primTypes.End; i++) {\n    model.primitives[i] = vtkHelper.newInstance();\n    model.primitives[i].setPrimitiveType(i);\n    model.primitives[i].set({\n      lastLightComplexity: 0,\n      lastLightCount: 0,\n      lastSelectionPass: false\n    }, true);\n  }\n\n  // Build VTK API\n  setGet(publicAPI, model, ['context']);\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime, {\n    mtime: 0\n  });\n  model.selectionStateChanged = {};\n  obj(model.selectionStateChanged, {\n    mtime: 0\n  });\n\n  // Object methods\n  vtkOpenGLPolyDataMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLPolyDataMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkOpenGLPolyDataMapper$1 = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkMapper', newInstance);\nexport { vtkOpenGLPolyDataMapper$1 as default, extend, newInstance };","map":{"version":3,"names":["mat3","mat4","vec3","n","newInstance$1","e","setGet","o","obj","c","macro","vtkHelper","vtkMapper","l","normalize","u","uninitializeBounds","vtkOpenGLTexture","vtkProp","vtkProperty","vtkShaderProgram","vtkViewNode","v","vtkPolyDataVS","vtkPolyDataFS","vtkReplacementShaderMapper","registerOverride","PassTypes","vtkDataSet","FieldAssociations","primTypes","Representation","Shading","ScalarMode","Filter","Wrap","vtkErrorMacro","StartEvent","type","EndEvent","CoordinateSystem","getPickState","renderer","selector","getSelector","getCurrentPass","MIN_KNOWN_PASS","vtkOpenGLPolyDataMapper","publicAPI","model","classHierarchy","push","buildPass","prepass","currentRenderPass","openGLActor","getFirstAncestorOfType","_openGLRenderer","_openGLRenderWindow","getParent","openGLCamera","getViewNodeFor","getRenderable","getActiveCamera","translucentPass","renderPass","render","zBufferPass","haveSeenDepthRequest","renderDepth","opaqueZBufferPass","opaquePass","ctx","getContext","context","i","Start","End","primitives","setOpenGLRenderWindow","actor","ren","renderPiece","getShaderTemplate","shaders","Vertex","Fragment","Geometry","replaceShaderColor","VSSource","GSSource","FSSource","lastLightComplexity","lastBoundBO","getReferenceByName","colorDec","concat","colorImpl","getCABO","getColorComponents","drawingEdges","substitute","result","renderable","getInterpolateScalarsBeforeMapping","getColorCoordinates","getBackfaceProperty","haveCellScalars","replaceShaderLight","shadowFactor","lastLightCount","sstring","lc","replaceShaderNormal","getNormalOffset","haveCellNormals","getOpenGLMode","getProperty","getRepresentation","LINES","replaceShaderPositionVC","replaceShaderTCoord","getTCoordOffset","tus","getActiveTextures","tNumComp","tcdim","length","getComponents","getTarget","TEXTURE_CUBE_MAP","getColorTextureMap","getPointData","getScalars","getNumberOfComponents","replaceShaderClip","getNumberOfClippingPlanes","numClipPlanes","getCoincidentParameters","cp","factor","offset","prop","getResolveCoincidentTopology","getEdgeVisibility","SURFACE","primType","getPrimitiveType","Points","POINTS","getCoincidentTopologyPointOffsetParameter","Lines","WIREFRAME","getCoincidentTopologyLineOffsetParameters","Tris","TriStrips","getCoincidentTopologyPolygonOffsetParameters","TrisEdges","TriStripsEdges","getFieldAssociation","FIELD_ASSOCIATION_POINTS","replaceShaderPicking","lastSelectionState","ID_LOW24","ID_HIGH24","replaceShaderValues","replaceShaderCoincidentOffset","getNeedToRebuildShaders","cellBO","lightComplexity","numberOfLights","poly","currentInput","needLighting","pointNormals","getNormals","cellNormals","getCellData","flat","getInterpolation","FLAT","representation","mode","TRIANGLES","getLighting","lights","getLightsByReference","index","light","status","getSwitch","getIntensity","lightTypeIsHeadLight","getPositional","needRebuild","set","lastRenderPassShaderReplacement","getShaderReplacement","lastHaveSeenDepthRequest","getShaderSourceTime","getMTime","selectionStateChanged","invokeShaderCallbacks","listCallbacks","getViewSpecificProperties","ShadersCallbacks","forEach","object","callback","userData","setMapperShaderParameters","getProgram","isUniformUsed","setUniformi","primitiveIDOffset","vertexIDOffset","getElementCount","VBOBuildTime","getAttributeUpdateTime","isAttributeUsed","getVAO","addAttributeArray","getVertexOffset","getStride","FLOAT","removeAttributeArray","getCustomShaderAttributes","attrName","idx","getCustomData","components","getTCoordComponents","getColorBO","getColorOffset","getColorBOStride","UNSIGNED_BYTE","modified","planeEquations","shiftScaleEnabled","getCoordShiftAndScaleEnabled","inverseShiftScaleMatrix","getInverseShiftAndScaleMatrix","mat","copy","tmpMat4","getMatrix","transpose","multiply","planeEquation","getClippingPlaneInDataCoords","j","setUniform4fv","internalColorTexture","getTextureUnit","tex","texUnit","tname","setUniformf","getTiledSizeAndOrigin","setUniform3fArray","getPropColorValue","setLightingShaderParameters","program","dColor","getColorByReference","intensity","lightColor","ld","getDirection","transform","getViewMatrix","newLightDirection","lightTypeIsSceneLight","lightDirection","cam","viewTF","lp","getTransformedPosition","np","Float64Array","transformMat4","getAttenuationValuesByReference","getExponent","getConeAngle","safeMatrixMultiply","matrixArray","matrixType","tmpMat","identity","reduce","res","matrix","setCameraShaderParameters","keyMats","getKeyMatrices","camm","getKeyMatrixTime","progm","getLastCameraMTime","actorIsIdentity","getIsIdentity","actMats","mcwc","normalMatrix","getCoordinateSystem","DISPLAY","size","usize","vsize","setUniformMatrix","wcpc","wcvc","setUniformMatrix3x3","tmpMat3","getParallelProjection","setLastCameraMTime","setPropertyShaderParameters","ppty","opacity","getOpacity","aColor","getEdgeColorByReference","getAmbientColorByReference","getDiffuseColorByReference","aIntensity","getAmbient","dIntensity","getDiffuse","sIntensity","getSpecular","specularPower","getSpecularPower","sColor","getSpecularColorByReference","getAmbientColor","getDiffuseColor","getSpecularColor","updateMaximumPointCellIds","selectionWebGLIdsToVTKIds","points","setMaximumPointId","cells","setMaximumCellId","fieldAssociation","pointPicking","renderPieceStart","picking","renderProp","updateBufferObjects","activate","renderPieceDraw","drawSurfaceWithEdges","setPointPicking","cabo","drawArrays","renderPieceFinish","LastBoundBO","release","deactivate","invokeEvent","getStatic","update","getInputData","getPoints","getNumberOfValues","gl","backfaceCulling","getBackfaceCulling","frontfaceCulling","getFrontfaceCulling","disableCullFace","enableCullFace","cullFace","FRONT","BACK","computeBounds","getInput","bounds","getBounds","getNeedToRebuildBufferObjects","buildBufferObjects","vmtime","mapScalars","getColorMapColors","scalarMode","getScalarMode","getScalarVisibility","USE_CELL_DATA","USE_CELL_FIELD_DATA","USE_FIELD_DATA","USE_POINT_FIELD_DATA","tcoords","getTCoords","newInstance","resizable","setMinificationFilter","NEAREST","setMagnificationFilter","setWrapS","CLAMP_TO_EDGE","setWrapT","input","ext","getExtent","inScalars","create2DFromRaw","getDataType","getData","sendParameters","toString","VBOBuildString","options","normals","colors","cellOffset","vertexOffset","customAttributes","map","arrayName","getArrayByName","getPopulateSelectionSettings","inRep","getVerts","getLines","getPolys","getStrips","createVBO","releaseGraphicsResources","setSelectionWebGLIdsToVTKIds","getAllocatedGPUMemoryInBytes","memUsed","prim","DEFAULT_VALUES","shaderRebuildString","ambientColor","diffuseColor","specularColor","extend","initialValues","arguments","undefined","Object","assign","implementReplaceShaderCoincidentOffset","implementBuildShadersWithReplacements","setPrimitiveType","lastSelectionPass","mtime","vtkOpenGLPolyDataMapper$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper.js"],"sourcesContent":["import { mat3, mat4, vec3 } from 'gl-matrix';\nimport { n as newInstance$1, e as setGet, o as obj, c as macro } from '../../macros2.js';\nimport vtkHelper from './Helper.js';\nimport vtkMapper from '../Core/Mapper.js';\nimport { l as normalize, u as uninitializeBounds } from '../../Common/Core/Math/index.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkProp from '../Core/Prop.js';\nimport vtkProperty from '../Core/Property.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { v as vtkPolyDataVS } from './glsl/vtkPolyDataVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport vtkReplacementShaderMapper from './ReplacementShaderMapper.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nimport { PassTypes } from './HardwareSelector/Constants.js';\nimport vtkDataSet from '../../Common/DataModel/DataSet.js';\n\nconst {\n  FieldAssociations\n} = vtkDataSet;\n\n/* eslint-disable no-lonely-if */\n\nconst {\n  primTypes\n} = vtkHelper;\nconst {\n  Representation,\n  Shading\n} = vtkProperty;\nconst {\n  ScalarMode\n} = vtkMapper;\nconst {\n  Filter,\n  Wrap\n} = vtkOpenGLTexture;\nconst {\n  vtkErrorMacro\n} = macro;\nconst StartEvent = {\n  type: 'StartEvent'\n};\nconst EndEvent = {\n  type: 'EndEvent'\n};\nconst {\n  CoordinateSystem\n} = vtkProp;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLPolyDataMapper methods\n// ----------------------------------------------------------------------------\n\nfunction getPickState(renderer) {\n  const selector = renderer.getSelector();\n  if (selector) {\n    return selector.getCurrentPass();\n  }\n  return PassTypes.MIN_KNOWN_PASS - 1;\n}\nfunction vtkOpenGLPolyDataMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLPolyDataMapper');\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model.openGLActor = publicAPI.getFirstAncestorOfType('vtkOpenGLActor');\n      model._openGLRenderer = model.openGLActor.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());\n    }\n  };\n\n  // Renders myself\n  publicAPI.translucentPass = (prepass, renderPass) => {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n  publicAPI.zBufferPass = prepass => {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n  publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);\n  publicAPI.opaquePass = prepass => {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n  publicAPI.render = () => {\n    const ctx = model._openGLRenderWindow.getContext();\n    if (model.context !== ctx) {\n      model.context = ctx;\n      for (let i = primTypes.Start; i < primTypes.End; i++) {\n        model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n    }\n    const actor = model.openGLActor.getRenderable();\n    const ren = model._openGLRenderer.getRenderable();\n    publicAPI.renderPiece(ren, actor);\n  };\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkPolyDataVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderColor = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let GSSource = shaders.Geometry;\n    let FSSource = shaders.Fragment;\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n\n    // create the material/color property declarations, and VS implementation\n    // these are always defined\n    let colorDec = ['uniform float ambient;', 'uniform float diffuse;', 'uniform float specular;', 'uniform float opacityUniform; // the fragment opacity', 'uniform vec3 ambientColorUniform;', 'uniform vec3 diffuseColorUniform;'];\n    // add more for specular\n    if (lastLightComplexity) {\n      colorDec = colorDec.concat(['uniform vec3 specularColorUniform;', 'uniform float specularPowerUniform;']);\n    }\n\n    // now handle the more complex fragment shader implementation\n    // the following are always defined variables.  We start\n    // by assigning a default value from the uniform\n    let colorImpl = ['vec3 ambientColor;', '  vec3 diffuseColor;', '  float opacity;'];\n    if (lastLightComplexity) {\n      colorImpl = colorImpl.concat(['  vec3 specularColor;', '  float specularPower;']);\n    }\n    colorImpl = colorImpl.concat(['  ambientColor = ambientColorUniform;', '  diffuseColor = diffuseColorUniform;', '  opacity = opacityUniform;']);\n    if (lastLightComplexity) {\n      colorImpl = colorImpl.concat(['  specularColor = specularColorUniform;', '  specularPower = specularPowerUniform;']);\n    }\n\n    // add scalar vertex coloring\n    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {\n      colorDec = colorDec.concat(['varying vec4 vertexColorVSOutput;']);\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Dec', ['attribute vec4 scalarColor;', 'varying vec4 vertexColorVSOutput;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Impl', ['vertexColorVSOutput =  scalarColor;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Dec', ['in vec4 vertexColorVSOutput[];', 'out vec4 vertexColorGSOutput;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Impl', ['vertexColorGSOutput = vertexColorVSOutput[i];']).result;\n    }\n    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  diffuseColor = vertexColorVSOutput.rgb;', '  ambientColor = vertexColorVSOutput.rgb;', '  opacity = opacity*vertexColorVSOutput.a;'])).result;\n    } else {\n      if (model.renderable.getInterpolateScalarsBeforeMapping() && model.renderable.getColorCoordinates() && !model.drawingEdges) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);', '  diffuseColor = texColor.rgb;', '  ambientColor = texColor.rgb;', '  opacity = opacity*texColor.a;'])).result;\n      } else {\n        if (actor.getBackfaceProperty() && !model.drawingEdges) {\n          colorDec = colorDec.concat(['uniform float opacityUniformBF; // the fragment opacity', 'uniform float ambientIntensityBF; // the material ambient', 'uniform float diffuseIntensityBF; // the material diffuse', 'uniform vec3 ambientColorUniformBF; // ambient material color', 'uniform vec3 diffuseColorUniformBF; // diffuse material color']);\n          if (lastLightComplexity) {\n            colorDec = colorDec.concat(['uniform float specularIntensityBF; // the material specular intensity', 'uniform vec3 specularColorUniformBF; // intensity weighted color', 'uniform float specularPowerUniformBF;']);\n            colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  specularColor = specularIntensityBF * specularColorUniformBF;', '  specularPower = specularPowerUniformBF;', '  opacity = opacityUniformBF; }']);\n          } else {\n            colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  opacity = opacityUniformBF; }']);\n          }\n        }\n        if (model.haveCellScalars && !model.drawingEdges) {\n          colorDec = colorDec.concat(['uniform samplerBuffer texture1;']);\n        }\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl).result;\n      }\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Dec', colorDec).result;\n    shaders.Vertex = VSSource;\n    shaders.Geometry = GSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderLight = (shaders, ren, actor) => {\n    let FSSource = shaders.Fragment;\n\n    // check for shadow maps\n    const shadowFactor = '';\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    const lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');\n    let sstring = [];\n    switch (lastLightComplexity) {\n      case 0:\n        // no lighting or RENDER_VALUES\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', ['  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);', '  //VTK::Light::Impl'], false).result;\n        break;\n      case 1:\n        // headlight\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', ['  float df = max(0.0, normalVCVSOutput.z);', '  float sf = pow(df, specularPower);', '  vec3 diffuseL = df * diffuseColor;', '  vec3 specularL = sf * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl'], false).result;\n        break;\n      case 2:\n        // light kit\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`]);\n        }\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', sstring).result;\n        sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  float df;'];\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${lc}));`, `  diffuseL += ((df${shadowFactor}) * lightColor${lc});`, `  if (dot(normalVCVSOutput, lightDirectionVC${lc}) < 0.0)`, '    {', `    float sf = sign(df)*pow(max(1e-5,\n                                              dot(reflect(lightDirectionVC${lc},normalVCVSOutput),\n                                                  normalize(-vertexVC.xyz))),\n                                         specularPower);`, `    specularL += (sf${shadowFactor} * lightColor${lc});`, '    }']);\n        }\n        sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;\n        break;\n      case 3:\n        // positional\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`, `uniform vec3 lightPositionVC${lc};`, `uniform vec3 lightAttenuation${lc};`, `uniform float lightConeAngle${lc};`, `uniform float lightExponent${lc};`, `uniform int lightPositional${lc};`]);\n        }\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', sstring).result;\n        sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  vec3 vertLightDirectionVC;', '  float attenuation;', '  float df;'];\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat(['  attenuation = 1.0;', `  if (lightPositional${lc} == 0)`, '    {', `      vertLightDirectionVC = lightDirectionVC${lc};`, '    }', '  else', '    {', `    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${lc};`, '    float distanceVC = length(vertLightDirectionVC);', '    vertLightDirectionVC = normalize(vertLightDirectionVC);', '    attenuation = 1.0 /', `      (lightAttenuation${lc}.x`, `       + lightAttenuation${lc}.y * distanceVC`, `       + lightAttenuation${lc}.z * distanceVC * distanceVC);`, '    // per OpenGL standard cone angle is 90 or less for a spot light', `    if (lightConeAngle${lc} <= 90.0)`, '      {', `      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${lc});`, '      // if inside the cone', `      if (coneDot >= cos(radians(lightConeAngle${lc})))`, '        {', `        attenuation = attenuation * pow(coneDot, lightExponent${lc});`, '        }', '      else', '        {', '        attenuation = 0.0;', '        }', '      }', '    }', '    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));', `    diffuseL += ((df${shadowFactor}) * lightColor${lc});`, '    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)', '      {', `      float sf = sign(df)*attenuation*pow(max(1e-5,\n                                                           dot(reflect(lightDirectionVC${lc},\n                                                                       normalVCVSOutput),\n                                                               normalize(-vertexVC.xyz))),\n                                                       specularPower);`, `    specularL += ((sf${shadowFactor}) * lightColor${lc});`, '    }']);\n        }\n        sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;\n        break;\n      default:\n        vtkErrorMacro('bad light complexity');\n    }\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderNormal = (shaders, ren, actor) => {\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity > 0) {\n      let VSSource = shaders.Vertex;\n      let GSSource = shaders.Geometry;\n      let FSSource = shaders.Fragment;\n      if (model.lastBoundBO.getCABO().getNormalOffset()) {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Normal::Dec', ['attribute vec3 normalMC;', 'uniform mat3 normalMatrix;', 'varying vec3 normalVCVSOutput;']).result;\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Normal::Impl', ['normalVCVSOutput = normalMatrix * normalMC;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Normal::Dec', ['in vec3 normalVCVSOutput[];', 'out vec3 normalVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Normal::Impl', ['normalVCGSOutput = normalVCVSOutput[i];']).result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['varying vec3 normalVCVSOutput;']).result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalVCVSOutput);',\n        //  if (!gl_FrontFacing) does not work in intel hd4000 mac\n        //  if (int(gl_FrontFacing) == 0) does not work on mesa\n        '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;\n      } else {\n        if (model.haveCellNormals) {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['uniform mat3 normalMatrix;', 'uniform samplerBuffer textureN;']).result;\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalMatrix *', '    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);', '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;\n        } else {\n          if (model.lastBoundBO.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES) {\n            // generate a normal for lines, it will be perpendicular to the line\n            // and maximally aligned with the camera view direction\n            // no clue if this is the best way to do this.\n            // the code below has been optimized a bit so what follows is\n            // an explanation of the basic approach. Compute the gradient of the line\n            // with respect to x and y, the the larger of the two\n            // cross that with the camera view direction. That gives a vector\n            // orthogonal to the camera view and the line. Note that the line and the camera\n            // view are probably not orthogonal. Which is why when we cross result that with\n            // the line gradient again we get a reasonable normal. It will be othogonal to\n            // the line (which is a plane but maximally aligned with the camera view.\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', ['  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements\n            ).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput;', '  if (abs(fdx.x) > 0.0)', '    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }', '  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}']).result;\n          } else {\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['uniform int cameraParallel;']).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', [\n            // '  vec3 fdx = vec3(dFdx(vertexVC.x),dFdx(vertexVC.y),dFdx(vertexVC.z));',\n            // '  vec3 fdy = vec3(dFdy(vertexVC.x),dFdy(vertexVC.y),dFdy(vertexVC.z));',\n            '  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements\n            ).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['  fdx = normalize(fdx);', '  fdy = normalize(fdy);', '  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));',\n            // the code below is faster, but does not work on some devices\n            // 'vec3 normalVC = normalize(cross(dFdx(vertexVC.xyz), dFdy(vertexVC.xyz)));',\n            '  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }', '  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }']).result;\n          }\n        }\n      }\n      shaders.Vertex = VSSource;\n      shaders.Geometry = GSSource;\n      shaders.Fragment = FSSource;\n    }\n  };\n  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {\n    // replace common shader code\n    model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);\n    let VSSource = shaders.Vertex;\n    let GSSource = shaders.Geometry;\n    let FSSource = shaders.Fragment;\n\n    // do we need the vertex in the shader in View Coordinates\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity > 0) {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['vertexVCVSOutput = MCVCMatrix * vertexMC;', '  gl_Position = MCPCMatrix * vertexMC;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::PositionVC::Dec', ['in vec4 vertexVCVSOutput[];', 'out vec4 vertexVCGSOutput;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::PositionVC::Impl', ['vertexVCGSOutput = vertexVCVSOutput[i];']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Impl', ['vec4 vertexVC = vertexVCVSOutput;']).result;\n    } else {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Geometry = GSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {\n    if (model.lastBoundBO.getCABO().getTCoordOffset()) {\n      let VSSource = shaders.Vertex;\n      let GSSource = shaders.Geometry;\n      let FSSource = shaders.Fragment;\n      if (model.drawingEdges) {\n        return;\n      }\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', 'tcoordVCVSOutput = tcoordMC;').result;\n\n      // we only handle the first texture by default\n      // additional textures are activated and we set the uniform\n      // for the texture unit they are assigned to, but you have to\n      // add in the shader code to do something with them\n      const tus = model.openGLActor.getActiveTextures();\n      let tNumComp = 2;\n      let tcdim = 2;\n      if (tus && tus.length > 0) {\n        tNumComp = tus[0].getComponents();\n        if (tus[0].getTarget() === model.context.TEXTURE_CUBE_MAP) {\n          tcdim = 3;\n        }\n      }\n      if (model.renderable.getColorTextureMap()) {\n        tNumComp = model.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents();\n        tcdim = 2;\n      }\n      if (tcdim === 2) {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;').result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordVCVSOutput[];', 'out vec2 tcoordVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec2 tcoordVCVSOutput;', 'uniform sampler2D texture1;']).result;\n        if (tus && tus.length >= 1) {\n          switch (tNumComp) {\n            case 1:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;\n              break;\n            case 2:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;\n              break;\n            default:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;\n          }\n        }\n      } else {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;').result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec3 tcoordVCVSOutput[];', 'out vec3 tcoordVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec3 tcoordVCVSOutput;', 'uniform samplerCube texture1;']).result;\n        switch (tNumComp) {\n          case 1:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;\n            break;\n          case 2:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;\n            break;\n          default:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;\n        }\n      }\n      shaders.Vertex = VSSource;\n      shaders.Geometry = GSSource;\n      shaders.Fragment = FSSource;\n    }\n  };\n  publicAPI.replaceShaderClip = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', `uniform vec4 clipPlanes[${numClipPlanes}];`, `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Impl', [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Impl', [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.getCoincidentParameters = (ren, actor) => {\n    // 1. ResolveCoincidentTopology is On and non zero for this primitive\n    // type\n    let cp = {\n      factor: 0.0,\n      offset: 0.0\n    };\n    const prop = actor.getProperty();\n    if (model.renderable.getResolveCoincidentTopology() || prop.getEdgeVisibility() && prop.getRepresentation() === Representation.SURFACE) {\n      const primType = model.lastBoundBO.getPrimitiveType();\n      if (primType === primTypes.Points || prop.getRepresentation() === Representation.POINTS) {\n        cp = model.renderable.getCoincidentTopologyPointOffsetParameter();\n      } else if (primType === primTypes.Lines || prop.getRepresentation() === Representation.WIREFRAME) {\n        cp = model.renderable.getCoincidentTopologyLineOffsetParameters();\n      } else if (primType === primTypes.Tris || primType === primTypes.TriStrips) {\n        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n      }\n      if (primType === primTypes.TrisEdges || primType === primTypes.TriStripsEdges) {\n        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n        cp.factor /= 2.0;\n        cp.offset /= 2.0;\n      }\n    }\n\n    // hardware picking always offset due to saved zbuffer\n    // This gets you above the saved surface depth buffer.\n    const selector = model._openGLRenderer.getSelector();\n    if (selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      cp.offset -= 2.0;\n    }\n    return cp;\n  };\n  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {\n    let FSSource = shaders.Fragment;\n    let VSSource = shaders.Vertex;\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', ['uniform int picking;', '//VTK::Picking::Dec']).result;\n    if (!model._openGLRenderer.getSelector()) {\n      return;\n    }\n    if (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24) {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Picking::Dec', ['flat out int vertexIDVSOutput;\\n', 'uniform int VertexIDOffset;\\n']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Picking::Impl', '  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\\n').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', 'flat in int vertexIDVSOutput;\\n').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', ['  int idx = vertexIDVSOutput;', '//VTK::Picking::Impl']).result;\n    }\n    switch (model.lastSelectionState) {\n      case PassTypes.ID_LOW24:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);').result;\n        break;\n      case PassTypes.ID_HIGH24:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float(idx)/255.0, 0.0, 0.0, 1.0);').result;\n        break;\n      default:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', 'uniform vec3 mapperIndex;').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];').result;\n    }\n    shaders.Fragment = FSSource;\n    shaders.Vertex = VSSource;\n  };\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    publicAPI.replaceShaderColor(shaders, ren, actor);\n    publicAPI.replaceShaderNormal(shaders, ren, actor);\n    publicAPI.replaceShaderLight(shaders, ren, actor);\n    publicAPI.replaceShaderTCoord(shaders, ren, actor);\n    publicAPI.replaceShaderPicking(shaders, ren, actor);\n    publicAPI.replaceShaderClip(shaders, ren, actor);\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n    publicAPI.replaceShaderPositionVC(shaders, ren, actor);\n    if (model.haveSeenDepthRequest) {\n      let FSSource = shaders.Fragment;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n      shaders.Fragment = FSSource;\n    }\n  };\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    let lightComplexity = 0;\n    let numberOfLights = 0;\n    const primType = cellBO.getPrimitiveType();\n    const poly = model.currentInput;\n\n    // different algo from C++ as of 5/2019\n    let needLighting = false;\n    const pointNormals = poly.getPointData().getNormals();\n    const cellNormals = poly.getCellData().getNormals();\n    const flat = actor.getProperty().getInterpolation() === Shading.FLAT;\n    const representation = actor.getProperty().getRepresentation();\n    const mode = cellBO.getOpenGLMode(representation, primType);\n    // 1) all surfaces need lighting\n    if (mode === model.context.TRIANGLES) {\n      needLighting = true;\n      // 2) all cell normals without point normals need lighting\n    } else if (cellNormals && !pointNormals) {\n      needLighting = true;\n      // 3) Phong + pointNormals need lighting\n    } else if (!flat && pointNormals) {\n      needLighting = true;\n      // 4) Phong Lines need lighting\n    } else if (!flat && mode === model.context.LINES) {\n      needLighting = true;\n    }\n    // 5) everything else is unlit\n\n    // do we need lighting?\n    if (actor.getProperty().getLighting() && needLighting) {\n      // consider the lighting complexity to determine which case applies\n      // simple headlight, Light Kit, the whole feature set of VTK\n      lightComplexity = 0;\n      const lights = ren.getLightsByReference();\n      for (let index = 0; index < lights.length; ++index) {\n        const light = lights[index];\n        const status = light.getSwitch();\n        if (status > 0) {\n          numberOfLights++;\n          if (lightComplexity === 0) {\n            lightComplexity = 1;\n          }\n        }\n        if (lightComplexity === 1 && (numberOfLights > 1 || light.getIntensity() !== 1.0 || !light.lightTypeIsHeadLight())) {\n          lightComplexity = 2;\n        }\n        if (lightComplexity < 3 && light.getPositional()) {\n          lightComplexity = 3;\n        }\n      }\n    }\n    let needRebuild = false;\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    const lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');\n    if (lastLightComplexity !== lightComplexity || lastLightCount !== numberOfLights) {\n      model.lastBoundBO.set({\n        lastLightComplexity: lightComplexity\n      }, true);\n      model.lastBoundBO.set({\n        lastLightCount: numberOfLights\n      }, true);\n      needRebuild = true;\n    }\n\n    // has the render pass shader replacement changed? Two options\n    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {\n      needRebuild = true;\n    }\n\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    // render pass shader replacement changed\n    if (model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.selectionStateChanged.getMTime() || needRebuild) {\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      return true;\n    }\n    return false;\n  };\n  publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {\n    const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;\n    if (listCallbacks) {\n      listCallbacks.forEach(object => {\n        object.callback(object.userData, cellBO, ren, actor);\n      });\n    }\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    // Now to update the VAO too, if necessary.\n    if (cellBO.getProgram().isUniformUsed('PrimitiveIDOffset')) {\n      cellBO.getProgram().setUniformi('PrimitiveIDOffset', model.primitiveIDOffset);\n    }\n    if (cellBO.getProgram().isUniformUsed('VertexIDOffset')) {\n      cellBO.getProgram().setUniformi('VertexIDOffset', model.vertexIDOffset);\n    }\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {\n          vtkErrorMacro('Error setting vertexMC in shader VAO.');\n        }\n      }\n      if (cellBO.getProgram().isAttributeUsed('normalMC') && cellBO.getCABO().getNormalOffset() && lastLightComplexity > 0) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'normalMC', cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {\n          vtkErrorMacro('Error setting normalMC in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('normalMC');\n      }\n      model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {\n        if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {\n          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {\n            vtkErrorMacro(`Error setting ${attrName}MC in shader VAO.`);\n          }\n        }\n      });\n      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {\n          vtkErrorMacro('Error setting tcoordMC in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('tcoordMC');\n      }\n      if (cellBO.getProgram().isAttributeUsed('scalarColor') && cellBO.getCABO().getColorComponents()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), 'scalarColor', cellBO.getCABO().getColorOffset(), cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 4, true)) {\n          vtkErrorMacro('Error setting scalarColor in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('scalarColor');\n      }\n      cellBO.getAttributeUpdateTime().modified();\n    }\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      // add all the clipping planes\n      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      const planeEquations = [];\n      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n      const mat = inverseShiftScaleMatrix ? mat4.copy(model.tmpMat4, actor.getMatrix()) : actor.getMatrix();\n      if (inverseShiftScaleMatrix) {\n        mat4.transpose(mat, mat);\n        mat4.multiply(mat, mat, inverseShiftScaleMatrix);\n        mat4.transpose(mat, mat);\n      }\n      for (let i = 0; i < numClipPlanes; i++) {\n        const planeEquation = [];\n        model.renderable.getClippingPlaneInDataCoords(mat, i, planeEquation);\n        for (let j = 0; j < 4; j++) {\n          planeEquations.push(planeEquation[j]);\n        }\n      }\n      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);\n      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);\n    }\n    if (model.internalColorTexture && cellBO.getProgram().isUniformUsed('texture1')) {\n      cellBO.getProgram().setUniformi('texture1', model.internalColorTexture.getTextureUnit());\n    }\n    const tus = model.openGLActor.getActiveTextures();\n    if (tus) {\n      for (let index = 0; index < tus.length; ++index) {\n        const tex = tus[index];\n        const texUnit = tex.getTextureUnit();\n        const tname = `texture${texUnit + 1}`;\n        if (cellBO.getProgram().isUniformUsed(tname)) {\n          cellBO.getProgram().setUniformi(tname, texUnit);\n        }\n      }\n    }\n\n    // handle depth requests\n    if (model.haveSeenDepthRequest) {\n      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    }\n\n    // handle coincident\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      const cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset);\n      // cfactor isn't always used when coffset is.\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    }\n\n    // handle wide lines\n    cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());\n    const selector = model._openGLRenderer.getSelector();\n    cellBO.getProgram().setUniform3fArray('mapperIndex', selector ? selector.getPropColorValue() : [0.0, 0.0, 0.0]);\n    cellBO.getProgram().setUniformi('picking', selector ? selector.getCurrentPass() + 1 : 0);\n  };\n  publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {\n    // for unlit and headlight there are no lighting parameters\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity < 2) {\n      return;\n    }\n    const program = cellBO.getProgram();\n\n    // bind some light settings\n    let numberOfLights = 0;\n    const lights = ren.getLightsByReference();\n    for (let index = 0; index < lights.length; ++index) {\n      const light = lights[index];\n      const status = light.getSwitch();\n      if (status > 0.0) {\n        const dColor = light.getColorByReference();\n        const intensity = light.getIntensity();\n        model.lightColor[0] = dColor[0] * intensity;\n        model.lightColor[1] = dColor[1] * intensity;\n        model.lightColor[2] = dColor[2] * intensity;\n        // get required info from light\n        const ld = light.getDirection();\n        const transform = ren.getActiveCamera().getViewMatrix();\n        const newLightDirection = [...ld];\n        if (light.lightTypeIsSceneLight()) {\n          newLightDirection[0] = transform[0] * ld[0] + transform[1] * ld[1] + transform[2] * ld[2];\n          newLightDirection[1] = transform[4] * ld[0] + transform[5] * ld[1] + transform[6] * ld[2];\n          newLightDirection[2] = transform[8] * ld[0] + transform[9] * ld[1] + transform[10] * ld[2];\n          normalize(newLightDirection);\n        }\n        model.lightDirection[0] = newLightDirection[0];\n        model.lightDirection[1] = newLightDirection[1];\n        model.lightDirection[2] = newLightDirection[2];\n        normalize(model.lightDirection);\n        program.setUniform3fArray(`lightColor${numberOfLights}`, model.lightColor);\n        program.setUniform3fArray(`lightDirectionVC${numberOfLights}`, model.lightDirection);\n        numberOfLights++;\n      }\n    }\n\n    // we are done unless we have positional lights\n    if (lastLightComplexity < 3) {\n      return;\n    }\n\n    // for lightkit case there are some parameters to set\n    const cam = ren.getActiveCamera();\n    const viewTF = cam.getViewMatrix();\n    mat4.transpose(viewTF, viewTF);\n    numberOfLights = 0;\n    for (let index = 0; index < lights.length; ++index) {\n      const light = lights[index];\n      const status = light.getSwitch();\n      if (status > 0.0) {\n        const lp = light.getTransformedPosition();\n        const np = new Float64Array(3);\n        vec3.transformMat4(np, lp, viewTF);\n        program.setUniform3fArray(`lightAttenuation${numberOfLights}`, light.getAttenuationValuesByReference());\n        program.setUniformi(`lightPositional${numberOfLights}`, light.getPositional());\n        program.setUniformf(`lightExponent${numberOfLights}`, light.getExponent());\n        program.setUniformf(`lightConeAngle${numberOfLights}`, light.getConeAngle());\n        program.setUniform3fArray(`lightPositionVC${numberOfLights}`, [np[0], np[1], np[2]]);\n        numberOfLights++;\n      }\n    }\n  };\n  function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {\n    matrixType.identity(tmpMat);\n    return matrixArray.reduce((res, matrix, index) => {\n      if (index === 0) {\n        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);\n      }\n      return matrix ? matrixType.multiply(res, res, matrix) : res;\n    }, tmpMat);\n  }\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n\n    // [WMVP]C == {world, model, view, projection} coordinates\n    // E.g., WCPC == world to projection coordinate transformation\n    const keyMats = model.openGLCamera.getKeyMatrices(ren);\n    const cam = ren.getActiveCamera();\n    const camm = model.openGLCamera.getKeyMatrixTime().getMTime();\n    const progm = program.getLastCameraMTime();\n    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n    const actorIsIdentity = actor.getIsIdentity();\n    const actMats = actorIsIdentity ? {\n      mcwc: null,\n      normalMatrix: null\n    } : model.openGLActor.getKeyMatrices();\n    if (actor.getCoordinateSystem() === CoordinateSystem.DISPLAY) {\n      const size = model._openGLRenderer.getTiledSizeAndOrigin();\n      mat4.identity(model.tmpMat4);\n      model.tmpMat4[0] = 2.0 / size.usize;\n      model.tmpMat4[12] = -1.0;\n      model.tmpMat4[5] = 2.0 / size.vsize;\n      model.tmpMat4[13] = -1.0;\n      mat4.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);\n      program.setUniformMatrix('MCPCMatrix', model.tmpMat4);\n    } else {\n      program.setUniformMatrix('MCPCMatrix', safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n    if (program.isUniformUsed('MCVCMatrix')) {\n      program.setUniformMatrix('MCVCMatrix', safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n    if (program.isUniformUsed('normalMatrix')) {\n      program.setUniformMatrix3x3('normalMatrix', safeMatrixMultiply([keyMats.normalMatrix, actMats.normalMatrix], mat3, model.tmpMat3));\n    }\n    if (progm !== camm) {\n      if (program.isUniformUsed('cameraParallel')) {\n        program.setUniformi('cameraParallel', cam.getParallelProjection());\n      }\n      program.setLastCameraMTime(camm);\n    }\n    if (!actorIsIdentity) {\n      // reset the cam mtime as actor modified the shader values\n      program.setLastCameraMTime(0);\n    }\n  };\n  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    let ppty = actor.getProperty();\n    let opacity = ppty.getOpacity();\n    let aColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getAmbientColorByReference();\n    let dColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getDiffuseColorByReference();\n    let aIntensity = model.drawingEdges ? 1.0 : ppty.getAmbient();\n    let dIntensity = model.drawingEdges ? 0.0 : ppty.getDiffuse();\n    let sIntensity = model.drawingEdges ? 0.0 : ppty.getSpecular();\n    const specularPower = ppty.getSpecularPower();\n    program.setUniformf('opacityUniform', opacity);\n    program.setUniform3fArray('ambientColorUniform', aColor);\n    program.setUniform3fArray('diffuseColorUniform', dColor);\n    program.setUniformf('ambient', aIntensity);\n    program.setUniformf('diffuse', dIntensity);\n\n    // we are done unless we have lighting\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity < 1) {\n      return;\n    }\n    let sColor = ppty.getSpecularColorByReference();\n    program.setUniform3fArray('specularColorUniform', sColor);\n    program.setUniformf('specularPowerUniform', specularPower);\n    program.setUniformf('specular', sIntensity);\n\n    // now set the backface properties if we have them\n    if (program.isUniformUsed('ambientIntensityBF')) {\n      ppty = actor.getBackfaceProperty();\n      opacity = ppty.getOpacity();\n      aColor = ppty.getAmbientColor();\n      aIntensity = ppty.getAmbient();\n      dColor = ppty.getDiffuseColor();\n      dIntensity = ppty.getDiffuse();\n      sColor = ppty.getSpecularColor();\n      sIntensity = ppty.getSpecular();\n      program.setUniformf('ambientIntensityBF', aIntensity);\n      program.setUniformf('diffuseIntensityBF', dIntensity);\n      program.setUniformf('opacityUniformBF', opacity);\n      program.setUniform3fArray('ambientColorUniformBF', aColor);\n      program.setUniform3fArray('diffuseColorUniformBF', dColor);\n\n      // we are done unless we have lighting\n      if (lastLightComplexity < 1) {\n        return;\n      }\n      program.setUniformf('specularIntensityBF', sIntensity);\n      program.setUniform3fArray('specularColorUniformBF', sColor);\n      program.setUniformf('specularPowerUniformBF', specularPower);\n    }\n  };\n  publicAPI.updateMaximumPointCellIds = (ren, actor) => {\n    const selector = model._openGLRenderer.getSelector();\n    if (!selector) {\n      return;\n    }\n    if (model.selectionWebGLIdsToVTKIds?.points?.length) {\n      const length = model.selectionWebGLIdsToVTKIds.points.length;\n      selector.setMaximumPointId(length - 1);\n    }\n    if (model.selectionWebGLIdsToVTKIds?.cells?.length) {\n      const length = model.selectionWebGLIdsToVTKIds.cells.length;\n      selector.setMaximumCellId(length - 1);\n    }\n    const fieldAssociation = selector.getFieldAssociation();\n    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      model.pointPicking = true;\n    }\n  };\n  publicAPI.renderPieceStart = (ren, actor) => {\n    model.primitiveIDOffset = 0;\n    model.vertexIDOffset = 0;\n    const picking = getPickState(model._openGLRenderer);\n    if (model.lastSelectionState !== picking) {\n      model.selectionStateChanged.modified();\n      model.lastSelectionState = picking;\n    }\n    if (model._openGLRenderer.getSelector()) {\n      switch (picking) {\n        default:\n          model._openGLRenderer.getSelector().renderProp(actor);\n      }\n    }\n\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor);\n\n    // If we are coloring by texture, then load the texture map.\n    // Use Map as indicator, because texture hangs around.\n    if (model.renderable.getColorTextureMap()) {\n      model.internalColorTexture.activate();\n    }\n\n    // Bind the OpenGL, this is shared between the different primitive/cell types.\n    model.lastBoundBO = null;\n  };\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const representation = actor.getProperty().getRepresentation();\n    const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;\n    const selector = model._openGLRenderer.getSelector();\n    // If we are picking points, we need to tell it to the helper\n    const pointPicking = selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS && (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24);\n\n    // for every primitive type\n    for (let i = primTypes.Start; i < primTypes.End; i++) {\n      model.primitives[i].setPointPicking(pointPicking);\n      const cabo = model.primitives[i].getCABO();\n      if (cabo.getElementCount()) {\n        // are we drawing edges\n        model.drawingEdges = drawSurfaceWithEdges && (i === primTypes.TrisEdges || i === primTypes.TriStripsEdges);\n        // don't draw edges when rendering depth or rendering for picking\n        if (!model.drawingEdges || !(model.renderDepth || model.lastSelectionState >= 0)) {\n          model.lastBoundBO = model.primitives[i];\n          model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);\n          model.vertexIDOffset += model.primitives[i].getCABO().getElementCount();\n        }\n      }\n    }\n  };\n  publicAPI.renderPieceFinish = (ren, actor) => {\n    if (model.LastBoundBO) {\n      model.LastBoundBO.getVAO().release();\n    }\n    if (model.renderable.getColorTextureMap()) {\n      model.internalColorTexture.deactivate();\n    }\n  };\n  publicAPI.renderPiece = (ren, actor) => {\n    // Make sure that we have been properly initialized.\n    // if (ren.getRenderWindow().checkAbortStatus()) {\n    //   return;\n    // }\n\n    publicAPI.invokeEvent(StartEvent);\n    if (!model.renderable.getStatic()) {\n      model.renderable.update();\n    }\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.invokeEvent(EndEvent);\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n\n    // if there are no points then we are done\n    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {\n      return;\n    }\n\n    // apply faceCulling\n    const gl = model.context;\n    const backfaceCulling = actor.getProperty().getBackfaceCulling();\n    const frontfaceCulling = actor.getProperty().getFrontfaceCulling();\n    if (!backfaceCulling && !frontfaceCulling) {\n      model._openGLRenderWindow.disableCullFace();\n    } else if (frontfaceCulling) {\n      model._openGLRenderWindow.enableCullFace();\n      gl.cullFace(gl.FRONT);\n    } else {\n      model._openGLRenderWindow.enableCullFace();\n      gl.cullFace(gl.BACK);\n    }\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n  publicAPI.computeBounds = (ren, actor) => {\n    if (!publicAPI.getInput()) {\n      uninitializeBounds(model.bounds);\n      return;\n    }\n    model.bounds = publicAPI.getInput().getBounds();\n  };\n  publicAPI.updateBufferObjects = (ren, actor) => {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {\n    // first do a coarse check\n    // Note that the actor's mtime includes it's properties mtime\n    const vmtime = model.VBOBuildTime.getMTime();\n    if (vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const poly = model.currentInput;\n    if (poly === null) {\n      return;\n    }\n    model.renderable.mapScalars(poly, 1.0);\n    const c = model.renderable.getColorMapColors();\n    model.haveCellScalars = false;\n    const scalarMode = model.renderable.getScalarMode();\n    if (model.renderable.getScalarVisibility()) {\n      // We must figure out how the scalars should be mapped to the polydata.\n      if ((scalarMode === ScalarMode.USE_CELL_DATA || scalarMode === ScalarMode.USE_CELL_FIELD_DATA || scalarMode === ScalarMode.USE_FIELD_DATA || !poly.getPointData().getScalars()) && scalarMode !== ScalarMode.USE_POINT_FIELD_DATA && c) {\n        model.haveCellScalars = true;\n      }\n    }\n\n    // Do we have normals?\n    let n = actor.getProperty().getInterpolation() !== Shading.FLAT ? poly.getPointData().getNormals() : null;\n    if (n === null && poly.getCellData().getNormals()) {\n      model.haveCellNormals = true;\n      n = poly.getCellData().getNormals();\n    }\n\n    // rebuild the VBO if the data has changed we create a string for the VBO what\n    // can change the VBO? points normals tcoords colors so what can change those?\n    // the input data is clearly one as it can change all four items tcoords may\n    // haveTextures or not colors may change based on quite a few mapping\n    // parameters in the mapper\n\n    const representation = actor.getProperty().getRepresentation();\n    let tcoords = poly.getPointData().getTCoords();\n    if (!model.openGLActor.getActiveTextures()) {\n      tcoords = null;\n    }\n\n    // handle color mapping via texture\n    if (model.renderable.getColorCoordinates()) {\n      tcoords = model.renderable.getColorCoordinates();\n      if (!model.internalColorTexture) {\n        model.internalColorTexture = vtkOpenGLTexture.newInstance({\n          resizable: true\n        });\n      }\n      const tex = model.internalColorTexture;\n      // the following 4 lines allow for NPOT textures\n      tex.setMinificationFilter(Filter.NEAREST);\n      tex.setMagnificationFilter(Filter.NEAREST);\n      tex.setWrapS(Wrap.CLAMP_TO_EDGE);\n      tex.setWrapT(Wrap.CLAMP_TO_EDGE);\n      tex.setOpenGLRenderWindow(model._openGLRenderWindow);\n      const input = model.renderable.getColorTextureMap();\n      const ext = input.getExtent();\n      const inScalars = input.getPointData().getScalars();\n      tex.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());\n      tex.activate();\n      tex.sendParameters();\n      tex.deactivate();\n    }\n    const toString = `${poly.getMTime()}A${representation}B${poly.getMTime()}` + `C${n ? n.getMTime() : 1}D${c ? c.getMTime() : 1}` + `E${actor.getProperty().getEdgeVisibility()}` + `F${tcoords ? tcoords.getMTime() : 1}`;\n    if (model.VBOBuildString !== toString) {\n      // Build the VBOs\n      const points = poly.getPoints();\n      const options = {\n        points,\n        normals: n,\n        tcoords,\n        colors: c,\n        cellOffset: 0,\n        vertexOffset: 0,\n        // Used to keep track of vertex ids across primitives for selection\n        haveCellScalars: model.haveCellScalars,\n        haveCellNormals: model.haveCellNormals,\n        customAttributes: model.renderable.getCustomShaderAttributes().map(arrayName => poly.getPointData().getArrayByName(arrayName))\n      };\n      if (model.renderable.getPopulateSelectionSettings()) {\n        model.selectionWebGLIdsToVTKIds = {\n          points: null,\n          cells: null\n        };\n      }\n      const primitives = [{\n        inRep: 'verts',\n        cells: poly.getVerts()\n      }, {\n        inRep: 'lines',\n        cells: poly.getLines()\n      }, {\n        inRep: 'polys',\n        cells: poly.getPolys()\n      }, {\n        inRep: 'strips',\n        cells: poly.getStrips()\n      }, {\n        inRep: 'polys',\n        cells: poly.getPolys()\n      }, {\n        inRep: 'strips',\n        cells: poly.getStrips()\n      }];\n      const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;\n      for (let i = primTypes.Start; i < primTypes.End; i++) {\n        if (i !== primTypes.TrisEdges && i !== primTypes.TriStripsEdges) {\n          options.cellOffset += model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, representation, options, model.selectionWebGLIdsToVTKIds);\n          options.vertexOffset += model.primitives[i].getCABO().getElementCount();\n        } else {\n          // if we have edge visibility build the edge VBOs\n          if (drawSurfaceWithEdges) {\n            // VBOs for edges in \"surface with edges\" are the last to be built,\n            // they are not used when picking with a hardware selector so they\n            // don't need selectionWebGLIdsToVTKIds and don't update cellOffset and vertexOffset\n            model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, Representation.WIREFRAME, {\n              ...options,\n              tcoords: null,\n              colors: null,\n              haveCellScalars: false,\n              haveCellNormals: false\n            });\n          } else {\n            // otherwise free them\n            model.primitives[i].releaseGraphicsResources();\n          }\n        }\n      }\n      if (model.renderable.getPopulateSelectionSettings()) {\n        model.renderable.setSelectionWebGLIdsToVTKIds(model.selectionWebGLIdsToVTKIds);\n        publicAPI.updateMaximumPointCellIds();\n      }\n      model.VBOBuildTime.modified();\n      model.VBOBuildString = toString;\n    }\n  };\n  publicAPI.getAllocatedGPUMemoryInBytes = () => {\n    let memUsed = 0;\n    model.primitives.forEach(prim => {\n      memUsed += prim.getAllocatedGPUMemoryInBytes();\n    });\n    // Return in MB\n    return memUsed;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  VBOBuildTime: 0,\n  VBOBuildString: null,\n  primitives: null,\n  primTypes: null,\n  shaderRebuildString: null,\n  tmpMat4: null,\n  ambientColor: [],\n  // used internally\n  diffuseColor: [],\n  // used internally\n  specularColor: [],\n  // used internally\n  lightColor: [],\n  // used internally\n  lightDirection: [],\n  // used internally\n  lastHaveSeenDepthRequest: false,\n  haveSeenDepthRequest: false,\n  lastSelectionState: PassTypes.MIN_KNOWN_PASS - 1,\n  selectionStateChanged: null,\n  selectionWebGLIdsToVTKIds: null,\n  pointPicking: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);\n  model.primitives = [];\n  model.primTypes = primTypes;\n  model.tmpMat3 = mat3.identity(new Float64Array(9));\n  model.tmpMat4 = mat4.identity(new Float64Array(16));\n  for (let i = primTypes.Start; i < primTypes.End; i++) {\n    model.primitives[i] = vtkHelper.newInstance();\n    model.primitives[i].setPrimitiveType(i);\n    model.primitives[i].set({\n      lastLightComplexity: 0,\n      lastLightCount: 0,\n      lastSelectionPass: false\n    }, true);\n  }\n\n  // Build VTK API\n  setGet(publicAPI, model, ['context']);\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime, {\n    mtime: 0\n  });\n  model.selectionStateChanged = {};\n  obj(model.selectionStateChanged, {\n    mtime: 0\n  });\n\n  // Object methods\n  vtkOpenGLPolyDataMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLPolyDataMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkOpenGLPolyDataMapper$1 = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkMapper', newInstance);\n\nexport { vtkOpenGLPolyDataMapper$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}