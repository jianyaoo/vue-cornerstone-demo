{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport * as d3 from 'd3-scale';\nimport { O as nearestPowerOfTwo } from '../../Common/Core/Math/index.js';\nimport { m as macro } from '../../macros2.js';\nimport vtkActor from './Actor.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors.js';\nimport vtkMapper from './Mapper.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkTexture from './Texture.js';\nconst {\n  VectorMode\n} = vtkScalarsToColors;\n\n// ----------------------------------------------------------------------------\n// vtkScalarBarActor\n//\n// Note log scales are currently not supported\n//\n// Developer note: This class is broken into the main class and a helper\n// class. The main class holds view independent properties (those properties\n// that do not change as the view's resolution/aspect ratio change). The\n// helper class is instantiated one per view and holds properties that can\n// depend on view specific values such as resolution. The helper class code\n// could have been left to the View specific implementation (such as\n// vtkWebGPUScalarBarActor) but is instead placed here to it can be shared by\n// multiple rendering backends.\n//\n// ----------------------------------------------------------------------------\n\nfunction applyTextStyle(ctx, style) {\n  ctx.strokeStyle = style.strokeColor;\n  ctx.lineWidth = style.strokeSize;\n  ctx.fillStyle = style.fontColor;\n  ctx.font = `${style.fontStyle} ${style.fontSize}px ${style.fontFamily}`;\n}\n\n// ----------------------------------------------------------------------------\n// Default autoLayout function\n// ----------------------------------------------------------------------------\n\n// compute good values to use based on window size etc a bunch of heuristics\n// here with hand tuned constants These values worked for me but really this\n// method could be redically changed. The basic gist is\n// 1) compute a resonable font size\n// 2) render the text atlas using those font sizes\n// 3) pick horizontal or vertical bsed on window size\n// 4) based on the size of the title and tick labels rendered\n//    compute the box size and position such that\n//    the text will all fit nicely and the bar will be a resonable size\n// 5) compute the bar segments based on the above settings\n//\n// Note that this function can and should read values from the\n// ScalarBarActor but should only write values to the view dependent helper\n// instance that is provided as those values are the ones that will be used\n// for rendering.\n//\nfunction defaultAutoLayout(publicAPI, model) {\n  return helper => {\n    // we don't do a linear scale, the proportions for\n    // a 700 pixel window differ from a 1400\n    const lastSize = helper.getLastSize();\n    const xAxisAdjust = (lastSize[0] / 700) ** 0.8;\n    const yAxisAdjust = (lastSize[1] / 700) ** 0.8;\n    const minAdjust = Math.min(xAxisAdjust, yAxisAdjust);\n    const axisTextStyle = helper.getAxisTextStyle();\n    const tickTextStyle = helper.getTickTextStyle();\n    Object.assign(axisTextStyle, model.axisTextStyle);\n    Object.assign(tickTextStyle, model.tickTextStyle);\n\n    // compute a reasonable font size first\n    axisTextStyle.fontSize = Math.max(24 * minAdjust, 12);\n    if (helper.getLastAspectRatio() > 1.0) {\n      tickTextStyle.fontSize = Math.max(20 * minAdjust, 10);\n    } else {\n      tickTextStyle.fontSize = Math.max(16 * minAdjust, 10);\n    }\n\n    // rebuild the text atlas\n    const textSizes = helper.updateTextureAtlas();\n\n    // now compute the boxSize and pixel offsets, different algorithm\n    // for horizonal versus vertical\n    helper.setTopTitle(false);\n    const boxSize = helper.getBoxSizeByReference();\n\n    // if vertical\n    if (helper.getLastAspectRatio() > 1.0) {\n      helper.setTickLabelPixelOffset(0.3 * tickTextStyle.fontSize);\n\n      // if the title will fit within the width of the bar then that looks\n      // nicer to put it at the top (helper.topTitle), otherwise rotate it\n      // and place it sideways\n      if (textSizes.titleWidth <= textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) {\n        helper.setTopTitle(true);\n        helper.setAxisTitlePixelOffset(0.2 * tickTextStyle.fontSize);\n        boxSize[0] = 2.0 * (textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) / lastSize[0];\n        helper.setBoxPosition([0.98 - boxSize[0], -0.92]);\n      } else {\n        helper.setAxisTitlePixelOffset(0.2 * tickTextStyle.fontSize);\n        boxSize[0] = 2.0 * (textSizes.titleHeight + helper.getAxisTitlePixelOffset() + textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) / lastSize[0];\n        helper.setBoxPosition([0.99 - boxSize[0], -0.92]);\n      }\n      boxSize[1] = Math.max(1.2, Math.min(1.84 / yAxisAdjust, 1.84));\n    } else {\n      // horizontal\n      helper.setAxisTitlePixelOffset(1.2 * tickTextStyle.fontSize);\n      helper.setTickLabelPixelOffset(0.1 * tickTextStyle.fontSize);\n      const titleHeight =\n      // total offset from top of bar (includes ticks)\n      2.0 * (0.8 * tickTextStyle.fontSize + textSizes.titleHeight + helper.getAxisTitlePixelOffset()) / lastSize[1];\n      const tickWidth = 2.0 * textSizes.tickWidth / lastSize[0];\n      boxSize[0] = Math.min(1.9, Math.max(1.4, 1.4 * tickWidth * (helper.getTicks().length + 3)));\n      boxSize[1] = titleHeight;\n      helper.setBoxPosition([-0.5 * boxSize[0], -0.97]);\n    }\n\n    // recomute bar segments based on positioning\n    helper.recomputeBarSegments(textSizes);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Default generateTicks function\n// ----------------------------------------------------------------------------\n\n// This function returns the default function used to generate vtkScalarBarActor ticks.\n// The default function makes use of d3.scaleLinear() to generate 5 tick marks between\n// the minimum and maximum values of the scalar bar. Customize this behavior by passing\n// a function to vtkScalarBarActor.newInstance({ generateTicks: customGenerateTicks })\n// or by calling scalarBarActor.setGenerateTicks(customGenerateTicks).\nfunction defaultGenerateTicks(publicApi, model) {\n  return helper => {\n    const lastTickBounds = helper.getLastTickBounds();\n    const scale = d3.scaleLinear().domain([lastTickBounds[0], lastTickBounds[1]]);\n    const ticks = scale.ticks(5);\n    const format = scale.tickFormat(5);\n    helper.setTicks(ticks);\n    helper.setTickStrings(ticks.map(format));\n  };\n}\n\n// many properties of this actor depend on the API specific view The main\n// dependency being the resolution as that drives what font sizes to use.\n// Bacause of this we need to do some of the calculations in a API specific\n// subclass. But... we don't want a lot of duplicated code between WebGL and\n// WebGPU for example so we have this helper class, that is designed to be\n// fairly API independent so that API specific views can call this to do\n// most of the work.\nfunction vtkScalarBarActorHelper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkScalarBarActorHelper');\n  publicAPI.setRenderable = renderable => {\n    if (model.renderable === renderable) {\n      return;\n    }\n    model.renderable = renderable;\n    model.barActor.setProperty(renderable.getProperty());\n    model.barActor.setParentProp(renderable);\n    model.barActor.setCoordinateSystemToDisplay();\n    model.tmActor.setProperty(renderable.getProperty());\n    model.tmActor.setParentProp(renderable);\n    model.tmActor.setCoordinateSystemToDisplay();\n    model.generateTicks = renderable.generateTicks;\n    model.axisTextStyle = {\n      ...renderable.getAxisTextStyle()\n    };\n    model.tickTextStyle = {\n      ...renderable.getTickTextStyle()\n    };\n    publicAPI.modified();\n  };\n  publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {\n    // has the size changed?\n    if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {\n      model.lastSize[0] = size[0];\n      model.lastSize[1] = size[1];\n      model.lastAspectRatio = size[0] / size[1];\n      model.forceUpdate = true;\n    }\n    const scalarsToColors = model.renderable.getScalarsToColors();\n    if (!scalarsToColors || !model.renderable.getVisibility()) {\n      return;\n    }\n\n    // make sure the lut is assigned to our mapper\n    model.barMapper.setLookupTable(scalarsToColors);\n\n    // camera should be the same for all views\n    model.camera = camera;\n    model.renderWindow = renderWindow;\n\n    // did something significant change? If so rebuild a lot of things\n    if (model.forceUpdate || Math.max(scalarsToColors.getMTime(), publicAPI.getMTime(), model.renderable.getMTime()) > model.lastRebuildTime.getMTime()) {\n      const range = scalarsToColors.getMappingRange();\n      model.lastTickBounds = [...range];\n\n      // compute tick marks for axes (update for log scale)\n      model.renderable.getGenerateTicks()(publicAPI);\n      if (model.renderable.getAutomated()) {\n        model.renderable.getAutoLayout()(publicAPI);\n      } else {\n        // copy values from renderable\n        model.axisTextStyle = {\n          ...model.renderable.getAxisTextStyle()\n        };\n        model.tickTextStyle = {\n          ...model.renderable.getTickTextStyle()\n        };\n        model.barPosition = [...model.renderable.getBarPosition()];\n        model.barSize = [...model.renderable.getBarSize()];\n        model.boxPosition = [...model.renderable.getBoxPosition()];\n        model.boxSize = [...model.renderable.getBoxSize()];\n        model.axisTitlePixelOffset = model.renderable.getAxisTitlePixelOffset();\n        model.tickLabelPixelOffset = model.renderable.getTickLabelPixelOffset();\n\n        // rebuild the texture only when force or changed bounds, face\n        // visibility changes do to change the atlas\n        const textSizes = publicAPI.updateTextureAtlas();\n\n        // recompute bar segments based on positioning\n        publicAPI.recomputeBarSegments(textSizes);\n      }\n      publicAPI.updatePolyDataForLabels();\n      publicAPI.updatePolyDataForBarSegments();\n      model.lastRebuildTime.modified();\n      model.forceUpdate = false;\n    }\n  };\n\n  // create the texture map atlas that contains the rendering of\n  // all the text strings. Only needs to be called when the text strings\n  // have changed (labels and ticks)\n  publicAPI.updateTextureAtlas = () => {\n    // set the text properties\n    model.tmContext.textBaseline = 'bottom';\n    model.tmContext.textAlign = 'left';\n\n    // return some factors about the text atlas\n    const results = {};\n\n    // first the axislabel\n    const newTmAtlas = new Map();\n    let maxWidth = 0;\n    let totalHeight = 1; // start one pixel in so we have a border\n    applyTextStyle(model.tmContext, model.axisTextStyle);\n    let metrics = model.tmContext.measureText(model.renderable.getAxisLabel());\n    let entry = {\n      height: metrics.actualBoundingBoxAscent + 2,\n      startingHeight: totalHeight,\n      width: metrics.width + 2,\n      textStyle: model.axisTextStyle\n    };\n    newTmAtlas.set(model.renderable.getAxisLabel(), entry);\n    totalHeight += entry.height;\n    maxWidth = entry.width;\n    results.titleWidth = entry.width;\n    results.titleHeight = entry.height;\n\n    // and the ticks, NaN Below and Above\n    results.tickWidth = 0;\n    results.tickHeight = 0;\n    applyTextStyle(model.tmContext, model.tickTextStyle);\n    const strings = [...publicAPI.getTickStrings(), 'NaN', 'Below', 'Above'];\n    for (let t = 0; t < strings.length; t++) {\n      if (!newTmAtlas.has(strings[t])) {\n        metrics = model.tmContext.measureText(strings[t]);\n        entry = {\n          height: metrics.actualBoundingBoxAscent + 2,\n          startingHeight: totalHeight,\n          width: metrics.width + 2,\n          textStyle: model.tickTextStyle\n        };\n        newTmAtlas.set(strings[t], entry);\n        totalHeight += entry.height;\n        if (maxWidth < entry.width) {\n          maxWidth = entry.width;\n        }\n        if (results.tickWidth < entry.width) {\n          results.tickWidth = entry.width;\n        }\n        if (results.tickHeight < entry.height) {\n          results.tickHeight = entry.height;\n        }\n      }\n    }\n\n    // always use power of two to avoid interpolation\n    // in cases where PO2 is required\n    maxWidth = nearestPowerOfTwo(maxWidth);\n    totalHeight = nearestPowerOfTwo(totalHeight);\n\n    // set the tcoord values\n    newTmAtlas.forEach(value => {\n      value.tcoords = [0.0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0.0, (totalHeight - value.startingHeight) / totalHeight];\n    });\n\n    // make sure we have power of two dimensions\n    model.tmCanvas.width = maxWidth;\n    model.tmCanvas.height = totalHeight;\n    model.tmContext.textBaseline = 'bottom';\n    model.tmContext.textAlign = 'left';\n    model.tmContext.clearRect(0, 0, maxWidth, totalHeight);\n\n    // draw the text onto the texture\n    newTmAtlas.forEach((value, key) => {\n      applyTextStyle(model.tmContext, value.textStyle);\n      model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);\n    });\n    model.tmTexture.setCanvas(model.tmCanvas);\n    // mark as modified since the canvas typically doesn't change\n    model.tmTexture.modified();\n    model._tmAtlas = newTmAtlas;\n    return results;\n  };\n  publicAPI.computeBarSize = textSizes => {\n    // compute orientation\n    model.vertical = model.boxSize[1] > model.boxSize[0];\n    const tickHeight = 2.0 * textSizes.tickHeight / model.lastSize[1];\n    const segSize = [1, 1];\n\n    // horizontal and vertical have different astetics so adjust based on\n    // orientation\n    if (model.vertical) {\n      const tickWidth = 2.0 * (textSizes.tickWidth + model.tickLabelPixelOffset) / model.lastSize[0];\n      if (model.topTitle) {\n        const titleHeight = 2.0 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[1];\n        model.barSize[0] = model.boxSize[0] - tickWidth;\n        model.barSize[1] = model.boxSize[1] - titleHeight;\n      } else {\n        // rotated title so width is based off height\n        const titleWidth = 2.0 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[0];\n        model.barSize[0] = model.boxSize[0] - titleWidth - tickWidth;\n        model.barSize[1] = model.boxSize[1];\n      }\n      model.barPosition[0] = model.boxPosition[0] + tickWidth;\n      model.barPosition[1] = model.boxPosition[1];\n      segSize[1] = tickHeight;\n    } else {\n      const tickWidth = (2.0 * textSizes.tickWidth - 8) / model.lastSize[0];\n      const titleHeight = 2.0 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[1];\n      model.barSize[0] = model.boxSize[0];\n      model.barPosition[0] = model.boxPosition[0];\n      model.barSize[1] = model.boxSize[1] - titleHeight;\n      model.barPosition[1] = model.boxPosition[1];\n      segSize[0] = tickWidth;\n    }\n    return segSize;\n  };\n\n  // based on all the settins compute a barSegments array\n  // containing the segments of the scalar bar\n  // each segment contains\n  //   corners[4][2]\n  //   title - e.g. NaN, Above, ticks\n  //   scalars - the normalized scalars values to use for that segment\n  //\n  // Note that the bar consumes the space in the box that remains after\n  // leaving room for the text labels\n  publicAPI.recomputeBarSegments = textSizes => {\n    // first compute the barSize/Position\n    const segSize = publicAPI.computeBarSize(textSizes);\n    model.barSegments = [];\n    const startPos = [0.0, 0.0];\n\n    // horizontal and vertical have different astetics so adjust based on\n    // orientation\n    const barAxis = model.vertical ? 1 : 0;\n    const segSpace = model.vertical ? 0.01 : 0.02;\n    function pushSeg(title, scalars) {\n      model.barSegments.push({\n        corners: [[...startPos], [startPos[0] + segSize[0], startPos[1]], [startPos[0] + segSize[0], startPos[1] + segSize[1]], [startPos[0], startPos[1] + segSize[1]]],\n        scalars,\n        title\n      });\n      startPos[barAxis] += segSize[barAxis] + segSpace;\n    }\n    if (model.renderable.getDrawNanAnnotation() && model.renderable.getScalarsToColors().getNanColor()) {\n      pushSeg('NaN', [NaN, NaN, NaN, NaN]);\n    }\n    if (model.renderable.getDrawBelowRangeSwatch() && model.renderable.getScalarsToColors().getUseBelowRangeColor?.()) {\n      pushSeg('Below', [-0.1, -0.1, -0.1, -0.1]);\n    }\n    const haveAbove = model.renderable.getScalarsToColors().getUseAboveRangeColor?.();\n\n    // extra space around the ticks section\n    startPos[barAxis] += segSpace;\n    const oldSegSize = segSize[barAxis];\n    segSize[barAxis] = haveAbove ? 1.0 - 2.0 * segSpace - segSize[barAxis] - startPos[barAxis] : 1.0 - segSpace - startPos[barAxis];\n    pushSeg('ticks', model.vertical ? [0, 0, 0.995, 0.995] : [0, 0.995, 0.995, 0]);\n    if (model.renderable.getDrawAboveRangeSwatch() && haveAbove) {\n      segSize[barAxis] = oldSegSize;\n      startPos[barAxis] += segSpace;\n      pushSeg('Above', [1.1, 1.1, 1.1, 1.1]);\n    }\n  };\n\n  // called by updatePolyDataForLabels\n  // modifies class constants tmp2v3\n  const tmp2v3 = new Float64Array(3);\n\n  // anchor point = pos\n  // H alignment = left, middle, right\n  // V alignment = bottom, middle, top\n  // Text Orientation = horizontal, vertical\n  // orientation\n  publicAPI.createPolyDataForOneLabel = (text, pos, alignment, orientation, offset, results) => {\n    const value = model._tmAtlas.get(text);\n    if (!value) {\n      return;\n    }\n    // have to find the four corners of the texture polygon for this label\n    let ptIdx = results.ptIdx;\n    let cellIdx = results.cellIdx;\n\n    // get achor point in pixels\n    tmp2v3[0] = (0.5 * pos[0] + 0.5) * model.lastSize[0];\n    tmp2v3[1] = (0.5 * pos[1] + 0.5) * model.lastSize[1];\n    tmp2v3[2] = pos[2];\n    tmp2v3[0] += offset[0];\n    tmp2v3[1] += offset[1];\n\n    // get text size in display pixels\n    const textSize = [];\n    const textAxes = orientation === 'vertical' ? [1, 0] : [0, 1];\n    if (orientation === 'vertical') {\n      textSize[0] = value.width;\n      textSize[1] = -value.height;\n      // update anchor point based on alignment\n      if (alignment[0] === 'middle') {\n        tmp2v3[1] -= value.width / 2.0;\n      } else if (alignment[0] === 'right') {\n        tmp2v3[1] -= value.width;\n      }\n      if (alignment[1] === 'middle') {\n        tmp2v3[0] += value.height / 2.0;\n      } else if (alignment[1] === 'top') {\n        tmp2v3[0] += value.height;\n      }\n    } else {\n      textSize[0] = value.width;\n      textSize[1] = value.height;\n      // update anchor point based on alignment\n      if (alignment[0] === 'middle') {\n        tmp2v3[0] -= value.width / 2.0;\n      } else if (alignment[0] === 'right') {\n        tmp2v3[0] -= value.width;\n      }\n      if (alignment[1] === 'middle') {\n        tmp2v3[1] -= value.height / 2.0;\n      } else if (alignment[1] === 'top') {\n        tmp2v3[1] -= value.height;\n      }\n    }\n    results.points[ptIdx * 3] = tmp2v3[0];\n    results.points[ptIdx * 3 + 1] = tmp2v3[1];\n    results.points[ptIdx * 3 + 2] = tmp2v3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[0];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];\n    ptIdx++;\n    tmp2v3[textAxes[0]] += textSize[0];\n    results.points[ptIdx * 3] = tmp2v3[0];\n    results.points[ptIdx * 3 + 1] = tmp2v3[1];\n    results.points[ptIdx * 3 + 2] = tmp2v3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[2];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];\n    ptIdx++;\n    tmp2v3[textAxes[1]] += textSize[1];\n    results.points[ptIdx * 3] = tmp2v3[0];\n    results.points[ptIdx * 3 + 1] = tmp2v3[1];\n    results.points[ptIdx * 3 + 2] = tmp2v3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[4];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];\n    ptIdx++;\n    tmp2v3[textAxes[0]] -= textSize[0];\n    results.points[ptIdx * 3] = tmp2v3[0];\n    results.points[ptIdx * 3 + 1] = tmp2v3[1];\n    results.points[ptIdx * 3 + 2] = tmp2v3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[6];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];\n    ptIdx++;\n\n    // add the two triangles to represent the quad\n    results.polys[cellIdx * 4] = 3;\n    results.polys[cellIdx * 4 + 1] = ptIdx - 4;\n    results.polys[cellIdx * 4 + 2] = ptIdx - 3;\n    results.polys[cellIdx * 4 + 3] = ptIdx - 2;\n    cellIdx++;\n    results.polys[cellIdx * 4] = 3;\n    results.polys[cellIdx * 4 + 1] = ptIdx - 4;\n    results.polys[cellIdx * 4 + 2] = ptIdx - 2;\n    results.polys[cellIdx * 4 + 3] = ptIdx - 1;\n    results.ptIdx += 4;\n    results.cellIdx += 2;\n  };\n\n  // update the polydata associated with drawing the text labels\n  // specifically the quads used for each label and their associated tcoords\n  // etc. This changes every time the camera viewpoint changes\n  const tmpv3 = new Float64Array(3);\n  publicAPI.updatePolyDataForLabels = () => {\n    // update the polydata\n    const numLabels = publicAPI.getTickStrings().length + model.barSegments.length;\n    const numPts = numLabels * 4;\n    const numTris = numLabels * 2;\n    const points = new Float64Array(numPts * 3);\n    const polys = new Uint16Array(numTris * 4);\n    const tcoords = new Float32Array(numPts * 2);\n    const results = {\n      ptIdx: 0,\n      cellIdx: 0,\n      polys,\n      points,\n      tcoords\n    };\n\n    // compute the direction vector\n    const offsetAxis = model.vertical ? 0 : 1;\n    const spacedAxis = model.vertical ? 1 : 0;\n    tmpv3[2] = -0.99; // near plane\n\n    // draw the title\n    const alignment = model.vertical ? ['right', 'middle'] : ['middle', 'bottom'];\n    let dir = [0, 1];\n    const tickOffsets = [0, 0];\n    if (model.vertical) {\n      tickOffsets[0] = -model.tickLabelPixelOffset;\n      if (model.topTitle) {\n        tmpv3[0] = model.boxPosition[0] + 0.5 * model.boxSize[0];\n        tmpv3[1] = model.barPosition[1] + model.barSize[1];\n\n        // write the axis label\n        publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv3, ['middle', 'bottom'], 'horizontal', [0, model.axisTitlePixelOffset], results);\n      } else {\n        tmpv3[0] = model.barPosition[0] + model.barSize[0];\n        tmpv3[1] = model.barPosition[1] + 0.5 * model.barSize[1];\n\n        // write the axis label\n        publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv3, ['middle', 'top'], 'vertical', [model.axisTitlePixelOffset, 0], results);\n      }\n      dir = [-1, 0];\n    } else {\n      tickOffsets[1] = model.tickLabelPixelOffset;\n      tmpv3[0] = model.barPosition[0] + 0.5 * model.barSize[0];\n      tmpv3[1] = model.barPosition[1] + model.barSize[1];\n      publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv3, ['middle', 'bottom'], 'horizontal', [0, model.axisTitlePixelOffset], results);\n    }\n    tmpv3[offsetAxis] = model.barPosition[offsetAxis] + (0.5 * dir[offsetAxis] + 0.5) * model.barSize[offsetAxis];\n    tmpv3[spacedAxis] = model.barPosition[spacedAxis] + model.barSize[spacedAxis] * 0.5;\n\n    // draw bar segment labels\n    let tickSeg = null;\n    for (let i = 0; i < model.barSegments.length; i++) {\n      const seg = model.barSegments[i];\n      if (seg.title === 'ticks') {\n        // handle ticks below\n        tickSeg = seg;\n      } else {\n        tmpv3[spacedAxis] = model.barPosition[spacedAxis] + 0.5 * model.barSize[spacedAxis] * (seg.corners[2][spacedAxis] + seg.corners[0][spacedAxis]);\n        publicAPI.createPolyDataForOneLabel(seg.title, tmpv3, alignment, 'horizontal', tickOffsets, results);\n      }\n    }\n\n    // write the tick labels\n    const tickSegmentStart = model.barPosition[spacedAxis] + model.barSize[spacedAxis] * tickSeg.corners[0][spacedAxis];\n    const tickSegmentSize = model.barSize[spacedAxis] * (tickSeg.corners[2][spacedAxis] - tickSeg.corners[0][spacedAxis]);\n    const ticks = publicAPI.getTicks();\n    const tickStrings = publicAPI.getTickStrings();\n    for (let t = 0; t < ticks.length; t++) {\n      const tickPos = (ticks[t] - model.lastTickBounds[0]) / (model.lastTickBounds[1] - model.lastTickBounds[0]);\n      tmpv3[spacedAxis] = tickSegmentStart + tickSegmentSize * tickPos;\n      publicAPI.createPolyDataForOneLabel(tickStrings[t], tmpv3, alignment, 'horizontal', tickOffsets, results);\n    }\n    const tcoordDA = vtkDataArray.newInstance({\n      numberOfComponents: 2,\n      values: tcoords,\n      name: 'TextureCoordinates'\n    });\n    model.tmPolyData.getPointData().setTCoords(tcoordDA);\n    model.tmPolyData.getPoints().setData(points, 3);\n    model.tmPolyData.getPoints().modified();\n    model.tmPolyData.getPolys().setData(polys, 1);\n    model.tmPolyData.getPolys().modified();\n    model.tmPolyData.modified();\n  };\n  publicAPI.updatePolyDataForBarSegments = () => {\n    const scalarsToColors = model.renderable.getScalarsToColors();\n    let numberOfExtraColors = 0;\n    if (model.renderable.getDrawNanAnnotation() && scalarsToColors.getNanColor()) {\n      numberOfExtraColors += 1;\n    }\n    if (model.renderable.getDrawBelowRangeSwatch() && scalarsToColors.getUseBelowRangeColor?.()) {\n      numberOfExtraColors += 1;\n    }\n    if (model.renderable.getDrawAboveRangeSwatch() && scalarsToColors.getUseAboveRangeColor?.()) {\n      numberOfExtraColors += 1;\n    }\n    const numPts = 4 * (1 + numberOfExtraColors);\n    const numQuads = numPts;\n\n    // handle vector component mode\n    let numComps = 1;\n    if (scalarsToColors.getVectorMode() === VectorMode.COMPONENT) {\n      numComps = scalarsToColors.getVectorComponent() + 1;\n    }\n\n    // create the colored bars\n    const points = new Float64Array(numPts * 3);\n    const cells = new Uint16Array(numQuads * 5);\n    const scalars = new Float32Array(numPts * numComps);\n    let ptIdx = 0;\n    let cellIdx = 0;\n    for (let i = 0; i < model.barSegments.length; i++) {\n      const seg = model.barSegments[i];\n      for (let e = 0; e < 4; e++) {\n        tmpv3[0] = model.barPosition[0] + seg.corners[e][0] * model.barSize[0];\n        tmpv3[1] = model.barPosition[1] + seg.corners[e][1] * model.barSize[1];\n        points[ptIdx * 3] = (0.5 * tmpv3[0] + 0.5) * model.lastSize[0];\n        points[ptIdx * 3 + 1] = (0.5 * tmpv3[1] + 0.5) * model.lastSize[1];\n        points[ptIdx * 3 + 2] = tmpv3[2];\n        for (let nc = 0; nc < numComps; nc++) {\n          scalars[ptIdx * numComps + nc] = model.lastTickBounds[0] + seg.scalars[e] * (model.lastTickBounds[1] - model.lastTickBounds[0]);\n        }\n        ptIdx++;\n      }\n      cells[cellIdx * 5] = 4;\n      cells[cellIdx * 5 + 1] = ptIdx - 4;\n      cells[cellIdx * 5 + 2] = ptIdx - 3;\n      cells[cellIdx * 5 + 3] = ptIdx - 2;\n      cells[cellIdx * 5 + 4] = ptIdx - 1;\n      cellIdx++;\n    }\n    const scalarsDA = vtkDataArray.newInstance({\n      numberOfComponents: numComps,\n      values: scalars,\n      name: 'Scalars'\n    });\n    model.polyData.getPointData().setScalars(scalarsDA);\n    model.polyData.getPoints().setData(points, 3);\n    model.polyData.getPoints().modified();\n    model.polyData.getPolys().setData(cells, 1);\n    model.polyData.getPolys().modified();\n    model.polyData.modified();\n  };\n}\nconst newScalarBarActorHelper = macro.newInstance(function (publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    renderable: null\n  };\n  Object.assign(model, {}, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['axisTitlePixelOffset', 'tickLabelPixelOffset', 'renderable', 'topTitle', 'ticks', 'tickStrings']);\n  macro.get(publicAPI, model, ['lastSize', 'lastAspectRatio', 'lastTickBounds', 'axisTextStyle', 'tickTextStyle', 'barActor', 'tmActor']);\n  macro.getArray(publicAPI, model, ['boxPosition', 'boxSize']);\n  macro.setArray(publicAPI, model, ['boxPosition', 'boxSize'], 2);\n  model.forceUpdate = false;\n  model.lastRebuildTime = {};\n  macro.obj(model.lastRebuildTime, {\n    mtime: 0\n  });\n  model.lastSize = [-1, -1];\n  model.tmCanvas = document.createElement('canvas');\n  model.tmContext = model.tmCanvas.getContext('2d');\n  model._tmAtlas = new Map();\n  model.barMapper = vtkMapper.newInstance();\n  model.barMapper.setInterpolateScalarsBeforeMapping(true);\n  model.barMapper.setUseLookupTableScalarRange(true);\n  model.polyData = vtkPolyData.newInstance();\n  model.barMapper.setInputData(model.polyData);\n  model.barActor = vtkActor.newInstance();\n  model.barActor.setMapper(model.barMapper);\n\n  // for texture atlas\n  model.tmPolyData = vtkPolyData.newInstance();\n  model.tmMapper = vtkMapper.newInstance();\n  model.tmMapper.setInputData(model.tmPolyData);\n  model.tmTexture = vtkTexture.newInstance({\n    resizable: true\n  });\n  model.tmTexture.setInterpolate(false);\n  model.tmActor = vtkActor.newInstance({\n    parentProp: publicAPI\n  });\n  model.tmActor.setMapper(model.tmMapper);\n  model.tmActor.addTexture(model.tmTexture);\n  model.barPosition = [0, 0];\n  model.barSize = [0, 0];\n  model.boxPosition = [0.88, -0.92];\n  model.boxSize = [0.1, 1.1];\n\n  // internal variables\n  model.lastTickBounds = [];\n  vtkScalarBarActorHelper(publicAPI, model);\n}, 'vtkScalarBarActorHelper');\n\n//\n// Now we define the public class that the application sets view independent\n// properties on. This class is fairly small as it mainly just holds\n// properties setter and getters leaving all calculations to the helper\n// class.\n//\nfunction vtkScalarBarActor(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkScalarBarActor');\n  publicAPI.setTickTextStyle = tickStyle => {\n    model.tickTextStyle = {\n      ...model.tickTextStyle,\n      ...tickStyle\n    };\n    publicAPI.modified();\n  };\n  publicAPI.setAxisTextStyle = axisStyle => {\n    model.axisTextStyle = {\n      ...model.axisTextStyle,\n      ...axisStyle\n    };\n    publicAPI.modified();\n  };\n  publicAPI.resetAutoLayoutToDefault = () => {\n    publicAPI.setAutoLayout(defaultAutoLayout(publicAPI, model));\n  };\n  publicAPI.resetGenerateTicksToDefault = () => {\n    publicAPI.setGenerateTicks(defaultGenerateTicks());\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(initialValues) {\n  return {\n    automated: true,\n    autoLayout: null,\n    axisLabel: 'Scalar Value',\n    barPosition: [0, 0],\n    barSize: [0, 0],\n    boxPosition: [0.88, -0.92],\n    boxSize: [0.1, 1.1],\n    scalarToColors: null,\n    axisTitlePixelOffset: 36.0,\n    axisTextStyle: {\n      fontColor: 'white',\n      fontStyle: 'normal',\n      fontSize: 18,\n      fontFamily: 'serif'\n    },\n    tickLabelPixelOffset: 14.0,\n    tickTextStyle: {\n      fontColor: 'white',\n      fontStyle: 'normal',\n      fontSize: 14,\n      fontFamily: 'serif'\n    },\n    generateTicks: null,\n    drawNanAnnotation: true,\n    drawBelowRangeSwatch: true,\n    drawAboveRangeSwatch: true,\n    ...initialValues\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, defaultValues(initialValues));\n  if (!model.autoLayout) model.autoLayout = defaultAutoLayout(publicAPI, model);\n  if (!model.generateTicks) model.generateTicks = defaultGenerateTicks();\n\n  // Inheritance\n  vtkActor.extend(publicAPI, model, initialValues);\n  publicAPI.getProperty().setDiffuse(0.0);\n  publicAPI.getProperty().setAmbient(1.0);\n  macro.setGet(publicAPI, model, ['automated', 'autoLayout', 'axisTitlePixelOffset', 'axisLabel', 'scalarsToColors', 'tickLabelPixelOffset', 'generateTicks', 'drawNanAnnotation', 'drawBelowRangeSwatch', 'drawAboveRangeSwatch']);\n  macro.get(publicAPI, model, ['axisTextStyle', 'tickTextStyle']);\n  macro.getArray(publicAPI, model, ['barPosition', 'barSize', 'boxPosition', 'boxSize']);\n  macro.setArray(publicAPI, model, ['barPosition', 'barSize', 'boxPosition', 'boxSize'], 2);\n\n  // Object methods\n  vtkScalarBarActor(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkScalarBarActor');\n\n// ----------------------------------------------------------------------------\n\nvar vtkScalarBarActor$1 = {\n  newInstance,\n  extend,\n  newScalarBarActorHelper\n};\nexport { vtkScalarBarActor$1 as default, extend, newInstance };","map":{"version":3,"names":["d3","O","nearestPowerOfTwo","m","macro","vtkActor","vtkDataArray","vtkScalarsToColors","vtkMapper","vtkPolyData","vtkTexture","VectorMode","applyTextStyle","ctx","style","strokeStyle","strokeColor","lineWidth","strokeSize","fillStyle","fontColor","font","fontStyle","fontSize","fontFamily","defaultAutoLayout","publicAPI","model","helper","lastSize","getLastSize","xAxisAdjust","yAxisAdjust","minAdjust","Math","min","axisTextStyle","getAxisTextStyle","tickTextStyle","getTickTextStyle","Object","assign","max","getLastAspectRatio","textSizes","updateTextureAtlas","setTopTitle","boxSize","getBoxSizeByReference","setTickLabelPixelOffset","titleWidth","tickWidth","getTickLabelPixelOffset","setAxisTitlePixelOffset","setBoxPosition","titleHeight","getAxisTitlePixelOffset","getTicks","length","recomputeBarSegments","defaultGenerateTicks","publicApi","lastTickBounds","getLastTickBounds","scale","scaleLinear","domain","ticks","format","tickFormat","setTicks","setTickStrings","map","vtkScalarBarActorHelper","classHierarchy","push","setRenderable","renderable","barActor","setProperty","getProperty","setParentProp","setCoordinateSystemToDisplay","tmActor","generateTicks","modified","updateAPISpecificData","size","camera","renderWindow","lastAspectRatio","forceUpdate","scalarsToColors","getScalarsToColors","getVisibility","barMapper","setLookupTable","getMTime","lastRebuildTime","range","getMappingRange","getGenerateTicks","getAutomated","getAutoLayout","barPosition","getBarPosition","barSize","getBarSize","boxPosition","getBoxPosition","getBoxSize","axisTitlePixelOffset","tickLabelPixelOffset","updatePolyDataForLabels","updatePolyDataForBarSegments","tmContext","textBaseline","textAlign","results","newTmAtlas","Map","maxWidth","totalHeight","metrics","measureText","getAxisLabel","entry","height","actualBoundingBoxAscent","startingHeight","width","textStyle","set","tickHeight","strings","getTickStrings","t","has","forEach","value","tcoords","tmCanvas","clearRect","key","fillText","tmTexture","setCanvas","_tmAtlas","computeBarSize","vertical","segSize","topTitle","barSegments","startPos","barAxis","segSpace","pushSeg","title","scalars","corners","getDrawNanAnnotation","getNanColor","NaN","getDrawBelowRangeSwatch","getUseBelowRangeColor","haveAbove","getUseAboveRangeColor","oldSegSize","getDrawAboveRangeSwatch","tmp2v3","Float64Array","createPolyDataForOneLabel","text","pos","alignment","orientation","offset","get","ptIdx","cellIdx","textSize","textAxes","points","polys","tmpv3","numLabels","numPts","numTris","Uint16Array","Float32Array","offsetAxis","spacedAxis","dir","tickOffsets","tickSeg","i","seg","tickSegmentStart","tickSegmentSize","tickStrings","tickPos","tcoordDA","newInstance","numberOfComponents","values","name","tmPolyData","getPointData","setTCoords","getPoints","setData","getPolys","numberOfExtraColors","numQuads","numComps","getVectorMode","COMPONENT","getVectorComponent","cells","e","nc","scalarsDA","polyData","setScalars","newScalarBarActorHelper","initialValues","arguments","undefined","obj","setGet","getArray","setArray","mtime","document","createElement","getContext","setInterpolateScalarsBeforeMapping","setUseLookupTableScalarRange","setInputData","setMapper","tmMapper","resizable","setInterpolate","parentProp","addTexture","vtkScalarBarActor","setTickTextStyle","tickStyle","setAxisTextStyle","axisStyle","resetAutoLayoutToDefault","setAutoLayout","resetGenerateTicksToDefault","setGenerateTicks","defaultValues","automated","autoLayout","axisLabel","scalarToColors","drawNanAnnotation","drawBelowRangeSwatch","drawAboveRangeSwatch","extend","setDiffuse","setAmbient","vtkScalarBarActor$1","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/Core/ScalarBarActor.js"],"sourcesContent":["import * as d3 from 'd3-scale';\nimport { O as nearestPowerOfTwo } from '../../Common/Core/Math/index.js';\nimport { m as macro } from '../../macros2.js';\nimport vtkActor from './Actor.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors.js';\nimport vtkMapper from './Mapper.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkTexture from './Texture.js';\n\nconst {\n  VectorMode\n} = vtkScalarsToColors;\n\n// ----------------------------------------------------------------------------\n// vtkScalarBarActor\n//\n// Note log scales are currently not supported\n//\n// Developer note: This class is broken into the main class and a helper\n// class. The main class holds view independent properties (those properties\n// that do not change as the view's resolution/aspect ratio change). The\n// helper class is instantiated one per view and holds properties that can\n// depend on view specific values such as resolution. The helper class code\n// could have been left to the View specific implementation (such as\n// vtkWebGPUScalarBarActor) but is instead placed here to it can be shared by\n// multiple rendering backends.\n//\n// ----------------------------------------------------------------------------\n\nfunction applyTextStyle(ctx, style) {\n  ctx.strokeStyle = style.strokeColor;\n  ctx.lineWidth = style.strokeSize;\n  ctx.fillStyle = style.fontColor;\n  ctx.font = `${style.fontStyle} ${style.fontSize}px ${style.fontFamily}`;\n}\n\n// ----------------------------------------------------------------------------\n// Default autoLayout function\n// ----------------------------------------------------------------------------\n\n// compute good values to use based on window size etc a bunch of heuristics\n// here with hand tuned constants These values worked for me but really this\n// method could be redically changed. The basic gist is\n// 1) compute a resonable font size\n// 2) render the text atlas using those font sizes\n// 3) pick horizontal or vertical bsed on window size\n// 4) based on the size of the title and tick labels rendered\n//    compute the box size and position such that\n//    the text will all fit nicely and the bar will be a resonable size\n// 5) compute the bar segments based on the above settings\n//\n// Note that this function can and should read values from the\n// ScalarBarActor but should only write values to the view dependent helper\n// instance that is provided as those values are the ones that will be used\n// for rendering.\n//\nfunction defaultAutoLayout(publicAPI, model) {\n  return helper => {\n    // we don't do a linear scale, the proportions for\n    // a 700 pixel window differ from a 1400\n    const lastSize = helper.getLastSize();\n    const xAxisAdjust = (lastSize[0] / 700) ** 0.8;\n    const yAxisAdjust = (lastSize[1] / 700) ** 0.8;\n    const minAdjust = Math.min(xAxisAdjust, yAxisAdjust);\n    const axisTextStyle = helper.getAxisTextStyle();\n    const tickTextStyle = helper.getTickTextStyle();\n    Object.assign(axisTextStyle, model.axisTextStyle);\n    Object.assign(tickTextStyle, model.tickTextStyle);\n\n    // compute a reasonable font size first\n    axisTextStyle.fontSize = Math.max(24 * minAdjust, 12);\n    if (helper.getLastAspectRatio() > 1.0) {\n      tickTextStyle.fontSize = Math.max(20 * minAdjust, 10);\n    } else {\n      tickTextStyle.fontSize = Math.max(16 * minAdjust, 10);\n    }\n\n    // rebuild the text atlas\n    const textSizes = helper.updateTextureAtlas();\n\n    // now compute the boxSize and pixel offsets, different algorithm\n    // for horizonal versus vertical\n    helper.setTopTitle(false);\n    const boxSize = helper.getBoxSizeByReference();\n\n    // if vertical\n    if (helper.getLastAspectRatio() > 1.0) {\n      helper.setTickLabelPixelOffset(0.3 * tickTextStyle.fontSize);\n\n      // if the title will fit within the width of the bar then that looks\n      // nicer to put it at the top (helper.topTitle), otherwise rotate it\n      // and place it sideways\n      if (textSizes.titleWidth <= textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) {\n        helper.setTopTitle(true);\n        helper.setAxisTitlePixelOffset(0.2 * tickTextStyle.fontSize);\n        boxSize[0] = 2.0 * (textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) / lastSize[0];\n        helper.setBoxPosition([0.98 - boxSize[0], -0.92]);\n      } else {\n        helper.setAxisTitlePixelOffset(0.2 * tickTextStyle.fontSize);\n        boxSize[0] = 2.0 * (textSizes.titleHeight + helper.getAxisTitlePixelOffset() + textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) / lastSize[0];\n        helper.setBoxPosition([0.99 - boxSize[0], -0.92]);\n      }\n      boxSize[1] = Math.max(1.2, Math.min(1.84 / yAxisAdjust, 1.84));\n    } else {\n      // horizontal\n      helper.setAxisTitlePixelOffset(1.2 * tickTextStyle.fontSize);\n      helper.setTickLabelPixelOffset(0.1 * tickTextStyle.fontSize);\n      const titleHeight =\n      // total offset from top of bar (includes ticks)\n      2.0 * (0.8 * tickTextStyle.fontSize + textSizes.titleHeight + helper.getAxisTitlePixelOffset()) / lastSize[1];\n      const tickWidth = 2.0 * textSizes.tickWidth / lastSize[0];\n      boxSize[0] = Math.min(1.9, Math.max(1.4, 1.4 * tickWidth * (helper.getTicks().length + 3)));\n      boxSize[1] = titleHeight;\n      helper.setBoxPosition([-0.5 * boxSize[0], -0.97]);\n    }\n\n    // recomute bar segments based on positioning\n    helper.recomputeBarSegments(textSizes);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Default generateTicks function\n// ----------------------------------------------------------------------------\n\n// This function returns the default function used to generate vtkScalarBarActor ticks.\n// The default function makes use of d3.scaleLinear() to generate 5 tick marks between\n// the minimum and maximum values of the scalar bar. Customize this behavior by passing\n// a function to vtkScalarBarActor.newInstance({ generateTicks: customGenerateTicks })\n// or by calling scalarBarActor.setGenerateTicks(customGenerateTicks).\nfunction defaultGenerateTicks(publicApi, model) {\n  return helper => {\n    const lastTickBounds = helper.getLastTickBounds();\n    const scale = d3.scaleLinear().domain([lastTickBounds[0], lastTickBounds[1]]);\n    const ticks = scale.ticks(5);\n    const format = scale.tickFormat(5);\n    helper.setTicks(ticks);\n    helper.setTickStrings(ticks.map(format));\n  };\n}\n\n// many properties of this actor depend on the API specific view The main\n// dependency being the resolution as that drives what font sizes to use.\n// Bacause of this we need to do some of the calculations in a API specific\n// subclass. But... we don't want a lot of duplicated code between WebGL and\n// WebGPU for example so we have this helper class, that is designed to be\n// fairly API independent so that API specific views can call this to do\n// most of the work.\nfunction vtkScalarBarActorHelper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkScalarBarActorHelper');\n  publicAPI.setRenderable = renderable => {\n    if (model.renderable === renderable) {\n      return;\n    }\n    model.renderable = renderable;\n    model.barActor.setProperty(renderable.getProperty());\n    model.barActor.setParentProp(renderable);\n    model.barActor.setCoordinateSystemToDisplay();\n    model.tmActor.setProperty(renderable.getProperty());\n    model.tmActor.setParentProp(renderable);\n    model.tmActor.setCoordinateSystemToDisplay();\n    model.generateTicks = renderable.generateTicks;\n    model.axisTextStyle = {\n      ...renderable.getAxisTextStyle()\n    };\n    model.tickTextStyle = {\n      ...renderable.getTickTextStyle()\n    };\n    publicAPI.modified();\n  };\n  publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {\n    // has the size changed?\n    if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {\n      model.lastSize[0] = size[0];\n      model.lastSize[1] = size[1];\n      model.lastAspectRatio = size[0] / size[1];\n      model.forceUpdate = true;\n    }\n    const scalarsToColors = model.renderable.getScalarsToColors();\n    if (!scalarsToColors || !model.renderable.getVisibility()) {\n      return;\n    }\n\n    // make sure the lut is assigned to our mapper\n    model.barMapper.setLookupTable(scalarsToColors);\n\n    // camera should be the same for all views\n    model.camera = camera;\n    model.renderWindow = renderWindow;\n\n    // did something significant change? If so rebuild a lot of things\n    if (model.forceUpdate || Math.max(scalarsToColors.getMTime(), publicAPI.getMTime(), model.renderable.getMTime()) > model.lastRebuildTime.getMTime()) {\n      const range = scalarsToColors.getMappingRange();\n      model.lastTickBounds = [...range];\n\n      // compute tick marks for axes (update for log scale)\n      model.renderable.getGenerateTicks()(publicAPI);\n      if (model.renderable.getAutomated()) {\n        model.renderable.getAutoLayout()(publicAPI);\n      } else {\n        // copy values from renderable\n        model.axisTextStyle = {\n          ...model.renderable.getAxisTextStyle()\n        };\n        model.tickTextStyle = {\n          ...model.renderable.getTickTextStyle()\n        };\n        model.barPosition = [...model.renderable.getBarPosition()];\n        model.barSize = [...model.renderable.getBarSize()];\n        model.boxPosition = [...model.renderable.getBoxPosition()];\n        model.boxSize = [...model.renderable.getBoxSize()];\n        model.axisTitlePixelOffset = model.renderable.getAxisTitlePixelOffset();\n        model.tickLabelPixelOffset = model.renderable.getTickLabelPixelOffset();\n\n        // rebuild the texture only when force or changed bounds, face\n        // visibility changes do to change the atlas\n        const textSizes = publicAPI.updateTextureAtlas();\n\n        // recompute bar segments based on positioning\n        publicAPI.recomputeBarSegments(textSizes);\n      }\n      publicAPI.updatePolyDataForLabels();\n      publicAPI.updatePolyDataForBarSegments();\n      model.lastRebuildTime.modified();\n      model.forceUpdate = false;\n    }\n  };\n\n  // create the texture map atlas that contains the rendering of\n  // all the text strings. Only needs to be called when the text strings\n  // have changed (labels and ticks)\n  publicAPI.updateTextureAtlas = () => {\n    // set the text properties\n    model.tmContext.textBaseline = 'bottom';\n    model.tmContext.textAlign = 'left';\n\n    // return some factors about the text atlas\n    const results = {};\n\n    // first the axislabel\n    const newTmAtlas = new Map();\n    let maxWidth = 0;\n    let totalHeight = 1; // start one pixel in so we have a border\n    applyTextStyle(model.tmContext, model.axisTextStyle);\n    let metrics = model.tmContext.measureText(model.renderable.getAxisLabel());\n    let entry = {\n      height: metrics.actualBoundingBoxAscent + 2,\n      startingHeight: totalHeight,\n      width: metrics.width + 2,\n      textStyle: model.axisTextStyle\n    };\n    newTmAtlas.set(model.renderable.getAxisLabel(), entry);\n    totalHeight += entry.height;\n    maxWidth = entry.width;\n    results.titleWidth = entry.width;\n    results.titleHeight = entry.height;\n\n    // and the ticks, NaN Below and Above\n    results.tickWidth = 0;\n    results.tickHeight = 0;\n    applyTextStyle(model.tmContext, model.tickTextStyle);\n    const strings = [...publicAPI.getTickStrings(), 'NaN', 'Below', 'Above'];\n    for (let t = 0; t < strings.length; t++) {\n      if (!newTmAtlas.has(strings[t])) {\n        metrics = model.tmContext.measureText(strings[t]);\n        entry = {\n          height: metrics.actualBoundingBoxAscent + 2,\n          startingHeight: totalHeight,\n          width: metrics.width + 2,\n          textStyle: model.tickTextStyle\n        };\n        newTmAtlas.set(strings[t], entry);\n        totalHeight += entry.height;\n        if (maxWidth < entry.width) {\n          maxWidth = entry.width;\n        }\n        if (results.tickWidth < entry.width) {\n          results.tickWidth = entry.width;\n        }\n        if (results.tickHeight < entry.height) {\n          results.tickHeight = entry.height;\n        }\n      }\n    }\n\n    // always use power of two to avoid interpolation\n    // in cases where PO2 is required\n    maxWidth = nearestPowerOfTwo(maxWidth);\n    totalHeight = nearestPowerOfTwo(totalHeight);\n\n    // set the tcoord values\n    newTmAtlas.forEach(value => {\n      value.tcoords = [0.0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0.0, (totalHeight - value.startingHeight) / totalHeight];\n    });\n\n    // make sure we have power of two dimensions\n    model.tmCanvas.width = maxWidth;\n    model.tmCanvas.height = totalHeight;\n    model.tmContext.textBaseline = 'bottom';\n    model.tmContext.textAlign = 'left';\n    model.tmContext.clearRect(0, 0, maxWidth, totalHeight);\n\n    // draw the text onto the texture\n    newTmAtlas.forEach((value, key) => {\n      applyTextStyle(model.tmContext, value.textStyle);\n      model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);\n    });\n    model.tmTexture.setCanvas(model.tmCanvas);\n    // mark as modified since the canvas typically doesn't change\n    model.tmTexture.modified();\n    model._tmAtlas = newTmAtlas;\n    return results;\n  };\n  publicAPI.computeBarSize = textSizes => {\n    // compute orientation\n    model.vertical = model.boxSize[1] > model.boxSize[0];\n    const tickHeight = 2.0 * textSizes.tickHeight / model.lastSize[1];\n    const segSize = [1, 1];\n\n    // horizontal and vertical have different astetics so adjust based on\n    // orientation\n    if (model.vertical) {\n      const tickWidth = 2.0 * (textSizes.tickWidth + model.tickLabelPixelOffset) / model.lastSize[0];\n      if (model.topTitle) {\n        const titleHeight = 2.0 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[1];\n        model.barSize[0] = model.boxSize[0] - tickWidth;\n        model.barSize[1] = model.boxSize[1] - titleHeight;\n      } else {\n        // rotated title so width is based off height\n        const titleWidth = 2.0 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[0];\n        model.barSize[0] = model.boxSize[0] - titleWidth - tickWidth;\n        model.barSize[1] = model.boxSize[1];\n      }\n      model.barPosition[0] = model.boxPosition[0] + tickWidth;\n      model.barPosition[1] = model.boxPosition[1];\n      segSize[1] = tickHeight;\n    } else {\n      const tickWidth = (2.0 * textSizes.tickWidth - 8) / model.lastSize[0];\n      const titleHeight = 2.0 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[1];\n      model.barSize[0] = model.boxSize[0];\n      model.barPosition[0] = model.boxPosition[0];\n      model.barSize[1] = model.boxSize[1] - titleHeight;\n      model.barPosition[1] = model.boxPosition[1];\n      segSize[0] = tickWidth;\n    }\n    return segSize;\n  };\n\n  // based on all the settins compute a barSegments array\n  // containing the segments of the scalar bar\n  // each segment contains\n  //   corners[4][2]\n  //   title - e.g. NaN, Above, ticks\n  //   scalars - the normalized scalars values to use for that segment\n  //\n  // Note that the bar consumes the space in the box that remains after\n  // leaving room for the text labels\n  publicAPI.recomputeBarSegments = textSizes => {\n    // first compute the barSize/Position\n    const segSize = publicAPI.computeBarSize(textSizes);\n    model.barSegments = [];\n    const startPos = [0.0, 0.0];\n\n    // horizontal and vertical have different astetics so adjust based on\n    // orientation\n    const barAxis = model.vertical ? 1 : 0;\n    const segSpace = model.vertical ? 0.01 : 0.02;\n    function pushSeg(title, scalars) {\n      model.barSegments.push({\n        corners: [[...startPos], [startPos[0] + segSize[0], startPos[1]], [startPos[0] + segSize[0], startPos[1] + segSize[1]], [startPos[0], startPos[1] + segSize[1]]],\n        scalars,\n        title\n      });\n      startPos[barAxis] += segSize[barAxis] + segSpace;\n    }\n    if (model.renderable.getDrawNanAnnotation() && model.renderable.getScalarsToColors().getNanColor()) {\n      pushSeg('NaN', [NaN, NaN, NaN, NaN]);\n    }\n    if (model.renderable.getDrawBelowRangeSwatch() && model.renderable.getScalarsToColors().getUseBelowRangeColor?.()) {\n      pushSeg('Below', [-0.1, -0.1, -0.1, -0.1]);\n    }\n    const haveAbove = model.renderable.getScalarsToColors().getUseAboveRangeColor?.();\n\n    // extra space around the ticks section\n    startPos[barAxis] += segSpace;\n    const oldSegSize = segSize[barAxis];\n    segSize[barAxis] = haveAbove ? 1.0 - 2.0 * segSpace - segSize[barAxis] - startPos[barAxis] : 1.0 - segSpace - startPos[barAxis];\n    pushSeg('ticks', model.vertical ? [0, 0, 0.995, 0.995] : [0, 0.995, 0.995, 0]);\n    if (model.renderable.getDrawAboveRangeSwatch() && haveAbove) {\n      segSize[barAxis] = oldSegSize;\n      startPos[barAxis] += segSpace;\n      pushSeg('Above', [1.1, 1.1, 1.1, 1.1]);\n    }\n  };\n\n  // called by updatePolyDataForLabels\n  // modifies class constants tmp2v3\n  const tmp2v3 = new Float64Array(3);\n\n  // anchor point = pos\n  // H alignment = left, middle, right\n  // V alignment = bottom, middle, top\n  // Text Orientation = horizontal, vertical\n  // orientation\n  publicAPI.createPolyDataForOneLabel = (text, pos, alignment, orientation, offset, results) => {\n    const value = model._tmAtlas.get(text);\n    if (!value) {\n      return;\n    }\n    // have to find the four corners of the texture polygon for this label\n    let ptIdx = results.ptIdx;\n    let cellIdx = results.cellIdx;\n\n    // get achor point in pixels\n    tmp2v3[0] = (0.5 * pos[0] + 0.5) * model.lastSize[0];\n    tmp2v3[1] = (0.5 * pos[1] + 0.5) * model.lastSize[1];\n    tmp2v3[2] = pos[2];\n    tmp2v3[0] += offset[0];\n    tmp2v3[1] += offset[1];\n\n    // get text size in display pixels\n    const textSize = [];\n    const textAxes = orientation === 'vertical' ? [1, 0] : [0, 1];\n    if (orientation === 'vertical') {\n      textSize[0] = value.width;\n      textSize[1] = -value.height;\n      // update anchor point based on alignment\n      if (alignment[0] === 'middle') {\n        tmp2v3[1] -= value.width / 2.0;\n      } else if (alignment[0] === 'right') {\n        tmp2v3[1] -= value.width;\n      }\n      if (alignment[1] === 'middle') {\n        tmp2v3[0] += value.height / 2.0;\n      } else if (alignment[1] === 'top') {\n        tmp2v3[0] += value.height;\n      }\n    } else {\n      textSize[0] = value.width;\n      textSize[1] = value.height;\n      // update anchor point based on alignment\n      if (alignment[0] === 'middle') {\n        tmp2v3[0] -= value.width / 2.0;\n      } else if (alignment[0] === 'right') {\n        tmp2v3[0] -= value.width;\n      }\n      if (alignment[1] === 'middle') {\n        tmp2v3[1] -= value.height / 2.0;\n      } else if (alignment[1] === 'top') {\n        tmp2v3[1] -= value.height;\n      }\n    }\n    results.points[ptIdx * 3] = tmp2v3[0];\n    results.points[ptIdx * 3 + 1] = tmp2v3[1];\n    results.points[ptIdx * 3 + 2] = tmp2v3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[0];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];\n    ptIdx++;\n    tmp2v3[textAxes[0]] += textSize[0];\n    results.points[ptIdx * 3] = tmp2v3[0];\n    results.points[ptIdx * 3 + 1] = tmp2v3[1];\n    results.points[ptIdx * 3 + 2] = tmp2v3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[2];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];\n    ptIdx++;\n    tmp2v3[textAxes[1]] += textSize[1];\n    results.points[ptIdx * 3] = tmp2v3[0];\n    results.points[ptIdx * 3 + 1] = tmp2v3[1];\n    results.points[ptIdx * 3 + 2] = tmp2v3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[4];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];\n    ptIdx++;\n    tmp2v3[textAxes[0]] -= textSize[0];\n    results.points[ptIdx * 3] = tmp2v3[0];\n    results.points[ptIdx * 3 + 1] = tmp2v3[1];\n    results.points[ptIdx * 3 + 2] = tmp2v3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[6];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];\n    ptIdx++;\n\n    // add the two triangles to represent the quad\n    results.polys[cellIdx * 4] = 3;\n    results.polys[cellIdx * 4 + 1] = ptIdx - 4;\n    results.polys[cellIdx * 4 + 2] = ptIdx - 3;\n    results.polys[cellIdx * 4 + 3] = ptIdx - 2;\n    cellIdx++;\n    results.polys[cellIdx * 4] = 3;\n    results.polys[cellIdx * 4 + 1] = ptIdx - 4;\n    results.polys[cellIdx * 4 + 2] = ptIdx - 2;\n    results.polys[cellIdx * 4 + 3] = ptIdx - 1;\n    results.ptIdx += 4;\n    results.cellIdx += 2;\n  };\n\n  // update the polydata associated with drawing the text labels\n  // specifically the quads used for each label and their associated tcoords\n  // etc. This changes every time the camera viewpoint changes\n  const tmpv3 = new Float64Array(3);\n  publicAPI.updatePolyDataForLabels = () => {\n    // update the polydata\n    const numLabels = publicAPI.getTickStrings().length + model.barSegments.length;\n    const numPts = numLabels * 4;\n    const numTris = numLabels * 2;\n    const points = new Float64Array(numPts * 3);\n    const polys = new Uint16Array(numTris * 4);\n    const tcoords = new Float32Array(numPts * 2);\n    const results = {\n      ptIdx: 0,\n      cellIdx: 0,\n      polys,\n      points,\n      tcoords\n    };\n\n    // compute the direction vector\n    const offsetAxis = model.vertical ? 0 : 1;\n    const spacedAxis = model.vertical ? 1 : 0;\n    tmpv3[2] = -0.99; // near plane\n\n    // draw the title\n    const alignment = model.vertical ? ['right', 'middle'] : ['middle', 'bottom'];\n    let dir = [0, 1];\n    const tickOffsets = [0, 0];\n    if (model.vertical) {\n      tickOffsets[0] = -model.tickLabelPixelOffset;\n      if (model.topTitle) {\n        tmpv3[0] = model.boxPosition[0] + 0.5 * model.boxSize[0];\n        tmpv3[1] = model.barPosition[1] + model.barSize[1];\n\n        // write the axis label\n        publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv3, ['middle', 'bottom'], 'horizontal', [0, model.axisTitlePixelOffset], results);\n      } else {\n        tmpv3[0] = model.barPosition[0] + model.barSize[0];\n        tmpv3[1] = model.barPosition[1] + 0.5 * model.barSize[1];\n\n        // write the axis label\n        publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv3, ['middle', 'top'], 'vertical', [model.axisTitlePixelOffset, 0], results);\n      }\n      dir = [-1, 0];\n    } else {\n      tickOffsets[1] = model.tickLabelPixelOffset;\n      tmpv3[0] = model.barPosition[0] + 0.5 * model.barSize[0];\n      tmpv3[1] = model.barPosition[1] + model.barSize[1];\n      publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv3, ['middle', 'bottom'], 'horizontal', [0, model.axisTitlePixelOffset], results);\n    }\n    tmpv3[offsetAxis] = model.barPosition[offsetAxis] + (0.5 * dir[offsetAxis] + 0.5) * model.barSize[offsetAxis];\n    tmpv3[spacedAxis] = model.barPosition[spacedAxis] + model.barSize[spacedAxis] * 0.5;\n\n    // draw bar segment labels\n    let tickSeg = null;\n    for (let i = 0; i < model.barSegments.length; i++) {\n      const seg = model.barSegments[i];\n      if (seg.title === 'ticks') {\n        // handle ticks below\n        tickSeg = seg;\n      } else {\n        tmpv3[spacedAxis] = model.barPosition[spacedAxis] + 0.5 * model.barSize[spacedAxis] * (seg.corners[2][spacedAxis] + seg.corners[0][spacedAxis]);\n        publicAPI.createPolyDataForOneLabel(seg.title, tmpv3, alignment, 'horizontal', tickOffsets, results);\n      }\n    }\n\n    // write the tick labels\n    const tickSegmentStart = model.barPosition[spacedAxis] + model.barSize[spacedAxis] * tickSeg.corners[0][spacedAxis];\n    const tickSegmentSize = model.barSize[spacedAxis] * (tickSeg.corners[2][spacedAxis] - tickSeg.corners[0][spacedAxis]);\n    const ticks = publicAPI.getTicks();\n    const tickStrings = publicAPI.getTickStrings();\n    for (let t = 0; t < ticks.length; t++) {\n      const tickPos = (ticks[t] - model.lastTickBounds[0]) / (model.lastTickBounds[1] - model.lastTickBounds[0]);\n      tmpv3[spacedAxis] = tickSegmentStart + tickSegmentSize * tickPos;\n      publicAPI.createPolyDataForOneLabel(tickStrings[t], tmpv3, alignment, 'horizontal', tickOffsets, results);\n    }\n    const tcoordDA = vtkDataArray.newInstance({\n      numberOfComponents: 2,\n      values: tcoords,\n      name: 'TextureCoordinates'\n    });\n    model.tmPolyData.getPointData().setTCoords(tcoordDA);\n    model.tmPolyData.getPoints().setData(points, 3);\n    model.tmPolyData.getPoints().modified();\n    model.tmPolyData.getPolys().setData(polys, 1);\n    model.tmPolyData.getPolys().modified();\n    model.tmPolyData.modified();\n  };\n  publicAPI.updatePolyDataForBarSegments = () => {\n    const scalarsToColors = model.renderable.getScalarsToColors();\n    let numberOfExtraColors = 0;\n    if (model.renderable.getDrawNanAnnotation() && scalarsToColors.getNanColor()) {\n      numberOfExtraColors += 1;\n    }\n    if (model.renderable.getDrawBelowRangeSwatch() && scalarsToColors.getUseBelowRangeColor?.()) {\n      numberOfExtraColors += 1;\n    }\n    if (model.renderable.getDrawAboveRangeSwatch() && scalarsToColors.getUseAboveRangeColor?.()) {\n      numberOfExtraColors += 1;\n    }\n    const numPts = 4 * (1 + numberOfExtraColors);\n    const numQuads = numPts;\n\n    // handle vector component mode\n    let numComps = 1;\n    if (scalarsToColors.getVectorMode() === VectorMode.COMPONENT) {\n      numComps = scalarsToColors.getVectorComponent() + 1;\n    }\n\n    // create the colored bars\n    const points = new Float64Array(numPts * 3);\n    const cells = new Uint16Array(numQuads * 5);\n    const scalars = new Float32Array(numPts * numComps);\n    let ptIdx = 0;\n    let cellIdx = 0;\n    for (let i = 0; i < model.barSegments.length; i++) {\n      const seg = model.barSegments[i];\n      for (let e = 0; e < 4; e++) {\n        tmpv3[0] = model.barPosition[0] + seg.corners[e][0] * model.barSize[0];\n        tmpv3[1] = model.barPosition[1] + seg.corners[e][1] * model.barSize[1];\n        points[ptIdx * 3] = (0.5 * tmpv3[0] + 0.5) * model.lastSize[0];\n        points[ptIdx * 3 + 1] = (0.5 * tmpv3[1] + 0.5) * model.lastSize[1];\n        points[ptIdx * 3 + 2] = tmpv3[2];\n        for (let nc = 0; nc < numComps; nc++) {\n          scalars[ptIdx * numComps + nc] = model.lastTickBounds[0] + seg.scalars[e] * (model.lastTickBounds[1] - model.lastTickBounds[0]);\n        }\n        ptIdx++;\n      }\n      cells[cellIdx * 5] = 4;\n      cells[cellIdx * 5 + 1] = ptIdx - 4;\n      cells[cellIdx * 5 + 2] = ptIdx - 3;\n      cells[cellIdx * 5 + 3] = ptIdx - 2;\n      cells[cellIdx * 5 + 4] = ptIdx - 1;\n      cellIdx++;\n    }\n    const scalarsDA = vtkDataArray.newInstance({\n      numberOfComponents: numComps,\n      values: scalars,\n      name: 'Scalars'\n    });\n    model.polyData.getPointData().setScalars(scalarsDA);\n    model.polyData.getPoints().setData(points, 3);\n    model.polyData.getPoints().modified();\n    model.polyData.getPolys().setData(cells, 1);\n    model.polyData.getPolys().modified();\n    model.polyData.modified();\n  };\n}\nconst newScalarBarActorHelper = macro.newInstance(function (publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    renderable: null\n  };\n  Object.assign(model, {}, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['axisTitlePixelOffset', 'tickLabelPixelOffset', 'renderable', 'topTitle', 'ticks', 'tickStrings']);\n  macro.get(publicAPI, model, ['lastSize', 'lastAspectRatio', 'lastTickBounds', 'axisTextStyle', 'tickTextStyle', 'barActor', 'tmActor']);\n  macro.getArray(publicAPI, model, ['boxPosition', 'boxSize']);\n  macro.setArray(publicAPI, model, ['boxPosition', 'boxSize'], 2);\n  model.forceUpdate = false;\n  model.lastRebuildTime = {};\n  macro.obj(model.lastRebuildTime, {\n    mtime: 0\n  });\n  model.lastSize = [-1, -1];\n  model.tmCanvas = document.createElement('canvas');\n  model.tmContext = model.tmCanvas.getContext('2d');\n  model._tmAtlas = new Map();\n  model.barMapper = vtkMapper.newInstance();\n  model.barMapper.setInterpolateScalarsBeforeMapping(true);\n  model.barMapper.setUseLookupTableScalarRange(true);\n  model.polyData = vtkPolyData.newInstance();\n  model.barMapper.setInputData(model.polyData);\n  model.barActor = vtkActor.newInstance();\n  model.barActor.setMapper(model.barMapper);\n\n  // for texture atlas\n  model.tmPolyData = vtkPolyData.newInstance();\n  model.tmMapper = vtkMapper.newInstance();\n  model.tmMapper.setInputData(model.tmPolyData);\n  model.tmTexture = vtkTexture.newInstance({\n    resizable: true\n  });\n  model.tmTexture.setInterpolate(false);\n  model.tmActor = vtkActor.newInstance({\n    parentProp: publicAPI\n  });\n  model.tmActor.setMapper(model.tmMapper);\n  model.tmActor.addTexture(model.tmTexture);\n  model.barPosition = [0, 0];\n  model.barSize = [0, 0];\n  model.boxPosition = [0.88, -0.92];\n  model.boxSize = [0.1, 1.1];\n\n  // internal variables\n  model.lastTickBounds = [];\n  vtkScalarBarActorHelper(publicAPI, model);\n}, 'vtkScalarBarActorHelper');\n\n//\n// Now we define the public class that the application sets view independent\n// properties on. This class is fairly small as it mainly just holds\n// properties setter and getters leaving all calculations to the helper\n// class.\n//\nfunction vtkScalarBarActor(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkScalarBarActor');\n  publicAPI.setTickTextStyle = tickStyle => {\n    model.tickTextStyle = {\n      ...model.tickTextStyle,\n      ...tickStyle\n    };\n    publicAPI.modified();\n  };\n  publicAPI.setAxisTextStyle = axisStyle => {\n    model.axisTextStyle = {\n      ...model.axisTextStyle,\n      ...axisStyle\n    };\n    publicAPI.modified();\n  };\n  publicAPI.resetAutoLayoutToDefault = () => {\n    publicAPI.setAutoLayout(defaultAutoLayout(publicAPI, model));\n  };\n  publicAPI.resetGenerateTicksToDefault = () => {\n    publicAPI.setGenerateTicks(defaultGenerateTicks());\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(initialValues) {\n  return {\n    automated: true,\n    autoLayout: null,\n    axisLabel: 'Scalar Value',\n    barPosition: [0, 0],\n    barSize: [0, 0],\n    boxPosition: [0.88, -0.92],\n    boxSize: [0.1, 1.1],\n    scalarToColors: null,\n    axisTitlePixelOffset: 36.0,\n    axisTextStyle: {\n      fontColor: 'white',\n      fontStyle: 'normal',\n      fontSize: 18,\n      fontFamily: 'serif'\n    },\n    tickLabelPixelOffset: 14.0,\n    tickTextStyle: {\n      fontColor: 'white',\n      fontStyle: 'normal',\n      fontSize: 14,\n      fontFamily: 'serif'\n    },\n    generateTicks: null,\n    drawNanAnnotation: true,\n    drawBelowRangeSwatch: true,\n    drawAboveRangeSwatch: true,\n    ...initialValues\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, defaultValues(initialValues));\n  if (!model.autoLayout) model.autoLayout = defaultAutoLayout(publicAPI, model);\n  if (!model.generateTicks) model.generateTicks = defaultGenerateTicks();\n\n  // Inheritance\n  vtkActor.extend(publicAPI, model, initialValues);\n  publicAPI.getProperty().setDiffuse(0.0);\n  publicAPI.getProperty().setAmbient(1.0);\n  macro.setGet(publicAPI, model, ['automated', 'autoLayout', 'axisTitlePixelOffset', 'axisLabel', 'scalarsToColors', 'tickLabelPixelOffset', 'generateTicks', 'drawNanAnnotation', 'drawBelowRangeSwatch', 'drawAboveRangeSwatch']);\n  macro.get(publicAPI, model, ['axisTextStyle', 'tickTextStyle']);\n  macro.getArray(publicAPI, model, ['barPosition', 'barSize', 'boxPosition', 'boxSize']);\n  macro.setArray(publicAPI, model, ['barPosition', 'barSize', 'boxPosition', 'boxSize'], 2);\n\n  // Object methods\n  vtkScalarBarActor(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkScalarBarActor');\n\n// ----------------------------------------------------------------------------\n\nvar vtkScalarBarActor$1 = {\n  newInstance,\n  extend,\n  newScalarBarActorHelper\n};\n\nexport { vtkScalarBarActor$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}