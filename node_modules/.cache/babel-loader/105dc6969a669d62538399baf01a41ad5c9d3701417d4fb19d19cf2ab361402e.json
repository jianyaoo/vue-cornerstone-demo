{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtk from '../../vtk.js';\nimport vtkCellArray from '../Core/CellArray.js';\nimport vtkCellLinks from './CellLinks.js';\nimport vtkCellTypes from './CellTypes.js';\nimport vtkLine from './Line.js';\nimport vtkPointSet from './PointSet.js';\nimport vtkTriangle from './Triangle.js';\nimport { CellType } from './CellTypes/Constants.js';\nimport { POLYDATA_FIELDS } from './PolyData/Constants.js';\nconst {\n  vtkWarningMacro\n} = macro;\nconst CELL_FACTORY = {\n  [CellType.VTK_LINE]: vtkLine,\n  [CellType.VTK_POLY_LINE]: vtkLine,\n  [CellType.VTK_TRIANGLE]: vtkTriangle\n};\n\n// ----------------------------------------------------------------------------\n// vtkPolyData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPolyData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPolyData');\n  function camelize(str) {\n    return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, letter => letter.toUpperCase()).replace(/\\s+/g, '');\n  }\n\n  // build empty cell arrays and set methods\n  POLYDATA_FIELDS.forEach(type => {\n    publicAPI[`getNumberOf${camelize(type)}`] = () => model[type].getNumberOfCells();\n    if (!model[type]) {\n      model[type] = vtkCellArray.newInstance();\n    } else {\n      model[type] = vtk(model[type]);\n    }\n  });\n  publicAPI.getNumberOfCells = () => POLYDATA_FIELDS.reduce((num, cellType) => num + model[cellType].getNumberOfCells(), 0);\n  const superShallowCopy = publicAPI.shallowCopy;\n  publicAPI.shallowCopy = function (other) {\n    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    superShallowCopy(other, debug);\n    POLYDATA_FIELDS.forEach(type => {\n      model[type] = vtkCellArray.newInstance();\n      model[type].shallowCopy(other.getReferenceByName(type));\n    });\n  };\n  publicAPI.buildCells = () => {\n    // here are the number of cells we have\n    const nVerts = publicAPI.getNumberOfVerts();\n    const nLines = publicAPI.getNumberOfLines();\n    const nPolys = publicAPI.getNumberOfPolys();\n    const nStrips = publicAPI.getNumberOfStrips();\n\n    // pre-allocate the space we need\n    const nCells = nVerts + nLines + nPolys + nStrips;\n    const types = new Uint8Array(nCells);\n    let pTypes = types;\n    const locs = new Uint32Array(nCells);\n    let pLocs = locs;\n\n    // record locations and type of each cell.\n    // verts\n    if (nVerts) {\n      let nextCellPts = 0;\n      model.verts.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        pTypes[index] = numCellPts > 1 ? CellType.VTK_POLY_VERTEX : CellType.VTK_VERTEX;\n        nextCellPts += numCellPts + 1;\n      });\n      pLocs = pLocs.subarray(nVerts);\n      pTypes = pTypes.subarray(nVerts);\n    }\n\n    // lines\n    if (nLines) {\n      let nextCellPts = 0;\n      model.lines.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        pTypes[index] = numCellPts > 2 ? CellType.VTK_POLY_LINE : CellType.VTK_LINE;\n        if (numCellPts === 1) {\n          vtkWarningMacro('Building VTK_LINE ', index, ' with only one point, but VTK_LINE needs at least two points. Check the input.');\n        }\n        nextCellPts += numCellPts + 1;\n      });\n      pLocs = pLocs.subarray(nLines);\n      pTypes = pTypes.subarray(nLines);\n    }\n\n    // polys\n    if (nPolys) {\n      let nextCellPts = 0;\n      model.polys.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        switch (numCellPts) {\n          case 3:\n            pTypes[index] = CellType.VTK_TRIANGLE;\n            break;\n          case 4:\n            pTypes[index] = CellType.VTK_QUAD;\n            break;\n          default:\n            pTypes[index] = CellType.VTK_POLYGON;\n            break;\n        }\n        if (numCellPts < 3) {\n          vtkWarningMacro('Building VTK_TRIANGLE ', index, ' with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.');\n        }\n        nextCellPts += numCellPts + 1;\n      });\n      pLocs += pLocs.subarray(nPolys);\n      pTypes += pTypes.subarray(nPolys);\n    }\n\n    // strips\n    if (nStrips) {\n      let nextCellPts = 0;\n      pTypes.fill(CellType.VTK_TRIANGLE_STRIP, 0, nStrips);\n      model.strips.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        nextCellPts += numCellPts + 1;\n      });\n    }\n\n    // set up the cell types data structure\n    model.cells = vtkCellTypes.newInstance();\n    model.cells.setCellTypes(nCells, types, locs);\n  };\n\n  /**\n   * Create upward links from points to cells that use each point. Enables\n   * topologically complex queries.\n   */\n  publicAPI.buildLinks = function () {\n    let initialSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (model.cells === undefined) {\n      publicAPI.buildCells();\n    }\n    model.links = vtkCellLinks.newInstance();\n    if (initialSize > 0) {\n      model.links.allocate(initialSize);\n    } else {\n      model.links.allocate(publicAPI.getPoints().getNumberOfPoints());\n    }\n    model.links.buildLinks(publicAPI);\n  };\n  publicAPI.getCellType = cellId => model.cells.getCellType(cellId);\n  publicAPI.getCellPoints = cellId => {\n    const cellType = publicAPI.getCellType(cellId);\n    let cells = null;\n    switch (cellType) {\n      case CellType.VTK_VERTEX:\n      case CellType.VTK_POLY_VERTEX:\n        cells = model.verts;\n        break;\n      case CellType.VTK_LINE:\n      case CellType.VTK_POLY_LINE:\n        cells = model.lines;\n        break;\n      case CellType.VTK_TRIANGLE:\n      case CellType.VTK_QUAD:\n      case CellType.VTK_POLYGON:\n        cells = model.polys;\n        break;\n      case CellType.VTK_TRIANGLE_STRIP:\n        cells = model.strips;\n        break;\n      default:\n        cells = null;\n        return {\n          type: 0,\n          cellPointIds: null\n        };\n    }\n    const loc = model.cells.getCellLocation(cellId);\n    const cellPointIds = cells.getCell(loc);\n    return {\n      cellType,\n      cellPointIds\n    };\n  };\n  publicAPI.getPointCells = ptId => model.links.getCells(ptId);\n  publicAPI.getCellEdgeNeighbors = (cellId, point1, point2) => {\n    const link1 = model.links.getLink(point1);\n    const link2 = model.links.getLink(point2);\n    return link1.cells.filter(cell => cell !== cellId && link2.cells.indexOf(cell) !== -1);\n  };\n\n  /**\n   * If you know the type of cell, you may provide it to improve performances.\n   */\n  publicAPI.getCell = function (cellId) {\n    let cellHint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const cellInfo = publicAPI.getCellPoints(cellId);\n    const cell = cellHint || CELL_FACTORY[cellInfo.cellType].newInstance();\n    cell.initialize(publicAPI.getPoints(), cellInfo.cellPointIds);\n    return cell;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // verts: null,\n  // lines: null,\n  // polys: null,\n  // strips: null,\n  // cells: null,\n  // links: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkPointSet.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['cells', 'links']);\n  macro.setGet(publicAPI, model, ['verts', 'lines', 'polys', 'strips']);\n\n  // Object specific methods\n  vtkPolyData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPolyData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPolyData$1 = {\n  newInstance,\n  extend\n};\nexport { CELL_FACTORY, vtkPolyData$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtk","vtkCellArray","vtkCellLinks","vtkCellTypes","vtkLine","vtkPointSet","vtkTriangle","CellType","POLYDATA_FIELDS","vtkWarningMacro","CELL_FACTORY","VTK_LINE","VTK_POLY_LINE","VTK_TRIANGLE","vtkPolyData","publicAPI","model","classHierarchy","push","camelize","str","replace","letter","toUpperCase","forEach","type","getNumberOfCells","newInstance","reduce","num","cellType","superShallowCopy","shallowCopy","other","debug","arguments","length","undefined","getReferenceByName","buildCells","nVerts","getNumberOfVerts","nLines","getNumberOfLines","nPolys","getNumberOfPolys","nStrips","getNumberOfStrips","nCells","types","Uint8Array","pTypes","locs","Uint32Array","pLocs","nextCellPts","verts","getCellSizes","numCellPts","index","VTK_POLY_VERTEX","VTK_VERTEX","subarray","lines","polys","VTK_QUAD","VTK_POLYGON","fill","VTK_TRIANGLE_STRIP","strips","cells","setCellTypes","buildLinks","initialSize","links","allocate","getPoints","getNumberOfPoints","getCellType","cellId","getCellPoints","cellPointIds","loc","getCellLocation","getCell","getPointCells","ptId","getCells","getCellEdgeNeighbors","point1","point2","link1","getLink","link2","filter","cell","indexOf","cellHint","cellInfo","initialize","DEFAULT_VALUES","extend","initialValues","Object","assign","get","setGet","vtkPolyData$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtk from '../../vtk.js';\nimport vtkCellArray from '../Core/CellArray.js';\nimport vtkCellLinks from './CellLinks.js';\nimport vtkCellTypes from './CellTypes.js';\nimport vtkLine from './Line.js';\nimport vtkPointSet from './PointSet.js';\nimport vtkTriangle from './Triangle.js';\nimport { CellType } from './CellTypes/Constants.js';\nimport { POLYDATA_FIELDS } from './PolyData/Constants.js';\n\nconst {\n  vtkWarningMacro\n} = macro;\nconst CELL_FACTORY = {\n  [CellType.VTK_LINE]: vtkLine,\n  [CellType.VTK_POLY_LINE]: vtkLine,\n  [CellType.VTK_TRIANGLE]: vtkTriangle\n};\n\n// ----------------------------------------------------------------------------\n// vtkPolyData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPolyData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPolyData');\n  function camelize(str) {\n    return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, letter => letter.toUpperCase()).replace(/\\s+/g, '');\n  }\n\n  // build empty cell arrays and set methods\n  POLYDATA_FIELDS.forEach(type => {\n    publicAPI[`getNumberOf${camelize(type)}`] = () => model[type].getNumberOfCells();\n    if (!model[type]) {\n      model[type] = vtkCellArray.newInstance();\n    } else {\n      model[type] = vtk(model[type]);\n    }\n  });\n  publicAPI.getNumberOfCells = () => POLYDATA_FIELDS.reduce((num, cellType) => num + model[cellType].getNumberOfCells(), 0);\n  const superShallowCopy = publicAPI.shallowCopy;\n  publicAPI.shallowCopy = function (other) {\n    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    superShallowCopy(other, debug);\n    POLYDATA_FIELDS.forEach(type => {\n      model[type] = vtkCellArray.newInstance();\n      model[type].shallowCopy(other.getReferenceByName(type));\n    });\n  };\n  publicAPI.buildCells = () => {\n    // here are the number of cells we have\n    const nVerts = publicAPI.getNumberOfVerts();\n    const nLines = publicAPI.getNumberOfLines();\n    const nPolys = publicAPI.getNumberOfPolys();\n    const nStrips = publicAPI.getNumberOfStrips();\n\n    // pre-allocate the space we need\n    const nCells = nVerts + nLines + nPolys + nStrips;\n    const types = new Uint8Array(nCells);\n    let pTypes = types;\n    const locs = new Uint32Array(nCells);\n    let pLocs = locs;\n\n    // record locations and type of each cell.\n    // verts\n    if (nVerts) {\n      let nextCellPts = 0;\n      model.verts.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        pTypes[index] = numCellPts > 1 ? CellType.VTK_POLY_VERTEX : CellType.VTK_VERTEX;\n        nextCellPts += numCellPts + 1;\n      });\n      pLocs = pLocs.subarray(nVerts);\n      pTypes = pTypes.subarray(nVerts);\n    }\n\n    // lines\n    if (nLines) {\n      let nextCellPts = 0;\n      model.lines.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        pTypes[index] = numCellPts > 2 ? CellType.VTK_POLY_LINE : CellType.VTK_LINE;\n        if (numCellPts === 1) {\n          vtkWarningMacro('Building VTK_LINE ', index, ' with only one point, but VTK_LINE needs at least two points. Check the input.');\n        }\n        nextCellPts += numCellPts + 1;\n      });\n      pLocs = pLocs.subarray(nLines);\n      pTypes = pTypes.subarray(nLines);\n    }\n\n    // polys\n    if (nPolys) {\n      let nextCellPts = 0;\n      model.polys.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        switch (numCellPts) {\n          case 3:\n            pTypes[index] = CellType.VTK_TRIANGLE;\n            break;\n          case 4:\n            pTypes[index] = CellType.VTK_QUAD;\n            break;\n          default:\n            pTypes[index] = CellType.VTK_POLYGON;\n            break;\n        }\n        if (numCellPts < 3) {\n          vtkWarningMacro('Building VTK_TRIANGLE ', index, ' with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.');\n        }\n        nextCellPts += numCellPts + 1;\n      });\n      pLocs += pLocs.subarray(nPolys);\n      pTypes += pTypes.subarray(nPolys);\n    }\n\n    // strips\n    if (nStrips) {\n      let nextCellPts = 0;\n      pTypes.fill(CellType.VTK_TRIANGLE_STRIP, 0, nStrips);\n      model.strips.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        nextCellPts += numCellPts + 1;\n      });\n    }\n\n    // set up the cell types data structure\n    model.cells = vtkCellTypes.newInstance();\n    model.cells.setCellTypes(nCells, types, locs);\n  };\n\n  /**\n   * Create upward links from points to cells that use each point. Enables\n   * topologically complex queries.\n   */\n  publicAPI.buildLinks = function () {\n    let initialSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (model.cells === undefined) {\n      publicAPI.buildCells();\n    }\n    model.links = vtkCellLinks.newInstance();\n    if (initialSize > 0) {\n      model.links.allocate(initialSize);\n    } else {\n      model.links.allocate(publicAPI.getPoints().getNumberOfPoints());\n    }\n    model.links.buildLinks(publicAPI);\n  };\n  publicAPI.getCellType = cellId => model.cells.getCellType(cellId);\n  publicAPI.getCellPoints = cellId => {\n    const cellType = publicAPI.getCellType(cellId);\n    let cells = null;\n    switch (cellType) {\n      case CellType.VTK_VERTEX:\n      case CellType.VTK_POLY_VERTEX:\n        cells = model.verts;\n        break;\n      case CellType.VTK_LINE:\n      case CellType.VTK_POLY_LINE:\n        cells = model.lines;\n        break;\n      case CellType.VTK_TRIANGLE:\n      case CellType.VTK_QUAD:\n      case CellType.VTK_POLYGON:\n        cells = model.polys;\n        break;\n      case CellType.VTK_TRIANGLE_STRIP:\n        cells = model.strips;\n        break;\n      default:\n        cells = null;\n        return {\n          type: 0,\n          cellPointIds: null\n        };\n    }\n    const loc = model.cells.getCellLocation(cellId);\n    const cellPointIds = cells.getCell(loc);\n    return {\n      cellType,\n      cellPointIds\n    };\n  };\n  publicAPI.getPointCells = ptId => model.links.getCells(ptId);\n  publicAPI.getCellEdgeNeighbors = (cellId, point1, point2) => {\n    const link1 = model.links.getLink(point1);\n    const link2 = model.links.getLink(point2);\n    return link1.cells.filter(cell => cell !== cellId && link2.cells.indexOf(cell) !== -1);\n  };\n\n  /**\n   * If you know the type of cell, you may provide it to improve performances.\n   */\n  publicAPI.getCell = function (cellId) {\n    let cellHint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const cellInfo = publicAPI.getCellPoints(cellId);\n    const cell = cellHint || CELL_FACTORY[cellInfo.cellType].newInstance();\n    cell.initialize(publicAPI.getPoints(), cellInfo.cellPointIds);\n    return cell;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // verts: null,\n  // lines: null,\n  // polys: null,\n  // strips: null,\n  // cells: null,\n  // links: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkPointSet.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['cells', 'links']);\n  macro.setGet(publicAPI, model, ['verts', 'lines', 'polys', 'strips']);\n\n  // Object specific methods\n  vtkPolyData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPolyData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPolyData$1 = {\n  newInstance,\n  extend\n};\n\nexport { CELL_FACTORY, vtkPolyData$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}