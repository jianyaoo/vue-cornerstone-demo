{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { s as subtract, d as dot, j as cross, k as add } from '../Core/Math/index.js';\nimport { m as macro } from '../../macros2.js';\nconst PLANE_TOLERANCE = 1.0e-6;\nconst COINCIDE = 'coincide';\nconst DISJOINT = 'disjoint';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction evaluate(normal, origin, x) {\n  return normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);\n}\nfunction distanceToPlane(x, origin, normal) {\n  const distance = normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);\n  return Math.abs(distance);\n}\nfunction projectPoint(x, origin, normal, xproj) {\n  const xo = [];\n  subtract(x, origin, xo);\n  const t = dot(normal, xo);\n  xproj[0] = x[0] - t * normal[0];\n  xproj[1] = x[1] - t * normal[1];\n  xproj[2] = x[2] - t * normal[2];\n}\nfunction projectVector(v, normal, vproj) {\n  const t = dot(v, normal);\n  let n2 = dot(normal, normal);\n  if (n2 === 0) {\n    n2 = 1.0;\n  }\n  vproj[0] = v[0] - t * normal[0] / n2;\n  vproj[1] = v[1] - t * normal[1] / n2;\n  vproj[2] = v[2] - t * normal[2] / n2;\n  return vproj;\n}\nfunction generalizedProjectPoint(x, origin, normal, xproj) {\n  const xo = [];\n  subtract(x, origin, xo);\n  const t = dot(normal, xo);\n  const n2 = dot(normal, normal);\n  if (n2 !== 0) {\n    xproj[0] = x[0] - t * normal[0] / n2;\n    xproj[1] = x[1] - t * normal[1] / n2;\n    xproj[2] = x[2] - t * normal[2] / n2;\n  } else {\n    xproj[0] = x[0];\n    xproj[1] = x[1];\n    xproj[2] = x[2];\n  }\n}\nfunction intersectWithLine(p1, p2, origin, normal) {\n  const outObj = {\n    intersection: false,\n    betweenPoints: false,\n    t: Number.MAX_VALUE,\n    x: []\n  };\n  const p21 = [];\n  const p1Origin = [];\n  // Compute line vector\n  subtract(p2, p1, p21);\n  subtract(origin, p1, p1Origin);\n\n  // Compute denominator.  If ~0, line and plane are parallel.\n  // const num = vtkMath.dot(normal, origin) - vtkMath.dot(normal, p1);\n  const num = dot(normal, p1Origin);\n  const den = dot(normal, p21);\n\n  // If denominator with respect to numerator is \"zero\", then the line and\n  // plane are considered parallel.\n  let fabsden;\n  let fabstolerance;\n\n  // Trying to avoid an expensive call to fabs()\n  if (den < 0.0) {\n    fabsden = -den;\n  } else {\n    fabsden = den;\n  }\n  if (num < 0.0) {\n    fabstolerance = -num * PLANE_TOLERANCE;\n  } else {\n    fabstolerance = num * PLANE_TOLERANCE;\n  }\n  if (fabsden <= fabstolerance) {\n    return outObj;\n  }\n\n  // Where on the line between p1 and p2 is the intersection\n  // If between 0 and 1, it is between the two points. If < 0 it's before p1, if > 1 it's after p2\n  outObj.t = num / den;\n  outObj.x[0] = p1[0] + outObj.t * p21[0];\n  outObj.x[1] = p1[1] + outObj.t * p21[1];\n  outObj.x[2] = p1[2] + outObj.t * p21[2];\n  outObj.intersection = true;\n  outObj.betweenPoints = outObj.t >= 0.0 && outObj.t <= 1.0;\n  return outObj;\n}\nfunction intersectWithPlane(plane1Origin, plane1Normal, plane2Origin, plane2Normal) {\n  const outObj = {\n    intersection: false,\n    l0: [],\n    l1: [],\n    error: null\n  };\n  const cross$1 = [];\n  cross(plane1Normal, plane2Normal, cross$1);\n  const absCross = cross$1.map(n => Math.abs(n));\n\n  // test if the two planes are parallel\n  if (absCross[0] + absCross[1] + absCross[2] < PLANE_TOLERANCE) {\n    // test if disjoint or coincide\n    const v = [];\n    subtract(plane1Origin, plane2Origin, v);\n    if (dot(plane1Normal, v) === 0) {\n      outObj.error = COINCIDE;\n    } else {\n      outObj.error = DISJOINT;\n    }\n    return outObj;\n  }\n\n  // Plane1 and Plane2 intersect in a line\n  // first determine max abs coordinate of the cross product\n  let maxc;\n  if (absCross[0] > absCross[1] && absCross[0] > absCross[2]) {\n    maxc = 'x';\n  } else if (absCross[1] > absCross[2]) {\n    maxc = 'y';\n  } else {\n    maxc = 'z';\n  }\n\n  // To get a point on the intersect line, zero the max coord, and solve for the other two\n  const iP = []; // intersectionPoint\n  // the constants in the 2 plane equations\n  const d1 = -dot(plane1Normal, plane1Origin);\n  const d2 = -dot(plane2Normal, plane2Origin);\n\n  // eslint-disable-next-line default-case\n  switch (maxc) {\n    case 'x':\n      // intersect with x=0\n      iP[0] = 0;\n      iP[1] = (d2 * plane1Normal[2] - d1 * plane2Normal[2]) / cross$1[0];\n      iP[2] = (d1 * plane2Normal[1] - d2 * plane1Normal[1]) / cross$1[0];\n      break;\n    case 'y':\n      // intersect with y=0\n      iP[0] = (d1 * plane2Normal[2] - d2 * plane1Normal[2]) / cross$1[1];\n      iP[1] = 0;\n      iP[2] = (d2 * plane1Normal[0] - d1 * plane2Normal[0]) / cross$1[1];\n      break;\n    case 'z':\n      // intersect with z=0\n      iP[0] = (d2 * plane1Normal[1] - d1 * plane2Normal[1]) / cross$1[2];\n      iP[1] = (d1 * plane2Normal[0] - d2 * plane1Normal[0]) / cross$1[2];\n      iP[2] = 0;\n      break;\n  }\n  outObj.l0 = iP;\n  add(iP, cross$1, outObj.l1);\n  outObj.intersection = true;\n  return outObj;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  evaluate,\n  distanceToPlane,\n  projectPoint,\n  projectVector,\n  generalizedProjectPoint,\n  intersectWithLine,\n  intersectWithPlane,\n  DISJOINT,\n  COINCIDE\n};\n\n// ----------------------------------------------------------------------------\n// vtkPlane methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPlane(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPlane');\n  publicAPI.distanceToPlane = x => distanceToPlane(x, model.origin, model.normal);\n  publicAPI.projectPoint = (x, xproj) => {\n    projectPoint(x, model.origin, model.normal, xproj);\n  };\n  publicAPI.projectVector = (v, vproj) => projectVector(v, model.normal, vproj);\n  publicAPI.push = distance => {\n    if (distance === 0.0) {\n      return;\n    }\n    for (let i = 0; i < 3; i++) {\n      model.origin[i] += distance * model.normal[i];\n    }\n  };\n  publicAPI.generalizedProjectPoint = (x, xproj) => {\n    generalizedProjectPoint(x, model.origin, model.normal, xproj);\n  };\n  publicAPI.evaluateFunction = (x, y, z) => {\n    if (!Array.isArray(x)) {\n      return model.normal[0] * (x - model.origin[0]) + model.normal[1] * (y - model.origin[1]) + model.normal[2] * (z - model.origin[2]);\n    }\n    return model.normal[0] * (x[0] - model.origin[0]) + model.normal[1] * (x[1] - model.origin[1]) + model.normal[2] * (x[2] - model.origin[2]);\n  };\n  publicAPI.evaluateGradient = xyz => {\n    const retVal = [model.normal[0], model.normal[1], model.normal[2]];\n    return retVal;\n  };\n  publicAPI.intersectWithLine = (p1, p2) => intersectWithLine(p1, p2, model.origin, model.normal);\n  publicAPI.intersectWithPlane = (planeOrigin, planeNormal) => intersectWithPlane(planeOrigin, planeNormal, model.origin, model.normal);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  normal: [0.0, 0.0, 1.0],\n  origin: [0.0, 0.0, 0.0]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  macro.setGetArray(publicAPI, model, ['normal', 'origin'], 3);\n  vtkPlane(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPlane');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPlane$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\nexport { STATIC, vtkPlane$1 as default, extend, newInstance, vtkPlane };","map":{"version":3,"names":["s","subtract","d","dot","j","cross","k","add","m","macro","PLANE_TOLERANCE","COINCIDE","DISJOINT","evaluate","normal","origin","x","distanceToPlane","distance","Math","abs","projectPoint","xproj","xo","t","projectVector","v","vproj","n2","generalizedProjectPoint","intersectWithLine","p1","p2","outObj","intersection","betweenPoints","Number","MAX_VALUE","p21","p1Origin","num","den","fabsden","fabstolerance","intersectWithPlane","plane1Origin","plane1Normal","plane2Origin","plane2Normal","l0","l1","error","cross$1","absCross","map","n","maxc","iP","d1","d2","STATIC","vtkPlane","publicAPI","model","classHierarchy","push","i","evaluateFunction","y","z","Array","isArray","evaluateGradient","xyz","retVal","planeOrigin","planeNormal","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","obj","setGetArray","newInstance","vtkPlane$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Common/DataModel/Plane.js"],"sourcesContent":["import { s as subtract, d as dot, j as cross, k as add } from '../Core/Math/index.js';\nimport { m as macro } from '../../macros2.js';\n\nconst PLANE_TOLERANCE = 1.0e-6;\nconst COINCIDE = 'coincide';\nconst DISJOINT = 'disjoint';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction evaluate(normal, origin, x) {\n  return normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);\n}\nfunction distanceToPlane(x, origin, normal) {\n  const distance = normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);\n  return Math.abs(distance);\n}\nfunction projectPoint(x, origin, normal, xproj) {\n  const xo = [];\n  subtract(x, origin, xo);\n  const t = dot(normal, xo);\n  xproj[0] = x[0] - t * normal[0];\n  xproj[1] = x[1] - t * normal[1];\n  xproj[2] = x[2] - t * normal[2];\n}\nfunction projectVector(v, normal, vproj) {\n  const t = dot(v, normal);\n  let n2 = dot(normal, normal);\n  if (n2 === 0) {\n    n2 = 1.0;\n  }\n  vproj[0] = v[0] - t * normal[0] / n2;\n  vproj[1] = v[1] - t * normal[1] / n2;\n  vproj[2] = v[2] - t * normal[2] / n2;\n  return vproj;\n}\nfunction generalizedProjectPoint(x, origin, normal, xproj) {\n  const xo = [];\n  subtract(x, origin, xo);\n  const t = dot(normal, xo);\n  const n2 = dot(normal, normal);\n  if (n2 !== 0) {\n    xproj[0] = x[0] - t * normal[0] / n2;\n    xproj[1] = x[1] - t * normal[1] / n2;\n    xproj[2] = x[2] - t * normal[2] / n2;\n  } else {\n    xproj[0] = x[0];\n    xproj[1] = x[1];\n    xproj[2] = x[2];\n  }\n}\nfunction intersectWithLine(p1, p2, origin, normal) {\n  const outObj = {\n    intersection: false,\n    betweenPoints: false,\n    t: Number.MAX_VALUE,\n    x: []\n  };\n  const p21 = [];\n  const p1Origin = [];\n  // Compute line vector\n  subtract(p2, p1, p21);\n  subtract(origin, p1, p1Origin);\n\n  // Compute denominator.  If ~0, line and plane are parallel.\n  // const num = vtkMath.dot(normal, origin) - vtkMath.dot(normal, p1);\n  const num = dot(normal, p1Origin);\n  const den = dot(normal, p21);\n\n  // If denominator with respect to numerator is \"zero\", then the line and\n  // plane are considered parallel.\n  let fabsden;\n  let fabstolerance;\n\n  // Trying to avoid an expensive call to fabs()\n  if (den < 0.0) {\n    fabsden = -den;\n  } else {\n    fabsden = den;\n  }\n  if (num < 0.0) {\n    fabstolerance = -num * PLANE_TOLERANCE;\n  } else {\n    fabstolerance = num * PLANE_TOLERANCE;\n  }\n  if (fabsden <= fabstolerance) {\n    return outObj;\n  }\n\n  // Where on the line between p1 and p2 is the intersection\n  // If between 0 and 1, it is between the two points. If < 0 it's before p1, if > 1 it's after p2\n  outObj.t = num / den;\n  outObj.x[0] = p1[0] + outObj.t * p21[0];\n  outObj.x[1] = p1[1] + outObj.t * p21[1];\n  outObj.x[2] = p1[2] + outObj.t * p21[2];\n  outObj.intersection = true;\n  outObj.betweenPoints = outObj.t >= 0.0 && outObj.t <= 1.0;\n  return outObj;\n}\nfunction intersectWithPlane(plane1Origin, plane1Normal, plane2Origin, plane2Normal) {\n  const outObj = {\n    intersection: false,\n    l0: [],\n    l1: [],\n    error: null\n  };\n  const cross$1 = [];\n  cross(plane1Normal, plane2Normal, cross$1);\n  const absCross = cross$1.map(n => Math.abs(n));\n\n  // test if the two planes are parallel\n  if (absCross[0] + absCross[1] + absCross[2] < PLANE_TOLERANCE) {\n    // test if disjoint or coincide\n    const v = [];\n    subtract(plane1Origin, plane2Origin, v);\n    if (dot(plane1Normal, v) === 0) {\n      outObj.error = COINCIDE;\n    } else {\n      outObj.error = DISJOINT;\n    }\n    return outObj;\n  }\n\n  // Plane1 and Plane2 intersect in a line\n  // first determine max abs coordinate of the cross product\n  let maxc;\n  if (absCross[0] > absCross[1] && absCross[0] > absCross[2]) {\n    maxc = 'x';\n  } else if (absCross[1] > absCross[2]) {\n    maxc = 'y';\n  } else {\n    maxc = 'z';\n  }\n\n  // To get a point on the intersect line, zero the max coord, and solve for the other two\n  const iP = []; // intersectionPoint\n  // the constants in the 2 plane equations\n  const d1 = -dot(plane1Normal, plane1Origin);\n  const d2 = -dot(plane2Normal, plane2Origin);\n\n  // eslint-disable-next-line default-case\n  switch (maxc) {\n    case 'x':\n      // intersect with x=0\n      iP[0] = 0;\n      iP[1] = (d2 * plane1Normal[2] - d1 * plane2Normal[2]) / cross$1[0];\n      iP[2] = (d1 * plane2Normal[1] - d2 * plane1Normal[1]) / cross$1[0];\n      break;\n    case 'y':\n      // intersect with y=0\n      iP[0] = (d1 * plane2Normal[2] - d2 * plane1Normal[2]) / cross$1[1];\n      iP[1] = 0;\n      iP[2] = (d2 * plane1Normal[0] - d1 * plane2Normal[0]) / cross$1[1];\n      break;\n    case 'z':\n      // intersect with z=0\n      iP[0] = (d2 * plane1Normal[1] - d1 * plane2Normal[1]) / cross$1[2];\n      iP[1] = (d1 * plane2Normal[0] - d2 * plane1Normal[0]) / cross$1[2];\n      iP[2] = 0;\n      break;\n  }\n  outObj.l0 = iP;\n  add(iP, cross$1, outObj.l1);\n  outObj.intersection = true;\n  return outObj;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  evaluate,\n  distanceToPlane,\n  projectPoint,\n  projectVector,\n  generalizedProjectPoint,\n  intersectWithLine,\n  intersectWithPlane,\n  DISJOINT,\n  COINCIDE\n};\n\n// ----------------------------------------------------------------------------\n// vtkPlane methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPlane(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPlane');\n  publicAPI.distanceToPlane = x => distanceToPlane(x, model.origin, model.normal);\n  publicAPI.projectPoint = (x, xproj) => {\n    projectPoint(x, model.origin, model.normal, xproj);\n  };\n  publicAPI.projectVector = (v, vproj) => projectVector(v, model.normal, vproj);\n  publicAPI.push = distance => {\n    if (distance === 0.0) {\n      return;\n    }\n    for (let i = 0; i < 3; i++) {\n      model.origin[i] += distance * model.normal[i];\n    }\n  };\n  publicAPI.generalizedProjectPoint = (x, xproj) => {\n    generalizedProjectPoint(x, model.origin, model.normal, xproj);\n  };\n  publicAPI.evaluateFunction = (x, y, z) => {\n    if (!Array.isArray(x)) {\n      return model.normal[0] * (x - model.origin[0]) + model.normal[1] * (y - model.origin[1]) + model.normal[2] * (z - model.origin[2]);\n    }\n    return model.normal[0] * (x[0] - model.origin[0]) + model.normal[1] * (x[1] - model.origin[1]) + model.normal[2] * (x[2] - model.origin[2]);\n  };\n  publicAPI.evaluateGradient = xyz => {\n    const retVal = [model.normal[0], model.normal[1], model.normal[2]];\n    return retVal;\n  };\n  publicAPI.intersectWithLine = (p1, p2) => intersectWithLine(p1, p2, model.origin, model.normal);\n  publicAPI.intersectWithPlane = (planeOrigin, planeNormal) => intersectWithPlane(planeOrigin, planeNormal, model.origin, model.normal);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  normal: [0.0, 0.0, 1.0],\n  origin: [0.0, 0.0, 0.0]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  macro.setGetArray(publicAPI, model, ['normal', 'origin'], 3);\n  vtkPlane(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPlane');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPlane$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkPlane$1 as default, extend, newInstance, vtkPlane };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}