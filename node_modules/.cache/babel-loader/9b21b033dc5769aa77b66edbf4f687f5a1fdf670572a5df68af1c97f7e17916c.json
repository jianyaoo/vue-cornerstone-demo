{"ast":null,"code":"import { m as macro } from '../../macros2.js';\nimport { h as hsv2rgb, i as isNan, H as floor, I as isInf, J as rgb2hsv, K as rgb2lab, L as lab2rgb } from '../../Common/Core/Math/index.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors.js';\nimport Constants from './ColorTransferFunction/Constants.js';\nconst {\n  ColorSpace,\n  Scale\n} = Constants;\nconst {\n  ScalarMappingTarget\n} = vtkScalarsToColors;\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n/* eslint-disable no-continue                                                */\n\n// Convert to and from a special polar version of CIELAB (useful for creating\n// continuous diverging color maps).\nfunction vtkColorTransferFunctionLabToMsh(lab, msh) {\n  const L = lab[0];\n  const a = lab[1];\n  const b = lab[2];\n  const M = Math.sqrt(L * L + a * a + b * b);\n  const s = M > 0.001 ? Math.acos(L / M) : 0.0;\n  const h = s > 0.001 ? Math.atan2(b, a) : 0.0;\n  msh[0] = M;\n  msh[1] = s;\n  msh[2] = h;\n}\nfunction vtkColorTransferFunctionMshToLab(msh, lab) {\n  const M = msh[0];\n  const s = msh[1];\n  const h = msh[2];\n  lab[0] = M * Math.cos(s);\n  lab[1] = M * Math.sin(s) * Math.cos(h);\n  lab[2] = M * Math.sin(s) * Math.sin(h);\n}\n\n// For the case when interpolating from a saturated color to an unsaturated\n// color, find a hue for the unsaturated color that makes sense.\nfunction vtkColorTransferFunctionAdjustHue(msh, unsatM) {\n  if (msh[0] >= unsatM - 0.1) {\n    // The best we can do is hold hue constant.\n    return msh[2];\n  }\n\n  // This equation is designed to make the perceptual change of the\n  // interpolation to be close to constant.\n  const hueSpin = msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0]) / (msh[0] * Math.sin(msh[1]));\n  // Spin hue away from 0 except in purple hues.\n  if (msh[2] > -0.3 * Math.PI) {\n    return msh[2] + hueSpin;\n  }\n  return msh[2] - hueSpin;\n}\nfunction vtkColorTransferFunctionAngleDiff(a1, a2) {\n  let adiff = a1 - a2;\n  if (adiff < 0.0) {\n    adiff = -adiff;\n  }\n  while (adiff >= 2.0 * Math.PI) {\n    adiff -= 2.0 * Math.PI;\n  }\n  if (adiff > Math.PI) {\n    adiff = 2.0 * Math.PI - adiff;\n  }\n  return adiff;\n}\n\n// Interpolate a diverging color map.\nfunction vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {\n  const lab1 = [];\n  const lab2 = [];\n  rgb2lab(rgb1, lab1);\n  rgb2lab(rgb2, lab2);\n  const msh1 = [];\n  const msh2 = [];\n  vtkColorTransferFunctionLabToMsh(lab1, msh1);\n  vtkColorTransferFunctionLabToMsh(lab2, msh2);\n\n  // If the endpoints are distinct saturated colors, then place white in between\n  // them.\n  let localS = s;\n  if (msh1[1] > 0.05 && msh2[1] > 0.05 && vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI) {\n    // Insert the white midpoint by setting one end to white and adjusting the\n    // scalar value.\n    let Mmid = Math.max(msh1[0], msh2[0]);\n    Mmid = Math.max(88.0, Mmid);\n    if (s < 0.5) {\n      msh2[0] = Mmid;\n      msh2[1] = 0.0;\n      msh2[2] = 0.0;\n      localS *= 2.0;\n    } else {\n      msh1[0] = Mmid;\n      msh1[1] = 0.0;\n      msh1[2] = 0.0;\n      localS = 2.0 * localS - 1.0;\n    }\n  }\n\n  // If one color has no saturation, then its hue value is invalid.  In this\n  // case, we want to set it to something logical so that the interpolation of\n  // hue makes sense.\n  if (msh1[1] < 0.05 && msh2[1] > 0.05) {\n    msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);\n  } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {\n    msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);\n  }\n  const mshTmp = [];\n  mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];\n  mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];\n  mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2];\n\n  // Now convert back to RGB\n  const labTmp = [];\n  vtkColorTransferFunctionMshToLab(mshTmp, labTmp);\n  lab2rgb(labTmp, result);\n}\n\n// ----------------------------------------------------------------------------\n// vtkColorTransferFunction methods\n// ----------------------------------------------------------------------------\n\nfunction vtkColorTransferFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkColorTransferFunction');\n\n  // Return the number of points which specify this function\n  publicAPI.getSize = () => model.nodes.length;\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n  publicAPI.addRGBPoint = (x, r, g, b) => publicAPI.addRGBPointLong(x, r, g, b, 0.5, 0.0);\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n  publicAPI.addRGBPointLong = function (x, r, g, b) {\n    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    // remove any node already at this X location\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    }\n\n    // Create the new node\n    const node = {\n      x,\n      r,\n      g,\n      b,\n      midpoint,\n      sharpness\n    };\n\n    // Add it, then sort to get everything in order\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange();\n\n    // We need to find the index of the node we just added in order\n    // to return this value\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If we didn't find it, something went horribly wrong so\n    // return -1\n    if (i < model.nodes.length) {\n      return i;\n    }\n    return -1;\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n  publicAPI.addHSVPoint = (x, h, s, v) => publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0.0);\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n  publicAPI.addHSVPointLong = function (x, h, s, v) {\n    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n    const rgb = [];\n    const hsv = [h, s, v];\n    hsv2rgb(hsv, rgb);\n    return publicAPI.addRGBPoint(x, rgb[0], rgb[1], rgb[2], midpoint, sharpness);\n  };\n\n  //----------------------------------------------------------------------------\n  // Set nodes directly\n  publicAPI.setNodes = nodes => {\n    if (model.nodes !== nodes) {\n      const before = JSON.stringify(model.nodes);\n      model.nodes = nodes;\n      const after = JSON.stringify(model.nodes);\n      if (publicAPI.sortAndUpdateRange() || before !== after) {\n        publicAPI.modified();\n        return true;\n      }\n    }\n    return false;\n  };\n\n  //----------------------------------------------------------------------------\n  // Sort the vector in increasing order, then fill in\n  // the Range\n  publicAPI.sortAndUpdateRange = () => {\n    const before = JSON.stringify(model.nodes);\n    model.nodes.sort((a, b) => a.x - b.x);\n    const after = JSON.stringify(model.nodes);\n    const modifiedInvoked = publicAPI.updateRange();\n    // If range is updated, Modified() has been called, don't call it again.\n    if (!modifiedInvoked && before !== after) {\n      publicAPI.modified();\n      return true;\n    }\n    return modifiedInvoked;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.updateRange = () => {\n    const oldRange = [2];\n    oldRange[0] = model.mappingRange[0];\n    oldRange[1] = model.mappingRange[1];\n    const size = model.nodes.length;\n    if (size) {\n      model.mappingRange[0] = model.nodes[0].x;\n      model.mappingRange[1] = model.nodes[size - 1].x;\n    } else {\n      model.mappingRange[0] = 0;\n      model.mappingRange[1] = 0;\n    }\n\n    // If the range is the same, then no need to call Modified()\n    if (oldRange[0] === model.mappingRange[0] && oldRange[1] === model.mappingRange[1]) {\n      return false;\n    }\n    publicAPI.modified();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  // Remove a point\n  publicAPI.removePoint = x => {\n    // First find the node since we need to know its\n    // index as our return value\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n    const retVal = i;\n\n    // If the node doesn't exist, we return -1\n    if (i >= model.nodes.length) {\n      return -1;\n    }\n\n    // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n    let modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n    return retVal;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.movePoint = (oldX, newX) => {\n    if (oldX === newX) {\n      // Nothing to do.\n      return;\n    }\n    publicAPI.removePoint(newX);\n    for (let i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === oldX) {\n        model.nodes[i].x = newX;\n        publicAPI.sortAndUpdateRange();\n        break;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  // Remove all points\n  publicAPI.removeAllPoints = () => {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a line defined in RGB\n  publicAPI.addRGBSegment = (x1, r1, g1, b1, x2, r2, g2, b2) => {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    // Now add the points\n    publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0.0);\n    publicAPI.addRGBPointLong(x2, r2, g2, b2, 0.5, 0.0);\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a line defined in HSV\n  publicAPI.addHSVSegment = (x1, h1, s1, v1, x2, h2, s2, v2) => {\n    const hsv1 = [h1, s1, v1];\n    const hsv2 = [h2, s2, v2];\n    const rgb1 = [];\n    const rgb2 = [];\n    hsv2rgb(hsv1, rgb1);\n    hsv2rgb(hsv2, rgb2);\n    publicAPI.addRGBSegment(x1, rgb1[0], rgb1[1], rgb1[2], x2, rgb2[0], rgb2[1], rgb2[2]);\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the RGBA color evaluated at the specified location\n  publicAPI.mapValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return [Math.floor(255.0 * rgb[0] + 0.5), Math.floor(255.0 * rgb[1] + 0.5), Math.floor(255.0 * rgb[2] + 0.5), 255];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the RGB color evaluated at the specified location\n  publicAPI.getColor = (x, rgb) => {\n    if (model.indexedLookup) {\n      const numNodes = publicAPI.getSize();\n      // todo\n      const idx = publicAPI.getAnnotatedValueIndexInternal(x);\n      if (idx < 0 || numNodes === 0) {\n        const nanColor = publicAPI.getNanColorByReference();\n        rgb[0] = nanColor[0];\n        rgb[1] = nanColor[1];\n        rgb[2] = nanColor[2];\n      } else {\n        const nodeVal = [];\n        publicAPI.getNodeValue(idx % numNodes, nodeVal);\n        // nodeVal[0] is the x value. nodeVal[1...3] is rgb.\n        rgb[0] = nodeVal[1];\n        rgb[1] = nodeVal[2];\n        rgb[2] = nodeVal[3];\n      }\n      return;\n    }\n    publicAPI.getTable(x, x, 1, rgb);\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the red color evaluated at the specified location\n  publicAPI.getRedValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[0];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the green color evaluated at the specified location\n  publicAPI.getGreenValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[1];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the blue color evaluated at the specified location\n  publicAPI.getBlueValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[2];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns a table of RGB colors at regular intervals along the function\n  publicAPI.getTable = (xStart_, xEnd_, size, table) => {\n    // To handle BigInt limitation\n    const xStart = Number(xStart_);\n    const xEnd = Number(xEnd_);\n\n    // Special case: If either the start or end is a NaN, then all any\n    // interpolation done on them is also a NaN.  Therefore, fill the table with\n    // the NaN color.\n    if (isNan(xStart) || isNan(xEnd)) {\n      for (let i = 0; i < size; i++) {\n        table[i * 3 + 0] = model.nanColor[0];\n        table[i * 3 + 1] = model.nanColor[1];\n        table[i * 3 + 2] = model.nanColor[2];\n      }\n      return;\n    }\n    let idx = 0;\n    const numNodes = model.nodes.length;\n\n    // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n    let lastR = 0.0;\n    let lastG = 0.0;\n    let lastB = 0.0;\n    if (numNodes !== 0) {\n      lastR = model.nodes[numNodes - 1].r;\n      lastG = model.nodes[numNodes - 1].g;\n      lastB = model.nodes[numNodes - 1].b;\n    }\n    let x = 0.0;\n    let x1 = 0.0;\n    let x2 = 0.0;\n    const rgb1 = [0.0, 0.0, 0.0];\n    const rgb2 = [0.0, 0.0, 0.0];\n    let midpoint = 0.0;\n    let sharpness = 0.0;\n    const tmpVec = [];\n\n    // If the scale is logarithmic, make sure the range is valid.\n    let usingLogScale = model.scale === Scale.LOG10;\n    if (usingLogScale) {\n      // Note: This requires range[0] <= range[1].\n      usingLogScale = model.mappingRange[0] > 0.0;\n    }\n    let logStart = 0.0;\n    let logEnd = 0.0;\n    let logX = 0.0;\n    if (usingLogScale) {\n      logStart = Math.log10(xStart);\n      logEnd = Math.log10(xEnd);\n    }\n\n    // For each table entry\n    for (let i = 0; i < size; i++) {\n      // Find our location in the table\n      const tidx = 3 * i;\n\n      // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n      if (size > 1) {\n        if (usingLogScale) {\n          logX = logStart + i / (size - 1.0) * (logEnd - logStart);\n          x = 10.0 ** logX;\n        } else {\n          x = xStart + i / (size - 1.0) * (xEnd - xStart);\n        }\n      } else if (usingLogScale) {\n        logX = 0.5 * (logStart + logEnd);\n        x = 10.0 ** logX;\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      }\n\n      // Linearly map x from mappingRange to [0, numberOfValues-1],\n      // discretize (round down to the closest integer),\n      // then map back to mappingRange\n      if (model.discretize) {\n        const range = model.mappingRange;\n        if (x >= range[0] && x <= range[1]) {\n          const numberOfValues = model.numberOfValues;\n          const deltaRange = range[1] - range[0];\n          if (numberOfValues <= 1) {\n            x = range[0] + deltaRange / 2.0;\n          } else {\n            // normalize x\n            const xn = (x - range[0]) / deltaRange;\n            // discretize\n            const discretizeIndex = floor(numberOfValues * xn);\n            // get discretized x\n            x = range[0] + discretizeIndex / (numberOfValues - 1) * deltaRange;\n          }\n        }\n      }\n\n      // Do we need to move to the next node?\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++;\n        // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n          if (usingLogScale) {\n            x1 = Math.log10(x1);\n            x2 = Math.log10(x2);\n          }\n          rgb1[0] = model.nodes[idx - 1].r;\n          rgb2[0] = model.nodes[idx].r;\n          rgb1[1] = model.nodes[idx - 1].g;\n          rgb2[1] = model.nodes[idx].g;\n          rgb1[2] = model.nodes[idx - 1].b;\n          rgb2[2] = model.nodes[idx].b;\n\n          // We only need the previous midpoint and sharpness\n          // since these control this region\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness;\n\n          // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      }\n\n      // Are we at or past the end? If so, just use the last value\n      if (x > model.mappingRange[1]) {\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n        if (model.clamping) {\n          if (publicAPI.getUseAboveRangeColor()) {\n            table[tidx] = model.aboveRangeColor[0];\n            table[tidx + 1] = model.aboveRangeColor[1];\n            table[tidx + 2] = model.aboveRangeColor[2];\n          } else {\n            table[tidx] = lastR;\n            table[tidx + 1] = lastG;\n            table[tidx + 2] = lastB;\n          }\n        }\n      } else if (x < model.mappingRange[0] || isInf(x) && x < 0) {\n        // we are before the first node? If so, duplicate this node's values.\n        // We have to deal with -inf here\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n        if (model.clamping) {\n          if (publicAPI.getUseBelowRangeColor()) {\n            table[tidx] = model.belowRangeColor[0];\n            table[tidx + 1] = model.belowRangeColor[1];\n            table[tidx + 2] = model.belowRangeColor[2];\n          } else if (numNodes > 0) {\n            table[tidx] = model.nodes[0].r;\n            table[tidx + 1] = model.nodes[0].g;\n            table[tidx + 2] = model.nodes[0].b;\n          }\n        }\n      } else if (idx === 0 && (Math.abs(x - xStart) < 1e-6 || model.discretize)) {\n        if (numNodes > 0) {\n          table[tidx] = model.nodes[0].r;\n          table[tidx + 1] = model.nodes[0].g;\n          table[tidx + 2] = model.nodes[0].b;\n        } else {\n          table[tidx] = 0.0;\n          table[tidx + 1] = 0.0;\n          table[tidx + 2] = 0.0;\n        }\n      } else {\n        // OK, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        let s = 0.0;\n        if (usingLogScale) {\n          s = (logX - x1) / (x2 - x1);\n        } else {\n          s = (x - x1) / (x2 - x1);\n        }\n\n        // Readjust based on the midpoint - linear adjustment\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        }\n\n        // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = rgb1[0];\n            table[tidx + 1] = rgb1[1];\n            table[tidx + 2] = rgb1[2];\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = rgb2[0];\n            table[tidx + 1] = rgb2[1];\n            table[tidx + 2] = rgb2[2];\n            continue;\n          }\n        }\n\n        // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          if (model.colorSpace === ColorSpace.RGB) {\n            table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];\n            table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];\n            table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];\n          } else if (model.colorSpace === ColorSpace.HSV) {\n            const hsv1 = [];\n            const hsv2 = [];\n            rgb2hsv(rgb1, hsv1);\n            rgb2hsv(rgb2, hsv2);\n            if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {\n              if (hsv1[0] > hsv2[0]) {\n                hsv1[0] -= 1.0;\n              } else {\n                hsv2[0] -= 1.0;\n              }\n            }\n            const hsvTmp = [];\n            hsvTmp[0] = (1.0 - s) * hsv1[0] + s * hsv2[0];\n            if (hsvTmp[0] < 0.0) {\n              hsvTmp[0] += 1.0;\n            }\n            hsvTmp[1] = (1.0 - s) * hsv1[1] + s * hsv2[1];\n            hsvTmp[2] = (1.0 - s) * hsv1[2] + s * hsv2[2];\n\n            // Now convert this back to RGB\n            hsv2rgb(hsvTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.LAB) {\n            const lab1 = [];\n            const lab2 = [];\n            rgb2lab(rgb1, lab1);\n            rgb2lab(rgb2, lab2);\n            const labTmp = [];\n            labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];\n            labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];\n            labTmp[2] = (1 - s) * lab1[2] + s * lab2[2];\n\n            // Now convert back to RGB\n            lab2rgb(labTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.DIVERGING) {\n            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else {\n            vtkErrorMacro('ColorSpace set to invalid value.', model.colorSpace);\n          }\n          continue;\n        }\n\n        // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n        if (s < 0.5) {\n          s = 0.5 * (s * 2.0) ** (1.0 + 10.0 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10.0 * sharpness);\n        }\n\n        // Compute some coefficients we will need for the hermite curve\n        const ss = s * s;\n        const sss = ss * s;\n        const h1 = 2.0 * sss - 3 * ss + 1;\n        const h2 = -2 * sss + 3 * ss;\n        const h3 = sss - 2 * ss + s;\n        const h4 = sss - ss;\n        let slope;\n        let t;\n        if (model.colorSpace === ColorSpace.RGB) {\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = rgb2[j] - rgb1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;\n          }\n        } else if (model.colorSpace === ColorSpace.HSV) {\n          const hsv1 = [];\n          const hsv2 = [];\n          rgb2hsv(rgb1, hsv1);\n          rgb2hsv(rgb2, hsv2);\n          if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {\n            if (hsv1[0] > hsv2[0]) {\n              hsv1[0] -= 1.0;\n            } else {\n              hsv2[0] -= 1.0;\n            }\n          }\n          const hsvTmp = [];\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = hsv2[j] - hsv1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            hsvTmp[j] = h1 * hsv1[j] + h2 * hsv2[j] + h3 * t + h4 * t;\n            if (j === 0 && hsvTmp[j] < 0.0) {\n              hsvTmp[j] += 1.0;\n            }\n          }\n          // Now convert this back to RGB\n          hsv2rgb(hsvTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.LAB) {\n          const lab1 = [];\n          const lab2 = [];\n          rgb2lab(rgb1, lab1);\n          rgb2lab(rgb2, lab2);\n          const labTmp = [];\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = lab2[j] - lab1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            labTmp[j] = h1 * lab1[j] + h2 * lab2[j] + h3 * t + h4 * t;\n          }\n          // Now convert this back to RGB\n          lab2rgb(labTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.DIVERGING) {\n          // I have not implemented proper interpolation by a hermite curve for\n          // the diverging color map, but I cannot think of a good use case for\n          // that anyway.\n          vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else {\n          vtkErrorMacro('ColorSpace set to invalid value.');\n        }\n\n        // Final error check to make sure we don't go outside [0,1]\n        for (let j = 0; j < 3; j++) {\n          table[tidx + j] = table[tidx + j] < 0.0 ? 0.0 : table[tidx + j];\n          table[tidx + j] = table[tidx + j] > 1.0 ? 1.0 : table[tidx + j];\n        }\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getUint8Table = function (xStart, xEnd, size) {\n    let withAlpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (publicAPI.getMTime() <= model.buildTime && model.tableSize === size && model.tableWithAlpha !== withAlpha) {\n      return model.table;\n    }\n    if (model.nodes.length === 0) {\n      vtkErrorMacro('Attempting to lookup a value with no points in the function');\n      return model.table;\n    }\n    const nbChannels = withAlpha ? 4 : 3;\n    if (model.tableSize !== size || model.tableWithAlpha !== withAlpha) {\n      model.table = new Uint8Array(size * nbChannels);\n      model.tableSize = size;\n      model.tableWithAlpha = withAlpha;\n    }\n    const tmpTable = [];\n    publicAPI.getTable(xStart, xEnd, size, tmpTable);\n    for (let i = 0; i < size; i++) {\n      model.table[i * nbChannels + 0] = Math.floor(tmpTable[i * 3 + 0] * 255.0 + 0.5);\n      model.table[i * nbChannels + 1] = Math.floor(tmpTable[i * 3 + 1] * 255.0 + 0.5);\n      model.table[i * nbChannels + 2] = Math.floor(tmpTable[i * 3 + 2] * 255.0 + 0.5);\n      if (withAlpha) {\n        model.table[i * nbChannels + 3] = 255;\n      }\n    }\n    model.buildTime.modified();\n    return model.table;\n  };\n  publicAPI.buildFunctionFromArray = array => {\n    publicAPI.removeAllPoints();\n    const numComponents = array.getNumberOfComponents();\n    for (let i = 0; i < array.getNumberOfTuples(); i++) {\n      switch (numComponents) {\n        case 3:\n          {\n            model.nodes.push({\n              x: i,\n              r: array.getComponent(i, 0),\n              g: array.getComponent(i, 1),\n              b: array.getComponent(i, 2),\n              midpoint: 0.5,\n              sharpness: 0.0\n            });\n            break;\n          }\n        case 4:\n          {\n            model.nodes.push({\n              x: array.getComponent(i, 0),\n              r: array.getComponent(i, 1),\n              g: array.getComponent(i, 2),\n              b: array.getComponent(i, 3),\n              midpoint: 0.5,\n              sharpness: 0.0\n            });\n            break;\n          }\n        case 5:\n          {\n            model.nodes.push({\n              x: i,\n              r: array.getComponent(i, 0),\n              g: array.getComponent(i, 1),\n              b: array.getComponent(i, 2),\n              midpoint: array.getComponent(i, 4),\n              sharpness: array.getComponent(i, 5)\n            });\n            break;\n          }\n        case 6:\n          {\n            model.nodes.push({\n              x: array.getComponent(i, 0),\n              r: array.getComponent(i, 1),\n              g: array.getComponent(i, 2),\n              b: array.getComponent(i, 3),\n              midpoint: array.getComponent(i, 4),\n              sharpness: array.getComponent(i, 5)\n            });\n            break;\n          }\n      }\n    }\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.buildFunctionFromTable = (xStart, xEnd, size, table) => {\n    let inc = 0.0;\n    publicAPI.removeAllPoints();\n    if (size > 1) {\n      inc = (xEnd - xStart) / (size - 1.0);\n    }\n    for (let i = 0; i < size; i++) {\n      const node = {\n        x: xStart + inc * i,\n        r: table[i * 3],\n        g: table[i * 3 + 1],\n        b: table[i * 3 + 2],\n        sharpness: 0.0,\n        midpoint: 0.5\n      };\n      model.nodes.push(node);\n    }\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n  publicAPI.getNodeValue = (index, val) => {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].r;\n    val[2] = model.nodes[index].g;\n    val[3] = model.nodes[index].b;\n    val[4] = model.nodes[index].midpoint;\n    val[5] = model.nodes[index].sharpness;\n    return 1;\n  };\n\n  //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n  publicAPI.setNodeValue = (index, val) => {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    const oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].r = val[1];\n    model.nodes[index].g = val[2];\n    model.nodes[index].b = val[3];\n    model.nodes[index].midpoint = val[4];\n    model.nodes[index].sharpness = val[5];\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange();\n      // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n    return 1;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getNumberOfAvailableColors = () => {\n    if (model.indexedLookup && publicAPI.getSize()) {\n      return publicAPI.getSize();\n    }\n    if (model.tableSize) {\n      // Not sure if this is correct since it is only set if\n      // \"const unsigned char *::GetTable(double xStart, double xEnd,int size)\"\n      // has been called.\n      return model.tableSize;\n    }\n    return 16777216; // 2^24\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getIndexedColor = (idx, rgba) => {\n    const n = publicAPI.getSize();\n    if (n > 0 && idx >= 0) {\n      const nodeValue = [];\n      publicAPI.getNodeValue(idx % n, nodeValue);\n      for (let j = 0; j < 3; ++j) {\n        rgba[j] = nodeValue[j + 1];\n      }\n      rgba[3] = 1.0; // NodeColor is RGB-only.\n      return;\n    }\n    const nanColor = publicAPI.getNanColorByReference();\n    rgba[0] = nanColor[0];\n    rgba[1] = nanColor[1];\n    rgba[2] = nanColor[2];\n    rgba[3] = 1.0; // NanColor is RGB-only.\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.fillFromDataPointer = (nb, ptr) => {\n    if (nb <= 0 || !ptr) {\n      return;\n    }\n    publicAPI.removeAllPoints();\n    for (let i = 0; i < nb; i++) {\n      publicAPI.addRGBPoint(ptr[i * 4], ptr[i * 4 + 1], ptr[i * 4 + 2], ptr[i * 4 + 3]);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.setMappingRange = (min, max) => {\n    const range = [min, max];\n    const originalRange = publicAPI.getRange();\n    if (originalRange[1] === range[1] && originalRange[0] === range[0]) {\n      return;\n    }\n    if (range[1] === range[0]) {\n      vtkErrorMacro('attempt to set zero width color range');\n      return;\n    }\n    const scale = (range[1] - range[0]) / (originalRange[1] - originalRange[0]);\n    const shift = range[0] - originalRange[0] * scale;\n    for (let i = 0; i < model.nodes.length; ++i) {\n      model.nodes[i].x = model.nodes[i].x * scale + shift;\n    }\n    model.mappingRange[0] = range[0];\n    model.mappingRange[1] = range[1];\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.adjustRange = range => {\n    const functionRange = publicAPI.getRange();\n\n    // Make sure we have points at each end of the range\n    const rgb = [];\n    if (functionRange[0] < range[0]) {\n      publicAPI.getColor(range[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    }\n    if (functionRange[1] > range[1]) {\n      publicAPI.getColor(range[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    }\n\n    // Remove all points out-of-range\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n    return 1;\n  };\n\n  //--------------------------------------------------------------------------\n  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {\n    const d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.findMinimumXDistance = () => {\n    if (model.nodes.length < 2) {\n      return -1.0;\n    }\n    let distance = Number.MAX_VALUE;\n    for (let i = 0; i < model.nodes.length - 1; i++) {\n      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n    return distance;\n  };\n  publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {\n    if (publicAPI.getSize() === 0) {\n      vtkDebugMacro('Transfer Function Has No Points!');\n      return;\n    }\n    if (model.indexedLookup) {\n      publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);\n    } else {\n      publicAPI.mapData(input, output, outFormat, inputOffset);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.mapData = (input, output, outFormat, inputOffset) => {\n    if (publicAPI.getSize() === 0) {\n      vtkWarningMacro('Transfer Function Has No Points!');\n      return;\n    }\n    const alpha = Math.floor(publicAPI.getAlpha() * 255.0 + 0.5);\n    const length = input.getNumberOfTuples();\n    const inIncr = input.getNumberOfComponents();\n    const outputV = output.getData();\n    const inputV = input.getData();\n    const rgb = [];\n    if (outFormat === ScalarMappingTarget.RGBA) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 4] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 4 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 4 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n        outputV[i * 4 + 3] = alpha;\n      }\n    }\n    if (outFormat === ScalarMappingTarget.RGB) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 3] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 3 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 3 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n      }\n    }\n    if (outFormat === ScalarMappingTarget.LUMINANCE) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n      }\n    }\n    if (outFormat === ScalarMappingTarget.LUMINANCE_ALPHA) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 2] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n        outputV[i * 2 + 1] = alpha;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.applyColorMap = colorMap => {\n    const oldColorSpace = JSON.stringify(model.colorSpace);\n    if (colorMap.ColorSpace) {\n      model.colorSpace = ColorSpace[colorMap.ColorSpace.toUpperCase()];\n      if (model.colorSpace === undefined) {\n        vtkErrorMacro(`ColorSpace ${colorMap.ColorSpace} not supported, using RGB instead`);\n        model.colorSpace = ColorSpace.RGB;\n      }\n    }\n    let isModified = oldColorSpace !== JSON.stringify(model.colorSpace);\n    const oldNanColor = isModified || JSON.stringify(model.nanColor);\n    if (colorMap.NanColor) {\n      model.nanColor = [].concat(colorMap.NanColor);\n      while (model.nanColor.length < 4) {\n        model.nanColor.push(1.0);\n      }\n    }\n    isModified = isModified || oldNanColor !== JSON.stringify(model.nanColor);\n    const oldNodes = isModified || JSON.stringify(model.nodes);\n    if (colorMap.RGBPoints) {\n      const size = colorMap.RGBPoints.length;\n      model.nodes = [];\n      const midpoint = 0.5;\n      const sharpness = 0.0;\n      for (let i = 0; i < size; i += 4) {\n        model.nodes.push({\n          x: colorMap.RGBPoints[i],\n          r: colorMap.RGBPoints[i + 1],\n          g: colorMap.RGBPoints[i + 2],\n          b: colorMap.RGBPoints[i + 3],\n          midpoint,\n          sharpness\n        });\n      }\n    }\n    const modifiedInvoked = publicAPI.sortAndUpdateRange();\n    const callModified = !modifiedInvoked && (isModified || oldNodes !== JSON.stringify(model.nodes));\n    if (callModified) publicAPI.modified();\n    return modifiedInvoked || callModified;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  clamping: true,\n  colorSpace: ColorSpace.RGB,\n  hSVWrap: true,\n  scale: Scale.LINEAR,\n  nanColor: null,\n  belowRangeColor: null,\n  aboveRangeColor: null,\n  useAboveRangeColor: false,\n  useBelowRangeColor: false,\n  allowDuplicateScalars: false,\n  table: null,\n  tableSize: 0,\n  buildTime: null,\n  nodes: null,\n  discretize: false,\n  numberOfValues: 256\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkScalarsToColors.extend(publicAPI, model, initialValues);\n\n  // Internal objects initialization\n  model.table = [];\n  model.nodes = [];\n  model.nanColor = [0.5, 0.0, 0.0, 1.0];\n  model.belowRangeColor = [0.0, 0.0, 0.0, 1.0];\n  model.aboveRangeColor = [1.0, 1.0, 1.0, 1.0];\n  model.buildTime = {};\n  macro.obj(model.buildTime);\n\n  // Create get-only macros\n  macro.get(publicAPI, model, ['buildTime', 'mappingRange']);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['useAboveRangeColor', 'useBelowRangeColor', 'colorSpace', 'discretize', 'numberOfValues']);\n  macro.setArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor'], 4);\n\n  // Create get macros for array\n  macro.getArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkColorTransferFunction(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkColorTransferFunction');\n\n// ----------------------------------------------------------------------------\n\nvar vtkColorTransferFunction$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\nexport { vtkColorTransferFunction$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","h","hsv2rgb","i","isNan","H","floor","I","isInf","J","rgb2hsv","K","rgb2lab","L","lab2rgb","vtkScalarsToColors","Constants","ColorSpace","Scale","ScalarMappingTarget","vtkDebugMacro","vtkErrorMacro","vtkWarningMacro","vtkColorTransferFunctionLabToMsh","lab","msh","a","b","M","Math","sqrt","s","acos","atan2","vtkColorTransferFunctionMshToLab","cos","sin","vtkColorTransferFunctionAdjustHue","unsatM","hueSpin","PI","vtkColorTransferFunctionAngleDiff","a1","a2","adiff","vtkColorTransferFunctionInterpolateDiverging","rgb1","rgb2","result","lab1","lab2","msh1","msh2","localS","Mmid","max","mshTmp","labTmp","vtkColorTransferFunction","publicAPI","model","classHierarchy","push","getSize","nodes","length","addRGBPoint","x","r","g","addRGBPointLong","midpoint","arguments","undefined","sharpness","allowDuplicateScalars","removePoint","node","sortAndUpdateRange","addHSVPoint","v","addHSVPointLong","rgb","hsv","setNodes","before","JSON","stringify","after","modified","sort","modifiedInvoked","updateRange","oldRange","mappingRange","size","retVal","splice","movePoint","oldX","newX","removeAllPoints","addRGBSegment","x1","r1","g1","b1","x2","r2","g2","b2","addHSVSegment","h1","s1","v1","h2","s2","v2","hsv1","hsv2","mapValue","getColor","indexedLookup","numNodes","idx","getAnnotatedValueIndexInternal","nanColor","getNanColorByReference","nodeVal","getNodeValue","getTable","getRedValue","getGreenValue","getBlueValue","xStart_","xEnd_","table","xStart","Number","xEnd","lastR","lastG","lastB","tmpVec","usingLogScale","scale","LOG10","logStart","logEnd","logX","log10","tidx","discretize","range","numberOfValues","deltaRange","xn","discretizeIndex","clamping","getUseAboveRangeColor","aboveRangeColor","getUseBelowRangeColor","belowRangeColor","abs","colorSpace","RGB","HSV","hSVWrap","hsvTmp","LAB","DIVERGING","ss","sss","h3","h4","slope","t","j","getUint8Table","withAlpha","getMTime","buildTime","tableSize","tableWithAlpha","nbChannels","Uint8Array","tmpTable","buildFunctionFromArray","array","numComponents","getNumberOfComponents","getNumberOfTuples","getComponent","buildFunctionFromTable","inc","index","val","setNodeValue","getNumberOfAvailableColors","getIndexedColor","rgba","n","nodeValue","fillFromDataPointer","nb","ptr","setMappingRange","min","originalRange","getRange","shift","adjustRange","functionRange","estimateMinNumberOfSamples","d","findMinimumXDistance","ceil","distance","MAX_VALUE","currentDist","mapScalarsThroughTable","input","output","outFormat","inputOffset","mapDataIndexed","mapData","alpha","getAlpha","inIncr","outputV","getData","inputV","RGBA","LUMINANCE","LUMINANCE_ALPHA","applyColorMap","colorMap","oldColorSpace","toUpperCase","isModified","oldNanColor","NanColor","concat","oldNodes","RGBPoints","callModified","DEFAULT_VALUES","LINEAR","useAboveRangeColor","useBelowRangeColor","extend","initialValues","Object","assign","obj","get","setGet","setArray","getArray","newInstance","vtkColorTransferFunction$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport { h as hsv2rgb, i as isNan, H as floor, I as isInf, J as rgb2hsv, K as rgb2lab, L as lab2rgb } from '../../Common/Core/Math/index.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors.js';\nimport Constants from './ColorTransferFunction/Constants.js';\n\nconst {\n  ColorSpace,\n  Scale\n} = Constants;\nconst {\n  ScalarMappingTarget\n} = vtkScalarsToColors;\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n/* eslint-disable no-continue                                                */\n\n// Convert to and from a special polar version of CIELAB (useful for creating\n// continuous diverging color maps).\nfunction vtkColorTransferFunctionLabToMsh(lab, msh) {\n  const L = lab[0];\n  const a = lab[1];\n  const b = lab[2];\n  const M = Math.sqrt(L * L + a * a + b * b);\n  const s = M > 0.001 ? Math.acos(L / M) : 0.0;\n  const h = s > 0.001 ? Math.atan2(b, a) : 0.0;\n  msh[0] = M;\n  msh[1] = s;\n  msh[2] = h;\n}\nfunction vtkColorTransferFunctionMshToLab(msh, lab) {\n  const M = msh[0];\n  const s = msh[1];\n  const h = msh[2];\n  lab[0] = M * Math.cos(s);\n  lab[1] = M * Math.sin(s) * Math.cos(h);\n  lab[2] = M * Math.sin(s) * Math.sin(h);\n}\n\n// For the case when interpolating from a saturated color to an unsaturated\n// color, find a hue for the unsaturated color that makes sense.\nfunction vtkColorTransferFunctionAdjustHue(msh, unsatM) {\n  if (msh[0] >= unsatM - 0.1) {\n    // The best we can do is hold hue constant.\n    return msh[2];\n  }\n\n  // This equation is designed to make the perceptual change of the\n  // interpolation to be close to constant.\n  const hueSpin = msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0]) / (msh[0] * Math.sin(msh[1]));\n  // Spin hue away from 0 except in purple hues.\n  if (msh[2] > -0.3 * Math.PI) {\n    return msh[2] + hueSpin;\n  }\n  return msh[2] - hueSpin;\n}\nfunction vtkColorTransferFunctionAngleDiff(a1, a2) {\n  let adiff = a1 - a2;\n  if (adiff < 0.0) {\n    adiff = -adiff;\n  }\n  while (adiff >= 2.0 * Math.PI) {\n    adiff -= 2.0 * Math.PI;\n  }\n  if (adiff > Math.PI) {\n    adiff = 2.0 * Math.PI - adiff;\n  }\n  return adiff;\n}\n\n// Interpolate a diverging color map.\nfunction vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {\n  const lab1 = [];\n  const lab2 = [];\n  rgb2lab(rgb1, lab1);\n  rgb2lab(rgb2, lab2);\n  const msh1 = [];\n  const msh2 = [];\n  vtkColorTransferFunctionLabToMsh(lab1, msh1);\n  vtkColorTransferFunctionLabToMsh(lab2, msh2);\n\n  // If the endpoints are distinct saturated colors, then place white in between\n  // them.\n  let localS = s;\n  if (msh1[1] > 0.05 && msh2[1] > 0.05 && vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI) {\n    // Insert the white midpoint by setting one end to white and adjusting the\n    // scalar value.\n    let Mmid = Math.max(msh1[0], msh2[0]);\n    Mmid = Math.max(88.0, Mmid);\n    if (s < 0.5) {\n      msh2[0] = Mmid;\n      msh2[1] = 0.0;\n      msh2[2] = 0.0;\n      localS *= 2.0;\n    } else {\n      msh1[0] = Mmid;\n      msh1[1] = 0.0;\n      msh1[2] = 0.0;\n      localS = 2.0 * localS - 1.0;\n    }\n  }\n\n  // If one color has no saturation, then its hue value is invalid.  In this\n  // case, we want to set it to something logical so that the interpolation of\n  // hue makes sense.\n  if (msh1[1] < 0.05 && msh2[1] > 0.05) {\n    msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);\n  } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {\n    msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);\n  }\n  const mshTmp = [];\n  mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];\n  mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];\n  mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2];\n\n  // Now convert back to RGB\n  const labTmp = [];\n  vtkColorTransferFunctionMshToLab(mshTmp, labTmp);\n  lab2rgb(labTmp, result);\n}\n\n// ----------------------------------------------------------------------------\n// vtkColorTransferFunction methods\n// ----------------------------------------------------------------------------\n\nfunction vtkColorTransferFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkColorTransferFunction');\n\n  // Return the number of points which specify this function\n  publicAPI.getSize = () => model.nodes.length;\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n  publicAPI.addRGBPoint = (x, r, g, b) => publicAPI.addRGBPointLong(x, r, g, b, 0.5, 0.0);\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n  publicAPI.addRGBPointLong = function (x, r, g, b) {\n    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    // remove any node already at this X location\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    }\n\n    // Create the new node\n    const node = {\n      x,\n      r,\n      g,\n      b,\n      midpoint,\n      sharpness\n    };\n\n    // Add it, then sort to get everything in order\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange();\n\n    // We need to find the index of the node we just added in order\n    // to return this value\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If we didn't find it, something went horribly wrong so\n    // return -1\n    if (i < model.nodes.length) {\n      return i;\n    }\n    return -1;\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n  publicAPI.addHSVPoint = (x, h, s, v) => publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0.0);\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n  publicAPI.addHSVPointLong = function (x, h, s, v) {\n    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n    const rgb = [];\n    const hsv = [h, s, v];\n    hsv2rgb(hsv, rgb);\n    return publicAPI.addRGBPoint(x, rgb[0], rgb[1], rgb[2], midpoint, sharpness);\n  };\n\n  //----------------------------------------------------------------------------\n  // Set nodes directly\n  publicAPI.setNodes = nodes => {\n    if (model.nodes !== nodes) {\n      const before = JSON.stringify(model.nodes);\n      model.nodes = nodes;\n      const after = JSON.stringify(model.nodes);\n      if (publicAPI.sortAndUpdateRange() || before !== after) {\n        publicAPI.modified();\n        return true;\n      }\n    }\n    return false;\n  };\n\n  //----------------------------------------------------------------------------\n  // Sort the vector in increasing order, then fill in\n  // the Range\n  publicAPI.sortAndUpdateRange = () => {\n    const before = JSON.stringify(model.nodes);\n    model.nodes.sort((a, b) => a.x - b.x);\n    const after = JSON.stringify(model.nodes);\n    const modifiedInvoked = publicAPI.updateRange();\n    // If range is updated, Modified() has been called, don't call it again.\n    if (!modifiedInvoked && before !== after) {\n      publicAPI.modified();\n      return true;\n    }\n    return modifiedInvoked;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.updateRange = () => {\n    const oldRange = [2];\n    oldRange[0] = model.mappingRange[0];\n    oldRange[1] = model.mappingRange[1];\n    const size = model.nodes.length;\n    if (size) {\n      model.mappingRange[0] = model.nodes[0].x;\n      model.mappingRange[1] = model.nodes[size - 1].x;\n    } else {\n      model.mappingRange[0] = 0;\n      model.mappingRange[1] = 0;\n    }\n\n    // If the range is the same, then no need to call Modified()\n    if (oldRange[0] === model.mappingRange[0] && oldRange[1] === model.mappingRange[1]) {\n      return false;\n    }\n    publicAPI.modified();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  // Remove a point\n  publicAPI.removePoint = x => {\n    // First find the node since we need to know its\n    // index as our return value\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n    const retVal = i;\n\n    // If the node doesn't exist, we return -1\n    if (i >= model.nodes.length) {\n      return -1;\n    }\n\n    // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n    let modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n    return retVal;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.movePoint = (oldX, newX) => {\n    if (oldX === newX) {\n      // Nothing to do.\n      return;\n    }\n    publicAPI.removePoint(newX);\n    for (let i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === oldX) {\n        model.nodes[i].x = newX;\n        publicAPI.sortAndUpdateRange();\n        break;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  // Remove all points\n  publicAPI.removeAllPoints = () => {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a line defined in RGB\n  publicAPI.addRGBSegment = (x1, r1, g1, b1, x2, r2, g2, b2) => {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    // Now add the points\n    publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0.0);\n    publicAPI.addRGBPointLong(x2, r2, g2, b2, 0.5, 0.0);\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a line defined in HSV\n  publicAPI.addHSVSegment = (x1, h1, s1, v1, x2, h2, s2, v2) => {\n    const hsv1 = [h1, s1, v1];\n    const hsv2 = [h2, s2, v2];\n    const rgb1 = [];\n    const rgb2 = [];\n    hsv2rgb(hsv1, rgb1);\n    hsv2rgb(hsv2, rgb2);\n    publicAPI.addRGBSegment(x1, rgb1[0], rgb1[1], rgb1[2], x2, rgb2[0], rgb2[1], rgb2[2]);\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the RGBA color evaluated at the specified location\n  publicAPI.mapValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return [Math.floor(255.0 * rgb[0] + 0.5), Math.floor(255.0 * rgb[1] + 0.5), Math.floor(255.0 * rgb[2] + 0.5), 255];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the RGB color evaluated at the specified location\n  publicAPI.getColor = (x, rgb) => {\n    if (model.indexedLookup) {\n      const numNodes = publicAPI.getSize();\n      // todo\n      const idx = publicAPI.getAnnotatedValueIndexInternal(x);\n      if (idx < 0 || numNodes === 0) {\n        const nanColor = publicAPI.getNanColorByReference();\n        rgb[0] = nanColor[0];\n        rgb[1] = nanColor[1];\n        rgb[2] = nanColor[2];\n      } else {\n        const nodeVal = [];\n        publicAPI.getNodeValue(idx % numNodes, nodeVal);\n        // nodeVal[0] is the x value. nodeVal[1...3] is rgb.\n        rgb[0] = nodeVal[1];\n        rgb[1] = nodeVal[2];\n        rgb[2] = nodeVal[3];\n      }\n      return;\n    }\n    publicAPI.getTable(x, x, 1, rgb);\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the red color evaluated at the specified location\n  publicAPI.getRedValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[0];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the green color evaluated at the specified location\n  publicAPI.getGreenValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[1];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the blue color evaluated at the specified location\n  publicAPI.getBlueValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[2];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns a table of RGB colors at regular intervals along the function\n  publicAPI.getTable = (xStart_, xEnd_, size, table) => {\n    // To handle BigInt limitation\n    const xStart = Number(xStart_);\n    const xEnd = Number(xEnd_);\n\n    // Special case: If either the start or end is a NaN, then all any\n    // interpolation done on them is also a NaN.  Therefore, fill the table with\n    // the NaN color.\n    if (isNan(xStart) || isNan(xEnd)) {\n      for (let i = 0; i < size; i++) {\n        table[i * 3 + 0] = model.nanColor[0];\n        table[i * 3 + 1] = model.nanColor[1];\n        table[i * 3 + 2] = model.nanColor[2];\n      }\n      return;\n    }\n    let idx = 0;\n    const numNodes = model.nodes.length;\n\n    // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n    let lastR = 0.0;\n    let lastG = 0.0;\n    let lastB = 0.0;\n    if (numNodes !== 0) {\n      lastR = model.nodes[numNodes - 1].r;\n      lastG = model.nodes[numNodes - 1].g;\n      lastB = model.nodes[numNodes - 1].b;\n    }\n    let x = 0.0;\n    let x1 = 0.0;\n    let x2 = 0.0;\n    const rgb1 = [0.0, 0.0, 0.0];\n    const rgb2 = [0.0, 0.0, 0.0];\n    let midpoint = 0.0;\n    let sharpness = 0.0;\n    const tmpVec = [];\n\n    // If the scale is logarithmic, make sure the range is valid.\n    let usingLogScale = model.scale === Scale.LOG10;\n    if (usingLogScale) {\n      // Note: This requires range[0] <= range[1].\n      usingLogScale = model.mappingRange[0] > 0.0;\n    }\n    let logStart = 0.0;\n    let logEnd = 0.0;\n    let logX = 0.0;\n    if (usingLogScale) {\n      logStart = Math.log10(xStart);\n      logEnd = Math.log10(xEnd);\n    }\n\n    // For each table entry\n    for (let i = 0; i < size; i++) {\n      // Find our location in the table\n      const tidx = 3 * i;\n\n      // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n      if (size > 1) {\n        if (usingLogScale) {\n          logX = logStart + i / (size - 1.0) * (logEnd - logStart);\n          x = 10.0 ** logX;\n        } else {\n          x = xStart + i / (size - 1.0) * (xEnd - xStart);\n        }\n      } else if (usingLogScale) {\n        logX = 0.5 * (logStart + logEnd);\n        x = 10.0 ** logX;\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      }\n\n      // Linearly map x from mappingRange to [0, numberOfValues-1],\n      // discretize (round down to the closest integer),\n      // then map back to mappingRange\n      if (model.discretize) {\n        const range = model.mappingRange;\n        if (x >= range[0] && x <= range[1]) {\n          const numberOfValues = model.numberOfValues;\n          const deltaRange = range[1] - range[0];\n          if (numberOfValues <= 1) {\n            x = range[0] + deltaRange / 2.0;\n          } else {\n            // normalize x\n            const xn = (x - range[0]) / deltaRange;\n            // discretize\n            const discretizeIndex = floor(numberOfValues * xn);\n            // get discretized x\n            x = range[0] + discretizeIndex / (numberOfValues - 1) * deltaRange;\n          }\n        }\n      }\n\n      // Do we need to move to the next node?\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++;\n        // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n          if (usingLogScale) {\n            x1 = Math.log10(x1);\n            x2 = Math.log10(x2);\n          }\n          rgb1[0] = model.nodes[idx - 1].r;\n          rgb2[0] = model.nodes[idx].r;\n          rgb1[1] = model.nodes[idx - 1].g;\n          rgb2[1] = model.nodes[idx].g;\n          rgb1[2] = model.nodes[idx - 1].b;\n          rgb2[2] = model.nodes[idx].b;\n\n          // We only need the previous midpoint and sharpness\n          // since these control this region\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness;\n\n          // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      }\n\n      // Are we at or past the end? If so, just use the last value\n      if (x > model.mappingRange[1]) {\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n        if (model.clamping) {\n          if (publicAPI.getUseAboveRangeColor()) {\n            table[tidx] = model.aboveRangeColor[0];\n            table[tidx + 1] = model.aboveRangeColor[1];\n            table[tidx + 2] = model.aboveRangeColor[2];\n          } else {\n            table[tidx] = lastR;\n            table[tidx + 1] = lastG;\n            table[tidx + 2] = lastB;\n          }\n        }\n      } else if (x < model.mappingRange[0] || isInf(x) && x < 0) {\n        // we are before the first node? If so, duplicate this node's values.\n        // We have to deal with -inf here\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n        if (model.clamping) {\n          if (publicAPI.getUseBelowRangeColor()) {\n            table[tidx] = model.belowRangeColor[0];\n            table[tidx + 1] = model.belowRangeColor[1];\n            table[tidx + 2] = model.belowRangeColor[2];\n          } else if (numNodes > 0) {\n            table[tidx] = model.nodes[0].r;\n            table[tidx + 1] = model.nodes[0].g;\n            table[tidx + 2] = model.nodes[0].b;\n          }\n        }\n      } else if (idx === 0 && (Math.abs(x - xStart) < 1e-6 || model.discretize)) {\n        if (numNodes > 0) {\n          table[tidx] = model.nodes[0].r;\n          table[tidx + 1] = model.nodes[0].g;\n          table[tidx + 2] = model.nodes[0].b;\n        } else {\n          table[tidx] = 0.0;\n          table[tidx + 1] = 0.0;\n          table[tidx + 2] = 0.0;\n        }\n      } else {\n        // OK, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        let s = 0.0;\n        if (usingLogScale) {\n          s = (logX - x1) / (x2 - x1);\n        } else {\n          s = (x - x1) / (x2 - x1);\n        }\n\n        // Readjust based on the midpoint - linear adjustment\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        }\n\n        // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = rgb1[0];\n            table[tidx + 1] = rgb1[1];\n            table[tidx + 2] = rgb1[2];\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = rgb2[0];\n            table[tidx + 1] = rgb2[1];\n            table[tidx + 2] = rgb2[2];\n            continue;\n          }\n        }\n\n        // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          if (model.colorSpace === ColorSpace.RGB) {\n            table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];\n            table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];\n            table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];\n          } else if (model.colorSpace === ColorSpace.HSV) {\n            const hsv1 = [];\n            const hsv2 = [];\n            rgb2hsv(rgb1, hsv1);\n            rgb2hsv(rgb2, hsv2);\n            if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {\n              if (hsv1[0] > hsv2[0]) {\n                hsv1[0] -= 1.0;\n              } else {\n                hsv2[0] -= 1.0;\n              }\n            }\n            const hsvTmp = [];\n            hsvTmp[0] = (1.0 - s) * hsv1[0] + s * hsv2[0];\n            if (hsvTmp[0] < 0.0) {\n              hsvTmp[0] += 1.0;\n            }\n            hsvTmp[1] = (1.0 - s) * hsv1[1] + s * hsv2[1];\n            hsvTmp[2] = (1.0 - s) * hsv1[2] + s * hsv2[2];\n\n            // Now convert this back to RGB\n            hsv2rgb(hsvTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.LAB) {\n            const lab1 = [];\n            const lab2 = [];\n            rgb2lab(rgb1, lab1);\n            rgb2lab(rgb2, lab2);\n            const labTmp = [];\n            labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];\n            labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];\n            labTmp[2] = (1 - s) * lab1[2] + s * lab2[2];\n\n            // Now convert back to RGB\n            lab2rgb(labTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.DIVERGING) {\n            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else {\n            vtkErrorMacro('ColorSpace set to invalid value.', model.colorSpace);\n          }\n          continue;\n        }\n\n        // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n        if (s < 0.5) {\n          s = 0.5 * (s * 2.0) ** (1.0 + 10.0 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10.0 * sharpness);\n        }\n\n        // Compute some coefficients we will need for the hermite curve\n        const ss = s * s;\n        const sss = ss * s;\n        const h1 = 2.0 * sss - 3 * ss + 1;\n        const h2 = -2 * sss + 3 * ss;\n        const h3 = sss - 2 * ss + s;\n        const h4 = sss - ss;\n        let slope;\n        let t;\n        if (model.colorSpace === ColorSpace.RGB) {\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = rgb2[j] - rgb1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;\n          }\n        } else if (model.colorSpace === ColorSpace.HSV) {\n          const hsv1 = [];\n          const hsv2 = [];\n          rgb2hsv(rgb1, hsv1);\n          rgb2hsv(rgb2, hsv2);\n          if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {\n            if (hsv1[0] > hsv2[0]) {\n              hsv1[0] -= 1.0;\n            } else {\n              hsv2[0] -= 1.0;\n            }\n          }\n          const hsvTmp = [];\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = hsv2[j] - hsv1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            hsvTmp[j] = h1 * hsv1[j] + h2 * hsv2[j] + h3 * t + h4 * t;\n            if (j === 0 && hsvTmp[j] < 0.0) {\n              hsvTmp[j] += 1.0;\n            }\n          }\n          // Now convert this back to RGB\n          hsv2rgb(hsvTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.LAB) {\n          const lab1 = [];\n          const lab2 = [];\n          rgb2lab(rgb1, lab1);\n          rgb2lab(rgb2, lab2);\n          const labTmp = [];\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = lab2[j] - lab1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            labTmp[j] = h1 * lab1[j] + h2 * lab2[j] + h3 * t + h4 * t;\n          }\n          // Now convert this back to RGB\n          lab2rgb(labTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.DIVERGING) {\n          // I have not implemented proper interpolation by a hermite curve for\n          // the diverging color map, but I cannot think of a good use case for\n          // that anyway.\n          vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else {\n          vtkErrorMacro('ColorSpace set to invalid value.');\n        }\n\n        // Final error check to make sure we don't go outside [0,1]\n        for (let j = 0; j < 3; j++) {\n          table[tidx + j] = table[tidx + j] < 0.0 ? 0.0 : table[tidx + j];\n          table[tidx + j] = table[tidx + j] > 1.0 ? 1.0 : table[tidx + j];\n        }\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getUint8Table = function (xStart, xEnd, size) {\n    let withAlpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (publicAPI.getMTime() <= model.buildTime && model.tableSize === size && model.tableWithAlpha !== withAlpha) {\n      return model.table;\n    }\n    if (model.nodes.length === 0) {\n      vtkErrorMacro('Attempting to lookup a value with no points in the function');\n      return model.table;\n    }\n    const nbChannels = withAlpha ? 4 : 3;\n    if (model.tableSize !== size || model.tableWithAlpha !== withAlpha) {\n      model.table = new Uint8Array(size * nbChannels);\n      model.tableSize = size;\n      model.tableWithAlpha = withAlpha;\n    }\n    const tmpTable = [];\n    publicAPI.getTable(xStart, xEnd, size, tmpTable);\n    for (let i = 0; i < size; i++) {\n      model.table[i * nbChannels + 0] = Math.floor(tmpTable[i * 3 + 0] * 255.0 + 0.5);\n      model.table[i * nbChannels + 1] = Math.floor(tmpTable[i * 3 + 1] * 255.0 + 0.5);\n      model.table[i * nbChannels + 2] = Math.floor(tmpTable[i * 3 + 2] * 255.0 + 0.5);\n      if (withAlpha) {\n        model.table[i * nbChannels + 3] = 255;\n      }\n    }\n    model.buildTime.modified();\n    return model.table;\n  };\n  publicAPI.buildFunctionFromArray = array => {\n    publicAPI.removeAllPoints();\n    const numComponents = array.getNumberOfComponents();\n    for (let i = 0; i < array.getNumberOfTuples(); i++) {\n      switch (numComponents) {\n        case 3:\n          {\n            model.nodes.push({\n              x: i,\n              r: array.getComponent(i, 0),\n              g: array.getComponent(i, 1),\n              b: array.getComponent(i, 2),\n              midpoint: 0.5,\n              sharpness: 0.0\n            });\n            break;\n          }\n        case 4:\n          {\n            model.nodes.push({\n              x: array.getComponent(i, 0),\n              r: array.getComponent(i, 1),\n              g: array.getComponent(i, 2),\n              b: array.getComponent(i, 3),\n              midpoint: 0.5,\n              sharpness: 0.0\n            });\n            break;\n          }\n        case 5:\n          {\n            model.nodes.push({\n              x: i,\n              r: array.getComponent(i, 0),\n              g: array.getComponent(i, 1),\n              b: array.getComponent(i, 2),\n              midpoint: array.getComponent(i, 4),\n              sharpness: array.getComponent(i, 5)\n            });\n            break;\n          }\n        case 6:\n          {\n            model.nodes.push({\n              x: array.getComponent(i, 0),\n              r: array.getComponent(i, 1),\n              g: array.getComponent(i, 2),\n              b: array.getComponent(i, 3),\n              midpoint: array.getComponent(i, 4),\n              sharpness: array.getComponent(i, 5)\n            });\n            break;\n          }\n      }\n    }\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.buildFunctionFromTable = (xStart, xEnd, size, table) => {\n    let inc = 0.0;\n    publicAPI.removeAllPoints();\n    if (size > 1) {\n      inc = (xEnd - xStart) / (size - 1.0);\n    }\n    for (let i = 0; i < size; i++) {\n      const node = {\n        x: xStart + inc * i,\n        r: table[i * 3],\n        g: table[i * 3 + 1],\n        b: table[i * 3 + 2],\n        sharpness: 0.0,\n        midpoint: 0.5\n      };\n      model.nodes.push(node);\n    }\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n  publicAPI.getNodeValue = (index, val) => {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].r;\n    val[2] = model.nodes[index].g;\n    val[3] = model.nodes[index].b;\n    val[4] = model.nodes[index].midpoint;\n    val[5] = model.nodes[index].sharpness;\n    return 1;\n  };\n\n  //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n  publicAPI.setNodeValue = (index, val) => {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    const oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].r = val[1];\n    model.nodes[index].g = val[2];\n    model.nodes[index].b = val[3];\n    model.nodes[index].midpoint = val[4];\n    model.nodes[index].sharpness = val[5];\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange();\n      // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n    return 1;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getNumberOfAvailableColors = () => {\n    if (model.indexedLookup && publicAPI.getSize()) {\n      return publicAPI.getSize();\n    }\n    if (model.tableSize) {\n      // Not sure if this is correct since it is only set if\n      // \"const unsigned char *::GetTable(double xStart, double xEnd,int size)\"\n      // has been called.\n      return model.tableSize;\n    }\n    return 16777216; // 2^24\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getIndexedColor = (idx, rgba) => {\n    const n = publicAPI.getSize();\n    if (n > 0 && idx >= 0) {\n      const nodeValue = [];\n      publicAPI.getNodeValue(idx % n, nodeValue);\n      for (let j = 0; j < 3; ++j) {\n        rgba[j] = nodeValue[j + 1];\n      }\n      rgba[3] = 1.0; // NodeColor is RGB-only.\n      return;\n    }\n    const nanColor = publicAPI.getNanColorByReference();\n    rgba[0] = nanColor[0];\n    rgba[1] = nanColor[1];\n    rgba[2] = nanColor[2];\n    rgba[3] = 1.0; // NanColor is RGB-only.\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.fillFromDataPointer = (nb, ptr) => {\n    if (nb <= 0 || !ptr) {\n      return;\n    }\n    publicAPI.removeAllPoints();\n    for (let i = 0; i < nb; i++) {\n      publicAPI.addRGBPoint(ptr[i * 4], ptr[i * 4 + 1], ptr[i * 4 + 2], ptr[i * 4 + 3]);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.setMappingRange = (min, max) => {\n    const range = [min, max];\n    const originalRange = publicAPI.getRange();\n    if (originalRange[1] === range[1] && originalRange[0] === range[0]) {\n      return;\n    }\n    if (range[1] === range[0]) {\n      vtkErrorMacro('attempt to set zero width color range');\n      return;\n    }\n    const scale = (range[1] - range[0]) / (originalRange[1] - originalRange[0]);\n    const shift = range[0] - originalRange[0] * scale;\n    for (let i = 0; i < model.nodes.length; ++i) {\n      model.nodes[i].x = model.nodes[i].x * scale + shift;\n    }\n    model.mappingRange[0] = range[0];\n    model.mappingRange[1] = range[1];\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.adjustRange = range => {\n    const functionRange = publicAPI.getRange();\n\n    // Make sure we have points at each end of the range\n    const rgb = [];\n    if (functionRange[0] < range[0]) {\n      publicAPI.getColor(range[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    }\n    if (functionRange[1] > range[1]) {\n      publicAPI.getColor(range[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    }\n\n    // Remove all points out-of-range\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n    return 1;\n  };\n\n  //--------------------------------------------------------------------------\n  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {\n    const d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.findMinimumXDistance = () => {\n    if (model.nodes.length < 2) {\n      return -1.0;\n    }\n    let distance = Number.MAX_VALUE;\n    for (let i = 0; i < model.nodes.length - 1; i++) {\n      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n    return distance;\n  };\n  publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {\n    if (publicAPI.getSize() === 0) {\n      vtkDebugMacro('Transfer Function Has No Points!');\n      return;\n    }\n    if (model.indexedLookup) {\n      publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);\n    } else {\n      publicAPI.mapData(input, output, outFormat, inputOffset);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.mapData = (input, output, outFormat, inputOffset) => {\n    if (publicAPI.getSize() === 0) {\n      vtkWarningMacro('Transfer Function Has No Points!');\n      return;\n    }\n    const alpha = Math.floor(publicAPI.getAlpha() * 255.0 + 0.5);\n    const length = input.getNumberOfTuples();\n    const inIncr = input.getNumberOfComponents();\n    const outputV = output.getData();\n    const inputV = input.getData();\n    const rgb = [];\n    if (outFormat === ScalarMappingTarget.RGBA) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 4] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 4 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 4 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n        outputV[i * 4 + 3] = alpha;\n      }\n    }\n    if (outFormat === ScalarMappingTarget.RGB) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 3] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 3 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 3 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n      }\n    }\n    if (outFormat === ScalarMappingTarget.LUMINANCE) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n      }\n    }\n    if (outFormat === ScalarMappingTarget.LUMINANCE_ALPHA) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 2] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n        outputV[i * 2 + 1] = alpha;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.applyColorMap = colorMap => {\n    const oldColorSpace = JSON.stringify(model.colorSpace);\n    if (colorMap.ColorSpace) {\n      model.colorSpace = ColorSpace[colorMap.ColorSpace.toUpperCase()];\n      if (model.colorSpace === undefined) {\n        vtkErrorMacro(`ColorSpace ${colorMap.ColorSpace} not supported, using RGB instead`);\n        model.colorSpace = ColorSpace.RGB;\n      }\n    }\n    let isModified = oldColorSpace !== JSON.stringify(model.colorSpace);\n    const oldNanColor = isModified || JSON.stringify(model.nanColor);\n    if (colorMap.NanColor) {\n      model.nanColor = [].concat(colorMap.NanColor);\n      while (model.nanColor.length < 4) {\n        model.nanColor.push(1.0);\n      }\n    }\n    isModified = isModified || oldNanColor !== JSON.stringify(model.nanColor);\n    const oldNodes = isModified || JSON.stringify(model.nodes);\n    if (colorMap.RGBPoints) {\n      const size = colorMap.RGBPoints.length;\n      model.nodes = [];\n      const midpoint = 0.5;\n      const sharpness = 0.0;\n      for (let i = 0; i < size; i += 4) {\n        model.nodes.push({\n          x: colorMap.RGBPoints[i],\n          r: colorMap.RGBPoints[i + 1],\n          g: colorMap.RGBPoints[i + 2],\n          b: colorMap.RGBPoints[i + 3],\n          midpoint,\n          sharpness\n        });\n      }\n    }\n    const modifiedInvoked = publicAPI.sortAndUpdateRange();\n    const callModified = !modifiedInvoked && (isModified || oldNodes !== JSON.stringify(model.nodes));\n    if (callModified) publicAPI.modified();\n    return modifiedInvoked || callModified;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  clamping: true,\n  colorSpace: ColorSpace.RGB,\n  hSVWrap: true,\n  scale: Scale.LINEAR,\n  nanColor: null,\n  belowRangeColor: null,\n  aboveRangeColor: null,\n  useAboveRangeColor: false,\n  useBelowRangeColor: false,\n  allowDuplicateScalars: false,\n  table: null,\n  tableSize: 0,\n  buildTime: null,\n  nodes: null,\n  discretize: false,\n  numberOfValues: 256\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkScalarsToColors.extend(publicAPI, model, initialValues);\n\n  // Internal objects initialization\n  model.table = [];\n  model.nodes = [];\n  model.nanColor = [0.5, 0.0, 0.0, 1.0];\n  model.belowRangeColor = [0.0, 0.0, 0.0, 1.0];\n  model.aboveRangeColor = [1.0, 1.0, 1.0, 1.0];\n  model.buildTime = {};\n  macro.obj(model.buildTime);\n\n  // Create get-only macros\n  macro.get(publicAPI, model, ['buildTime', 'mappingRange']);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['useAboveRangeColor', 'useBelowRangeColor', 'colorSpace', 'discretize', 'numberOfValues']);\n  macro.setArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor'], 4);\n\n  // Create get macros for array\n  macro.getArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkColorTransferFunction(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkColorTransferFunction');\n\n// ----------------------------------------------------------------------------\n\nvar vtkColorTransferFunction$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\nexport { vtkColorTransferFunction$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}