"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBoundingBoxAroundShapeWorld = exports.getBoundingBoxAroundShapeIJK = void 0;
const core_1 = require("@cornerstonejs/core");
const { EPSILON } = core_1.CONSTANTS;
function calculateBoundingBox(points, dimensions, isWorld = false) {
    var _a, _b, _c;
    let xMin = Infinity;
    let xMax = isWorld ? -Infinity : 0;
    let yMin = Infinity;
    let yMax = isWorld ? -Infinity : 0;
    let zMin = Infinity;
    let zMax = isWorld ? -Infinity : 0;
    const is3D = ((_a = points[0]) === null || _a === void 0 ? void 0 : _a.length) === 3;
    for (let i = 0; i < points.length; i++) {
        const p = points[i];
        xMin = Math.min(p[0], xMin);
        xMax = Math.max(p[0], xMax);
        yMin = Math.min(p[1], yMin);
        yMax = Math.max(p[1], yMax);
        if (is3D) {
            zMin = Math.min((_b = p[2]) !== null && _b !== void 0 ? _b : zMin, zMin);
            zMax = Math.max((_c = p[2]) !== null && _c !== void 0 ? _c : zMax, zMax);
        }
    }
    if (dimensions) {
        xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);
        xMax = Math.min(isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1, xMax);
        yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);
        yMax = Math.min(isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1, yMax);
        if (is3D && dimensions.length === 3) {
            zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);
            zMax = Math.min(isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1, zMax);
        }
    }
    else if (!isWorld) {
        xMin = Math.max(0, xMin);
        xMax = Math.min(Infinity, xMax);
        yMin = Math.max(0, yMin);
        yMax = Math.min(Infinity, yMax);
        if (is3D) {
            zMin = Math.max(0, zMin);
            zMax = Math.min(Infinity, zMax);
        }
    }
    return is3D
        ? [
            [xMin, xMax],
            [yMin, yMax],
            [zMin, zMax],
        ]
        : [[xMin, xMax], [yMin, yMax], null];
}
function getBoundingBoxAroundShapeIJK(points, dimensions) {
    return calculateBoundingBox(points, dimensions, false);
}
exports.getBoundingBoxAroundShapeIJK = getBoundingBoxAroundShapeIJK;
function getBoundingBoxAroundShapeWorld(points, clipBounds) {
    return calculateBoundingBox(points, clipBounds, true);
}
exports.getBoundingBoxAroundShapeWorld = getBoundingBoxAroundShapeWorld;
//# sourceMappingURL=getBoundingBoxAroundShape.js.map