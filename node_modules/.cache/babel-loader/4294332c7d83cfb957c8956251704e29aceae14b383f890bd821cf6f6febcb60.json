{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { n as newInstance$1, o as obj, e as setGet, h as chain, c as macro } from '../../macros2.js';\nimport { mat4, mat3, vec3 } from 'gl-matrix';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport vtkHelper from './Helper.js';\nimport { u as uninitializeBounds } from '../../Common/Core/Math/index.js';\nimport vtkOpenGLFramebuffer from './Framebuffer.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkVertexArrayObject from './VertexArrayObject.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { Wrap, Filter } from './Texture/Constants.js';\nimport { InterpolationType, OpacityMode } from '../Core/VolumeProperty/Constants.js';\nimport { BlendMode } from '../Core/VolumeMapper/Constants.js';\nimport { v as vtkVolumeVS } from './glsl/vtkVolumeVS.glsl.js';\nimport { v as vtkVolumeFS } from './glsl/vtkVolumeFS.glsl.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nconst {\n  vtkWarningMacro,\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n// TODO: Do we want this in some shared utility? Shouldwe just use lodash.isEqual\nfunction arrayEquals(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction computeFnToString(property, pwfun, numberOfComponents) {\n  if (pwfun) {\n    const iComps = property.getIndependentComponents();\n    return `${pwfun.getMTime()}-${iComps}-${numberOfComponents}`;\n  }\n  return '0';\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLVolumeMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLVolumeMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLVolumeMapper');\n  publicAPI.buildPass = () => {\n    model.zBufferTexture = null;\n  };\n\n  // ohh someone is doing a zbuffer pass, use that for\n  // intermixed volume rendering\n  publicAPI.zBufferPass = (prepass, renderPass) => {\n    if (prepass) {\n      const zbt = renderPass.getZBufferTexture();\n      if (zbt !== model.zBufferTexture) {\n        model.zBufferTexture = zbt;\n      }\n    }\n  };\n  publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.zBufferPass(prepass, renderPass);\n\n  // Renders myself\n  publicAPI.volumePass = (prepass, renderPass) => {\n    if (prepass) {\n      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderWindow');\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.jitterTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);\n\n      // Per Component?\n      model.scalarTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.opacityTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.labelOutlineThicknessTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.openGLVolume = publicAPI.getFirstAncestorOfType('vtkOpenGLVolume');\n      const actor = model.openGLVolume.getRenderable();\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      const ren = model._openGLRenderer.getRenderable();\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());\n      publicAPI.renderPiece(ren, actor);\n    }\n  };\n  publicAPI.buildShaders = (shaders, ren, actor) => {\n    publicAPI.getShaderTemplate(shaders, ren, actor);\n    publicAPI.replaceShaderValues(shaders, ren, actor);\n  };\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkVolumeVS;\n    shaders.Fragment = vtkVolumeFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    let FSSource = shaders.Fragment;\n\n    // define some values in the shader\n    const iType = actor.getProperty().getInterpolationType();\n    if (iType === InterpolationType.LINEAR) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TrilinearOn', '#define vtkTrilinearOn').result;\n    }\n    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();\n    if (vtkImageLabelOutline === true) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ImageLabelOutlineOn', '#define vtkImageLabelOutlineOn').result;\n    }\n    const numComp = model.scalarTexture.getComponents();\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::NumComponents', `#define vtkNumComponents ${numComp}`).result;\n    const iComps = actor.getProperty().getIndependentComponents();\n    if (iComps) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::IndependentComponentsOn', '#define vtkIndependentComponentsOn').result;\n\n      // Define any proportional components\n      const proportionalComponents = [];\n      for (let nc = 0; nc < numComp; nc++) {\n        if (actor.getProperty().getOpacityMode(nc) === OpacityMode.PROPORTIONAL) {\n          proportionalComponents.push(`#define vtkComponent${nc}Proportional`);\n        }\n      }\n      if (proportionalComponents.length > 0) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::vtkProportionalComponents', proportionalComponents.join('\\n')).result;\n      }\n    }\n\n    // WebGL only supports loops over constants\n    // and does not support while loops so we\n    // have to hard code how many steps/samples to take\n    // We do a break so most systems will gracefully\n    // early terminate, but it is always possible\n    // a system will execute every step regardless\n    const ext = model.currentInput.getSpatialExtent();\n    const spc = model.currentInput.getSpacing();\n    const vsize = new Float64Array(3);\n    vec3.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);\n    const maxSamples = vec3.length(vsize) / publicAPI.getCurrentSampleDistance(ren);\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::MaximumSamplesValue', `${Math.ceil(maxSamples)}`).result;\n\n    // set light complexity\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::LightComplexity', `#define vtkLightComplexity ${model.lastLightComplexity}`).result;\n\n    // set shadow blending flag\n    if (model.lastLightComplexity > 0) {\n      if (model.renderable.getVolumetricScatteringBlending() > 0.0) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::VolumeShadowOn', `#define VolumeShadowOn`).result;\n      }\n      if (model.renderable.getVolumetricScatteringBlending() < 1.0) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::SurfaceShadowOn', `#define SurfaceShadowOn`).result;\n      }\n      if (model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0.0) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::localAmbientOcclusionOn', `#define localAmbientOcclusionOn`).result;\n      }\n    }\n\n    // if using gradient opacity define that\n    model.gopacity = actor.getProperty().getUseGradientOpacity(0);\n    for (let nc = 1; iComps && !model.gopacity && nc < numComp; ++nc) {\n      if (actor.getProperty().getUseGradientOpacity(nc)) {\n        model.gopacity = true;\n      }\n    }\n    if (model.gopacity) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::GradientOpacityOn', '#define vtkGradientOpacityOn').result;\n    }\n\n    // set normal from density\n    if (model.renderable.getComputeNormalFromOpacity()) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::vtkComputeNormalFromOpacity', `#define vtkComputeNormalFromOpacity`).result;\n    }\n\n    // if we have a ztexture then declare it and use it\n    if (model.zBufferTexture !== null) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', ['uniform sampler2D zBufferTexture;', 'uniform float vpZWidth;', 'uniform float vpZHeight;']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));', 'float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;', 'zdepth = zdepth * 2.0 - 1.0;', 'if (cameraParallel == 0) {', 'zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}', 'else {', 'zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\\n', 'zdepth = -zdepth/rayDir.z;', 'dists.y = min(zdepth,dists.y);']).result;\n    }\n\n    // Set the BlendMode approach\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::BlendMode', `${model.renderable.getBlendMode()}`).result;\n    shaders.Fragment = FSSource;\n    publicAPI.replaceShaderLight(shaders, ren, actor);\n    publicAPI.replaceShaderClippingPlane(shaders, ren, actor);\n  };\n  publicAPI.replaceShaderLight = (shaders, ren, actor) => {\n    if (model.lastLightComplexity === 0) {\n      return;\n    }\n    let FSSource = shaders.Fragment;\n    // check for shadow maps - not implemented yet, skip\n    // const shadowFactor = '';\n\n    // to-do: single out the case when complexity = 1\n\n    // only account for lights that are switched on\n    let lightNum = 0;\n    ren.getLights().forEach(light => {\n      if (light.getSwitch()) {\n        lightNum += 1;\n      }\n    });\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', [`uniform int lightNum;`, `uniform bool twoSidedLighting;`, `uniform vec3 lightColor[${lightNum}];`, `uniform vec3 lightDirectionVC[${lightNum}]; // normalized`, `uniform vec3 lightHalfAngleVC[${lightNum}];`, '//VTK::Light::Dec'], false).result;\n    // support any number of lights\n    if (model.lastLightComplexity === 3) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', [`uniform vec3 lightPositionVC[${lightNum}];`, `uniform vec3 lightAttenuation[${lightNum}];`, `uniform float lightConeAngle[${lightNum}];`, `uniform float lightExponent[${lightNum}];`, `uniform int lightPositional[${lightNum}];`], false).result;\n    }\n    if (model.renderable.getVolumetricScatteringBlending() > 0.0) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::VolumeShadow::Dec', [`uniform float volumetricScatteringBlending;`, `uniform float giReach;`, `uniform float volumeShadowSamplingDistFactor;`, `uniform float anisotropy;`, `uniform float anisotropy2;`], false).result;\n    }\n    if (model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0.0) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::LAO::Dec', [`uniform int kernelRadius;`, `uniform vec2 kernelSample[${model.renderable.getLAOKernelRadius()}];`, `uniform int kernelSize;`], false).result;\n    }\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderClippingPlane = (shaders, ren, actor) => {\n    let FSSource = shaders.Fragment;\n    if (model.renderable.getClippingPlanes().length > 0) {\n      const clipPlaneSize = model.renderable.getClippingPlanes().length;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ClipPlane::Dec', [`uniform vec3 vClipPlaneNormals[6];`, `uniform float vClipPlaneDistances[6];`, `uniform vec3 vClipPlaneOrigins[6];`, `uniform int clip_numPlanes;`, '//VTK::ClipPlane::Dec', '#define vtkClippingPlanesOn'], false).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ClipPlane::Impl', [`for(int i = 0; i < ${clipPlaneSize}; i++) {`, '  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);', '  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];', '  if (rayDirRatio == 0.0)', '  {', '    if (equationResult < 0.0) dists.x = dists.y;', '    continue;', '  }', '  float result = -1.0 * equationResult / rayDirRatio;', '  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);', '  else dists.x = max(dists.x, result);', '}', '//VTK::ClipPlane::Impl'], false).result;\n    }\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    // do we need lighting?\n    let lightComplexity = 0;\n    if (actor.getProperty().getShade() && model.renderable.getBlendMode() === BlendMode.COMPOSITE_BLEND) {\n      // consider the lighting complexity to determine which case applies\n      // simple headlight, Light Kit, the whole feature set of VTK\n      lightComplexity = 0;\n      model.numberOfLights = 0;\n      ren.getLights().forEach(light => {\n        const status = light.getSwitch();\n        if (status > 0) {\n          model.numberOfLights++;\n          if (lightComplexity === 0) {\n            lightComplexity = 1;\n          }\n        }\n        if (lightComplexity === 1 && (model.numberOfLights > 1 || light.getIntensity() !== 1.0 || !light.lightTypeIsHeadLight())) {\n          lightComplexity = 2;\n        }\n        if (lightComplexity < 3 && light.getPositional()) {\n          lightComplexity = 3;\n        }\n      });\n    }\n    let needRebuild = false;\n    if (model.lastLightComplexity !== lightComplexity) {\n      model.lastLightComplexity = lightComplexity;\n      needRebuild = true;\n    }\n    const numComp = model.scalarTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n    let usesProportionalComponents = false;\n    const proportionalComponents = [];\n    if (iComps) {\n      // Define any proportional components\n      for (let nc = 0; nc < numComp; nc++) {\n        proportionalComponents.push(actor.getProperty().getOpacityMode(nc));\n      }\n      if (proportionalComponents.length > 0) {\n        usesProportionalComponents = true;\n      }\n    }\n    const ext = model.currentInput.getSpatialExtent();\n    const spc = model.currentInput.getSpacing();\n    const vsize = new Float64Array(3);\n    vec3.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);\n    const maxSamples = vec3.length(vsize) / publicAPI.getCurrentSampleDistance(ren);\n    const state = {\n      interpolationType: actor.getProperty().getInterpolationType(),\n      useLabelOutline: actor.getProperty().getUseLabelOutline(),\n      numComp,\n      usesProportionalComponents,\n      iComps,\n      maxSamples,\n      useGradientOpacity: actor.getProperty().getUseGradientOpacity(0),\n      blendMode: model.renderable.getBlendMode(),\n      proportionalComponents\n    };\n\n    // We only need to rebuild the shader if one of these variables has changed,\n    // since they are used in the shader template replacement step.\n    if (!model.previousState || model.previousState.interpolationType !== state.interpolationType || model.previousState.useLabelOutline !== state.useLabelOutline || model.previousState.numComp !== state.numComp || model.previousState.usesProportionalComponents !== state.usesProportionalComponents || model.previousState.iComps !== state.iComps || model.previousState.maxSamples !== state.maxSamples || model.previousState.useGradientOpacity !== state.useGradientOpacity || model.previousState.blendMode !== state.blendMode || !arrayEquals(model.previousState.proportionalComponents, state.proportionalComponents)) {\n      model.previousState = {\n        ...state\n      };\n      return true;\n    }\n\n    // has something changed that would require us to recreate the shader?\n    if (cellBO.getProgram()?.getHandle() === 0 || needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || !!model.lastZBufferTexture !== !!model.zBufferTexture || cellBO.getShaderSourceTime().getMTime() < publicAPI.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime()) {\n      model.lastZBufferTexture = model.zBufferTexture;\n      return true;\n    }\n    return false;\n  };\n  publicAPI.updateShaders = (cellBO, ren, actor) => {\n    model.lastBoundBO = cellBO;\n\n    // has something changed that would require us to recreate the shader?\n    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {\n      const shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      publicAPI.buildShaders(shaders, ren, actor);\n\n      // compile and bind the program if needed\n      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);\n\n      // if the shader changed reinitialize the VAO\n      if (newShader !== cellBO.getProgram()) {\n        cellBO.setProgram(newShader);\n        // reset the VAO as the shader has changed\n        cellBO.getVAO().releaseGraphicsResources();\n      }\n      cellBO.getShaderSourceTime().modified();\n    } else {\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());\n    }\n    cellBO.getVAO().bind();\n    publicAPI.setMapperShaderParameters(cellBO, ren, actor);\n    publicAPI.setCameraShaderParameters(cellBO, ren, actor);\n    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);\n    publicAPI.getClippingPlaneShaderParameters(cellBO, ren, actor);\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    // Now to update the VAO too, if necessary.\n    const program = cellBO.getProgram();\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      if (program.isAttributeUsed('vertexDC')) {\n        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), 'vertexDC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexDC in shader VAO.');\n        }\n      }\n      cellBO.getAttributeUpdateTime().modified();\n    }\n    program.setUniformi('texture1', model.scalarTexture.getTextureUnit());\n    program.setUniformf('sampleDistance', publicAPI.getCurrentSampleDistance(ren));\n    const volInfo = model.scalarTexture.getVolumeInfo();\n    const ipScalarRange = model.renderable.getIpScalarRange();\n    const minVals = [];\n    const maxVals = [];\n    for (let i = 0; i < 4; i++) {\n      // convert iprange from 0-1 into data range values\n      minVals[i] = ipScalarRange[0] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i];\n      maxVals[i] = ipScalarRange[1] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i];\n      // convert data ranges into texture values\n      minVals[i] = (minVals[i] - volInfo.offset[i]) / volInfo.scale[i];\n      maxVals[i] = (maxVals[i] - volInfo.offset[i]) / volInfo.scale[i];\n    }\n    program.setUniform4f('ipScalarRangeMin', minVals[0], minVals[1], minVals[2], minVals[3]);\n    program.setUniform4f('ipScalarRangeMax', maxVals[0], maxVals[1], maxVals[2], maxVals[3]);\n\n    // if we have a zbuffer texture then set it\n    if (model.zBufferTexture !== null) {\n      program.setUniformi('zBufferTexture', model.zBufferTexture.getTextureUnit());\n      const size = model._useSmallViewport ? [model._smallViewportWidth, model._smallViewportHeight] : model._openGLRenderWindow.getFramebufferSize();\n      program.setUniformf('vpZWidth', size[0]);\n      program.setUniformf('vpZHeight', size[1]);\n    }\n  };\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    // // [WMVP]C == {world, model, view, projection} coordinates\n    // // E.g., WCPC == world to projection coordinate transformation\n    const keyMats = model.openGLCamera.getKeyMatrices(ren);\n    const actMats = model.openGLVolume.getKeyMatrices();\n    mat4.multiply(model.modelToView, keyMats.wcvc, actMats.mcwc);\n    const program = cellBO.getProgram();\n    const cam = model.openGLCamera.getRenderable();\n    const crange = cam.getClippingRange();\n    program.setUniformf('camThick', crange[1] - crange[0]);\n    program.setUniformf('camNear', crange[0]);\n    program.setUniformf('camFar', crange[1]);\n    const bounds = model.currentInput.getBounds();\n    const dims = model.currentInput.getDimensions();\n\n    // compute the viewport bounds of the volume\n    // we will only render those fragments.\n    const pos = new Float64Array(3);\n    const dir = new Float64Array(3);\n    let dcxmin = 1.0;\n    let dcxmax = -1.0;\n    let dcymin = 1.0;\n    let dcymax = -1.0;\n    for (let i = 0; i < 8; ++i) {\n      vec3.set(pos, bounds[i % 2], bounds[2 + Math.floor(i / 2) % 2], bounds[4 + Math.floor(i / 4)]);\n      vec3.transformMat4(pos, pos, model.modelToView);\n      if (!cam.getParallelProjection()) {\n        vec3.normalize(dir, pos);\n\n        // now find the projection of this point onto a\n        // nearZ distance plane. Since the camera is at 0,0,0\n        // in VC the ray is just t*pos and\n        // t is -nearZ/dir.z\n        // intersection becomes pos.x/pos.z\n        const t = -crange[0] / pos[2];\n        vec3.scale(pos, dir, t);\n      }\n      // now convert to DC\n      vec3.transformMat4(pos, pos, keyMats.vcpc);\n      dcxmin = Math.min(pos[0], dcxmin);\n      dcxmax = Math.max(pos[0], dcxmax);\n      dcymin = Math.min(pos[1], dcymin);\n      dcymax = Math.max(pos[1], dcymax);\n    }\n    program.setUniformf('dcxmin', dcxmin);\n    program.setUniformf('dcxmax', dcxmax);\n    program.setUniformf('dcymin', dcymin);\n    program.setUniformf('dcymax', dcymax);\n    if (program.isUniformUsed('cameraParallel')) {\n      program.setUniformi('cameraParallel', cam.getParallelProjection());\n    }\n    const ext = model.currentInput.getSpatialExtent();\n    const spc = model.currentInput.getSpacing();\n    const vsize = new Float64Array(3);\n    vec3.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);\n    program.setUniform3f('vSpacing', spc[0], spc[1], spc[2]);\n    vec3.set(pos, ext[0], ext[2], ext[4]);\n    model.currentInput.indexToWorldVec3(pos, pos);\n    vec3.transformMat4(pos, pos, model.modelToView);\n    program.setUniform3f('vOriginVC', pos[0], pos[1], pos[2]);\n\n    // apply the image directions\n    const i2wmat4 = model.currentInput.getIndexToWorld();\n    mat4.multiply(model.idxToView, model.modelToView, i2wmat4);\n    mat3.multiply(model.idxNormalMatrix, keyMats.normalMatrix, actMats.normalMatrix);\n    mat3.multiply(model.idxNormalMatrix, model.idxNormalMatrix, model.currentInput.getDirectionByReference());\n    const maxSamples = vec3.length(vsize) / publicAPI.getCurrentSampleDistance(ren);\n    if (maxSamples > model.renderable.getMaximumSamplesPerRay()) {\n      vtkWarningMacro(`The number of steps required ${Math.ceil(maxSamples)} is larger than the\n        specified maximum number of steps ${model.renderable.getMaximumSamplesPerRay()}.\n        Please either change the\n        volumeMapper sampleDistance or its maximum number of samples.`);\n    }\n    const vctoijk = new Float64Array(3);\n    vec3.set(vctoijk, 1.0, 1.0, 1.0);\n    vec3.divide(vctoijk, vctoijk, vsize);\n    program.setUniform3f('vVCToIJK', vctoijk[0], vctoijk[1], vctoijk[2]);\n    program.setUniform3i('volumeDimensions', dims[0], dims[1], dims[2]);\n    if (!model._openGLRenderWindow.getWebgl2()) {\n      const volInfo = model.scalarTexture.getVolumeInfo();\n      program.setUniformf('texWidth', model.scalarTexture.getWidth());\n      program.setUniformf('texHeight', model.scalarTexture.getHeight());\n      program.setUniformi('xreps', volInfo.xreps);\n      program.setUniformi('xstride', volInfo.xstride);\n      program.setUniformi('ystride', volInfo.ystride);\n    }\n\n    // map normals through normal matrix\n    // then use a point on the plane to compute the distance\n    const normal = new Float64Array(3);\n    const pos2 = new Float64Array(3);\n    for (let i = 0; i < 6; ++i) {\n      switch (i) {\n        case 1:\n          vec3.set(normal, -1.0, 0.0, 0.0);\n          vec3.set(pos2, ext[0], ext[2], ext[4]);\n          break;\n        case 2:\n          vec3.set(normal, 0.0, 1.0, 0.0);\n          vec3.set(pos2, ext[1], ext[3], ext[5]);\n          break;\n        case 3:\n          vec3.set(normal, 0.0, -1.0, 0.0);\n          vec3.set(pos2, ext[0], ext[2], ext[4]);\n          break;\n        case 4:\n          vec3.set(normal, 0.0, 0.0, 1.0);\n          vec3.set(pos2, ext[1], ext[3], ext[5]);\n          break;\n        case 5:\n          vec3.set(normal, 0.0, 0.0, -1.0);\n          vec3.set(pos2, ext[0], ext[2], ext[4]);\n          break;\n        case 0:\n        default:\n          vec3.set(normal, 1.0, 0.0, 0.0);\n          vec3.set(pos2, ext[1], ext[3], ext[5]);\n          break;\n      }\n      vec3.transformMat3(normal, normal, model.idxNormalMatrix);\n      vec3.transformMat4(pos2, pos2, model.idxToView);\n      const dist = -1.0 * vec3.dot(pos2, normal);\n\n      // we have the plane in view coordinates\n      // specify the planes in view coordinates\n      program.setUniform3f(`vPlaneNormal${i}`, normal[0], normal[1], normal[2]);\n      program.setUniformf(`vPlaneDistance${i}`, dist);\n    }\n    if (actor.getProperty().getUseLabelOutline()) {\n      const image = model.currentInput;\n      const worldToIndex = image.getWorldToIndex();\n      program.setUniformMatrix('vWCtoIDX', worldToIndex);\n      const camera = ren.getActiveCamera();\n      const [cRange0, cRange1] = camera.getClippingRange();\n      const distance = camera.getDistance();\n\n      // set the clipping range to be model.distance and model.distance + 0.1\n      // since we use the in the keyMats.wcpc (world to projection) matrix\n      // the projection matrix calculation relies on the clipping range to be\n      // set correctly. This is done inside the interactorStyleMPRSlice which\n      // limits use cases where the interactor style is not used.\n\n      camera.setClippingRange(distance, distance + 0.1);\n      const labelOutlineKeyMats = model.openGLCamera.getKeyMatrices(ren);\n\n      // Get the projection coordinate to world coordinate transformation matrix.\n      mat4.invert(model.projectionToWorld, labelOutlineKeyMats.wcpc);\n\n      // reset the clipping range since the keyMats are cached\n      camera.setClippingRange(cRange0, cRange1);\n\n      // to re compute the matrices for the current camera and cache them\n      model.openGLCamera.getKeyMatrices(ren);\n      program.setUniformMatrix('PCWCMatrix', model.projectionToWorld);\n      const size = publicAPI.getRenderTargetSize();\n      program.setUniformf('vpWidth', size[0]);\n      program.setUniformf('vpHeight', size[1]);\n      const offset = publicAPI.getRenderTargetOffset();\n      program.setUniformf('vpOffsetX', offset[0] / size[0]);\n      program.setUniformf('vpOffsetY', offset[1] / size[1]);\n    }\n    mat4.invert(model.projectionToView, keyMats.vcpc);\n    program.setUniformMatrix('PCVCMatrix', model.projectionToView);\n\n    // handle lighting values\n    if (model.lastLightComplexity === 0) {\n      return;\n    }\n    let lightNum = 0;\n    const lightColor = [];\n    const lightDir = [];\n    const halfAngle = [];\n    ren.getLights().forEach(light => {\n      const status = light.getSwitch();\n      if (status > 0) {\n        const dColor = light.getColor();\n        const intensity = light.getIntensity();\n        lightColor[0 + lightNum * 3] = dColor[0] * intensity;\n        lightColor[1 + lightNum * 3] = dColor[1] * intensity;\n        lightColor[2 + lightNum * 3] = dColor[2] * intensity;\n        const ldir = light.getDirection();\n        vec3.set(normal, ldir[0], ldir[1], ldir[2]);\n        vec3.transformMat3(normal, normal, keyMats.normalMatrix); // in view coordinat\n        vec3.normalize(normal, normal);\n        lightDir[0 + lightNum * 3] = normal[0];\n        lightDir[1 + lightNum * 3] = normal[1];\n        lightDir[2 + lightNum * 3] = normal[2];\n        // camera DOP is 0,0,-1.0 in VC\n        halfAngle[0 + lightNum * 3] = -0.5 * normal[0];\n        halfAngle[1 + lightNum * 3] = -0.5 * normal[1];\n        halfAngle[2 + lightNum * 3] = -0.5 * (normal[2] - 1.0);\n        lightNum++;\n      }\n    });\n    program.setUniformi('twoSidedLighting', ren.getTwoSidedLighting());\n    program.setUniformi('lightNum', lightNum);\n    program.setUniform3fv('lightColor', lightColor);\n    program.setUniform3fv('lightDirectionVC', lightDir);\n    program.setUniform3fv('lightHalfAngleVC', halfAngle);\n    if (model.lastLightComplexity === 3) {\n      lightNum = 0;\n      const lightPositionVC = [];\n      const lightAttenuation = [];\n      const lightConeAngle = [];\n      const lightExponent = [];\n      const lightPositional = [];\n      ren.getLights().forEach(light => {\n        const status = light.getSwitch();\n        if (status > 0) {\n          const attenuation = light.getAttenuationValues();\n          lightAttenuation[0 + lightNum * 3] = attenuation[0];\n          lightAttenuation[1 + lightNum * 3] = attenuation[1];\n          lightAttenuation[2 + lightNum * 3] = attenuation[2];\n          lightExponent[lightNum] = light.getExponent();\n          lightConeAngle[lightNum] = light.getConeAngle();\n          lightPositional[lightNum] = light.getPositional();\n          const lp = light.getTransformedPosition();\n          vec3.transformMat4(lp, lp, model.modelToView);\n          lightPositionVC[0 + lightNum * 3] = lp[0];\n          lightPositionVC[1 + lightNum * 3] = lp[1];\n          lightPositionVC[2 + lightNum * 3] = lp[2];\n          lightNum += 1;\n        }\n      });\n      program.setUniform3fv('lightPositionVC', lightPositionVC);\n      program.setUniform3fv('lightAttenuation', lightAttenuation);\n      program.setUniformfv('lightConeAngle', lightConeAngle);\n      program.setUniformfv('lightExponent', lightExponent);\n      program.setUniformiv('lightPositional', lightPositional);\n    }\n    if (model.renderable.getVolumetricScatteringBlending() > 0.0) {\n      program.setUniformf('giReach', model.renderable.getGlobalIlluminationReach());\n      program.setUniformf('volumetricScatteringBlending', model.renderable.getVolumetricScatteringBlending());\n      program.setUniformf('volumeShadowSamplingDistFactor', model.renderable.getVolumeShadowSamplingDistFactor());\n      program.setUniformf('anisotropy', model.renderable.getAnisotropy());\n      program.setUniformf('anisotropy2', model.renderable.getAnisotropy() ** 2.0);\n    }\n    if (model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0.0) {\n      const ks = model.renderable.getLAOKernelSize();\n      program.setUniformi('kernelSize', ks);\n      const kernelSample = [];\n      for (let i = 0; i < ks; i++) {\n        kernelSample[i * 2] = Math.random() * 0.5;\n        kernelSample[i * 2 + 1] = Math.random() * 0.5;\n      }\n      program.setUniform2fv('kernelSample', kernelSample);\n      program.setUniformi('kernelRadius', model.renderable.getLAOKernelRadius());\n    }\n  };\n  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    program.setUniformi('ctexture', model.colorTexture.getTextureUnit());\n    program.setUniformi('otexture', model.opacityTexture.getTextureUnit());\n    program.setUniformi('jtexture', model.jitterTexture.getTextureUnit());\n    program.setUniformi('ttexture', model.labelOutlineThicknessTexture.getTextureUnit());\n    const volInfo = model.scalarTexture.getVolumeInfo();\n    const vprop = actor.getProperty();\n\n    // set the component mix when independent\n    const numComp = model.scalarTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n    if (iComps && numComp >= 2) {\n      for (let i = 0; i < numComp; i++) {\n        program.setUniformf(`mix${i}`, actor.getProperty().getComponentWeight(i));\n      }\n    }\n\n    // three levels of shift scale combined into one\n    // for performance in the fragment shader\n    for (let i = 0; i < numComp; i++) {\n      const target = iComps ? i : 0;\n      const sscale = volInfo.scale[i];\n      const ofun = vprop.getScalarOpacity(target);\n      const oRange = ofun.getRange();\n      const oscale = sscale / (oRange[1] - oRange[0]);\n      const oshift = (volInfo.offset[i] - oRange[0]) / (oRange[1] - oRange[0]);\n      program.setUniformf(`oshift${i}`, oshift);\n      program.setUniformf(`oscale${i}`, oscale);\n      const cfun = vprop.getRGBTransferFunction(target);\n      const cRange = cfun.getRange();\n      const cshift = (volInfo.offset[i] - cRange[0]) / (cRange[1] - cRange[0]);\n      const cScale = sscale / (cRange[1] - cRange[0]);\n      program.setUniformf(`cshift${i}`, cshift);\n      program.setUniformf(`cscale${i}`, cScale);\n    }\n    if (model.gopacity) {\n      if (iComps) {\n        for (let nc = 0; nc < numComp; ++nc) {\n          const sscale = volInfo.scale[nc];\n          const useGO = vprop.getUseGradientOpacity(nc);\n          if (useGO) {\n            const gomin = vprop.getGradientOpacityMinimumOpacity(nc);\n            const gomax = vprop.getGradientOpacityMaximumOpacity(nc);\n            program.setUniformf(`gomin${nc}`, gomin);\n            program.setUniformf(`gomax${nc}`, gomax);\n            const goRange = [vprop.getGradientOpacityMinimumValue(nc), vprop.getGradientOpacityMaximumValue(nc)];\n            program.setUniformf(`goscale${nc}`, sscale * (gomax - gomin) / (goRange[1] - goRange[0]));\n            program.setUniformf(`goshift${nc}`, -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin);\n          } else {\n            program.setUniformf(`gomin${nc}`, 1.0);\n            program.setUniformf(`gomax${nc}`, 1.0);\n            program.setUniformf(`goscale${nc}`, 0.0);\n            program.setUniformf(`goshift${nc}`, 1.0);\n          }\n        }\n      } else {\n        const sscale = volInfo.scale[numComp - 1];\n        const gomin = vprop.getGradientOpacityMinimumOpacity(0);\n        const gomax = vprop.getGradientOpacityMaximumOpacity(0);\n        program.setUniformf('gomin0', gomin);\n        program.setUniformf('gomax0', gomax);\n        const goRange = [vprop.getGradientOpacityMinimumValue(0), vprop.getGradientOpacityMaximumValue(0)];\n        program.setUniformf('goscale0', sscale * (gomax - gomin) / (goRange[1] - goRange[0]));\n        program.setUniformf('goshift0', -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin);\n      }\n    }\n    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();\n    if (vtkImageLabelOutline === true) {\n      const labelOutlineOpacity = actor.getProperty().getLabelOutlineOpacity();\n      program.setUniformf('outlineOpacity', labelOutlineOpacity);\n    }\n    if (model.lastLightComplexity > 0) {\n      program.setUniformf('vAmbient', vprop.getAmbient());\n      program.setUniformf('vDiffuse', vprop.getDiffuse());\n      program.setUniformf('vSpecular', vprop.getSpecular());\n      program.setUniformf('vSpecularPower', vprop.getSpecularPower());\n    }\n  };\n  publicAPI.getClippingPlaneShaderParameters = (cellBO, ren, actor) => {\n    if (model.renderable.getClippingPlanes().length > 0) {\n      const keyMats = model.openGLCamera.getKeyMatrices(ren);\n      const clipPlaneNormals = [];\n      const clipPlaneDistances = [];\n      const clipPlaneOrigins = [];\n      const clipPlanes = model.renderable.getClippingPlanes();\n      const clipPlaneSize = clipPlanes.length;\n      for (let i = 0; i < clipPlaneSize; ++i) {\n        const clipPlaneNormal = clipPlanes[i].getNormal();\n        const clipPlanePos = clipPlanes[i].getOrigin();\n        vec3.transformMat3(clipPlaneNormal, clipPlaneNormal, keyMats.normalMatrix);\n        vec3.transformMat4(clipPlanePos, clipPlanePos, keyMats.wcvc);\n        const clipPlaneDist = -1.0 * vec3.dot(clipPlanePos, clipPlaneNormal);\n        clipPlaneNormals.push(clipPlaneNormal[0]);\n        clipPlaneNormals.push(clipPlaneNormal[1]);\n        clipPlaneNormals.push(clipPlaneNormal[2]);\n        clipPlaneDistances.push(clipPlaneDist);\n        clipPlaneOrigins.push(clipPlanePos[0]);\n        clipPlaneOrigins.push(clipPlanePos[1]);\n        clipPlaneOrigins.push(clipPlanePos[2]);\n      }\n      const program = cellBO.getProgram();\n      program.setUniform3fv(`vClipPlaneNormals`, clipPlaneNormals);\n      program.setUniformfv(`vClipPlaneDistances`, clipPlaneDistances);\n      program.setUniform3fv(`vClipPlaneOrigins`, clipPlaneOrigins);\n      program.setUniformi(`clip_numPlanes`, clipPlaneSize);\n    }\n  };\n\n  // unsubscribe from our listeners\n  publicAPI.delete = chain(() => {\n    if (model._animationRateSubscription) {\n      model._animationRateSubscription.unsubscribe();\n      model._animationRateSubscription = null;\n    }\n  }, publicAPI.delete);\n  publicAPI.getRenderTargetSize = () => {\n    if (model._useSmallViewport) {\n      return [model._smallViewportWidth, model._smallViewportHeight];\n    }\n    const {\n      usize,\n      vsize\n    } = model._openGLRenderer.getTiledSizeAndOrigin();\n    return [usize, vsize];\n  };\n  publicAPI.getRenderTargetOffset = () => {\n    const {\n      lowerLeftU,\n      lowerLeftV\n    } = model._openGLRenderer.getTiledSizeAndOrigin();\n    return [lowerLeftU, lowerLeftV];\n  };\n  publicAPI.getCurrentSampleDistance = ren => {\n    const rwi = ren.getVTKWindow().getInteractor();\n    const baseSampleDistance = model.renderable.getSampleDistance();\n    if (rwi.isAnimating()) {\n      const factor = model.renderable.getInteractionSampleDistanceFactor();\n      return baseSampleDistance * factor;\n    }\n    return baseSampleDistance;\n  };\n  publicAPI.renderPieceStart = (ren, actor) => {\n    const rwi = ren.getVTKWindow().getInteractor();\n    if (!model._lastScale) {\n      model._lastScale = model.renderable.getInitialInteractionScale();\n    }\n    model._useSmallViewport = false;\n    if (rwi.isAnimating() && model._lastScale > 1.5) {\n      model._useSmallViewport = true;\n    }\n    if (!model._animationRateSubscription) {\n      // when the animation frame rate changes recompute the scale factor\n      model._animationRateSubscription = rwi.onAnimationFrameRateUpdate(() => {\n        if (model.renderable.getAutoAdjustSampleDistances()) {\n          const frate = rwi.getRecentAnimationFrameRate();\n          const adjustment = rwi.getDesiredUpdateRate() / frate;\n\n          // only change if we are off by 15%\n          if (adjustment > 1.15 || adjustment < 0.85) {\n            model._lastScale *= adjustment;\n          }\n          // clamp scale to some reasonable values.\n          // Below 1.5 we will just be using full resolution as that is close enough\n          // Above 400 seems like a lot so we limit to that 1/20th per axis\n          if (model._lastScale > 400) {\n            model._lastScale = 400;\n          }\n          if (model._lastScale < 1.5) {\n            model._lastScale = 1.5;\n          }\n        } else {\n          model._lastScale = model.renderable.getImageSampleDistance() * model.renderable.getImageSampleDistance();\n        }\n      });\n    }\n\n    // use/create/resize framebuffer if needed\n    if (model._useSmallViewport) {\n      const size = model._openGLRenderWindow.getFramebufferSize();\n      const scaleFactor = 1 / Math.sqrt(model._lastScale);\n      model._smallViewportWidth = Math.ceil(scaleFactor * size[0]);\n      model._smallViewportHeight = Math.ceil(scaleFactor * size[1]);\n\n      // adjust viewportSize to always be at most the dest fo size\n      if (model._smallViewportHeight > size[1]) {\n        model._smallViewportHeight = size[1];\n      }\n      if (model._smallViewportWidth > size[0]) {\n        model._smallViewportWidth = size[0];\n      }\n      model.framebuffer.saveCurrentBindingsAndBuffers();\n      if (model.framebuffer.getGLFramebuffer() === null) {\n        model.framebuffer.create(size[0], size[1]);\n        model.framebuffer.populateFramebuffer();\n      } else {\n        const fbSize = model.framebuffer.getSize();\n        if (fbSize[0] !== size[0] || fbSize[1] !== size[1]) {\n          model.framebuffer.create(size[0], size[1]);\n          model.framebuffer.populateFramebuffer();\n        }\n      }\n      model.framebuffer.bind();\n      const gl = model.context;\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n      gl.colorMask(true, true, true, true);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      gl.viewport(0, 0, model._smallViewportWidth, model._smallViewportHeight);\n      model.fvp = [model._smallViewportWidth / size[0], model._smallViewportHeight / size[1]];\n    }\n    model.context.disable(model.context.DEPTH_TEST);\n\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor);\n\n    // set interpolation on the texture based on property setting\n    const iType = actor.getProperty().getInterpolationType();\n    if (iType === InterpolationType.NEAREST) {\n      model.scalarTexture.setMinificationFilter(Filter.NEAREST);\n      model.scalarTexture.setMagnificationFilter(Filter.NEAREST);\n    } else {\n      model.scalarTexture.setMinificationFilter(Filter.LINEAR);\n      model.scalarTexture.setMagnificationFilter(Filter.LINEAR);\n    }\n\n    // Bind the OpenGL, this is shared between the different primitive/cell types.\n    model.lastBoundBO = null;\n\n    // if we have a zbuffer texture then activate it\n    if (model.zBufferTexture !== null) {\n      model.zBufferTexture.activate();\n    }\n  };\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const gl = model.context;\n\n    // render the texture\n    model.scalarTexture.activate();\n    model.opacityTexture.activate();\n    model.labelOutlineThicknessTexture.activate();\n    model.colorTexture.activate();\n    model.jitterTexture.activate();\n    publicAPI.updateShaders(model.tris, ren, actor);\n\n    // First we do the triangles, update the shader, set uniforms, etc.\n    // for (let i = 0; i < 11; ++i) {\n    //   gl.drawArrays(gl.TRIANGLES, 66 * i, 66);\n    // }\n    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n    model.tris.getVAO().release();\n    model.scalarTexture.deactivate();\n    model.colorTexture.deactivate();\n    model.opacityTexture.deactivate();\n    model.labelOutlineThicknessTexture.deactivate();\n    model.jitterTexture.deactivate();\n  };\n  publicAPI.renderPieceFinish = (ren, actor) => {\n    // if we have a zbuffer texture then deactivate it\n    if (model.zBufferTexture !== null) {\n      model.zBufferTexture.deactivate();\n    }\n    if (model._useSmallViewport) {\n      // now copy the framebuffer with the volume into the\n      // regular buffer\n      model.framebuffer.restorePreviousBindingsAndBuffers();\n      if (model.copyShader === null) {\n        model.copyShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(['//VTK::System::Dec', 'attribute vec4 vertexDC;', 'uniform vec2 tfactor;', 'varying vec2 tcoord;', 'void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }'].join('\\n'), ['//VTK::System::Dec', '//VTK::Output::Dec', 'uniform sampler2D texture1;', 'varying vec2 tcoord;', 'void main() { gl_FragData[0] = texture2D(texture1,tcoord); }'].join('\\n'), '');\n        const program = model.copyShader;\n        model.copyVAO = vtkVertexArrayObject.newInstance();\n        model.copyVAO.setOpenGLRenderWindow(model._openGLRenderWindow);\n        model.tris.getCABO().bind();\n        if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), 'vertexDC', model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexDC in copy shader VAO.');\n        }\n      } else {\n        model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.copyShader);\n      }\n      const size = model._openGLRenderWindow.getFramebufferSize();\n      model.context.viewport(0, 0, size[0], size[1]);\n\n      // activate texture\n      const tex = model.framebuffer.getColorTexture();\n      tex.activate();\n      model.copyShader.setUniformi('texture', tex.getTextureUnit());\n      model.copyShader.setUniform2f('tfactor', model.fvp[0], model.fvp[1]);\n      const gl = model.context;\n      gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n      // render quad\n      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n      tex.deactivate();\n      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    }\n  };\n  publicAPI.renderPiece = (ren, actor) => {\n    publicAPI.invokeEvent({\n      type: 'StartEvent'\n    });\n    model.renderable.update();\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.invokeEvent({\n      type: 'EndEvent'\n    });\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n  publicAPI.computeBounds = (ren, actor) => {\n    if (!publicAPI.getInput()) {\n      uninitializeBounds(model.Bounds);\n      return;\n    }\n    model.bounds = publicAPI.getInput().getBounds();\n  };\n  publicAPI.updateBufferObjects = (ren, actor) => {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {\n    // first do a coarse check\n    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const image = model.currentInput;\n    if (!image) {\n      return;\n    }\n    const scalars = image.getPointData() && image.getPointData().getScalars();\n    if (!scalars) {\n      return;\n    }\n    if (model._scalars !== scalars) {\n      model._openGLRenderWindow.releaseGraphicsResourcesForObject(model._scalars);\n      model._scalars = scalars;\n    }\n    const vprop = actor.getProperty();\n    if (!model.jitterTexture.getHandle()) {\n      const oTable = new Uint8Array(32 * 32);\n      for (let i = 0; i < 32 * 32; ++i) {\n        oTable[i] = 255.0 * Math.random();\n      }\n      model.jitterTexture.setMinificationFilter(Filter.LINEAR);\n      model.jitterTexture.setMagnificationFilter(Filter.LINEAR);\n      model.jitterTexture.create2DFromRaw(32, 32, 1, VtkDataTypes.UNSIGNED_CHAR, oTable);\n    }\n    const numComp = scalars.getNumberOfComponents();\n    const iComps = vprop.getIndependentComponents();\n    const numIComps = iComps ? numComp : 1;\n    const scalarOpacityFunc = vprop.getScalarOpacity();\n    const opTex = model._openGLRenderWindow.getGraphicsResourceForObject(scalarOpacityFunc);\n    let toString = computeFnToString(vprop, scalarOpacityFunc, numIComps);\n    const reBuildOp = !opTex.vtkObj || opTex.hash !== toString || model.opacityTextureString !== toString;\n    if (reBuildOp) {\n      // rebuild opacity tfun?\n      const oWidth = 1024;\n      const oSize = oWidth * 2 * numIComps;\n      const ofTable = new Float32Array(oSize);\n      const tmpTable = new Float32Array(oWidth);\n      for (let c = 0; c < numIComps; ++c) {\n        const ofun = vprop.getScalarOpacity(c);\n        const opacityFactor = publicAPI.getCurrentSampleDistance(ren) / vprop.getScalarOpacityUnitDistance(c);\n        const oRange = ofun.getRange();\n        ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);\n        // adjust for sample distance etc\n        for (let i = 0; i < oWidth; ++i) {\n          ofTable[c * oWidth * 2 + i] = 1.0 - (1.0 - tmpTable[i]) ** opacityFactor;\n          ofTable[c * oWidth * 2 + i + oWidth] = ofTable[c * oWidth * 2 + i];\n        }\n      }\n      model.opacityTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.opacityTexture.resetFormatAndType();\n      model.opacityTexture.setMinificationFilter(Filter.LINEAR);\n      model.opacityTexture.setMagnificationFilter(Filter.LINEAR);\n\n      // use float texture where possible because we really need the resolution\n      // for this table. Errors in low values of opacity accumulate to\n      // visible artifacts. High values of opacity quickly terminate without\n      // artifacts.\n      if (model._openGLRenderWindow.getWebgl2() || model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes.FLOAT, ofTable);\n      } else {\n        const oTable = new Uint8Array(oSize);\n        for (let i = 0; i < oSize; ++i) {\n          oTable[i] = 255.0 * ofTable[i];\n        }\n        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes.UNSIGNED_CHAR, oTable);\n      }\n      model.opacityTextureString = toString;\n      if (scalarOpacityFunc) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(scalarOpacityFunc, model.opacityTexture, model.opacityTextureString);\n      }\n    } else {\n      model.opacityTexture = opTex.vtkObj;\n      model.opacityTextureString = opTex.hash;\n    }\n\n    // rebuild color tfun?\n    const colorTransferFunc = vprop.getRGBTransferFunction();\n    toString = computeFnToString(vprop, colorTransferFunc, numIComps);\n    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);\n    const reBuildC = !cTex?.vtkObj || cTex?.hash !== toString || model.colorTextureString !== toString;\n    if (reBuildC) {\n      const cWidth = 1024;\n      const cSize = cWidth * 2 * numIComps * 3;\n      const cTable = new Uint8Array(cSize);\n      const tmpTable = new Float32Array(cWidth * 3);\n      for (let c = 0; c < numIComps; ++c) {\n        const cfun = vprop.getRGBTransferFunction(c);\n        const cRange = cfun.getRange();\n        cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);\n        for (let i = 0; i < cWidth * 3; ++i) {\n          cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n          cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];\n        }\n      }\n      model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.colorTexture.resetFormatAndType();\n      model.colorTexture.setMinificationFilter(Filter.LINEAR);\n      model.colorTexture.setMagnificationFilter(Filter.LINEAR);\n      model.colorTexture.create2DFromRaw(cWidth, 2 * numIComps, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      model.colorTextureString = toString;\n      if (colorTransferFunc) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, model.colorTextureString);\n      }\n    } else {\n      model.colorTexture = cTex.vtkObj;\n      model.colorTextureString = cTex.hash;\n    }\n    publicAPI.updateLabelOutlineThicknessTexture(actor);\n    const tex = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);\n    // rebuild the scalarTexture if the data has changed\n    toString = `${image.getMTime()}A${scalars.getMTime()}`;\n    const reBuildTex = !tex?.vtkObj || tex?.hash !== toString || model.scalarTextureString !== toString;\n    if (reBuildTex) {\n      // Build the textures\n      const dims = image.getDimensions();\n      // Use norm16 for scalar texture if the extension is available\n      model.scalarTexture.setOglNorm16Ext(model.context.getExtension('EXT_texture_norm16'));\n      model.scalarTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.scalarTexture.resetFormatAndType();\n      model.scalarTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars, model.renderable.getPreferSizeOverAccuracy());\n      model.scalarTextureString = toString;\n      if (scalars) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(scalars, model.scalarTexture, model.scalarTextureString);\n      }\n    } else {\n      model.scalarTexture = tex.vtkObj;\n      model.scalarTextureString = tex.hash;\n    }\n    if (!model.tris.getCABO().getElementCount()) {\n      // build the CABO\n      const ptsArray = new Float32Array(12);\n      for (let i = 0; i < 4; i++) {\n        ptsArray[i * 3] = i % 2 * 2 - 1.0;\n        ptsArray[i * 3 + 1] = i > 1 ? 1.0 : -1.0;\n        ptsArray[i * 3 + 2] = -1.0;\n      }\n      const cellArray = new Uint16Array(8);\n      cellArray[0] = 3;\n      cellArray[1] = 0;\n      cellArray[2] = 1;\n      cellArray[3] = 3;\n      cellArray[4] = 3;\n      cellArray[5] = 0;\n      cellArray[6] = 3;\n      cellArray[7] = 2;\n\n      // const dim = 12.0;\n      // const ptsArray = new Float32Array(3 * dim * dim);\n      // for (let i = 0; i < dim; i++) {\n      //   for (let j = 0; j < dim; j++) {\n      //     const offset = ((i * dim) + j) * 3;\n      //     ptsArray[offset] = (2.0 * (i / (dim - 1.0))) - 1.0;\n      //     ptsArray[offset + 1] = (2.0 * (j / (dim - 1.0))) - 1.0;\n      //     ptsArray[offset + 2] = -1.0;\n      //   }\n      // }\n\n      // const cellArray = new Uint16Array(8 * (dim - 1) * (dim - 1));\n      // for (let i = 0; i < dim - 1; i++) {\n      //   for (let j = 0; j < dim - 1; j++) {\n      //     const offset = 8 * ((i * (dim - 1)) + j);\n      //     cellArray[offset] = 3;\n      //     cellArray[offset + 1] = (i * dim) + j;\n      //     cellArray[offset + 2] = (i * dim) + 1 + j;\n      //     cellArray[offset + 3] = ((i + 1) * dim) + 1 + j;\n      //     cellArray[offset + 4] = 3;\n      //     cellArray[offset + 5] = (i * dim) + j;\n      //     cellArray[offset + 6] = ((i + 1) * dim) + 1 + j;\n      //     cellArray[offset + 7] = ((i + 1) * dim) + j;\n      //   }\n      // }\n\n      const points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: ptsArray\n      });\n      points.setName('points');\n      const cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: cellArray\n      });\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n        points,\n        cellOffset: 0\n      });\n    }\n    model.VBOBuildTime.modified();\n  };\n  publicAPI.updateLabelOutlineThicknessTexture = volume => {\n    const labelOutlineThicknessArray = volume.getProperty().getLabelOutlineThickness();\n    const lTex = model._openGLRenderWindow.getGraphicsResourceForObject(labelOutlineThicknessArray);\n\n    // compute the join of the labelOutlineThicknessArray so that\n    // we can use it to decide whether to rebuild the labelOutlineThicknessTexture\n    // or not\n    const toString = `${labelOutlineThicknessArray.join('-')}`;\n    const reBuildL = !lTex?.vtkObj || lTex?.hash !== toString || model.labelOutlineThicknessTextureString !== toString;\n    if (reBuildL) {\n      const lWidth = 1024;\n      const lHeight = 1;\n      const lSize = lWidth * lHeight;\n      const lTable = new Uint8Array(lSize);\n\n      // Assuming labelOutlineThicknessArray contains the thickness for each segment\n      for (let i = 0; i < lWidth; ++i) {\n        // Retrieve the thickness value for the current segment index.\n        // If the value is undefined, null, or 0, use the first element's value as a default.\n        const thickness = labelOutlineThicknessArray[i] || labelOutlineThicknessArray[0];\n        lTable[i] = thickness;\n      }\n      model.labelOutlineThicknessTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.labelOutlineThicknessTexture.resetFormatAndType();\n      model.labelOutlineThicknessTexture.setMinificationFilter(Filter.NEAREST);\n      model.labelOutlineThicknessTexture.setMagnificationFilter(Filter.NEAREST);\n\n      // Create a 2D texture (acting as 1D) from the raw data\n      model.labelOutlineThicknessTexture.create2DFromRaw(lWidth, lHeight, 1, VtkDataTypes.UNSIGNED_CHAR, lTable);\n      model.labelOutlineThicknessTextureString = toString;\n      if (labelOutlineThicknessArray) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(labelOutlineThicknessArray, model.labelOutlineThicknessTexture, model.labelOutlineThicknessTextureString);\n      }\n    } else {\n      model.labelOutlineThicknessTexture = lTex.vtkObj;\n      model.labelOutlineThicknessTextureString = lTex.hash;\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  VBOBuildTime: null,\n  scalarTexture: null,\n  scalarTextureString: null,\n  opacityTexture: null,\n  opacityTextureString: null,\n  colorTexture: null,\n  colorTextureString: null,\n  jitterTexture: null,\n  labelOutlineThicknessTexture: null,\n  labelOutlineThicknessTextureString: null,\n  tris: null,\n  framebuffer: null,\n  copyShader: null,\n  copyVAO: null,\n  lastXYF: 1.0,\n  targetXYF: 1.0,\n  zBufferTexture: null,\n  lastZBufferTexture: null,\n  lastLightComplexity: 0,\n  fullViewportTime: 1.0,\n  idxToView: null,\n  idxNormalMatrix: null,\n  modelToView: null,\n  projectionToView: null,\n  avgWindowArea: 0.0,\n  avgFrameTime: 0.0,\n  _scalars: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime, {\n    mtime: 0\n  });\n  model.tris = vtkHelper.newInstance();\n  model.scalarTexture = vtkOpenGLTexture.newInstance();\n  model.opacityTexture = vtkOpenGLTexture.newInstance();\n  model.colorTexture = vtkOpenGLTexture.newInstance();\n  model.jitterTexture = vtkOpenGLTexture.newInstance();\n  model.jitterTexture.setWrapS(Wrap.REPEAT);\n  model.jitterTexture.setWrapT(Wrap.REPEAT);\n  model.labelOutlineThicknessTexture = vtkOpenGLTexture.newInstance();\n  model.framebuffer = vtkOpenGLFramebuffer.newInstance();\n  model.idxToView = mat4.identity(new Float64Array(16));\n  model.idxNormalMatrix = mat3.identity(new Float64Array(9));\n  model.modelToView = mat4.identity(new Float64Array(16));\n  model.projectionToView = mat4.identity(new Float64Array(16));\n  model.projectionToWorld = mat4.identity(new Float64Array(16));\n\n  // Build VTK API\n  setGet(publicAPI, model, ['context']);\n\n  // Object methods\n  vtkOpenGLVolumeMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLVolumeMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkVolumeMapper = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkVolumeMapper', newInstance);\nexport { vtkVolumeMapper as default, extend, newInstance };","map":{"version":3,"names":["n","newInstance$1","o","obj","e","setGet","h","chain","c","macro","mat4","mat3","vec3","vtkDataArray","VtkDataTypes","vtkHelper","u","uninitializeBounds","vtkOpenGLFramebuffer","vtkOpenGLTexture","vtkShaderProgram","vtkVertexArrayObject","vtkViewNode","Representation","Wrap","Filter","InterpolationType","OpacityMode","BlendMode","v","vtkVolumeVS","vtkVolumeFS","registerOverride","vtkWarningMacro","vtkErrorMacro","arrayEquals","a","b","length","i","computeFnToString","property","pwfun","numberOfComponents","iComps","getIndependentComponents","getMTime","vtkOpenGLVolumeMapper","publicAPI","model","classHierarchy","push","buildPass","zBufferTexture","zBufferPass","prepass","renderPass","zbt","getZBufferTexture","opaqueZBufferPass","volumePass","_openGLRenderWindow","getFirstAncestorOfType","context","getContext","tris","setOpenGLRenderWindow","jitterTexture","framebuffer","scalarTexture","colorTexture","opacityTexture","labelOutlineThicknessTexture","openGLVolume","actor","getRenderable","_openGLRenderer","ren","openGLCamera","getViewNodeFor","getActiveCamera","renderPiece","buildShaders","shaders","getShaderTemplate","replaceShaderValues","Vertex","Fragment","Geometry","FSSource","iType","getProperty","getInterpolationType","LINEAR","substitute","result","vtkImageLabelOutline","getUseLabelOutline","numComp","getComponents","proportionalComponents","nc","getOpacityMode","PROPORTIONAL","join","ext","currentInput","getSpatialExtent","spc","getSpacing","vsize","Float64Array","set","maxSamples","getCurrentSampleDistance","Math","ceil","lastLightComplexity","renderable","getVolumetricScatteringBlending","getLocalAmbientOcclusion","getAmbient","gopacity","getUseGradientOpacity","getComputeNormalFromOpacity","getBlendMode","replaceShaderLight","replaceShaderClippingPlane","lightNum","getLights","forEach","light","getSwitch","getLAOKernelRadius","getClippingPlanes","clipPlaneSize","getNeedToRebuildShaders","cellBO","lightComplexity","getShade","COMPOSITE_BLEND","numberOfLights","status","getIntensity","lightTypeIsHeadLight","getPositional","needRebuild","usesProportionalComponents","state","interpolationType","useLabelOutline","useGradientOpacity","blendMode","previousState","getProgram","getHandle","lastHaveSeenDepthRequest","haveSeenDepthRequest","lastZBufferTexture","getShaderSourceTime","updateShaders","lastBoundBO","newShader","getShaderCache","readyShaderProgramArray","setProgram","getVAO","releaseGraphicsResources","modified","readyShaderProgram","bind","setMapperShaderParameters","setCameraShaderParameters","setPropertyShaderParameters","getClippingPlaneShaderParameters","program","getCABO","getElementCount","VBOBuildTime","getAttributeUpdateTime","isAttributeUsed","addAttributeArray","getVertexOffset","getStride","FLOAT","FALSE","setUniformi","getTextureUnit","setUniformf","volInfo","getVolumeInfo","ipScalarRange","getIpScalarRange","minVals","maxVals","dataComputedScale","dataComputedOffset","offset","scale","setUniform4f","size","_useSmallViewport","_smallViewportWidth","_smallViewportHeight","getFramebufferSize","keyMats","getKeyMatrices","actMats","multiply","modelToView","wcvc","mcwc","cam","crange","getClippingRange","bounds","getBounds","dims","getDimensions","pos","dir","dcxmin","dcxmax","dcymin","dcymax","floor","transformMat4","getParallelProjection","normalize","t","vcpc","min","max","isUniformUsed","setUniform3f","indexToWorldVec3","i2wmat4","getIndexToWorld","idxToView","idxNormalMatrix","normalMatrix","getDirectionByReference","getMaximumSamplesPerRay","vctoijk","divide","setUniform3i","getWebgl2","getWidth","getHeight","xreps","xstride","ystride","normal","pos2","transformMat3","dist","dot","image","worldToIndex","getWorldToIndex","setUniformMatrix","camera","cRange0","cRange1","distance","getDistance","setClippingRange","labelOutlineKeyMats","invert","projectionToWorld","wcpc","getRenderTargetSize","getRenderTargetOffset","projectionToView","lightColor","lightDir","halfAngle","dColor","getColor","intensity","ldir","getDirection","getTwoSidedLighting","setUniform3fv","lightPositionVC","lightAttenuation","lightConeAngle","lightExponent","lightPositional","attenuation","getAttenuationValues","getExponent","getConeAngle","lp","getTransformedPosition","setUniformfv","setUniformiv","getGlobalIlluminationReach","getVolumeShadowSamplingDistFactor","getAnisotropy","ks","getLAOKernelSize","kernelSample","random","setUniform2fv","vprop","getComponentWeight","target","sscale","ofun","getScalarOpacity","oRange","getRange","oscale","oshift","cfun","getRGBTransferFunction","cRange","cshift","cScale","useGO","gomin","getGradientOpacityMinimumOpacity","gomax","getGradientOpacityMaximumOpacity","goRange","getGradientOpacityMinimumValue","getGradientOpacityMaximumValue","labelOutlineOpacity","getLabelOutlineOpacity","getDiffuse","getSpecular","getSpecularPower","clipPlaneNormals","clipPlaneDistances","clipPlaneOrigins","clipPlanes","clipPlaneNormal","getNormal","clipPlanePos","getOrigin","clipPlaneDist","delete","_animationRateSubscription","unsubscribe","usize","getTiledSizeAndOrigin","lowerLeftU","lowerLeftV","rwi","getVTKWindow","getInteractor","baseSampleDistance","getSampleDistance","isAnimating","factor","getInteractionSampleDistanceFactor","renderPieceStart","_lastScale","getInitialInteractionScale","onAnimationFrameRateUpdate","getAutoAdjustSampleDistances","frate","getRecentAnimationFrameRate","adjustment","getDesiredUpdateRate","getImageSampleDistance","scaleFactor","sqrt","saveCurrentBindingsAndBuffers","getGLFramebuffer","create","populateFramebuffer","fbSize","getSize","gl","clearColor","colorMask","clear","COLOR_BUFFER_BIT","viewport","fvp","disable","DEPTH_TEST","updateBufferObjects","NEAREST","setMinificationFilter","setMagnificationFilter","activate","renderPieceDraw","drawArrays","TRIANGLES","release","deactivate","renderPieceFinish","restorePreviousBindingsAndBuffers","copyShader","copyVAO","newInstance","tex","getColorTexture","setUniform2f","blendFuncSeparate","ONE","ONE_MINUS_SRC_ALPHA","SRC_ALPHA","invokeEvent","type","update","getInputData","computeBounds","getInput","Bounds","getNeedToRebuildBufferObjects","buildBufferObjects","scalars","getPointData","getScalars","_scalars","releaseGraphicsResourcesForObject","oTable","Uint8Array","create2DFromRaw","UNSIGNED_CHAR","getNumberOfComponents","numIComps","scalarOpacityFunc","opTex","getGraphicsResourceForObject","toString","reBuildOp","vtkObj","hash","opacityTextureString","oWidth","oSize","ofTable","Float32Array","tmpTable","opacityFactor","getScalarOpacityUnitDistance","getTable","resetFormatAndType","getExtension","setGraphicsResourceForObject","colorTransferFunc","cTex","reBuildC","colorTextureString","cWidth","cSize","cTable","updateLabelOutlineThicknessTexture","reBuildTex","scalarTextureString","setOglNorm16Ext","create3DFilterableFromDataArray","getPreferSizeOverAccuracy","ptsArray","cellArray","Uint16Array","points","values","setName","cells","createVBO","SURFACE","cellOffset","volume","labelOutlineThicknessArray","getLabelOutlineThickness","lTex","reBuildL","labelOutlineThicknessTextureString","lWidth","lHeight","lSize","lTable","thickness","DEFAULT_VALUES","lastXYF","targetXYF","fullViewportTime","avgWindowArea","avgFrameTime","extend","initialValues","arguments","undefined","Object","assign","mtime","setWrapS","REPEAT","setWrapT","identity","vtkVolumeMapper","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/OpenGL/VolumeMapper.js"],"sourcesContent":["import { n as newInstance$1, o as obj, e as setGet, h as chain, c as macro } from '../../macros2.js';\nimport { mat4, mat3, vec3 } from 'gl-matrix';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport vtkHelper from './Helper.js';\nimport { u as uninitializeBounds } from '../../Common/Core/Math/index.js';\nimport vtkOpenGLFramebuffer from './Framebuffer.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkVertexArrayObject from './VertexArrayObject.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { Wrap, Filter } from './Texture/Constants.js';\nimport { InterpolationType, OpacityMode } from '../Core/VolumeProperty/Constants.js';\nimport { BlendMode } from '../Core/VolumeMapper/Constants.js';\nimport { v as vtkVolumeVS } from './glsl/vtkVolumeVS.glsl.js';\nimport { v as vtkVolumeFS } from './glsl/vtkVolumeFS.glsl.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  vtkWarningMacro,\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n// TODO: Do we want this in some shared utility? Shouldwe just use lodash.isEqual\nfunction arrayEquals(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction computeFnToString(property, pwfun, numberOfComponents) {\n  if (pwfun) {\n    const iComps = property.getIndependentComponents();\n    return `${pwfun.getMTime()}-${iComps}-${numberOfComponents}`;\n  }\n  return '0';\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLVolumeMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLVolumeMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLVolumeMapper');\n  publicAPI.buildPass = () => {\n    model.zBufferTexture = null;\n  };\n\n  // ohh someone is doing a zbuffer pass, use that for\n  // intermixed volume rendering\n  publicAPI.zBufferPass = (prepass, renderPass) => {\n    if (prepass) {\n      const zbt = renderPass.getZBufferTexture();\n      if (zbt !== model.zBufferTexture) {\n        model.zBufferTexture = zbt;\n      }\n    }\n  };\n  publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.zBufferPass(prepass, renderPass);\n\n  // Renders myself\n  publicAPI.volumePass = (prepass, renderPass) => {\n    if (prepass) {\n      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderWindow');\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.jitterTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);\n\n      // Per Component?\n      model.scalarTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.opacityTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.labelOutlineThicknessTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.openGLVolume = publicAPI.getFirstAncestorOfType('vtkOpenGLVolume');\n      const actor = model.openGLVolume.getRenderable();\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      const ren = model._openGLRenderer.getRenderable();\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());\n      publicAPI.renderPiece(ren, actor);\n    }\n  };\n  publicAPI.buildShaders = (shaders, ren, actor) => {\n    publicAPI.getShaderTemplate(shaders, ren, actor);\n    publicAPI.replaceShaderValues(shaders, ren, actor);\n  };\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkVolumeVS;\n    shaders.Fragment = vtkVolumeFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    let FSSource = shaders.Fragment;\n\n    // define some values in the shader\n    const iType = actor.getProperty().getInterpolationType();\n    if (iType === InterpolationType.LINEAR) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TrilinearOn', '#define vtkTrilinearOn').result;\n    }\n    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();\n    if (vtkImageLabelOutline === true) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ImageLabelOutlineOn', '#define vtkImageLabelOutlineOn').result;\n    }\n    const numComp = model.scalarTexture.getComponents();\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::NumComponents', `#define vtkNumComponents ${numComp}`).result;\n    const iComps = actor.getProperty().getIndependentComponents();\n    if (iComps) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::IndependentComponentsOn', '#define vtkIndependentComponentsOn').result;\n\n      // Define any proportional components\n      const proportionalComponents = [];\n      for (let nc = 0; nc < numComp; nc++) {\n        if (actor.getProperty().getOpacityMode(nc) === OpacityMode.PROPORTIONAL) {\n          proportionalComponents.push(`#define vtkComponent${nc}Proportional`);\n        }\n      }\n      if (proportionalComponents.length > 0) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::vtkProportionalComponents', proportionalComponents.join('\\n')).result;\n      }\n    }\n\n    // WebGL only supports loops over constants\n    // and does not support while loops so we\n    // have to hard code how many steps/samples to take\n    // We do a break so most systems will gracefully\n    // early terminate, but it is always possible\n    // a system will execute every step regardless\n    const ext = model.currentInput.getSpatialExtent();\n    const spc = model.currentInput.getSpacing();\n    const vsize = new Float64Array(3);\n    vec3.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);\n    const maxSamples = vec3.length(vsize) / publicAPI.getCurrentSampleDistance(ren);\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::MaximumSamplesValue', `${Math.ceil(maxSamples)}`).result;\n\n    // set light complexity\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::LightComplexity', `#define vtkLightComplexity ${model.lastLightComplexity}`).result;\n\n    // set shadow blending flag\n    if (model.lastLightComplexity > 0) {\n      if (model.renderable.getVolumetricScatteringBlending() > 0.0) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::VolumeShadowOn', `#define VolumeShadowOn`).result;\n      }\n      if (model.renderable.getVolumetricScatteringBlending() < 1.0) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::SurfaceShadowOn', `#define SurfaceShadowOn`).result;\n      }\n      if (model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0.0) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::localAmbientOcclusionOn', `#define localAmbientOcclusionOn`).result;\n      }\n    }\n\n    // if using gradient opacity define that\n    model.gopacity = actor.getProperty().getUseGradientOpacity(0);\n    for (let nc = 1; iComps && !model.gopacity && nc < numComp; ++nc) {\n      if (actor.getProperty().getUseGradientOpacity(nc)) {\n        model.gopacity = true;\n      }\n    }\n    if (model.gopacity) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::GradientOpacityOn', '#define vtkGradientOpacityOn').result;\n    }\n\n    // set normal from density\n    if (model.renderable.getComputeNormalFromOpacity()) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::vtkComputeNormalFromOpacity', `#define vtkComputeNormalFromOpacity`).result;\n    }\n\n    // if we have a ztexture then declare it and use it\n    if (model.zBufferTexture !== null) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', ['uniform sampler2D zBufferTexture;', 'uniform float vpZWidth;', 'uniform float vpZHeight;']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));', 'float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;', 'zdepth = zdepth * 2.0 - 1.0;', 'if (cameraParallel == 0) {', 'zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}', 'else {', 'zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\\n', 'zdepth = -zdepth/rayDir.z;', 'dists.y = min(zdepth,dists.y);']).result;\n    }\n\n    // Set the BlendMode approach\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::BlendMode', `${model.renderable.getBlendMode()}`).result;\n    shaders.Fragment = FSSource;\n    publicAPI.replaceShaderLight(shaders, ren, actor);\n    publicAPI.replaceShaderClippingPlane(shaders, ren, actor);\n  };\n  publicAPI.replaceShaderLight = (shaders, ren, actor) => {\n    if (model.lastLightComplexity === 0) {\n      return;\n    }\n    let FSSource = shaders.Fragment;\n    // check for shadow maps - not implemented yet, skip\n    // const shadowFactor = '';\n\n    // to-do: single out the case when complexity = 1\n\n    // only account for lights that are switched on\n    let lightNum = 0;\n    ren.getLights().forEach(light => {\n      if (light.getSwitch()) {\n        lightNum += 1;\n      }\n    });\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', [`uniform int lightNum;`, `uniform bool twoSidedLighting;`, `uniform vec3 lightColor[${lightNum}];`, `uniform vec3 lightDirectionVC[${lightNum}]; // normalized`, `uniform vec3 lightHalfAngleVC[${lightNum}];`, '//VTK::Light::Dec'], false).result;\n    // support any number of lights\n    if (model.lastLightComplexity === 3) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', [`uniform vec3 lightPositionVC[${lightNum}];`, `uniform vec3 lightAttenuation[${lightNum}];`, `uniform float lightConeAngle[${lightNum}];`, `uniform float lightExponent[${lightNum}];`, `uniform int lightPositional[${lightNum}];`], false).result;\n    }\n    if (model.renderable.getVolumetricScatteringBlending() > 0.0) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::VolumeShadow::Dec', [`uniform float volumetricScatteringBlending;`, `uniform float giReach;`, `uniform float volumeShadowSamplingDistFactor;`, `uniform float anisotropy;`, `uniform float anisotropy2;`], false).result;\n    }\n    if (model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0.0) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::LAO::Dec', [`uniform int kernelRadius;`, `uniform vec2 kernelSample[${model.renderable.getLAOKernelRadius()}];`, `uniform int kernelSize;`], false).result;\n    }\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderClippingPlane = (shaders, ren, actor) => {\n    let FSSource = shaders.Fragment;\n    if (model.renderable.getClippingPlanes().length > 0) {\n      const clipPlaneSize = model.renderable.getClippingPlanes().length;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ClipPlane::Dec', [`uniform vec3 vClipPlaneNormals[6];`, `uniform float vClipPlaneDistances[6];`, `uniform vec3 vClipPlaneOrigins[6];`, `uniform int clip_numPlanes;`, '//VTK::ClipPlane::Dec', '#define vtkClippingPlanesOn'], false).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ClipPlane::Impl', [`for(int i = 0; i < ${clipPlaneSize}; i++) {`, '  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);', '  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];', '  if (rayDirRatio == 0.0)', '  {', '    if (equationResult < 0.0) dists.x = dists.y;', '    continue;', '  }', '  float result = -1.0 * equationResult / rayDirRatio;', '  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);', '  else dists.x = max(dists.x, result);', '}', '//VTK::ClipPlane::Impl'], false).result;\n    }\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    // do we need lighting?\n    let lightComplexity = 0;\n    if (actor.getProperty().getShade() && model.renderable.getBlendMode() === BlendMode.COMPOSITE_BLEND) {\n      // consider the lighting complexity to determine which case applies\n      // simple headlight, Light Kit, the whole feature set of VTK\n      lightComplexity = 0;\n      model.numberOfLights = 0;\n      ren.getLights().forEach(light => {\n        const status = light.getSwitch();\n        if (status > 0) {\n          model.numberOfLights++;\n          if (lightComplexity === 0) {\n            lightComplexity = 1;\n          }\n        }\n        if (lightComplexity === 1 && (model.numberOfLights > 1 || light.getIntensity() !== 1.0 || !light.lightTypeIsHeadLight())) {\n          lightComplexity = 2;\n        }\n        if (lightComplexity < 3 && light.getPositional()) {\n          lightComplexity = 3;\n        }\n      });\n    }\n    let needRebuild = false;\n    if (model.lastLightComplexity !== lightComplexity) {\n      model.lastLightComplexity = lightComplexity;\n      needRebuild = true;\n    }\n    const numComp = model.scalarTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n    let usesProportionalComponents = false;\n    const proportionalComponents = [];\n    if (iComps) {\n      // Define any proportional components\n      for (let nc = 0; nc < numComp; nc++) {\n        proportionalComponents.push(actor.getProperty().getOpacityMode(nc));\n      }\n      if (proportionalComponents.length > 0) {\n        usesProportionalComponents = true;\n      }\n    }\n    const ext = model.currentInput.getSpatialExtent();\n    const spc = model.currentInput.getSpacing();\n    const vsize = new Float64Array(3);\n    vec3.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);\n    const maxSamples = vec3.length(vsize) / publicAPI.getCurrentSampleDistance(ren);\n    const state = {\n      interpolationType: actor.getProperty().getInterpolationType(),\n      useLabelOutline: actor.getProperty().getUseLabelOutline(),\n      numComp,\n      usesProportionalComponents,\n      iComps,\n      maxSamples,\n      useGradientOpacity: actor.getProperty().getUseGradientOpacity(0),\n      blendMode: model.renderable.getBlendMode(),\n      proportionalComponents\n    };\n\n    // We only need to rebuild the shader if one of these variables has changed,\n    // since they are used in the shader template replacement step.\n    if (!model.previousState || model.previousState.interpolationType !== state.interpolationType || model.previousState.useLabelOutline !== state.useLabelOutline || model.previousState.numComp !== state.numComp || model.previousState.usesProportionalComponents !== state.usesProportionalComponents || model.previousState.iComps !== state.iComps || model.previousState.maxSamples !== state.maxSamples || model.previousState.useGradientOpacity !== state.useGradientOpacity || model.previousState.blendMode !== state.blendMode || !arrayEquals(model.previousState.proportionalComponents, state.proportionalComponents)) {\n      model.previousState = {\n        ...state\n      };\n      return true;\n    }\n\n    // has something changed that would require us to recreate the shader?\n    if (cellBO.getProgram()?.getHandle() === 0 || needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || !!model.lastZBufferTexture !== !!model.zBufferTexture || cellBO.getShaderSourceTime().getMTime() < publicAPI.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime()) {\n      model.lastZBufferTexture = model.zBufferTexture;\n      return true;\n    }\n    return false;\n  };\n  publicAPI.updateShaders = (cellBO, ren, actor) => {\n    model.lastBoundBO = cellBO;\n\n    // has something changed that would require us to recreate the shader?\n    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {\n      const shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      publicAPI.buildShaders(shaders, ren, actor);\n\n      // compile and bind the program if needed\n      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);\n\n      // if the shader changed reinitialize the VAO\n      if (newShader !== cellBO.getProgram()) {\n        cellBO.setProgram(newShader);\n        // reset the VAO as the shader has changed\n        cellBO.getVAO().releaseGraphicsResources();\n      }\n      cellBO.getShaderSourceTime().modified();\n    } else {\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());\n    }\n    cellBO.getVAO().bind();\n    publicAPI.setMapperShaderParameters(cellBO, ren, actor);\n    publicAPI.setCameraShaderParameters(cellBO, ren, actor);\n    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);\n    publicAPI.getClippingPlaneShaderParameters(cellBO, ren, actor);\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    // Now to update the VAO too, if necessary.\n    const program = cellBO.getProgram();\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      if (program.isAttributeUsed('vertexDC')) {\n        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), 'vertexDC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexDC in shader VAO.');\n        }\n      }\n      cellBO.getAttributeUpdateTime().modified();\n    }\n    program.setUniformi('texture1', model.scalarTexture.getTextureUnit());\n    program.setUniformf('sampleDistance', publicAPI.getCurrentSampleDistance(ren));\n    const volInfo = model.scalarTexture.getVolumeInfo();\n    const ipScalarRange = model.renderable.getIpScalarRange();\n    const minVals = [];\n    const maxVals = [];\n    for (let i = 0; i < 4; i++) {\n      // convert iprange from 0-1 into data range values\n      minVals[i] = ipScalarRange[0] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i];\n      maxVals[i] = ipScalarRange[1] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i];\n      // convert data ranges into texture values\n      minVals[i] = (minVals[i] - volInfo.offset[i]) / volInfo.scale[i];\n      maxVals[i] = (maxVals[i] - volInfo.offset[i]) / volInfo.scale[i];\n    }\n    program.setUniform4f('ipScalarRangeMin', minVals[0], minVals[1], minVals[2], minVals[3]);\n    program.setUniform4f('ipScalarRangeMax', maxVals[0], maxVals[1], maxVals[2], maxVals[3]);\n\n    // if we have a zbuffer texture then set it\n    if (model.zBufferTexture !== null) {\n      program.setUniformi('zBufferTexture', model.zBufferTexture.getTextureUnit());\n      const size = model._useSmallViewport ? [model._smallViewportWidth, model._smallViewportHeight] : model._openGLRenderWindow.getFramebufferSize();\n      program.setUniformf('vpZWidth', size[0]);\n      program.setUniformf('vpZHeight', size[1]);\n    }\n  };\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    // // [WMVP]C == {world, model, view, projection} coordinates\n    // // E.g., WCPC == world to projection coordinate transformation\n    const keyMats = model.openGLCamera.getKeyMatrices(ren);\n    const actMats = model.openGLVolume.getKeyMatrices();\n    mat4.multiply(model.modelToView, keyMats.wcvc, actMats.mcwc);\n    const program = cellBO.getProgram();\n    const cam = model.openGLCamera.getRenderable();\n    const crange = cam.getClippingRange();\n    program.setUniformf('camThick', crange[1] - crange[0]);\n    program.setUniformf('camNear', crange[0]);\n    program.setUniformf('camFar', crange[1]);\n    const bounds = model.currentInput.getBounds();\n    const dims = model.currentInput.getDimensions();\n\n    // compute the viewport bounds of the volume\n    // we will only render those fragments.\n    const pos = new Float64Array(3);\n    const dir = new Float64Array(3);\n    let dcxmin = 1.0;\n    let dcxmax = -1.0;\n    let dcymin = 1.0;\n    let dcymax = -1.0;\n    for (let i = 0; i < 8; ++i) {\n      vec3.set(pos, bounds[i % 2], bounds[2 + Math.floor(i / 2) % 2], bounds[4 + Math.floor(i / 4)]);\n      vec3.transformMat4(pos, pos, model.modelToView);\n      if (!cam.getParallelProjection()) {\n        vec3.normalize(dir, pos);\n\n        // now find the projection of this point onto a\n        // nearZ distance plane. Since the camera is at 0,0,0\n        // in VC the ray is just t*pos and\n        // t is -nearZ/dir.z\n        // intersection becomes pos.x/pos.z\n        const t = -crange[0] / pos[2];\n        vec3.scale(pos, dir, t);\n      }\n      // now convert to DC\n      vec3.transformMat4(pos, pos, keyMats.vcpc);\n      dcxmin = Math.min(pos[0], dcxmin);\n      dcxmax = Math.max(pos[0], dcxmax);\n      dcymin = Math.min(pos[1], dcymin);\n      dcymax = Math.max(pos[1], dcymax);\n    }\n    program.setUniformf('dcxmin', dcxmin);\n    program.setUniformf('dcxmax', dcxmax);\n    program.setUniformf('dcymin', dcymin);\n    program.setUniformf('dcymax', dcymax);\n    if (program.isUniformUsed('cameraParallel')) {\n      program.setUniformi('cameraParallel', cam.getParallelProjection());\n    }\n    const ext = model.currentInput.getSpatialExtent();\n    const spc = model.currentInput.getSpacing();\n    const vsize = new Float64Array(3);\n    vec3.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);\n    program.setUniform3f('vSpacing', spc[0], spc[1], spc[2]);\n    vec3.set(pos, ext[0], ext[2], ext[4]);\n    model.currentInput.indexToWorldVec3(pos, pos);\n    vec3.transformMat4(pos, pos, model.modelToView);\n    program.setUniform3f('vOriginVC', pos[0], pos[1], pos[2]);\n\n    // apply the image directions\n    const i2wmat4 = model.currentInput.getIndexToWorld();\n    mat4.multiply(model.idxToView, model.modelToView, i2wmat4);\n    mat3.multiply(model.idxNormalMatrix, keyMats.normalMatrix, actMats.normalMatrix);\n    mat3.multiply(model.idxNormalMatrix, model.idxNormalMatrix, model.currentInput.getDirectionByReference());\n    const maxSamples = vec3.length(vsize) / publicAPI.getCurrentSampleDistance(ren);\n    if (maxSamples > model.renderable.getMaximumSamplesPerRay()) {\n      vtkWarningMacro(`The number of steps required ${Math.ceil(maxSamples)} is larger than the\n        specified maximum number of steps ${model.renderable.getMaximumSamplesPerRay()}.\n        Please either change the\n        volumeMapper sampleDistance or its maximum number of samples.`);\n    }\n    const vctoijk = new Float64Array(3);\n    vec3.set(vctoijk, 1.0, 1.0, 1.0);\n    vec3.divide(vctoijk, vctoijk, vsize);\n    program.setUniform3f('vVCToIJK', vctoijk[0], vctoijk[1], vctoijk[2]);\n    program.setUniform3i('volumeDimensions', dims[0], dims[1], dims[2]);\n    if (!model._openGLRenderWindow.getWebgl2()) {\n      const volInfo = model.scalarTexture.getVolumeInfo();\n      program.setUniformf('texWidth', model.scalarTexture.getWidth());\n      program.setUniformf('texHeight', model.scalarTexture.getHeight());\n      program.setUniformi('xreps', volInfo.xreps);\n      program.setUniformi('xstride', volInfo.xstride);\n      program.setUniformi('ystride', volInfo.ystride);\n    }\n\n    // map normals through normal matrix\n    // then use a point on the plane to compute the distance\n    const normal = new Float64Array(3);\n    const pos2 = new Float64Array(3);\n    for (let i = 0; i < 6; ++i) {\n      switch (i) {\n        case 1:\n          vec3.set(normal, -1.0, 0.0, 0.0);\n          vec3.set(pos2, ext[0], ext[2], ext[4]);\n          break;\n        case 2:\n          vec3.set(normal, 0.0, 1.0, 0.0);\n          vec3.set(pos2, ext[1], ext[3], ext[5]);\n          break;\n        case 3:\n          vec3.set(normal, 0.0, -1.0, 0.0);\n          vec3.set(pos2, ext[0], ext[2], ext[4]);\n          break;\n        case 4:\n          vec3.set(normal, 0.0, 0.0, 1.0);\n          vec3.set(pos2, ext[1], ext[3], ext[5]);\n          break;\n        case 5:\n          vec3.set(normal, 0.0, 0.0, -1.0);\n          vec3.set(pos2, ext[0], ext[2], ext[4]);\n          break;\n        case 0:\n        default:\n          vec3.set(normal, 1.0, 0.0, 0.0);\n          vec3.set(pos2, ext[1], ext[3], ext[5]);\n          break;\n      }\n      vec3.transformMat3(normal, normal, model.idxNormalMatrix);\n      vec3.transformMat4(pos2, pos2, model.idxToView);\n      const dist = -1.0 * vec3.dot(pos2, normal);\n\n      // we have the plane in view coordinates\n      // specify the planes in view coordinates\n      program.setUniform3f(`vPlaneNormal${i}`, normal[0], normal[1], normal[2]);\n      program.setUniformf(`vPlaneDistance${i}`, dist);\n    }\n    if (actor.getProperty().getUseLabelOutline()) {\n      const image = model.currentInput;\n      const worldToIndex = image.getWorldToIndex();\n      program.setUniformMatrix('vWCtoIDX', worldToIndex);\n      const camera = ren.getActiveCamera();\n      const [cRange0, cRange1] = camera.getClippingRange();\n      const distance = camera.getDistance();\n\n      // set the clipping range to be model.distance and model.distance + 0.1\n      // since we use the in the keyMats.wcpc (world to projection) matrix\n      // the projection matrix calculation relies on the clipping range to be\n      // set correctly. This is done inside the interactorStyleMPRSlice which\n      // limits use cases where the interactor style is not used.\n\n      camera.setClippingRange(distance, distance + 0.1);\n      const labelOutlineKeyMats = model.openGLCamera.getKeyMatrices(ren);\n\n      // Get the projection coordinate to world coordinate transformation matrix.\n      mat4.invert(model.projectionToWorld, labelOutlineKeyMats.wcpc);\n\n      // reset the clipping range since the keyMats are cached\n      camera.setClippingRange(cRange0, cRange1);\n\n      // to re compute the matrices for the current camera and cache them\n      model.openGLCamera.getKeyMatrices(ren);\n      program.setUniformMatrix('PCWCMatrix', model.projectionToWorld);\n      const size = publicAPI.getRenderTargetSize();\n      program.setUniformf('vpWidth', size[0]);\n      program.setUniformf('vpHeight', size[1]);\n      const offset = publicAPI.getRenderTargetOffset();\n      program.setUniformf('vpOffsetX', offset[0] / size[0]);\n      program.setUniformf('vpOffsetY', offset[1] / size[1]);\n    }\n    mat4.invert(model.projectionToView, keyMats.vcpc);\n    program.setUniformMatrix('PCVCMatrix', model.projectionToView);\n\n    // handle lighting values\n    if (model.lastLightComplexity === 0) {\n      return;\n    }\n    let lightNum = 0;\n    const lightColor = [];\n    const lightDir = [];\n    const halfAngle = [];\n    ren.getLights().forEach(light => {\n      const status = light.getSwitch();\n      if (status > 0) {\n        const dColor = light.getColor();\n        const intensity = light.getIntensity();\n        lightColor[0 + lightNum * 3] = dColor[0] * intensity;\n        lightColor[1 + lightNum * 3] = dColor[1] * intensity;\n        lightColor[2 + lightNum * 3] = dColor[2] * intensity;\n        const ldir = light.getDirection();\n        vec3.set(normal, ldir[0], ldir[1], ldir[2]);\n        vec3.transformMat3(normal, normal, keyMats.normalMatrix); // in view coordinat\n        vec3.normalize(normal, normal);\n        lightDir[0 + lightNum * 3] = normal[0];\n        lightDir[1 + lightNum * 3] = normal[1];\n        lightDir[2 + lightNum * 3] = normal[2];\n        // camera DOP is 0,0,-1.0 in VC\n        halfAngle[0 + lightNum * 3] = -0.5 * normal[0];\n        halfAngle[1 + lightNum * 3] = -0.5 * normal[1];\n        halfAngle[2 + lightNum * 3] = -0.5 * (normal[2] - 1.0);\n        lightNum++;\n      }\n    });\n    program.setUniformi('twoSidedLighting', ren.getTwoSidedLighting());\n    program.setUniformi('lightNum', lightNum);\n    program.setUniform3fv('lightColor', lightColor);\n    program.setUniform3fv('lightDirectionVC', lightDir);\n    program.setUniform3fv('lightHalfAngleVC', halfAngle);\n    if (model.lastLightComplexity === 3) {\n      lightNum = 0;\n      const lightPositionVC = [];\n      const lightAttenuation = [];\n      const lightConeAngle = [];\n      const lightExponent = [];\n      const lightPositional = [];\n      ren.getLights().forEach(light => {\n        const status = light.getSwitch();\n        if (status > 0) {\n          const attenuation = light.getAttenuationValues();\n          lightAttenuation[0 + lightNum * 3] = attenuation[0];\n          lightAttenuation[1 + lightNum * 3] = attenuation[1];\n          lightAttenuation[2 + lightNum * 3] = attenuation[2];\n          lightExponent[lightNum] = light.getExponent();\n          lightConeAngle[lightNum] = light.getConeAngle();\n          lightPositional[lightNum] = light.getPositional();\n          const lp = light.getTransformedPosition();\n          vec3.transformMat4(lp, lp, model.modelToView);\n          lightPositionVC[0 + lightNum * 3] = lp[0];\n          lightPositionVC[1 + lightNum * 3] = lp[1];\n          lightPositionVC[2 + lightNum * 3] = lp[2];\n          lightNum += 1;\n        }\n      });\n      program.setUniform3fv('lightPositionVC', lightPositionVC);\n      program.setUniform3fv('lightAttenuation', lightAttenuation);\n      program.setUniformfv('lightConeAngle', lightConeAngle);\n      program.setUniformfv('lightExponent', lightExponent);\n      program.setUniformiv('lightPositional', lightPositional);\n    }\n    if (model.renderable.getVolumetricScatteringBlending() > 0.0) {\n      program.setUniformf('giReach', model.renderable.getGlobalIlluminationReach());\n      program.setUniformf('volumetricScatteringBlending', model.renderable.getVolumetricScatteringBlending());\n      program.setUniformf('volumeShadowSamplingDistFactor', model.renderable.getVolumeShadowSamplingDistFactor());\n      program.setUniformf('anisotropy', model.renderable.getAnisotropy());\n      program.setUniformf('anisotropy2', model.renderable.getAnisotropy() ** 2.0);\n    }\n    if (model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0.0) {\n      const ks = model.renderable.getLAOKernelSize();\n      program.setUniformi('kernelSize', ks);\n      const kernelSample = [];\n      for (let i = 0; i < ks; i++) {\n        kernelSample[i * 2] = Math.random() * 0.5;\n        kernelSample[i * 2 + 1] = Math.random() * 0.5;\n      }\n      program.setUniform2fv('kernelSample', kernelSample);\n      program.setUniformi('kernelRadius', model.renderable.getLAOKernelRadius());\n    }\n  };\n  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    program.setUniformi('ctexture', model.colorTexture.getTextureUnit());\n    program.setUniformi('otexture', model.opacityTexture.getTextureUnit());\n    program.setUniformi('jtexture', model.jitterTexture.getTextureUnit());\n    program.setUniformi('ttexture', model.labelOutlineThicknessTexture.getTextureUnit());\n    const volInfo = model.scalarTexture.getVolumeInfo();\n    const vprop = actor.getProperty();\n\n    // set the component mix when independent\n    const numComp = model.scalarTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n    if (iComps && numComp >= 2) {\n      for (let i = 0; i < numComp; i++) {\n        program.setUniformf(`mix${i}`, actor.getProperty().getComponentWeight(i));\n      }\n    }\n\n    // three levels of shift scale combined into one\n    // for performance in the fragment shader\n    for (let i = 0; i < numComp; i++) {\n      const target = iComps ? i : 0;\n      const sscale = volInfo.scale[i];\n      const ofun = vprop.getScalarOpacity(target);\n      const oRange = ofun.getRange();\n      const oscale = sscale / (oRange[1] - oRange[0]);\n      const oshift = (volInfo.offset[i] - oRange[0]) / (oRange[1] - oRange[0]);\n      program.setUniformf(`oshift${i}`, oshift);\n      program.setUniformf(`oscale${i}`, oscale);\n      const cfun = vprop.getRGBTransferFunction(target);\n      const cRange = cfun.getRange();\n      const cshift = (volInfo.offset[i] - cRange[0]) / (cRange[1] - cRange[0]);\n      const cScale = sscale / (cRange[1] - cRange[0]);\n      program.setUniformf(`cshift${i}`, cshift);\n      program.setUniformf(`cscale${i}`, cScale);\n    }\n    if (model.gopacity) {\n      if (iComps) {\n        for (let nc = 0; nc < numComp; ++nc) {\n          const sscale = volInfo.scale[nc];\n          const useGO = vprop.getUseGradientOpacity(nc);\n          if (useGO) {\n            const gomin = vprop.getGradientOpacityMinimumOpacity(nc);\n            const gomax = vprop.getGradientOpacityMaximumOpacity(nc);\n            program.setUniformf(`gomin${nc}`, gomin);\n            program.setUniformf(`gomax${nc}`, gomax);\n            const goRange = [vprop.getGradientOpacityMinimumValue(nc), vprop.getGradientOpacityMaximumValue(nc)];\n            program.setUniformf(`goscale${nc}`, sscale * (gomax - gomin) / (goRange[1] - goRange[0]));\n            program.setUniformf(`goshift${nc}`, -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin);\n          } else {\n            program.setUniformf(`gomin${nc}`, 1.0);\n            program.setUniformf(`gomax${nc}`, 1.0);\n            program.setUniformf(`goscale${nc}`, 0.0);\n            program.setUniformf(`goshift${nc}`, 1.0);\n          }\n        }\n      } else {\n        const sscale = volInfo.scale[numComp - 1];\n        const gomin = vprop.getGradientOpacityMinimumOpacity(0);\n        const gomax = vprop.getGradientOpacityMaximumOpacity(0);\n        program.setUniformf('gomin0', gomin);\n        program.setUniformf('gomax0', gomax);\n        const goRange = [vprop.getGradientOpacityMinimumValue(0), vprop.getGradientOpacityMaximumValue(0)];\n        program.setUniformf('goscale0', sscale * (gomax - gomin) / (goRange[1] - goRange[0]));\n        program.setUniformf('goshift0', -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin);\n      }\n    }\n    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();\n    if (vtkImageLabelOutline === true) {\n      const labelOutlineOpacity = actor.getProperty().getLabelOutlineOpacity();\n      program.setUniformf('outlineOpacity', labelOutlineOpacity);\n    }\n    if (model.lastLightComplexity > 0) {\n      program.setUniformf('vAmbient', vprop.getAmbient());\n      program.setUniformf('vDiffuse', vprop.getDiffuse());\n      program.setUniformf('vSpecular', vprop.getSpecular());\n      program.setUniformf('vSpecularPower', vprop.getSpecularPower());\n    }\n  };\n  publicAPI.getClippingPlaneShaderParameters = (cellBO, ren, actor) => {\n    if (model.renderable.getClippingPlanes().length > 0) {\n      const keyMats = model.openGLCamera.getKeyMatrices(ren);\n      const clipPlaneNormals = [];\n      const clipPlaneDistances = [];\n      const clipPlaneOrigins = [];\n      const clipPlanes = model.renderable.getClippingPlanes();\n      const clipPlaneSize = clipPlanes.length;\n      for (let i = 0; i < clipPlaneSize; ++i) {\n        const clipPlaneNormal = clipPlanes[i].getNormal();\n        const clipPlanePos = clipPlanes[i].getOrigin();\n        vec3.transformMat3(clipPlaneNormal, clipPlaneNormal, keyMats.normalMatrix);\n        vec3.transformMat4(clipPlanePos, clipPlanePos, keyMats.wcvc);\n        const clipPlaneDist = -1.0 * vec3.dot(clipPlanePos, clipPlaneNormal);\n        clipPlaneNormals.push(clipPlaneNormal[0]);\n        clipPlaneNormals.push(clipPlaneNormal[1]);\n        clipPlaneNormals.push(clipPlaneNormal[2]);\n        clipPlaneDistances.push(clipPlaneDist);\n        clipPlaneOrigins.push(clipPlanePos[0]);\n        clipPlaneOrigins.push(clipPlanePos[1]);\n        clipPlaneOrigins.push(clipPlanePos[2]);\n      }\n      const program = cellBO.getProgram();\n      program.setUniform3fv(`vClipPlaneNormals`, clipPlaneNormals);\n      program.setUniformfv(`vClipPlaneDistances`, clipPlaneDistances);\n      program.setUniform3fv(`vClipPlaneOrigins`, clipPlaneOrigins);\n      program.setUniformi(`clip_numPlanes`, clipPlaneSize);\n    }\n  };\n\n  // unsubscribe from our listeners\n  publicAPI.delete = chain(() => {\n    if (model._animationRateSubscription) {\n      model._animationRateSubscription.unsubscribe();\n      model._animationRateSubscription = null;\n    }\n  }, publicAPI.delete);\n  publicAPI.getRenderTargetSize = () => {\n    if (model._useSmallViewport) {\n      return [model._smallViewportWidth, model._smallViewportHeight];\n    }\n    const {\n      usize,\n      vsize\n    } = model._openGLRenderer.getTiledSizeAndOrigin();\n    return [usize, vsize];\n  };\n  publicAPI.getRenderTargetOffset = () => {\n    const {\n      lowerLeftU,\n      lowerLeftV\n    } = model._openGLRenderer.getTiledSizeAndOrigin();\n    return [lowerLeftU, lowerLeftV];\n  };\n  publicAPI.getCurrentSampleDistance = ren => {\n    const rwi = ren.getVTKWindow().getInteractor();\n    const baseSampleDistance = model.renderable.getSampleDistance();\n    if (rwi.isAnimating()) {\n      const factor = model.renderable.getInteractionSampleDistanceFactor();\n      return baseSampleDistance * factor;\n    }\n    return baseSampleDistance;\n  };\n  publicAPI.renderPieceStart = (ren, actor) => {\n    const rwi = ren.getVTKWindow().getInteractor();\n    if (!model._lastScale) {\n      model._lastScale = model.renderable.getInitialInteractionScale();\n    }\n    model._useSmallViewport = false;\n    if (rwi.isAnimating() && model._lastScale > 1.5) {\n      model._useSmallViewport = true;\n    }\n    if (!model._animationRateSubscription) {\n      // when the animation frame rate changes recompute the scale factor\n      model._animationRateSubscription = rwi.onAnimationFrameRateUpdate(() => {\n        if (model.renderable.getAutoAdjustSampleDistances()) {\n          const frate = rwi.getRecentAnimationFrameRate();\n          const adjustment = rwi.getDesiredUpdateRate() / frate;\n\n          // only change if we are off by 15%\n          if (adjustment > 1.15 || adjustment < 0.85) {\n            model._lastScale *= adjustment;\n          }\n          // clamp scale to some reasonable values.\n          // Below 1.5 we will just be using full resolution as that is close enough\n          // Above 400 seems like a lot so we limit to that 1/20th per axis\n          if (model._lastScale > 400) {\n            model._lastScale = 400;\n          }\n          if (model._lastScale < 1.5) {\n            model._lastScale = 1.5;\n          }\n        } else {\n          model._lastScale = model.renderable.getImageSampleDistance() * model.renderable.getImageSampleDistance();\n        }\n      });\n    }\n\n    // use/create/resize framebuffer if needed\n    if (model._useSmallViewport) {\n      const size = model._openGLRenderWindow.getFramebufferSize();\n      const scaleFactor = 1 / Math.sqrt(model._lastScale);\n      model._smallViewportWidth = Math.ceil(scaleFactor * size[0]);\n      model._smallViewportHeight = Math.ceil(scaleFactor * size[1]);\n\n      // adjust viewportSize to always be at most the dest fo size\n      if (model._smallViewportHeight > size[1]) {\n        model._smallViewportHeight = size[1];\n      }\n      if (model._smallViewportWidth > size[0]) {\n        model._smallViewportWidth = size[0];\n      }\n      model.framebuffer.saveCurrentBindingsAndBuffers();\n      if (model.framebuffer.getGLFramebuffer() === null) {\n        model.framebuffer.create(size[0], size[1]);\n        model.framebuffer.populateFramebuffer();\n      } else {\n        const fbSize = model.framebuffer.getSize();\n        if (fbSize[0] !== size[0] || fbSize[1] !== size[1]) {\n          model.framebuffer.create(size[0], size[1]);\n          model.framebuffer.populateFramebuffer();\n        }\n      }\n      model.framebuffer.bind();\n      const gl = model.context;\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n      gl.colorMask(true, true, true, true);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      gl.viewport(0, 0, model._smallViewportWidth, model._smallViewportHeight);\n      model.fvp = [model._smallViewportWidth / size[0], model._smallViewportHeight / size[1]];\n    }\n    model.context.disable(model.context.DEPTH_TEST);\n\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor);\n\n    // set interpolation on the texture based on property setting\n    const iType = actor.getProperty().getInterpolationType();\n    if (iType === InterpolationType.NEAREST) {\n      model.scalarTexture.setMinificationFilter(Filter.NEAREST);\n      model.scalarTexture.setMagnificationFilter(Filter.NEAREST);\n    } else {\n      model.scalarTexture.setMinificationFilter(Filter.LINEAR);\n      model.scalarTexture.setMagnificationFilter(Filter.LINEAR);\n    }\n\n    // Bind the OpenGL, this is shared between the different primitive/cell types.\n    model.lastBoundBO = null;\n\n    // if we have a zbuffer texture then activate it\n    if (model.zBufferTexture !== null) {\n      model.zBufferTexture.activate();\n    }\n  };\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const gl = model.context;\n\n    // render the texture\n    model.scalarTexture.activate();\n    model.opacityTexture.activate();\n    model.labelOutlineThicknessTexture.activate();\n    model.colorTexture.activate();\n    model.jitterTexture.activate();\n    publicAPI.updateShaders(model.tris, ren, actor);\n\n    // First we do the triangles, update the shader, set uniforms, etc.\n    // for (let i = 0; i < 11; ++i) {\n    //   gl.drawArrays(gl.TRIANGLES, 66 * i, 66);\n    // }\n    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n    model.tris.getVAO().release();\n    model.scalarTexture.deactivate();\n    model.colorTexture.deactivate();\n    model.opacityTexture.deactivate();\n    model.labelOutlineThicknessTexture.deactivate();\n    model.jitterTexture.deactivate();\n  };\n  publicAPI.renderPieceFinish = (ren, actor) => {\n    // if we have a zbuffer texture then deactivate it\n    if (model.zBufferTexture !== null) {\n      model.zBufferTexture.deactivate();\n    }\n    if (model._useSmallViewport) {\n      // now copy the framebuffer with the volume into the\n      // regular buffer\n      model.framebuffer.restorePreviousBindingsAndBuffers();\n      if (model.copyShader === null) {\n        model.copyShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(['//VTK::System::Dec', 'attribute vec4 vertexDC;', 'uniform vec2 tfactor;', 'varying vec2 tcoord;', 'void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }'].join('\\n'), ['//VTK::System::Dec', '//VTK::Output::Dec', 'uniform sampler2D texture1;', 'varying vec2 tcoord;', 'void main() { gl_FragData[0] = texture2D(texture1,tcoord); }'].join('\\n'), '');\n        const program = model.copyShader;\n        model.copyVAO = vtkVertexArrayObject.newInstance();\n        model.copyVAO.setOpenGLRenderWindow(model._openGLRenderWindow);\n        model.tris.getCABO().bind();\n        if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), 'vertexDC', model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexDC in copy shader VAO.');\n        }\n      } else {\n        model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.copyShader);\n      }\n      const size = model._openGLRenderWindow.getFramebufferSize();\n      model.context.viewport(0, 0, size[0], size[1]);\n\n      // activate texture\n      const tex = model.framebuffer.getColorTexture();\n      tex.activate();\n      model.copyShader.setUniformi('texture', tex.getTextureUnit());\n      model.copyShader.setUniform2f('tfactor', model.fvp[0], model.fvp[1]);\n      const gl = model.context;\n      gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n      // render quad\n      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n      tex.deactivate();\n      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    }\n  };\n  publicAPI.renderPiece = (ren, actor) => {\n    publicAPI.invokeEvent({\n      type: 'StartEvent'\n    });\n    model.renderable.update();\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.invokeEvent({\n      type: 'EndEvent'\n    });\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n  publicAPI.computeBounds = (ren, actor) => {\n    if (!publicAPI.getInput()) {\n      uninitializeBounds(model.Bounds);\n      return;\n    }\n    model.bounds = publicAPI.getInput().getBounds();\n  };\n  publicAPI.updateBufferObjects = (ren, actor) => {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {\n    // first do a coarse check\n    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const image = model.currentInput;\n    if (!image) {\n      return;\n    }\n    const scalars = image.getPointData() && image.getPointData().getScalars();\n    if (!scalars) {\n      return;\n    }\n    if (model._scalars !== scalars) {\n      model._openGLRenderWindow.releaseGraphicsResourcesForObject(model._scalars);\n      model._scalars = scalars;\n    }\n    const vprop = actor.getProperty();\n    if (!model.jitterTexture.getHandle()) {\n      const oTable = new Uint8Array(32 * 32);\n      for (let i = 0; i < 32 * 32; ++i) {\n        oTable[i] = 255.0 * Math.random();\n      }\n      model.jitterTexture.setMinificationFilter(Filter.LINEAR);\n      model.jitterTexture.setMagnificationFilter(Filter.LINEAR);\n      model.jitterTexture.create2DFromRaw(32, 32, 1, VtkDataTypes.UNSIGNED_CHAR, oTable);\n    }\n    const numComp = scalars.getNumberOfComponents();\n    const iComps = vprop.getIndependentComponents();\n    const numIComps = iComps ? numComp : 1;\n    const scalarOpacityFunc = vprop.getScalarOpacity();\n    const opTex = model._openGLRenderWindow.getGraphicsResourceForObject(scalarOpacityFunc);\n    let toString = computeFnToString(vprop, scalarOpacityFunc, numIComps);\n    const reBuildOp = !opTex.vtkObj || opTex.hash !== toString || model.opacityTextureString !== toString;\n    if (reBuildOp) {\n      // rebuild opacity tfun?\n      const oWidth = 1024;\n      const oSize = oWidth * 2 * numIComps;\n      const ofTable = new Float32Array(oSize);\n      const tmpTable = new Float32Array(oWidth);\n      for (let c = 0; c < numIComps; ++c) {\n        const ofun = vprop.getScalarOpacity(c);\n        const opacityFactor = publicAPI.getCurrentSampleDistance(ren) / vprop.getScalarOpacityUnitDistance(c);\n        const oRange = ofun.getRange();\n        ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);\n        // adjust for sample distance etc\n        for (let i = 0; i < oWidth; ++i) {\n          ofTable[c * oWidth * 2 + i] = 1.0 - (1.0 - tmpTable[i]) ** opacityFactor;\n          ofTable[c * oWidth * 2 + i + oWidth] = ofTable[c * oWidth * 2 + i];\n        }\n      }\n      model.opacityTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.opacityTexture.resetFormatAndType();\n      model.opacityTexture.setMinificationFilter(Filter.LINEAR);\n      model.opacityTexture.setMagnificationFilter(Filter.LINEAR);\n\n      // use float texture where possible because we really need the resolution\n      // for this table. Errors in low values of opacity accumulate to\n      // visible artifacts. High values of opacity quickly terminate without\n      // artifacts.\n      if (model._openGLRenderWindow.getWebgl2() || model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes.FLOAT, ofTable);\n      } else {\n        const oTable = new Uint8Array(oSize);\n        for (let i = 0; i < oSize; ++i) {\n          oTable[i] = 255.0 * ofTable[i];\n        }\n        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes.UNSIGNED_CHAR, oTable);\n      }\n      model.opacityTextureString = toString;\n      if (scalarOpacityFunc) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(scalarOpacityFunc, model.opacityTexture, model.opacityTextureString);\n      }\n    } else {\n      model.opacityTexture = opTex.vtkObj;\n      model.opacityTextureString = opTex.hash;\n    }\n\n    // rebuild color tfun?\n    const colorTransferFunc = vprop.getRGBTransferFunction();\n    toString = computeFnToString(vprop, colorTransferFunc, numIComps);\n    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);\n    const reBuildC = !cTex?.vtkObj || cTex?.hash !== toString || model.colorTextureString !== toString;\n    if (reBuildC) {\n      const cWidth = 1024;\n      const cSize = cWidth * 2 * numIComps * 3;\n      const cTable = new Uint8Array(cSize);\n      const tmpTable = new Float32Array(cWidth * 3);\n      for (let c = 0; c < numIComps; ++c) {\n        const cfun = vprop.getRGBTransferFunction(c);\n        const cRange = cfun.getRange();\n        cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);\n        for (let i = 0; i < cWidth * 3; ++i) {\n          cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n          cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];\n        }\n      }\n      model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.colorTexture.resetFormatAndType();\n      model.colorTexture.setMinificationFilter(Filter.LINEAR);\n      model.colorTexture.setMagnificationFilter(Filter.LINEAR);\n      model.colorTexture.create2DFromRaw(cWidth, 2 * numIComps, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      model.colorTextureString = toString;\n      if (colorTransferFunc) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, model.colorTextureString);\n      }\n    } else {\n      model.colorTexture = cTex.vtkObj;\n      model.colorTextureString = cTex.hash;\n    }\n    publicAPI.updateLabelOutlineThicknessTexture(actor);\n    const tex = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);\n    // rebuild the scalarTexture if the data has changed\n    toString = `${image.getMTime()}A${scalars.getMTime()}`;\n    const reBuildTex = !tex?.vtkObj || tex?.hash !== toString || model.scalarTextureString !== toString;\n    if (reBuildTex) {\n      // Build the textures\n      const dims = image.getDimensions();\n      // Use norm16 for scalar texture if the extension is available\n      model.scalarTexture.setOglNorm16Ext(model.context.getExtension('EXT_texture_norm16'));\n      model.scalarTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.scalarTexture.resetFormatAndType();\n      model.scalarTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars, model.renderable.getPreferSizeOverAccuracy());\n      model.scalarTextureString = toString;\n      if (scalars) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(scalars, model.scalarTexture, model.scalarTextureString);\n      }\n    } else {\n      model.scalarTexture = tex.vtkObj;\n      model.scalarTextureString = tex.hash;\n    }\n    if (!model.tris.getCABO().getElementCount()) {\n      // build the CABO\n      const ptsArray = new Float32Array(12);\n      for (let i = 0; i < 4; i++) {\n        ptsArray[i * 3] = i % 2 * 2 - 1.0;\n        ptsArray[i * 3 + 1] = i > 1 ? 1.0 : -1.0;\n        ptsArray[i * 3 + 2] = -1.0;\n      }\n      const cellArray = new Uint16Array(8);\n      cellArray[0] = 3;\n      cellArray[1] = 0;\n      cellArray[2] = 1;\n      cellArray[3] = 3;\n      cellArray[4] = 3;\n      cellArray[5] = 0;\n      cellArray[6] = 3;\n      cellArray[7] = 2;\n\n      // const dim = 12.0;\n      // const ptsArray = new Float32Array(3 * dim * dim);\n      // for (let i = 0; i < dim; i++) {\n      //   for (let j = 0; j < dim; j++) {\n      //     const offset = ((i * dim) + j) * 3;\n      //     ptsArray[offset] = (2.0 * (i / (dim - 1.0))) - 1.0;\n      //     ptsArray[offset + 1] = (2.0 * (j / (dim - 1.0))) - 1.0;\n      //     ptsArray[offset + 2] = -1.0;\n      //   }\n      // }\n\n      // const cellArray = new Uint16Array(8 * (dim - 1) * (dim - 1));\n      // for (let i = 0; i < dim - 1; i++) {\n      //   for (let j = 0; j < dim - 1; j++) {\n      //     const offset = 8 * ((i * (dim - 1)) + j);\n      //     cellArray[offset] = 3;\n      //     cellArray[offset + 1] = (i * dim) + j;\n      //     cellArray[offset + 2] = (i * dim) + 1 + j;\n      //     cellArray[offset + 3] = ((i + 1) * dim) + 1 + j;\n      //     cellArray[offset + 4] = 3;\n      //     cellArray[offset + 5] = (i * dim) + j;\n      //     cellArray[offset + 6] = ((i + 1) * dim) + 1 + j;\n      //     cellArray[offset + 7] = ((i + 1) * dim) + j;\n      //   }\n      // }\n\n      const points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: ptsArray\n      });\n      points.setName('points');\n      const cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: cellArray\n      });\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n        points,\n        cellOffset: 0\n      });\n    }\n    model.VBOBuildTime.modified();\n  };\n  publicAPI.updateLabelOutlineThicknessTexture = volume => {\n    const labelOutlineThicknessArray = volume.getProperty().getLabelOutlineThickness();\n    const lTex = model._openGLRenderWindow.getGraphicsResourceForObject(labelOutlineThicknessArray);\n\n    // compute the join of the labelOutlineThicknessArray so that\n    // we can use it to decide whether to rebuild the labelOutlineThicknessTexture\n    // or not\n    const toString = `${labelOutlineThicknessArray.join('-')}`;\n    const reBuildL = !lTex?.vtkObj || lTex?.hash !== toString || model.labelOutlineThicknessTextureString !== toString;\n    if (reBuildL) {\n      const lWidth = 1024;\n      const lHeight = 1;\n      const lSize = lWidth * lHeight;\n      const lTable = new Uint8Array(lSize);\n\n      // Assuming labelOutlineThicknessArray contains the thickness for each segment\n      for (let i = 0; i < lWidth; ++i) {\n        // Retrieve the thickness value for the current segment index.\n        // If the value is undefined, null, or 0, use the first element's value as a default.\n        const thickness = labelOutlineThicknessArray[i] || labelOutlineThicknessArray[0];\n        lTable[i] = thickness;\n      }\n      model.labelOutlineThicknessTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.labelOutlineThicknessTexture.resetFormatAndType();\n      model.labelOutlineThicknessTexture.setMinificationFilter(Filter.NEAREST);\n      model.labelOutlineThicknessTexture.setMagnificationFilter(Filter.NEAREST);\n\n      // Create a 2D texture (acting as 1D) from the raw data\n      model.labelOutlineThicknessTexture.create2DFromRaw(lWidth, lHeight, 1, VtkDataTypes.UNSIGNED_CHAR, lTable);\n      model.labelOutlineThicknessTextureString = toString;\n      if (labelOutlineThicknessArray) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(labelOutlineThicknessArray, model.labelOutlineThicknessTexture, model.labelOutlineThicknessTextureString);\n      }\n    } else {\n      model.labelOutlineThicknessTexture = lTex.vtkObj;\n      model.labelOutlineThicknessTextureString = lTex.hash;\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  VBOBuildTime: null,\n  scalarTexture: null,\n  scalarTextureString: null,\n  opacityTexture: null,\n  opacityTextureString: null,\n  colorTexture: null,\n  colorTextureString: null,\n  jitterTexture: null,\n  labelOutlineThicknessTexture: null,\n  labelOutlineThicknessTextureString: null,\n  tris: null,\n  framebuffer: null,\n  copyShader: null,\n  copyVAO: null,\n  lastXYF: 1.0,\n  targetXYF: 1.0,\n  zBufferTexture: null,\n  lastZBufferTexture: null,\n  lastLightComplexity: 0,\n  fullViewportTime: 1.0,\n  idxToView: null,\n  idxNormalMatrix: null,\n  modelToView: null,\n  projectionToView: null,\n  avgWindowArea: 0.0,\n  avgFrameTime: 0.0,\n  _scalars: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime, {\n    mtime: 0\n  });\n  model.tris = vtkHelper.newInstance();\n  model.scalarTexture = vtkOpenGLTexture.newInstance();\n  model.opacityTexture = vtkOpenGLTexture.newInstance();\n  model.colorTexture = vtkOpenGLTexture.newInstance();\n  model.jitterTexture = vtkOpenGLTexture.newInstance();\n  model.jitterTexture.setWrapS(Wrap.REPEAT);\n  model.jitterTexture.setWrapT(Wrap.REPEAT);\n  model.labelOutlineThicknessTexture = vtkOpenGLTexture.newInstance();\n  model.framebuffer = vtkOpenGLFramebuffer.newInstance();\n  model.idxToView = mat4.identity(new Float64Array(16));\n  model.idxNormalMatrix = mat3.identity(new Float64Array(9));\n  model.modelToView = mat4.identity(new Float64Array(16));\n  model.projectionToView = mat4.identity(new Float64Array(16));\n  model.projectionToWorld = mat4.identity(new Float64Array(16));\n\n  // Build VTK API\n  setGet(publicAPI, model, ['context']);\n\n  // Object methods\n  vtkOpenGLVolumeMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLVolumeMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkVolumeMapper = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkVolumeMapper', newInstance);\n\nexport { vtkVolumeMapper as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}