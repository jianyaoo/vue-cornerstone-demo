import { vec3 } from 'gl-matrix';
import { getEnabledElement, utilities as csUtils, VolumeViewport, } from '@cornerstonejs/core';
import { removeAnnotation } from '../../stateManagement/annotation/annotationState';
import { drawHandles as drawHandlesSvg } from '../../drawingSvg';
import { state } from '../../store';
import { Events, KeyboardBindings, ChangeTypes } from '../../enums';
import { resetElementCursor } from '../../cursors/elementCursor';
import getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';
import { math, triggerAnnotationRenderForViewportIds } from '../../utilities';
import findHandlePolylineIndex from '../../utilities/contours/findHandlePolylineIndex';
import { ContourWindingDirection } from '../../types/ContourAnnotation';
import { triggerAnnotationModified, triggerContourAnnotationCompleted, } from '../../stateManagement/annotation/helpers/state';
import { LivewireScissors } from '../../utilities/livewire/LivewireScissors';
import { LivewirePath } from '../../utilities/livewire/LiveWirePath';
import { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';
import ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';
const CLICK_CLOSE_CURVE_SQR_DIST = 10 ** 2;
class LivewireContourTool extends ContourSegmentationBaseTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            preventHandleOutsideImage: false,
            contourHoleAdditionModifierKey: KeyboardBindings.Shift,
            snapHandleNearby: 2,
            interpolation: {
                enabled: false,
                nearestEdge: 2,
                showInterpolationPolyline: false,
            },
            decimate: {
                enabled: false,
                epsilon: 0.1,
            },
            actions: {
                undo: {
                    method: 'undo',
                    bindings: [
                        {
                            key: 'Escape',
                        },
                    ],
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = getEnabledElement(element);
            const { viewport } = enabledElement;
            const proximitySquared = proximity * proximity;
            const canvasPoints = annotation.data.contour.polyline.map((p) => viewport.worldToCanvas(p));
            let startPoint = canvasPoints[canvasPoints.length - 1];
            for (let i = 0; i < canvasPoints.length; i++) {
                const endPoint = canvasPoints[i];
                const distanceToPointSquared = math.lineSegment.distanceToPointSquared(startPoint, endPoint, canvasCoords);
                if (distanceToPointSquared <= proximitySquared) {
                    return true;
                }
                startPoint = endPoint;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
            };
            const enabledElement = getEnabledElement(element);
            const { renderingEngine } = enabledElement;
            this._activateModify(element);
            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            const { points } = data.handles;
            const handleIndex = points.findIndex((p) => p === handle);
            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
            };
            this._activateModify(element);
            const enabledElement = getEnabledElement(element);
            const { renderingEngine } = enabledElement;
            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt, clearAnnotation = false) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;
            const { data } = annotation;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            resetElementCursor(element);
            const enabledElement = getEnabledElement(element);
            const { renderingEngine } = enabledElement;
            if ((this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) ||
                clearAnnotation) {
                removeAnnotation(annotation.annotationUID);
                this.clearEditData();
                triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);
                return;
            }
            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);
            const changeType = newAnnotation
                ? ChangeTypes.Completed
                : ChangeTypes.HandlesUpdated;
            this.triggerChangeEvent(annotation, enabledElement, changeType, contourHoleProcessingEnabled);
            this.clearEditData();
        };
        this.triggerChangeEvent = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated, contourHoleProcessingEnabled = false) => {
            if (changeType === ChangeTypes.Completed) {
                triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);
            }
            else {
                triggerAnnotationModified(annotation, enabledElement.viewport.element, changeType);
            }
        };
        this._mouseDownCallback = (evt) => {
            const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;
            const { annotation, viewportIdsToRender, worldToSlice, sliceToWorld } = this.editData;
            if (this.editData.closed) {
                return;
            }
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const { canvas: canvasPos, world: worldPosOriginal } = currentPoints;
            let worldPos = worldPosOriginal;
            const enabledElement = getEnabledElement(element);
            const { viewport, renderingEngine } = enabledElement;
            const controlPoints = this.editData.currentPath.getControlPoints();
            let closePath = controlPoints.length >= 2 && doubleClick;
            if (controlPoints.length >= 2) {
                const closestHandlePoint = {
                    index: -1,
                    distSquared: Infinity,
                };
                for (let i = 0, len = controlPoints.length; i < len; i++) {
                    const controlPoint = controlPoints[i];
                    const worldControlPoint = sliceToWorld(controlPoint);
                    const canvasControlPoint = viewport.worldToCanvas(worldControlPoint);
                    const distSquared = math.point.distanceToPointSquared(canvasPos, canvasControlPoint);
                    if (distSquared <= CLICK_CLOSE_CURVE_SQR_DIST &&
                        distSquared < closestHandlePoint.distSquared) {
                        closestHandlePoint.distSquared = distSquared;
                        closestHandlePoint.index = i;
                    }
                }
                if (closestHandlePoint.index === 0) {
                    closePath = true;
                }
            }
            const { snapHandleNearby } = this.configuration;
            if (snapHandleNearby && !this.editData.closed) {
                const currentPath = new LivewirePath();
                const snapPoint = this.scissors.findMinNearby(worldToSlice(worldPosOriginal), 1);
                const pathPoints = this.scissors.findPathToPoint(snapPoint);
                currentPath.addPoints(pathPoints);
                currentPath.prependPath(this.editData.confirmedPath);
                worldPos = sliceToWorld(snapPoint);
                this.editData.currentPath = currentPath;
            }
            this.editData.closed = this.editData.closed || closePath;
            this.editData.confirmedPath = this.editData.currentPath;
            const lastPoint = this.editData.currentPath.getLastPoint();
            this.editData.confirmedPath.addControlPoint(lastPoint);
            annotation.data.handles.points.push(sliceToWorld(lastPoint));
            this.scissors.startSearch(worldToSlice(worldPos));
            annotation.invalidated = true;
            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);
            if (this.editData.closed) {
                this.updateAnnotation(this.editData.confirmedPath);
                this._endCallback(evt);
            }
            evt.preventDefault();
        };
        this._mouseMoveCallback = (evt) => {
            const { element, currentPoints } = evt.detail;
            const { world: worldPos, canvas: canvasPos } = currentPoints;
            const { renderingEngine } = getEnabledElement(element);
            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
            this.editData.lastCanvasPoint = canvasPos;
            const { width: imgWidth, height: imgHeight } = this.scissors;
            const { worldToSlice } = this.editData;
            const slicePoint = worldToSlice(worldPos);
            if (slicePoint[0] < 0 ||
                slicePoint[1] < 0 ||
                slicePoint[0] >= imgWidth ||
                slicePoint[1] >= imgHeight) {
                return;
            }
            const pathPoints = this.scissors.findPathToPoint(slicePoint);
            const currentPath = new LivewirePath();
            currentPath.addPoints(pathPoints);
            currentPath.prependPath(this.editData.confirmedPath);
            this.editData.currentPath = currentPath;
            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);
            evt.preventDefault();
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex } = this.editData;
            if (handleIndex === undefined) {
                console.warn('No drag implemented for livewire');
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                this.editHandle(worldPos, element, annotation, handleIndex);
            }
            const enabledElement = getEnabledElement(element);
            const { renderingEngine } = enabledElement;
            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (!this.isDrawing) {
                return;
            }
            this.isDrawing = false;
            this._deactivateDraw(element);
            this._deactivateModify(element);
            resetElementCursor(element);
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            if (newAnnotation) {
                removeAnnotation(annotation.annotationUID);
            }
            const enabledElement = getEnabledElement(element);
            const { renderingEngine } = enabledElement;
            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);
            this.editData = null;
            this.scissors = null;
            return annotation.annotationUID;
        };
        this._activateModify = (element) => {
            state.isInteractingWithTool = true;
            element.addEventListener(Events.MOUSE_UP, this._endCallback);
            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(Events.TOUCH_END, this._endCallback);
            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            state.isInteractingWithTool = false;
            element.removeEventListener(Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(Events.TOUCH_END, this._endCallback);
            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            state.isInteractingWithTool = true;
            element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);
            element.addEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);
        };
        this._deactivateDraw = (element) => {
            state.isInteractingWithTool = false;
            element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);
            element.removeEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);
        };
    }
    setupBaseEditData(worldPos, element, annotation, rightPos, contourHoleProcessingEnabled) {
        const enabledElement = getEnabledElement(element);
        const { viewport } = enabledElement;
        this.isDrawing = true;
        const viewportImageData = viewport.getImageData();
        const { imageData: vtkImageData } = viewportImageData;
        let worldToSlice;
        let sliceToWorld;
        let { scalarData } = viewportImageData;
        let width;
        let height;
        if (!(viewport instanceof VolumeViewport) && scalarData) {
            width = viewportImageData.dimensions[0];
            height = viewportImageData.dimensions[1];
            worldToSlice = (point) => {
                const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);
                return [ijkPoint[0], ijkPoint[1]];
            };
            sliceToWorld = (point) => csUtils.transformIndexToWorld(vtkImageData, [point[0], point[1], 0]);
        }
        else if (viewport instanceof VolumeViewport) {
            const sliceImageData = csUtils.getCurrentVolumeViewportSlice(viewport);
            const { sliceToIndexMatrix, indexToSliceMatrix } = sliceImageData;
            worldToSlice = (point) => {
                const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);
                const slicePoint = vec3.transformMat4([0, 0, 0], ijkPoint, indexToSliceMatrix);
                return [slicePoint[0], slicePoint[1]];
            };
            sliceToWorld = (point) => {
                const ijkPoint = vec3.transformMat4([0, 0, 0], [point[0], point[1], 0], sliceToIndexMatrix);
                return csUtils.transformIndexToWorld(vtkImageData, ijkPoint);
            };
            scalarData = sliceImageData.scalarData;
            width = sliceImageData.width;
            height = sliceImageData.height;
        }
        else {
            throw new Error('Viewport not supported');
        }
        scalarData = csUtils.convertToGrayscale(scalarData, width, height);
        const { voiRange } = viewport.getProperties();
        const startPos = worldToSlice(worldPos);
        this.scissors = LivewireScissors.createInstanceFromRawPixelData(scalarData, width, height, voiRange);
        if (rightPos) {
            this.scissorsRight = LivewireScissors.createInstanceFromRawPixelData(scalarData, width, height, voiRange);
            this.scissorsRight.startSearch(worldToSlice(rightPos));
        }
        this.scissors.startSearch(startPos);
        const newAnnotation = !rightPos;
        const confirmedPath = new LivewirePath();
        const currentPath = new LivewirePath();
        const currentPathNext = newAnnotation ? undefined : new LivewirePath();
        confirmedPath.addPoint(startPos);
        confirmedPath.addControlPoint(startPos);
        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
        const lastCanvasPoint = viewport.worldToCanvas(worldPos);
        this.editData = {
            annotation,
            viewportIdsToRender,
            newAnnotation,
            hasMoved: false,
            lastCanvasPoint,
            confirmedPath,
            currentPath,
            confirmedPathRight: currentPathNext,
            closed: false,
            handleIndex: this.editData?.handleIndex ?? annotation.handles?.activeHandleIndex,
            worldToSlice,
            sliceToWorld,
            contourHoleProcessingEnabled,
        };
    }
    addNewAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const { world: worldPos } = currentPoints;
        const { renderingEngine } = getEnabledElement(element);
        const annotation = this.createAnnotation(evt);
        const contourHoleProcessingEnabled = getMouseModifierKey(evt.detail.event) ===
            this.configuration.contourHoleAdditionModifierKey;
        this.setupBaseEditData(worldPos, element, annotation, undefined, contourHoleProcessingEnabled);
        this.addAnnotation(annotation, element);
        this._activateDraw(element);
        evt.preventDefault();
        triggerAnnotationRenderForViewportIds(renderingEngine, this.editData.viewportIdsToRender);
        return annotation;
    }
    clearEditData() {
        this.editData = null;
        this.scissors = null;
        this.scissorsRight = null;
        this.isDrawing = false;
    }
    editHandle(worldPos, element, annotation, handleIndex) {
        const { data } = annotation;
        const { points: handlePoints } = data.handles;
        const { length: numHandles } = handlePoints;
        const previousHandle = handlePoints[(handleIndex - 1 + numHandles) % numHandles];
        const nextHandle = handlePoints[(handleIndex + 1) % numHandles];
        if (!this.editData?.confirmedPathRight) {
            this.setupBaseEditData(previousHandle, element, annotation, nextHandle);
            const { polyline } = data.contour;
            const confirmedPath = new LivewirePath();
            const confirmedPathRight = new LivewirePath();
            const { worldToSlice } = this.editData;
            const previousIndex = findHandlePolylineIndex(annotation, handleIndex - 1);
            const nextIndex = findHandlePolylineIndex(annotation, handleIndex + 1);
            if (nextIndex === -1 || previousIndex === -1) {
                throw new Error(`Can't find handle index ${nextIndex === -1 && nextHandle} ${previousIndex === -1 && previousHandle}`);
            }
            if (handleIndex === 0) {
                confirmedPathRight.addPoints(polyline.slice(nextIndex + 1, previousIndex).map(worldToSlice));
            }
            else if (nextIndex < previousIndex) {
                throw new Error(`Expected right index after left index, but were: ${previousIndex} ${nextIndex}`);
            }
            else {
                confirmedPath.addPoints(polyline.slice(0, previousIndex + 1).map(worldToSlice));
                confirmedPathRight.addPoints(polyline.slice(nextIndex, polyline.length).map(worldToSlice));
            }
            this.editData.confirmedPath = confirmedPath;
            this.editData.confirmedPathRight = confirmedPathRight;
        }
        const { editData, scissors } = this;
        const { worldToSlice, sliceToWorld } = editData;
        const { activeHandleIndex } = data.handles;
        if (activeHandleIndex === null || activeHandleIndex === undefined) {
            data.handles.activeHandleIndex = handleIndex;
        }
        else if (activeHandleIndex !== handleIndex) {
            throw new Error(`Trying to edit a different handle than the one currently being edited ${handleIndex}!==${data.handles.activeHandleIndex}`);
        }
        const slicePos = worldToSlice(worldPos);
        if (slicePos[0] < 0 ||
            slicePos[0] >= scissors.width ||
            slicePos[1] < 0 ||
            slicePos[1] >= scissors.height) {
            return;
        }
        handlePoints[handleIndex] = sliceToWorld(slicePos);
        const pathPointsLeft = scissors.findPathToPoint(slicePos);
        const pathPointsRight = this.scissorsRight.findPathToPoint(slicePos);
        const currentPath = new LivewirePath();
        currentPath.prependPath(editData.confirmedPath);
        if (handleIndex !== 0) {
            currentPath.addPoints(pathPointsLeft);
        }
        currentPath.addPoints(pathPointsRight.reverse());
        currentPath.appendPath(editData.confirmedPathRight);
        if (handleIndex === 0) {
            currentPath.addPoints(pathPointsLeft);
        }
        editData.currentPath = currentPath;
        annotation.invalidated = true;
        editData.hasMoved = true;
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        this.updateAnnotation(this.editData?.currentPath);
        return super.renderAnnotation(enabledElement, svgDrawingHelper);
    }
    isContourSegmentationTool() {
        return false;
    }
    createAnnotation(evt) {
        const contourSegmentationAnnotation = super.createAnnotation(evt);
        const { world: worldPos } = evt.detail.currentPoints;
        const annotation = csUtils.deepMerge(contourSegmentationAnnotation, {
            data: {
                handles: {
                    points: [[...worldPos]],
                },
            },
        });
        return annotation;
    }
    undo(element, config, evt) {
        if (!this.editData) {
            return;
        }
        this._endCallback(evt, true);
    }
    renderAnnotationInstance(renderContext) {
        const { annotation, enabledElement, svgDrawingHelper, annotationStyle } = renderContext;
        const { viewport } = enabledElement;
        const { worldToCanvas } = viewport;
        const { annotationUID, data, highlighted } = annotation;
        const { handles } = data;
        const newAnnotation = this.editData?.newAnnotation;
        const { lineWidth, lineDash, color } = annotationStyle;
        if (highlighted ||
            (newAnnotation &&
                annotation.annotationUID === this.editData?.annotation?.annotationUID)) {
            const handleGroupUID = '0';
            const canvasHandles = handles.points.map(worldToCanvas);
            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasHandles, {
                color,
                lineDash,
                lineWidth,
            });
        }
        super.renderAnnotationInstance(renderContext);
        return true;
    }
    updateAnnotation(livewirePath) {
        if (!this.editData || !livewirePath) {
            return;
        }
        const { annotation, sliceToWorld } = this.editData;
        let { pointArray: imagePoints } = livewirePath;
        if (imagePoints.length > 1) {
            imagePoints = [...imagePoints, imagePoints[0]];
        }
        this.updateContourPolyline(annotation, {
            points: imagePoints,
            closed: annotation.data.contour.closed,
            targetWindingDirection: ContourWindingDirection.Clockwise,
        }, {
            canvasToWorld: sliceToWorld,
        });
    }
}
LivewireContourTool.toolName = 'LivewireContour';
export default LivewireContourTool;
//# sourceMappingURL=LivewireContourTool.js.map