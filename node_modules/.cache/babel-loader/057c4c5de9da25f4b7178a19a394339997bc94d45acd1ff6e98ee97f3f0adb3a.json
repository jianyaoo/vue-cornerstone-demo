{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Constants from './ImageMapper/Constants.js';\nimport { m as macro } from '../../macros2.js';\nimport vtkAbstractImageMapper from './AbstractImageMapper.js';\nimport { intersectWithLineForPointPicking, intersectWithLineForCellPicking } from './AbstractImageMapper/helper.js';\nimport { C as clampValue, P as multiply3x3_vect3, F as createUninitializedBounds, Q as getSparseOrthogonalMatrix } from '../../Common/Core/Math/index.js';\nimport CoincidentTopologyHelper from './Mapper/CoincidentTopologyHelper.js';\nconst {\n  staticOffsetAPI,\n  otherStaticMethods\n} = CoincidentTopologyHelper;\nconst {\n  SlicingMode\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// vtkImageMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageMapper');\n  publicAPI.getSliceAtPosition = pos => {\n    const image = publicAPI.getCurrentImage();\n    let pos3;\n    if (pos.length === 3) {\n      pos3 = pos;\n    } else if (Number.isFinite(pos)) {\n      const bds = image.getBounds();\n      switch (model.slicingMode) {\n        case SlicingMode.X:\n          pos3 = [pos, (bds[3] + bds[2]) / 2, (bds[5] + bds[4]) / 2];\n          break;\n        case SlicingMode.Y:\n          pos3 = [(bds[1] + bds[0]) / 2, pos, (bds[5] + bds[4]) / 2];\n          break;\n        case SlicingMode.Z:\n          pos3 = [(bds[1] + bds[0]) / 2, (bds[3] + bds[2]) / 2, pos];\n          break;\n      }\n    }\n    const ijk = [0, 0, 0];\n    image.worldToIndex(pos3, ijk);\n    const ex = image.getExtent();\n    const {\n      ijkMode\n    } = publicAPI.getClosestIJKAxis();\n    let slice = 0;\n    switch (ijkMode) {\n      case SlicingMode.I:\n        slice = clampValue(ijk[0], ex[0], ex[1]);\n        break;\n      case SlicingMode.J:\n        slice = clampValue(ijk[1], ex[2], ex[3]);\n        break;\n      case SlicingMode.K:\n        slice = clampValue(ijk[2], ex[4], ex[5]);\n        break;\n      default:\n        return 0;\n    }\n    return slice;\n  };\n  publicAPI.setSliceFromCamera = cam => {\n    const fp = cam.getFocalPoint();\n    switch (model.slicingMode) {\n      case SlicingMode.I:\n      case SlicingMode.J:\n      case SlicingMode.K:\n        {\n          const slice = publicAPI.getSliceAtPosition(fp);\n          publicAPI.setSlice(slice);\n        }\n        break;\n      case SlicingMode.X:\n        publicAPI.setSlice(fp[0]);\n        break;\n      case SlicingMode.Y:\n        publicAPI.setSlice(fp[1]);\n        break;\n      case SlicingMode.Z:\n        publicAPI.setSlice(fp[2]);\n        break;\n    }\n  };\n  publicAPI.setXSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.X);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setYSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.Y);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setZSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.Z);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setISlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.I);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setJSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.J);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setKSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.K);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.getSlicingModeNormal = () => {\n    const out = [0, 0, 0];\n    const mat3 = publicAPI.getCurrentImage().getDirection();\n    switch (model.slicingMode) {\n      case SlicingMode.X:\n        out[0] = 1;\n        break;\n      case SlicingMode.Y:\n        out[1] = 1;\n        break;\n      case SlicingMode.Z:\n        out[2] = 1;\n        break;\n      case SlicingMode.I:\n        multiply3x3_vect3(mat3, [1, 0, 0], out);\n        break;\n      case SlicingMode.J:\n        multiply3x3_vect3(mat3, [0, 1, 0], out);\n        break;\n      case SlicingMode.K:\n        multiply3x3_vect3(mat3, [0, 0, 1], out);\n        break;\n    }\n    return out;\n  };\n  function computeClosestIJKAxis() {\n    let xyzMode;\n    switch (model.slicingMode) {\n      case SlicingMode.X:\n        xyzMode = 0;\n        break;\n      case SlicingMode.Y:\n        xyzMode = 1;\n        break;\n      case SlicingMode.Z:\n        xyzMode = 2;\n        break;\n      default:\n        model.closestIJKAxis = {\n          ijkMode: model.slicingMode,\n          flip: false\n        };\n        return;\n    }\n\n    // The direction matrix in vtkImageData is the indexToWorld rotation matrix\n    // with a column-major data layout since it is stored as a WebGL matrix.\n    const direction = publicAPI.getCurrentImage().getDirection();\n    const newMatrix = getSparseOrthogonalMatrix(direction);\n    // With {foo}Vector filled with 0s except at {foo}Mode position where it is 1\n    // We have xyzVector = (+/-) newMatrix * ijkVector\n    let ijkMode = 0;\n    for (; ijkMode < 3; ++ijkMode) {\n      if (newMatrix[xyzMode + 3 * ijkMode] !== 0) {\n        break;\n      }\n    }\n    const flip = newMatrix[xyzMode + 3 * ijkMode] < 0;\n    model.closestIJKAxis = {\n      ijkMode,\n      flip\n    };\n  }\n  publicAPI.setSlicingMode = mode => {\n    if (model.slicingMode === mode) {\n      return;\n    }\n    model.slicingMode = mode;\n    if (publicAPI.getCurrentImage()) {\n      computeClosestIJKAxis();\n    }\n    publicAPI.modified();\n  };\n  publicAPI.getClosestIJKAxis = () => {\n    if ((model.closestIJKAxis === undefined || model.closestIJKAxis.ijkMode === SlicingMode.NONE) && publicAPI.getCurrentImage()) {\n      computeClosestIJKAxis();\n    }\n    return model.closestIJKAxis;\n  };\n  publicAPI.getBounds = () => {\n    const image = publicAPI.getCurrentImage();\n    if (!image) {\n      return createUninitializedBounds();\n    }\n    if (!model.useCustomExtents) {\n      return image.getBounds();\n    }\n    const ex = model.customDisplayExtent.slice();\n    const {\n      ijkMode\n    } = publicAPI.getClosestIJKAxis();\n    let nSlice = model.slice;\n    if (ijkMode !== model.slicingMode) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      nSlice = publicAPI.getSliceAtPosition(model.slice);\n    }\n    switch (ijkMode) {\n      case SlicingMode.I:\n        ex[0] = nSlice;\n        ex[1] = nSlice;\n        break;\n      case SlicingMode.J:\n        ex[2] = nSlice;\n        ex[3] = nSlice;\n        break;\n      case SlicingMode.K:\n        ex[4] = nSlice;\n        ex[5] = nSlice;\n        break;\n    }\n    return image.extentToBounds(ex);\n  };\n  publicAPI.getBoundsForSlice = function () {\n    let slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : model.slice;\n    let halfThickness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const image = publicAPI.getCurrentImage();\n    if (!image) {\n      return createUninitializedBounds();\n    }\n    const extent = image.getSpatialExtent();\n    const {\n      ijkMode\n    } = publicAPI.getClosestIJKAxis();\n    let nSlice = slice;\n    if (ijkMode !== model.slicingMode) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      nSlice = publicAPI.getSliceAtPosition(slice);\n    }\n    switch (ijkMode) {\n      case SlicingMode.I:\n        extent[0] = nSlice - halfThickness;\n        extent[1] = nSlice + halfThickness;\n        break;\n      case SlicingMode.J:\n        extent[2] = nSlice - halfThickness;\n        extent[3] = nSlice + halfThickness;\n        break;\n      case SlicingMode.K:\n        extent[4] = nSlice - halfThickness;\n        extent[5] = nSlice + halfThickness;\n        break;\n    }\n    return image.extentToBounds(extent);\n  };\n  publicAPI.intersectWithLineForPointPicking = (p1, p2) => intersectWithLineForPointPicking(p1, p2, publicAPI);\n  publicAPI.intersectWithLineForCellPicking = (p1, p2) => intersectWithLineForCellPicking(p1, p2, publicAPI);\n  publicAPI.getCurrentImage = () => publicAPI.getInputData();\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  slicingMode: SlicingMode.NONE,\n  closestIJKAxis: {\n    ijkMode: SlicingMode.NONE,\n    flip: false\n  },\n  renderToRectangle: false,\n  sliceAtFocalPoint: false,\n  preferSizeOverAccuracy: false // Whether to use halfFloat representation of float, when it is inaccurate\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  vtkAbstractImageMapper.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['slicingMode']);\n  macro.setGet(publicAPI, model, ['closestIJKAxis', 'renderToRectangle', 'sliceAtFocalPoint', 'preferSizeOverAccuracy']);\n  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);\n\n  // Object methods\n  vtkImageMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMapper$1 = {\n  newInstance,\n  extend,\n  ...staticOffsetAPI,\n  ...otherStaticMethods,\n  ...Constants\n};\nexport { vtkImageMapper$1 as default, extend, newInstance };","map":{"version":3,"names":["Constants","m","macro","vtkAbstractImageMapper","intersectWithLineForPointPicking","intersectWithLineForCellPicking","C","clampValue","P","multiply3x3_vect3","F","createUninitializedBounds","Q","getSparseOrthogonalMatrix","CoincidentTopologyHelper","staticOffsetAPI","otherStaticMethods","SlicingMode","vtkImageMapper","publicAPI","model","classHierarchy","push","getSliceAtPosition","pos","image","getCurrentImage","pos3","length","Number","isFinite","bds","getBounds","slicingMode","X","Y","Z","ijk","worldToIndex","ex","getExtent","ijkMode","getClosestIJKAxis","slice","I","J","K","setSliceFromCamera","cam","fp","getFocalPoint","setSlice","setXSlice","id","setSlicingMode","setYSlice","setZSlice","setISlice","setJSlice","setKSlice","getSlicingModeNormal","out","mat3","getDirection","computeClosestIJKAxis","xyzMode","closestIJKAxis","flip","direction","newMatrix","mode","modified","undefined","NONE","useCustomExtents","customDisplayExtent","nSlice","extentToBounds","getBoundsForSlice","arguments","halfThickness","extent","getSpatialExtent","p1","p2","getInputData","DEFAULT_VALUES","renderToRectangle","sliceAtFocalPoint","preferSizeOverAccuracy","extend","initialValues","Object","assign","get","setGet","implementCoincidentTopologyMethods","newInstance","vtkImageMapper$1","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper.js"],"sourcesContent":["import Constants from './ImageMapper/Constants.js';\nimport { m as macro } from '../../macros2.js';\nimport vtkAbstractImageMapper from './AbstractImageMapper.js';\nimport { intersectWithLineForPointPicking, intersectWithLineForCellPicking } from './AbstractImageMapper/helper.js';\nimport { C as clampValue, P as multiply3x3_vect3, F as createUninitializedBounds, Q as getSparseOrthogonalMatrix } from '../../Common/Core/Math/index.js';\nimport CoincidentTopologyHelper from './Mapper/CoincidentTopologyHelper.js';\n\nconst {\n  staticOffsetAPI,\n  otherStaticMethods\n} = CoincidentTopologyHelper;\nconst {\n  SlicingMode\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// vtkImageMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageMapper');\n  publicAPI.getSliceAtPosition = pos => {\n    const image = publicAPI.getCurrentImage();\n    let pos3;\n    if (pos.length === 3) {\n      pos3 = pos;\n    } else if (Number.isFinite(pos)) {\n      const bds = image.getBounds();\n      switch (model.slicingMode) {\n        case SlicingMode.X:\n          pos3 = [pos, (bds[3] + bds[2]) / 2, (bds[5] + bds[4]) / 2];\n          break;\n        case SlicingMode.Y:\n          pos3 = [(bds[1] + bds[0]) / 2, pos, (bds[5] + bds[4]) / 2];\n          break;\n        case SlicingMode.Z:\n          pos3 = [(bds[1] + bds[0]) / 2, (bds[3] + bds[2]) / 2, pos];\n          break;\n      }\n    }\n    const ijk = [0, 0, 0];\n    image.worldToIndex(pos3, ijk);\n    const ex = image.getExtent();\n    const {\n      ijkMode\n    } = publicAPI.getClosestIJKAxis();\n    let slice = 0;\n    switch (ijkMode) {\n      case SlicingMode.I:\n        slice = clampValue(ijk[0], ex[0], ex[1]);\n        break;\n      case SlicingMode.J:\n        slice = clampValue(ijk[1], ex[2], ex[3]);\n        break;\n      case SlicingMode.K:\n        slice = clampValue(ijk[2], ex[4], ex[5]);\n        break;\n      default:\n        return 0;\n    }\n    return slice;\n  };\n  publicAPI.setSliceFromCamera = cam => {\n    const fp = cam.getFocalPoint();\n    switch (model.slicingMode) {\n      case SlicingMode.I:\n      case SlicingMode.J:\n      case SlicingMode.K:\n        {\n          const slice = publicAPI.getSliceAtPosition(fp);\n          publicAPI.setSlice(slice);\n        }\n        break;\n      case SlicingMode.X:\n        publicAPI.setSlice(fp[0]);\n        break;\n      case SlicingMode.Y:\n        publicAPI.setSlice(fp[1]);\n        break;\n      case SlicingMode.Z:\n        publicAPI.setSlice(fp[2]);\n        break;\n    }\n  };\n  publicAPI.setXSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.X);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setYSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.Y);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setZSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.Z);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setISlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.I);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setJSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.J);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setKSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.K);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.getSlicingModeNormal = () => {\n    const out = [0, 0, 0];\n    const mat3 = publicAPI.getCurrentImage().getDirection();\n    switch (model.slicingMode) {\n      case SlicingMode.X:\n        out[0] = 1;\n        break;\n      case SlicingMode.Y:\n        out[1] = 1;\n        break;\n      case SlicingMode.Z:\n        out[2] = 1;\n        break;\n      case SlicingMode.I:\n        multiply3x3_vect3(mat3, [1, 0, 0], out);\n        break;\n      case SlicingMode.J:\n        multiply3x3_vect3(mat3, [0, 1, 0], out);\n        break;\n      case SlicingMode.K:\n        multiply3x3_vect3(mat3, [0, 0, 1], out);\n        break;\n    }\n    return out;\n  };\n  function computeClosestIJKAxis() {\n    let xyzMode;\n    switch (model.slicingMode) {\n      case SlicingMode.X:\n        xyzMode = 0;\n        break;\n      case SlicingMode.Y:\n        xyzMode = 1;\n        break;\n      case SlicingMode.Z:\n        xyzMode = 2;\n        break;\n      default:\n        model.closestIJKAxis = {\n          ijkMode: model.slicingMode,\n          flip: false\n        };\n        return;\n    }\n\n    // The direction matrix in vtkImageData is the indexToWorld rotation matrix\n    // with a column-major data layout since it is stored as a WebGL matrix.\n    const direction = publicAPI.getCurrentImage().getDirection();\n    const newMatrix = getSparseOrthogonalMatrix(direction);\n    // With {foo}Vector filled with 0s except at {foo}Mode position where it is 1\n    // We have xyzVector = (+/-) newMatrix * ijkVector\n    let ijkMode = 0;\n    for (; ijkMode < 3; ++ijkMode) {\n      if (newMatrix[xyzMode + 3 * ijkMode] !== 0) {\n        break;\n      }\n    }\n    const flip = newMatrix[xyzMode + 3 * ijkMode] < 0;\n    model.closestIJKAxis = {\n      ijkMode,\n      flip\n    };\n  }\n  publicAPI.setSlicingMode = mode => {\n    if (model.slicingMode === mode) {\n      return;\n    }\n    model.slicingMode = mode;\n    if (publicAPI.getCurrentImage()) {\n      computeClosestIJKAxis();\n    }\n    publicAPI.modified();\n  };\n  publicAPI.getClosestIJKAxis = () => {\n    if ((model.closestIJKAxis === undefined || model.closestIJKAxis.ijkMode === SlicingMode.NONE) && publicAPI.getCurrentImage()) {\n      computeClosestIJKAxis();\n    }\n    return model.closestIJKAxis;\n  };\n  publicAPI.getBounds = () => {\n    const image = publicAPI.getCurrentImage();\n    if (!image) {\n      return createUninitializedBounds();\n    }\n    if (!model.useCustomExtents) {\n      return image.getBounds();\n    }\n    const ex = model.customDisplayExtent.slice();\n    const {\n      ijkMode\n    } = publicAPI.getClosestIJKAxis();\n    let nSlice = model.slice;\n    if (ijkMode !== model.slicingMode) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      nSlice = publicAPI.getSliceAtPosition(model.slice);\n    }\n    switch (ijkMode) {\n      case SlicingMode.I:\n        ex[0] = nSlice;\n        ex[1] = nSlice;\n        break;\n      case SlicingMode.J:\n        ex[2] = nSlice;\n        ex[3] = nSlice;\n        break;\n      case SlicingMode.K:\n        ex[4] = nSlice;\n        ex[5] = nSlice;\n        break;\n    }\n    return image.extentToBounds(ex);\n  };\n  publicAPI.getBoundsForSlice = function () {\n    let slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : model.slice;\n    let halfThickness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const image = publicAPI.getCurrentImage();\n    if (!image) {\n      return createUninitializedBounds();\n    }\n    const extent = image.getSpatialExtent();\n    const {\n      ijkMode\n    } = publicAPI.getClosestIJKAxis();\n    let nSlice = slice;\n    if (ijkMode !== model.slicingMode) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      nSlice = publicAPI.getSliceAtPosition(slice);\n    }\n    switch (ijkMode) {\n      case SlicingMode.I:\n        extent[0] = nSlice - halfThickness;\n        extent[1] = nSlice + halfThickness;\n        break;\n      case SlicingMode.J:\n        extent[2] = nSlice - halfThickness;\n        extent[3] = nSlice + halfThickness;\n        break;\n      case SlicingMode.K:\n        extent[4] = nSlice - halfThickness;\n        extent[5] = nSlice + halfThickness;\n        break;\n    }\n    return image.extentToBounds(extent);\n  };\n  publicAPI.intersectWithLineForPointPicking = (p1, p2) => intersectWithLineForPointPicking(p1, p2, publicAPI);\n  publicAPI.intersectWithLineForCellPicking = (p1, p2) => intersectWithLineForCellPicking(p1, p2, publicAPI);\n  publicAPI.getCurrentImage = () => publicAPI.getInputData();\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  slicingMode: SlicingMode.NONE,\n  closestIJKAxis: {\n    ijkMode: SlicingMode.NONE,\n    flip: false\n  },\n  renderToRectangle: false,\n  sliceAtFocalPoint: false,\n  preferSizeOverAccuracy: false // Whether to use halfFloat representation of float, when it is inaccurate\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  vtkAbstractImageMapper.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['slicingMode']);\n  macro.setGet(publicAPI, model, ['closestIJKAxis', 'renderToRectangle', 'sliceAtFocalPoint', 'preferSizeOverAccuracy']);\n  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);\n\n  // Object methods\n  vtkImageMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMapper$1 = {\n  newInstance,\n  extend,\n  ...staticOffsetAPI,\n  ...otherStaticMethods,\n  ...Constants\n};\n\nexport { vtkImageMapper$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}