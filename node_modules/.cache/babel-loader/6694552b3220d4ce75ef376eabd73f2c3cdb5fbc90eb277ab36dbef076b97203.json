{"ast":null,"code":"/* eslint-disable no-bitwise */\n\n// ----------------------------------------------------------------------------\n// Decoding infrastructure\n// ----------------------------------------------------------------------------\n\nconst REVERSE_LOOKUP = [];\nREVERSE_LOOKUP['-'.charCodeAt(0)] = 62;\nREVERSE_LOOKUP['_'.charCodeAt(0)] = 63;\nconst BASE64_CODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor (let i = 0; i < BASE64_CODE.length; i++) {\n  REVERSE_LOOKUP[BASE64_CODE.charCodeAt(i)] = i;\n}\n\n// ----------------------------------------------------------------------------\n// Base64 analysis\n// ----------------------------------------------------------------------------\n\nfunction isValidChar(c) {\n  return REVERSE_LOOKUP[c.charCodeAt(0)] !== undefined;\n}\nfunction extractChunks(b64Str) {\n  const strSize = b64Str.length;\n  const chunks = [];\n  let currentChunk = null;\n  for (let i = 0; i < strSize; i++) {\n    if (isValidChar(b64Str[i])) {\n      if (!currentChunk) {\n        currentChunk = {\n          start: i,\n          count: 0\n        };\n      }\n      currentChunk.count++;\n      currentChunk.end = i;\n    } else if (b64Str[i] === '=' && currentChunk) {\n      // End of chunk (found padding char)\n      chunks.push(currentChunk);\n      currentChunk = null;\n    }\n  }\n  if (currentChunk) {\n    chunks.push(currentChunk);\n  }\n  return chunks;\n}\nfunction writeChunk(b64Str, chunk, dstOffset, uint8) {\n  const {\n    start,\n    count\n  } = chunk;\n  const remain = count % 4;\n  const fourCharProcessCount = Math.floor(count / 4);\n  let charIdx = start;\n  let tmp = null;\n  let offset = dstOffset;\n\n  // Handle 4=>3\n  for (let i = 0; i < fourCharProcessCount; i++) {\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n    tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 18;\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 12;\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 6;\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)];\n    uint8[offset++] = tmp >> 16 & 0xff;\n    uint8[offset++] = tmp >> 8 & 0xff;\n    uint8[offset++] = tmp & 0xff;\n  }\n\n  // Handle remain\n  switch (remain) {\n    case 3:\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 10;\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 4;\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] >> 2;\n      uint8[offset++] = tmp >> 8 & 0xff;\n      uint8[offset++] = tmp & 0xff;\n      break;\n    case 2:\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 2;\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] >> 4;\n      uint8[offset++] = tmp & 0xff;\n      break;\n    case 1:\n      throw new Error('BASE64: remain 1 should not happen');\n  }\n  return offset;\n}\nfunction toArrayBuffer(b64Str) {\n  const chunks = extractChunks(b64Str);\n  const totalEncodedLength = chunks[chunks.length - 1].end + 1;\n  const padding = (4 - totalEncodedLength % 4) % 4; // -length mod 4\n  // Any padding chars in the middle of b64Str is to be interpreted as \\x00,\n  // whereas the terminating padding chars are to be interpreted as literal padding.\n  const totalSize = (totalEncodedLength + padding) * 3 / 4 - padding;\n  const arrayBuffer = new ArrayBuffer(totalSize);\n  const view = new Uint8Array(arrayBuffer);\n  let dstOffset = 0;\n  for (let i = 0; i < chunks.length; i++) {\n    dstOffset += writeChunk(b64Str, chunks[i], dstOffset, view);\n    dstOffset += (4 - chunks[i].count % 4) % 4;\n  }\n  return arrayBuffer;\n}\nfunction encodeTriplet(v1, v2, v3) {\n  const triplet = (v1 << 16) + (v2 << 8) + v3;\n  return BASE64_CODE[triplet >> 18] + BASE64_CODE[triplet >> 12 & 0x3f] + BASE64_CODE[triplet >> 6 & 0x3f] + BASE64_CODE[triplet & 0x3f];\n}\nfunction fromArrayBuffer(ab) {\n  const uint8 = new Uint8Array(ab);\n  const leftoverLength = ab.byteLength % 3;\n  const maxTripletIndex = ab.byteLength - leftoverLength;\n  const segments = Array(maxTripletIndex / 3);\n  for (let i = 0; i < segments.length; i++) {\n    const bufOffset = i * 3;\n    segments[i] = encodeTriplet(uint8[bufOffset], uint8[bufOffset + 1], uint8[bufOffset + 2]);\n  }\n  if (leftoverLength > 0) {\n    const segment = encodeTriplet(uint8[maxTripletIndex], uint8[maxTripletIndex + 1] || 0, uint8[maxTripletIndex + 2] || 0);\n    if (leftoverLength === 1) {\n      segments.push(`${segment.substr(0, 2)}==`);\n    } else if (leftoverLength === 2) {\n      segments.push(`${segment.substr(0, 3)}=`);\n    }\n  }\n  return segments.join('');\n}\nvar Base64 = {\n  toArrayBuffer,\n  fromArrayBuffer\n};\nexport { Base64 as default, fromArrayBuffer, toArrayBuffer };","map":{"version":3,"names":["REVERSE_LOOKUP","charCodeAt","BASE64_CODE","i","length","isValidChar","c","undefined","extractChunks","b64Str","strSize","chunks","currentChunk","start","count","end","push","writeChunk","chunk","dstOffset","uint8","remain","fourCharProcessCount","Math","floor","charIdx","tmp","offset","Error","toArrayBuffer","totalEncodedLength","padding","totalSize","arrayBuffer","ArrayBuffer","view","Uint8Array","encodeTriplet","v1","v2","v3","triplet","fromArrayBuffer","ab","leftoverLength","byteLength","maxTripletIndex","segments","Array","bufOffset","segment","substr","join","Base64","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Common/Core/Base64.js"],"sourcesContent":["/* eslint-disable no-bitwise */\n\n// ----------------------------------------------------------------------------\n// Decoding infrastructure\n// ----------------------------------------------------------------------------\n\nconst REVERSE_LOOKUP = [];\nREVERSE_LOOKUP['-'.charCodeAt(0)] = 62;\nREVERSE_LOOKUP['_'.charCodeAt(0)] = 63;\nconst BASE64_CODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor (let i = 0; i < BASE64_CODE.length; i++) {\n  REVERSE_LOOKUP[BASE64_CODE.charCodeAt(i)] = i;\n}\n\n// ----------------------------------------------------------------------------\n// Base64 analysis\n// ----------------------------------------------------------------------------\n\nfunction isValidChar(c) {\n  return REVERSE_LOOKUP[c.charCodeAt(0)] !== undefined;\n}\nfunction extractChunks(b64Str) {\n  const strSize = b64Str.length;\n  const chunks = [];\n  let currentChunk = null;\n  for (let i = 0; i < strSize; i++) {\n    if (isValidChar(b64Str[i])) {\n      if (!currentChunk) {\n        currentChunk = {\n          start: i,\n          count: 0\n        };\n      }\n      currentChunk.count++;\n      currentChunk.end = i;\n    } else if (b64Str[i] === '=' && currentChunk) {\n      // End of chunk (found padding char)\n      chunks.push(currentChunk);\n      currentChunk = null;\n    }\n  }\n  if (currentChunk) {\n    chunks.push(currentChunk);\n  }\n  return chunks;\n}\nfunction writeChunk(b64Str, chunk, dstOffset, uint8) {\n  const {\n    start,\n    count\n  } = chunk;\n  const remain = count % 4;\n  const fourCharProcessCount = Math.floor(count / 4);\n  let charIdx = start;\n  let tmp = null;\n  let offset = dstOffset;\n\n  // Handle 4=>3\n  for (let i = 0; i < fourCharProcessCount; i++) {\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n    tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 18;\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 12;\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 6;\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)];\n    uint8[offset++] = tmp >> 16 & 0xff;\n    uint8[offset++] = tmp >> 8 & 0xff;\n    uint8[offset++] = tmp & 0xff;\n  }\n\n  // Handle remain\n  switch (remain) {\n    case 3:\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 10;\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 4;\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] >> 2;\n      uint8[offset++] = tmp >> 8 & 0xff;\n      uint8[offset++] = tmp & 0xff;\n      break;\n    case 2:\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 2;\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] >> 4;\n      uint8[offset++] = tmp & 0xff;\n      break;\n    case 1:\n      throw new Error('BASE64: remain 1 should not happen');\n  }\n  return offset;\n}\nfunction toArrayBuffer(b64Str) {\n  const chunks = extractChunks(b64Str);\n  const totalEncodedLength = chunks[chunks.length - 1].end + 1;\n  const padding = (4 - totalEncodedLength % 4) % 4; // -length mod 4\n  // Any padding chars in the middle of b64Str is to be interpreted as \\x00,\n  // whereas the terminating padding chars are to be interpreted as literal padding.\n  const totalSize = (totalEncodedLength + padding) * 3 / 4 - padding;\n  const arrayBuffer = new ArrayBuffer(totalSize);\n  const view = new Uint8Array(arrayBuffer);\n  let dstOffset = 0;\n  for (let i = 0; i < chunks.length; i++) {\n    dstOffset += writeChunk(b64Str, chunks[i], dstOffset, view);\n    dstOffset += (4 - chunks[i].count % 4) % 4;\n  }\n  return arrayBuffer;\n}\nfunction encodeTriplet(v1, v2, v3) {\n  const triplet = (v1 << 16) + (v2 << 8) + v3;\n  return BASE64_CODE[triplet >> 18] + BASE64_CODE[triplet >> 12 & 0x3f] + BASE64_CODE[triplet >> 6 & 0x3f] + BASE64_CODE[triplet & 0x3f];\n}\nfunction fromArrayBuffer(ab) {\n  const uint8 = new Uint8Array(ab);\n  const leftoverLength = ab.byteLength % 3;\n  const maxTripletIndex = ab.byteLength - leftoverLength;\n  const segments = Array(maxTripletIndex / 3);\n  for (let i = 0; i < segments.length; i++) {\n    const bufOffset = i * 3;\n    segments[i] = encodeTriplet(uint8[bufOffset], uint8[bufOffset + 1], uint8[bufOffset + 2]);\n  }\n  if (leftoverLength > 0) {\n    const segment = encodeTriplet(uint8[maxTripletIndex], uint8[maxTripletIndex + 1] || 0, uint8[maxTripletIndex + 2] || 0);\n    if (leftoverLength === 1) {\n      segments.push(`${segment.substr(0, 2)}==`);\n    } else if (leftoverLength === 2) {\n      segments.push(`${segment.substr(0, 3)}=`);\n    }\n  }\n  return segments.join('');\n}\nvar Base64 = {\n  toArrayBuffer,\n  fromArrayBuffer\n};\n\nexport { Base64 as default, fromArrayBuffer, toArrayBuffer };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}