{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport vtkWebGPUBindGroup from './BindGroup.js';\nimport vtkWebGPUPipeline from './Pipeline.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUShaderDescription from './ShaderDescription.js';\nimport vtkWebGPUVertexInput from './VertexInput.js';\nconst vtkWebGPUSimpleMapperVS = `\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n`;\nconst vtkWebGPUSimpleMapperFS = `\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n`;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUSimpleMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUSimpleMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUSimpleMapper');\n  publicAPI.generateShaderDescriptions = (hash, pipeline, vertexInput) => {\n    // create the shader descriptions\n    const vDesc = vtkWebGPUShaderDescription.newInstance({\n      type: 'vertex',\n      hash,\n      code: model.vertexShaderTemplate\n    });\n    const fDesc = vtkWebGPUShaderDescription.newInstance({\n      type: 'fragment',\n      hash,\n      code: model.fragmentShaderTemplate\n    });\n\n    // add them to the pipeline\n    const sdrs = pipeline.getShaderDescriptions();\n    sdrs.push(vDesc);\n    sdrs.push(fDesc);\n\n    // look for replacements to invoke\n    const scode = model.vertexShaderTemplate + model.fragmentShaderTemplate;\n    // eslint-disable-next-line prefer-regex-literals\n    const re = new RegExp('//VTK::[^:]*::', 'g');\n    const unique = scode.match(re).filter((v, i, a) => a.indexOf(v) === i);\n    const fnames = unique.map(v => `replaceShader${v.substring(7, v.length - 2)}`);\n\n    // now invoke shader replacement functions\n    for (let i = 0; i < fnames.length; i++) {\n      const fname = fnames[i];\n      if (fname !== 'replaceShaderIOStructs' && model.shaderReplacements.has(fname)) {\n        model.shaderReplacements.get(fname)(hash, pipeline, vertexInput);\n      }\n    }\n\n    // always replace the IOStructs last as other replacement funcs may\n    // add inputs or outputs\n    publicAPI.replaceShaderIOStructs(hash, pipeline, vertexInput);\n\n    // console.log(vDesc.getCode());\n    // console.log(fDesc.getCode());\n  };\n  publicAPI.replaceShaderIOStructs = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.replaceShaderCode(null, vertexInput);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.replaceShaderCode(vDesc);\n  };\n  publicAPI.replaceShaderRenderEncoder = (hash, pipeline, vertexInput) => {\n    model.renderEncoder.replaceShaderCode(pipeline);\n  };\n  model.shaderReplacements.set('replaceShaderRenderEncoder', publicAPI.replaceShaderRenderEncoder);\n  publicAPI.replaceShaderRenderer = (hash, pipeline, vertexInput) => {\n    if (!model.WebGPURenderer) {\n      return;\n    }\n    const ubocode = model.WebGPURenderer.getBindGroup().getShaderCode(pipeline);\n    const vDesc = pipeline.getShaderDescription('vertex');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Renderer::Dec', [ubocode]).result;\n    vDesc.setCode(code);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Renderer::Dec', [ubocode]).result;\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderRenderer', publicAPI.replaceShaderRenderer);\n  publicAPI.replaceShaderMapper = (hash, pipeline, vertexInput) => {\n    const ubocode = model.bindGroup.getShaderCode(pipeline);\n    const vDesc = pipeline.getShaderDescription('vertex');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Mapper::Dec', [ubocode]).result;\n    vDesc.setCode(code);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinInput('bool', '@builtin(front_facing) frontFacing');\n    code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Mapper::Dec', [ubocode]).result;\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderMapper', publicAPI.replaceShaderMapper);\n  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    output.Position = rendererUBO.SCPCMatrix*vertexBC;']).result;\n    vDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addOutput('vec2<f32>', 'tcoordVS');\n  };\n  model.shaderReplacements.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);\n  publicAPI.addTextureView = view => {\n    // is it already there?\n    if (model.textureViews.includes(view)) {\n      return;\n    }\n    model.textureViews.push(view);\n  };\n\n  // do everything required for this mapper to be rerady to draw\n  // but do not bind or do the actual draw commands as the pipeline\n  // is not neccessarily bound yet\n  publicAPI.prepareToDraw = renderEncoder => {\n    model.renderEncoder = renderEncoder;\n\n    // do anything needed to get our input data up to date\n    publicAPI.updateInput();\n\n    // make sure buffers are created and up to date\n    publicAPI.updateBuffers();\n\n    // update bindings and bind groups/layouts\n    // does not acutally bind them, that is done in draw(...)\n    publicAPI.updateBindings();\n\n    // update the pipeline, includes computing the hash, and if needed\n    // creating the pipeline, shader code etc\n    publicAPI.updatePipeline();\n  };\n  publicAPI.updateInput = () => {};\n  publicAPI.updateBuffers = () => {};\n  publicAPI.updateBindings = () => {\n    // bindings can change without a pipeline change\n    // as long as their layout remains the same.\n    // That is why this is done even when the pipeline\n    // hash doesn't change.\n    model.bindGroup.setBindables(publicAPI.getBindables());\n  };\n  publicAPI.computePipelineHash = () => {};\n  publicAPI.registerDrawCallback = encoder => {\n    encoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n  };\n  publicAPI.prepareAndDraw = encoder => {\n    publicAPI.prepareToDraw(encoder);\n    encoder.setPipeline(model.pipeline);\n    publicAPI.draw(encoder);\n  };\n\n  // do the rest of the calls required to draw this mapper\n  // at this point the command encouder and pipeline are\n  // created and bound\n  publicAPI.draw = renderEncoder => {\n    const pipeline = renderEncoder.getBoundPipeline();\n\n    // bind the mapper bind group\n    renderEncoder.activateBindGroup(model.bindGroup);\n    if (model.WebGPURenderer) {\n      model.WebGPURenderer.bindUBO(renderEncoder);\n    }\n\n    // bind the vertex input\n    pipeline.bindVertexInput(renderEncoder, model.vertexInput);\n    const indexBuffer = model.vertexInput.getIndexBuffer();\n    if (indexBuffer) {\n      renderEncoder.drawIndexed(indexBuffer.getIndexCount(), model.numberOfInstances, 0, 0, 0);\n    } else {\n      renderEncoder.draw(model.numberOfVertices, model.numberOfInstances, 0, 0);\n    }\n  };\n  publicAPI.getBindables = () => {\n    const bindables = [...model.additionalBindables];\n    if (model.UBO) {\n      bindables.push(model.UBO);\n    }\n    if (model.SSBO) {\n      bindables.push(model.SSBO);\n    }\n\n    // add texture BindGroupLayouts\n    for (let t = 0; t < model.textureViews.length; t++) {\n      bindables.push(model.textureViews[t]);\n      const samp = model.textureViews[t].getSampler();\n      if (samp) {\n        bindables.push(samp);\n      }\n    }\n    return bindables;\n  };\n  publicAPI.updatePipeline = () => {\n    publicAPI.computePipelineHash();\n    model.pipeline = model.device.getPipeline(model.pipelineHash);\n\n    // build the pipeline if needed\n    if (!model.pipeline) {\n      model.pipeline = vtkWebGPUPipeline.newInstance();\n      model.pipeline.setDevice(model.device);\n      if (model.WebGPURenderer) {\n        model.pipeline.addBindGroupLayout(model.WebGPURenderer.getBindGroup());\n      }\n      model.pipeline.addBindGroupLayout(model.bindGroup);\n      publicAPI.generateShaderDescriptions(model.pipelineHash, model.pipeline, model.vertexInput);\n      model.pipeline.setTopology(model.topology);\n      model.pipeline.setRenderEncoder(model.renderEncoder);\n      model.pipeline.setVertexState(model.vertexInput.getVertexInputInformation());\n      model.device.createPipeline(model.pipelineHash, model.pipeline);\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  additionalBindables: undefined,\n  bindGroup: null,\n  device: null,\n  fragmentShaderTemplate: null,\n  numberOfInstances: 1,\n  numberOfVertices: 0,\n  pipelineHash: null,\n  shaderReplacements: null,\n  SSBO: null,\n  textureViews: null,\n  topology: 'triangle-list',\n  UBO: null,\n  vertexShaderTemplate: null,\n  WebGPURenderer: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.textureViews = [];\n  model.vertexInput = vtkWebGPUVertexInput.newInstance();\n  model.bindGroup = vtkWebGPUBindGroup.newInstance({\n    label: 'mapperBG'\n  });\n  model.additionalBindables = [];\n  model.fragmentShaderTemplate = model.fragmentShaderTemplate || vtkWebGPUSimpleMapperFS;\n  model.vertexShaderTemplate = model.vertexShaderTemplate || vtkWebGPUSimpleMapperVS;\n  model.shaderReplacements = new Map();\n\n  // Build VTK API\n  macro.get(publicAPI, model, ['pipeline', 'vertexInput']);\n  macro.setGet(publicAPI, model, ['additionalBindables', 'device', 'fragmentShaderTemplate', 'interpolate', 'numberOfInstances', 'numberOfVertices', 'pipelineHash', 'shaderReplacements', 'SSBO', 'textureViews', 'topology', 'UBO', 'vertexShaderTemplate', 'WebGPURenderer']);\n\n  // Object methods\n  vtkWebGPUSimpleMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPUSimpleMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUSimpleMapper$1 = {\n  newInstance,\n  extend\n};\nexport { vtkWebGPUSimpleMapper$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkViewNode","vtkWebGPUBindGroup","vtkWebGPUPipeline","vtkWebGPUShaderCache","vtkWebGPUShaderDescription","vtkWebGPUVertexInput","vtkWebGPUSimpleMapperVS","vtkWebGPUSimpleMapperFS","vtkWebGPUSimpleMapper","publicAPI","model","classHierarchy","push","generateShaderDescriptions","hash","pipeline","vertexInput","vDesc","newInstance","type","code","vertexShaderTemplate","fDesc","fragmentShaderTemplate","sdrs","getShaderDescriptions","scode","re","RegExp","unique","match","filter","v","i","a","indexOf","fnames","map","substring","length","fname","shaderReplacements","has","get","replaceShaderIOStructs","getShaderDescription","replaceShaderCode","replaceShaderRenderEncoder","renderEncoder","set","replaceShaderRenderer","WebGPURenderer","ubocode","getBindGroup","getShaderCode","getCode","substitute","result","setCode","replaceShaderMapper","bindGroup","addBuiltinInput","replaceShaderPosition","addBuiltinOutput","replaceShaderTCoord","addOutput","addTextureView","view","textureViews","includes","prepareToDraw","updateInput","updateBuffers","updateBindings","updatePipeline","setBindables","getBindables","computePipelineHash","registerDrawCallback","encoder","draw","prepareAndDraw","setPipeline","getBoundPipeline","activateBindGroup","bindUBO","bindVertexInput","indexBuffer","getIndexBuffer","drawIndexed","getIndexCount","numberOfInstances","numberOfVertices","bindables","additionalBindables","UBO","SSBO","t","samp","getSampler","device","getPipeline","pipelineHash","setDevice","addBindGroupLayout","setTopology","topology","setRenderEncoder","setVertexState","getVertexInputInformation","createPipeline","DEFAULT_VALUES","undefined","extend","initialValues","arguments","Object","assign","label","Map","setGet","vtkWebGPUSimpleMapper$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/WebGPU/SimpleMapper.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport vtkWebGPUBindGroup from './BindGroup.js';\nimport vtkWebGPUPipeline from './Pipeline.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUShaderDescription from './ShaderDescription.js';\nimport vtkWebGPUVertexInput from './VertexInput.js';\n\nconst vtkWebGPUSimpleMapperVS = `\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n`;\nconst vtkWebGPUSimpleMapperFS = `\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n`;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUSimpleMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUSimpleMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUSimpleMapper');\n  publicAPI.generateShaderDescriptions = (hash, pipeline, vertexInput) => {\n    // create the shader descriptions\n    const vDesc = vtkWebGPUShaderDescription.newInstance({\n      type: 'vertex',\n      hash,\n      code: model.vertexShaderTemplate\n    });\n    const fDesc = vtkWebGPUShaderDescription.newInstance({\n      type: 'fragment',\n      hash,\n      code: model.fragmentShaderTemplate\n    });\n\n    // add them to the pipeline\n    const sdrs = pipeline.getShaderDescriptions();\n    sdrs.push(vDesc);\n    sdrs.push(fDesc);\n\n    // look for replacements to invoke\n    const scode = model.vertexShaderTemplate + model.fragmentShaderTemplate;\n    // eslint-disable-next-line prefer-regex-literals\n    const re = new RegExp('//VTK::[^:]*::', 'g');\n    const unique = scode.match(re).filter((v, i, a) => a.indexOf(v) === i);\n    const fnames = unique.map(v => `replaceShader${v.substring(7, v.length - 2)}`);\n\n    // now invoke shader replacement functions\n    for (let i = 0; i < fnames.length; i++) {\n      const fname = fnames[i];\n      if (fname !== 'replaceShaderIOStructs' && model.shaderReplacements.has(fname)) {\n        model.shaderReplacements.get(fname)(hash, pipeline, vertexInput);\n      }\n    }\n\n    // always replace the IOStructs last as other replacement funcs may\n    // add inputs or outputs\n    publicAPI.replaceShaderIOStructs(hash, pipeline, vertexInput);\n\n    // console.log(vDesc.getCode());\n    // console.log(fDesc.getCode());\n  };\n\n  publicAPI.replaceShaderIOStructs = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.replaceShaderCode(null, vertexInput);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.replaceShaderCode(vDesc);\n  };\n  publicAPI.replaceShaderRenderEncoder = (hash, pipeline, vertexInput) => {\n    model.renderEncoder.replaceShaderCode(pipeline);\n  };\n  model.shaderReplacements.set('replaceShaderRenderEncoder', publicAPI.replaceShaderRenderEncoder);\n  publicAPI.replaceShaderRenderer = (hash, pipeline, vertexInput) => {\n    if (!model.WebGPURenderer) {\n      return;\n    }\n    const ubocode = model.WebGPURenderer.getBindGroup().getShaderCode(pipeline);\n    const vDesc = pipeline.getShaderDescription('vertex');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Renderer::Dec', [ubocode]).result;\n    vDesc.setCode(code);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Renderer::Dec', [ubocode]).result;\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderRenderer', publicAPI.replaceShaderRenderer);\n  publicAPI.replaceShaderMapper = (hash, pipeline, vertexInput) => {\n    const ubocode = model.bindGroup.getShaderCode(pipeline);\n    const vDesc = pipeline.getShaderDescription('vertex');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Mapper::Dec', [ubocode]).result;\n    vDesc.setCode(code);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinInput('bool', '@builtin(front_facing) frontFacing');\n    code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Mapper::Dec', [ubocode]).result;\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderMapper', publicAPI.replaceShaderMapper);\n  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    output.Position = rendererUBO.SCPCMatrix*vertexBC;']).result;\n    vDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addOutput('vec2<f32>', 'tcoordVS');\n  };\n  model.shaderReplacements.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);\n  publicAPI.addTextureView = view => {\n    // is it already there?\n    if (model.textureViews.includes(view)) {\n      return;\n    }\n    model.textureViews.push(view);\n  };\n\n  // do everything required for this mapper to be rerady to draw\n  // but do not bind or do the actual draw commands as the pipeline\n  // is not neccessarily bound yet\n  publicAPI.prepareToDraw = renderEncoder => {\n    model.renderEncoder = renderEncoder;\n\n    // do anything needed to get our input data up to date\n    publicAPI.updateInput();\n\n    // make sure buffers are created and up to date\n    publicAPI.updateBuffers();\n\n    // update bindings and bind groups/layouts\n    // does not acutally bind them, that is done in draw(...)\n    publicAPI.updateBindings();\n\n    // update the pipeline, includes computing the hash, and if needed\n    // creating the pipeline, shader code etc\n    publicAPI.updatePipeline();\n  };\n  publicAPI.updateInput = () => {};\n  publicAPI.updateBuffers = () => {};\n  publicAPI.updateBindings = () => {\n    // bindings can change without a pipeline change\n    // as long as their layout remains the same.\n    // That is why this is done even when the pipeline\n    // hash doesn't change.\n    model.bindGroup.setBindables(publicAPI.getBindables());\n  };\n  publicAPI.computePipelineHash = () => {};\n  publicAPI.registerDrawCallback = encoder => {\n    encoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n  };\n  publicAPI.prepareAndDraw = encoder => {\n    publicAPI.prepareToDraw(encoder);\n    encoder.setPipeline(model.pipeline);\n    publicAPI.draw(encoder);\n  };\n\n  // do the rest of the calls required to draw this mapper\n  // at this point the command encouder and pipeline are\n  // created and bound\n  publicAPI.draw = renderEncoder => {\n    const pipeline = renderEncoder.getBoundPipeline();\n\n    // bind the mapper bind group\n    renderEncoder.activateBindGroup(model.bindGroup);\n    if (model.WebGPURenderer) {\n      model.WebGPURenderer.bindUBO(renderEncoder);\n    }\n\n    // bind the vertex input\n    pipeline.bindVertexInput(renderEncoder, model.vertexInput);\n    const indexBuffer = model.vertexInput.getIndexBuffer();\n    if (indexBuffer) {\n      renderEncoder.drawIndexed(indexBuffer.getIndexCount(), model.numberOfInstances, 0, 0, 0);\n    } else {\n      renderEncoder.draw(model.numberOfVertices, model.numberOfInstances, 0, 0);\n    }\n  };\n  publicAPI.getBindables = () => {\n    const bindables = [...model.additionalBindables];\n    if (model.UBO) {\n      bindables.push(model.UBO);\n    }\n    if (model.SSBO) {\n      bindables.push(model.SSBO);\n    }\n\n    // add texture BindGroupLayouts\n    for (let t = 0; t < model.textureViews.length; t++) {\n      bindables.push(model.textureViews[t]);\n      const samp = model.textureViews[t].getSampler();\n      if (samp) {\n        bindables.push(samp);\n      }\n    }\n    return bindables;\n  };\n  publicAPI.updatePipeline = () => {\n    publicAPI.computePipelineHash();\n    model.pipeline = model.device.getPipeline(model.pipelineHash);\n\n    // build the pipeline if needed\n    if (!model.pipeline) {\n      model.pipeline = vtkWebGPUPipeline.newInstance();\n      model.pipeline.setDevice(model.device);\n      if (model.WebGPURenderer) {\n        model.pipeline.addBindGroupLayout(model.WebGPURenderer.getBindGroup());\n      }\n      model.pipeline.addBindGroupLayout(model.bindGroup);\n      publicAPI.generateShaderDescriptions(model.pipelineHash, model.pipeline, model.vertexInput);\n      model.pipeline.setTopology(model.topology);\n      model.pipeline.setRenderEncoder(model.renderEncoder);\n      model.pipeline.setVertexState(model.vertexInput.getVertexInputInformation());\n      model.device.createPipeline(model.pipelineHash, model.pipeline);\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  additionalBindables: undefined,\n  bindGroup: null,\n  device: null,\n  fragmentShaderTemplate: null,\n  numberOfInstances: 1,\n  numberOfVertices: 0,\n  pipelineHash: null,\n  shaderReplacements: null,\n  SSBO: null,\n  textureViews: null,\n  topology: 'triangle-list',\n  UBO: null,\n  vertexShaderTemplate: null,\n  WebGPURenderer: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.textureViews = [];\n  model.vertexInput = vtkWebGPUVertexInput.newInstance();\n  model.bindGroup = vtkWebGPUBindGroup.newInstance({\n    label: 'mapperBG'\n  });\n  model.additionalBindables = [];\n  model.fragmentShaderTemplate = model.fragmentShaderTemplate || vtkWebGPUSimpleMapperFS;\n  model.vertexShaderTemplate = model.vertexShaderTemplate || vtkWebGPUSimpleMapperVS;\n  model.shaderReplacements = new Map();\n\n  // Build VTK API\n  macro.get(publicAPI, model, ['pipeline', 'vertexInput']);\n  macro.setGet(publicAPI, model, ['additionalBindables', 'device', 'fragmentShaderTemplate', 'interpolate', 'numberOfInstances', 'numberOfVertices', 'pipelineHash', 'shaderReplacements', 'SSBO', 'textureViews', 'topology', 'UBO', 'vertexShaderTemplate', 'WebGPURenderer']);\n\n  // Object methods\n  vtkWebGPUSimpleMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPUSimpleMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUSimpleMapper$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUSimpleMapper$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}