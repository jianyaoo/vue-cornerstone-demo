import vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';
import { Metadata, Point3, IImageVolume, Mat3, PixelDataTypedArray, ImageVolumeProps, IImage, IImageLoadObject } from '../../types';
export declare class ImageVolume implements IImageVolume {
    private _imageIds;
    private _imageIdsIndexMap;
    private _imageURIsIndexMap;
    protected scalarData: PixelDataTypedArray | Array<PixelDataTypedArray>;
    protected numFrames: number;
    protected totalNumFrames: number;
    protected cornerstoneImageMetaData: any;
    readonly volumeId: string;
    imageCacheOffsetMap: Map<any, any>;
    isPreScaled: boolean;
    dimensions: Point3;
    direction: Mat3;
    metadata: Metadata;
    origin: Point3;
    scaling?: {
        PT?: {
            SUVlbmFactor?: number;
            SUVbsaFactor?: number;
            suvbwToSuvlbm?: number;
            suvbwToSuvbsa?: number;
        };
    };
    sizeInBytes?: number;
    spacing: Point3;
    numVoxels: number;
    imageData?: vtkImageData;
    vtkOpenGLTexture: any;
    loadStatus?: Record<string, any>;
    referencedVolumeId?: string;
    referencedImageIds?: Array<string>;
    hasPixelSpacing: boolean;
    additionalDetails?: Record<string, any>;
    constructor(props: ImageVolumeProps);
    get imageIds(): Array<string>;
    set imageIds(newImageIds: Array<string>);
    private _reprocessImageIds;
    cancelLoading: () => void;
    isDynamicVolume(): boolean;
    getScalarData(): PixelDataTypedArray;
    getImageIdIndex(imageId: string): number;
    getImageURIIndex(imageURI: string): number;
    destroy(): void;
    getScalarDataArrays(): PixelDataTypedArray[];
    modified(): void;
    decache(completelyRemove?: boolean): void | Array<string>;
    removeFromCache(): void;
    getScalarDataLength(): number;
    private _getNumFrames;
    private _getScalarDataLength;
    private _createCornerstoneImageMetaData;
    protected getScalarDataByImageIdIndex(imageIdIndex: number): PixelDataTypedArray;
    getCornerstoneImage(imageId: string, imageIdIndex: number): IImage;
    protected imageIdIndexToFrameIndex(imageIdIndex: number): number;
    convertToCornerstoneImage(imageId: string, imageIdIndex: number): IImageLoadObject;
    getCornerstoneImageLoadObject(imageId: string, imageIdIndex: number): IImageLoadObject;
    getCornerstoneImages(): IImage[];
    convertToImageSlicesAndCache(): string[];
}
export default ImageVolume;
//# sourceMappingURL=ImageVolume.d.ts.map