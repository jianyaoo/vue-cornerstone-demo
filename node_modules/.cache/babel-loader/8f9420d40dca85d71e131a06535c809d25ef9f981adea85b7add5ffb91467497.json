{"ast":null,"code":"import { m as macro } from '../../macros2.js';\nimport { d as dot, s as subtract, j as cross, k as add, l as normalize, e as distance2BetweenPoints, n as norm } from '../Core/Math/index.js';\nimport vtkLine from './Line.js';\nimport vtkPlane from './Plane.js';\nimport vtkPriorityQueue from '../Core/PriorityQueue.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport { IntersectionState } from './Line/Constants.js';\nimport { PolygonWithPointIntersectionState, FLOAT_EPSILON, TOLERANCE, EPSILON } from './Polygon/Constants.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n// Given the line (p0,p1), determine if the given point is located to the left\n// of, on, or to the right of a line (with the function returning >0, ==0, or\n// <0 respectively). The points are assumed 3D points, but projected into\n// one of x-y-z planes; hence the indices axis0 and axis1 specify which plane\n// the computation is to be performed on.\nfunction pointLocation(axis0, axis1, p0, p1, point) {\n  return (p1[axis0] - p0[axis0]) * (point[axis1] - p0[axis1]) - (point[axis0] - p0[axis0]) * (p1[axis1] - p0[axis1]);\n}\n\n//------------------------------------------------------------------------------\n\nfunction pointInPolygon(point, vertices, bounds, normal) {\n  // Do a quick bounds check to throw out trivial cases.\n  // winding plane.\n  if (point[0] < bounds[0] || point[0] > bounds[1] || point[1] < bounds[2] || point[1] > bounds[3] || point[2] < bounds[4] || point[2] > bounds[5]) {\n    return PolygonWithPointIntersectionState.OUTSIDE;\n  }\n\n  //  Check that the normal is non-zero.\n  if (normalize(normal) <= FLOAT_EPSILON) {\n    return PolygonWithPointIntersectionState.FAILURE;\n  }\n\n  // Assess whether the point lies on the boundary of the polygon. Points on\n  // the boundary are considered inside the polygon. Need to define a small\n  // tolerance relative to the bounding box diagonal length of the polygon.\n  let tol2 = TOLERANCE * ((bounds[1] - bounds[0]) * (bounds[1] - bounds[0]) + (bounds[3] - bounds[2]) * (bounds[3] - bounds[2]) + (bounds[5] - bounds[4]) * (bounds[5] - bounds[4]));\n  tol2 *= tol2;\n  tol2 = tol2 === 0.0 ? FLOAT_EPSILON : tol2;\n  const p0 = [];\n  const p1 = [];\n  for (let i = 0; i < vertices.length;) {\n    // Check coincidence to polygon vertices\n    p0[0] = vertices[i++];\n    p0[1] = vertices[i++];\n    p0[2] = vertices[i++];\n    if (distance2BetweenPoints(point, p0) <= tol2) {\n      return PolygonWithPointIntersectionState.INSIDE;\n    }\n\n    // Check coincidence to polygon edges\n    const {\n      distance,\n      t\n    } = vtkLine.distanceToLine(point, p0, p1);\n    if (distance <= tol2 && t > 0.0 && t < 1.0) {\n      return PolygonWithPointIntersectionState.INSIDE;\n    }\n  }\n\n  // If here, begin computation of the winding number. This method works for\n  // points/polygons arbitrarily oriented in 3D space.  Hence a projection\n  // onto one of the x-y-z coordinate planes using the maximum normal\n  // component. The computation will be performed in the (axis0, axis1) plane.\n  let axis0;\n  let axis1;\n  if (Math.abs(normal[0]) > Math.abs(normal[1])) {\n    if (Math.abs(normal[0]) > Math.abs(normal[2])) {\n      axis0 = 1;\n      axis1 = 2;\n    } else {\n      axis0 = 0;\n      axis1 = 1;\n    }\n  } else if (Math.abs(normal[1]) > Math.abs(normal[2])) {\n    axis0 = 0;\n    axis1 = 2;\n  } else {\n    axis0 = 0;\n    axis1 = 1;\n  }\n\n  // Compute the winding number wn. If after processing all polygon edges\n  // wn == 0, then the point is outside.  Otherwise, the point is inside the\n  // polygon. Process all polygon edges determining if there are ascending or\n  // descending crossings of the line axis1=constant.\n  let wn = 0;\n  for (let i = 0; i < vertices.length;) {\n    p0[0] = vertices[i++];\n    p0[1] = vertices[i++];\n    p0[2] = vertices[i++];\n    if (i < vertices.length) {\n      p1[0] = vertices[i];\n      p1[1] = vertices[i + 1];\n      p1[2] = vertices[i + 2];\n    } else {\n      p1[0] = vertices[0];\n      p1[1] = vertices[1];\n      p1[2] = vertices[2];\n    }\n    if (p0[axis1] <= point[axis1]) {\n      if (p1[axis1] > point[axis1]) {\n        // if an upward crossing\n        if (pointLocation(axis0, axis1, p0, p1, point) > 0) {\n          // if x left of edge\n          ++wn; // a valid up intersect, increment the winding number\n        }\n      }\n    } else if (p1[axis1] <= point[axis1]) {\n      // if a downward crossing\n      if (pointLocation(axis0, axis1, p0, p1, point) < 0) {\n        // if x right of edge\n        --wn; // a valid down intersect, decrement the winding number\n      }\n    }\n  } // Over all polygon edges\n\n  // A winding number == 0 is outside the polygon\n  return wn === 0 ? PolygonWithPointIntersectionState.OUTSIDE : PolygonWithPointIntersectionState.INSIDE;\n}\n\n// ---------------------------------------------------\n/**\n * Simple utility method for computing polygon bounds.\n * Returns the sum of the squares of the dimensions.\n * Requires a poly with at least one point.\n *\n * @param {Array<Number>|TypedArray<Number>} poly\n * @param {vtkPoints} points\n * @param {Bound} bounds\n */\nfunction getBounds(poly, points, bounds) {\n  const n = poly.length;\n  const p = [];\n  points.getPoint(poly[0], p);\n  bounds[0] = p[0];\n  bounds[1] = p[0];\n  bounds[2] = p[1];\n  bounds[3] = p[1];\n  bounds[4] = p[2];\n  bounds[5] = p[2];\n  for (let j = 1; j < n; j++) {\n    points.getPoint(poly[j], p);\n    vtkBoundingBox.addPoint(bounds, ...p);\n  }\n  const length = vtkBoundingBox.getLengths(bounds);\n  return dot(length, length);\n}\n\n// ---------------------------------------------------\n/**\n * Compute the normal of a polygon and return its norm.\n *\n * TBD: This does the same thing as vtkPolygon.computeNormal,\n * but in a more generic way. Maybe we can keep the public\n * static method somehow and have the private method use it instead.\n *\n * @param {Array<Number>|TypedArray<Number>} poly\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @returns {Number}\n */\nfunction getNormal(poly, points, normal) {\n  normal.length = 3;\n  normal[0] = 0.0;\n  normal[1] = 0.0;\n  normal[2] = 0.0;\n  const p0 = [];\n  let p1 = [];\n  let p2 = [];\n  const v1 = [];\n  const v2 = [];\n  points.getPoint(poly[0], p0);\n  points.getPoint(poly[1], p1);\n  for (let j = 2; j < poly.length; j++) {\n    points.getPoint(poly[j], p2);\n    subtract(p2, p1, v1);\n    subtract(p0, p1, v2);\n    const n = [0, 0, 0];\n    cross(v1, v2, n);\n    add(normal, n, normal);\n    [p1, p2] = [p2, p1];\n  }\n  return normalize(normal);\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  PolygonWithPointIntersectionState,\n  pointInPolygon,\n  getBounds,\n  getNormal\n};\n\n// ----------------------------------------------------------------------------\n// vtkPolygon methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPolygon(publicAPI, model) {\n  // Set our classname\n  model.classHierarchy.push('vtkPolygon');\n  function computeNormal() {\n    const v1 = [0, 0, 0];\n    const v2 = [0, 0, 0];\n    model.normal = [0, 0, 0];\n    const anchor = [...model.firstPoint.point];\n    let point = model.firstPoint;\n    for (let i = 0; i < model.pointCount; i++) {\n      subtract(point.point, anchor, v1);\n      subtract(point.next.point, anchor, v2);\n      const n = [0, 0, 0];\n      cross(v1, v2, n);\n      add(model.normal, n, model.normal);\n      point = point.next;\n    }\n    return normalize(model.normal);\n  }\n  function computeMeasure(point) {\n    const v1 = [0, 0, 0];\n    const v2 = [0, 0, 0];\n    const v3 = [0, 0, 0];\n    const v4 = [0, 0, 0];\n    subtract(point.point, point.previous.point, v1);\n    subtract(point.next.point, point.point, v2);\n    subtract(point.previous.point, point.next.point, v3);\n    cross(v1, v2, v4);\n    const area = dot(v4, model.normal);\n    if (area <= 0) {\n      return -1;\n    }\n    const perimeter = norm(v1) + norm(v2) + norm(v3);\n    return perimeter * perimeter / area;\n  }\n  function canRemoveVertex(point) {\n    if (model.pointCount <= 3) {\n      return true;\n    }\n    const previous = point.previous;\n    const next = point.next;\n    const v = [0, 0, 0];\n    subtract(next.point, previous.point, v);\n    const sN = [0, 0, 0];\n    cross(v, model.normal, sN);\n    normalize(sN);\n    if (norm(sN) === 0) {\n      return false;\n    }\n    let val = vtkPlane.evaluate(sN, previous.point, next.next.point);\n    // eslint-disable-next-line no-nested-ternary\n    let currentSign = val > EPSILON ? 1 : val < -EPSILON ? -1 : 0;\n    let oneNegative = currentSign < 0 ? 1 : 0;\n    for (let vertex = next.next.next; vertex.id !== previous.id; vertex = vertex.next) {\n      const previousVertex = vertex.previous;\n      val = vtkPlane.evaluate(sN, previous.point, vertex.point);\n      // eslint-disable-next-line no-nested-ternary\n      const sign = val > EPSILON ? 1 : val < -EPSILON ? -1 : 0;\n      if (sign !== currentSign) {\n        if (!oneNegative) {\n          oneNegative = sign <= 0 ? 1 : 0;\n        }\n        if (vtkLine.intersection(previous.point, next.point, vertex.point, previousVertex.point, [0], [0]) === IntersectionState.YES_INTERSECTION) {\n          return false;\n        }\n        currentSign = sign;\n      }\n    }\n    return oneNegative === 1;\n  }\n  function removePoint(point, queue) {\n    model.pointCount -= 1;\n    const previous = point.previous;\n    const next = point.next;\n    model.tris = model.tris.concat(point.point);\n    model.tris = model.tris.concat(next.point);\n    model.tris = model.tris.concat(previous.point);\n    previous.next = next;\n    next.previous = previous;\n    queue.deleteById(previous.id);\n    queue.deleteById(next.id);\n    const previousMeasure = computeMeasure(previous);\n    if (previousMeasure > 0) {\n      queue.push(previousMeasure, previous);\n    }\n    const nextMeasure = computeMeasure(next);\n    if (nextMeasure > 0) {\n      queue.push(nextMeasure, next);\n    }\n    if (point.id === model.firstPoint.id) {\n      model.firstPoint = next;\n    }\n  }\n  function earCutTriangulation() {\n    computeNormal();\n    const vertexQueue = vtkPriorityQueue.newInstance();\n    let point = model.firstPoint;\n    for (let i = 0; i < model.pointCount; i++) {\n      const measure = computeMeasure(point);\n      if (measure > 0) {\n        vertexQueue.push(measure, point);\n      }\n      point = point.next;\n    }\n    while (model.pointCount > 2 && vertexQueue.length() > 0) {\n      if (model.pointCount === vertexQueue.length()) {\n        // convex\n        const pointToRemove = vertexQueue.pop();\n        removePoint(pointToRemove, vertexQueue);\n      } else {\n        // concave\n        const pointToRemove = vertexQueue.pop();\n        if (canRemoveVertex(pointToRemove)) {\n          removePoint(pointToRemove, vertexQueue);\n        }\n      }\n    }\n    return model.pointCount <= 2;\n  }\n  publicAPI.triangulate = () => {\n    if (!model.firstPoint) {\n      return null;\n    }\n    return earCutTriangulation();\n  };\n  publicAPI.setPoints = points => {\n    model.pointCount = points.length;\n    model.firstPoint = {\n      id: 0,\n      point: points[0],\n      next: null,\n      previous: null\n    };\n    let currentPoint = model.firstPoint;\n    for (let i = 1; i < model.pointCount; i++) {\n      currentPoint.next = {\n        id: i,\n        point: points[i],\n        next: null,\n        previous: currentPoint\n      };\n      currentPoint = currentPoint.next;\n    }\n    model.firstPoint.previous = currentPoint;\n    currentPoint.next = model.firstPoint;\n  };\n  publicAPI.getPointArray = () => model.tris;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  firstPoint: null,\n  pointCount: 0,\n  tris: []\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  vtkPolygon(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPolygon');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPolygon$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\nexport { vtkPolygon$1 as default, extend, getBounds, getNormal, newInstance };","map":{"version":3,"names":["m","macro","d","dot","s","subtract","j","cross","k","add","l","normalize","e","distance2BetweenPoints","n","norm","vtkLine","vtkPlane","vtkPriorityQueue","vtkBoundingBox","IntersectionState","PolygonWithPointIntersectionState","FLOAT_EPSILON","TOLERANCE","EPSILON","pointLocation","axis0","axis1","p0","p1","point","pointInPolygon","vertices","bounds","normal","OUTSIDE","FAILURE","tol2","i","length","INSIDE","distance","t","distanceToLine","Math","abs","wn","getBounds","poly","points","p","getPoint","addPoint","getLengths","getNormal","p2","v1","v2","STATIC","vtkPolygon","publicAPI","model","classHierarchy","push","computeNormal","anchor","firstPoint","pointCount","next","computeMeasure","v3","v4","previous","area","perimeter","canRemoveVertex","v","sN","val","evaluate","currentSign","oneNegative","vertex","id","previousVertex","sign","intersection","YES_INTERSECTION","removePoint","queue","tris","concat","deleteById","previousMeasure","nextMeasure","earCutTriangulation","vertexQueue","newInstance","measure","pointToRemove","pop","triangulate","setPoints","currentPoint","getPointArray","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","obj","vtkPolygon$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Common/DataModel/Polygon.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport { d as dot, s as subtract, j as cross, k as add, l as normalize, e as distance2BetweenPoints, n as norm } from '../Core/Math/index.js';\nimport vtkLine from './Line.js';\nimport vtkPlane from './Plane.js';\nimport vtkPriorityQueue from '../Core/PriorityQueue.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport { IntersectionState } from './Line/Constants.js';\nimport { PolygonWithPointIntersectionState, FLOAT_EPSILON, TOLERANCE, EPSILON } from './Polygon/Constants.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n// Given the line (p0,p1), determine if the given point is located to the left\n// of, on, or to the right of a line (with the function returning >0, ==0, or\n// <0 respectively). The points are assumed 3D points, but projected into\n// one of x-y-z planes; hence the indices axis0 and axis1 specify which plane\n// the computation is to be performed on.\nfunction pointLocation(axis0, axis1, p0, p1, point) {\n  return (p1[axis0] - p0[axis0]) * (point[axis1] - p0[axis1]) - (point[axis0] - p0[axis0]) * (p1[axis1] - p0[axis1]);\n}\n\n//------------------------------------------------------------------------------\n\nfunction pointInPolygon(point, vertices, bounds, normal) {\n  // Do a quick bounds check to throw out trivial cases.\n  // winding plane.\n  if (point[0] < bounds[0] || point[0] > bounds[1] || point[1] < bounds[2] || point[1] > bounds[3] || point[2] < bounds[4] || point[2] > bounds[5]) {\n    return PolygonWithPointIntersectionState.OUTSIDE;\n  }\n\n  //  Check that the normal is non-zero.\n  if (normalize(normal) <= FLOAT_EPSILON) {\n    return PolygonWithPointIntersectionState.FAILURE;\n  }\n\n  // Assess whether the point lies on the boundary of the polygon. Points on\n  // the boundary are considered inside the polygon. Need to define a small\n  // tolerance relative to the bounding box diagonal length of the polygon.\n  let tol2 = TOLERANCE * ((bounds[1] - bounds[0]) * (bounds[1] - bounds[0]) + (bounds[3] - bounds[2]) * (bounds[3] - bounds[2]) + (bounds[5] - bounds[4]) * (bounds[5] - bounds[4]));\n  tol2 *= tol2;\n  tol2 = tol2 === 0.0 ? FLOAT_EPSILON : tol2;\n  const p0 = [];\n  const p1 = [];\n  for (let i = 0; i < vertices.length;) {\n    // Check coincidence to polygon vertices\n    p0[0] = vertices[i++];\n    p0[1] = vertices[i++];\n    p0[2] = vertices[i++];\n    if (distance2BetweenPoints(point, p0) <= tol2) {\n      return PolygonWithPointIntersectionState.INSIDE;\n    }\n\n    // Check coincidence to polygon edges\n    const {\n      distance,\n      t\n    } = vtkLine.distanceToLine(point, p0, p1);\n    if (distance <= tol2 && t > 0.0 && t < 1.0) {\n      return PolygonWithPointIntersectionState.INSIDE;\n    }\n  }\n\n  // If here, begin computation of the winding number. This method works for\n  // points/polygons arbitrarily oriented in 3D space.  Hence a projection\n  // onto one of the x-y-z coordinate planes using the maximum normal\n  // component. The computation will be performed in the (axis0, axis1) plane.\n  let axis0;\n  let axis1;\n  if (Math.abs(normal[0]) > Math.abs(normal[1])) {\n    if (Math.abs(normal[0]) > Math.abs(normal[2])) {\n      axis0 = 1;\n      axis1 = 2;\n    } else {\n      axis0 = 0;\n      axis1 = 1;\n    }\n  } else if (Math.abs(normal[1]) > Math.abs(normal[2])) {\n    axis0 = 0;\n    axis1 = 2;\n  } else {\n    axis0 = 0;\n    axis1 = 1;\n  }\n\n  // Compute the winding number wn. If after processing all polygon edges\n  // wn == 0, then the point is outside.  Otherwise, the point is inside the\n  // polygon. Process all polygon edges determining if there are ascending or\n  // descending crossings of the line axis1=constant.\n  let wn = 0;\n  for (let i = 0; i < vertices.length;) {\n    p0[0] = vertices[i++];\n    p0[1] = vertices[i++];\n    p0[2] = vertices[i++];\n    if (i < vertices.length) {\n      p1[0] = vertices[i];\n      p1[1] = vertices[i + 1];\n      p1[2] = vertices[i + 2];\n    } else {\n      p1[0] = vertices[0];\n      p1[1] = vertices[1];\n      p1[2] = vertices[2];\n    }\n    if (p0[axis1] <= point[axis1]) {\n      if (p1[axis1] > point[axis1]) {\n        // if an upward crossing\n        if (pointLocation(axis0, axis1, p0, p1, point) > 0) {\n          // if x left of edge\n          ++wn; // a valid up intersect, increment the winding number\n        }\n      }\n    } else if (p1[axis1] <= point[axis1]) {\n      // if a downward crossing\n      if (pointLocation(axis0, axis1, p0, p1, point) < 0) {\n        // if x right of edge\n        --wn; // a valid down intersect, decrement the winding number\n      }\n    }\n  } // Over all polygon edges\n\n  // A winding number == 0 is outside the polygon\n  return wn === 0 ? PolygonWithPointIntersectionState.OUTSIDE : PolygonWithPointIntersectionState.INSIDE;\n}\n\n// ---------------------------------------------------\n/**\n * Simple utility method for computing polygon bounds.\n * Returns the sum of the squares of the dimensions.\n * Requires a poly with at least one point.\n *\n * @param {Array<Number>|TypedArray<Number>} poly\n * @param {vtkPoints} points\n * @param {Bound} bounds\n */\nfunction getBounds(poly, points, bounds) {\n  const n = poly.length;\n  const p = [];\n  points.getPoint(poly[0], p);\n  bounds[0] = p[0];\n  bounds[1] = p[0];\n  bounds[2] = p[1];\n  bounds[3] = p[1];\n  bounds[4] = p[2];\n  bounds[5] = p[2];\n  for (let j = 1; j < n; j++) {\n    points.getPoint(poly[j], p);\n    vtkBoundingBox.addPoint(bounds, ...p);\n  }\n  const length = vtkBoundingBox.getLengths(bounds);\n  return dot(length, length);\n}\n\n// ---------------------------------------------------\n/**\n * Compute the normal of a polygon and return its norm.\n *\n * TBD: This does the same thing as vtkPolygon.computeNormal,\n * but in a more generic way. Maybe we can keep the public\n * static method somehow and have the private method use it instead.\n *\n * @param {Array<Number>|TypedArray<Number>} poly\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @returns {Number}\n */\nfunction getNormal(poly, points, normal) {\n  normal.length = 3;\n  normal[0] = 0.0;\n  normal[1] = 0.0;\n  normal[2] = 0.0;\n  const p0 = [];\n  let p1 = [];\n  let p2 = [];\n  const v1 = [];\n  const v2 = [];\n  points.getPoint(poly[0], p0);\n  points.getPoint(poly[1], p1);\n  for (let j = 2; j < poly.length; j++) {\n    points.getPoint(poly[j], p2);\n    subtract(p2, p1, v1);\n    subtract(p0, p1, v2);\n    const n = [0, 0, 0];\n    cross(v1, v2, n);\n    add(normal, n, normal);\n    [p1, p2] = [p2, p1];\n  }\n  return normalize(normal);\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  PolygonWithPointIntersectionState,\n  pointInPolygon,\n  getBounds,\n  getNormal\n};\n\n// ----------------------------------------------------------------------------\n// vtkPolygon methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPolygon(publicAPI, model) {\n  // Set our classname\n  model.classHierarchy.push('vtkPolygon');\n  function computeNormal() {\n    const v1 = [0, 0, 0];\n    const v2 = [0, 0, 0];\n    model.normal = [0, 0, 0];\n    const anchor = [...model.firstPoint.point];\n    let point = model.firstPoint;\n    for (let i = 0; i < model.pointCount; i++) {\n      subtract(point.point, anchor, v1);\n      subtract(point.next.point, anchor, v2);\n      const n = [0, 0, 0];\n      cross(v1, v2, n);\n      add(model.normal, n, model.normal);\n      point = point.next;\n    }\n    return normalize(model.normal);\n  }\n  function computeMeasure(point) {\n    const v1 = [0, 0, 0];\n    const v2 = [0, 0, 0];\n    const v3 = [0, 0, 0];\n    const v4 = [0, 0, 0];\n    subtract(point.point, point.previous.point, v1);\n    subtract(point.next.point, point.point, v2);\n    subtract(point.previous.point, point.next.point, v3);\n    cross(v1, v2, v4);\n    const area = dot(v4, model.normal);\n    if (area <= 0) {\n      return -1;\n    }\n    const perimeter = norm(v1) + norm(v2) + norm(v3);\n    return perimeter * perimeter / area;\n  }\n  function canRemoveVertex(point) {\n    if (model.pointCount <= 3) {\n      return true;\n    }\n    const previous = point.previous;\n    const next = point.next;\n    const v = [0, 0, 0];\n    subtract(next.point, previous.point, v);\n    const sN = [0, 0, 0];\n    cross(v, model.normal, sN);\n    normalize(sN);\n    if (norm(sN) === 0) {\n      return false;\n    }\n    let val = vtkPlane.evaluate(sN, previous.point, next.next.point);\n    // eslint-disable-next-line no-nested-ternary\n    let currentSign = val > EPSILON ? 1 : val < -EPSILON ? -1 : 0;\n    let oneNegative = currentSign < 0 ? 1 : 0;\n    for (let vertex = next.next.next; vertex.id !== previous.id; vertex = vertex.next) {\n      const previousVertex = vertex.previous;\n      val = vtkPlane.evaluate(sN, previous.point, vertex.point);\n      // eslint-disable-next-line no-nested-ternary\n      const sign = val > EPSILON ? 1 : val < -EPSILON ? -1 : 0;\n      if (sign !== currentSign) {\n        if (!oneNegative) {\n          oneNegative = sign <= 0 ? 1 : 0;\n        }\n        if (vtkLine.intersection(previous.point, next.point, vertex.point, previousVertex.point, [0], [0]) === IntersectionState.YES_INTERSECTION) {\n          return false;\n        }\n        currentSign = sign;\n      }\n    }\n    return oneNegative === 1;\n  }\n  function removePoint(point, queue) {\n    model.pointCount -= 1;\n    const previous = point.previous;\n    const next = point.next;\n    model.tris = model.tris.concat(point.point);\n    model.tris = model.tris.concat(next.point);\n    model.tris = model.tris.concat(previous.point);\n    previous.next = next;\n    next.previous = previous;\n    queue.deleteById(previous.id);\n    queue.deleteById(next.id);\n    const previousMeasure = computeMeasure(previous);\n    if (previousMeasure > 0) {\n      queue.push(previousMeasure, previous);\n    }\n    const nextMeasure = computeMeasure(next);\n    if (nextMeasure > 0) {\n      queue.push(nextMeasure, next);\n    }\n    if (point.id === model.firstPoint.id) {\n      model.firstPoint = next;\n    }\n  }\n  function earCutTriangulation() {\n    computeNormal();\n    const vertexQueue = vtkPriorityQueue.newInstance();\n    let point = model.firstPoint;\n    for (let i = 0; i < model.pointCount; i++) {\n      const measure = computeMeasure(point);\n      if (measure > 0) {\n        vertexQueue.push(measure, point);\n      }\n      point = point.next;\n    }\n    while (model.pointCount > 2 && vertexQueue.length() > 0) {\n      if (model.pointCount === vertexQueue.length()) {\n        // convex\n        const pointToRemove = vertexQueue.pop();\n        removePoint(pointToRemove, vertexQueue);\n      } else {\n        // concave\n        const pointToRemove = vertexQueue.pop();\n        if (canRemoveVertex(pointToRemove)) {\n          removePoint(pointToRemove, vertexQueue);\n        }\n      }\n    }\n    return model.pointCount <= 2;\n  }\n  publicAPI.triangulate = () => {\n    if (!model.firstPoint) {\n      return null;\n    }\n    return earCutTriangulation();\n  };\n  publicAPI.setPoints = points => {\n    model.pointCount = points.length;\n    model.firstPoint = {\n      id: 0,\n      point: points[0],\n      next: null,\n      previous: null\n    };\n    let currentPoint = model.firstPoint;\n    for (let i = 1; i < model.pointCount; i++) {\n      currentPoint.next = {\n        id: i,\n        point: points[i],\n        next: null,\n        previous: currentPoint\n      };\n      currentPoint = currentPoint.next;\n    }\n    model.firstPoint.previous = currentPoint;\n    currentPoint.next = model.firstPoint;\n  };\n  publicAPI.getPointArray = () => model.tris;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  firstPoint: null,\n  pointCount: 0,\n  tris: []\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  vtkPolygon(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPolygon');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPolygon$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { vtkPolygon$1 as default, extend, getBounds, getNormal, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}