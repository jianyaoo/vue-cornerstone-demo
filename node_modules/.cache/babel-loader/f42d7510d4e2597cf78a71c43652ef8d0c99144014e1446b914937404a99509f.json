{"ast":null,"code":"import { m as macro } from '../../macros2.js';\nimport vtkAbstractMapper3D from './AbstractMapper3D.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkImageData from '../../Common/DataModel/ImageData.js';\nimport vtkLookupTable from '../../Common/Core/LookupTable.js';\nimport { F as createUninitializedBounds, i as isNan } from '../../Common/Core/Math/index.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors/Constants.js';\nimport CoincidentTopologyHelper from './Mapper/CoincidentTopologyHelper.js';\nimport Constants from './Mapper/Constants.js';\nimport vtkDataSet from '../../Common/DataModel/DataSet.js';\nimport { PassTypes } from '../OpenGL/HardwareSelector/Constants.js';\nconst {\n  FieldAssociations\n} = vtkDataSet;\nconst {\n  staticOffsetAPI,\n  otherStaticMethods\n} = CoincidentTopologyHelper;\nconst {\n  ColorMode,\n  ScalarMode,\n  GetArray\n} = Constants;\nconst {\n  VectorMode\n} = vtkScalarsToColors;\nconst {\n  VtkDataTypes\n} = vtkDataArray;\n\n// ----------------------------------------------------------------------------\n\nfunction notImplemented(method) {\n  return () => macro.vtkErrorMacro(`vtkMapper::${method} - NOT IMPLEMENTED`);\n}\n\n// ----------------------------------------------------------------------------\n// vtkMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMapper');\n  publicAPI.getBounds = () => {\n    const input = publicAPI.getInputData();\n    if (!input) {\n      model.bounds = createUninitializedBounds();\n    } else {\n      if (!model.static) {\n        publicAPI.update();\n      }\n      model.bounds = input.getBounds();\n    }\n    return model.bounds;\n  };\n  publicAPI.setForceCompileOnly = v => {\n    model.forceCompileOnly = v;\n    // make sure we do NOT call modified()\n  };\n  publicAPI.setSelectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds => {\n    model.selectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds;\n    // make sure we do NOT call modified()\n    // this attribute is only used when processing a selection made with the hardware selector\n    // the mtime of the mapper doesn't need to be changed\n  };\n  publicAPI.createDefaultLookupTable = () => {\n    model.lookupTable = vtkLookupTable.newInstance();\n  };\n  publicAPI.getColorModeAsString = () => macro.enumToString(ColorMode, model.colorMode);\n  publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);\n  publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);\n  publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);\n  publicAPI.getScalarModeAsString = () => macro.enumToString(ScalarMode, model.scalarMode);\n  publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);\n  publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);\n  publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);\n  publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);\n  publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);\n  publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);\n  publicAPI.getAbstractScalars = (input, scalarMode, arrayAccessMode, arrayId, arrayName) => {\n    // make sure we have an input\n    if (!input || !model.scalarVisibility) {\n      return {\n        scalars: null,\n        cellFLag: false\n      };\n    }\n    let scalars = null;\n    let cellFlag = false;\n\n    // get and scalar data according to scalar mode\n    if (scalarMode === ScalarMode.DEFAULT) {\n      scalars = input.getPointData().getScalars();\n      if (!scalars) {\n        scalars = input.getCellData().getScalars();\n        cellFlag = true;\n      }\n    } else if (scalarMode === ScalarMode.USE_POINT_DATA) {\n      scalars = input.getPointData().getScalars();\n    } else if (scalarMode === ScalarMode.USE_CELL_DATA) {\n      scalars = input.getCellData().getScalars();\n      cellFlag = true;\n    } else if (scalarMode === ScalarMode.USE_POINT_FIELD_DATA) {\n      const pd = input.getPointData();\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = pd.getArrayByIndex(arrayId);\n      } else {\n        scalars = pd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_CELL_FIELD_DATA) {\n      const cd = input.getCellData();\n      cellFlag = true;\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = cd.getArrayByIndex(arrayId);\n      } else {\n        scalars = cd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_FIELD_DATA) {\n      const fd = input.getFieldData();\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = fd.getArrayByIndex(arrayId);\n      } else {\n        scalars = fd.getArrayByName(arrayName);\n      }\n    }\n    return {\n      scalars,\n      cellFlag\n    };\n  };\n  publicAPI.mapScalars = (input, alpha) => {\n    const scalars = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName).scalars;\n    if (!scalars) {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n      model.colorMapColors = null;\n      return;\n    }\n\n    // we want to only recompute when something has changed\n    const toString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;\n    if (model.colorBuildString === toString) return;\n    if (!model.useLookupTableScalarRange) {\n      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);\n    }\n\n    // Decide between texture color or vertex color.\n    // Cell data always uses vertex color.\n    // Only point data can use both texture and vertex coloring.\n    if (publicAPI.canUseTextureMapForColoring(input)) {\n      publicAPI.mapScalarsToTexture(scalars, alpha);\n    } else {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n      const lut = publicAPI.getLookupTable();\n      if (lut) {\n        // Ensure that the lookup table is built\n        lut.build();\n        model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);\n      }\n    }\n    model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;\n  };\n\n  //-----------------------------------------------------------------------------\n  publicAPI.scalarToTextureCoordinate = (scalarValue,\n  // Input scalar\n  rangeMin,\n  // range[0]\n  invRangeWidth) => {\n    // 1/(range[1]-range[0])\n    let texCoordS = 0.5; // Scalar value is arbitrary when NaN\n    let texCoordT = 1.0; // 1.0 in t coordinate means NaN\n    if (!isNan(scalarValue)) {\n      // 0.0 in t coordinate means not NaN.  So why am I setting it to 0.49?\n      // Because when you are mapping scalars and you have a NaN adjacent to\n      // anything else, the interpolation everywhere should be NaN.  Thus, I\n      // want the NaN color everywhere except right on the non-NaN neighbors.\n      // To simulate this, I set the t coord for the real numbers close to\n      // the threshold so that the interpolation almost immediately looks up\n      // the NaN value.\n      texCoordT = 0.49;\n      texCoordS = (scalarValue - rangeMin) * invRangeWidth;\n\n      // Some implementations apparently don't handle relatively large\n      // numbers (compared to the range [0.0, 1.0]) very well. In fact,\n      // values above 1122.0f appear to cause texture wrap-around on\n      // some systems even when edge clamping is enabled. Why 1122.0f? I\n      // don't know. For safety, we'll clamp at +/- 1000. This will\n      // result in incorrect images when the texture value should be\n      // above or below 1000, but I don't have a better solution.\n      if (texCoordS > 1000.0) {\n        texCoordS = 1000.0;\n      } else if (texCoordS < -1000.0) {\n        texCoordS = -1000.0;\n      }\n    }\n    return {\n      texCoordS,\n      texCoordT\n    };\n  };\n\n  //-----------------------------------------------------------------------------\n  publicAPI.createColorTextureCoordinates = (input, output, numScalars, numComps, component, range, tableRange, tableNumberOfColors, useLogScale) => {\n    // We have to change the range used for computing texture\n    // coordinates slightly to accommodate the special above- and\n    // below-range colors that are the first and last texels,\n    // respectively.\n    const scalarTexelWidth = (range[1] - range[0]) / tableNumberOfColors;\n    const paddedRange = [];\n    paddedRange[0] = range[0] - scalarTexelWidth;\n    paddedRange[1] = range[1] + scalarTexelWidth;\n    const invRangeWidth = 1.0 / (paddedRange[1] - paddedRange[0]);\n    const outputV = output.getData();\n    const inputV = input.getData();\n    let count = 0;\n    let outputCount = 0;\n    if (component < 0 || component >= numComps) {\n      for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {\n        let sum = 0;\n        for (let compIdx = 0; compIdx < numComps; ++compIdx) {\n          sum += inputV[count] * inputV[count];\n          count++;\n        }\n        let magnitude = Math.sqrt(sum);\n        if (useLogScale) {\n          magnitude = vtkLookupTable.applyLogScale(magnitude, tableRange, range);\n        }\n        const outputs = publicAPI.scalarToTextureCoordinate(magnitude, paddedRange[0], invRangeWidth);\n        outputV[outputCount] = outputs.texCoordS;\n        outputV[outputCount + 1] = outputs.texCoordT;\n        outputCount += 2;\n      }\n    } else {\n      count += component;\n      for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {\n        let inputValue = inputV[count];\n        if (useLogScale) {\n          inputValue = vtkLookupTable.applyLogScale(inputValue, tableRange, range);\n        }\n        const outputs = publicAPI.scalarToTextureCoordinate(inputValue, paddedRange[0], invRangeWidth);\n        outputV[outputCount] = outputs.texCoordS;\n        outputV[outputCount + 1] = outputs.texCoordT;\n        outputCount += 2;\n        count += numComps;\n      }\n    }\n  };\n  publicAPI.mapScalarsToTexture = (scalars, alpha) => {\n    const range = model.lookupTable.getRange();\n    const useLogScale = model.lookupTable.usingLogScale();\n    if (useLogScale) {\n      // convert range to log.\n      vtkLookupTable.getLogRange(range, range);\n    }\n    const origAlpha = model.lookupTable.getAlpha();\n\n    // Get rid of vertex color array.  Only texture or vertex coloring\n    // can be active at one time.  The existence of the array is the\n    // signal to use that technique.\n    model.colorMapColors = null;\n\n    // If the lookup table has changed, then recreate the color texture map.\n    // Set a new lookup table changes this->MTime.\n    if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {\n      model.lookupTable.setAlpha(alpha);\n      model.colorTextureMap = null;\n\n      // Get the texture map from the lookup table.\n      // Create a dummy ramp of scalars.\n      // In the future, we could extend vtkScalarsToColors.\n      model.lookupTable.build();\n      let numberOfColors = model.lookupTable.getNumberOfAvailableColors();\n      if (numberOfColors > 4094) {\n        numberOfColors = 4094;\n      }\n      if (numberOfColors < 64) {\n        numberOfColors = 64;\n      }\n      numberOfColors += 2;\n      const k = (range[1] - range[0]) / (numberOfColors - 2);\n      const newArray = new Float64Array(numberOfColors * 2);\n      for (let i = 0; i < numberOfColors; ++i) {\n        newArray[i] = range[0] + i * k - k / 2.0; // minus k / 2 to start at below range color\n        if (useLogScale) {\n          newArray[i] = 10.0 ** newArray[i];\n        }\n      }\n      // Dimension on NaN.\n      for (let i = 0; i < numberOfColors; ++i) {\n        newArray[i + numberOfColors] = NaN;\n      }\n      model.colorTextureMap = vtkImageData.newInstance();\n      model.colorTextureMap.setExtent(0, numberOfColors - 1, 0, 1, 0, 0);\n      const tmp = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: newArray\n      });\n      model.colorTextureMap.getPointData().setScalars(model.lookupTable.mapScalars(tmp, model.colorMode, 0));\n      model.lookupTable.setAlpha(origAlpha);\n    }\n\n    // Create new coordinates if necessary.\n    // Need to compare lookup table in case the range has changed.\n    if (!model.colorCoordinates || publicAPI.getMTime() > model.colorCoordinates.getMTime() || publicAPI.getInputData(0).getMTime() > model.colorCoordinates.getMTime() || model.lookupTable.getMTime() > model.colorCoordinates.getMTime()) {\n      // Get rid of old colors\n      model.colorCoordinates = null;\n\n      // Now create the color texture coordinates.\n      const numComps = scalars.getNumberOfComponents();\n      const num = scalars.getNumberOfTuples();\n\n      // const fArray = new FloatArray(num * 2);\n      model.colorCoordinates = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        values: new Float32Array(num * 2)\n      });\n      let scalarComponent = model.lookupTable.getVectorComponent();\n      // Although I like the feature of applying magnitude to single component\n      // scalars, it is not how the old MapScalars for vertex coloring works.\n      if (model.lookupTable.getVectorMode() === VectorMode.MAGNITUDE && scalars.getNumberOfComponents() > 1) {\n        scalarComponent = -1;\n      }\n      publicAPI.createColorTextureCoordinates(scalars, model.colorCoordinates, num, numComps, scalarComponent, range, model.lookupTable.getRange(), model.colorTextureMap.getPointData().getScalars().getNumberOfTuples() / 2 - 2, useLogScale);\n    }\n  };\n  publicAPI.getIsOpaque = () => {\n    const input = publicAPI.getInputData();\n    const gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);\n    const scalars = gasResult.scalars;\n    if (!model.scalarVisibility || scalars == null) {\n      // No scalar colors.\n      return true;\n    }\n    const lut = publicAPI.getLookupTable();\n    if (lut) {\n      // Ensure that the lookup table is built\n      lut.build();\n      return lut.areScalarsOpaque(scalars, model.colorMode, -1);\n    }\n    return true;\n  };\n  publicAPI.canUseTextureMapForColoring = input => {\n    if (!model.interpolateScalarsBeforeMapping) {\n      return false; // user doesn't want us to use texture maps at all.\n    }\n\n    // index color does not use textures\n    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {\n      return false;\n    }\n    const gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);\n    const scalars = gasResult.scalars;\n    if (!scalars) {\n      // no scalars on this dataset, we don't care if texture is used at all.\n      return false;\n    }\n    if (gasResult.cellFlag) {\n      return false; // cell data colors, don't use textures.\n    }\n    if (model.colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || model.colorMode === ColorMode.DIRECT_SCALARS) {\n      // Don't use texture is direct coloring using RGB unsigned chars is\n      // requested.\n      return false;\n    }\n    return true;\n  };\n  publicAPI.clearColorArrays = () => {\n    model.colorMapColors = null;\n    model.colorCoordinates = null;\n    model.colorTextureMap = null;\n  };\n  publicAPI.getLookupTable = () => {\n    if (!model.lookupTable) {\n      publicAPI.createDefaultLookupTable();\n    }\n    return model.lookupTable;\n  };\n  publicAPI.getMTime = () => {\n    let mt = model.mtime;\n    if (model.lookupTable !== null) {\n      const time = model.lookupTable.getMTime();\n      mt = time > mt ? time : mt;\n    }\n    return mt;\n  };\n  publicAPI.getPrimitiveCount = () => {\n    const input = publicAPI.getInputData();\n    const pcount = {\n      points: input.getPoints().getNumberOfValues() / 3,\n      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),\n      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),\n      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()\n    };\n    return pcount;\n  };\n  publicAPI.acquireInvertibleLookupTable = notImplemented('AcquireInvertibleLookupTable');\n  publicAPI.valueToColor = notImplemented('ValueToColor');\n  publicAPI.colorToValue = notImplemented('ColorToValue');\n  publicAPI.useInvertibleColorFor = notImplemented('UseInvertibleColorFor');\n  publicAPI.clearInvertibleColor = notImplemented('ClearInvertibleColor');\n  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {\n    /* eslint-disable no-bitwise */\n    if (!selector || !model.selectionWebGLIdsToVTKIds || !model.populateSelectionSettings) {\n      return;\n    }\n    const rawLowData = selector.getRawPixelBuffer(PassTypes.ID_LOW24);\n    const rawHighData = selector.getRawPixelBuffer(PassTypes.ID_HIGH24);\n    const currentPass = selector.getCurrentPass();\n    const fieldAssociation = selector.getFieldAssociation();\n    let idMap = null;\n    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      idMap = model.selectionWebGLIdsToVTKIds.points;\n    } else if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_CELLS) {\n      idMap = model.selectionWebGLIdsToVTKIds.cells;\n    }\n    if (!idMap) {\n      return;\n    }\n    pixelOffsets.forEach(pos => {\n      if (currentPass === PassTypes.ID_LOW24) {\n        let inValue = 0;\n        if (rawHighData) {\n          inValue += rawHighData[pos];\n          inValue *= 256;\n        }\n        inValue += rawLowData[pos + 2];\n        inValue *= 256;\n        inValue += rawLowData[pos + 1];\n        inValue *= 256;\n        inValue += rawLowData[pos];\n        const outValue = idMap[inValue];\n        const lowData = selector.getPixelBuffer(PassTypes.ID_LOW24);\n        lowData[pos] = outValue & 0xff;\n        lowData[pos + 1] = (outValue & 0xff00) >> 8;\n        lowData[pos + 2] = (outValue & 0xff0000) >> 16;\n      } else if (currentPass === PassTypes.ID_HIGH24 && rawHighData) {\n        let inValue = 0;\n        inValue += rawHighData[pos];\n        inValue *= 256;\n        inValue += rawLowData[pos];\n        inValue *= 256;\n        inValue += rawLowData[pos + 1];\n        inValue *= 256;\n        inValue += rawLowData[pos + 2];\n        const outValue = idMap[inValue];\n        const highData = selector.getPixelBuffer(PassTypes.ID_HIGH24);\n        highData[pos] = (outValue & 0xff000000) >> 24;\n      }\n    });\n    /* eslint-enable no-bitwise */\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  colorMapColors: null,\n  // Same as this->Colors\n\n  static: false,\n  lookupTable: null,\n  scalarVisibility: true,\n  scalarRange: [0, 1],\n  useLookupTableScalarRange: false,\n  colorMode: 0,\n  scalarMode: 0,\n  arrayAccessMode: 1,\n  // By_NAME\n\n  renderTime: 0,\n  colorByArrayName: null,\n  fieldDataTupleId: -1,\n  populateSelectionSettings: true,\n  selectionWebGLIdsToVTKIds: null,\n  interpolateScalarsBeforeMapping: false,\n  colorCoordinates: null,\n  colorTextureMap: null,\n  forceCompileOnly: 0,\n  useInvertibleColors: false,\n  invertibleScalars: null,\n  customShaderAttributes: []\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkAbstractMapper3D.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['colorCoordinates', 'colorMapColors', 'colorTextureMap', 'selectionWebGLIdsToVTKIds']);\n  macro.setGet(publicAPI, model, ['colorByArrayName', 'arrayAccessMode', 'colorMode', 'fieldDataTupleId', 'interpolateScalarsBeforeMapping', 'lookupTable', 'populateSelectionSettings', 'renderTime', 'scalarMode', 'scalarVisibility', 'static', 'useLookupTableScalarRange', 'customShaderAttributes' // point data array names that will be transferred to the VBO\n  ]);\n  macro.setGetArray(publicAPI, model, ['scalarRange'], 2);\n  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);\n\n  // Object methods\n  vtkMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkMapper$1 = {\n  newInstance,\n  extend,\n  ...staticOffsetAPI,\n  ...otherStaticMethods,\n  ...Constants\n};\nexport { vtkMapper$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkAbstractMapper3D","vtkDataArray","vtkImageData","vtkLookupTable","F","createUninitializedBounds","i","isNan","vtkScalarsToColors","CoincidentTopologyHelper","Constants","vtkDataSet","PassTypes","FieldAssociations","staticOffsetAPI","otherStaticMethods","ColorMode","ScalarMode","GetArray","VectorMode","VtkDataTypes","notImplemented","method","vtkErrorMacro","vtkMapper","publicAPI","model","classHierarchy","push","getBounds","input","getInputData","bounds","static","update","setForceCompileOnly","v","forceCompileOnly","setSelectionWebGLIdsToVTKIds","selectionWebGLIdsToVTKIds","createDefaultLookupTable","lookupTable","newInstance","getColorModeAsString","enumToString","colorMode","setColorModeToDefault","setColorMode","setColorModeToMapScalars","setColorModeToDirectScalars","getScalarModeAsString","scalarMode","setScalarModeToDefault","setScalarMode","setScalarModeToUsePointData","setScalarModeToUseCellData","setScalarModeToUsePointFieldData","setScalarModeToUseCellFieldData","setScalarModeToUseFieldData","getAbstractScalars","arrayAccessMode","arrayId","arrayName","scalarVisibility","scalars","cellFLag","cellFlag","DEFAULT","getPointData","getScalars","getCellData","USE_POINT_DATA","USE_CELL_DATA","USE_POINT_FIELD_DATA","pd","BY_ID","getArrayByIndex","getArrayByName","USE_CELL_FIELD_DATA","cd","USE_FIELD_DATA","fd","getFieldData","mapScalars","alpha","colorByArrayName","colorCoordinates","colorTextureMap","colorMapColors","toString","getMTime","colorBuildString","useLookupTableScalarRange","getLookupTable","setRange","scalarRange","canUseTextureMapForColoring","mapScalarsToTexture","lut","build","fieldDataTupleId","scalarToTextureCoordinate","scalarValue","rangeMin","invRangeWidth","texCoordS","texCoordT","createColorTextureCoordinates","output","numScalars","numComps","component","range","tableRange","tableNumberOfColors","useLogScale","scalarTexelWidth","paddedRange","outputV","getData","inputV","count","outputCount","scalarIdx","sum","compIdx","magnitude","Math","sqrt","applyLogScale","outputs","inputValue","getRange","usingLogScale","getLogRange","origAlpha","getAlpha","setAlpha","numberOfColors","getNumberOfAvailableColors","k","newArray","Float64Array","NaN","setExtent","tmp","numberOfComponents","values","setScalars","getNumberOfComponents","num","getNumberOfTuples","Float32Array","scalarComponent","getVectorComponent","getVectorMode","MAGNITUDE","getIsOpaque","gasResult","areScalarsOpaque","interpolateScalarsBeforeMapping","getIndexedLookup","getDataType","UNSIGNED_CHAR","DIRECT_SCALARS","clearColorArrays","mt","mtime","time","getPrimitiveCount","pcount","points","getPoints","getNumberOfValues","verts","getVerts","getNumberOfCells","lines","getLines","triangles","getPolys","acquireInvertibleLookupTable","valueToColor","colorToValue","useInvertibleColorFor","clearInvertibleColor","processSelectorPixelBuffers","selector","pixelOffsets","populateSelectionSettings","rawLowData","getRawPixelBuffer","ID_LOW24","rawHighData","ID_HIGH24","currentPass","getCurrentPass","fieldAssociation","getFieldAssociation","idMap","FIELD_ASSOCIATION_POINTS","FIELD_ASSOCIATION_CELLS","cells","forEach","pos","inValue","outValue","lowData","getPixelBuffer","highData","DEFAULT_VALUES","renderTime","useInvertibleColors","invertibleScalars","customShaderAttributes","extend","initialValues","arguments","length","undefined","Object","assign","get","setGet","setGetArray","implementCoincidentTopologyMethods","vtkMapper$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkAbstractMapper3D from './AbstractMapper3D.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkImageData from '../../Common/DataModel/ImageData.js';\nimport vtkLookupTable from '../../Common/Core/LookupTable.js';\nimport { F as createUninitializedBounds, i as isNan } from '../../Common/Core/Math/index.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors/Constants.js';\nimport CoincidentTopologyHelper from './Mapper/CoincidentTopologyHelper.js';\nimport Constants from './Mapper/Constants.js';\nimport vtkDataSet from '../../Common/DataModel/DataSet.js';\nimport { PassTypes } from '../OpenGL/HardwareSelector/Constants.js';\n\nconst {\n  FieldAssociations\n} = vtkDataSet;\nconst {\n  staticOffsetAPI,\n  otherStaticMethods\n} = CoincidentTopologyHelper;\nconst {\n  ColorMode,\n  ScalarMode,\n  GetArray\n} = Constants;\nconst {\n  VectorMode\n} = vtkScalarsToColors;\nconst {\n  VtkDataTypes\n} = vtkDataArray;\n\n// ----------------------------------------------------------------------------\n\nfunction notImplemented(method) {\n  return () => macro.vtkErrorMacro(`vtkMapper::${method} - NOT IMPLEMENTED`);\n}\n\n// ----------------------------------------------------------------------------\n// vtkMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMapper');\n  publicAPI.getBounds = () => {\n    const input = publicAPI.getInputData();\n    if (!input) {\n      model.bounds = createUninitializedBounds();\n    } else {\n      if (!model.static) {\n        publicAPI.update();\n      }\n      model.bounds = input.getBounds();\n    }\n    return model.bounds;\n  };\n  publicAPI.setForceCompileOnly = v => {\n    model.forceCompileOnly = v;\n    // make sure we do NOT call modified()\n  };\n\n  publicAPI.setSelectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds => {\n    model.selectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds;\n    // make sure we do NOT call modified()\n    // this attribute is only used when processing a selection made with the hardware selector\n    // the mtime of the mapper doesn't need to be changed\n  };\n\n  publicAPI.createDefaultLookupTable = () => {\n    model.lookupTable = vtkLookupTable.newInstance();\n  };\n  publicAPI.getColorModeAsString = () => macro.enumToString(ColorMode, model.colorMode);\n  publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);\n  publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);\n  publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);\n  publicAPI.getScalarModeAsString = () => macro.enumToString(ScalarMode, model.scalarMode);\n  publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);\n  publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);\n  publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);\n  publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);\n  publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);\n  publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);\n  publicAPI.getAbstractScalars = (input, scalarMode, arrayAccessMode, arrayId, arrayName) => {\n    // make sure we have an input\n    if (!input || !model.scalarVisibility) {\n      return {\n        scalars: null,\n        cellFLag: false\n      };\n    }\n    let scalars = null;\n    let cellFlag = false;\n\n    // get and scalar data according to scalar mode\n    if (scalarMode === ScalarMode.DEFAULT) {\n      scalars = input.getPointData().getScalars();\n      if (!scalars) {\n        scalars = input.getCellData().getScalars();\n        cellFlag = true;\n      }\n    } else if (scalarMode === ScalarMode.USE_POINT_DATA) {\n      scalars = input.getPointData().getScalars();\n    } else if (scalarMode === ScalarMode.USE_CELL_DATA) {\n      scalars = input.getCellData().getScalars();\n      cellFlag = true;\n    } else if (scalarMode === ScalarMode.USE_POINT_FIELD_DATA) {\n      const pd = input.getPointData();\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = pd.getArrayByIndex(arrayId);\n      } else {\n        scalars = pd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_CELL_FIELD_DATA) {\n      const cd = input.getCellData();\n      cellFlag = true;\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = cd.getArrayByIndex(arrayId);\n      } else {\n        scalars = cd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_FIELD_DATA) {\n      const fd = input.getFieldData();\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = fd.getArrayByIndex(arrayId);\n      } else {\n        scalars = fd.getArrayByName(arrayName);\n      }\n    }\n    return {\n      scalars,\n      cellFlag\n    };\n  };\n  publicAPI.mapScalars = (input, alpha) => {\n    const scalars = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName).scalars;\n    if (!scalars) {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n      model.colorMapColors = null;\n      return;\n    }\n\n    // we want to only recompute when something has changed\n    const toString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;\n    if (model.colorBuildString === toString) return;\n    if (!model.useLookupTableScalarRange) {\n      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);\n    }\n\n    // Decide between texture color or vertex color.\n    // Cell data always uses vertex color.\n    // Only point data can use both texture and vertex coloring.\n    if (publicAPI.canUseTextureMapForColoring(input)) {\n      publicAPI.mapScalarsToTexture(scalars, alpha);\n    } else {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n      const lut = publicAPI.getLookupTable();\n      if (lut) {\n        // Ensure that the lookup table is built\n        lut.build();\n        model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);\n      }\n    }\n    model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;\n  };\n\n  //-----------------------------------------------------------------------------\n  publicAPI.scalarToTextureCoordinate = (scalarValue,\n  // Input scalar\n  rangeMin,\n  // range[0]\n  invRangeWidth) => {\n    // 1/(range[1]-range[0])\n    let texCoordS = 0.5; // Scalar value is arbitrary when NaN\n    let texCoordT = 1.0; // 1.0 in t coordinate means NaN\n    if (!isNan(scalarValue)) {\n      // 0.0 in t coordinate means not NaN.  So why am I setting it to 0.49?\n      // Because when you are mapping scalars and you have a NaN adjacent to\n      // anything else, the interpolation everywhere should be NaN.  Thus, I\n      // want the NaN color everywhere except right on the non-NaN neighbors.\n      // To simulate this, I set the t coord for the real numbers close to\n      // the threshold so that the interpolation almost immediately looks up\n      // the NaN value.\n      texCoordT = 0.49;\n      texCoordS = (scalarValue - rangeMin) * invRangeWidth;\n\n      // Some implementations apparently don't handle relatively large\n      // numbers (compared to the range [0.0, 1.0]) very well. In fact,\n      // values above 1122.0f appear to cause texture wrap-around on\n      // some systems even when edge clamping is enabled. Why 1122.0f? I\n      // don't know. For safety, we'll clamp at +/- 1000. This will\n      // result in incorrect images when the texture value should be\n      // above or below 1000, but I don't have a better solution.\n      if (texCoordS > 1000.0) {\n        texCoordS = 1000.0;\n      } else if (texCoordS < -1000.0) {\n        texCoordS = -1000.0;\n      }\n    }\n    return {\n      texCoordS,\n      texCoordT\n    };\n  };\n\n  //-----------------------------------------------------------------------------\n  publicAPI.createColorTextureCoordinates = (input, output, numScalars, numComps, component, range, tableRange, tableNumberOfColors, useLogScale) => {\n    // We have to change the range used for computing texture\n    // coordinates slightly to accommodate the special above- and\n    // below-range colors that are the first and last texels,\n    // respectively.\n    const scalarTexelWidth = (range[1] - range[0]) / tableNumberOfColors;\n    const paddedRange = [];\n    paddedRange[0] = range[0] - scalarTexelWidth;\n    paddedRange[1] = range[1] + scalarTexelWidth;\n    const invRangeWidth = 1.0 / (paddedRange[1] - paddedRange[0]);\n    const outputV = output.getData();\n    const inputV = input.getData();\n    let count = 0;\n    let outputCount = 0;\n    if (component < 0 || component >= numComps) {\n      for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {\n        let sum = 0;\n        for (let compIdx = 0; compIdx < numComps; ++compIdx) {\n          sum += inputV[count] * inputV[count];\n          count++;\n        }\n        let magnitude = Math.sqrt(sum);\n        if (useLogScale) {\n          magnitude = vtkLookupTable.applyLogScale(magnitude, tableRange, range);\n        }\n        const outputs = publicAPI.scalarToTextureCoordinate(magnitude, paddedRange[0], invRangeWidth);\n        outputV[outputCount] = outputs.texCoordS;\n        outputV[outputCount + 1] = outputs.texCoordT;\n        outputCount += 2;\n      }\n    } else {\n      count += component;\n      for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {\n        let inputValue = inputV[count];\n        if (useLogScale) {\n          inputValue = vtkLookupTable.applyLogScale(inputValue, tableRange, range);\n        }\n        const outputs = publicAPI.scalarToTextureCoordinate(inputValue, paddedRange[0], invRangeWidth);\n        outputV[outputCount] = outputs.texCoordS;\n        outputV[outputCount + 1] = outputs.texCoordT;\n        outputCount += 2;\n        count += numComps;\n      }\n    }\n  };\n  publicAPI.mapScalarsToTexture = (scalars, alpha) => {\n    const range = model.lookupTable.getRange();\n    const useLogScale = model.lookupTable.usingLogScale();\n    if (useLogScale) {\n      // convert range to log.\n      vtkLookupTable.getLogRange(range, range);\n    }\n    const origAlpha = model.lookupTable.getAlpha();\n\n    // Get rid of vertex color array.  Only texture or vertex coloring\n    // can be active at one time.  The existence of the array is the\n    // signal to use that technique.\n    model.colorMapColors = null;\n\n    // If the lookup table has changed, then recreate the color texture map.\n    // Set a new lookup table changes this->MTime.\n    if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {\n      model.lookupTable.setAlpha(alpha);\n      model.colorTextureMap = null;\n\n      // Get the texture map from the lookup table.\n      // Create a dummy ramp of scalars.\n      // In the future, we could extend vtkScalarsToColors.\n      model.lookupTable.build();\n      let numberOfColors = model.lookupTable.getNumberOfAvailableColors();\n      if (numberOfColors > 4094) {\n        numberOfColors = 4094;\n      }\n      if (numberOfColors < 64) {\n        numberOfColors = 64;\n      }\n      numberOfColors += 2;\n      const k = (range[1] - range[0]) / (numberOfColors - 2);\n      const newArray = new Float64Array(numberOfColors * 2);\n      for (let i = 0; i < numberOfColors; ++i) {\n        newArray[i] = range[0] + i * k - k / 2.0; // minus k / 2 to start at below range color\n        if (useLogScale) {\n          newArray[i] = 10.0 ** newArray[i];\n        }\n      }\n      // Dimension on NaN.\n      for (let i = 0; i < numberOfColors; ++i) {\n        newArray[i + numberOfColors] = NaN;\n      }\n      model.colorTextureMap = vtkImageData.newInstance();\n      model.colorTextureMap.setExtent(0, numberOfColors - 1, 0, 1, 0, 0);\n      const tmp = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: newArray\n      });\n      model.colorTextureMap.getPointData().setScalars(model.lookupTable.mapScalars(tmp, model.colorMode, 0));\n      model.lookupTable.setAlpha(origAlpha);\n    }\n\n    // Create new coordinates if necessary.\n    // Need to compare lookup table in case the range has changed.\n    if (!model.colorCoordinates || publicAPI.getMTime() > model.colorCoordinates.getMTime() || publicAPI.getInputData(0).getMTime() > model.colorCoordinates.getMTime() || model.lookupTable.getMTime() > model.colorCoordinates.getMTime()) {\n      // Get rid of old colors\n      model.colorCoordinates = null;\n\n      // Now create the color texture coordinates.\n      const numComps = scalars.getNumberOfComponents();\n      const num = scalars.getNumberOfTuples();\n\n      // const fArray = new FloatArray(num * 2);\n      model.colorCoordinates = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        values: new Float32Array(num * 2)\n      });\n      let scalarComponent = model.lookupTable.getVectorComponent();\n      // Although I like the feature of applying magnitude to single component\n      // scalars, it is not how the old MapScalars for vertex coloring works.\n      if (model.lookupTable.getVectorMode() === VectorMode.MAGNITUDE && scalars.getNumberOfComponents() > 1) {\n        scalarComponent = -1;\n      }\n      publicAPI.createColorTextureCoordinates(scalars, model.colorCoordinates, num, numComps, scalarComponent, range, model.lookupTable.getRange(), model.colorTextureMap.getPointData().getScalars().getNumberOfTuples() / 2 - 2, useLogScale);\n    }\n  };\n  publicAPI.getIsOpaque = () => {\n    const input = publicAPI.getInputData();\n    const gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);\n    const scalars = gasResult.scalars;\n    if (!model.scalarVisibility || scalars == null) {\n      // No scalar colors.\n      return true;\n    }\n    const lut = publicAPI.getLookupTable();\n    if (lut) {\n      // Ensure that the lookup table is built\n      lut.build();\n      return lut.areScalarsOpaque(scalars, model.colorMode, -1);\n    }\n    return true;\n  };\n  publicAPI.canUseTextureMapForColoring = input => {\n    if (!model.interpolateScalarsBeforeMapping) {\n      return false; // user doesn't want us to use texture maps at all.\n    }\n\n    // index color does not use textures\n    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {\n      return false;\n    }\n    const gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);\n    const scalars = gasResult.scalars;\n    if (!scalars) {\n      // no scalars on this dataset, we don't care if texture is used at all.\n      return false;\n    }\n    if (gasResult.cellFlag) {\n      return false; // cell data colors, don't use textures.\n    }\n\n    if (model.colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || model.colorMode === ColorMode.DIRECT_SCALARS) {\n      // Don't use texture is direct coloring using RGB unsigned chars is\n      // requested.\n      return false;\n    }\n    return true;\n  };\n  publicAPI.clearColorArrays = () => {\n    model.colorMapColors = null;\n    model.colorCoordinates = null;\n    model.colorTextureMap = null;\n  };\n  publicAPI.getLookupTable = () => {\n    if (!model.lookupTable) {\n      publicAPI.createDefaultLookupTable();\n    }\n    return model.lookupTable;\n  };\n  publicAPI.getMTime = () => {\n    let mt = model.mtime;\n    if (model.lookupTable !== null) {\n      const time = model.lookupTable.getMTime();\n      mt = time > mt ? time : mt;\n    }\n    return mt;\n  };\n  publicAPI.getPrimitiveCount = () => {\n    const input = publicAPI.getInputData();\n    const pcount = {\n      points: input.getPoints().getNumberOfValues() / 3,\n      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),\n      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),\n      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()\n    };\n    return pcount;\n  };\n  publicAPI.acquireInvertibleLookupTable = notImplemented('AcquireInvertibleLookupTable');\n  publicAPI.valueToColor = notImplemented('ValueToColor');\n  publicAPI.colorToValue = notImplemented('ColorToValue');\n  publicAPI.useInvertibleColorFor = notImplemented('UseInvertibleColorFor');\n  publicAPI.clearInvertibleColor = notImplemented('ClearInvertibleColor');\n  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {\n    /* eslint-disable no-bitwise */\n    if (!selector || !model.selectionWebGLIdsToVTKIds || !model.populateSelectionSettings) {\n      return;\n    }\n    const rawLowData = selector.getRawPixelBuffer(PassTypes.ID_LOW24);\n    const rawHighData = selector.getRawPixelBuffer(PassTypes.ID_HIGH24);\n    const currentPass = selector.getCurrentPass();\n    const fieldAssociation = selector.getFieldAssociation();\n    let idMap = null;\n    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      idMap = model.selectionWebGLIdsToVTKIds.points;\n    } else if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_CELLS) {\n      idMap = model.selectionWebGLIdsToVTKIds.cells;\n    }\n    if (!idMap) {\n      return;\n    }\n    pixelOffsets.forEach(pos => {\n      if (currentPass === PassTypes.ID_LOW24) {\n        let inValue = 0;\n        if (rawHighData) {\n          inValue += rawHighData[pos];\n          inValue *= 256;\n        }\n        inValue += rawLowData[pos + 2];\n        inValue *= 256;\n        inValue += rawLowData[pos + 1];\n        inValue *= 256;\n        inValue += rawLowData[pos];\n        const outValue = idMap[inValue];\n        const lowData = selector.getPixelBuffer(PassTypes.ID_LOW24);\n        lowData[pos] = outValue & 0xff;\n        lowData[pos + 1] = (outValue & 0xff00) >> 8;\n        lowData[pos + 2] = (outValue & 0xff0000) >> 16;\n      } else if (currentPass === PassTypes.ID_HIGH24 && rawHighData) {\n        let inValue = 0;\n        inValue += rawHighData[pos];\n        inValue *= 256;\n        inValue += rawLowData[pos];\n        inValue *= 256;\n        inValue += rawLowData[pos + 1];\n        inValue *= 256;\n        inValue += rawLowData[pos + 2];\n        const outValue = idMap[inValue];\n        const highData = selector.getPixelBuffer(PassTypes.ID_HIGH24);\n        highData[pos] = (outValue & 0xff000000) >> 24;\n      }\n    });\n    /* eslint-enable no-bitwise */\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  colorMapColors: null,\n  // Same as this->Colors\n\n  static: false,\n  lookupTable: null,\n  scalarVisibility: true,\n  scalarRange: [0, 1],\n  useLookupTableScalarRange: false,\n  colorMode: 0,\n  scalarMode: 0,\n  arrayAccessMode: 1,\n  // By_NAME\n\n  renderTime: 0,\n  colorByArrayName: null,\n  fieldDataTupleId: -1,\n  populateSelectionSettings: true,\n  selectionWebGLIdsToVTKIds: null,\n  interpolateScalarsBeforeMapping: false,\n  colorCoordinates: null,\n  colorTextureMap: null,\n  forceCompileOnly: 0,\n  useInvertibleColors: false,\n  invertibleScalars: null,\n  customShaderAttributes: []\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkAbstractMapper3D.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['colorCoordinates', 'colorMapColors', 'colorTextureMap', 'selectionWebGLIdsToVTKIds']);\n  macro.setGet(publicAPI, model, ['colorByArrayName', 'arrayAccessMode', 'colorMode', 'fieldDataTupleId', 'interpolateScalarsBeforeMapping', 'lookupTable', 'populateSelectionSettings', 'renderTime', 'scalarMode', 'scalarVisibility', 'static', 'useLookupTableScalarRange', 'customShaderAttributes' // point data array names that will be transferred to the VBO\n  ]);\n\n  macro.setGetArray(publicAPI, model, ['scalarRange'], 2);\n  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);\n\n  // Object methods\n  vtkMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkMapper$1 = {\n  newInstance,\n  extend,\n  ...staticOffsetAPI,\n  ...otherStaticMethods,\n  ...Constants\n};\n\nexport { vtkMapper$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}