"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fillOutsideRectangle = exports.fillInsideRectangle = void 0;
const core_1 = require("@cornerstonejs/core");
const boundingBox_1 = require("../../../utilities/boundingBox");
const utilities_1 = require("../../../utilities");
const triggerSegmentationEvents_1 = require("../../../stateManagement/segmentation/triggerSegmentationEvents");
const getStrategyData_1 = require("./utils/getStrategyData");
const isAxisAlignedRectangle_1 = require("../../../utilities/rectangleROITool/isAxisAlignedRectangle");
const { transformWorldToIndex } = core_1.utilities;
function fillRectangle(enabledElement, operationData, inside = true) {
    const { points, segmentsLocked, segmentIndex, segmentationId } = operationData;
    const { viewport } = enabledElement;
    const strategyData = (0, getStrategyData_1.getStrategyData)({
        operationData,
        viewport: enabledElement.viewport,
    });
    if (!strategyData) {
        console.warn('No data found for fillRectangle');
        return;
    }
    const { segmentationImageData, segmentationScalarData } = strategyData;
    let rectangleCornersIJK = points.map((world) => {
        return transformWorldToIndex(segmentationImageData, world);
    });
    rectangleCornersIJK = rectangleCornersIJK.map((point) => {
        return point.map((coord) => {
            return Math.round(coord);
        });
    });
    const boundsIJK = (0, boundingBox_1.getBoundingBoxAroundShapeIJK)(rectangleCornersIJK, segmentationImageData.getDimensions());
    const isStackViewport = viewport instanceof core_1.StackViewport;
    const isAligned = isStackViewport || (0, isAxisAlignedRectangle_1.isAxisAlignedRectangle)(rectangleCornersIJK);
    const direction = segmentationImageData.getDirection();
    const spacing = segmentationImageData.getSpacing();
    const { viewPlaneNormal } = viewport.getCamera();
    const EPS = core_1.utilities.getSpacingInNormalDirection({
        direction,
        spacing,
    }, viewPlaneNormal);
    const pointsBoundsLPS = (0, boundingBox_1.getBoundingBoxAroundShapeWorld)(points);
    let [[xMin, xMax], [yMin, yMax], [zMin, zMax]] = pointsBoundsLPS;
    xMin -= EPS;
    xMax += EPS;
    yMin -= EPS;
    yMax += EPS;
    zMin -= EPS;
    zMax += EPS;
    const pointInShapeFn = isAligned
        ? () => true
        : (pointLPS) => {
            const [x, y, z] = pointLPS;
            const xInside = x >= xMin && x <= xMax;
            const yInside = y >= yMin && y <= yMax;
            const zInside = z >= zMin && z <= zMax;
            return xInside && yInside && zInside;
        };
    const callback = ({ value, index }) => {
        if (segmentsLocked.includes(value)) {
            return;
        }
        segmentationScalarData[index] = segmentIndex;
    };
    (0, utilities_1.pointInShapeCallback)(segmentationImageData, pointInShapeFn, callback, boundsIJK);
    (0, triggerSegmentationEvents_1.triggerSegmentationDataModified)(segmentationId);
}
function fillInsideRectangle(enabledElement, operationData) {
    fillRectangle(enabledElement, operationData, true);
}
exports.fillInsideRectangle = fillInsideRectangle;
function fillOutsideRectangle(enabledElement, operationData) {
    fillRectangle(enabledElement, operationData, false);
}
exports.fillOutsideRectangle = fillOutsideRectangle;
//# sourceMappingURL=fillRectangle.js.map