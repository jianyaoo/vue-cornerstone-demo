{"ast":null,"code":"import { n as newInstance$1, c as macro } from '../../macros2.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// import { mat4, vec3 }     from 'gl-matrix';\nconst {\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLPixelSpaceCallbackMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model) {\n  model.classHierarchy.push('vtkOpenGLPixelSpaceCallbackMapper');\n  publicAPI.opaquePass = (prepass, renderPass) => {\n    model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n    model._openGLRenderWindow = model._openGLRenderer.getParent();\n    const aspectRatio = model._openGLRenderer.getAspectRatio();\n    const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;\n    const tsize = model._openGLRenderer.getTiledSizeAndOrigin();\n    let texels = null;\n    if (model.renderable.getUseZValues()) {\n      const zbt = renderPass.getZBufferTexture();\n      const width = Math.floor(zbt.getWidth());\n      const height = Math.floor(zbt.getHeight());\n      const gl = model._openGLRenderWindow.getContext();\n      zbt.bind();\n\n      // Here we need to use vtkFramebuffer to save current settings (bindings/buffers)\n      const fb = renderPass.getFramebuffer();\n      if (!fb) {\n        vtkDebugMacro('No framebuffer to save/restore');\n      } else {\n        // save framebuffer settings\n        fb.saveCurrentBindingsAndBuffers();\n      }\n      const framebuffer = gl.createFramebuffer();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, zbt.getHandle(), 0);\n      if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {\n        texels = new Uint8Array(width * height * 4);\n        gl.viewport(0, 0, width, height);\n        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, texels);\n      }\n\n      // Now we need to restore framebuffer bindings/buffers\n      if (fb) {\n        fb.restorePreviousBindingsAndBuffers();\n      }\n      gl.deleteFramebuffer(framebuffer);\n    }\n    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);\n  };\n  publicAPI.queryPass = (prepass, renderPass) => {\n    if (prepass) {\n      if (model.renderable.getUseZValues()) {\n        renderPass.requestDepth();\n      }\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n\n  // Object methods\n  vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLPixelSpaceCallbackMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPixelSpaceCallbackMapper = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkPixelSpaceCallbackMapper', newInstance);\nexport { vtkPixelSpaceCallbackMapper as default, extend, newInstance };","map":{"version":3,"names":["n","newInstance$1","c","macro","vtkViewNode","registerOverride","vtkDebugMacro","vtkOpenGLPixelSpaceCallbackMapper","publicAPI","model","classHierarchy","push","opaquePass","prepass","renderPass","_openGLRenderer","getFirstAncestorOfType","_openGLRenderWindow","getParent","aspectRatio","getAspectRatio","camera","getRenderable","getActiveCamera","tsize","getTiledSizeAndOrigin","texels","renderable","getUseZValues","zbt","getZBufferTexture","width","Math","floor","getWidth","height","getHeight","gl","getContext","bind","fb","getFramebuffer","saveCurrentBindingsAndBuffers","framebuffer","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","TEXTURE_2D","getHandle","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","Uint8Array","viewport","readPixels","RGBA","UNSIGNED_BYTE","restorePreviousBindingsAndBuffers","deleteFramebuffer","invokeCallback","getInputData","queryPass","requestDepth","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","newInstance","vtkPixelSpaceCallbackMapper","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/OpenGL/PixelSpaceCallbackMapper.js"],"sourcesContent":["import { n as newInstance$1, c as macro } from '../../macros2.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// import { mat4, vec3 }     from 'gl-matrix';\nconst {\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLPixelSpaceCallbackMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model) {\n  model.classHierarchy.push('vtkOpenGLPixelSpaceCallbackMapper');\n  publicAPI.opaquePass = (prepass, renderPass) => {\n    model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n    model._openGLRenderWindow = model._openGLRenderer.getParent();\n    const aspectRatio = model._openGLRenderer.getAspectRatio();\n    const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;\n    const tsize = model._openGLRenderer.getTiledSizeAndOrigin();\n    let texels = null;\n    if (model.renderable.getUseZValues()) {\n      const zbt = renderPass.getZBufferTexture();\n      const width = Math.floor(zbt.getWidth());\n      const height = Math.floor(zbt.getHeight());\n      const gl = model._openGLRenderWindow.getContext();\n      zbt.bind();\n\n      // Here we need to use vtkFramebuffer to save current settings (bindings/buffers)\n      const fb = renderPass.getFramebuffer();\n      if (!fb) {\n        vtkDebugMacro('No framebuffer to save/restore');\n      } else {\n        // save framebuffer settings\n        fb.saveCurrentBindingsAndBuffers();\n      }\n      const framebuffer = gl.createFramebuffer();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, zbt.getHandle(), 0);\n      if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {\n        texels = new Uint8Array(width * height * 4);\n        gl.viewport(0, 0, width, height);\n        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, texels);\n      }\n\n      // Now we need to restore framebuffer bindings/buffers\n      if (fb) {\n        fb.restorePreviousBindingsAndBuffers();\n      }\n      gl.deleteFramebuffer(framebuffer);\n    }\n    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);\n  };\n  publicAPI.queryPass = (prepass, renderPass) => {\n    if (prepass) {\n      if (model.renderable.getUseZValues()) {\n        renderPass.requestDepth();\n      }\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n\n  // Object methods\n  vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLPixelSpaceCallbackMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPixelSpaceCallbackMapper = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkPixelSpaceCallbackMapper', newInstance);\n\nexport { vtkPixelSpaceCallbackMapper as default, extend, newInstance };\n"],"mappings":"AAAA,SAASA,CAAC,IAAIC,aAAa,EAAEC,CAAC,IAAIC,KAAK,QAAQ,kBAAkB;AACjE,OAAOC,WAAW,MAAM,2BAA2B;AACnD,SAASC,gBAAgB,QAAQ,sBAAsB;;AAEvD;AACA,MAAM;EACJC;AACF,CAAC,GAAGH,KAAK;;AAET;AACA;AACA;;AAEA,SAASI,iCAAiCA,CAACC,SAAS,EAAEC,KAAK,EAAE;EAC3DA,KAAK,CAACC,cAAc,CAACC,IAAI,CAAC,mCAAmC,CAAC;EAC9DH,SAAS,CAACI,UAAU,GAAG,CAACC,OAAO,EAAEC,UAAU,KAAK;IAC9CL,KAAK,CAACM,eAAe,GAAGP,SAAS,CAACQ,sBAAsB,CAAC,mBAAmB,CAAC;IAC7EP,KAAK,CAACQ,mBAAmB,GAAGR,KAAK,CAACM,eAAe,CAACG,SAAS,CAAC,CAAC;IAC7D,MAAMC,WAAW,GAAGV,KAAK,CAACM,eAAe,CAACK,cAAc,CAAC,CAAC;IAC1D,MAAMC,MAAM,GAAGZ,KAAK,CAACM,eAAe,GAAGN,KAAK,CAACM,eAAe,CAACO,aAAa,CAAC,CAAC,CAACC,eAAe,CAAC,CAAC,GAAG,IAAI;IACrG,MAAMC,KAAK,GAAGf,KAAK,CAACM,eAAe,CAACU,qBAAqB,CAAC,CAAC;IAC3D,IAAIC,MAAM,GAAG,IAAI;IACjB,IAAIjB,KAAK,CAACkB,UAAU,CAACC,aAAa,CAAC,CAAC,EAAE;MACpC,MAAMC,GAAG,GAAGf,UAAU,CAACgB,iBAAiB,CAAC,CAAC;MAC1C,MAAMC,KAAK,GAAGC,IAAI,CAACC,KAAK,CAACJ,GAAG,CAACK,QAAQ,CAAC,CAAC,CAAC;MACxC,MAAMC,MAAM,GAAGH,IAAI,CAACC,KAAK,CAACJ,GAAG,CAACO,SAAS,CAAC,CAAC,CAAC;MAC1C,MAAMC,EAAE,GAAG5B,KAAK,CAACQ,mBAAmB,CAACqB,UAAU,CAAC,CAAC;MACjDT,GAAG,CAACU,IAAI,CAAC,CAAC;;MAEV;MACA,MAAMC,EAAE,GAAG1B,UAAU,CAAC2B,cAAc,CAAC,CAAC;MACtC,IAAI,CAACD,EAAE,EAAE;QACPlC,aAAa,CAAC,gCAAgC,CAAC;MACjD,CAAC,MAAM;QACL;QACAkC,EAAE,CAACE,6BAA6B,CAAC,CAAC;MACpC;MACA,MAAMC,WAAW,GAAGN,EAAE,CAACO,iBAAiB,CAAC,CAAC;MAC1CP,EAAE,CAACQ,eAAe,CAACR,EAAE,CAACS,WAAW,EAAEH,WAAW,CAAC;MAC/CN,EAAE,CAACU,oBAAoB,CAACV,EAAE,CAACS,WAAW,EAAET,EAAE,CAACW,iBAAiB,EAAEX,EAAE,CAACY,UAAU,EAAEpB,GAAG,CAACqB,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;MAChG,IAAIb,EAAE,CAACc,sBAAsB,CAACd,EAAE,CAACS,WAAW,CAAC,KAAKT,EAAE,CAACe,oBAAoB,EAAE;QACzE1B,MAAM,GAAG,IAAI2B,UAAU,CAACtB,KAAK,GAAGI,MAAM,GAAG,CAAC,CAAC;QAC3CE,EAAE,CAACiB,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEvB,KAAK,EAAEI,MAAM,CAAC;QAChCE,EAAE,CAACkB,UAAU,CAAC,CAAC,EAAE,CAAC,EAAExB,KAAK,EAAEI,MAAM,EAAEE,EAAE,CAACmB,IAAI,EAAEnB,EAAE,CAACoB,aAAa,EAAE/B,MAAM,CAAC;MACvE;;MAEA;MACA,IAAIc,EAAE,EAAE;QACNA,EAAE,CAACkB,iCAAiC,CAAC,CAAC;MACxC;MACArB,EAAE,CAACsB,iBAAiB,CAAChB,WAAW,CAAC;IACnC;IACAlC,KAAK,CAACkB,UAAU,CAACiC,cAAc,CAACnD,KAAK,CAACkB,UAAU,CAACkC,YAAY,CAAC,CAAC,EAAExC,MAAM,EAAEF,WAAW,EAAEK,KAAK,EAAEE,MAAM,CAAC;EACtG,CAAC;EACDlB,SAAS,CAACsD,SAAS,GAAG,CAACjD,OAAO,EAAEC,UAAU,KAAK;IAC7C,IAAID,OAAO,EAAE;MACX,IAAIJ,KAAK,CAACkB,UAAU,CAACC,aAAa,CAAC,CAAC,EAAE;QACpCd,UAAU,CAACiD,YAAY,CAAC,CAAC;MAC3B;IACF;EACF,CAAC;AACH;;AAEA;AACA;AACA;;AAEA,MAAMC,cAAc,GAAG,CAAC,CAAC;;AAEzB;;AAEA,SAASC,MAAMA,CAACzD,SAAS,EAAEC,KAAK,EAAE;EAChC,IAAIyD,aAAa,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;EAC1FG,MAAM,CAACC,MAAM,CAAC9D,KAAK,EAAEuD,cAAc,EAAEE,aAAa,CAAC;;EAEnD;EACA9D,WAAW,CAAC6D,MAAM,CAACzD,SAAS,EAAEC,KAAK,EAAEyD,aAAa,CAAC;;EAEnD;EACA3D,iCAAiC,CAACC,SAAS,EAAEC,KAAK,CAAC;AACrD;;AAEA;;AAEA,MAAM+D,WAAW,GAAGvE,aAAa,CAACgE,MAAM,EAAE,mCAAmC,CAAC;;AAE9E;;AAEA,IAAIQ,2BAA2B,GAAG;EAChCD,WAAW;EACXP;AACF,CAAC;;AAED;AACA5D,gBAAgB,CAAC,6BAA6B,EAAEmE,WAAW,CAAC;AAE5D,SAASC,2BAA2B,IAAIC,OAAO,EAAET,MAAM,EAAEO,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}