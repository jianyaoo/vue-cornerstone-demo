{"ast":null,"code":"import { m as macro } from '../../macros2.js';\nimport vtkCell from './Cell.js';\nimport { d as dot, j as cross, l as normalize, m as multiplyAccumulate, e as distance2BetweenPoints, o as determinant2x2 } from '../Core/Math/index.js';\nimport vtkLine from './Line.js';\nimport vtkPlane from './Plane.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction computeNormalDirection(v1, v2, v3, n) {\n  // order is important!!! maintain consistency with triangle vertex order\n  const ax = v3[0] - v2[0];\n  const ay = v3[1] - v2[1];\n  const az = v3[2] - v2[2];\n  const bx = v1[0] - v2[0];\n  const by = v1[1] - v2[1];\n  const bz = v1[2] - v2[2];\n  n[0] = ay * bz - az * by;\n  n[1] = az * bx - ax * bz;\n  n[2] = ax * by - ay * bx;\n}\nfunction computeNormal(v1, v2, v3, n) {\n  computeNormalDirection(v1, v2, v3, n);\n  const length = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);\n  if (length !== 0.0) {\n    n[0] /= length;\n    n[1] /= length;\n    n[2] /= length;\n  }\n}\nfunction intersectWithTriangle(p1, q1, r1, p2, q2, r2) {\n  let tolerance = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1e-6;\n  let coplanar = false;\n  const pt1 = [];\n  const pt2 = [];\n  const surfaceId = [];\n  const n1 = [];\n  const n2 = [];\n\n  // Compute supporting plane normals.\n  computeNormal(p1, q1, r1, n1);\n  computeNormal(p2, q2, r2, n2);\n  const s1 = -dot(n1, p1);\n  const s2 = -dot(n2, p2);\n\n  // Compute signed distances of points p1, q1, r1 from supporting\n  // plane of second triangle.\n  const dist1 = [dot(n2, p1) + s2, dot(n2, q1) + s2, dot(n2, r1) + s2];\n\n  // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n  if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 1!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n  // Do the same for p2, q2, r2 and supporting plane of first\n  // triangle.\n  const dist2 = [dot(n1, p2) + s1, dot(n1, q2) + s1, dot(n1, r2) + s1];\n\n  // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n  if (dist2[0] * dist2[1] > tolerance && dist2[0] * dist2[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 2!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n  // Check for coplanarity of the supporting planes.\n  if (Math.abs(n1[0] - n2[0]) < 1e-9 && Math.abs(n1[1] - n2[1]) < 1e-9 && Math.abs(n1[2] - n2[2]) < 1e-9 && Math.abs(s1 - s2) < 1e-9) {\n    coplanar = true;\n    // vtkDebugMacro(<<\"Coplanar!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n\n  // There are more efficient ways to find the intersection line (if\n  // it exists), but this is clear enough.\n  const pts1 = [p1, q1, r1];\n  const pts2 = [p2, q2, r2];\n\n  // Find line of intersection (L = p + t*v) between two planes.\n  const n1n2 = dot(n1, n2);\n  const a = (s1 - s2 * n1n2) / (n1n2 * n1n2 - 1.0);\n  const b = (s2 - s1 * n1n2) / (n1n2 * n1n2 - 1.0);\n  const p = [a * n1[0] + b * n2[0], a * n1[1] + b * n2[1], a * n1[2] + b * n2[2]];\n  const v = cross(n1, n2, []);\n  normalize(v);\n  let index1 = 0;\n  let index2 = 0;\n  const t1 = [];\n  const t2 = [];\n  let ts1 = 50;\n  let ts2 = 50;\n  for (let i = 0; i < 3; i++) {\n    const id1 = i;\n    const id2 = (i + 1) % 3;\n\n    // Find t coordinate on line of intersection between two planes.\n    const val1 = vtkPlane.intersectWithLine(pts1[id1], pts1[id2], p2, n2);\n    if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {\n      if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {\n        ts1 = index1;\n      }\n      t1[index1++] = dot(val1.x, v) - dot(p, v);\n    }\n    const val2 = vtkPlane.intersectWithLine(pts2[id1], pts2[id2], p1, n1);\n    if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {\n      if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {\n        ts2 = index2;\n      }\n      t2[index2++] = dot(val2.x, v) - dot(p, v);\n    }\n  }\n\n  // If the value of the index is greater than 2, the intersecting point\n  // actually is intersected by all three edges. In this case, set the two\n  // edges to the two edges where the intersecting point is not the end point\n  if (index1 > 2) {\n    index1--;\n    // swap\n    const t12 = t1[2];\n    t1[2] = t1[ts1];\n    t1[ts1] = t12;\n  }\n  if (index2 > 2) {\n    index2--;\n    const t22 = t2[2];\n    t2[2] = t2[ts2];\n    t2[ts2] = t22;\n  }\n  // Check if only one edge or all edges intersect the supporting\n  // planes intersection.\n  if (index1 !== 2 || index2 !== 2) {\n    // vtkDebugMacro(<<\"Only one edge intersecting!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n\n  // Check for NaNs\n  if (Number.isNaN(t1[0]) || Number.isNaN(t1[1]) || Number.isNaN(t2[0]) || Number.isNaN(t2[1])) {\n    // vtkWarningMacro(<<\"NaNs!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n  if (t1[0] > t1[1]) {\n    // swap\n    const t11 = t1[1];\n    t1[1] = t1[0];\n    t1[0] = t11;\n  }\n  if (t2[0] > t2[1]) {\n    // swap\n    const t21 = t2[1];\n    t2[1] = t2[0];\n    t2[0] = t21;\n  }\n  // Handle the different interval configuration cases.\n  let tt1;\n  let tt2;\n  if (t1[1] < t2[0] || t2[1] < t1[0]) {\n    // vtkDebugMacro(<<\"No Overlap!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    }; // No overlap\n  }\n  if (t1[0] < t2[0]) {\n    if (t1[1] < t2[1]) {\n      // First point on surface 2, second point on surface 1\n      surfaceId[0] = 2;\n      surfaceId[1] = 1;\n      tt1 = t2[0];\n      tt2 = t1[1];\n    } else {\n      // Both points belong to lines on surface 2\n      surfaceId[0] = 2;\n      surfaceId[1] = 2;\n      tt1 = t2[0];\n      tt2 = t2[1];\n    }\n  } // t1[0] >= t2[0]\n  else if (t1[1] < t2[1]) {\n    // Both points belong to lines on surface 1\n    surfaceId[0] = 1;\n    surfaceId[1] = 1;\n    tt1 = t1[0];\n    tt2 = t1[1];\n  } else {\n    // First point on surface 1, second point on surface 2\n    surfaceId[0] = 1;\n    surfaceId[1] = 2;\n    tt1 = t1[0];\n    tt2 = t2[1];\n  }\n\n  // Create actual intersection points.\n  multiplyAccumulate(p, v, tt1, pt1);\n  multiplyAccumulate(p, v, tt2, pt2);\n  return {\n    intersect: true,\n    coplanar,\n    pt1,\n    pt2,\n    surfaceId\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  computeNormalDirection,\n  computeNormal,\n  intersectWithTriangle\n};\n\n// ----------------------------------------------------------------------------\n// vtkTriangle methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTriangle(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkTriangle');\n  publicAPI.getCellDimension = () => 2;\n  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {\n    const outObj = {\n      subId: 0,\n      t: Number.MAX_VALUE,\n      intersect: 0,\n      betweenPoints: false\n    };\n    pcoords[2] = 0.0;\n    const closestPoint = [];\n    const tol2 = tol * tol;\n\n    // Get normal for triangle\n    const pt1 = [];\n    const pt2 = [];\n    const pt3 = [];\n    model.points.getPoint(0, pt1);\n    model.points.getPoint(1, pt2);\n    model.points.getPoint(2, pt3);\n    const n = [];\n    const weights = [];\n    computeNormal(pt1, pt2, pt3, n);\n    if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {\n      // Intersect plane of triangle with line\n      const plane = vtkPlane.intersectWithLine(p1, p2, pt1, n);\n      outObj.betweenPoints = plane.betweenPoints;\n      outObj.t = plane.t;\n      x[0] = plane.x[0];\n      x[1] = plane.x[1];\n      x[2] = plane.x[2];\n      if (!plane.intersection) {\n        pcoords[0] = 0.0;\n        pcoords[1] = 0.0;\n        outObj.intersect = 0;\n        return outObj;\n      }\n\n      // Evaluate position\n      const inside = publicAPI.evaluatePosition(x, closestPoint, pcoords, weights);\n      if (inside.evaluation >= 0) {\n        if (inside.dist2 <= tol2) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n        outObj.intersect = inside.evaluation;\n        return outObj;\n      }\n    }\n\n    // Normals are null, so the triangle is degenerated and\n    // we still need to check intersection between line and\n    // the longest edge.\n    const dist2Pt1Pt2 = distance2BetweenPoints(pt1, pt2);\n    const dist2Pt2Pt3 = distance2BetweenPoints(pt2, pt3);\n    const dist2Pt3Pt1 = distance2BetweenPoints(pt3, pt1);\n    if (!model.line) {\n      model.line = vtkLine.newInstance();\n    }\n    if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {\n      model.line.getPoints().setPoint(0, pt1);\n      model.line.getPoints().setPoint(1, pt2);\n    } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {\n      model.line.getPoints().setPoint(0, pt2);\n      model.line.getPoints().setPoint(1, pt3);\n    } else {\n      model.line.getPoints().setPoint(0, pt3);\n      model.line.getPoints().setPoint(1, pt1);\n    }\n    const intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);\n    outObj.betweenPoints = intersectLine.betweenPoints;\n    outObj.t = intersectLine.t;\n    if (intersectLine.intersect) {\n      const pt3Pt1 = [];\n      const pt3Pt2 = [];\n      const pt3X = [];\n      // Compute r and s manually, using dot and norm.\n      for (let i = 0; i < 3; i++) {\n        pt3Pt1[i] = pt1[i] - pt3[i];\n        pt3Pt2[i] = pt2[i] - pt3[i];\n        pt3X[i] = x[i] - pt3[i];\n      }\n      pcoords[0] = dot(pt3X, pt3Pt1) / dist2Pt3Pt1;\n      pcoords[1] = dot(pt3X, pt3Pt2) / dist2Pt2Pt3;\n      outObj.intersect = 1;\n      return outObj;\n    }\n    pcoords[0] = 0.0;\n    pcoords[1] = 0.0;\n    outObj.intersect = 0;\n    return outObj;\n  };\n  publicAPI.evaluatePosition = (x, closestPoint, pcoords, weights) => {\n    // will return obj\n    const outObj = {\n      subId: 0,\n      dist2: 0,\n      evaluation: -1\n    };\n    let i;\n    let j;\n    const pt1 = [];\n    const pt2 = [];\n    const pt3 = [];\n    const n = [];\n    let fabsn;\n    const rhs = [];\n    const c1 = [];\n    const c2 = [];\n    let det = 0;\n    let idx = 0;\n    const indices = [];\n    let dist2Point;\n    let dist2Line1;\n    let dist2Line2;\n    let closest = [];\n    const closestPoint1 = [];\n    const closestPoint2 = [];\n    const cp = [];\n    outObj.subId = 0;\n    pcoords[2] = 0.0;\n\n    // Get normal for triangle, only the normal direction is needed, i.e. the\n    // normal need not be normalized (unit length)\n    //\n    model.points.getPoint(1, pt1);\n    model.points.getPoint(2, pt2);\n    model.points.getPoint(0, pt3);\n    computeNormalDirection(pt1, pt2, pt3, n);\n\n    // Project point to plane\n    vtkPlane.generalizedProjectPoint(x, pt1, n, cp);\n\n    // Construct matrices.  Since we have over determined system, need to find\n    // which 2 out of 3 equations to use to develop equations. (Any 2 should\n    // work since we've projected point to plane.)\n    let maxComponent = 0.0;\n    for (i = 0; i < 3; i++) {\n      // trying to avoid an expensive call to fabs()\n      if (n[i] < 0) {\n        fabsn = -n[i];\n      } else {\n        fabsn = n[i];\n      }\n      if (fabsn > maxComponent) {\n        maxComponent = fabsn;\n        idx = i;\n      }\n    }\n    for (j = 0, i = 0; i < 3; i++) {\n      if (i !== idx) {\n        indices[j++] = i;\n      }\n    }\n    for (i = 0; i < 2; i++) {\n      rhs[i] = cp[indices[i]] - pt3[indices[i]];\n      c1[i] = pt1[indices[i]] - pt3[indices[i]];\n      c2[i] = pt2[indices[i]] - pt3[indices[i]];\n    }\n    det = determinant2x2(c1, c2);\n    if (det === 0.0) {\n      pcoords[0] = 0.0;\n      pcoords[1] = 0.0;\n      outObj.evaluation = -1;\n      return outObj;\n    }\n    pcoords[0] = determinant2x2(rhs, c2) / det;\n    pcoords[1] = determinant2x2(c1, rhs) / det;\n\n    // Okay, now find closest point to element\n    weights[0] = 1 - (pcoords[0] + pcoords[1]);\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n    if (weights[0] >= 0.0 && weights[0] <= 1.0 && weights[1] >= 0.0 && weights[1] <= 1.0 && weights[2] >= 0.0 && weights[2] <= 1.0) {\n      // projection distance\n      if (closestPoint) {\n        outObj.dist2 = distance2BetweenPoints(cp, x);\n        closestPoint[0] = cp[0];\n        closestPoint[1] = cp[1];\n        closestPoint[2] = cp[2];\n      }\n      outObj.evaluation = 1;\n    } else {\n      let t;\n      if (closestPoint) {\n        if (weights[1] < 0.0 && weights[2] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt3);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt3, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt3;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[2] < 0.0 && weights[0] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt1);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt1;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[1] < 0.0 && weights[0] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt2);\n          dist2Line1 = vtkLine.distanceToLine(x, pt2, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt2;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[0] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(x, pt1, pt2, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        } else if (weights[1] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(x, pt2, pt3, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        } else if (weights[2] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(x, pt1, pt3, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        }\n      }\n      outObj.evaluation = 0;\n    }\n    return outObj;\n  };\n  publicAPI.evaluateLocation = (pcoords, x, weights) => {\n    const p0 = [];\n    const p1 = [];\n    const p2 = [];\n    model.points.getPoint(0, p0);\n    model.points.getPoint(1, p1);\n    model.points.getPoint(2, p2);\n    const u3 = 1.0 - pcoords[0] - pcoords[1];\n    for (let i = 0; i < 3; i++) {\n      x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];\n    }\n    weights[0] = u3;\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n  };\n  publicAPI.getParametricDistance = pcoords => {\n    let pDist;\n    let pDistMax = 0.0;\n    const pc = [];\n    pc[0] = pcoords[0];\n    pc[1] = pcoords[1];\n    pc[2] = 1.0 - pcoords[0] - pcoords[1];\n    for (let i = 0; i < 3; i++) {\n      if (pc[i] < 0.0) {\n        pDist = -pc[i];\n      } else if (pc[i] > 1.0) {\n        pDist = pc[i] - 1.0;\n      } else {\n        // inside the cell in the parametric direction\n        pDist = 0.0;\n      }\n      if (pDist > pDistMax) {\n        pDistMax = pDist;\n      }\n    }\n    return pDistMax;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  vtkTriangle(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkTriangle');\n\n// ----------------------------------------------------------------------------\n\nvar vtkTriangle$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\nexport { STATIC, vtkTriangle$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkCell","d","dot","j","cross","l","normalize","multiplyAccumulate","e","distance2BetweenPoints","o","determinant2x2","vtkLine","vtkPlane","computeNormalDirection","v1","v2","v3","n","ax","ay","az","bx","by","bz","computeNormal","length","Math","sqrt","intersectWithTriangle","p1","q1","r1","p2","q2","r2","tolerance","arguments","undefined","coplanar","pt1","pt2","surfaceId","n1","n2","s1","s2","dist1","intersect","dist2","abs","pts1","pts2","n1n2","a","b","p","v","index1","index2","t1","t2","ts1","ts2","i","id1","id2","val1","intersectWithLine","intersection","t","x","val2","t12","t22","Number","isNaN","t11","t21","tt1","tt2","STATIC","vtkTriangle","publicAPI","model","classHierarchy","push","getCellDimension","tol","pcoords","outObj","subId","MAX_VALUE","betweenPoints","closestPoint","tol2","pt3","points","getPoint","weights","plane","inside","evaluatePosition","evaluation","dist2Pt1Pt2","dist2Pt2Pt3","dist2Pt3Pt1","line","newInstance","getPoints","setPoint","intersectLine","pt3Pt1","pt3Pt2","pt3X","fabsn","rhs","c1","c2","det","idx","indices","dist2Point","dist2Line1","dist2Line2","closest","closestPoint1","closestPoint2","cp","generalizedProjectPoint","maxComponent","distanceToLine","lineDistance","distance","evaluateLocation","p0","u3","getParametricDistance","pDist","pDistMax","pc","DEFAULT_VALUES","extend","initialValues","Object","assign","vtkTriangle$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Common/DataModel/Triangle.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkCell from './Cell.js';\nimport { d as dot, j as cross, l as normalize, m as multiplyAccumulate, e as distance2BetweenPoints, o as determinant2x2 } from '../Core/Math/index.js';\nimport vtkLine from './Line.js';\nimport vtkPlane from './Plane.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction computeNormalDirection(v1, v2, v3, n) {\n  // order is important!!! maintain consistency with triangle vertex order\n  const ax = v3[0] - v2[0];\n  const ay = v3[1] - v2[1];\n  const az = v3[2] - v2[2];\n  const bx = v1[0] - v2[0];\n  const by = v1[1] - v2[1];\n  const bz = v1[2] - v2[2];\n  n[0] = ay * bz - az * by;\n  n[1] = az * bx - ax * bz;\n  n[2] = ax * by - ay * bx;\n}\nfunction computeNormal(v1, v2, v3, n) {\n  computeNormalDirection(v1, v2, v3, n);\n  const length = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);\n  if (length !== 0.0) {\n    n[0] /= length;\n    n[1] /= length;\n    n[2] /= length;\n  }\n}\nfunction intersectWithTriangle(p1, q1, r1, p2, q2, r2) {\n  let tolerance = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1e-6;\n  let coplanar = false;\n  const pt1 = [];\n  const pt2 = [];\n  const surfaceId = [];\n  const n1 = [];\n  const n2 = [];\n\n  // Compute supporting plane normals.\n  computeNormal(p1, q1, r1, n1);\n  computeNormal(p2, q2, r2, n2);\n  const s1 = -dot(n1, p1);\n  const s2 = -dot(n2, p2);\n\n  // Compute signed distances of points p1, q1, r1 from supporting\n  // plane of second triangle.\n  const dist1 = [dot(n2, p1) + s2, dot(n2, q1) + s2, dot(n2, r1) + s2];\n\n  // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n  if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 1!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n  // Do the same for p2, q2, r2 and supporting plane of first\n  // triangle.\n  const dist2 = [dot(n1, p2) + s1, dot(n1, q2) + s1, dot(n1, r2) + s1];\n\n  // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n  if (dist2[0] * dist2[1] > tolerance && dist2[0] * dist2[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 2!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n  // Check for coplanarity of the supporting planes.\n  if (Math.abs(n1[0] - n2[0]) < 1e-9 && Math.abs(n1[1] - n2[1]) < 1e-9 && Math.abs(n1[2] - n2[2]) < 1e-9 && Math.abs(s1 - s2) < 1e-9) {\n    coplanar = true;\n    // vtkDebugMacro(<<\"Coplanar!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n\n  // There are more efficient ways to find the intersection line (if\n  // it exists), but this is clear enough.\n  const pts1 = [p1, q1, r1];\n  const pts2 = [p2, q2, r2];\n\n  // Find line of intersection (L = p + t*v) between two planes.\n  const n1n2 = dot(n1, n2);\n  const a = (s1 - s2 * n1n2) / (n1n2 * n1n2 - 1.0);\n  const b = (s2 - s1 * n1n2) / (n1n2 * n1n2 - 1.0);\n  const p = [a * n1[0] + b * n2[0], a * n1[1] + b * n2[1], a * n1[2] + b * n2[2]];\n  const v = cross(n1, n2, []);\n  normalize(v);\n  let index1 = 0;\n  let index2 = 0;\n  const t1 = [];\n  const t2 = [];\n  let ts1 = 50;\n  let ts2 = 50;\n  for (let i = 0; i < 3; i++) {\n    const id1 = i;\n    const id2 = (i + 1) % 3;\n\n    // Find t coordinate on line of intersection between two planes.\n    const val1 = vtkPlane.intersectWithLine(pts1[id1], pts1[id2], p2, n2);\n    if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {\n      if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {\n        ts1 = index1;\n      }\n      t1[index1++] = dot(val1.x, v) - dot(p, v);\n    }\n    const val2 = vtkPlane.intersectWithLine(pts2[id1], pts2[id2], p1, n1);\n    if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {\n      if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {\n        ts2 = index2;\n      }\n      t2[index2++] = dot(val2.x, v) - dot(p, v);\n    }\n  }\n\n  // If the value of the index is greater than 2, the intersecting point\n  // actually is intersected by all three edges. In this case, set the two\n  // edges to the two edges where the intersecting point is not the end point\n  if (index1 > 2) {\n    index1--;\n    // swap\n    const t12 = t1[2];\n    t1[2] = t1[ts1];\n    t1[ts1] = t12;\n  }\n  if (index2 > 2) {\n    index2--;\n    const t22 = t2[2];\n    t2[2] = t2[ts2];\n    t2[ts2] = t22;\n  }\n  // Check if only one edge or all edges intersect the supporting\n  // planes intersection.\n  if (index1 !== 2 || index2 !== 2) {\n    // vtkDebugMacro(<<\"Only one edge intersecting!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n\n  // Check for NaNs\n  if (Number.isNaN(t1[0]) || Number.isNaN(t1[1]) || Number.isNaN(t2[0]) || Number.isNaN(t2[1])) {\n    // vtkWarningMacro(<<\"NaNs!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n  if (t1[0] > t1[1]) {\n    // swap\n    const t11 = t1[1];\n    t1[1] = t1[0];\n    t1[0] = t11;\n  }\n  if (t2[0] > t2[1]) {\n    // swap\n    const t21 = t2[1];\n    t2[1] = t2[0];\n    t2[0] = t21;\n  }\n  // Handle the different interval configuration cases.\n  let tt1;\n  let tt2;\n  if (t1[1] < t2[0] || t2[1] < t1[0]) {\n    // vtkDebugMacro(<<\"No Overlap!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    }; // No overlap\n  }\n\n  if (t1[0] < t2[0]) {\n    if (t1[1] < t2[1]) {\n      // First point on surface 2, second point on surface 1\n      surfaceId[0] = 2;\n      surfaceId[1] = 1;\n      tt1 = t2[0];\n      tt2 = t1[1];\n    } else {\n      // Both points belong to lines on surface 2\n      surfaceId[0] = 2;\n      surfaceId[1] = 2;\n      tt1 = t2[0];\n      tt2 = t2[1];\n    }\n  } // t1[0] >= t2[0]\n  else if (t1[1] < t2[1]) {\n    // Both points belong to lines on surface 1\n    surfaceId[0] = 1;\n    surfaceId[1] = 1;\n    tt1 = t1[0];\n    tt2 = t1[1];\n  } else {\n    // First point on surface 1, second point on surface 2\n    surfaceId[0] = 1;\n    surfaceId[1] = 2;\n    tt1 = t1[0];\n    tt2 = t2[1];\n  }\n\n  // Create actual intersection points.\n  multiplyAccumulate(p, v, tt1, pt1);\n  multiplyAccumulate(p, v, tt2, pt2);\n  return {\n    intersect: true,\n    coplanar,\n    pt1,\n    pt2,\n    surfaceId\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  computeNormalDirection,\n  computeNormal,\n  intersectWithTriangle\n};\n\n// ----------------------------------------------------------------------------\n// vtkTriangle methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTriangle(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkTriangle');\n  publicAPI.getCellDimension = () => 2;\n  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {\n    const outObj = {\n      subId: 0,\n      t: Number.MAX_VALUE,\n      intersect: 0,\n      betweenPoints: false\n    };\n    pcoords[2] = 0.0;\n    const closestPoint = [];\n    const tol2 = tol * tol;\n\n    // Get normal for triangle\n    const pt1 = [];\n    const pt2 = [];\n    const pt3 = [];\n    model.points.getPoint(0, pt1);\n    model.points.getPoint(1, pt2);\n    model.points.getPoint(2, pt3);\n    const n = [];\n    const weights = [];\n    computeNormal(pt1, pt2, pt3, n);\n    if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {\n      // Intersect plane of triangle with line\n      const plane = vtkPlane.intersectWithLine(p1, p2, pt1, n);\n      outObj.betweenPoints = plane.betweenPoints;\n      outObj.t = plane.t;\n      x[0] = plane.x[0];\n      x[1] = plane.x[1];\n      x[2] = plane.x[2];\n      if (!plane.intersection) {\n        pcoords[0] = 0.0;\n        pcoords[1] = 0.0;\n        outObj.intersect = 0;\n        return outObj;\n      }\n\n      // Evaluate position\n      const inside = publicAPI.evaluatePosition(x, closestPoint, pcoords, weights);\n      if (inside.evaluation >= 0) {\n        if (inside.dist2 <= tol2) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n        outObj.intersect = inside.evaluation;\n        return outObj;\n      }\n    }\n\n    // Normals are null, so the triangle is degenerated and\n    // we still need to check intersection between line and\n    // the longest edge.\n    const dist2Pt1Pt2 = distance2BetweenPoints(pt1, pt2);\n    const dist2Pt2Pt3 = distance2BetweenPoints(pt2, pt3);\n    const dist2Pt3Pt1 = distance2BetweenPoints(pt3, pt1);\n    if (!model.line) {\n      model.line = vtkLine.newInstance();\n    }\n    if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {\n      model.line.getPoints().setPoint(0, pt1);\n      model.line.getPoints().setPoint(1, pt2);\n    } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {\n      model.line.getPoints().setPoint(0, pt2);\n      model.line.getPoints().setPoint(1, pt3);\n    } else {\n      model.line.getPoints().setPoint(0, pt3);\n      model.line.getPoints().setPoint(1, pt1);\n    }\n    const intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);\n    outObj.betweenPoints = intersectLine.betweenPoints;\n    outObj.t = intersectLine.t;\n    if (intersectLine.intersect) {\n      const pt3Pt1 = [];\n      const pt3Pt2 = [];\n      const pt3X = [];\n      // Compute r and s manually, using dot and norm.\n      for (let i = 0; i < 3; i++) {\n        pt3Pt1[i] = pt1[i] - pt3[i];\n        pt3Pt2[i] = pt2[i] - pt3[i];\n        pt3X[i] = x[i] - pt3[i];\n      }\n      pcoords[0] = dot(pt3X, pt3Pt1) / dist2Pt3Pt1;\n      pcoords[1] = dot(pt3X, pt3Pt2) / dist2Pt2Pt3;\n      outObj.intersect = 1;\n      return outObj;\n    }\n    pcoords[0] = 0.0;\n    pcoords[1] = 0.0;\n    outObj.intersect = 0;\n    return outObj;\n  };\n  publicAPI.evaluatePosition = (x, closestPoint, pcoords, weights) => {\n    // will return obj\n    const outObj = {\n      subId: 0,\n      dist2: 0,\n      evaluation: -1\n    };\n    let i;\n    let j;\n    const pt1 = [];\n    const pt2 = [];\n    const pt3 = [];\n    const n = [];\n    let fabsn;\n    const rhs = [];\n    const c1 = [];\n    const c2 = [];\n    let det = 0;\n    let idx = 0;\n    const indices = [];\n    let dist2Point;\n    let dist2Line1;\n    let dist2Line2;\n    let closest = [];\n    const closestPoint1 = [];\n    const closestPoint2 = [];\n    const cp = [];\n    outObj.subId = 0;\n    pcoords[2] = 0.0;\n\n    // Get normal for triangle, only the normal direction is needed, i.e. the\n    // normal need not be normalized (unit length)\n    //\n    model.points.getPoint(1, pt1);\n    model.points.getPoint(2, pt2);\n    model.points.getPoint(0, pt3);\n    computeNormalDirection(pt1, pt2, pt3, n);\n\n    // Project point to plane\n    vtkPlane.generalizedProjectPoint(x, pt1, n, cp);\n\n    // Construct matrices.  Since we have over determined system, need to find\n    // which 2 out of 3 equations to use to develop equations. (Any 2 should\n    // work since we've projected point to plane.)\n    let maxComponent = 0.0;\n    for (i = 0; i < 3; i++) {\n      // trying to avoid an expensive call to fabs()\n      if (n[i] < 0) {\n        fabsn = -n[i];\n      } else {\n        fabsn = n[i];\n      }\n      if (fabsn > maxComponent) {\n        maxComponent = fabsn;\n        idx = i;\n      }\n    }\n    for (j = 0, i = 0; i < 3; i++) {\n      if (i !== idx) {\n        indices[j++] = i;\n      }\n    }\n    for (i = 0; i < 2; i++) {\n      rhs[i] = cp[indices[i]] - pt3[indices[i]];\n      c1[i] = pt1[indices[i]] - pt3[indices[i]];\n      c2[i] = pt2[indices[i]] - pt3[indices[i]];\n    }\n    det = determinant2x2(c1, c2);\n    if (det === 0.0) {\n      pcoords[0] = 0.0;\n      pcoords[1] = 0.0;\n      outObj.evaluation = -1;\n      return outObj;\n    }\n    pcoords[0] = determinant2x2(rhs, c2) / det;\n    pcoords[1] = determinant2x2(c1, rhs) / det;\n\n    // Okay, now find closest point to element\n    weights[0] = 1 - (pcoords[0] + pcoords[1]);\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n    if (weights[0] >= 0.0 && weights[0] <= 1.0 && weights[1] >= 0.0 && weights[1] <= 1.0 && weights[2] >= 0.0 && weights[2] <= 1.0) {\n      // projection distance\n      if (closestPoint) {\n        outObj.dist2 = distance2BetweenPoints(cp, x);\n        closestPoint[0] = cp[0];\n        closestPoint[1] = cp[1];\n        closestPoint[2] = cp[2];\n      }\n      outObj.evaluation = 1;\n    } else {\n      let t;\n      if (closestPoint) {\n        if (weights[1] < 0.0 && weights[2] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt3);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt3, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt3;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[2] < 0.0 && weights[0] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt1);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt1;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[1] < 0.0 && weights[0] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt2);\n          dist2Line1 = vtkLine.distanceToLine(x, pt2, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt2;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[0] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(x, pt1, pt2, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        } else if (weights[1] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(x, pt2, pt3, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        } else if (weights[2] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(x, pt1, pt3, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        }\n      }\n      outObj.evaluation = 0;\n    }\n    return outObj;\n  };\n  publicAPI.evaluateLocation = (pcoords, x, weights) => {\n    const p0 = [];\n    const p1 = [];\n    const p2 = [];\n    model.points.getPoint(0, p0);\n    model.points.getPoint(1, p1);\n    model.points.getPoint(2, p2);\n    const u3 = 1.0 - pcoords[0] - pcoords[1];\n    for (let i = 0; i < 3; i++) {\n      x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];\n    }\n    weights[0] = u3;\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n  };\n  publicAPI.getParametricDistance = pcoords => {\n    let pDist;\n    let pDistMax = 0.0;\n    const pc = [];\n    pc[0] = pcoords[0];\n    pc[1] = pcoords[1];\n    pc[2] = 1.0 - pcoords[0] - pcoords[1];\n    for (let i = 0; i < 3; i++) {\n      if (pc[i] < 0.0) {\n        pDist = -pc[i];\n      } else if (pc[i] > 1.0) {\n        pDist = pc[i] - 1.0;\n      } else {\n        // inside the cell in the parametric direction\n        pDist = 0.0;\n      }\n      if (pDist > pDistMax) {\n        pDistMax = pDist;\n      }\n    }\n    return pDistMax;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  vtkTriangle(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkTriangle');\n\n// ----------------------------------------------------------------------------\n\nvar vtkTriangle$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkTriangle$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}