{"ast":null,"code":"import { n as newInstance$1, o as obj, g as get, c as macro } from '../../macros2.js';\nimport { mat4, mat3, vec3 } from 'gl-matrix';\nimport vtkClosedPolyLineToSurfaceFilter from '../../Filters/General/ClosedPolyLineToSurfaceFilter.js';\nimport vtkCutter from '../../Filters/Core/Cutter.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkHelper from './Helper.js';\nimport vtkImageDataOutlineFilter from '../../Filters/General/ImageDataOutlineFilter.js';\nimport { f as vtkMath } from '../../Common/Core/Math/index.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkPlane from '../../Common/DataModel/Plane.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkReplacementShaderMapper from './ReplacementShaderMapper.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkTransform from '../../Common/Transform/Transform.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { v as vtkImageResliceMapperVS } from './glsl/vtkImageResliceMapperVS.glsl.js';\nimport { v as vtkImageResliceMapperFS } from './glsl/vtkImageResliceMapperFS.glsl.js';\nimport { Filter } from './Texture/Constants.js';\nimport { InterpolationType } from '../Core/ImageProperty/Constants.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n\nfunction computeFnToString(property, pwfun, numberOfComponents) {\n  if (pwfun) {\n    const iComps = property.getIndependentComponents();\n    return `${pwfun.getMTime()}-${iComps}-${numberOfComponents}`;\n  }\n  return '0';\n}\nfunction safeMatrixMultiply(matrixArray, matrixType, tmpMat) {\n  matrixType.identity(tmpMat);\n  return matrixArray.reduce((res, matrix, index) => {\n    if (index === 0) {\n      return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);\n    }\n    return matrix ? matrixType.multiply(res, res, matrix) : res;\n  }, tmpMat);\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLImageResliceMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLImageResliceMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLImageResliceMapper');\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model._openGLImageSlice = publicAPI.getFirstAncestorOfType('vtkOpenGLImageSlice');\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      const ren = model._openGLRenderer.getRenderable();\n      model._openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n    }\n  };\n  publicAPI.translucentPass = (prepass, renderPass) => {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n  publicAPI.zBufferPass = prepass => {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n  publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);\n  publicAPI.opaquePass = prepass => {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n  publicAPI.getCoincidentParameters = (ren, actor) => {\n    if (model.renderable.getResolveCoincidentTopology()) {\n      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n    }\n    return null;\n  };\n\n  // Renders myself\n  publicAPI.render = () => {\n    const actor = model._openGLImageSlice.getRenderable();\n    const ren = model._openGLRenderer.getRenderable();\n    publicAPI.renderPiece(ren, actor);\n  };\n  publicAPI.renderPiece = (ren, actor) => {\n    publicAPI.invokeEvent({\n      type: 'StartEvent'\n    });\n    model.renderable.update();\n    model.currentInput = model.renderable.getInputData();\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n    publicAPI.updateResliceGeometry();\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n    publicAPI.invokeEvent({\n      type: 'EndEvent'\n    });\n  };\n  publicAPI.renderPieceStart = (ren, actor) => {\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor);\n    const iType = actor.getProperty().getInterpolationType();\n    if (iType === InterpolationType.NEAREST) {\n      model.openGLTexture.setMinificationFilter(Filter.NEAREST);\n      model.openGLTexture.setMagnificationFilter(Filter.NEAREST);\n      model.colorTexture.setMinificationFilter(Filter.NEAREST);\n      model.colorTexture.setMagnificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMinificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMagnificationFilter(Filter.NEAREST);\n    } else {\n      model.openGLTexture.setMinificationFilter(Filter.LINEAR);\n      model.openGLTexture.setMagnificationFilter(Filter.LINEAR);\n      model.colorTexture.setMinificationFilter(Filter.LINEAR);\n      model.colorTexture.setMagnificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMinificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMagnificationFilter(Filter.LINEAR);\n    }\n\n    // No buffer objects bound.\n    model.lastBoundBO = null;\n  };\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const gl = model.context;\n\n    // render the texture\n    model.openGLTexture.activate();\n    model.colorTexture.activate();\n    model.pwfTexture.activate();\n\n    // update shaders if required\n    publicAPI.updateShaders(model.tris, ren, actor);\n\n    // Finally draw\n    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n    model.tris.getVAO().release();\n    model.openGLTexture.deactivate();\n    model.colorTexture.deactivate();\n    model.pwfTexture.deactivate();\n  };\n  publicAPI.renderPieceFinish = (ren, actor) => {};\n  publicAPI.updateBufferObjects = (ren, actor) => {\n    // Rebuild buffer objects if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime() || model.VBOBuildTime.getMTime() < model.resliceGeom.getMTime();\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const image = model.currentInput;\n    if (!image) {\n      return;\n    }\n    const scalars = image.getPointData()?.getScalars();\n    if (!scalars) {\n      return;\n    }\n    if (model._scalars !== scalars) {\n      model._openGLRenderWindow.releaseGraphicsResourcesForObject(model._scalars);\n      model._scalars = scalars;\n    }\n    const numComp = scalars.getNumberOfComponents();\n    let toString = `${image.getMTime()}A${scalars.getMTime()}`;\n    const tex = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);\n    const reBuildTex = !tex?.vtkObj || tex?.hash !== toString || model.openGLTextureString !== toString;\n    if (reBuildTex) {\n      if (!model.openGLTexture) {\n        model.openGLTexture = vtkOpenGLTexture.newInstance();\n        model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n      // Build the image scalar texture\n      const dims = image.getDimensions();\n      // Use norm16 for the 3D texture if the extension is available\n      model.openGLTexture.setOglNorm16Ext(model.context.getExtension('EXT_texture_norm16'));\n      model.openGLTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.openGLTexture.resetFormatAndType();\n      model.openGLTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars);\n      model.openGLTextureString = toString;\n      if (scalars) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(scalars, model.openGLTexture, model.openGLTextureString);\n      }\n    } else {\n      model.openGLTexture = tex.vtkObj;\n      model.openGLTextureString = tex.hash;\n    }\n    const ppty = actor.getProperty();\n    const iComps = ppty.getIndependentComponents();\n    const numIComps = iComps ? numComp : 1;\n    const textureHeight = iComps ? 2 * numIComps : 1;\n    const colorTransferFunc = ppty.getRGBTransferFunction();\n    toString = computeFnToString(ppty, colorTransferFunc, numIComps);\n    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);\n    const reBuildC = !cTex?.vtkObj || cTex?.hash !== toString || model.colorTextureString !== toString;\n    if (reBuildC) {\n      const cWidth = 1024;\n      const cSize = cWidth * textureHeight * 3;\n      const cTable = new Uint8Array(cSize);\n      if (!model.colorTexture) {\n        model.colorTexture = vtkOpenGLTexture.newInstance();\n        model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n      if (colorTransferFunc) {\n        const tmpTable = new Float32Array(cWidth * 3);\n        for (let c = 0; c < numIComps; c++) {\n          const cfun = ppty.getRGBTransferFunction(c);\n          const cRange = cfun.getRange();\n          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);\n          if (iComps) {\n            for (let i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];\n            }\n          } else {\n            for (let i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n            }\n          }\n        }\n        model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);\n        model.colorTexture.resetFormatAndType();\n        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      } else {\n        for (let i = 0; i < cWidth * 3; ++i) {\n          cTable[i] = 255.0 * i / ((cWidth - 1) * 3);\n          cTable[i + 1] = 255.0 * i / ((cWidth - 1) * 3);\n          cTable[i + 2] = 255.0 * i / ((cWidth - 1) * 3);\n        }\n        model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);\n        model.colorTexture.resetFormatAndType();\n        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      }\n      model.colorTextureString = toString;\n      if (colorTransferFunc) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, model.colorTextureString);\n      }\n    } else {\n      model.colorTexture = cTex.vtkObj;\n      model.colorTextureString = cTex.hash;\n    }\n\n    // Build piecewise function buffer.  This buffer is used either\n    // for component weighting or opacity, depending on whether we're\n    // rendering components independently or not.\n    const pwFunc = ppty.getPiecewiseFunction();\n    toString = computeFnToString(ppty, pwFunc, numIComps);\n    const pwfTex = model._openGLRenderWindow.getGraphicsResourceForObject(pwFunc);\n    // rebuild opacity tfun?\n    const reBuildPwf = !pwfTex?.vtkObj || pwfTex?.hash !== toString || model.pwfTextureString !== toString;\n    if (reBuildPwf) {\n      const pwfWidth = 1024;\n      const pwfSize = pwfWidth * textureHeight;\n      const pwfTable = new Uint8Array(pwfSize);\n      if (!model.pwfTexture) {\n        model.pwfTexture = vtkOpenGLTexture.newInstance();\n        model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n      if (pwFunc) {\n        const pwfFloatTable = new Float32Array(pwfSize);\n        const tmpTable = new Float32Array(pwfWidth);\n        for (let c = 0; c < numIComps; ++c) {\n          const pwfun = ppty.getPiecewiseFunction(c);\n          if (pwfun === null) {\n            // Piecewise constant max if no function supplied for this component\n            pwfFloatTable.fill(1.0);\n          } else {\n            const pwfRange = pwfun.getRange();\n            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);\n            // adjust for sample distance etc\n            if (iComps) {\n              for (let i = 0; i < pwfWidth; i++) {\n                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];\n                pwfFloatTable[c * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];\n              }\n            } else {\n              for (let i = 0; i < pwfWidth; i++) {\n                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];\n              }\n            }\n          }\n        }\n        model.pwfTexture.releaseGraphicsResources(model._openGLRenderWindow);\n        model.pwfTexture.resetFormatAndType();\n        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);\n      } else {\n        // default is opaque\n        pwfTable.fill(255.0);\n        model.pwfTexture.releaseGraphicsResources(model._openGLRenderWindow);\n        model.pwfTexture.resetFormatAndType();\n        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);\n      }\n      model.pwfTextureString = toString;\n      if (pwFunc) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(pwFunc, model.pwfTexture, model.pwfTextureString);\n      }\n    } else {\n      model.pwfTexture = pwfTex.vtkObj;\n      model.pwfTextureString = pwfTex.hash;\n    }\n    const vboString = `${model.resliceGeom.getMTime()}A${model.renderable.getSlabThickness()}`;\n    if (!model.tris.getCABO().getElementCount() || model.VBOBuildString !== vboString) {\n      const points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: model.resliceGeom.getPoints().getData()\n      });\n      points.setName('points');\n      const cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: model.resliceGeom.getPolys().getData()\n      });\n      const options = {\n        points,\n        cellOffset: 0\n      };\n      if (model.renderable.getSlabThickness() > 0.0) {\n        const n = model.resliceGeom.getPointData().getNormals();\n        if (!n) {\n          vtkErrorMacro('Slab mode requested without normals');\n        } else {\n          options.normals = n;\n        }\n      }\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, options);\n    }\n    model.VBOBuildString = vboString;\n    model.VBOBuildTime.modified();\n  };\n  publicAPI.updateShaders = (cellBO, ren, actor) => {\n    model.lastBoundBO = cellBO;\n\n    // has something changed that would require us to recreate the shader?\n    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {\n      const shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      publicAPI.buildShaders(shaders, ren, actor);\n\n      // compile and bind the program if needed\n      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);\n\n      // if the shader changed reinitialize the VAO\n      if (newShader !== cellBO.getProgram()) {\n        cellBO.setProgram(newShader);\n        // reset the VAO as the shader has changed\n        cellBO.getVAO().releaseGraphicsResources();\n      }\n      cellBO.getShaderSourceTime().modified();\n    } else {\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());\n    }\n    cellBO.getVAO().bind();\n    publicAPI.setMapperShaderParameters(cellBO, ren, actor);\n    publicAPI.setCameraShaderParameters(cellBO, ren, actor);\n    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      // Set the 3D texture\n      if (program.isUniformUsed('texture1')) {\n        program.setUniformi('texture1', model.openGLTexture.getTextureUnit());\n      }\n\n      // Set the plane vertex attributes\n      if (program.isAttributeUsed('vertexWC')) {\n        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), 'vertexWC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexWC in shader VAO.');\n        }\n      }\n\n      // If we are doing slab mode, we need normals\n      if (program.isAttributeUsed('normalWC')) {\n        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), 'normalWC', cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting normalWC in shader VAO.');\n        }\n      }\n      if (program.isUniformUsed('slabThickness')) {\n        program.setUniformf('slabThickness', model.renderable.getSlabThickness());\n      }\n      if (program.isUniformUsed('spacing')) {\n        program.setUniform3fv('spacing', model.currentInput.getSpacing());\n      }\n      if (program.isUniformUsed('slabType')) {\n        program.setUniformi('slabType', model.renderable.getSlabType());\n      }\n      if (program.isUniformUsed('slabType')) {\n        program.setUniformi('slabType', model.renderable.getSlabType());\n      }\n      if (program.isUniformUsed('slabTrapezoid')) {\n        program.setUniformi('slabTrapezoid', model.renderable.getSlabTrapezoidIntegration());\n      }\n      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n\n      // Set the world->texture matrix\n      if (program.isUniformUsed('WCTCMatrix')) {\n        const image = model.currentInput;\n        const dim = image.getDimensions();\n        mat4.copy(model.tmpMat4, image.getIndexToWorld());\n        mat4.scale(model.tmpMat4, model.tmpMat4, dim);\n        mat4.invert(model.tmpMat4, model.tmpMat4);\n        if (inverseShiftScaleMatrix) {\n          mat4.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);\n        }\n        program.setUniformMatrix('WCTCMatrix', model.tmpMat4);\n      }\n      if (program.isUniformUsed('vboScaling')) {\n        program.setUniform3fv('vboScaling', cellBO.getCABO().getCoordScale());\n      }\n      cellBO.getAttributeUpdateTime().modified();\n    }\n\n    // Depth request\n    if (model.haveSeenDepthRequest) {\n      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    }\n\n    // handle coincident\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      const cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset);\n      // cfactor isn't always used when coffset is.\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    }\n  };\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    // [WMVP]C == {world, model, view, projection} coordinates\n    // e.g. WCPC == world to projection coordinate transformation\n    const keyMats = model._openGLCamera.getKeyMatrices(ren);\n    const actMats = model._openGLImageSlice.getKeyMatrices();\n    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n    const program = cellBO.getProgram();\n    if (program.isUniformUsed('MCPCMatrix')) {\n      mat4.identity(model.tmpMat4);\n      program.setUniformMatrix('MCPCMatrix', safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n    if (program.isUniformUsed('MCVCMatrix')) {\n      mat4.identity(model.tmpMat4);\n      program.setUniformMatrix('MCVCMatrix', safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n  };\n  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    const ppty = actor.getProperty();\n    const opacity = ppty.getOpacity();\n    program.setUniformf('opacity', opacity);\n\n    // Component mix\n    // Independent components: Mixed according to component weights\n    // Dependent components: Mixed using the following logic:\n    //    - 2 comps => LA\n    //    - 3 comps => RGB + opacity from pwf\n    //    - 4 comps => RGBA\n    const numComp = model.openGLTexture.getComponents();\n    const iComps = ppty.getIndependentComponents();\n    if (iComps) {\n      for (let i = 0; i < numComp; ++i) {\n        program.setUniformf(`mix${i}`, ppty.getComponentWeight(i));\n      }\n    }\n\n    // Color opacity map\n    const volInfo = model.openGLTexture.getVolumeInfo();\n\n    // three levels of shift scale combined into one\n    // for performance in the fragment shader\n    for (let i = 0; i < numComp; i++) {\n      let cw = ppty.getColorWindow();\n      let cl = ppty.getColorLevel();\n      const target = iComps ? i : 0;\n      const cfun = ppty.getRGBTransferFunction(target);\n      if (cfun && ppty.getUseLookupTableScalarRange()) {\n        const cRange = cfun.getRange();\n        cw = cRange[1] - cRange[0];\n        cl = 0.5 * (cRange[1] + cRange[0]);\n      }\n      const scale = volInfo.scale[i] / cw;\n      const shift = (volInfo.offset[i] - cl) / cw + 0.5;\n      program.setUniformf(`cshift${i}`, shift);\n      program.setUniformf(`cscale${i}`, scale);\n    }\n    const texColorUnit = model.colorTexture.getTextureUnit();\n    program.setUniformi('colorTexture1', texColorUnit);\n\n    // pwf shift/scale\n    for (let i = 0; i < numComp; i++) {\n      let pwfScale = 1.0;\n      let pwfShift = 0.0;\n      const target = iComps ? i : 0;\n      const pwfun = ppty.getPiecewiseFunction(target);\n      if (pwfun) {\n        const pwfRange = pwfun.getRange();\n        const length = pwfRange[1] - pwfRange[0];\n        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);\n        pwfScale = volInfo.scale[i] / length;\n        pwfShift = (volInfo.offset[i] - mid) / length + 0.5;\n      }\n      program.setUniformf(`pwfshift${i}`, pwfShift);\n      program.setUniformf(`pwfscale${i}`, pwfScale);\n    }\n    const texOpacityUnit = model.pwfTexture.getTextureUnit();\n    program.setUniformi('pwfTexture1', texOpacityUnit);\n\n    // Background color\n    program.setUniform4fv('backgroundColor', model.renderable.getBackgroundColor());\n  };\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    // render pass shader replacement changed\n    const tNumComp = model.openGLTexture.getComponents();\n    const iComp = actor.getProperty().getIndependentComponents();\n    const slabTh = model.renderable.getSlabThickness();\n    const slabType = model.renderable.getSlabType();\n    const slabTrap = model.renderable.getSlabTrapezoidIntegration();\n\n    // has the render pass shader replacement changed? Two options\n    let needRebuild = false;\n    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {\n      needRebuild = true;\n    }\n    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram()?.getHandle() === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp || model.lastSlabThickness !== slabTh || model.lastSlabType !== slabType || model.lastSlabTrapezoidIntegration !== slabTrap) {\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      model.lastTextureComponents = tNumComp;\n      model.lastIndependentComponents = iComp;\n      model.lastSlabThickness = slabTh;\n      model.lastSlabType = slabType;\n      model.lastSlabTrapezoidIntegration = slabTrap;\n      return true;\n    }\n    return false;\n  };\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkImageResliceMapperVS;\n    shaders.Fragment = vtkImageResliceMapperFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    publicAPI.replaceShaderTCoord(shaders, ren, actor);\n    publicAPI.replaceShaderPositionVC(shaders, ren, actor);\n    if (model.haveSeenDepthRequest) {\n      let FSSource = shaders.Fragment;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n      shaders.Fragment = FSSource;\n    }\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n  };\n  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    const GSSource = shaders.Geometry;\n    let FSSource = shaders.Fragment;\n    const tcoordVSDec = ['uniform mat4 WCTCMatrix;', 'out vec3 fragTexCoord;'];\n    const slabThickness = model.renderable.getSlabThickness();\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', tcoordVSDec).result;\n    const tcoordVSImpl = ['fragTexCoord = (WCTCMatrix * vertexWC).xyz;'];\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', tcoordVSImpl).result;\n    const tNumComp = model.openGLTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n    let tcoordFSDec = ['in vec3 fragTexCoord;', 'uniform highp sampler3D texture1;', 'uniform mat4 WCTCMatrix;',\n    // color shift and scale\n    'uniform float cshift0;', 'uniform float cscale0;',\n    // pwf shift and scale\n    'uniform float pwfshift0;', 'uniform float pwfscale0;',\n    // color and pwf textures\n    'uniform sampler2D colorTexture1;', 'uniform sampler2D pwfTexture1;',\n    // opacity\n    'uniform float opacity;',\n    // background color\n    'uniform vec4 backgroundColor;'];\n    if (iComps) {\n      for (let comp = 1; comp < tNumComp; comp++) {\n        tcoordFSDec = tcoordFSDec.concat([\n        // color shift and scale\n        `uniform float cshift${comp};`, `uniform float cscale${comp};`,\n        // weighting shift and scale\n        `uniform float pwfshift${comp};`, `uniform float pwfscale${comp};`]);\n      }\n      // the heights defined below are the locations\n      // for the up to four components of the tfuns\n      // the tfuns have a height of 2XnumComps pixels so the\n      // values are computed to hit the middle of the two rows\n      // for that component\n      switch (tNumComp) {\n        case 1:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', '#define height0 0.5']);\n          break;\n        case 2:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', '#define height0 0.25', '#define height1 0.75']);\n          break;\n        case 3:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', '#define height0 0.17', '#define height1 0.5', '#define height2 0.83']);\n          break;\n        case 4:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', 'uniform float mix3;', '#define height0 0.125', '#define height1 0.375', '#define height2 0.625', '#define height3 0.875']);\n          break;\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n    }\n    if (slabThickness > 0.0) {\n      tcoordFSDec = tcoordFSDec.concat(['uniform vec3 spacing;', 'uniform float slabThickness;', 'uniform int slabType;', 'uniform int slabTrapezoid;', 'uniform vec3 vboScaling;']);\n      tcoordFSDec = tcoordFSDec.concat(['vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)', '{', '  vec4 retVal = vec4(1.0);', '  if (slabType == 0) // min', '  {', '    retVal = min(currVal, valToComp);', '  }', '  else if (slabType == 1) // max', '  {', '    retVal = max(currVal, valToComp);', '  }', '  else if (slabType == 3) // sum', '  {', '    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ', '  }', '  else // mean', '  {', '    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ', '  }', '  return retVal;', '}']);\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', tcoordFSDec).result;\n    let tcoordFSImpl = ['if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))', '{', '  // set the background color and exit', '  gl_FragData[0] = backgroundColor;', '  return;', '}', 'vec4 tvalue = texture(texture1, fragTexCoord);'];\n    if (slabThickness > 0.0) {\n      tcoordFSImpl = tcoordFSImpl.concat(['// Get the first and last samples', 'int numSlices = 1;', 'float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;', 'vec3 normalxspacing = scaling * normalWCVSOutput;', 'float distTraveled = length(normalxspacing);', 'int trapezoid = 0;', 'while (distTraveled < slabThickness * 0.5)', '{', '  distTraveled += length(normalxspacing);', '  float fnumSlices = float(numSlices);', '  if (distTraveled > slabThickness * 0.5)', '  {', '    // Before stepping outside the slab, sample at the boundaries', '    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;', '    trapezoid = slabTrapezoid;', '  }', '  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;', '  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))', '  {', '    vec4 newVal = texture(texture1, fragTCoordNeg);', '    tvalue = compositeValue(tvalue, newVal, trapezoid);', '    numSlices += 1;', '  }', '  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;', '  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))', '  {', '    vec4 newVal = texture(texture1, fragTCoordPos);', '    tvalue = compositeValue(tvalue, newVal, trapezoid);', '    numSlices += 1;', '  }', '}', '// Finally, if slab type is *mean*, divide the sum by the numSlices', 'if (slabType == 2)', '{', '  tvalue = tvalue / float(numSlices);', '}']);\n    }\n    if (iComps) {\n      const rgba = ['r', 'g', 'b', 'a'];\n      for (let comp = 0; comp < tNumComp; ++comp) {\n        tcoordFSImpl = tcoordFSImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);\n      }\n      switch (tNumComp) {\n        case 1:\n          tcoordFSImpl = tcoordFSImpl.concat(['gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);']);\n          break;\n        case 2:\n          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);']);\n          break;\n        case 3:\n          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);']);\n          break;\n        case 4:\n          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);']);\n          break;\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n    } else {\n      // dependent components\n      switch (tNumComp) {\n        case 1:\n          tcoordFSImpl = tcoordFSImpl.concat(['// Dependent components', 'float intensity = tvalue.r;', 'vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;', 'float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;', 'gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);']);\n          break;\n        case 2:\n          tcoordFSImpl = tcoordFSImpl.concat(['float intensity = tvalue.r*cscale0 + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);']);\n          break;\n        case 3:\n          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);']);\n          break;\n        default:\n          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);']);\n      }\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', tcoordFSImpl).result;\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    shaders.Geometry = GSSource;\n  };\n  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    const GSSource = shaders.Geometry;\n    let FSSource = shaders.Fragment;\n    const slabThickness = model.renderable.getSlabThickness();\n    let posVCVSDec = ['attribute vec4 vertexWC;'];\n    // Add a unique hash to the shader to ensure that the shader program is unique to this mapper.\n    posVCVSDec = posVCVSDec.concat([`//${publicAPI.getMTime()}${model.resliceGeomUpdateString}`]);\n    if (slabThickness > 0.0) {\n      posVCVSDec = posVCVSDec.concat(['attribute vec3 normalWC;', 'varying vec3 normalWCVSOutput;', 'varying vec4 vertexWCVSOutput;']);\n    }\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', posVCVSDec).result;\n    let posVCVSImpl = ['gl_Position = MCPCMatrix * vertexWC;'];\n    if (slabThickness > 0.0) {\n      posVCVSImpl = posVCVSImpl.concat(['normalWCVSOutput = normalWC;', 'vertexWCVSOutput = vertexWC;']);\n    }\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', posVCVSImpl).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;\n    let posVCFSDec = [];\n    if (slabThickness > 0.0) {\n      posVCFSDec = posVCFSDec.concat(['varying vec3 normalWCVSOutput;', 'varying vec4 vertexWCVSOutput;']);\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Dec', posVCFSDec).result;\n    shaders.Vertex = VSSource;\n    shaders.Geometry = GSSource;\n    shaders.Fragment = FSSource;\n  };\n  function isVectorAxisAligned(n) {\n    vtkMath.normalize(n);\n    const tmpN = [0, 0, 0];\n    for (let i = 0; i < 3; ++i) {\n      vec3.zero(tmpN);\n      tmpN[i] = 1.0;\n      const dotP = vtkMath.dot(n, tmpN);\n      if (dotP < -0.999 || dotP > 0.999) {\n        return [true, i];\n      }\n    }\n    return [false, 2];\n  }\n  publicAPI.updateResliceGeometry = () => {\n    let resGeomString = '';\n    const image = model.currentInput;\n    const imageBounds = image?.getBounds();\n    // Orthogonal slicing by default\n    let orthoSlicing = true;\n    let orthoAxis = 2;\n    const slicePD = model.renderable.getSlicePolyData();\n    const slicePlane = model.renderable.getSlicePlane();\n    if (slicePD) {\n      resGeomString = resGeomString.concat(`PolyData${slicePD.getMTime()}`);\n    } else if (slicePlane) {\n      resGeomString = resGeomString.concat(`Plane${slicePlane.getMTime()}`);\n      if (image) {\n        resGeomString = resGeomString.concat(`Image${image.getMTime()}`);\n      }\n      // Check to see if we can bypass oblique slicing related bounds computation\n      // Compute a world-to-image-orientation matrix.\n      // Ignore the translation component since we are\n      // using it on vectors rather than positions.\n      const w2io = mat3.fromValues(image?.getDirection());\n      mat3.invert(w2io, w2io);\n      // transform the cutting plane normal to image local coords\n      const imageLocalNormal = [...slicePlane.getNormal()];\n      vec3.transformMat3(imageLocalNormal, imageLocalNormal, w2io);\n      [orthoSlicing, orthoAxis] = isVectorAxisAligned(imageLocalNormal);\n    } else {\n      // Create a default slice plane here\n      const plane = vtkPlane.newInstance();\n      plane.setNormal(0, 0, 1);\n      let bds = [0, 1, 0, 1, 0, 1];\n      if (image) {\n        bds = imageBounds;\n      }\n      plane.setOrigin(bds[0], bds[2], 0.5 * (bds[5] + bds[4]));\n      model.renderable.setSlicePlane(plane);\n      resGeomString = resGeomString.concat(`Plane${slicePlane?.getMTime()}`);\n      if (image) {\n        resGeomString = resGeomString.concat(`Image${image.getMTime()}`);\n      }\n    }\n    if (!model.resliceGeom || model.resliceGeomUpdateString !== resGeomString) {\n      if (slicePD) {\n        if (!model.resliceGeom) {\n          model.resliceGeom = vtkPolyData.newInstance();\n        }\n        model.resliceGeom.getPoints().setData(slicePD.getPoints().getData(), 3);\n        model.resliceGeom.getPolys().setData(slicePD.getPolys().getData(), 1);\n        model.resliceGeom.getPointData().setNormals(slicePD.getPointData().getNormals());\n      } else if (slicePlane) {\n        if (!orthoSlicing) {\n          model.outlineFilter.setInputData(image);\n          model.cutter.setInputConnection(model.outlineFilter.getOutputPort());\n          model.cutter.setCutFunction(slicePlane);\n          model.lineToSurfaceFilter.setInputConnection(model.cutter.getOutputPort());\n          model.lineToSurfaceFilter.update();\n          if (!model.resliceGeom) {\n            model.resliceGeom = vtkPolyData.newInstance();\n          }\n          const planePD = model.lineToSurfaceFilter.getOutputData();\n          model.resliceGeom.getPoints().setData(planePD.getPoints().getData(), 3);\n          model.resliceGeom.getPolys().setData(planePD.getPolys().getData(), 1);\n          model.resliceGeom.getPointData().setNormals(planePD.getPointData().getNormals());\n          // The above method does not generate point normals\n          // Set it manually here.\n          const n = slicePlane.getNormal();\n          const npts = model.resliceGeom.getNumberOfPoints();\n          vtkMath.normalize(n);\n          const normalsData = new Float32Array(npts * 3);\n          for (let i = 0; i < npts; ++i) {\n            normalsData[3 * i] = n[0];\n            normalsData[3 * i + 1] = n[1];\n            normalsData[3 * i + 2] = n[2];\n          }\n          const normals = vtkDataArray.newInstance({\n            numberOfComponents: 3,\n            values: normalsData,\n            name: 'Normals'\n          });\n          model.resliceGeom.getPointData().setNormals(normals);\n        } else {\n          // Since the image-local normal is axis-aligned, we\n          // can quickly construct the cutting plane using indexToWorld transforms.\n          const ptsArray = new Float32Array(12);\n          const indexSpacePlaneOrigin = image.worldToIndex(slicePlane.getOrigin(), [0, 0, 0]);\n          const otherAxes = [(orthoAxis + 1) % 3, (orthoAxis + 2) % 3].sort();\n          const dim = image.getDimensions();\n          const ext = [0, dim[0] - 1, 0, dim[1] - 1, 0, dim[2] - 1];\n          let ptIdx = 0;\n          for (let i = 0; i < 2; ++i) {\n            for (let j = 0; j < 2; ++j) {\n              ptsArray[ptIdx + orthoAxis] = indexSpacePlaneOrigin[orthoAxis];\n              ptsArray[ptIdx + otherAxes[0]] = ext[2 * otherAxes[0] + j];\n              ptsArray[ptIdx + otherAxes[1]] = ext[2 * otherAxes[1] + i];\n              ptIdx += 3;\n            }\n          }\n          model.transform.setMatrix(image.getIndexToWorld());\n          model.transform.transformPoints(ptsArray, ptsArray);\n          const cellArray = new Uint16Array(8);\n          cellArray[0] = 3;\n          cellArray[1] = 0;\n          cellArray[2] = 1;\n          cellArray[3] = 3;\n          cellArray[4] = 3;\n          cellArray[5] = 0;\n          cellArray[6] = 3;\n          cellArray[7] = 2;\n          const n = slicePlane.getNormal();\n          vtkMath.normalize(n);\n          const normalsData = new Float32Array(12);\n          for (let i = 0; i < 4; ++i) {\n            normalsData[3 * i] = n[0];\n            normalsData[3 * i + 1] = n[1];\n            normalsData[3 * i + 2] = n[2];\n          }\n          if (!model.resliceGeom) {\n            model.resliceGeom = vtkPolyData.newInstance();\n          }\n          model.resliceGeom.getPoints().setData(ptsArray, 3);\n          model.resliceGeom.getPolys().setData(cellArray, 1);\n          const normals = vtkDataArray.newInstance({\n            numberOfComponents: 3,\n            values: normalsData,\n            name: 'Normals'\n          });\n          model.resliceGeom.getPointData().setNormals(normals);\n        }\n      } else {\n        vtkErrorMacro('Something went wrong.', 'A default slice plane should have been created in the beginning of', 'updateResliceGeometry.');\n      }\n      model.resliceGeomUpdateString = resGeomString;\n      model.resliceGeom?.modified();\n    }\n  };\n  publicAPI.setOpenGLTexture = oglTex => {\n    if (oglTex) {\n      model.openGLTexture = oglTex;\n      model._externalOpenGLTexture = true;\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  VBOBuildTime: {},\n  VBOBuildString: null,\n  haveSeenDepthRequest: false,\n  lastHaveSeenDepthRequest: false,\n  lastIndependentComponents: false,\n  lastTextureComponents: 0,\n  lastSlabThickness: 0,\n  lastSlabTrapezoidIntegration: 0,\n  lastSlabType: -1,\n  openGLTexture: null,\n  openGLTextureString: null,\n  colorTextureString: null,\n  pwfTextureString: null,\n  resliceGeom: null,\n  resliceGeomUpdateString: null,\n  tris: null,\n  colorTexture: null,\n  pwfTexture: null,\n  _externalOpenGLTexture: false,\n  _scalars: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);\n  model.tris = vtkHelper.newInstance();\n  model.openGLTexture = null;\n  model.colorTexture = null;\n  model.pwfTexture = null;\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime);\n  model.tmpMat4 = mat4.identity(new Float64Array(16));\n\n  // Implicit plane to polydata related cache:\n  model.outlineFilter = vtkImageDataOutlineFilter.newInstance();\n  model.outlineFilter.setGenerateFaces(true);\n  model.outlineFilter.setGenerateLines(false);\n  model.cubePolyData = vtkPolyData.newInstance();\n  model.cutter = vtkCutter.newInstance();\n  model.lineToSurfaceFilter = vtkClosedPolyLineToSurfaceFilter.newInstance();\n  model.transform = vtkTransform.newInstance();\n  get(publicAPI, model, ['openGLTexture']);\n\n  // Object methods\n  vtkOpenGLImageResliceMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLImageResliceMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageResliceMapper = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkImageResliceMapper', newInstance);\nexport { vtkImageResliceMapper as default, extend, newInstance };","map":{"version":3,"names":["n","newInstance$1","o","obj","g","get","c","macro","mat4","mat3","vec3","vtkClosedPolyLineToSurfaceFilter","vtkCutter","vtkDataArray","vtkHelper","vtkImageDataOutlineFilter","f","vtkMath","vtkOpenGLTexture","vtkPlane","vtkPolyData","vtkReplacementShaderMapper","vtkShaderProgram","vtkTransform","vtkViewNode","v","vtkImageResliceMapperVS","vtkImageResliceMapperFS","Filter","InterpolationType","Representation","VtkDataTypes","registerOverride","vtkErrorMacro","computeFnToString","property","pwfun","numberOfComponents","iComps","getIndependentComponents","getMTime","safeMatrixMultiply","matrixArray","matrixType","tmpMat","identity","reduce","res","matrix","index","copy","multiply","vtkOpenGLImageResliceMapper","publicAPI","model","classHierarchy","push","buildPass","prepass","currentRenderPass","_openGLImageSlice","getFirstAncestorOfType","_openGLRenderer","ren","getRenderable","_openGLCamera","getViewNodeFor","getActiveCamera","_openGLRenderWindow","getParent","context","getContext","tris","setOpenGLRenderWindow","translucentPass","renderPass","render","zBufferPass","haveSeenDepthRequest","renderDepth","opaqueZBufferPass","opaquePass","getCoincidentParameters","actor","renderable","getResolveCoincidentTopology","getCoincidentTopologyPolygonOffsetParameters","renderPiece","invokeEvent","type","update","currentInput","getInputData","updateResliceGeometry","renderPieceStart","renderPieceDraw","renderPieceFinish","updateBufferObjects","iType","getProperty","getInterpolationType","NEAREST","openGLTexture","setMinificationFilter","setMagnificationFilter","colorTexture","pwfTexture","LINEAR","lastBoundBO","gl","activate","updateShaders","drawArrays","TRIANGLES","getCABO","getElementCount","getVAO","release","deactivate","getNeedToRebuildBufferObjects","buildBufferObjects","VBOBuildTime","resliceGeom","image","scalars","getPointData","getScalars","_scalars","releaseGraphicsResourcesForObject","numComp","getNumberOfComponents","toString","tex","getGraphicsResourceForObject","reBuildTex","vtkObj","hash","openGLTextureString","newInstance","dims","getDimensions","setOglNorm16Ext","getExtension","releaseGraphicsResources","resetFormatAndType","create3DFilterableFromDataArray","setGraphicsResourceForObject","ppty","numIComps","textureHeight","colorTransferFunc","getRGBTransferFunction","cTex","reBuildC","colorTextureString","cWidth","cSize","cTable","Uint8Array","tmpTable","Float32Array","cfun","cRange","getRange","getTable","i","create2DFromRaw","UNSIGNED_CHAR","pwFunc","getPiecewiseFunction","pwfTex","reBuildPwf","pwfTextureString","pwfWidth","pwfSize","pwfTable","pwfFloatTable","fill","pwfRange","FLOAT","vboString","getSlabThickness","VBOBuildString","points","values","getPoints","getData","setName","cells","getPolys","options","cellOffset","getNormals","normals","createVBO","SURFACE","modified","cellBO","getNeedToRebuildShaders","shaders","Vertex","Fragment","Geometry","buildShaders","newShader","getShaderCache","readyShaderProgramArray","getProgram","setProgram","getShaderSourceTime","readyShaderProgram","bind","setMapperShaderParameters","setCameraShaderParameters","setPropertyShaderParameters","program","getAttributeUpdateTime","isUniformUsed","setUniformi","getTextureUnit","isAttributeUsed","addAttributeArray","getVertexOffset","getStride","FALSE","getNormalOffset","setUniformf","setUniform3fv","getSpacing","getSlabType","getSlabTrapezoidIntegration","shiftScaleEnabled","getCoordShiftAndScaleEnabled","inverseShiftScaleMatrix","getInverseShiftAndScaleMatrix","dim","tmpMat4","getIndexToWorld","scale","invert","setUniformMatrix","getCoordScale","cp","offset","factor","keyMats","getKeyMatrices","actMats","wcpc","mcwc","wcvc","opacity","getOpacity","getComponents","getComponentWeight","volInfo","getVolumeInfo","cw","getColorWindow","cl","getColorLevel","target","getUseLookupTableScalarRange","shift","texColorUnit","pwfScale","pwfShift","length","mid","texOpacityUnit","setUniform4fv","getBackgroundColor","tNumComp","iComp","slabTh","slabType","slabTrap","needRebuild","lastRenderPassShaderReplacement","getShaderReplacement","lastHaveSeenDepthRequest","getHandle","lastTextureComponents","lastIndependentComponents","lastSlabThickness","lastSlabType","lastSlabTrapezoidIntegration","getShaderTemplate","replaceShaderValues","replaceShaderTCoord","replaceShaderPositionVC","FSSource","substitute","result","replaceShaderCoincidentOffset","VSSource","GSSource","tcoordVSDec","slabThickness","tcoordVSImpl","tcoordFSDec","comp","concat","tcoordFSImpl","rgba","posVCVSDec","resliceGeomUpdateString","posVCVSImpl","posVCFSDec","isVectorAxisAligned","normalize","tmpN","zero","dotP","dot","resGeomString","imageBounds","getBounds","orthoSlicing","orthoAxis","slicePD","getSlicePolyData","slicePlane","getSlicePlane","w2io","fromValues","getDirection","imageLocalNormal","getNormal","transformMat3","plane","setNormal","bds","setOrigin","setSlicePlane","setData","setNormals","outlineFilter","setInputData","cutter","setInputConnection","getOutputPort","setCutFunction","lineToSurfaceFilter","planePD","getOutputData","npts","getNumberOfPoints","normalsData","name","ptsArray","indexSpacePlaneOrigin","worldToIndex","getOrigin","otherAxes","sort","ext","ptIdx","j","transform","setMatrix","transformPoints","cellArray","Uint16Array","setOpenGLTexture","oglTex","_externalOpenGLTexture","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","implementReplaceShaderCoincidentOffset","implementBuildShadersWithReplacements","Float64Array","setGenerateFaces","setGenerateLines","cubePolyData","vtkImageResliceMapper","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageResliceMapper.js"],"sourcesContent":["import { n as newInstance$1, o as obj, g as get, c as macro } from '../../macros2.js';\nimport { mat4, mat3, vec3 } from 'gl-matrix';\nimport vtkClosedPolyLineToSurfaceFilter from '../../Filters/General/ClosedPolyLineToSurfaceFilter.js';\nimport vtkCutter from '../../Filters/Core/Cutter.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkHelper from './Helper.js';\nimport vtkImageDataOutlineFilter from '../../Filters/General/ImageDataOutlineFilter.js';\nimport { f as vtkMath } from '../../Common/Core/Math/index.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkPlane from '../../Common/DataModel/Plane.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkReplacementShaderMapper from './ReplacementShaderMapper.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkTransform from '../../Common/Transform/Transform.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { v as vtkImageResliceMapperVS } from './glsl/vtkImageResliceMapperVS.glsl.js';\nimport { v as vtkImageResliceMapperFS } from './glsl/vtkImageResliceMapperFS.glsl.js';\nimport { Filter } from './Texture/Constants.js';\nimport { InterpolationType } from '../Core/ImageProperty/Constants.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n\nfunction computeFnToString(property, pwfun, numberOfComponents) {\n  if (pwfun) {\n    const iComps = property.getIndependentComponents();\n    return `${pwfun.getMTime()}-${iComps}-${numberOfComponents}`;\n  }\n  return '0';\n}\nfunction safeMatrixMultiply(matrixArray, matrixType, tmpMat) {\n  matrixType.identity(tmpMat);\n  return matrixArray.reduce((res, matrix, index) => {\n    if (index === 0) {\n      return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);\n    }\n    return matrix ? matrixType.multiply(res, res, matrix) : res;\n  }, tmpMat);\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLImageResliceMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLImageResliceMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLImageResliceMapper');\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model._openGLImageSlice = publicAPI.getFirstAncestorOfType('vtkOpenGLImageSlice');\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      const ren = model._openGLRenderer.getRenderable();\n      model._openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n    }\n  };\n  publicAPI.translucentPass = (prepass, renderPass) => {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n  publicAPI.zBufferPass = prepass => {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n  publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);\n  publicAPI.opaquePass = prepass => {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n  publicAPI.getCoincidentParameters = (ren, actor) => {\n    if (model.renderable.getResolveCoincidentTopology()) {\n      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n    }\n    return null;\n  };\n\n  // Renders myself\n  publicAPI.render = () => {\n    const actor = model._openGLImageSlice.getRenderable();\n    const ren = model._openGLRenderer.getRenderable();\n    publicAPI.renderPiece(ren, actor);\n  };\n  publicAPI.renderPiece = (ren, actor) => {\n    publicAPI.invokeEvent({\n      type: 'StartEvent'\n    });\n    model.renderable.update();\n    model.currentInput = model.renderable.getInputData();\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n    publicAPI.updateResliceGeometry();\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n    publicAPI.invokeEvent({\n      type: 'EndEvent'\n    });\n  };\n  publicAPI.renderPieceStart = (ren, actor) => {\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor);\n    const iType = actor.getProperty().getInterpolationType();\n    if (iType === InterpolationType.NEAREST) {\n      model.openGLTexture.setMinificationFilter(Filter.NEAREST);\n      model.openGLTexture.setMagnificationFilter(Filter.NEAREST);\n      model.colorTexture.setMinificationFilter(Filter.NEAREST);\n      model.colorTexture.setMagnificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMinificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMagnificationFilter(Filter.NEAREST);\n    } else {\n      model.openGLTexture.setMinificationFilter(Filter.LINEAR);\n      model.openGLTexture.setMagnificationFilter(Filter.LINEAR);\n      model.colorTexture.setMinificationFilter(Filter.LINEAR);\n      model.colorTexture.setMagnificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMinificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMagnificationFilter(Filter.LINEAR);\n    }\n\n    // No buffer objects bound.\n    model.lastBoundBO = null;\n  };\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const gl = model.context;\n\n    // render the texture\n    model.openGLTexture.activate();\n    model.colorTexture.activate();\n    model.pwfTexture.activate();\n\n    // update shaders if required\n    publicAPI.updateShaders(model.tris, ren, actor);\n\n    // Finally draw\n    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n    model.tris.getVAO().release();\n    model.openGLTexture.deactivate();\n    model.colorTexture.deactivate();\n    model.pwfTexture.deactivate();\n  };\n  publicAPI.renderPieceFinish = (ren, actor) => {};\n  publicAPI.updateBufferObjects = (ren, actor) => {\n    // Rebuild buffer objects if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime() || model.VBOBuildTime.getMTime() < model.resliceGeom.getMTime();\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const image = model.currentInput;\n    if (!image) {\n      return;\n    }\n    const scalars = image.getPointData()?.getScalars();\n    if (!scalars) {\n      return;\n    }\n    if (model._scalars !== scalars) {\n      model._openGLRenderWindow.releaseGraphicsResourcesForObject(model._scalars);\n      model._scalars = scalars;\n    }\n    const numComp = scalars.getNumberOfComponents();\n    let toString = `${image.getMTime()}A${scalars.getMTime()}`;\n    const tex = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);\n    const reBuildTex = !tex?.vtkObj || tex?.hash !== toString || model.openGLTextureString !== toString;\n    if (reBuildTex) {\n      if (!model.openGLTexture) {\n        model.openGLTexture = vtkOpenGLTexture.newInstance();\n        model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n      // Build the image scalar texture\n      const dims = image.getDimensions();\n      // Use norm16 for the 3D texture if the extension is available\n      model.openGLTexture.setOglNorm16Ext(model.context.getExtension('EXT_texture_norm16'));\n      model.openGLTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.openGLTexture.resetFormatAndType();\n      model.openGLTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars);\n      model.openGLTextureString = toString;\n      if (scalars) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(scalars, model.openGLTexture, model.openGLTextureString);\n      }\n    } else {\n      model.openGLTexture = tex.vtkObj;\n      model.openGLTextureString = tex.hash;\n    }\n    const ppty = actor.getProperty();\n    const iComps = ppty.getIndependentComponents();\n    const numIComps = iComps ? numComp : 1;\n    const textureHeight = iComps ? 2 * numIComps : 1;\n    const colorTransferFunc = ppty.getRGBTransferFunction();\n    toString = computeFnToString(ppty, colorTransferFunc, numIComps);\n    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);\n    const reBuildC = !cTex?.vtkObj || cTex?.hash !== toString || model.colorTextureString !== toString;\n    if (reBuildC) {\n      const cWidth = 1024;\n      const cSize = cWidth * textureHeight * 3;\n      const cTable = new Uint8Array(cSize);\n      if (!model.colorTexture) {\n        model.colorTexture = vtkOpenGLTexture.newInstance();\n        model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n      if (colorTransferFunc) {\n        const tmpTable = new Float32Array(cWidth * 3);\n        for (let c = 0; c < numIComps; c++) {\n          const cfun = ppty.getRGBTransferFunction(c);\n          const cRange = cfun.getRange();\n          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);\n          if (iComps) {\n            for (let i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];\n            }\n          } else {\n            for (let i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n            }\n          }\n        }\n        model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);\n        model.colorTexture.resetFormatAndType();\n        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      } else {\n        for (let i = 0; i < cWidth * 3; ++i) {\n          cTable[i] = 255.0 * i / ((cWidth - 1) * 3);\n          cTable[i + 1] = 255.0 * i / ((cWidth - 1) * 3);\n          cTable[i + 2] = 255.0 * i / ((cWidth - 1) * 3);\n        }\n        model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);\n        model.colorTexture.resetFormatAndType();\n        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      }\n      model.colorTextureString = toString;\n      if (colorTransferFunc) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, model.colorTextureString);\n      }\n    } else {\n      model.colorTexture = cTex.vtkObj;\n      model.colorTextureString = cTex.hash;\n    }\n\n    // Build piecewise function buffer.  This buffer is used either\n    // for component weighting or opacity, depending on whether we're\n    // rendering components independently or not.\n    const pwFunc = ppty.getPiecewiseFunction();\n    toString = computeFnToString(ppty, pwFunc, numIComps);\n    const pwfTex = model._openGLRenderWindow.getGraphicsResourceForObject(pwFunc);\n    // rebuild opacity tfun?\n    const reBuildPwf = !pwfTex?.vtkObj || pwfTex?.hash !== toString || model.pwfTextureString !== toString;\n    if (reBuildPwf) {\n      const pwfWidth = 1024;\n      const pwfSize = pwfWidth * textureHeight;\n      const pwfTable = new Uint8Array(pwfSize);\n      if (!model.pwfTexture) {\n        model.pwfTexture = vtkOpenGLTexture.newInstance();\n        model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n      if (pwFunc) {\n        const pwfFloatTable = new Float32Array(pwfSize);\n        const tmpTable = new Float32Array(pwfWidth);\n        for (let c = 0; c < numIComps; ++c) {\n          const pwfun = ppty.getPiecewiseFunction(c);\n          if (pwfun === null) {\n            // Piecewise constant max if no function supplied for this component\n            pwfFloatTable.fill(1.0);\n          } else {\n            const pwfRange = pwfun.getRange();\n            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);\n            // adjust for sample distance etc\n            if (iComps) {\n              for (let i = 0; i < pwfWidth; i++) {\n                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];\n                pwfFloatTable[c * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];\n              }\n            } else {\n              for (let i = 0; i < pwfWidth; i++) {\n                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];\n              }\n            }\n          }\n        }\n        model.pwfTexture.releaseGraphicsResources(model._openGLRenderWindow);\n        model.pwfTexture.resetFormatAndType();\n        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);\n      } else {\n        // default is opaque\n        pwfTable.fill(255.0);\n        model.pwfTexture.releaseGraphicsResources(model._openGLRenderWindow);\n        model.pwfTexture.resetFormatAndType();\n        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);\n      }\n      model.pwfTextureString = toString;\n      if (pwFunc) {\n        model._openGLRenderWindow.setGraphicsResourceForObject(pwFunc, model.pwfTexture, model.pwfTextureString);\n      }\n    } else {\n      model.pwfTexture = pwfTex.vtkObj;\n      model.pwfTextureString = pwfTex.hash;\n    }\n    const vboString = `${model.resliceGeom.getMTime()}A${model.renderable.getSlabThickness()}`;\n    if (!model.tris.getCABO().getElementCount() || model.VBOBuildString !== vboString) {\n      const points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: model.resliceGeom.getPoints().getData()\n      });\n      points.setName('points');\n      const cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: model.resliceGeom.getPolys().getData()\n      });\n      const options = {\n        points,\n        cellOffset: 0\n      };\n      if (model.renderable.getSlabThickness() > 0.0) {\n        const n = model.resliceGeom.getPointData().getNormals();\n        if (!n) {\n          vtkErrorMacro('Slab mode requested without normals');\n        } else {\n          options.normals = n;\n        }\n      }\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, options);\n    }\n    model.VBOBuildString = vboString;\n    model.VBOBuildTime.modified();\n  };\n  publicAPI.updateShaders = (cellBO, ren, actor) => {\n    model.lastBoundBO = cellBO;\n\n    // has something changed that would require us to recreate the shader?\n    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {\n      const shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      publicAPI.buildShaders(shaders, ren, actor);\n\n      // compile and bind the program if needed\n      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);\n\n      // if the shader changed reinitialize the VAO\n      if (newShader !== cellBO.getProgram()) {\n        cellBO.setProgram(newShader);\n        // reset the VAO as the shader has changed\n        cellBO.getVAO().releaseGraphicsResources();\n      }\n      cellBO.getShaderSourceTime().modified();\n    } else {\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());\n    }\n    cellBO.getVAO().bind();\n    publicAPI.setMapperShaderParameters(cellBO, ren, actor);\n    publicAPI.setCameraShaderParameters(cellBO, ren, actor);\n    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      // Set the 3D texture\n      if (program.isUniformUsed('texture1')) {\n        program.setUniformi('texture1', model.openGLTexture.getTextureUnit());\n      }\n\n      // Set the plane vertex attributes\n      if (program.isAttributeUsed('vertexWC')) {\n        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), 'vertexWC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexWC in shader VAO.');\n        }\n      }\n\n      // If we are doing slab mode, we need normals\n      if (program.isAttributeUsed('normalWC')) {\n        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), 'normalWC', cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting normalWC in shader VAO.');\n        }\n      }\n      if (program.isUniformUsed('slabThickness')) {\n        program.setUniformf('slabThickness', model.renderable.getSlabThickness());\n      }\n      if (program.isUniformUsed('spacing')) {\n        program.setUniform3fv('spacing', model.currentInput.getSpacing());\n      }\n      if (program.isUniformUsed('slabType')) {\n        program.setUniformi('slabType', model.renderable.getSlabType());\n      }\n      if (program.isUniformUsed('slabType')) {\n        program.setUniformi('slabType', model.renderable.getSlabType());\n      }\n      if (program.isUniformUsed('slabTrapezoid')) {\n        program.setUniformi('slabTrapezoid', model.renderable.getSlabTrapezoidIntegration());\n      }\n      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n\n      // Set the world->texture matrix\n      if (program.isUniformUsed('WCTCMatrix')) {\n        const image = model.currentInput;\n        const dim = image.getDimensions();\n        mat4.copy(model.tmpMat4, image.getIndexToWorld());\n        mat4.scale(model.tmpMat4, model.tmpMat4, dim);\n        mat4.invert(model.tmpMat4, model.tmpMat4);\n        if (inverseShiftScaleMatrix) {\n          mat4.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);\n        }\n        program.setUniformMatrix('WCTCMatrix', model.tmpMat4);\n      }\n      if (program.isUniformUsed('vboScaling')) {\n        program.setUniform3fv('vboScaling', cellBO.getCABO().getCoordScale());\n      }\n      cellBO.getAttributeUpdateTime().modified();\n    }\n\n    // Depth request\n    if (model.haveSeenDepthRequest) {\n      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    }\n\n    // handle coincident\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      const cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset);\n      // cfactor isn't always used when coffset is.\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    }\n  };\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    // [WMVP]C == {world, model, view, projection} coordinates\n    // e.g. WCPC == world to projection coordinate transformation\n    const keyMats = model._openGLCamera.getKeyMatrices(ren);\n    const actMats = model._openGLImageSlice.getKeyMatrices();\n    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n    const program = cellBO.getProgram();\n    if (program.isUniformUsed('MCPCMatrix')) {\n      mat4.identity(model.tmpMat4);\n      program.setUniformMatrix('MCPCMatrix', safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n    if (program.isUniformUsed('MCVCMatrix')) {\n      mat4.identity(model.tmpMat4);\n      program.setUniformMatrix('MCVCMatrix', safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n  };\n  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    const ppty = actor.getProperty();\n    const opacity = ppty.getOpacity();\n    program.setUniformf('opacity', opacity);\n\n    // Component mix\n    // Independent components: Mixed according to component weights\n    // Dependent components: Mixed using the following logic:\n    //    - 2 comps => LA\n    //    - 3 comps => RGB + opacity from pwf\n    //    - 4 comps => RGBA\n    const numComp = model.openGLTexture.getComponents();\n    const iComps = ppty.getIndependentComponents();\n    if (iComps) {\n      for (let i = 0; i < numComp; ++i) {\n        program.setUniformf(`mix${i}`, ppty.getComponentWeight(i));\n      }\n    }\n\n    // Color opacity map\n    const volInfo = model.openGLTexture.getVolumeInfo();\n\n    // three levels of shift scale combined into one\n    // for performance in the fragment shader\n    for (let i = 0; i < numComp; i++) {\n      let cw = ppty.getColorWindow();\n      let cl = ppty.getColorLevel();\n      const target = iComps ? i : 0;\n      const cfun = ppty.getRGBTransferFunction(target);\n      if (cfun && ppty.getUseLookupTableScalarRange()) {\n        const cRange = cfun.getRange();\n        cw = cRange[1] - cRange[0];\n        cl = 0.5 * (cRange[1] + cRange[0]);\n      }\n      const scale = volInfo.scale[i] / cw;\n      const shift = (volInfo.offset[i] - cl) / cw + 0.5;\n      program.setUniformf(`cshift${i}`, shift);\n      program.setUniformf(`cscale${i}`, scale);\n    }\n    const texColorUnit = model.colorTexture.getTextureUnit();\n    program.setUniformi('colorTexture1', texColorUnit);\n\n    // pwf shift/scale\n    for (let i = 0; i < numComp; i++) {\n      let pwfScale = 1.0;\n      let pwfShift = 0.0;\n      const target = iComps ? i : 0;\n      const pwfun = ppty.getPiecewiseFunction(target);\n      if (pwfun) {\n        const pwfRange = pwfun.getRange();\n        const length = pwfRange[1] - pwfRange[0];\n        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);\n        pwfScale = volInfo.scale[i] / length;\n        pwfShift = (volInfo.offset[i] - mid) / length + 0.5;\n      }\n      program.setUniformf(`pwfshift${i}`, pwfShift);\n      program.setUniformf(`pwfscale${i}`, pwfScale);\n    }\n    const texOpacityUnit = model.pwfTexture.getTextureUnit();\n    program.setUniformi('pwfTexture1', texOpacityUnit);\n\n    // Background color\n    program.setUniform4fv('backgroundColor', model.renderable.getBackgroundColor());\n  };\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    // render pass shader replacement changed\n    const tNumComp = model.openGLTexture.getComponents();\n    const iComp = actor.getProperty().getIndependentComponents();\n    const slabTh = model.renderable.getSlabThickness();\n    const slabType = model.renderable.getSlabType();\n    const slabTrap = model.renderable.getSlabTrapezoidIntegration();\n\n    // has the render pass shader replacement changed? Two options\n    let needRebuild = false;\n    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {\n      needRebuild = true;\n    }\n    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram()?.getHandle() === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp || model.lastSlabThickness !== slabTh || model.lastSlabType !== slabType || model.lastSlabTrapezoidIntegration !== slabTrap) {\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      model.lastTextureComponents = tNumComp;\n      model.lastIndependentComponents = iComp;\n      model.lastSlabThickness = slabTh;\n      model.lastSlabType = slabType;\n      model.lastSlabTrapezoidIntegration = slabTrap;\n      return true;\n    }\n    return false;\n  };\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkImageResliceMapperVS;\n    shaders.Fragment = vtkImageResliceMapperFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    publicAPI.replaceShaderTCoord(shaders, ren, actor);\n    publicAPI.replaceShaderPositionVC(shaders, ren, actor);\n    if (model.haveSeenDepthRequest) {\n      let FSSource = shaders.Fragment;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n      shaders.Fragment = FSSource;\n    }\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n  };\n  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    const GSSource = shaders.Geometry;\n    let FSSource = shaders.Fragment;\n    const tcoordVSDec = ['uniform mat4 WCTCMatrix;', 'out vec3 fragTexCoord;'];\n    const slabThickness = model.renderable.getSlabThickness();\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', tcoordVSDec).result;\n    const tcoordVSImpl = ['fragTexCoord = (WCTCMatrix * vertexWC).xyz;'];\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', tcoordVSImpl).result;\n    const tNumComp = model.openGLTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n    let tcoordFSDec = ['in vec3 fragTexCoord;', 'uniform highp sampler3D texture1;', 'uniform mat4 WCTCMatrix;',\n    // color shift and scale\n    'uniform float cshift0;', 'uniform float cscale0;',\n    // pwf shift and scale\n    'uniform float pwfshift0;', 'uniform float pwfscale0;',\n    // color and pwf textures\n    'uniform sampler2D colorTexture1;', 'uniform sampler2D pwfTexture1;',\n    // opacity\n    'uniform float opacity;',\n    // background color\n    'uniform vec4 backgroundColor;'];\n    if (iComps) {\n      for (let comp = 1; comp < tNumComp; comp++) {\n        tcoordFSDec = tcoordFSDec.concat([\n        // color shift and scale\n        `uniform float cshift${comp};`, `uniform float cscale${comp};`,\n        // weighting shift and scale\n        `uniform float pwfshift${comp};`, `uniform float pwfscale${comp};`]);\n      }\n      // the heights defined below are the locations\n      // for the up to four components of the tfuns\n      // the tfuns have a height of 2XnumComps pixels so the\n      // values are computed to hit the middle of the two rows\n      // for that component\n      switch (tNumComp) {\n        case 1:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', '#define height0 0.5']);\n          break;\n        case 2:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', '#define height0 0.25', '#define height1 0.75']);\n          break;\n        case 3:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', '#define height0 0.17', '#define height1 0.5', '#define height2 0.83']);\n          break;\n        case 4:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', 'uniform float mix3;', '#define height0 0.125', '#define height1 0.375', '#define height2 0.625', '#define height3 0.875']);\n          break;\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n    }\n    if (slabThickness > 0.0) {\n      tcoordFSDec = tcoordFSDec.concat(['uniform vec3 spacing;', 'uniform float slabThickness;', 'uniform int slabType;', 'uniform int slabTrapezoid;', 'uniform vec3 vboScaling;']);\n      tcoordFSDec = tcoordFSDec.concat(['vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)', '{', '  vec4 retVal = vec4(1.0);', '  if (slabType == 0) // min', '  {', '    retVal = min(currVal, valToComp);', '  }', '  else if (slabType == 1) // max', '  {', '    retVal = max(currVal, valToComp);', '  }', '  else if (slabType == 3) // sum', '  {', '    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ', '  }', '  else // mean', '  {', '    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ', '  }', '  return retVal;', '}']);\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', tcoordFSDec).result;\n    let tcoordFSImpl = ['if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))', '{', '  // set the background color and exit', '  gl_FragData[0] = backgroundColor;', '  return;', '}', 'vec4 tvalue = texture(texture1, fragTexCoord);'];\n    if (slabThickness > 0.0) {\n      tcoordFSImpl = tcoordFSImpl.concat(['// Get the first and last samples', 'int numSlices = 1;', 'float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;', 'vec3 normalxspacing = scaling * normalWCVSOutput;', 'float distTraveled = length(normalxspacing);', 'int trapezoid = 0;', 'while (distTraveled < slabThickness * 0.5)', '{', '  distTraveled += length(normalxspacing);', '  float fnumSlices = float(numSlices);', '  if (distTraveled > slabThickness * 0.5)', '  {', '    // Before stepping outside the slab, sample at the boundaries', '    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;', '    trapezoid = slabTrapezoid;', '  }', '  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;', '  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))', '  {', '    vec4 newVal = texture(texture1, fragTCoordNeg);', '    tvalue = compositeValue(tvalue, newVal, trapezoid);', '    numSlices += 1;', '  }', '  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;', '  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))', '  {', '    vec4 newVal = texture(texture1, fragTCoordPos);', '    tvalue = compositeValue(tvalue, newVal, trapezoid);', '    numSlices += 1;', '  }', '}', '// Finally, if slab type is *mean*, divide the sum by the numSlices', 'if (slabType == 2)', '{', '  tvalue = tvalue / float(numSlices);', '}']);\n    }\n    if (iComps) {\n      const rgba = ['r', 'g', 'b', 'a'];\n      for (let comp = 0; comp < tNumComp; ++comp) {\n        tcoordFSImpl = tcoordFSImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);\n      }\n      switch (tNumComp) {\n        case 1:\n          tcoordFSImpl = tcoordFSImpl.concat(['gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);']);\n          break;\n        case 2:\n          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);']);\n          break;\n        case 3:\n          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);']);\n          break;\n        case 4:\n          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);']);\n          break;\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n    } else {\n      // dependent components\n      switch (tNumComp) {\n        case 1:\n          tcoordFSImpl = tcoordFSImpl.concat(['// Dependent components', 'float intensity = tvalue.r;', 'vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;', 'float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;', 'gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);']);\n          break;\n        case 2:\n          tcoordFSImpl = tcoordFSImpl.concat(['float intensity = tvalue.r*cscale0 + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);']);\n          break;\n        case 3:\n          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);']);\n          break;\n        default:\n          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);']);\n      }\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', tcoordFSImpl).result;\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    shaders.Geometry = GSSource;\n  };\n  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    const GSSource = shaders.Geometry;\n    let FSSource = shaders.Fragment;\n    const slabThickness = model.renderable.getSlabThickness();\n    let posVCVSDec = ['attribute vec4 vertexWC;'];\n    // Add a unique hash to the shader to ensure that the shader program is unique to this mapper.\n    posVCVSDec = posVCVSDec.concat([`//${publicAPI.getMTime()}${model.resliceGeomUpdateString}`]);\n    if (slabThickness > 0.0) {\n      posVCVSDec = posVCVSDec.concat(['attribute vec3 normalWC;', 'varying vec3 normalWCVSOutput;', 'varying vec4 vertexWCVSOutput;']);\n    }\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', posVCVSDec).result;\n    let posVCVSImpl = ['gl_Position = MCPCMatrix * vertexWC;'];\n    if (slabThickness > 0.0) {\n      posVCVSImpl = posVCVSImpl.concat(['normalWCVSOutput = normalWC;', 'vertexWCVSOutput = vertexWC;']);\n    }\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', posVCVSImpl).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;\n    let posVCFSDec = [];\n    if (slabThickness > 0.0) {\n      posVCFSDec = posVCFSDec.concat(['varying vec3 normalWCVSOutput;', 'varying vec4 vertexWCVSOutput;']);\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Dec', posVCFSDec).result;\n    shaders.Vertex = VSSource;\n    shaders.Geometry = GSSource;\n    shaders.Fragment = FSSource;\n  };\n  function isVectorAxisAligned(n) {\n    vtkMath.normalize(n);\n    const tmpN = [0, 0, 0];\n    for (let i = 0; i < 3; ++i) {\n      vec3.zero(tmpN);\n      tmpN[i] = 1.0;\n      const dotP = vtkMath.dot(n, tmpN);\n      if (dotP < -0.999 || dotP > 0.999) {\n        return [true, i];\n      }\n    }\n    return [false, 2];\n  }\n  publicAPI.updateResliceGeometry = () => {\n    let resGeomString = '';\n    const image = model.currentInput;\n    const imageBounds = image?.getBounds();\n    // Orthogonal slicing by default\n    let orthoSlicing = true;\n    let orthoAxis = 2;\n    const slicePD = model.renderable.getSlicePolyData();\n    const slicePlane = model.renderable.getSlicePlane();\n    if (slicePD) {\n      resGeomString = resGeomString.concat(`PolyData${slicePD.getMTime()}`);\n    } else if (slicePlane) {\n      resGeomString = resGeomString.concat(`Plane${slicePlane.getMTime()}`);\n      if (image) {\n        resGeomString = resGeomString.concat(`Image${image.getMTime()}`);\n      }\n      // Check to see if we can bypass oblique slicing related bounds computation\n      // Compute a world-to-image-orientation matrix.\n      // Ignore the translation component since we are\n      // using it on vectors rather than positions.\n      const w2io = mat3.fromValues(image?.getDirection());\n      mat3.invert(w2io, w2io);\n      // transform the cutting plane normal to image local coords\n      const imageLocalNormal = [...slicePlane.getNormal()];\n      vec3.transformMat3(imageLocalNormal, imageLocalNormal, w2io);\n      [orthoSlicing, orthoAxis] = isVectorAxisAligned(imageLocalNormal);\n    } else {\n      // Create a default slice plane here\n      const plane = vtkPlane.newInstance();\n      plane.setNormal(0, 0, 1);\n      let bds = [0, 1, 0, 1, 0, 1];\n      if (image) {\n        bds = imageBounds;\n      }\n      plane.setOrigin(bds[0], bds[2], 0.5 * (bds[5] + bds[4]));\n      model.renderable.setSlicePlane(plane);\n      resGeomString = resGeomString.concat(`Plane${slicePlane?.getMTime()}`);\n      if (image) {\n        resGeomString = resGeomString.concat(`Image${image.getMTime()}`);\n      }\n    }\n    if (!model.resliceGeom || model.resliceGeomUpdateString !== resGeomString) {\n      if (slicePD) {\n        if (!model.resliceGeom) {\n          model.resliceGeom = vtkPolyData.newInstance();\n        }\n        model.resliceGeom.getPoints().setData(slicePD.getPoints().getData(), 3);\n        model.resliceGeom.getPolys().setData(slicePD.getPolys().getData(), 1);\n        model.resliceGeom.getPointData().setNormals(slicePD.getPointData().getNormals());\n      } else if (slicePlane) {\n        if (!orthoSlicing) {\n          model.outlineFilter.setInputData(image);\n          model.cutter.setInputConnection(model.outlineFilter.getOutputPort());\n          model.cutter.setCutFunction(slicePlane);\n          model.lineToSurfaceFilter.setInputConnection(model.cutter.getOutputPort());\n          model.lineToSurfaceFilter.update();\n          if (!model.resliceGeom) {\n            model.resliceGeom = vtkPolyData.newInstance();\n          }\n          const planePD = model.lineToSurfaceFilter.getOutputData();\n          model.resliceGeom.getPoints().setData(planePD.getPoints().getData(), 3);\n          model.resliceGeom.getPolys().setData(planePD.getPolys().getData(), 1);\n          model.resliceGeom.getPointData().setNormals(planePD.getPointData().getNormals());\n          // The above method does not generate point normals\n          // Set it manually here.\n          const n = slicePlane.getNormal();\n          const npts = model.resliceGeom.getNumberOfPoints();\n          vtkMath.normalize(n);\n          const normalsData = new Float32Array(npts * 3);\n          for (let i = 0; i < npts; ++i) {\n            normalsData[3 * i] = n[0];\n            normalsData[3 * i + 1] = n[1];\n            normalsData[3 * i + 2] = n[2];\n          }\n          const normals = vtkDataArray.newInstance({\n            numberOfComponents: 3,\n            values: normalsData,\n            name: 'Normals'\n          });\n          model.resliceGeom.getPointData().setNormals(normals);\n        } else {\n          // Since the image-local normal is axis-aligned, we\n          // can quickly construct the cutting plane using indexToWorld transforms.\n          const ptsArray = new Float32Array(12);\n          const indexSpacePlaneOrigin = image.worldToIndex(slicePlane.getOrigin(), [0, 0, 0]);\n          const otherAxes = [(orthoAxis + 1) % 3, (orthoAxis + 2) % 3].sort();\n          const dim = image.getDimensions();\n          const ext = [0, dim[0] - 1, 0, dim[1] - 1, 0, dim[2] - 1];\n          let ptIdx = 0;\n          for (let i = 0; i < 2; ++i) {\n            for (let j = 0; j < 2; ++j) {\n              ptsArray[ptIdx + orthoAxis] = indexSpacePlaneOrigin[orthoAxis];\n              ptsArray[ptIdx + otherAxes[0]] = ext[2 * otherAxes[0] + j];\n              ptsArray[ptIdx + otherAxes[1]] = ext[2 * otherAxes[1] + i];\n              ptIdx += 3;\n            }\n          }\n          model.transform.setMatrix(image.getIndexToWorld());\n          model.transform.transformPoints(ptsArray, ptsArray);\n          const cellArray = new Uint16Array(8);\n          cellArray[0] = 3;\n          cellArray[1] = 0;\n          cellArray[2] = 1;\n          cellArray[3] = 3;\n          cellArray[4] = 3;\n          cellArray[5] = 0;\n          cellArray[6] = 3;\n          cellArray[7] = 2;\n          const n = slicePlane.getNormal();\n          vtkMath.normalize(n);\n          const normalsData = new Float32Array(12);\n          for (let i = 0; i < 4; ++i) {\n            normalsData[3 * i] = n[0];\n            normalsData[3 * i + 1] = n[1];\n            normalsData[3 * i + 2] = n[2];\n          }\n          if (!model.resliceGeom) {\n            model.resliceGeom = vtkPolyData.newInstance();\n          }\n          model.resliceGeom.getPoints().setData(ptsArray, 3);\n          model.resliceGeom.getPolys().setData(cellArray, 1);\n          const normals = vtkDataArray.newInstance({\n            numberOfComponents: 3,\n            values: normalsData,\n            name: 'Normals'\n          });\n          model.resliceGeom.getPointData().setNormals(normals);\n        }\n      } else {\n        vtkErrorMacro('Something went wrong.', 'A default slice plane should have been created in the beginning of', 'updateResliceGeometry.');\n      }\n      model.resliceGeomUpdateString = resGeomString;\n      model.resliceGeom?.modified();\n    }\n  };\n  publicAPI.setOpenGLTexture = oglTex => {\n    if (oglTex) {\n      model.openGLTexture = oglTex;\n      model._externalOpenGLTexture = true;\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  VBOBuildTime: {},\n  VBOBuildString: null,\n  haveSeenDepthRequest: false,\n  lastHaveSeenDepthRequest: false,\n  lastIndependentComponents: false,\n  lastTextureComponents: 0,\n  lastSlabThickness: 0,\n  lastSlabTrapezoidIntegration: 0,\n  lastSlabType: -1,\n  openGLTexture: null,\n  openGLTextureString: null,\n  colorTextureString: null,\n  pwfTextureString: null,\n  resliceGeom: null,\n  resliceGeomUpdateString: null,\n  tris: null,\n  colorTexture: null,\n  pwfTexture: null,\n  _externalOpenGLTexture: false,\n  _scalars: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);\n  model.tris = vtkHelper.newInstance();\n  model.openGLTexture = null;\n  model.colorTexture = null;\n  model.pwfTexture = null;\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime);\n  model.tmpMat4 = mat4.identity(new Float64Array(16));\n\n  // Implicit plane to polydata related cache:\n  model.outlineFilter = vtkImageDataOutlineFilter.newInstance();\n  model.outlineFilter.setGenerateFaces(true);\n  model.outlineFilter.setGenerateLines(false);\n  model.cubePolyData = vtkPolyData.newInstance();\n  model.cutter = vtkCutter.newInstance();\n  model.lineToSurfaceFilter = vtkClosedPolyLineToSurfaceFilter.newInstance();\n  model.transform = vtkTransform.newInstance();\n  get(publicAPI, model, ['openGLTexture']);\n\n  // Object methods\n  vtkOpenGLImageResliceMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLImageResliceMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageResliceMapper = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkImageResliceMapper', newInstance);\n\nexport { vtkImageResliceMapper as default, extend, newInstance };\n"],"mappings":"AAAA,SAASA,CAAC,IAAIC,aAAa,EAAEC,CAAC,IAAIC,GAAG,EAAEC,CAAC,IAAIC,GAAG,EAAEC,CAAC,IAAIC,KAAK,QAAQ,kBAAkB;AACrF,SAASC,IAAI,EAAEC,IAAI,EAAEC,IAAI,QAAQ,WAAW;AAC5C,OAAOC,gCAAgC,MAAM,wDAAwD;AACrG,OAAOC,SAAS,MAAM,8BAA8B;AACpD,OAAOC,YAAY,MAAM,gCAAgC;AACzD,OAAOC,SAAS,MAAM,aAAa;AACnC,OAAOC,yBAAyB,MAAM,iDAAiD;AACvF,SAASC,CAAC,IAAIC,OAAO,QAAQ,iCAAiC;AAC9D,OAAOC,gBAAgB,MAAM,cAAc;AAC3C,OAAOC,QAAQ,MAAM,iCAAiC;AACtD,OAAOC,WAAW,MAAM,oCAAoC;AAC5D,OAAOC,0BAA0B,MAAM,8BAA8B;AACrE,OAAOC,gBAAgB,MAAM,oBAAoB;AACjD,OAAOC,YAAY,MAAM,qCAAqC;AAC9D,OAAOC,WAAW,MAAM,2BAA2B;AACnD,SAASC,CAAC,IAAIC,uBAAuB,QAAQ,wCAAwC;AACrF,SAASD,CAAC,IAAIE,uBAAuB,QAAQ,wCAAwC;AACrF,SAASC,MAAM,QAAQ,wBAAwB;AAC/C,SAASC,iBAAiB,QAAQ,oCAAoC;AACtE,SAASC,cAAc,QAAQ,+BAA+B;AAC9D,SAASC,YAAY,QAAQ,0CAA0C;AACvE,SAASC,gBAAgB,QAAQ,sBAAsB;AAEvD,MAAM;EACJC;AACF,CAAC,GAAG1B,KAAK;;AAET;AACA;AACA;;AAEA,SAAS2B,iBAAiBA,CAACC,QAAQ,EAAEC,KAAK,EAAEC,kBAAkB,EAAE;EAC9D,IAAID,KAAK,EAAE;IACT,MAAME,MAAM,GAAGH,QAAQ,CAACI,wBAAwB,CAAC,CAAC;IAClD,OAAQ,GAAEH,KAAK,CAACI,QAAQ,CAAC,CAAE,IAAGF,MAAO,IAAGD,kBAAmB,EAAC;EAC9D;EACA,OAAO,GAAG;AACZ;AACA,SAASI,kBAAkBA,CAACC,WAAW,EAAEC,UAAU,EAAEC,MAAM,EAAE;EAC3DD,UAAU,CAACE,QAAQ,CAACD,MAAM,CAAC;EAC3B,OAAOF,WAAW,CAACI,MAAM,CAAC,CAACC,GAAG,EAAEC,MAAM,EAAEC,KAAK,KAAK;IAChD,IAAIA,KAAK,KAAK,CAAC,EAAE;MACf,OAAOD,MAAM,GAAGL,UAAU,CAACO,IAAI,CAACH,GAAG,EAAEC,MAAM,CAAC,GAAGL,UAAU,CAACE,QAAQ,CAACE,GAAG,CAAC;IACzE;IACA,OAAOC,MAAM,GAAGL,UAAU,CAACQ,QAAQ,CAACJ,GAAG,EAAEA,GAAG,EAAEC,MAAM,CAAC,GAAGD,GAAG;EAC7D,CAAC,EAAEH,MAAM,CAAC;AACZ;;AAEA;AACA;AACA;;AAEA,SAASQ,2BAA2BA,CAACC,SAAS,EAAEC,KAAK,EAAE;EACrD;EACAA,KAAK,CAACC,cAAc,CAACC,IAAI,CAAC,6BAA6B,CAAC;EACxDH,SAAS,CAACI,SAAS,GAAGC,OAAO,IAAI;IAC/B,IAAIA,OAAO,EAAE;MACXJ,KAAK,CAACK,iBAAiB,GAAG,IAAI;MAC9BL,KAAK,CAACM,iBAAiB,GAAGP,SAAS,CAACQ,sBAAsB,CAAC,qBAAqB,CAAC;MACjFP,KAAK,CAACQ,eAAe,GAAGT,SAAS,CAACQ,sBAAsB,CAAC,mBAAmB,CAAC;MAC7E,MAAME,GAAG,GAAGT,KAAK,CAACQ,eAAe,CAACE,aAAa,CAAC,CAAC;MACjDV,KAAK,CAACW,aAAa,GAAGX,KAAK,CAACQ,eAAe,CAACI,cAAc,CAACH,GAAG,CAACI,eAAe,CAAC,CAAC,CAAC;MACjFb,KAAK,CAACc,mBAAmB,GAAGd,KAAK,CAACQ,eAAe,CAACO,SAAS,CAAC,CAAC;MAC7Df,KAAK,CAACgB,OAAO,GAAGhB,KAAK,CAACc,mBAAmB,CAACG,UAAU,CAAC,CAAC;MACtDjB,KAAK,CAACkB,IAAI,CAACC,qBAAqB,CAACnB,KAAK,CAACc,mBAAmB,CAAC;IAC7D;EACF,CAAC;EACDf,SAAS,CAACqB,eAAe,GAAG,CAAChB,OAAO,EAAEiB,UAAU,KAAK;IACnD,IAAIjB,OAAO,EAAE;MACXJ,KAAK,CAACK,iBAAiB,GAAGgB,UAAU;MACpCtB,SAAS,CAACuB,MAAM,CAAC,CAAC;IACpB;EACF,CAAC;EACDvB,SAAS,CAACwB,WAAW,GAAGnB,OAAO,IAAI;IACjC,IAAIA,OAAO,EAAE;MACXJ,KAAK,CAACwB,oBAAoB,GAAG,IAAI;MACjCxB,KAAK,CAACyB,WAAW,GAAG,IAAI;MACxB1B,SAAS,CAACuB,MAAM,CAAC,CAAC;MAClBtB,KAAK,CAACyB,WAAW,GAAG,KAAK;IAC3B;EACF,CAAC;EACD1B,SAAS,CAAC2B,iBAAiB,GAAGtB,OAAO,IAAIL,SAAS,CAACwB,WAAW,CAACnB,OAAO,CAAC;EACvEL,SAAS,CAAC4B,UAAU,GAAGvB,OAAO,IAAI;IAChC,IAAIA,OAAO,EAAE;MACXL,SAAS,CAACuB,MAAM,CAAC,CAAC;IACpB;EACF,CAAC;EACDvB,SAAS,CAAC6B,uBAAuB,GAAG,CAACnB,GAAG,EAAEoB,KAAK,KAAK;IAClD,IAAI7B,KAAK,CAAC8B,UAAU,CAACC,4BAA4B,CAAC,CAAC,EAAE;MACnD,OAAO/B,KAAK,CAAC8B,UAAU,CAACE,4CAA4C,CAAC,CAAC;IACxE;IACA,OAAO,IAAI;EACb,CAAC;;EAED;EACAjC,SAAS,CAACuB,MAAM,GAAG,MAAM;IACvB,MAAMO,KAAK,GAAG7B,KAAK,CAACM,iBAAiB,CAACI,aAAa,CAAC,CAAC;IACrD,MAAMD,GAAG,GAAGT,KAAK,CAACQ,eAAe,CAACE,aAAa,CAAC,CAAC;IACjDX,SAAS,CAACkC,WAAW,CAACxB,GAAG,EAAEoB,KAAK,CAAC;EACnC,CAAC;EACD9B,SAAS,CAACkC,WAAW,GAAG,CAACxB,GAAG,EAAEoB,KAAK,KAAK;IACtC9B,SAAS,CAACmC,WAAW,CAAC;MACpBC,IAAI,EAAE;IACR,CAAC,CAAC;IACFnC,KAAK,CAAC8B,UAAU,CAACM,MAAM,CAAC,CAAC;IACzBpC,KAAK,CAACqC,YAAY,GAAGrC,KAAK,CAAC8B,UAAU,CAACQ,YAAY,CAAC,CAAC;IACpD,IAAI,CAACtC,KAAK,CAACqC,YAAY,EAAE;MACvB1D,aAAa,CAAC,WAAW,CAAC;MAC1B;IACF;IACAoB,SAAS,CAACwC,qBAAqB,CAAC,CAAC;IACjCxC,SAAS,CAACyC,gBAAgB,CAAC/B,GAAG,EAAEoB,KAAK,CAAC;IACtC9B,SAAS,CAAC0C,eAAe,CAAChC,GAAG,EAAEoB,KAAK,CAAC;IACrC9B,SAAS,CAAC2C,iBAAiB,CAACjC,GAAG,EAAEoB,KAAK,CAAC;IACvC9B,SAAS,CAACmC,WAAW,CAAC;MACpBC,IAAI,EAAE;IACR,CAAC,CAAC;EACJ,CAAC;EACDpC,SAAS,CAACyC,gBAAgB,GAAG,CAAC/B,GAAG,EAAEoB,KAAK,KAAK;IAC3C;IACA9B,SAAS,CAAC4C,mBAAmB,CAAClC,GAAG,EAAEoB,KAAK,CAAC;IACzC,MAAMe,KAAK,GAAGf,KAAK,CAACgB,WAAW,CAAC,CAAC,CAACC,oBAAoB,CAAC,CAAC;IACxD,IAAIF,KAAK,KAAKrE,iBAAiB,CAACwE,OAAO,EAAE;MACvC/C,KAAK,CAACgD,aAAa,CAACC,qBAAqB,CAAC3E,MAAM,CAACyE,OAAO,CAAC;MACzD/C,KAAK,CAACgD,aAAa,CAACE,sBAAsB,CAAC5E,MAAM,CAACyE,OAAO,CAAC;MAC1D/C,KAAK,CAACmD,YAAY,CAACF,qBAAqB,CAAC3E,MAAM,CAACyE,OAAO,CAAC;MACxD/C,KAAK,CAACmD,YAAY,CAACD,sBAAsB,CAAC5E,MAAM,CAACyE,OAAO,CAAC;MACzD/C,KAAK,CAACoD,UAAU,CAACH,qBAAqB,CAAC3E,MAAM,CAACyE,OAAO,CAAC;MACtD/C,KAAK,CAACoD,UAAU,CAACF,sBAAsB,CAAC5E,MAAM,CAACyE,OAAO,CAAC;IACzD,CAAC,MAAM;MACL/C,KAAK,CAACgD,aAAa,CAACC,qBAAqB,CAAC3E,MAAM,CAAC+E,MAAM,CAAC;MACxDrD,KAAK,CAACgD,aAAa,CAACE,sBAAsB,CAAC5E,MAAM,CAAC+E,MAAM,CAAC;MACzDrD,KAAK,CAACmD,YAAY,CAACF,qBAAqB,CAAC3E,MAAM,CAAC+E,MAAM,CAAC;MACvDrD,KAAK,CAACmD,YAAY,CAACD,sBAAsB,CAAC5E,MAAM,CAAC+E,MAAM,CAAC;MACxDrD,KAAK,CAACoD,UAAU,CAACH,qBAAqB,CAAC3E,MAAM,CAAC+E,MAAM,CAAC;MACrDrD,KAAK,CAACoD,UAAU,CAACF,sBAAsB,CAAC5E,MAAM,CAAC+E,MAAM,CAAC;IACxD;;IAEA;IACArD,KAAK,CAACsD,WAAW,GAAG,IAAI;EAC1B,CAAC;EACDvD,SAAS,CAAC0C,eAAe,GAAG,CAAChC,GAAG,EAAEoB,KAAK,KAAK;IAC1C,MAAM0B,EAAE,GAAGvD,KAAK,CAACgB,OAAO;;IAExB;IACAhB,KAAK,CAACgD,aAAa,CAACQ,QAAQ,CAAC,CAAC;IAC9BxD,KAAK,CAACmD,YAAY,CAACK,QAAQ,CAAC,CAAC;IAC7BxD,KAAK,CAACoD,UAAU,CAACI,QAAQ,CAAC,CAAC;;IAE3B;IACAzD,SAAS,CAAC0D,aAAa,CAACzD,KAAK,CAACkB,IAAI,EAAET,GAAG,EAAEoB,KAAK,CAAC;;IAE/C;IACA0B,EAAE,CAACG,UAAU,CAACH,EAAE,CAACI,SAAS,EAAE,CAAC,EAAE3D,KAAK,CAACkB,IAAI,CAAC0C,OAAO,CAAC,CAAC,CAACC,eAAe,CAAC,CAAC,CAAC;IACtE7D,KAAK,CAACkB,IAAI,CAAC4C,MAAM,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;IAC7B/D,KAAK,CAACgD,aAAa,CAACgB,UAAU,CAAC,CAAC;IAChChE,KAAK,CAACmD,YAAY,CAACa,UAAU,CAAC,CAAC;IAC/BhE,KAAK,CAACoD,UAAU,CAACY,UAAU,CAAC,CAAC;EAC/B,CAAC;EACDjE,SAAS,CAAC2C,iBAAiB,GAAG,CAACjC,GAAG,EAAEoB,KAAK,KAAK,CAAC,CAAC;EAChD9B,SAAS,CAAC4C,mBAAmB,GAAG,CAAClC,GAAG,EAAEoB,KAAK,KAAK;IAC9C;IACA,IAAI9B,SAAS,CAACkE,6BAA6B,CAACxD,GAAG,EAAEoB,KAAK,CAAC,EAAE;MACvD9B,SAAS,CAACmE,kBAAkB,CAACzD,GAAG,EAAEoB,KAAK,CAAC;IAC1C;EACF,CAAC;EACD9B,SAAS,CAACkE,6BAA6B,GAAG,CAACxD,GAAG,EAAEoB,KAAK,KAAK7B,KAAK,CAACmE,YAAY,CAACjF,QAAQ,CAAC,CAAC,GAAGa,SAAS,CAACb,QAAQ,CAAC,CAAC,IAAIc,KAAK,CAACmE,YAAY,CAACjF,QAAQ,CAAC,CAAC,GAAG2C,KAAK,CAAC3C,QAAQ,CAAC,CAAC,IAAIc,KAAK,CAACmE,YAAY,CAACjF,QAAQ,CAAC,CAAC,GAAGc,KAAK,CAAC8B,UAAU,CAAC5C,QAAQ,CAAC,CAAC,IAAIc,KAAK,CAACmE,YAAY,CAACjF,QAAQ,CAAC,CAAC,GAAG2C,KAAK,CAACgB,WAAW,CAAC,CAAC,CAAC3D,QAAQ,CAAC,CAAC,IAAIc,KAAK,CAACmE,YAAY,CAACjF,QAAQ,CAAC,CAAC,GAAGc,KAAK,CAACqC,YAAY,CAACnD,QAAQ,CAAC,CAAC,IAAIc,KAAK,CAACmE,YAAY,CAACjF,QAAQ,CAAC,CAAC,GAAGc,KAAK,CAACoE,WAAW,CAAClF,QAAQ,CAAC,CAAC;EACpaa,SAAS,CAACmE,kBAAkB,GAAG,CAACzD,GAAG,EAAEoB,KAAK,KAAK;IAC7C,MAAMwC,KAAK,GAAGrE,KAAK,CAACqC,YAAY;IAChC,IAAI,CAACgC,KAAK,EAAE;MACV;IACF;IACA,MAAMC,OAAO,GAAGD,KAAK,CAACE,YAAY,CAAC,CAAC,EAAEC,UAAU,CAAC,CAAC;IAClD,IAAI,CAACF,OAAO,EAAE;MACZ;IACF;IACA,IAAItE,KAAK,CAACyE,QAAQ,KAAKH,OAAO,EAAE;MAC9BtE,KAAK,CAACc,mBAAmB,CAAC4D,iCAAiC,CAAC1E,KAAK,CAACyE,QAAQ,CAAC;MAC3EzE,KAAK,CAACyE,QAAQ,GAAGH,OAAO;IAC1B;IACA,MAAMK,OAAO,GAAGL,OAAO,CAACM,qBAAqB,CAAC,CAAC;IAC/C,IAAIC,QAAQ,GAAI,GAAER,KAAK,CAACnF,QAAQ,CAAC,CAAE,IAAGoF,OAAO,CAACpF,QAAQ,CAAC,CAAE,EAAC;IAC1D,MAAM4F,GAAG,GAAG9E,KAAK,CAACc,mBAAmB,CAACiE,4BAA4B,CAACT,OAAO,CAAC;IAC3E,MAAMU,UAAU,GAAG,CAACF,GAAG,EAAEG,MAAM,IAAIH,GAAG,EAAEI,IAAI,KAAKL,QAAQ,IAAI7E,KAAK,CAACmF,mBAAmB,KAAKN,QAAQ;IACnG,IAAIG,UAAU,EAAE;MACd,IAAI,CAAChF,KAAK,CAACgD,aAAa,EAAE;QACxBhD,KAAK,CAACgD,aAAa,GAAGpF,gBAAgB,CAACwH,WAAW,CAAC,CAAC;QACpDpF,KAAK,CAACgD,aAAa,CAAC7B,qBAAqB,CAACnB,KAAK,CAACc,mBAAmB,CAAC;MACtE;MACA;MACA,MAAMuE,IAAI,GAAGhB,KAAK,CAACiB,aAAa,CAAC,CAAC;MAClC;MACAtF,KAAK,CAACgD,aAAa,CAACuC,eAAe,CAACvF,KAAK,CAACgB,OAAO,CAACwE,YAAY,CAAC,oBAAoB,CAAC,CAAC;MACrFxF,KAAK,CAACgD,aAAa,CAACyC,wBAAwB,CAACzF,KAAK,CAACc,mBAAmB,CAAC;MACvEd,KAAK,CAACgD,aAAa,CAAC0C,kBAAkB,CAAC,CAAC;MACxC1F,KAAK,CAACgD,aAAa,CAAC2C,+BAA+B,CAACN,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,EAAEf,OAAO,CAAC;MACvFtE,KAAK,CAACmF,mBAAmB,GAAGN,QAAQ;MACpC,IAAIP,OAAO,EAAE;QACXtE,KAAK,CAACc,mBAAmB,CAAC8E,4BAA4B,CAACtB,OAAO,EAAEtE,KAAK,CAACgD,aAAa,EAAEhD,KAAK,CAACmF,mBAAmB,CAAC;MACjH;IACF,CAAC,MAAM;MACLnF,KAAK,CAACgD,aAAa,GAAG8B,GAAG,CAACG,MAAM;MAChCjF,KAAK,CAACmF,mBAAmB,GAAGL,GAAG,CAACI,IAAI;IACtC;IACA,MAAMW,IAAI,GAAGhE,KAAK,CAACgB,WAAW,CAAC,CAAC;IAChC,MAAM7D,MAAM,GAAG6G,IAAI,CAAC5G,wBAAwB,CAAC,CAAC;IAC9C,MAAM6G,SAAS,GAAG9G,MAAM,GAAG2F,OAAO,GAAG,CAAC;IACtC,MAAMoB,aAAa,GAAG/G,MAAM,GAAG,CAAC,GAAG8G,SAAS,GAAG,CAAC;IAChD,MAAME,iBAAiB,GAAGH,IAAI,CAACI,sBAAsB,CAAC,CAAC;IACvDpB,QAAQ,GAAGjG,iBAAiB,CAACiH,IAAI,EAAEG,iBAAiB,EAAEF,SAAS,CAAC;IAChE,MAAMI,IAAI,GAAGlG,KAAK,CAACc,mBAAmB,CAACiE,4BAA4B,CAACiB,iBAAiB,CAAC;IACtF,MAAMG,QAAQ,GAAG,CAACD,IAAI,EAAEjB,MAAM,IAAIiB,IAAI,EAAEhB,IAAI,KAAKL,QAAQ,IAAI7E,KAAK,CAACoG,kBAAkB,KAAKvB,QAAQ;IAClG,IAAIsB,QAAQ,EAAE;MACZ,MAAME,MAAM,GAAG,IAAI;MACnB,MAAMC,KAAK,GAAGD,MAAM,GAAGN,aAAa,GAAG,CAAC;MACxC,MAAMQ,MAAM,GAAG,IAAIC,UAAU,CAACF,KAAK,CAAC;MACpC,IAAI,CAACtG,KAAK,CAACmD,YAAY,EAAE;QACvBnD,KAAK,CAACmD,YAAY,GAAGvF,gBAAgB,CAACwH,WAAW,CAAC,CAAC;QACnDpF,KAAK,CAACmD,YAAY,CAAChC,qBAAqB,CAACnB,KAAK,CAACc,mBAAmB,CAAC;MACrE;MACA,IAAIkF,iBAAiB,EAAE;QACrB,MAAMS,QAAQ,GAAG,IAAIC,YAAY,CAACL,MAAM,GAAG,CAAC,CAAC;QAC7C,KAAK,IAAIrJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8I,SAAS,EAAE9I,CAAC,EAAE,EAAE;UAClC,MAAM2J,IAAI,GAAGd,IAAI,CAACI,sBAAsB,CAACjJ,CAAC,CAAC;UAC3C,MAAM4J,MAAM,GAAGD,IAAI,CAACE,QAAQ,CAAC,CAAC;UAC9BF,IAAI,CAACG,QAAQ,CAACF,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,EAAEP,MAAM,EAAEI,QAAQ,EAAE,CAAC,CAAC;UACxD,IAAIzH,MAAM,EAAE;YACV,KAAK,IAAI+H,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,MAAM,GAAG,CAAC,EAAEU,CAAC,EAAE,EAAE;cACnCR,MAAM,CAACvJ,CAAC,GAAGqJ,MAAM,GAAG,CAAC,GAAGU,CAAC,CAAC,GAAG,KAAK,GAAGN,QAAQ,CAACM,CAAC,CAAC;cAChDR,MAAM,CAACvJ,CAAC,GAAGqJ,MAAM,GAAG,CAAC,GAAGU,CAAC,GAAGV,MAAM,GAAG,CAAC,CAAC,GAAG,KAAK,GAAGI,QAAQ,CAACM,CAAC,CAAC;YAC/D;UACF,CAAC,MAAM;YACL,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,MAAM,GAAG,CAAC,EAAEU,CAAC,EAAE,EAAE;cACnCR,MAAM,CAACvJ,CAAC,GAAGqJ,MAAM,GAAG,CAAC,GAAGU,CAAC,CAAC,GAAG,KAAK,GAAGN,QAAQ,CAACM,CAAC,CAAC;YAClD;UACF;QACF;QACA/G,KAAK,CAACmD,YAAY,CAACsC,wBAAwB,CAACzF,KAAK,CAACc,mBAAmB,CAAC;QACtEd,KAAK,CAACmD,YAAY,CAACuC,kBAAkB,CAAC,CAAC;QACvC1F,KAAK,CAACmD,YAAY,CAAC6D,eAAe,CAACX,MAAM,EAAEN,aAAa,EAAE,CAAC,EAAEtH,YAAY,CAACwI,aAAa,EAAEV,MAAM,CAAC;MAClG,CAAC,MAAM;QACL,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,MAAM,GAAG,CAAC,EAAE,EAAEU,CAAC,EAAE;UACnCR,MAAM,CAACQ,CAAC,CAAC,GAAG,KAAK,GAAGA,CAAC,IAAI,CAACV,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC;UAC1CE,MAAM,CAACQ,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,GAAGA,CAAC,IAAI,CAACV,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC;UAC9CE,MAAM,CAACQ,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,GAAGA,CAAC,IAAI,CAACV,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC;QAChD;QACArG,KAAK,CAACmD,YAAY,CAACsC,wBAAwB,CAACzF,KAAK,CAACc,mBAAmB,CAAC;QACtEd,KAAK,CAACmD,YAAY,CAACuC,kBAAkB,CAAC,CAAC;QACvC1F,KAAK,CAACmD,YAAY,CAAC6D,eAAe,CAACX,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE5H,YAAY,CAACwI,aAAa,EAAEV,MAAM,CAAC;MACtF;MACAvG,KAAK,CAACoG,kBAAkB,GAAGvB,QAAQ;MACnC,IAAImB,iBAAiB,EAAE;QACrBhG,KAAK,CAACc,mBAAmB,CAAC8E,4BAA4B,CAACI,iBAAiB,EAAEhG,KAAK,CAACmD,YAAY,EAAEnD,KAAK,CAACoG,kBAAkB,CAAC;MACzH;IACF,CAAC,MAAM;MACLpG,KAAK,CAACmD,YAAY,GAAG+C,IAAI,CAACjB,MAAM;MAChCjF,KAAK,CAACoG,kBAAkB,GAAGF,IAAI,CAAChB,IAAI;IACtC;;IAEA;IACA;IACA;IACA,MAAMgC,MAAM,GAAGrB,IAAI,CAACsB,oBAAoB,CAAC,CAAC;IAC1CtC,QAAQ,GAAGjG,iBAAiB,CAACiH,IAAI,EAAEqB,MAAM,EAAEpB,SAAS,CAAC;IACrD,MAAMsB,MAAM,GAAGpH,KAAK,CAACc,mBAAmB,CAACiE,4BAA4B,CAACmC,MAAM,CAAC;IAC7E;IACA,MAAMG,UAAU,GAAG,CAACD,MAAM,EAAEnC,MAAM,IAAImC,MAAM,EAAElC,IAAI,KAAKL,QAAQ,IAAI7E,KAAK,CAACsH,gBAAgB,KAAKzC,QAAQ;IACtG,IAAIwC,UAAU,EAAE;MACd,MAAME,QAAQ,GAAG,IAAI;MACrB,MAAMC,OAAO,GAAGD,QAAQ,GAAGxB,aAAa;MACxC,MAAM0B,QAAQ,GAAG,IAAIjB,UAAU,CAACgB,OAAO,CAAC;MACxC,IAAI,CAACxH,KAAK,CAACoD,UAAU,EAAE;QACrBpD,KAAK,CAACoD,UAAU,GAAGxF,gBAAgB,CAACwH,WAAW,CAAC,CAAC;QACjDpF,KAAK,CAACoD,UAAU,CAACjC,qBAAqB,CAACnB,KAAK,CAACc,mBAAmB,CAAC;MACnE;MACA,IAAIoG,MAAM,EAAE;QACV,MAAMQ,aAAa,GAAG,IAAIhB,YAAY,CAACc,OAAO,CAAC;QAC/C,MAAMf,QAAQ,GAAG,IAAIC,YAAY,CAACa,QAAQ,CAAC;QAC3C,KAAK,IAAIvK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8I,SAAS,EAAE,EAAE9I,CAAC,EAAE;UAClC,MAAM8B,KAAK,GAAG+G,IAAI,CAACsB,oBAAoB,CAACnK,CAAC,CAAC;UAC1C,IAAI8B,KAAK,KAAK,IAAI,EAAE;YAClB;YACA4I,aAAa,CAACC,IAAI,CAAC,GAAG,CAAC;UACzB,CAAC,MAAM;YACL,MAAMC,QAAQ,GAAG9I,KAAK,CAAC+H,QAAQ,CAAC,CAAC;YACjC/H,KAAK,CAACgI,QAAQ,CAACc,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,EAAEL,QAAQ,EAAEd,QAAQ,EAAE,CAAC,CAAC;YAC/D;YACA,IAAIzH,MAAM,EAAE;cACV,KAAK,IAAI+H,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,QAAQ,EAAER,CAAC,EAAE,EAAE;gBACjCW,aAAa,CAAC1K,CAAC,GAAGuK,QAAQ,GAAG,CAAC,GAAGR,CAAC,CAAC,GAAGN,QAAQ,CAACM,CAAC,CAAC;gBACjDW,aAAa,CAAC1K,CAAC,GAAGuK,QAAQ,GAAG,CAAC,GAAGR,CAAC,GAAGQ,QAAQ,CAAC,GAAGd,QAAQ,CAACM,CAAC,CAAC;cAC9D;YACF,CAAC,MAAM;cACL,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,QAAQ,EAAER,CAAC,EAAE,EAAE;gBACjCW,aAAa,CAAC1K,CAAC,GAAGuK,QAAQ,GAAG,CAAC,GAAGR,CAAC,CAAC,GAAGN,QAAQ,CAACM,CAAC,CAAC;cACnD;YACF;UACF;QACF;QACA/G,KAAK,CAACoD,UAAU,CAACqC,wBAAwB,CAACzF,KAAK,CAACc,mBAAmB,CAAC;QACpEd,KAAK,CAACoD,UAAU,CAACsC,kBAAkB,CAAC,CAAC;QACrC1F,KAAK,CAACoD,UAAU,CAAC4D,eAAe,CAACO,QAAQ,EAAExB,aAAa,EAAE,CAAC,EAAEtH,YAAY,CAACoJ,KAAK,EAAEH,aAAa,CAAC;MACjG,CAAC,MAAM;QACL;QACAD,QAAQ,CAACE,IAAI,CAAC,KAAK,CAAC;QACpB3H,KAAK,CAACoD,UAAU,CAACqC,wBAAwB,CAACzF,KAAK,CAACc,mBAAmB,CAAC;QACpEd,KAAK,CAACoD,UAAU,CAACsC,kBAAkB,CAAC,CAAC;QACrC1F,KAAK,CAACoD,UAAU,CAAC4D,eAAe,CAACO,QAAQ,EAAE,CAAC,EAAE,CAAC,EAAE9I,YAAY,CAACwI,aAAa,EAAEQ,QAAQ,CAAC;MACxF;MACAzH,KAAK,CAACsH,gBAAgB,GAAGzC,QAAQ;MACjC,IAAIqC,MAAM,EAAE;QACVlH,KAAK,CAACc,mBAAmB,CAAC8E,4BAA4B,CAACsB,MAAM,EAAElH,KAAK,CAACoD,UAAU,EAAEpD,KAAK,CAACsH,gBAAgB,CAAC;MAC1G;IACF,CAAC,MAAM;MACLtH,KAAK,CAACoD,UAAU,GAAGgE,MAAM,CAACnC,MAAM;MAChCjF,KAAK,CAACsH,gBAAgB,GAAGF,MAAM,CAAClC,IAAI;IACtC;IACA,MAAM4C,SAAS,GAAI,GAAE9H,KAAK,CAACoE,WAAW,CAAClF,QAAQ,CAAC,CAAE,IAAGc,KAAK,CAAC8B,UAAU,CAACiG,gBAAgB,CAAC,CAAE,EAAC;IAC1F,IAAI,CAAC/H,KAAK,CAACkB,IAAI,CAAC0C,OAAO,CAAC,CAAC,CAACC,eAAe,CAAC,CAAC,IAAI7D,KAAK,CAACgI,cAAc,KAAKF,SAAS,EAAE;MACjF,MAAMG,MAAM,GAAG1K,YAAY,CAAC6H,WAAW,CAAC;QACtCrG,kBAAkB,EAAE,CAAC;QACrBmJ,MAAM,EAAElI,KAAK,CAACoE,WAAW,CAAC+D,SAAS,CAAC,CAAC,CAACC,OAAO,CAAC;MAChD,CAAC,CAAC;MACFH,MAAM,CAACI,OAAO,CAAC,QAAQ,CAAC;MACxB,MAAMC,KAAK,GAAG/K,YAAY,CAAC6H,WAAW,CAAC;QACrCrG,kBAAkB,EAAE,CAAC;QACrBmJ,MAAM,EAAElI,KAAK,CAACoE,WAAW,CAACmE,QAAQ,CAAC,CAAC,CAACH,OAAO,CAAC;MAC/C,CAAC,CAAC;MACF,MAAMI,OAAO,GAAG;QACdP,MAAM;QACNQ,UAAU,EAAE;MACd,CAAC;MACD,IAAIzI,KAAK,CAAC8B,UAAU,CAACiG,gBAAgB,CAAC,CAAC,GAAG,GAAG,EAAE;QAC7C,MAAMrL,CAAC,GAAGsD,KAAK,CAACoE,WAAW,CAACG,YAAY,CAAC,CAAC,CAACmE,UAAU,CAAC,CAAC;QACvD,IAAI,CAAChM,CAAC,EAAE;UACNiC,aAAa,CAAC,qCAAqC,CAAC;QACtD,CAAC,MAAM;UACL6J,OAAO,CAACG,OAAO,GAAGjM,CAAC;QACrB;MACF;MACAsD,KAAK,CAACkB,IAAI,CAAC0C,OAAO,CAAC,CAAC,CAACgF,SAAS,CAACN,KAAK,EAAE,OAAO,EAAE9J,cAAc,CAACqK,OAAO,EAAEL,OAAO,CAAC;IACjF;IACAxI,KAAK,CAACgI,cAAc,GAAGF,SAAS;IAChC9H,KAAK,CAACmE,YAAY,CAAC2E,QAAQ,CAAC,CAAC;EAC/B,CAAC;EACD/I,SAAS,CAAC0D,aAAa,GAAG,CAACsF,MAAM,EAAEtI,GAAG,EAAEoB,KAAK,KAAK;IAChD7B,KAAK,CAACsD,WAAW,GAAGyF,MAAM;;IAE1B;IACA,IAAIhJ,SAAS,CAACiJ,uBAAuB,CAACD,MAAM,EAAEtI,GAAG,EAAEoB,KAAK,CAAC,EAAE;MACzD,MAAMoH,OAAO,GAAG;QACdC,MAAM,EAAE,IAAI;QACZC,QAAQ,EAAE,IAAI;QACdC,QAAQ,EAAE;MACZ,CAAC;MACDrJ,SAAS,CAACsJ,YAAY,CAACJ,OAAO,EAAExI,GAAG,EAAEoB,KAAK,CAAC;;MAE3C;MACA,MAAMyH,SAAS,GAAGtJ,KAAK,CAACc,mBAAmB,CAACyI,cAAc,CAAC,CAAC,CAACC,uBAAuB,CAACP,OAAO,CAACC,MAAM,EAAED,OAAO,CAACE,QAAQ,EAAEF,OAAO,CAACG,QAAQ,CAAC;;MAExI;MACA,IAAIE,SAAS,KAAKP,MAAM,CAACU,UAAU,CAAC,CAAC,EAAE;QACrCV,MAAM,CAACW,UAAU,CAACJ,SAAS,CAAC;QAC5B;QACAP,MAAM,CAACjF,MAAM,CAAC,CAAC,CAAC2B,wBAAwB,CAAC,CAAC;MAC5C;MACAsD,MAAM,CAACY,mBAAmB,CAAC,CAAC,CAACb,QAAQ,CAAC,CAAC;IACzC,CAAC,MAAM;MACL9I,KAAK,CAACc,mBAAmB,CAACyI,cAAc,CAAC,CAAC,CAACK,kBAAkB,CAACb,MAAM,CAACU,UAAU,CAAC,CAAC,CAAC;IACpF;IACAV,MAAM,CAACjF,MAAM,CAAC,CAAC,CAAC+F,IAAI,CAAC,CAAC;IACtB9J,SAAS,CAAC+J,yBAAyB,CAACf,MAAM,EAAEtI,GAAG,EAAEoB,KAAK,CAAC;IACvD9B,SAAS,CAACgK,yBAAyB,CAAChB,MAAM,EAAEtI,GAAG,EAAEoB,KAAK,CAAC;IACvD9B,SAAS,CAACiK,2BAA2B,CAACjB,MAAM,EAAEtI,GAAG,EAAEoB,KAAK,CAAC;EAC3D,CAAC;EACD9B,SAAS,CAAC+J,yBAAyB,GAAG,CAACf,MAAM,EAAEtI,GAAG,EAAEoB,KAAK,KAAK;IAC5D,MAAMoI,OAAO,GAAGlB,MAAM,CAACU,UAAU,CAAC,CAAC;IACnC,IAAIV,MAAM,CAACnF,OAAO,CAAC,CAAC,CAACC,eAAe,CAAC,CAAC,KAAK7D,KAAK,CAACmE,YAAY,CAACjF,QAAQ,CAAC,CAAC,GAAG6J,MAAM,CAACmB,sBAAsB,CAAC,CAAC,CAAChL,QAAQ,CAAC,CAAC,IAAI6J,MAAM,CAACY,mBAAmB,CAAC,CAAC,CAACzK,QAAQ,CAAC,CAAC,GAAG6J,MAAM,CAACmB,sBAAsB,CAAC,CAAC,CAAChL,QAAQ,CAAC,CAAC,CAAC,EAAE;MAC9M;MACA,IAAI+K,OAAO,CAACE,aAAa,CAAC,UAAU,CAAC,EAAE;QACrCF,OAAO,CAACG,WAAW,CAAC,UAAU,EAAEpK,KAAK,CAACgD,aAAa,CAACqH,cAAc,CAAC,CAAC,CAAC;MACvE;;MAEA;MACA,IAAIJ,OAAO,CAACK,eAAe,CAAC,UAAU,CAAC,EAAE;QACvC,IAAI,CAACvB,MAAM,CAACjF,MAAM,CAAC,CAAC,CAACyG,iBAAiB,CAACN,OAAO,EAAElB,MAAM,CAACnF,OAAO,CAAC,CAAC,EAAE,UAAU,EAAEmF,MAAM,CAACnF,OAAO,CAAC,CAAC,CAAC4G,eAAe,CAAC,CAAC,EAAEzB,MAAM,CAACnF,OAAO,CAAC,CAAC,CAAC6G,SAAS,CAAC,CAAC,EAAEzK,KAAK,CAACgB,OAAO,CAAC6G,KAAK,EAAE,CAAC,EAAE7H,KAAK,CAACgB,OAAO,CAAC0J,KAAK,CAAC,EAAE;UAC5L/L,aAAa,CAAC,uCAAuC,CAAC;QACxD;MACF;;MAEA;MACA,IAAIsL,OAAO,CAACK,eAAe,CAAC,UAAU,CAAC,EAAE;QACvC,IAAI,CAACvB,MAAM,CAACjF,MAAM,CAAC,CAAC,CAACyG,iBAAiB,CAACN,OAAO,EAAElB,MAAM,CAACnF,OAAO,CAAC,CAAC,EAAE,UAAU,EAAEmF,MAAM,CAACnF,OAAO,CAAC,CAAC,CAAC+G,eAAe,CAAC,CAAC,EAAE5B,MAAM,CAACnF,OAAO,CAAC,CAAC,CAAC6G,SAAS,CAAC,CAAC,EAAEzK,KAAK,CAACgB,OAAO,CAAC6G,KAAK,EAAE,CAAC,EAAE7H,KAAK,CAACgB,OAAO,CAAC0J,KAAK,CAAC,EAAE;UAC5L/L,aAAa,CAAC,uCAAuC,CAAC;QACxD;MACF;MACA,IAAIsL,OAAO,CAACE,aAAa,CAAC,eAAe,CAAC,EAAE;QAC1CF,OAAO,CAACW,WAAW,CAAC,eAAe,EAAE5K,KAAK,CAAC8B,UAAU,CAACiG,gBAAgB,CAAC,CAAC,CAAC;MAC3E;MACA,IAAIkC,OAAO,CAACE,aAAa,CAAC,SAAS,CAAC,EAAE;QACpCF,OAAO,CAACY,aAAa,CAAC,SAAS,EAAE7K,KAAK,CAACqC,YAAY,CAACyI,UAAU,CAAC,CAAC,CAAC;MACnE;MACA,IAAIb,OAAO,CAACE,aAAa,CAAC,UAAU,CAAC,EAAE;QACrCF,OAAO,CAACG,WAAW,CAAC,UAAU,EAAEpK,KAAK,CAAC8B,UAAU,CAACiJ,WAAW,CAAC,CAAC,CAAC;MACjE;MACA,IAAId,OAAO,CAACE,aAAa,CAAC,UAAU,CAAC,EAAE;QACrCF,OAAO,CAACG,WAAW,CAAC,UAAU,EAAEpK,KAAK,CAAC8B,UAAU,CAACiJ,WAAW,CAAC,CAAC,CAAC;MACjE;MACA,IAAId,OAAO,CAACE,aAAa,CAAC,eAAe,CAAC,EAAE;QAC1CF,OAAO,CAACG,WAAW,CAAC,eAAe,EAAEpK,KAAK,CAAC8B,UAAU,CAACkJ,2BAA2B,CAAC,CAAC,CAAC;MACtF;MACA,MAAMC,iBAAiB,GAAGlC,MAAM,CAACnF,OAAO,CAAC,CAAC,CAACsH,4BAA4B,CAAC,CAAC;MACzE,MAAMC,uBAAuB,GAAGF,iBAAiB,GAAGlC,MAAM,CAACnF,OAAO,CAAC,CAAC,CAACwH,6BAA6B,CAAC,CAAC,GAAG,IAAI;;MAE3G;MACA,IAAInB,OAAO,CAACE,aAAa,CAAC,YAAY,CAAC,EAAE;QACvC,MAAM9F,KAAK,GAAGrE,KAAK,CAACqC,YAAY;QAChC,MAAMgJ,GAAG,GAAGhH,KAAK,CAACiB,aAAa,CAAC,CAAC;QACjCpI,IAAI,CAAC0C,IAAI,CAACI,KAAK,CAACsL,OAAO,EAAEjH,KAAK,CAACkH,eAAe,CAAC,CAAC,CAAC;QACjDrO,IAAI,CAACsO,KAAK,CAACxL,KAAK,CAACsL,OAAO,EAAEtL,KAAK,CAACsL,OAAO,EAAED,GAAG,CAAC;QAC7CnO,IAAI,CAACuO,MAAM,CAACzL,KAAK,CAACsL,OAAO,EAAEtL,KAAK,CAACsL,OAAO,CAAC;QACzC,IAAIH,uBAAuB,EAAE;UAC3BjO,IAAI,CAAC2C,QAAQ,CAACG,KAAK,CAACsL,OAAO,EAAEtL,KAAK,CAACsL,OAAO,EAAEH,uBAAuB,CAAC;QACtE;QACAlB,OAAO,CAACyB,gBAAgB,CAAC,YAAY,EAAE1L,KAAK,CAACsL,OAAO,CAAC;MACvD;MACA,IAAIrB,OAAO,CAACE,aAAa,CAAC,YAAY,CAAC,EAAE;QACvCF,OAAO,CAACY,aAAa,CAAC,YAAY,EAAE9B,MAAM,CAACnF,OAAO,CAAC,CAAC,CAAC+H,aAAa,CAAC,CAAC,CAAC;MACvE;MACA5C,MAAM,CAACmB,sBAAsB,CAAC,CAAC,CAACpB,QAAQ,CAAC,CAAC;IAC5C;;IAEA;IACA,IAAI9I,KAAK,CAACwB,oBAAoB,EAAE;MAC9BuH,MAAM,CAACU,UAAU,CAAC,CAAC,CAACW,WAAW,CAAC,cAAc,EAAEpK,KAAK,CAACyB,WAAW,GAAG,CAAC,GAAG,CAAC,CAAC;IAC5E;;IAEA;IACA,IAAIsH,MAAM,CAACU,UAAU,CAAC,CAAC,CAACU,aAAa,CAAC,SAAS,CAAC,EAAE;MAChD,MAAMyB,EAAE,GAAG7L,SAAS,CAAC6B,uBAAuB,CAACnB,GAAG,EAAEoB,KAAK,CAAC;MACxDkH,MAAM,CAACU,UAAU,CAAC,CAAC,CAACmB,WAAW,CAAC,SAAS,EAAEgB,EAAE,CAACC,MAAM,CAAC;MACrD;MACA,IAAI9C,MAAM,CAACU,UAAU,CAAC,CAAC,CAACU,aAAa,CAAC,SAAS,CAAC,EAAE;QAChDpB,MAAM,CAACU,UAAU,CAAC,CAAC,CAACmB,WAAW,CAAC,SAAS,EAAEgB,EAAE,CAACE,MAAM,CAAC;MACvD;IACF;EACF,CAAC;EACD/L,SAAS,CAACgK,yBAAyB,GAAG,CAAChB,MAAM,EAAEtI,GAAG,EAAEoB,KAAK,KAAK;IAC5D;IACA;IACA,MAAMkK,OAAO,GAAG/L,KAAK,CAACW,aAAa,CAACqL,cAAc,CAACvL,GAAG,CAAC;IACvD,MAAMwL,OAAO,GAAGjM,KAAK,CAACM,iBAAiB,CAAC0L,cAAc,CAAC,CAAC;IACxD,MAAMf,iBAAiB,GAAGlC,MAAM,CAACnF,OAAO,CAAC,CAAC,CAACsH,4BAA4B,CAAC,CAAC;IACzE,MAAMC,uBAAuB,GAAGF,iBAAiB,GAAGlC,MAAM,CAACnF,OAAO,CAAC,CAAC,CAACwH,6BAA6B,CAAC,CAAC,GAAG,IAAI;IAC3G,MAAMnB,OAAO,GAAGlB,MAAM,CAACU,UAAU,CAAC,CAAC;IACnC,IAAIQ,OAAO,CAACE,aAAa,CAAC,YAAY,CAAC,EAAE;MACvCjN,IAAI,CAACqC,QAAQ,CAACS,KAAK,CAACsL,OAAO,CAAC;MAC5BrB,OAAO,CAACyB,gBAAgB,CAAC,YAAY,EAAEvM,kBAAkB,CAAC,CAAC4M,OAAO,CAACG,IAAI,EAAED,OAAO,CAACE,IAAI,EAAEhB,uBAAuB,CAAC,EAAEjO,IAAI,EAAE8C,KAAK,CAACsL,OAAO,CAAC,CAAC;IACxI;IACA,IAAIrB,OAAO,CAACE,aAAa,CAAC,YAAY,CAAC,EAAE;MACvCjN,IAAI,CAACqC,QAAQ,CAACS,KAAK,CAACsL,OAAO,CAAC;MAC5BrB,OAAO,CAACyB,gBAAgB,CAAC,YAAY,EAAEvM,kBAAkB,CAAC,CAAC4M,OAAO,CAACK,IAAI,EAAEH,OAAO,CAACE,IAAI,EAAEhB,uBAAuB,CAAC,EAAEjO,IAAI,EAAE8C,KAAK,CAACsL,OAAO,CAAC,CAAC;IACxI;EACF,CAAC;EACDvL,SAAS,CAACiK,2BAA2B,GAAG,CAACjB,MAAM,EAAEtI,GAAG,EAAEoB,KAAK,KAAK;IAC9D,MAAMoI,OAAO,GAAGlB,MAAM,CAACU,UAAU,CAAC,CAAC;IACnC,MAAM5D,IAAI,GAAGhE,KAAK,CAACgB,WAAW,CAAC,CAAC;IAChC,MAAMwJ,OAAO,GAAGxG,IAAI,CAACyG,UAAU,CAAC,CAAC;IACjCrC,OAAO,CAACW,WAAW,CAAC,SAAS,EAAEyB,OAAO,CAAC;;IAEvC;IACA;IACA;IACA;IACA;IACA;IACA,MAAM1H,OAAO,GAAG3E,KAAK,CAACgD,aAAa,CAACuJ,aAAa,CAAC,CAAC;IACnD,MAAMvN,MAAM,GAAG6G,IAAI,CAAC5G,wBAAwB,CAAC,CAAC;IAC9C,IAAID,MAAM,EAAE;MACV,KAAK,IAAI+H,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpC,OAAO,EAAE,EAAEoC,CAAC,EAAE;QAChCkD,OAAO,CAACW,WAAW,CAAE,MAAK7D,CAAE,EAAC,EAAElB,IAAI,CAAC2G,kBAAkB,CAACzF,CAAC,CAAC,CAAC;MAC5D;IACF;;IAEA;IACA,MAAM0F,OAAO,GAAGzM,KAAK,CAACgD,aAAa,CAAC0J,aAAa,CAAC,CAAC;;IAEnD;IACA;IACA,KAAK,IAAI3F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpC,OAAO,EAAEoC,CAAC,EAAE,EAAE;MAChC,IAAI4F,EAAE,GAAG9G,IAAI,CAAC+G,cAAc,CAAC,CAAC;MAC9B,IAAIC,EAAE,GAAGhH,IAAI,CAACiH,aAAa,CAAC,CAAC;MAC7B,MAAMC,MAAM,GAAG/N,MAAM,GAAG+H,CAAC,GAAG,CAAC;MAC7B,MAAMJ,IAAI,GAAGd,IAAI,CAACI,sBAAsB,CAAC8G,MAAM,CAAC;MAChD,IAAIpG,IAAI,IAAId,IAAI,CAACmH,4BAA4B,CAAC,CAAC,EAAE;QAC/C,MAAMpG,MAAM,GAAGD,IAAI,CAACE,QAAQ,CAAC,CAAC;QAC9B8F,EAAE,GAAG/F,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC;QAC1BiG,EAAE,GAAG,GAAG,IAAIjG,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,CAAC;MACpC;MACA,MAAM4E,KAAK,GAAGiB,OAAO,CAACjB,KAAK,CAACzE,CAAC,CAAC,GAAG4F,EAAE;MACnC,MAAMM,KAAK,GAAG,CAACR,OAAO,CAACZ,MAAM,CAAC9E,CAAC,CAAC,GAAG8F,EAAE,IAAIF,EAAE,GAAG,GAAG;MACjD1C,OAAO,CAACW,WAAW,CAAE,SAAQ7D,CAAE,EAAC,EAAEkG,KAAK,CAAC;MACxChD,OAAO,CAACW,WAAW,CAAE,SAAQ7D,CAAE,EAAC,EAAEyE,KAAK,CAAC;IAC1C;IACA,MAAM0B,YAAY,GAAGlN,KAAK,CAACmD,YAAY,CAACkH,cAAc,CAAC,CAAC;IACxDJ,OAAO,CAACG,WAAW,CAAC,eAAe,EAAE8C,YAAY,CAAC;;IAElD;IACA,KAAK,IAAInG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpC,OAAO,EAAEoC,CAAC,EAAE,EAAE;MAChC,IAAIoG,QAAQ,GAAG,GAAG;MAClB,IAAIC,QAAQ,GAAG,GAAG;MAClB,MAAML,MAAM,GAAG/N,MAAM,GAAG+H,CAAC,GAAG,CAAC;MAC7B,MAAMjI,KAAK,GAAG+G,IAAI,CAACsB,oBAAoB,CAAC4F,MAAM,CAAC;MAC/C,IAAIjO,KAAK,EAAE;QACT,MAAM8I,QAAQ,GAAG9I,KAAK,CAAC+H,QAAQ,CAAC,CAAC;QACjC,MAAMwG,MAAM,GAAGzF,QAAQ,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC;QACxC,MAAM0F,GAAG,GAAG,GAAG,IAAI1F,QAAQ,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC,CAAC;QAC7CuF,QAAQ,GAAGV,OAAO,CAACjB,KAAK,CAACzE,CAAC,CAAC,GAAGsG,MAAM;QACpCD,QAAQ,GAAG,CAACX,OAAO,CAACZ,MAAM,CAAC9E,CAAC,CAAC,GAAGuG,GAAG,IAAID,MAAM,GAAG,GAAG;MACrD;MACApD,OAAO,CAACW,WAAW,CAAE,WAAU7D,CAAE,EAAC,EAAEqG,QAAQ,CAAC;MAC7CnD,OAAO,CAACW,WAAW,CAAE,WAAU7D,CAAE,EAAC,EAAEoG,QAAQ,CAAC;IAC/C;IACA,MAAMI,cAAc,GAAGvN,KAAK,CAACoD,UAAU,CAACiH,cAAc,CAAC,CAAC;IACxDJ,OAAO,CAACG,WAAW,CAAC,aAAa,EAAEmD,cAAc,CAAC;;IAElD;IACAtD,OAAO,CAACuD,aAAa,CAAC,iBAAiB,EAAExN,KAAK,CAAC8B,UAAU,CAAC2L,kBAAkB,CAAC,CAAC,CAAC;EACjF,CAAC;EACD1N,SAAS,CAACiJ,uBAAuB,GAAG,CAACD,MAAM,EAAEtI,GAAG,EAAEoB,KAAK,KAAK;IAC1D;IACA;IACA;IACA;IACA;IACA;IACA,MAAM6L,QAAQ,GAAG1N,KAAK,CAACgD,aAAa,CAACuJ,aAAa,CAAC,CAAC;IACpD,MAAMoB,KAAK,GAAG9L,KAAK,CAACgB,WAAW,CAAC,CAAC,CAAC5D,wBAAwB,CAAC,CAAC;IAC5D,MAAM2O,MAAM,GAAG5N,KAAK,CAAC8B,UAAU,CAACiG,gBAAgB,CAAC,CAAC;IAClD,MAAM8F,QAAQ,GAAG7N,KAAK,CAAC8B,UAAU,CAACiJ,WAAW,CAAC,CAAC;IAC/C,MAAM+C,QAAQ,GAAG9N,KAAK,CAAC8B,UAAU,CAACkJ,2BAA2B,CAAC,CAAC;;IAE/D;IACA,IAAI+C,WAAW,GAAG,KAAK;IACvB,IAAI,CAAC/N,KAAK,CAACK,iBAAiB,IAAIL,KAAK,CAACgO,+BAA+B,IAAIhO,KAAK,CAACK,iBAAiB,IAAIL,KAAK,CAACK,iBAAiB,CAAC4N,oBAAoB,CAAC,CAAC,KAAKjO,KAAK,CAACgO,+BAA+B,EAAE;MAC5LD,WAAW,GAAG,IAAI;IACpB;IACA,IAAIA,WAAW,IAAI/N,KAAK,CAACkO,wBAAwB,KAAKlO,KAAK,CAACwB,oBAAoB,IAAIuH,MAAM,CAACU,UAAU,CAAC,CAAC,EAAE0E,SAAS,CAAC,CAAC,KAAK,CAAC,IAAInO,KAAK,CAACoO,qBAAqB,KAAKV,QAAQ,IAAI1N,KAAK,CAACqO,yBAAyB,KAAKV,KAAK,IAAI3N,KAAK,CAACsO,iBAAiB,KAAKV,MAAM,IAAI5N,KAAK,CAACuO,YAAY,KAAKV,QAAQ,IAAI7N,KAAK,CAACwO,4BAA4B,KAAKV,QAAQ,EAAE;MAC/U9N,KAAK,CAACkO,wBAAwB,GAAGlO,KAAK,CAACwB,oBAAoB;MAC3DxB,KAAK,CAACoO,qBAAqB,GAAGV,QAAQ;MACtC1N,KAAK,CAACqO,yBAAyB,GAAGV,KAAK;MACvC3N,KAAK,CAACsO,iBAAiB,GAAGV,MAAM;MAChC5N,KAAK,CAACuO,YAAY,GAAGV,QAAQ;MAC7B7N,KAAK,CAACwO,4BAA4B,GAAGV,QAAQ;MAC7C,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd,CAAC;EACD/N,SAAS,CAAC0O,iBAAiB,GAAG,CAACxF,OAAO,EAAExI,GAAG,EAAEoB,KAAK,KAAK;IACrDoH,OAAO,CAACC,MAAM,GAAG9K,uBAAuB;IACxC6K,OAAO,CAACE,QAAQ,GAAG9K,uBAAuB;IAC1C4K,OAAO,CAACG,QAAQ,GAAG,EAAE;EACvB,CAAC;EACDrJ,SAAS,CAAC2O,mBAAmB,GAAG,CAACzF,OAAO,EAAExI,GAAG,EAAEoB,KAAK,KAAK;IACvD9B,SAAS,CAAC4O,mBAAmB,CAAC1F,OAAO,EAAExI,GAAG,EAAEoB,KAAK,CAAC;IAClD9B,SAAS,CAAC6O,uBAAuB,CAAC3F,OAAO,EAAExI,GAAG,EAAEoB,KAAK,CAAC;IACtD,IAAI7B,KAAK,CAACwB,oBAAoB,EAAE;MAC9B,IAAIqN,QAAQ,GAAG5F,OAAO,CAACE,QAAQ;MAC/B0F,QAAQ,GAAG7Q,gBAAgB,CAAC8Q,UAAU,CAACD,QAAQ,EAAE,qBAAqB,EAAE,2BAA2B,CAAC,CAACE,MAAM;MAC3GF,QAAQ,GAAG7Q,gBAAgB,CAAC8Q,UAAU,CAACD,QAAQ,EAAE,sBAAsB,EAAE,CAAC,0BAA0B,EAAE,iDAAiD,EAAE,mCAAmC,EAAE,iCAAiC,EAAE,4CAA4C,CAAC,CAAC,CAACE,MAAM;MACtR9F,OAAO,CAACE,QAAQ,GAAG0F,QAAQ;IAC7B;IACA9O,SAAS,CAACiP,6BAA6B,CAAC/F,OAAO,EAAExI,GAAG,EAAEoB,KAAK,CAAC;EAC9D,CAAC;EACD9B,SAAS,CAAC4O,mBAAmB,GAAG,CAAC1F,OAAO,EAAExI,GAAG,EAAEoB,KAAK,KAAK;IACvD,IAAIoN,QAAQ,GAAGhG,OAAO,CAACC,MAAM;IAC7B,MAAMgG,QAAQ,GAAGjG,OAAO,CAACG,QAAQ;IACjC,IAAIyF,QAAQ,GAAG5F,OAAO,CAACE,QAAQ;IAC/B,MAAMgG,WAAW,GAAG,CAAC,0BAA0B,EAAE,wBAAwB,CAAC;IAC1E,MAAMC,aAAa,GAAGpP,KAAK,CAAC8B,UAAU,CAACiG,gBAAgB,CAAC,CAAC;IACzDkH,QAAQ,GAAGjR,gBAAgB,CAAC8Q,UAAU,CAACG,QAAQ,EAAE,oBAAoB,EAAEE,WAAW,CAAC,CAACJ,MAAM;IAC1F,MAAMM,YAAY,GAAG,CAAC,6CAA6C,CAAC;IACpEJ,QAAQ,GAAGjR,gBAAgB,CAAC8Q,UAAU,CAACG,QAAQ,EAAE,qBAAqB,EAAEI,YAAY,CAAC,CAACN,MAAM;IAC5F,MAAMrB,QAAQ,GAAG1N,KAAK,CAACgD,aAAa,CAACuJ,aAAa,CAAC,CAAC;IACpD,MAAMvN,MAAM,GAAG6C,KAAK,CAACgB,WAAW,CAAC,CAAC,CAAC5D,wBAAwB,CAAC,CAAC;IAC7D,IAAIqQ,WAAW,GAAG,CAAC,uBAAuB,EAAE,mCAAmC,EAAE,0BAA0B;IAC3G;IACA,wBAAwB,EAAE,wBAAwB;IAClD;IACA,0BAA0B,EAAE,0BAA0B;IACtD;IACA,kCAAkC,EAAE,gCAAgC;IACpE;IACA,wBAAwB;IACxB;IACA,+BAA+B,CAAC;IAChC,IAAItQ,MAAM,EAAE;MACV,KAAK,IAAIuQ,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAG7B,QAAQ,EAAE6B,IAAI,EAAE,EAAE;QAC1CD,WAAW,GAAGA,WAAW,CAACE,MAAM,CAAC;QACjC;QACC,uBAAsBD,IAAK,GAAE,EAAG,uBAAsBA,IAAK,GAAE;QAC9D;QACC,yBAAwBA,IAAK,GAAE,EAAG,yBAAwBA,IAAK,GAAE,CAAC,CAAC;MACtE;MACA;MACA;MACA;MACA;MACA;MACA,QAAQ7B,QAAQ;QACd,KAAK,CAAC;UACJ4B,WAAW,GAAGA,WAAW,CAACE,MAAM,CAAC,CAAC,qBAAqB,EAAE,qBAAqB,CAAC,CAAC;UAChF;QACF,KAAK,CAAC;UACJF,WAAW,GAAGA,WAAW,CAACE,MAAM,CAAC,CAAC,qBAAqB,EAAE,qBAAqB,EAAE,sBAAsB,EAAE,sBAAsB,CAAC,CAAC;UAChI;QACF,KAAK,CAAC;UACJF,WAAW,GAAGA,WAAW,CAACE,MAAM,CAAC,CAAC,qBAAqB,EAAE,qBAAqB,EAAE,qBAAqB,EAAE,sBAAsB,EAAE,qBAAqB,EAAE,sBAAsB,CAAC,CAAC;UAC9K;QACF,KAAK,CAAC;UACJF,WAAW,GAAGA,WAAW,CAACE,MAAM,CAAC,CAAC,qBAAqB,EAAE,qBAAqB,EAAE,qBAAqB,EAAE,qBAAqB,EAAE,uBAAuB,EAAE,uBAAuB,EAAE,uBAAuB,EAAE,uBAAuB,CAAC,CAAC;UAClO;QACF;UACE7Q,aAAa,CAAC,gDAAgD,CAAC;MACnE;IACF;IACA,IAAIyQ,aAAa,GAAG,GAAG,EAAE;MACvBE,WAAW,GAAGA,WAAW,CAACE,MAAM,CAAC,CAAC,uBAAuB,EAAE,8BAA8B,EAAE,uBAAuB,EAAE,4BAA4B,EAAE,0BAA0B,CAAC,CAAC;MAC9KF,WAAW,GAAGA,WAAW,CAACE,MAAM,CAAC,CAAC,kEAAkE,EAAE,GAAG,EAAE,4BAA4B,EAAE,6BAA6B,EAAE,KAAK,EAAE,uCAAuC,EAAE,KAAK,EAAE,kCAAkC,EAAE,KAAK,EAAE,uCAAuC,EAAE,KAAK,EAAE,kCAAkC,EAAE,KAAK,EAAE,wEAAwE,EAAE,KAAK,EAAE,gBAAgB,EAAE,KAAK,EAAE,wEAAwE,EAAE,KAAK,EAAE,kBAAkB,EAAE,GAAG,CAAC,CAAC;IAC3jB;IACAX,QAAQ,GAAG7Q,gBAAgB,CAAC8Q,UAAU,CAACD,QAAQ,EAAE,oBAAoB,EAAES,WAAW,CAAC,CAACP,MAAM;IAC1F,IAAIU,YAAY,GAAG,CAAC,0FAA0F,EAAE,GAAG,EAAE,wCAAwC,EAAE,qCAAqC,EAAE,WAAW,EAAE,GAAG,EAAE,gDAAgD,CAAC;IACzQ,IAAIL,aAAa,GAAG,GAAG,EAAE;MACvBK,YAAY,GAAGA,YAAY,CAACD,MAAM,CAAC,CAAC,mCAAmC,EAAE,oBAAoB,EAAE,kEAAkE,EAAE,mDAAmD,EAAE,8CAA8C,EAAE,oBAAoB,EAAE,4CAA4C,EAAE,GAAG,EAAE,2CAA2C,EAAE,wCAAwC,EAAE,2CAA2C,EAAE,KAAK,EAAE,mEAAmE,EAAE,2EAA2E,EAAE,gCAAgC,EAAE,KAAK,EAAE,uHAAuH,EAAE,gGAAgG,EAAE,KAAK,EAAE,qDAAqD,EAAE,yDAAyD,EAAE,qBAAqB,EAAE,KAAK,EAAE,uHAAuH,EAAE,gGAAgG,EAAE,KAAK,EAAE,qDAAqD,EAAE,yDAAyD,EAAE,qBAAqB,EAAE,KAAK,EAAE,GAAG,EAAE,qEAAqE,EAAE,oBAAoB,EAAE,GAAG,EAAE,uCAAuC,EAAE,GAAG,CAAC,CAAC;IAClhD;IACA,IAAIxQ,MAAM,EAAE;MACV,MAAM0Q,IAAI,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;MACjC,KAAK,IAAIH,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAG7B,QAAQ,EAAE,EAAE6B,IAAI,EAAE;QAC1CE,YAAY,GAAGA,YAAY,CAACD,MAAM,CAAC,CAAE,cAAaD,IAAK,SAAQA,IAAK,2CAA0CG,IAAI,CAACH,IAAI,CAAE,YAAWA,IAAK,YAAWA,IAAK,WAAUA,IAAK,SAAQ,EAAG,mBAAkBA,IAAK,SAAQA,IAAK,yCAAwCG,IAAI,CAACH,IAAI,CAAE,cAAaA,IAAK,cAAaA,IAAK,WAAUA,IAAK,OAAM,CAAC,CAAC;MACvU;MACA,QAAQ7B,QAAQ;QACd,KAAK,CAAC;UACJ+B,YAAY,GAAGA,YAAY,CAACD,MAAM,CAAC,CAAC,4DAA4D,CAAC,CAAC;UAClG;QACF,KAAK,CAAC;UACJC,YAAY,GAAGA,YAAY,CAACD,MAAM,CAAC,CAAC,8CAA8C,EAAE,8HAA8H,CAAC,CAAC;UACpN;QACF,KAAK,CAAC;UACJC,YAAY,GAAGA,YAAY,CAACD,MAAM,CAAC,CAAC,4DAA4D,EAAE,0KAA0K,CAAC,CAAC;UAC9Q;QACF,KAAK,CAAC;UACJC,YAAY,GAAGA,YAAY,CAACD,MAAM,CAAC,CAAC,0EAA0E,EAAE,sNAAsN,CAAC,CAAC;UACxU;QACF;UACE7Q,aAAa,CAAC,gDAAgD,CAAC;MACnE;IACF,CAAC,MAAM;MACL;MACA,QAAQ+O,QAAQ;QACd,KAAK,CAAC;UACJ+B,YAAY,GAAGA,YAAY,CAACD,MAAM,CAAC,CAAC,yBAAyB,EAAE,6BAA6B,EAAE,uFAAuF,EAAE,+FAA+F,EAAE,yDAAyD,CAAC,CAAC;UACnV;QACF,KAAK,CAAC;UACJC,YAAY,GAAGA,YAAY,CAACD,MAAM,CAAC,CAAC,+CAA+C,EAAE,4GAA4G,CAAC,CAAC;UACnM;QACF,KAAK,CAAC;UACJC,YAAY,GAAGA,YAAY,CAACD,MAAM,CAAC,CAAC,yCAAyC,EAAE,uEAAuE,EAAE,mDAAmD,EAAE,6DAA6D,CAAC,CAAC;UAC5Q;QACF;UACEC,YAAY,GAAGA,YAAY,CAACD,MAAM,CAAC,CAAC,yCAAyC,EAAE,uEAAuE,EAAE,mDAAmD,EAAE,8DAA8D,CAAC,CAAC;MACjR;IACF;IACAX,QAAQ,GAAG7Q,gBAAgB,CAAC8Q,UAAU,CAACD,QAAQ,EAAE,qBAAqB,EAAEY,YAAY,CAAC,CAACV,MAAM;IAC5F9F,OAAO,CAACC,MAAM,GAAG+F,QAAQ;IACzBhG,OAAO,CAACE,QAAQ,GAAG0F,QAAQ;IAC3B5F,OAAO,CAACG,QAAQ,GAAG8F,QAAQ;EAC7B,CAAC;EACDnP,SAAS,CAAC6O,uBAAuB,GAAG,CAAC3F,OAAO,EAAExI,GAAG,EAAEoB,KAAK,KAAK;IAC3D,IAAIoN,QAAQ,GAAGhG,OAAO,CAACC,MAAM;IAC7B,MAAMgG,QAAQ,GAAGjG,OAAO,CAACG,QAAQ;IACjC,IAAIyF,QAAQ,GAAG5F,OAAO,CAACE,QAAQ;IAC/B,MAAMiG,aAAa,GAAGpP,KAAK,CAAC8B,UAAU,CAACiG,gBAAgB,CAAC,CAAC;IACzD,IAAI4H,UAAU,GAAG,CAAC,0BAA0B,CAAC;IAC7C;IACAA,UAAU,GAAGA,UAAU,CAACH,MAAM,CAAC,CAAE,KAAIzP,SAAS,CAACb,QAAQ,CAAC,CAAE,GAAEc,KAAK,CAAC4P,uBAAwB,EAAC,CAAC,CAAC;IAC7F,IAAIR,aAAa,GAAG,GAAG,EAAE;MACvBO,UAAU,GAAGA,UAAU,CAACH,MAAM,CAAC,CAAC,0BAA0B,EAAE,gCAAgC,EAAE,gCAAgC,CAAC,CAAC;IAClI;IACAP,QAAQ,GAAGjR,gBAAgB,CAAC8Q,UAAU,CAACG,QAAQ,EAAE,wBAAwB,EAAEU,UAAU,CAAC,CAACZ,MAAM;IAC7F,IAAIc,WAAW,GAAG,CAAC,sCAAsC,CAAC;IAC1D,IAAIT,aAAa,GAAG,GAAG,EAAE;MACvBS,WAAW,GAAGA,WAAW,CAACL,MAAM,CAAC,CAAC,8BAA8B,EAAE,8BAA8B,CAAC,CAAC;IACpG;IACAP,QAAQ,GAAGjR,gBAAgB,CAAC8Q,UAAU,CAACG,QAAQ,EAAE,yBAAyB,EAAEY,WAAW,CAAC,CAACd,MAAM;IAC/FE,QAAQ,GAAGjR,gBAAgB,CAAC8Q,UAAU,CAACG,QAAQ,EAAE,oBAAoB,EAAE,CAAC,0BAA0B,EAAE,0BAA0B,CAAC,CAAC,CAACF,MAAM;IACvI,IAAIe,UAAU,GAAG,EAAE;IACnB,IAAIV,aAAa,GAAG,GAAG,EAAE;MACvBU,UAAU,GAAGA,UAAU,CAACN,MAAM,CAAC,CAAC,gCAAgC,EAAE,gCAAgC,CAAC,CAAC;IACtG;IACAX,QAAQ,GAAG7Q,gBAAgB,CAAC8Q,UAAU,CAACD,QAAQ,EAAE,wBAAwB,EAAEiB,UAAU,CAAC,CAACf,MAAM;IAC7F9F,OAAO,CAACC,MAAM,GAAG+F,QAAQ;IACzBhG,OAAO,CAACG,QAAQ,GAAG8F,QAAQ;IAC3BjG,OAAO,CAACE,QAAQ,GAAG0F,QAAQ;EAC7B,CAAC;EACD,SAASkB,mBAAmBA,CAACrT,CAAC,EAAE;IAC9BiB,OAAO,CAACqS,SAAS,CAACtT,CAAC,CAAC;IACpB,MAAMuT,IAAI,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACtB,KAAK,IAAIlJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE,EAAEA,CAAC,EAAE;MAC1B3J,IAAI,CAAC8S,IAAI,CAACD,IAAI,CAAC;MACfA,IAAI,CAAClJ,CAAC,CAAC,GAAG,GAAG;MACb,MAAMoJ,IAAI,GAAGxS,OAAO,CAACyS,GAAG,CAAC1T,CAAC,EAAEuT,IAAI,CAAC;MACjC,IAAIE,IAAI,GAAG,CAAC,KAAK,IAAIA,IAAI,GAAG,KAAK,EAAE;QACjC,OAAO,CAAC,IAAI,EAAEpJ,CAAC,CAAC;MAClB;IACF;IACA,OAAO,CAAC,KAAK,EAAE,CAAC,CAAC;EACnB;EACAhH,SAAS,CAACwC,qBAAqB,GAAG,MAAM;IACtC,IAAI8N,aAAa,GAAG,EAAE;IACtB,MAAMhM,KAAK,GAAGrE,KAAK,CAACqC,YAAY;IAChC,MAAMiO,WAAW,GAAGjM,KAAK,EAAEkM,SAAS,CAAC,CAAC;IACtC;IACA,IAAIC,YAAY,GAAG,IAAI;IACvB,IAAIC,SAAS,GAAG,CAAC;IACjB,MAAMC,OAAO,GAAG1Q,KAAK,CAAC8B,UAAU,CAAC6O,gBAAgB,CAAC,CAAC;IACnD,MAAMC,UAAU,GAAG5Q,KAAK,CAAC8B,UAAU,CAAC+O,aAAa,CAAC,CAAC;IACnD,IAAIH,OAAO,EAAE;MACXL,aAAa,GAAGA,aAAa,CAACb,MAAM,CAAE,WAAUkB,OAAO,CAACxR,QAAQ,CAAC,CAAE,EAAC,CAAC;IACvE,CAAC,MAAM,IAAI0R,UAAU,EAAE;MACrBP,aAAa,GAAGA,aAAa,CAACb,MAAM,CAAE,QAAOoB,UAAU,CAAC1R,QAAQ,CAAC,CAAE,EAAC,CAAC;MACrE,IAAImF,KAAK,EAAE;QACTgM,aAAa,GAAGA,aAAa,CAACb,MAAM,CAAE,QAAOnL,KAAK,CAACnF,QAAQ,CAAC,CAAE,EAAC,CAAC;MAClE;MACA;MACA;MACA;MACA;MACA,MAAM4R,IAAI,GAAG3T,IAAI,CAAC4T,UAAU,CAAC1M,KAAK,EAAE2M,YAAY,CAAC,CAAC,CAAC;MACnD7T,IAAI,CAACsO,MAAM,CAACqF,IAAI,EAAEA,IAAI,CAAC;MACvB;MACA,MAAMG,gBAAgB,GAAG,CAAC,GAAGL,UAAU,CAACM,SAAS,CAAC,CAAC,CAAC;MACpD9T,IAAI,CAAC+T,aAAa,CAACF,gBAAgB,EAAEA,gBAAgB,EAAEH,IAAI,CAAC;MAC5D,CAACN,YAAY,EAAEC,SAAS,CAAC,GAAGV,mBAAmB,CAACkB,gBAAgB,CAAC;IACnE,CAAC,MAAM;MACL;MACA,MAAMG,KAAK,GAAGvT,QAAQ,CAACuH,WAAW,CAAC,CAAC;MACpCgM,KAAK,CAACC,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACxB,IAAIC,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAC5B,IAAIjN,KAAK,EAAE;QACTiN,GAAG,GAAGhB,WAAW;MACnB;MACAc,KAAK,CAACG,SAAS,CAACD,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,IAAIA,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;MACxDtR,KAAK,CAAC8B,UAAU,CAAC0P,aAAa,CAACJ,KAAK,CAAC;MACrCf,aAAa,GAAGA,aAAa,CAACb,MAAM,CAAE,QAAOoB,UAAU,EAAE1R,QAAQ,CAAC,CAAE,EAAC,CAAC;MACtE,IAAImF,KAAK,EAAE;QACTgM,aAAa,GAAGA,aAAa,CAACb,MAAM,CAAE,QAAOnL,KAAK,CAACnF,QAAQ,CAAC,CAAE,EAAC,CAAC;MAClE;IACF;IACA,IAAI,CAACc,KAAK,CAACoE,WAAW,IAAIpE,KAAK,CAAC4P,uBAAuB,KAAKS,aAAa,EAAE;MACzE,IAAIK,OAAO,EAAE;QACX,IAAI,CAAC1Q,KAAK,CAACoE,WAAW,EAAE;UACtBpE,KAAK,CAACoE,WAAW,GAAGtG,WAAW,CAACsH,WAAW,CAAC,CAAC;QAC/C;QACApF,KAAK,CAACoE,WAAW,CAAC+D,SAAS,CAAC,CAAC,CAACsJ,OAAO,CAACf,OAAO,CAACvI,SAAS,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;QACvEpI,KAAK,CAACoE,WAAW,CAACmE,QAAQ,CAAC,CAAC,CAACkJ,OAAO,CAACf,OAAO,CAACnI,QAAQ,CAAC,CAAC,CAACH,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;QACrEpI,KAAK,CAACoE,WAAW,CAACG,YAAY,CAAC,CAAC,CAACmN,UAAU,CAAChB,OAAO,CAACnM,YAAY,CAAC,CAAC,CAACmE,UAAU,CAAC,CAAC,CAAC;MAClF,CAAC,MAAM,IAAIkI,UAAU,EAAE;QACrB,IAAI,CAACJ,YAAY,EAAE;UACjBxQ,KAAK,CAAC2R,aAAa,CAACC,YAAY,CAACvN,KAAK,CAAC;UACvCrE,KAAK,CAAC6R,MAAM,CAACC,kBAAkB,CAAC9R,KAAK,CAAC2R,aAAa,CAACI,aAAa,CAAC,CAAC,CAAC;UACpE/R,KAAK,CAAC6R,MAAM,CAACG,cAAc,CAACpB,UAAU,CAAC;UACvC5Q,KAAK,CAACiS,mBAAmB,CAACH,kBAAkB,CAAC9R,KAAK,CAAC6R,MAAM,CAACE,aAAa,CAAC,CAAC,CAAC;UAC1E/R,KAAK,CAACiS,mBAAmB,CAAC7P,MAAM,CAAC,CAAC;UAClC,IAAI,CAACpC,KAAK,CAACoE,WAAW,EAAE;YACtBpE,KAAK,CAACoE,WAAW,GAAGtG,WAAW,CAACsH,WAAW,CAAC,CAAC;UAC/C;UACA,MAAM8M,OAAO,GAAGlS,KAAK,CAACiS,mBAAmB,CAACE,aAAa,CAAC,CAAC;UACzDnS,KAAK,CAACoE,WAAW,CAAC+D,SAAS,CAAC,CAAC,CAACsJ,OAAO,CAACS,OAAO,CAAC/J,SAAS,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;UACvEpI,KAAK,CAACoE,WAAW,CAACmE,QAAQ,CAAC,CAAC,CAACkJ,OAAO,CAACS,OAAO,CAAC3J,QAAQ,CAAC,CAAC,CAACH,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;UACrEpI,KAAK,CAACoE,WAAW,CAACG,YAAY,CAAC,CAAC,CAACmN,UAAU,CAACQ,OAAO,CAAC3N,YAAY,CAAC,CAAC,CAACmE,UAAU,CAAC,CAAC,CAAC;UAChF;UACA;UACA,MAAMhM,CAAC,GAAGkU,UAAU,CAACM,SAAS,CAAC,CAAC;UAChC,MAAMkB,IAAI,GAAGpS,KAAK,CAACoE,WAAW,CAACiO,iBAAiB,CAAC,CAAC;UAClD1U,OAAO,CAACqS,SAAS,CAACtT,CAAC,CAAC;UACpB,MAAM4V,WAAW,GAAG,IAAI5L,YAAY,CAAC0L,IAAI,GAAG,CAAC,CAAC;UAC9C,KAAK,IAAIrL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqL,IAAI,EAAE,EAAErL,CAAC,EAAE;YAC7BuL,WAAW,CAAC,CAAC,GAAGvL,CAAC,CAAC,GAAGrK,CAAC,CAAC,CAAC,CAAC;YACzB4V,WAAW,CAAC,CAAC,GAAGvL,CAAC,GAAG,CAAC,CAAC,GAAGrK,CAAC,CAAC,CAAC,CAAC;YAC7B4V,WAAW,CAAC,CAAC,GAAGvL,CAAC,GAAG,CAAC,CAAC,GAAGrK,CAAC,CAAC,CAAC,CAAC;UAC/B;UACA,MAAMiM,OAAO,GAAGpL,YAAY,CAAC6H,WAAW,CAAC;YACvCrG,kBAAkB,EAAE,CAAC;YACrBmJ,MAAM,EAAEoK,WAAW;YACnBC,IAAI,EAAE;UACR,CAAC,CAAC;UACFvS,KAAK,CAACoE,WAAW,CAACG,YAAY,CAAC,CAAC,CAACmN,UAAU,CAAC/I,OAAO,CAAC;QACtD,CAAC,MAAM;UACL;UACA;UACA,MAAM6J,QAAQ,GAAG,IAAI9L,YAAY,CAAC,EAAE,CAAC;UACrC,MAAM+L,qBAAqB,GAAGpO,KAAK,CAACqO,YAAY,CAAC9B,UAAU,CAAC+B,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;UACnF,MAAMC,SAAS,GAAG,CAAC,CAACnC,SAAS,GAAG,CAAC,IAAI,CAAC,EAAE,CAACA,SAAS,GAAG,CAAC,IAAI,CAAC,CAAC,CAACoC,IAAI,CAAC,CAAC;UACnE,MAAMxH,GAAG,GAAGhH,KAAK,CAACiB,aAAa,CAAC,CAAC;UACjC,MAAMwN,GAAG,GAAG,CAAC,CAAC,EAAEzH,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;UACzD,IAAI0H,KAAK,GAAG,CAAC;UACb,KAAK,IAAIhM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE,EAAEA,CAAC,EAAE;YAC1B,KAAK,IAAIiM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE,EAAEA,CAAC,EAAE;cAC1BR,QAAQ,CAACO,KAAK,GAAGtC,SAAS,CAAC,GAAGgC,qBAAqB,CAAChC,SAAS,CAAC;cAC9D+B,QAAQ,CAACO,KAAK,GAAGH,SAAS,CAAC,CAAC,CAAC,CAAC,GAAGE,GAAG,CAAC,CAAC,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAGI,CAAC,CAAC;cAC1DR,QAAQ,CAACO,KAAK,GAAGH,SAAS,CAAC,CAAC,CAAC,CAAC,GAAGE,GAAG,CAAC,CAAC,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG7L,CAAC,CAAC;cAC1DgM,KAAK,IAAI,CAAC;YACZ;UACF;UACA/S,KAAK,CAACiT,SAAS,CAACC,SAAS,CAAC7O,KAAK,CAACkH,eAAe,CAAC,CAAC,CAAC;UAClDvL,KAAK,CAACiT,SAAS,CAACE,eAAe,CAACX,QAAQ,EAAEA,QAAQ,CAAC;UACnD,MAAMY,SAAS,GAAG,IAAIC,WAAW,CAAC,CAAC,CAAC;UACpCD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;UAChBA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;UAChBA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;UAChBA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;UAChBA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;UAChBA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;UAChBA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;UAChBA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;UAChB,MAAM1W,CAAC,GAAGkU,UAAU,CAACM,SAAS,CAAC,CAAC;UAChCvT,OAAO,CAACqS,SAAS,CAACtT,CAAC,CAAC;UACpB,MAAM4V,WAAW,GAAG,IAAI5L,YAAY,CAAC,EAAE,CAAC;UACxC,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE,EAAEA,CAAC,EAAE;YAC1BuL,WAAW,CAAC,CAAC,GAAGvL,CAAC,CAAC,GAAGrK,CAAC,CAAC,CAAC,CAAC;YACzB4V,WAAW,CAAC,CAAC,GAAGvL,CAAC,GAAG,CAAC,CAAC,GAAGrK,CAAC,CAAC,CAAC,CAAC;YAC7B4V,WAAW,CAAC,CAAC,GAAGvL,CAAC,GAAG,CAAC,CAAC,GAAGrK,CAAC,CAAC,CAAC,CAAC;UAC/B;UACA,IAAI,CAACsD,KAAK,CAACoE,WAAW,EAAE;YACtBpE,KAAK,CAACoE,WAAW,GAAGtG,WAAW,CAACsH,WAAW,CAAC,CAAC;UAC/C;UACApF,KAAK,CAACoE,WAAW,CAAC+D,SAAS,CAAC,CAAC,CAACsJ,OAAO,CAACe,QAAQ,EAAE,CAAC,CAAC;UAClDxS,KAAK,CAACoE,WAAW,CAACmE,QAAQ,CAAC,CAAC,CAACkJ,OAAO,CAAC2B,SAAS,EAAE,CAAC,CAAC;UAClD,MAAMzK,OAAO,GAAGpL,YAAY,CAAC6H,WAAW,CAAC;YACvCrG,kBAAkB,EAAE,CAAC;YACrBmJ,MAAM,EAAEoK,WAAW;YACnBC,IAAI,EAAE;UACR,CAAC,CAAC;UACFvS,KAAK,CAACoE,WAAW,CAACG,YAAY,CAAC,CAAC,CAACmN,UAAU,CAAC/I,OAAO,CAAC;QACtD;MACF,CAAC,MAAM;QACLhK,aAAa,CAAC,uBAAuB,EAAE,oEAAoE,EAAE,wBAAwB,CAAC;MACxI;MACAqB,KAAK,CAAC4P,uBAAuB,GAAGS,aAAa;MAC7CrQ,KAAK,CAACoE,WAAW,EAAE0E,QAAQ,CAAC,CAAC;IAC/B;EACF,CAAC;EACD/I,SAAS,CAACuT,gBAAgB,GAAGC,MAAM,IAAI;IACrC,IAAIA,MAAM,EAAE;MACVvT,KAAK,CAACgD,aAAa,GAAGuQ,MAAM;MAC5BvT,KAAK,CAACwT,sBAAsB,GAAG,IAAI;IACrC;EACF,CAAC;AACH;;AAEA;AACA;AACA;;AAEA,MAAMC,cAAc,GAAG;EACrBtP,YAAY,EAAE,CAAC,CAAC;EAChB6D,cAAc,EAAE,IAAI;EACpBxG,oBAAoB,EAAE,KAAK;EAC3B0M,wBAAwB,EAAE,KAAK;EAC/BG,yBAAyB,EAAE,KAAK;EAChCD,qBAAqB,EAAE,CAAC;EACxBE,iBAAiB,EAAE,CAAC;EACpBE,4BAA4B,EAAE,CAAC;EAC/BD,YAAY,EAAE,CAAC,CAAC;EAChBvL,aAAa,EAAE,IAAI;EACnBmC,mBAAmB,EAAE,IAAI;EACzBiB,kBAAkB,EAAE,IAAI;EACxBkB,gBAAgB,EAAE,IAAI;EACtBlD,WAAW,EAAE,IAAI;EACjBwL,uBAAuB,EAAE,IAAI;EAC7B1O,IAAI,EAAE,IAAI;EACViC,YAAY,EAAE,IAAI;EAClBC,UAAU,EAAE,IAAI;EAChBoQ,sBAAsB,EAAE,KAAK;EAC7B/O,QAAQ,EAAE;AACZ,CAAC;;AAED;;AAEA,SAASiP,MAAMA,CAAC3T,SAAS,EAAEC,KAAK,EAAE;EAChC,IAAI2T,aAAa,GAAGC,SAAS,CAACvG,MAAM,GAAG,CAAC,IAAIuG,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;EAC1FE,MAAM,CAACC,MAAM,CAAC/T,KAAK,EAAEyT,cAAc,EAAEE,aAAa,CAAC;;EAEnD;EACAzV,WAAW,CAACwV,MAAM,CAAC3T,SAAS,EAAEC,KAAK,EAAE2T,aAAa,CAAC;EACnD5V,0BAA0B,CAACiW,sCAAsC,CAACjU,SAAS,EAAEC,KAAK,EAAE2T,aAAa,CAAC;EAClG5V,0BAA0B,CAACkW,qCAAqC,CAAClU,SAAS,EAAEC,KAAK,EAAE2T,aAAa,CAAC;EACjG3T,KAAK,CAACkB,IAAI,GAAG1D,SAAS,CAAC4H,WAAW,CAAC,CAAC;EACpCpF,KAAK,CAACgD,aAAa,GAAG,IAAI;EAC1BhD,KAAK,CAACmD,YAAY,GAAG,IAAI;EACzBnD,KAAK,CAACoD,UAAU,GAAG,IAAI;EACvBpD,KAAK,CAACmE,YAAY,GAAG,CAAC,CAAC;EACvBtH,GAAG,CAACmD,KAAK,CAACmE,YAAY,CAAC;EACvBnE,KAAK,CAACsL,OAAO,GAAGpO,IAAI,CAACqC,QAAQ,CAAC,IAAI2U,YAAY,CAAC,EAAE,CAAC,CAAC;;EAEnD;EACAlU,KAAK,CAAC2R,aAAa,GAAGlU,yBAAyB,CAAC2H,WAAW,CAAC,CAAC;EAC7DpF,KAAK,CAAC2R,aAAa,CAACwC,gBAAgB,CAAC,IAAI,CAAC;EAC1CnU,KAAK,CAAC2R,aAAa,CAACyC,gBAAgB,CAAC,KAAK,CAAC;EAC3CpU,KAAK,CAACqU,YAAY,GAAGvW,WAAW,CAACsH,WAAW,CAAC,CAAC;EAC9CpF,KAAK,CAAC6R,MAAM,GAAGvU,SAAS,CAAC8H,WAAW,CAAC,CAAC;EACtCpF,KAAK,CAACiS,mBAAmB,GAAG5U,gCAAgC,CAAC+H,WAAW,CAAC,CAAC;EAC1EpF,KAAK,CAACiT,SAAS,GAAGhV,YAAY,CAACmH,WAAW,CAAC,CAAC;EAC5CrI,GAAG,CAACgD,SAAS,EAAEC,KAAK,EAAE,CAAC,eAAe,CAAC,CAAC;;EAExC;EACAF,2BAA2B,CAACC,SAAS,EAAEC,KAAK,CAAC;AAC/C;;AAEA;;AAEA,MAAMoF,WAAW,GAAGzI,aAAa,CAAC+W,MAAM,EAAE,6BAA6B,CAAC;;AAExE;;AAEA,IAAIY,qBAAqB,GAAG;EAC1BlP,WAAW;EACXsO;AACF,CAAC;;AAED;AACAhV,gBAAgB,CAAC,uBAAuB,EAAE0G,WAAW,CAAC;AAEtD,SAASkP,qBAAqB,IAAIC,OAAO,EAAEb,MAAM,EAAEtO,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}