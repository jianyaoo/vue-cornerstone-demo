"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@cornerstonejs/core");
const StreamingImageVolume_1 = __importDefault(require("./StreamingImageVolume"));
function cornerstoneStreamingImageVolumeLoader(volumeId, options) {
    if (!options || !options.imageIds || !options.imageIds.length) {
        throw new Error('ImageIds must be provided to create a streaming image volume');
    }
    function getStreamingImageVolume() {
        return __awaiter(this, void 0, void 0, function* () {
            if (options.imageIds[0].split(':')[0] === 'wadouri') {
                const [middleImageIndex, lastImageIndex] = [
                    Math.floor(options.imageIds.length / 2),
                    options.imageIds.length - 1,
                ];
                const indexesToPrefetch = [0, middleImageIndex, lastImageIndex];
                yield Promise.all(indexesToPrefetch.map((index) => {
                    return new Promise((resolve, reject) => {
                        const imageId = options.imageIds[index];
                        core_1.imageLoadPoolManager.addRequest(() => __awaiter(this, void 0, void 0, function* () {
                            core_1.imageLoader
                                .loadImage(imageId)
                                .then(() => {
                                console.log(`Prefetched imageId: ${imageId}`);
                                resolve(true);
                            })
                                .catch((err) => {
                                reject(err);
                            });
                        }), core_1.Enums.RequestType.Prefetch, { volumeId }, 1);
                    });
                })).catch(console.error);
            }
            const { dimensions, spacing, origin, scalarData, direction, sizeInBytes, metadata, imageIds, } = core_1.utilities.generateVolumePropsFromImageIds(options.imageIds, volumeId);
            const streamingImageVolume = new StreamingImageVolume_1.default({
                volumeId,
                metadata,
                dimensions,
                spacing,
                origin,
                direction,
                scalarData,
                sizeInBytes,
                imageIds,
            }, {
                imageIds,
                loadStatus: {
                    loaded: false,
                    loading: false,
                    cancelled: false,
                    cachedFrames: [],
                    callbacks: [],
                },
            });
            return streamingImageVolume;
        });
    }
    const streamingImageVolumePromise = getStreamingImageVolume();
    return {
        promise: streamingImageVolumePromise,
        decache: () => {
            streamingImageVolumePromise.then((streamingImageVolume) => {
                streamingImageVolume.destroy();
                streamingImageVolume = null;
            });
        },
        cancel: () => {
            streamingImageVolumePromise.then((streamingImageVolume) => {
                streamingImageVolume.cancelLoading();
            });
        },
    };
}
exports.default = cornerstoneStreamingImageVolumeLoader;
//# sourceMappingURL=cornerstoneStreamingImageVolumeLoader.js.map