{"ast":null,"code":"import { m as macro } from '../../../macros2.js';\nimport Endian from '../../../Common/Core/Endian.js';\nimport { DataTypeByteSize } from '../../../Common/Core/DataArray/Constants.js';\nimport { has, registerType } from '../DataAccessHelper.js';\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\nconst REJECT_COMPRESSION = () => {\n  vtkErrorMacro('LiteHttpDataAccessHelper does not support compression. Need to register HttpDataAccessHelper instead.');\n  return Promise.reject(new Error('LiteHttpDataAccessHelper does not support compression. Need to register HttpDataAccessHelper instead.'));\n};\n\n/* eslint-disable prefer-promise-reject-errors */\nlet requestCount = 0;\nfunction openAsyncXHR(method, url) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const xhr = new XMLHttpRequest();\n  xhr.open(method, url, true);\n  if (options.headers) {\n    Object.entries(options.headers).forEach(_ref => {\n      let [key, value] = _ref;\n      return xhr.setRequestHeader(key, value);\n    });\n  }\n  if (options.progressCallback) {\n    xhr.addEventListener('progress', options.progressCallback);\n  }\n  return xhr;\n}\nfunction fetchBinary(url) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new Promise((resolve, reject) => {\n    const xhr = openAsyncXHR('GET', url, options);\n    xhr.onreadystatechange = e => {\n      if (xhr.readyState === 4) {\n        if (xhr.status === 200 || xhr.status === 0) {\n          resolve(xhr.response);\n        } else {\n          reject({\n            xhr,\n            e\n          });\n        }\n      }\n    };\n\n    // Make request\n    xhr.responseType = 'arraybuffer';\n    xhr.send();\n  });\n}\nfunction fetchArray(instance, baseURL, array) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  if (options && options.compression) {\n    return REJECT_COMPRESSION();\n  }\n  if (array.ref && !array.ref.pending) {\n    return new Promise((resolve, reject) => {\n      const url = [baseURL, array.ref.basepath, array.ref.id].join('/');\n      const xhr = openAsyncXHR('GET', url, options);\n      xhr.onreadystatechange = e => {\n        if (xhr.readyState === 1) {\n          array.ref.pending = true;\n          if (++requestCount === 1 && instance?.invokeBusy) {\n            instance.invokeBusy(true);\n          }\n        }\n        if (xhr.readyState === 4) {\n          array.ref.pending = false;\n          if (xhr.status === 200 || xhr.status === 0) {\n            array.buffer = xhr.response;\n            if (array.ref.encode === 'JSON') {\n              array.values = JSON.parse(array.buffer);\n            } else {\n              if (Endian.ENDIANNESS !== array.ref.encode && Endian.ENDIANNESS) {\n                // Need to swap bytes\n                vtkDebugMacro(`Swap bytes of ${array.name}`);\n                Endian.swapBytes(array.buffer, DataTypeByteSize[array.dataType]);\n              }\n              array.values = macro.newTypedArray(array.dataType, array.buffer);\n            }\n            if (array.values.length !== array.size) {\n              vtkErrorMacro(`Error in FetchArray: ${array.name}, does not have the proper array size. Got ${array.values.length}, instead of ${array.size}`);\n            }\n\n            // Done with the ref and work\n            delete array.ref;\n            if (--requestCount === 0 && instance?.invokeBusy) {\n              instance.invokeBusy(false);\n            }\n            if (instance?.modified) {\n              instance.modified();\n            }\n            resolve(array);\n          } else {\n            reject({\n              xhr,\n              e\n            });\n          }\n        }\n      };\n\n      // Make request\n      xhr.responseType = array.dataType !== 'string' ? 'arraybuffer' : 'text';\n      xhr.send();\n    });\n  }\n  return Promise.resolve(array);\n}\n\n// ----------------------------------------------------------------------------\n\nfunction fetchJSON(instance, url) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (options && options.compression) {\n    return REJECT_COMPRESSION();\n  }\n  return new Promise((resolve, reject) => {\n    const xhr = openAsyncXHR('GET', url, options);\n    xhr.onreadystatechange = e => {\n      if (xhr.readyState === 1) {\n        if (++requestCount === 1 && instance?.invokeBusy) {\n          instance.invokeBusy(true);\n        }\n      }\n      if (xhr.readyState === 4) {\n        if (--requestCount === 0 && instance?.invokeBusy) {\n          instance.invokeBusy(false);\n        }\n        if (xhr.status === 200 || xhr.status === 0) {\n          resolve(JSON.parse(xhr.responseText));\n        } else {\n          reject({\n            xhr,\n            e\n          });\n        }\n      }\n    };\n\n    // Make request\n    xhr.responseType = 'text';\n    xhr.send();\n  });\n}\n\n// ----------------------------------------------------------------------------\n\nfunction fetchText(instance, url) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (options && options.compression) {\n    return REJECT_COMPRESSION();\n  }\n  return new Promise((resolve, reject) => {\n    const xhr = openAsyncXHR('GET', url, options);\n    xhr.onreadystatechange = e => {\n      if (xhr.readyState === 1) {\n        if (++requestCount === 1 && instance?.invokeBusy) {\n          instance.invokeBusy(true);\n        }\n      }\n      if (xhr.readyState === 4) {\n        if (--requestCount === 0 && instance?.invokeBusy) {\n          instance.invokeBusy(false);\n        }\n        if (xhr.status === 200 || xhr.status === 0) {\n          resolve(xhr.responseText);\n        } else {\n          reject({\n            xhr,\n            e\n          });\n        }\n      }\n    };\n\n    // Make request\n    xhr.responseType = 'text';\n    xhr.send();\n  });\n}\n\n// ----------------------------------------------------------------------------\n\nfunction fetchImage(instance, url) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    if (options.crossOrigin) {\n      img.crossOrigin = options.crossOrigin;\n    }\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = url;\n  });\n}\n/* eslint-enable prefer-promise-reject-errors */\n\n// ----------------------------------------------------------------------------\n\nconst LiteHttpDataAccessHelper = {\n  fetchArray,\n  fetchJSON,\n  fetchText,\n  fetchBinary,\n  // Only for HTTP\n  fetchImage\n};\n\n// The lite version should never override a full feature one...\nif (!has('http')) {\n  registerType('http', options => LiteHttpDataAccessHelper);\n}\nexport { LiteHttpDataAccessHelper as default };","map":{"version":3,"names":["m","macro","Endian","DataTypeByteSize","has","registerType","vtkErrorMacro","vtkDebugMacro","REJECT_COMPRESSION","Promise","reject","Error","requestCount","openAsyncXHR","method","url","options","arguments","length","undefined","xhr","XMLHttpRequest","open","headers","Object","entries","forEach","_ref","key","value","setRequestHeader","progressCallback","addEventListener","fetchBinary","resolve","onreadystatechange","e","readyState","status","response","responseType","send","fetchArray","instance","baseURL","array","compression","ref","pending","basepath","id","join","invokeBusy","buffer","encode","values","JSON","parse","ENDIANNESS","name","swapBytes","dataType","newTypedArray","size","modified","fetchJSON","responseText","fetchText","fetchImage","img","Image","crossOrigin","onload","onerror","src","LiteHttpDataAccessHelper","default"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/IO/Core/DataAccessHelper/LiteHttpDataAccessHelper.js"],"sourcesContent":["import { m as macro } from '../../../macros2.js';\nimport Endian from '../../../Common/Core/Endian.js';\nimport { DataTypeByteSize } from '../../../Common/Core/DataArray/Constants.js';\nimport { has, registerType } from '../DataAccessHelper.js';\n\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\nconst REJECT_COMPRESSION = () => {\n  vtkErrorMacro('LiteHttpDataAccessHelper does not support compression. Need to register HttpDataAccessHelper instead.');\n  return Promise.reject(new Error('LiteHttpDataAccessHelper does not support compression. Need to register HttpDataAccessHelper instead.'));\n};\n\n/* eslint-disable prefer-promise-reject-errors */\nlet requestCount = 0;\nfunction openAsyncXHR(method, url) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const xhr = new XMLHttpRequest();\n  xhr.open(method, url, true);\n  if (options.headers) {\n    Object.entries(options.headers).forEach(_ref => {\n      let [key, value] = _ref;\n      return xhr.setRequestHeader(key, value);\n    });\n  }\n  if (options.progressCallback) {\n    xhr.addEventListener('progress', options.progressCallback);\n  }\n  return xhr;\n}\nfunction fetchBinary(url) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new Promise((resolve, reject) => {\n    const xhr = openAsyncXHR('GET', url, options);\n    xhr.onreadystatechange = e => {\n      if (xhr.readyState === 4) {\n        if (xhr.status === 200 || xhr.status === 0) {\n          resolve(xhr.response);\n        } else {\n          reject({\n            xhr,\n            e\n          });\n        }\n      }\n    };\n\n    // Make request\n    xhr.responseType = 'arraybuffer';\n    xhr.send();\n  });\n}\nfunction fetchArray(instance, baseURL, array) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  if (options && options.compression) {\n    return REJECT_COMPRESSION();\n  }\n  if (array.ref && !array.ref.pending) {\n    return new Promise((resolve, reject) => {\n      const url = [baseURL, array.ref.basepath, array.ref.id].join('/');\n      const xhr = openAsyncXHR('GET', url, options);\n      xhr.onreadystatechange = e => {\n        if (xhr.readyState === 1) {\n          array.ref.pending = true;\n          if (++requestCount === 1 && instance?.invokeBusy) {\n            instance.invokeBusy(true);\n          }\n        }\n        if (xhr.readyState === 4) {\n          array.ref.pending = false;\n          if (xhr.status === 200 || xhr.status === 0) {\n            array.buffer = xhr.response;\n            if (array.ref.encode === 'JSON') {\n              array.values = JSON.parse(array.buffer);\n            } else {\n              if (Endian.ENDIANNESS !== array.ref.encode && Endian.ENDIANNESS) {\n                // Need to swap bytes\n                vtkDebugMacro(`Swap bytes of ${array.name}`);\n                Endian.swapBytes(array.buffer, DataTypeByteSize[array.dataType]);\n              }\n              array.values = macro.newTypedArray(array.dataType, array.buffer);\n            }\n            if (array.values.length !== array.size) {\n              vtkErrorMacro(`Error in FetchArray: ${array.name}, does not have the proper array size. Got ${array.values.length}, instead of ${array.size}`);\n            }\n\n            // Done with the ref and work\n            delete array.ref;\n            if (--requestCount === 0 && instance?.invokeBusy) {\n              instance.invokeBusy(false);\n            }\n            if (instance?.modified) {\n              instance.modified();\n            }\n            resolve(array);\n          } else {\n            reject({\n              xhr,\n              e\n            });\n          }\n        }\n      };\n\n      // Make request\n      xhr.responseType = array.dataType !== 'string' ? 'arraybuffer' : 'text';\n      xhr.send();\n    });\n  }\n  return Promise.resolve(array);\n}\n\n// ----------------------------------------------------------------------------\n\nfunction fetchJSON(instance, url) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (options && options.compression) {\n    return REJECT_COMPRESSION();\n  }\n  return new Promise((resolve, reject) => {\n    const xhr = openAsyncXHR('GET', url, options);\n    xhr.onreadystatechange = e => {\n      if (xhr.readyState === 1) {\n        if (++requestCount === 1 && instance?.invokeBusy) {\n          instance.invokeBusy(true);\n        }\n      }\n      if (xhr.readyState === 4) {\n        if (--requestCount === 0 && instance?.invokeBusy) {\n          instance.invokeBusy(false);\n        }\n        if (xhr.status === 200 || xhr.status === 0) {\n          resolve(JSON.parse(xhr.responseText));\n        } else {\n          reject({\n            xhr,\n            e\n          });\n        }\n      }\n    };\n\n    // Make request\n    xhr.responseType = 'text';\n    xhr.send();\n  });\n}\n\n// ----------------------------------------------------------------------------\n\nfunction fetchText(instance, url) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (options && options.compression) {\n    return REJECT_COMPRESSION();\n  }\n  return new Promise((resolve, reject) => {\n    const xhr = openAsyncXHR('GET', url, options);\n    xhr.onreadystatechange = e => {\n      if (xhr.readyState === 1) {\n        if (++requestCount === 1 && instance?.invokeBusy) {\n          instance.invokeBusy(true);\n        }\n      }\n      if (xhr.readyState === 4) {\n        if (--requestCount === 0 && instance?.invokeBusy) {\n          instance.invokeBusy(false);\n        }\n        if (xhr.status === 200 || xhr.status === 0) {\n          resolve(xhr.responseText);\n        } else {\n          reject({\n            xhr,\n            e\n          });\n        }\n      }\n    };\n\n    // Make request\n    xhr.responseType = 'text';\n    xhr.send();\n  });\n}\n\n// ----------------------------------------------------------------------------\n\nfunction fetchImage(instance, url) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    if (options.crossOrigin) {\n      img.crossOrigin = options.crossOrigin;\n    }\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = url;\n  });\n}\n/* eslint-enable prefer-promise-reject-errors */\n\n// ----------------------------------------------------------------------------\n\nconst LiteHttpDataAccessHelper = {\n  fetchArray,\n  fetchJSON,\n  fetchText,\n  fetchBinary,\n  // Only for HTTP\n  fetchImage\n};\n\n// The lite version should never override a full feature one...\nif (!has('http')) {\n  registerType('http', options => LiteHttpDataAccessHelper);\n}\n\nexport { LiteHttpDataAccessHelper as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}