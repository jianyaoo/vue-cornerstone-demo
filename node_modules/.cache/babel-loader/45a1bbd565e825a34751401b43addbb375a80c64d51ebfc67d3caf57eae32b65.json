{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { m as macro } from '../../../macros2.js';\nimport vtkPoints from '../../../Common/Core/Points.js';\nimport { s as subtract, j as cross, d as dot, n as norm, e as distance2BetweenPoints, k as add, l as normalize } from '../../../Common/Core/Math/index.js';\nimport vtkLine from '../../../Common/DataModel/Line.js';\nimport vtkPolygon from '../../../Common/DataModel/Polygon.js';\nimport vtkIncrementalOctreePointLocator from '../../../Common/DataModel/IncrementalOctreePointLocator.js';\nimport { VtkDataTypes } from '../../../Common/Core/DataArray/Constants.js';\nimport { CCS_POLYGON_TOLERANCE } from './Constants.js';\nimport { PolygonWithPointIntersectionState } from '../../../Common/DataModel/Polygon/Constants.js';\nconst {\n  vtkErrorMacro\n} = macro;\n\n/**\n * Reverse the elements between the indices firstIdx and lastIdx of the given array arr.\n *\n * @param {Array|TypedArray} arr\n * @param {Number} firstIdx\n * @param {Number} lastIdx\n */\nfunction reverseElements(arr) {\n  let firstIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  let lastIdx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  const first = firstIdx ?? 0;\n  const last = lastIdx ?? arr.length - 1;\n  const mid = first + Math.floor((last - first) / 2);\n  for (let i = first; i <= mid; ++i) {\n    [arr[i], arr[last - (i - first)]] = [arr[last - (i - first)], arr[i]];\n  }\n}\n\n// ---------------------------------------------------\n/**\n * Compute the quality of a triangle.\n *\n * @param {Vector3} p0\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {Vector3} normal\n * @returns {Number}\n */\nfunction vtkCCSTriangleQuality(p0, p1, p2, normal) {\n  const u = [];\n  const v = [];\n  const w = [];\n  subtract(p1, p0, u);\n  subtract(p2, p1, v);\n  subtract(p0, p2, w);\n  const area2 = (u[1] * v[2] - u[2] * v[1]) * normal[0] + (u[2] * v[0] - u[0] * v[2]) * normal[1] + (u[0] * v[1] - u[1] * v[0]) * normal[2];\n  let perim = Math.sqrt(u[0] * u[0] + u[1] * u[1] + u[2] * u[2]) + Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]) + Math.sqrt(w[0] * w[0] + w[1] * w[1] + w[2] * w[2]);\n  perim *= perim; // square the perimeter\n  perim = perim !== 0 ? perim : 1.0;\n\n  // use a normalization factor so equilateral quality is 1.0\n  return area2 / perim * 10.392304845413264;\n}\n\n// ---------------------------------------------------\n/**\n * Insert a triangle, and subdivide that triangle if one of\n * its edges originally had more than two points before\n * vtkCCSFindTrueEdges was called. Is called by vtkCCSTriangulate.\n *\n * @param {vtkCellArray} polys\n * @param {Array|TypedArray} poly\n * @param {Vector3} trids\n * @param {Array|TypedArray} polyEdges\n * @param {Array|TypedArray} originalEdges\n */\nfunction vtkCCSInsertTriangle(polys, poly, trids, polyEdges, originalEdges) {\n  const nextVert = [1, 2, 0];\n\n  // To store how many of originalEdges match\n  let edgeCount = 0;\n  const edgeLocs = [-1, -1, -1];\n\n  // Check for original edge matches\n  for (let vert = 0; vert < 3; vert++) {\n    const currId = trids[vert];\n    const edgeLoc = polyEdges[currId];\n    if (edgeLoc >= 0) {\n      let nextId = currId + 1;\n      if (nextId === poly.length) {\n        nextId = 0;\n      }\n\n      // Is the triangle edge a polygon edge?\n      if (nextId === trids[nextVert[vert]]) {\n        edgeLocs[vert] = edgeLoc;\n        edgeCount++;\n      }\n    }\n  }\n  if (edgeCount === 0) {\n    // No special edge handling, so just do one triangle\n    polys.insertNextCell([poly[trids[0]], poly[trids[1]], poly[trids[2]]]);\n  } else {\n    // Make triangle fans for edges with extra points\n    const edgePts = [[poly[trids[0]], poly[trids[1]]], [poly[trids[1]], poly[trids[2]]], [poly[trids[2]], poly[trids[0]]]];\n\n    // Find out which edge has the most extra points\n    let maxPoints = 0;\n    let currSide = 0;\n    for (let i = 0; i < 3; i++) {\n      if (edgeLocs[i] >= 0) {\n        const edgeLoc = edgeLocs[i];\n        const npts = originalEdges[edgeLoc];\n        const pts = originalEdges.slice(edgeLoc + 1, edgeLoc + 1 + npts);\n        if (!(edgePts[i][0] === pts[0] || edgePts[i][1] === pts[npts - 1])) {\n          vtkErrorMacro('assertion error in vtkCCSInsertTriangle');\n        }\n        if (npts > maxPoints) {\n          maxPoints = npts;\n          currSide = i;\n        }\n        edgePts[i] = pts;\n      }\n    }\n\n    // Find the edges before/after the edge with most points\n    const prevSide = (currSide + 2) % 3;\n    const nextSide = (currSide + 1) % 3;\n\n    // If other edges have only 2 points, nothing to do with them\n    const prevNeeded = edgePts[prevSide].length > 2;\n    const nextNeeded = edgePts[nextSide].length > 2;\n\n    // The tail is the common point in the triangle fan\n    const tailPtIds = [];\n    tailPtIds[prevSide] = edgePts[currSide][1];\n    tailPtIds[currSide] = edgePts[prevSide][0];\n    tailPtIds[nextSide] = edgePts[currSide][edgePts[currSide].length - 2];\n\n    // Go through the sides and make the fans\n    for (let side = 0; side < 3; side++) {\n      if ((side !== prevSide || prevNeeded) && (side !== nextSide || nextNeeded)) {\n        let m = 0;\n        let n = edgePts[side].length - 1;\n        if (side === currSide) {\n          m += prevNeeded;\n          n -= nextNeeded;\n        }\n        for (let k = m; k < n; k++) {\n          polys.insertNextCell([edgePts[side][k], edgePts[side][k + 1], tailPtIds[side]]);\n        }\n      }\n    }\n  }\n}\n\n// ---------------------------------------------------\n/**\n * Triangulate a polygon that has been simplified by FindTrueEdges.\n * This will re-insert the original edges.  The output triangles are\n * appended to \"polys\" and, for each stored triangle, \"color\" will\n * be added to \"scalars\".  The final two arguments (polygon and\n * triangles) are only for temporary storage.\n * The return value is true if triangulation was successful.\n *\n * @param {Array} poly\n * @param {vtkPoints} points\n * @param {Array} polyEdges\n * @param {Array} originalEdges\n * @param {vtkCellArray} polys\n * @param {Vector3} normal\n * @returns {boolean}\n */\nfunction vtkCCSTriangulate(poly, points, polyEdges, originalEdges, polys, normal) {\n  let n = poly.length;\n\n  // If the poly is a line, then skip it\n  if (n < 3) {\n    return true;\n  }\n\n  // If the poly is a triangle, then pass it\n  if (n === 3) {\n    const trids = [0, 1, 2];\n    vtkCCSInsertTriangle(polys, poly, trids, polyEdges, originalEdges);\n    return true;\n  }\n\n  // If the poly has 4 or more points, triangulate it\n  let triangulationFailure = false;\n  let ppoint = [];\n  let point = [];\n  let npoint = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  const verts = [];\n  verts.length = n;\n  for (i = 0; i < n; i++) {\n    verts[i] = [i, 0];\n  }\n\n  // compute the triangle quality for each vert\n  k = n - 2;\n  points.getPoint(poly[verts[k][0]], point);\n  i = n - 1;\n  points.getPoint(poly[verts[i][0]], npoint);\n  let concave = 0;\n  let maxq = 0;\n  let maxi = 0;\n  for (j = 0; j < n; j++) {\n    [ppoint, point, npoint] = [point, npoint, ppoint];\n    points.getPoint(poly[verts[j][0]], npoint);\n    const q = vtkCCSTriangleQuality(ppoint, point, npoint, normal);\n    if (q > maxq) {\n      maxi = i;\n      maxq = q;\n    }\n    concave += q < 0;\n    verts[i][1] = q;\n    i = j;\n  }\n  let foundEar;\n  // perform the ear-cut triangulation\n  for (;;) {\n    // if no potential ears were found, then fail\n    if (maxq <= Number.MIN_VALUE) {\n      triangulationFailure = true;\n      break;\n    }\n    i = maxi;\n    j = i + 1 !== n ? i + 1 : 0;\n    k = i !== 0 ? i - 1 : n - 1;\n    if (verts[i][1] > 0) {\n      foundEar = true;\n      points.getPoint(poly[verts[j][0]], npoint);\n      points.getPoint(poly[verts[k][0]], ppoint);\n\n      // only do ear check if there are concave vertices\n      if (concave) {\n        // get the normal of the split plane\n        const v = [];\n        const u = [];\n        subtract(npoint, ppoint, v);\n        cross(v, normal, u);\n        const d = dot(ppoint, u);\n        let jj = j + 1 !== n ? j + 1 : 0;\n        let x = [];\n        points.getPoint(poly[verts[jj][0]], x);\n        let side = dot(x, u) < d;\n        let foundNegative = side;\n\n        // check for crossings of the split plane\n        jj = jj + 1 !== n ? jj + 1 : 0;\n        let y = [];\n        const s = [];\n        const t = [];\n        for (; foundEar && jj !== k; jj = jj + 1 !== n ? jj + 1 : 0) {\n          [x, y] = [y, x];\n          points.getPoint(poly[verts[jj][0]], x);\n          const sside = dot(x, u) < d;\n          // XOR\n          if (side ? !sside : sside) {\n            side = !side;\n            foundNegative = true;\n            foundEar = vtkLine.intersection(ppoint, npoint, x, y, s, t) === vtkLine.IntersectionState.NO_INTERSECTION;\n          }\n        }\n        foundEar &&= foundNegative;\n      }\n      if (!foundEar) {\n        // don't try again until it is split\n        verts[i][1] = Number.MIN_VALUE;\n      } else {\n        // create a triangle from vertex and neighbors\n        const trids = [verts[i][0], verts[j][0], verts[k][0]];\n        vtkCCSInsertTriangle(polys, poly, trids, polyEdges, originalEdges);\n\n        // remove the vertex i\n        verts.splice(i, 1);\n        k -= i === 0;\n        j -= j !== 0;\n\n        // break if this was final triangle\n        if (--n < 3) {\n          break;\n        }\n\n        // re-compute quality of previous point\n        const kk = k !== 0 ? k - 1 : n - 1;\n        points.getPoint(poly[verts[kk][0]], point);\n        const kq = vtkCCSTriangleQuality(point, ppoint, npoint, normal);\n        concave -= verts[k][1] < 0 && kq >= 0;\n        verts[k][1] = kq;\n\n        // re-compute quality of next point\n        const jj = j + 1 !== n ? j + 1 : 0;\n        points.getPoint(poly[verts[jj][0]], point);\n        const jq = vtkCCSTriangleQuality(ppoint, npoint, point, normal);\n        concave -= verts[j][1] < 0 && jq >= 0;\n        verts[j][1] = jq;\n      }\n    }\n\n    // find the highest-quality ear candidate\n    maxi = 0;\n    maxq = verts[0][1];\n    for (i = 1; i < n; i++) {\n      const q = verts[i][1];\n      if (q > maxq) {\n        maxi = i;\n        maxq = q;\n      }\n    }\n  }\n  return !triangulationFailure;\n}\n\n// ---------------------------------------------------\n/**\n * Create polygons from line segments.\n *\n * @param {vtkPolyData} polyData\n * @param {Number} firstLine\n * @param {Number} endLine\n * @param {Boolean} oriented\n * @param {Array} newPolys\n * @param {Array} incompletePolys\n */\nfunction vtkCCSMakePolysFromLines(polyData, firstLine, endLine, oriented, newPolys, incompletePolys) {\n  let npts = 0;\n  let pts = [];\n\n  // Bitfield for marking lines as used\n  const usedLines = new Uint8Array(endLine - firstLine); // defaults to 0\n\n  // Require cell links to get lines from pointIds\n  polyData.buildLinks(polyData.getPoints().getNumberOfPoints());\n  let numNewPolys = 0;\n  let remainingLines = endLine - firstLine;\n  while (remainingLines > 0) {\n    // Create a new poly\n    const polyId = numNewPolys++;\n    const poly = [];\n    newPolys.push(poly);\n    let lineId = 0;\n    let completePoly = false;\n\n    // start the poly\n    for (lineId = firstLine; lineId < endLine; lineId++) {\n      if (!usedLines[lineId - firstLine]) {\n        pts = polyData.getCellPoints(lineId).cellPointIds;\n        npts = pts.length;\n        let n = npts;\n        if (npts > 2 && pts[0] === pts[npts - 1]) {\n          n = npts - 1;\n          completePoly = true;\n        }\n        poly.length = n;\n        for (let i = 0; i < n; i++) {\n          poly[i] = pts[i];\n        }\n        break;\n      }\n    }\n    usedLines[lineId - firstLine] = 1;\n    remainingLines--;\n    let noLinesMatch = remainingLines === 0 && !completePoly;\n    while (!completePoly && !noLinesMatch && remainingLines > 0) {\n      // This is cleared if a match is found\n      noLinesMatch = true;\n\n      // Number of points in the poly\n      const npoly = poly.length;\n      const lineEndPts = [];\n      const endPts = [poly[npoly - 1], poly[0]];\n\n      // For both open ends of the polygon\n      for (let endIdx = 0; endIdx < 2; endIdx++) {\n        const matches = [];\n        const cells = polyData.getPointCells(endPts[endIdx]);\n\n        // Go through all lines that contain this endpoint\n        for (let icell = 0; icell < cells.length; icell++) {\n          lineId = cells[icell];\n          if (lineId >= firstLine && lineId < endLine && !usedLines[lineId - firstLine]) {\n            pts = polyData.getCellPoints(lineId).cellPointIds;\n            npts = pts.length;\n            lineEndPts[0] = pts[0];\n            lineEndPts[1] = pts[npts - 1];\n\n            // Check that poly end matches line end\n            if (endPts[endIdx] === lineEndPts[endIdx] || !oriented && endPts[endIdx] === lineEndPts[1 - endIdx]) {\n              matches.push(lineId);\n            }\n          }\n        }\n        if (matches.length > 0) {\n          // Multiple matches mean we need to decide which path to take\n          if (matches.length > 1) {\n            // Remove double-backs\n            let k = matches.length;\n            do {\n              lineId = matches[--k];\n              pts = polyData.getCellPoints(lineId).cellPointIds;\n              npts = pts.length;\n              lineEndPts[0] = pts[0];\n              lineEndPts[1] = pts[npts - 1];\n              // check if line is reversed\n              const r = endPts[endIdx] !== lineEndPts[endIdx];\n              if (!r && (endIdx === 0 && poly[npoly - 2] === pts[1] || endIdx === 1 && poly[1] === pts[npts - 2]) || r && (endIdx === 0 && poly[npoly - 2] === pts[npts - 2] || endIdx === 1 && poly[1] === pts[1])) {\n                matches.splice(k, 1);\n              }\n            } while (k > 0 && matches.length > 1);\n\n            // If there are multiple matches due to intersections,\n            // they should be dealt with here.\n          }\n          lineId = matches[0];\n          pts = polyData.getCellPoints(lineId).cellPointIds;\n          npts = pts.length;\n          lineEndPts[0] = pts[0];\n          lineEndPts[1] = pts[npts - 1];\n\n          // Do both ends match?\n          if (endPts[endIdx] === lineEndPts[endIdx]) {\n            completePoly = endPts[1 - endIdx] === lineEndPts[1 - endIdx];\n          } else {\n            completePoly = endPts[1 - endIdx] === lineEndPts[endIdx];\n          }\n          if (endIdx === 0) {\n            for (let i = 1; i < npts - (completePoly ? 1 : 0); i++) {\n              poly.push(pts[i]);\n            }\n          } else {\n            for (let i = completePoly ? 1 : 0; i < npts - 1; i++) {\n              poly.unshift(pts[i]);\n            }\n          }\n          if (endPts[endIdx] !== lineEndPts[endIdx]) {\n            // reverse the ids in the added line\n            let pit = poly.length;\n            let ptsIt = completePoly ? 1 : 0;\n            let ptsEnd = npts - 1;\n            if (endIdx === 1) {\n              pit = npts - 1 - (completePoly ? 1 : 0);\n              ptsIt = pts + 1;\n              ptsEnd = pts + npts - (completePoly ? 1 : 0);\n            }\n            while (ptsIt !== ptsEnd) {\n              poly[--pit] = poly[ptsIt++];\n            }\n          }\n          usedLines[lineId - firstLine] = 1;\n          remainingLines--;\n          noLinesMatch = false;\n        }\n      }\n    }\n\n    // Check for incomplete polygons\n    if (noLinesMatch) {\n      incompletePolys.push(polyId);\n    }\n  }\n}\n\n// ---------------------------------------------------\n/**\n * Join polys that have loose ends, as indicated by incompletePolys.\n * Any polys created will have a normal opposite to the supplied normal,\n * and any new edges that are created will be on the hull of the point set.\n * Shorter edges will be preferred over long edges.\n *\n * @param {Array[]} polys\n * @param {Array} incompletePolys\n * @param {vtkPoints} points\n * @param {Vector3} normal\n */\nfunction vtkCCSJoinLooseEnds(polys, incompletePolys, points, normal) {\n  // Relative tolerance for checking whether an edge is on the hull\n  const tol = CCS_POLYGON_TOLERANCE;\n\n  // A list of polys to remove when everything is done\n  const removePolys = [];\n  const p1 = [];\n  const p2 = [];\n  let poly1;\n  let poly2;\n  let pt1;\n  let pt2;\n  let dMin;\n  let iMin;\n  let v;\n  let d;\n  let n = incompletePolys.length;\n  while (n !== 0) {\n    poly1 = polys[incompletePolys[n - 1]];\n    pt1 = poly1[poly1.length - 1];\n    points.getPoint(pt1, p1);\n    dMin = Number.MAX_VALUE;\n    iMin = 0;\n    for (let i = 0; i < n; i++) {\n      poly2 = polys[incompletePolys[i]];\n      pt2 = poly2[0];\n      points.getPoint(pt2, p2);\n\n      // The next few steps verify that edge [p1, p2] is on the hull\n      v = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n      d = norm(v);\n      if (d !== 0) {\n        v[0] /= d;\n        v[1] /= d;\n        v[2] /= d;\n      }\n\n      // Compute the midpoint of the edge\n      const pm = [0.5 * (p1[0] + p2[0]), 0.5 * (p1[1] + p2[1]), 0.5 * (p1[2] + p2[2])];\n\n      // Create a plane equation\n      const pc = [];\n      cross(normal, v, pc);\n      pc[3] = -dot(pc, pm);\n\n      // Check that all points are inside the plane.  If they aren't, then\n      // the edge is not on the hull of the pointset.\n      let badPoint = false;\n      const m = polys.length;\n      const p = [];\n      for (let j = 0; j < m && !badPoint; j++) {\n        const poly = polys[j];\n        const npts = poly.length;\n        for (let k = 0; k < npts; k++) {\n          const ptId = poly[k];\n          if (ptId !== pt1 && ptId !== pt2) {\n            points.getPoint(ptId, p);\n            const val = p[0] * pc[0] + p[1] * pc[1] + p[2] * pc[2] + pc[3];\n            const r2 = distance2BetweenPoints(p, pm);\n\n            // Check distance from plane against the tolerance\n            if (val < 0 && val * val > tol * tol * r2) {\n              badPoint = true;\n              break;\n            }\n          }\n        }\n\n        // If no bad points, then this edge is a candidate\n        if (!badPoint && d < dMin) {\n          dMin = d;\n          iMin = i;\n        }\n      }\n    }\n\n    // If a match was found, append the polys\n    if (dMin < Number.MAX_VALUE) {\n      // Did the poly match with itself?\n      if (iMin === n - 1) {\n        // Mark the poly as closed\n        incompletePolys.pop();\n      } else {\n        const id2 = incompletePolys[iMin];\n\n        // Combine the polys\n        // for (let i = 1; i < polys[id2].length; i++) {\n        //   poly1.push(polys[id2][i]);\n        // }\n        poly1.push(...polys[id2]);\n\n        // Erase the second poly\n        removePolys.push(id2);\n        incompletePolys.splice(iMin, 1);\n      }\n    } else {\n      // If no match, erase this poly from consideration\n      removePolys.push(incompletePolys[n - 1]);\n      incompletePolys.pop();\n    }\n    n = incompletePolys.length;\n  }\n\n  // Remove polys that couldn't be completed\n  removePolys.sort((a, b) => a - b);\n  let i = removePolys.length;\n  while (i > 0) {\n    // Remove items in reverse order\n    polys.splice(removePolys[--i], 1);\n  }\n\n  // Clear the incompletePolys vector, it's indices are no longer valid\n  incompletePolys.length = 0;\n}\n\n// ---------------------------------------------------\n/**\n * Given three vectors p.p1, p.p2, and p.p3, this routine\n * checks to see if progressing from p1 to p2 to p3 is a clockwise\n * or counterclockwise progression with respect to the normal.\n * The return value is -1 for clockwise, +1 for counterclockwise,\n * and 0 if any two of the vectors are coincident.\n *\n * @param {Vector3} p\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {Vector3} p3\n * @param {Vector3} normal\n * @returns {Number}\n */\nfunction vtkCCSVectorProgression(p, p1, p2, p3, normal) {\n  const v1 = [p1[0] - p[0], p1[1] - p[1], p1[2] - p[2]];\n  const v2 = [p2[0] - p[0], p2[1] - p[1], p2[2] - p[2]];\n  const v3 = [p3[0] - p[0], p3[1] - p[1], p3[2] - p[2]];\n  const w1 = [];\n  const w2 = [];\n  cross(v2, v1, w1);\n  cross(v2, v3, w2);\n  const s1 = dot(w1, normal);\n  const s2 = dot(w2, normal);\n  if (s1 !== 0 && s2 !== 0) {\n    const sb1 = s1 < 0;\n    const sb2 = s2 < 0;\n\n    // if sines have different signs\n    // XOR\n    if (sb1 ? !sb2 : sb2) {\n      // return -1 if s2 is -ve\n      return 1 - 2 * sb2;\n    }\n    const c1 = dot(v2, v1);\n    const l1 = norm(v1);\n    const c2 = dot(v2, v3);\n    const l2 = norm(v3);\n\n    // ck is the difference of the cosines, flipped in sign if sines are +ve\n    const ck = (c2 * l2 - c1 * l1) * (1 - sb1 * 2);\n    if (ck !== 0) {\n      // return the sign of ck\n      return 1 - 2 * (ck < 0);\n    }\n  }\n  return 0;\n}\n\n// ---------------------------------------------------\n/**\n * Check for self-intersection. Split the figure-eights.\n * This assumes that all intersections occur at existing\n * vertices, i.e. no new vertices will be created. Returns\n * the number of splits made.\n *\n * @param {Array[]} polys\n * @param {vtkPoints} points\n * @param {Array} polyGroups\n * @param {Array} polyEdges\n * @param {Vector3} normal\n * @param {Boolean} oriented\n */\nfunction vtkCCSSplitAtPinchPoints(polys, points, polyGroups, polyEdges, normal, oriented) {\n  const tryPoints = vtkPoints.newInstance({\n    dataType: VtkDataTypes.DOUBLE,\n    empty: true\n  });\n  const locator = vtkIncrementalOctreePointLocator.newInstance();\n  let splitCount = 0;\n  let poly;\n  let n;\n  let bounds;\n  let tol;\n  for (let i = 0; i < polys.length; i++) {\n    poly = polys[i];\n    n = poly.length;\n    bounds = [];\n    tol = CCS_POLYGON_TOLERANCE * Math.sqrt(vtkPolygon.getBounds(poly, points, bounds));\n    if (tol === 0) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    tryPoints.initialize();\n    locator.setTolerance(tol);\n    locator.initPointInsertion(tryPoints, bounds);\n    let foundMatch = false;\n    let idx1 = 0;\n    let idx2 = 0;\n    let unique = 0;\n    const point = [];\n    const p1 = [];\n    const p2 = [];\n    const p3 = [];\n    for (idx2 = 0; idx2 < n; idx2++) {\n      points.getPoint(poly[idx2], point);\n      const {\n        success,\n        pointIdx\n      } = locator.insertUniquePoint(point, 0);\n      if (!success) {\n        // Need vertIdx to match poly indices, so force point insertion\n        locator.insertNextPoint(point);\n\n        // Do the points have different pointIds?\n        idx1 = pointIdx;\n        unique = poly[idx2] !== poly[idx1];\n        if (idx2 > idx1 + 2 - unique && n + idx1 > idx2 + 2 - unique) {\n          if (oriented) {\n            // Make sure that splitting this poly won't create a hole poly\n            let prevIdx = n + idx1 - 1;\n            let midIdx = idx1 + 1;\n            let nextIdx = idx2 + 1;\n            if (prevIdx >= n) {\n              prevIdx -= n;\n            }\n            if (midIdx >= n) {\n              midIdx -= n;\n            }\n            if (nextIdx >= n) {\n              nextIdx -= n;\n            }\n            points.getPoint(poly[prevIdx], p1);\n            points.getPoint(poly[midIdx], p2);\n            points.getPoint(poly[nextIdx], p3);\n            if (vtkCCSVectorProgression(point, p1, p2, p3, normal) > 0) {\n              foundMatch = true;\n              break;\n            }\n          } else {\n            foundMatch = true;\n            break;\n          }\n        }\n      }\n    }\n    if (foundMatch) {\n      splitCount++;\n\n      // Split off a new poly\n      const m = idx2 - idx1;\n      const oldPoly = polys[i];\n      const oldEdges = polyEdges[i];\n      const newPoly1 = oldPoly.slice(idx1, idx1 + m + unique);\n      const newEdges1 = oldEdges.slice(idx1, idx1 + m + unique);\n      const newPoly2 = new Array(n - m + unique);\n      const newEdges2 = new Array(n - m + unique);\n      if (unique) {\n        newEdges1[m] = -1;\n      }\n\n      // The poly that is split off, which might have more intersections\n      for (let j = 0; j < idx1 + unique; j++) {\n        newPoly2[j] = oldPoly[j];\n        newEdges2[j] = oldEdges[j];\n      }\n      if (unique) {\n        newEdges2[idx1] = -1;\n      }\n      for (let k = idx2; k < n; k++) {\n        newPoly2[k - m + unique] = oldPoly[k];\n        newEdges2[k - m + unique] = oldEdges[k];\n      }\n      polys[i] = newPoly1;\n      polyEdges[i] = newEdges1;\n      polys.push(newPoly2);\n      polyEdges.push(newEdges2);\n\n      // Unless polygroup was clear (because poly was reversed),\n      // make a group with one entry for the new poly\n      polyGroups.length = polys.length;\n      if (polyGroups[i].length > 0) {\n        polyGroups[polys.length - 1].push(polys.length - 1);\n      }\n    }\n  }\n  return splitCount;\n}\n\n// ---------------------------------------------------\n/**\n * The polygons might have a lot of extra points, i.e. points\n * in the middle of the edges.  Remove those points, but keep\n * the original edges as polylines in the originalEdges array.\n * Only original edges with more than two points will be kept.\n *\n * @param {Array[]} polys\n * @param {vtkPoints} points\n * @param {Array} polyEdges\n * @param {Array} originalEdges\n */\nfunction vtkCCSFindTrueEdges(polys, points, polyEdges, originalEdges) {\n  // Tolerance^2 for angle to see if line segments are parallel\n  const atol2 = CCS_POLYGON_TOLERANCE * CCS_POLYGON_TOLERANCE;\n  const p0 = [];\n  const p1 = [];\n  const p2 = [];\n  const v1 = [];\n  const v2 = [];\n  let l1;\n  let l2;\n  for (let polyId = 0; polyId < polys.length; polyId++) {\n    const oldPoly = polys[polyId];\n    const n = oldPoly.length;\n    const newEdges = [];\n    polyEdges.push(newEdges);\n\n    // Only useful if poly has more than three sides\n    if (n < 4) {\n      newEdges[0] = -1;\n      newEdges[1] = -1;\n      newEdges[2] = -1;\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    // While we remove points, m keeps track of how many points are left\n    let m = n;\n\n    // Compute bounds for tolerance\n    const bounds = [];\n    const tol2 = vtkPolygon.getBounds(oldPoly, points, bounds) * atol2;\n\n    // The new poly\n    const newPoly = [];\n    let cornerPointId = 0;\n    let oldOriginalId = -1;\n\n    // Keep the partial edge from before the first corner is found\n    const partialEdge = [];\n    let cellCount = 0;\n    points.getPoint(oldPoly[n - 1], p0);\n    points.getPoint(oldPoly[0], p1);\n    subtract(p1, p0, v1);\n    l1 = dot(v1, v1);\n    for (let j = 0; j < n; j++) {\n      let k = j + 1;\n      if (k >= n) {\n        k -= n;\n      }\n      points.getPoint(oldPoly[k], p2);\n      subtract(p2, p1, v2);\n      l2 = dot(v2, v2);\n\n      // Dot product is |v1||v2|cos(theta)\n      const c = dot(v1, v2);\n      // sin^2(theta) = (1 - cos^2(theta))\n      // and   c*c = l1*l2*cos^2(theta)\n      const s2 = l1 * l2 - c * c;\n\n      // In the small angle approximation, sin(theta) == theta, so\n      // s2/(l1*l2) is the angle that we want to check, but it's not\n      // a valid check if l1 or l2 is very close to zero.\n\n      const pointId = oldPoly[j];\n\n      // Keep the point if:\n      // 1) removing it would create a 2-point poly OR\n      // 2) it's more than \"tol\" distance from the prev point AND\n      // 3) the angle is greater than atol:\n      if (m <= 3 || l1 > tol2 && (c < 0 || l1 < tol2 || l2 < tol2 || s2 > l1 * l2 * atol2)) {\n        // Complete the previous edge only if the final point count\n        // will be greater than two\n        if (cellCount > 1) {\n          if (pointId !== oldOriginalId) {\n            originalEdges.push(pointId);\n            cellCount++;\n          }\n          // Update the number of segments in the edge\n          const countLocation = originalEdges.length - cellCount - 1;\n          originalEdges[countLocation] = cellCount;\n          newEdges.push(countLocation);\n        } else if (cellCount === 0) {\n          partialEdge.push(pointId);\n        } else {\n          newEdges.push(-1);\n        }\n        newPoly.push(pointId);\n\n        // Start a new edge with cornerPointId as a \"virtual\" point\n        cornerPointId = pointId;\n        oldOriginalId = pointId;\n        cellCount = 1;\n\n        // Rotate to the next point\n        p0[0] = p2[0];\n        p0[1] = p2[1];\n        p0[2] = p2[2];\n        p1[0] = p2[0];\n        p1[1] = p2[1];\n        p1[2] = p2[2];\n        v1[0] = v2[0];\n        v1[1] = v2[1];\n        v1[2] = v2[2];\n        l1 = l2;\n      } else {\n        if (cellCount > 0 && pointId !== oldOriginalId) {\n          // First check to see if we have to add cornerPointId\n          if (cellCount === 1) {\n            originalEdges.push(1); // new edge\n            originalEdges.push(cornerPointId);\n          }\n          // Then add the new point\n          originalEdges.push(pointId);\n          oldOriginalId = pointId;\n          cellCount++;\n        } else {\n          // No corner yet, so save the point\n          partialEdge.push(pointId);\n        }\n\n        // Reduce the count\n        m--;\n\n        // Join the previous two segments, since the point was removed\n        p1[0] = p2[0];\n        p1[1] = p2[1];\n        p1[2] = p2[2];\n        subtract(p2, p0, v1);\n        l1 = dot(v1, v1);\n      }\n    }\n\n    // Add the partial edge to the end\n    for (let ii = 0; ii < partialEdge.length; ii++) {\n      const pointId = partialEdge[ii];\n      if (pointId !== oldOriginalId) {\n        if (cellCount === 1) {\n          originalEdges.push(1); // new edge\n          originalEdges.push(cornerPointId);\n        }\n        originalEdges.push(pointId);\n        oldOriginalId = pointId;\n        cellCount++;\n      }\n    }\n\n    // Finalize\n    if (cellCount > 1) {\n      // Update the number of segments in the edge\n      const countLocation = originalEdges.length - cellCount - 1;\n      originalEdges[countLocation] = cellCount;\n      newEdges.push(countLocation);\n    }\n    polys[polyId] = newPoly;\n  }\n}\n\n// ---------------------------------------------------\n/**\n * Reverse a cleaned-up polygon along with the info about\n * all of its original vertices.\n *\n * @param {Array} poly\n * @param {Array} edges\n * @param {Array} originalEdges\n */\nfunction vtkCCSReversePoly(poly, edges, originalEdges) {\n  reverseElements(poly, 1, poly.length - 1);\n  edges.reverse();\n  for (let i = 0; i < edges.length; i++) {\n    if (edges[i] >= 0) {\n      const firstPtsIdx = edges[i] + 1;\n      const npts = originalEdges[edges[i]];\n      reverseElements(originalEdges, firstPtsIdx, firstPtsIdx + npts - 1);\n    }\n  }\n}\n\n// ---------------------------------------------------\n/**\n * Check the sense of the polygon against the given normal. Returns\n * zero if the normal is zero.\n *\n * @param {Array} poly\n * @param {vtkPoints} points\n * @param {Vector3} normal\n */\nfunction vtkCCSCheckPolygonSense(poly, points, normal) {\n  // Compute the normal\n  const pnormal = [0.0, 0.0, 0.0];\n  const p0 = [];\n  const p1 = [];\n  const p2 = [];\n  const v1 = [];\n  const v2 = [];\n  const v = [];\n  points.getPoint(poly[0], p0);\n  points.getPoint(poly[1], p1);\n  subtract(p1, p0, v1);\n  for (let jj = 2; jj < poly.length; jj++) {\n    points.getPoint(poly[jj], p2);\n    subtract(p2, p0, v2);\n    cross(v1, v2, v);\n    add(pnormal, v, pnormal);\n    p1[0] = p2[0];\n    p1[1] = p2[1];\n    p1[2] = p2[2];\n    v1[0] = v2[0];\n    v1[1] = v2[1];\n    v1[2] = v2[2];\n  }\n\n  // Check the normal\n  const d = dot(pnormal, normal);\n  return {\n    isNormalNotZero: d !== 0,\n    sense: d > 0\n  };\n}\n\n// ---------------------------------------------------\n/**\n * Check whether innerPoly is inside outerPoly.\n * The normal is needed to verify the polygon orientation.\n * The values of pp, bounds, and tol2 must be precomputed\n * by calling vtkCCSPrepareForPolyInPoly() on outerPoly.\n *\n * @param {Array} outerPoly\n * @param {Array} innerPoly\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @param {Float64Array} pp\n * @param {Bounds} bounds\n * @param {Number} tol2\n */\nfunction vtkCCSPolyInPoly(outerPoly, innerPoly, points, normal, pp, bounds, tol2) {\n  // Find a vertex of poly \"j\" that isn't on the edge of poly \"i\".\n  // This is necessary or the PointInPolygon might return \"true\"\n  // based only on roundoff error.\n  const n = outerPoly.length;\n  const m = innerPoly.length;\n  const p = [];\n  const q1 = [];\n  const q2 = [];\n  for (let jj = 0; jj < m; jj++) {\n    // Semi-randomize the point order\n    // eslint-disable-next-line no-bitwise\n    const kk = (jj >> 1) + (jj & 1) * (m + 1 >> 1);\n    points.getPoint(innerPoly[kk], p);\n    const intersectionState = vtkPolygon.pointInPolygon(p, pp, bounds, normal);\n    if (intersectionState === PolygonWithPointIntersectionState.FAILURE) {\n      vtkErrorMacro('Error finding point in polygon in vtkCCSPolyInPoly');\n    }\n    if (intersectionState !== PolygonWithPointIntersectionState.OUTSIDE) {\n      let pointOnEdge = 0;\n      points.getPoint(outerPoly[n - 1], q1);\n      for (let ii = 0; ii < n; ii++) {\n        points.getPoint(outerPoly[ii], q2);\n        // This method returns distance squared\n        const {\n          distance\n        } = vtkLine.distanceToLine(p, q1, q2);\n        if (distance < tol2) {\n          pointOnEdge = 1;\n          break;\n        }\n        q1[0] = q2[0];\n        q1[1] = q2[1];\n        q1[2] = q2[2];\n      }\n      if (!pointOnEdge) {\n        // Good result, point is in polygon\n        return true;\n      }\n    }\n  }\n\n  // No matches found\n  return false;\n}\n\n// ---------------------------------------------------\n/**\n * Precompute values needed for the PolyInPoly check.\n * The values that are returned are as follows:\n * pp: an array of the polygon vertices\n * bounds: the polygon bounds\n * tol2: a tolerance value based on the size of the polygon\n * (note: pp must be pre-allocated to the 3*outerPoly.length)\n *\n * @param {Array} outerPoly\n * @param {vtkPoints} points\n * @param {Float64Array} pp\n * @param {Bounds} bounds\n */\nfunction vtkCCSPrepareForPolyInPoly(outerPoly, points, pp, bounds) {\n  const n = outerPoly.length;\n  if (n === 0) {\n    return 0.0; // to avoid false positive warning about uninitialized value\n  }\n\n  // Pull out the points\n  const point = [];\n  let j = 0;\n  for (let i = 0; i < n; i++) {\n    points.getPoint(outerPoly[i], point);\n    pp[j++] = point[0];\n    pp[j++] = point[1];\n    pp[j++] = point[2];\n  }\n\n  // Find the bounding box and tolerance for the polygon\n  return vtkPolygon.getBounds(outerPoly, points, bounds) * (CCS_POLYGON_TOLERANCE * CCS_POLYGON_TOLERANCE);\n}\n\n// ---------------------------------------------------\n/**\n * Check for polygons within polygons. Group the polygons\n * if they are within each other. Reverse the sense of\n * the interior \"hole\" polygons. A hole within a hole\n * will be reversed twice and will become its own group.\n *\n * @param {Array} newPolys\n * @param {vtkPoints} points\n * @param {Array} polyGroups\n * @param {Array} polyEdges\n * @param {Array} originalEdges\n * @param {Vector3} normal\n * @param {Boolean} oriented\n */\nfunction vtkCCSMakeHoleyPolys(newPolys, points, polyGroups, polyEdges, originalEdges, normal, oriented) {\n  const numNewPolys = newPolys.length;\n  if (numNewPolys <= 1) {\n    return;\n  }\n\n  // Use bit arrays to keep track of inner polys\n  const polyReversed = [];\n  const innerPolys = [];\n\n  // GroupCount is an array only needed for unoriented polys\n  let groupCount;\n  if (!oriented) {\n    groupCount = new Int32Array(numNewPolys);\n  }\n\n  // Find the maximum poly size\n  let nmax = 1;\n  for (let kk = 0; kk < numNewPolys; kk++) {\n    nmax = Math.max(nmax, newPolys[kk].length);\n  }\n\n  // These are some values needed for poly-in-poly checks\n  const pp = new Float64Array(3 * nmax);\n  const bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];\n  let tol2;\n\n  // Go through all polys\n  for (let i = 0; i < numNewPolys; i++) {\n    const n = newPolys[i].length;\n    if (n < 3) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    // Check if poly is reversed\n    const {\n      isNormalNotZero,\n      sense\n    } = vtkCCSCheckPolygonSense(newPolys[i], points, normal);\n    if (isNormalNotZero) {\n      polyReversed[i] = !sense;\n    }\n\n    // Precompute some values needed for poly-in-poly checks\n    tol2 = vtkCCSPrepareForPolyInPoly(newPolys[i], points, pp, bounds);\n\n    // Look for polygons inside of this one\n    for (let j = 0; j < numNewPolys; j++) {\n      if (j !== i && newPolys[j].length >= 3) {\n        // Make sure polygon i is not in polygon j\n        const pg = polyGroups[j];\n        if (!pg.includes(i)) {\n          if (vtkCCSPolyInPoly(newPolys[i], newPolys[j], points, normal, pp.subarray(3 * n), bounds, tol2)) {\n            // Add to group\n            polyGroups[i].push(j);\n            if (groupCount) {\n              groupCount[j] += 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  if (!oriented) {\n    // build a stack of polys that aren't inside other polys=\n    const outerPolyStack = [];\n    for (let ll = 0; ll < numNewPolys; ll++) {\n      if (groupCount[ll] === 0) {\n        outerPolyStack.push(ll);\n      }\n    }\n    let j;\n    while (outerPolyStack.length > 0) {\n      j = outerPolyStack.length - 1;\n      outerPolyStack.pop();\n      if (polyReversed[j]) {\n        vtkCCSReversePoly(newPolys[j], polyEdges[j], originalEdges);\n        polyReversed[j] = false;\n      }\n      if (polyGroups[j].length > 1) {\n        // Convert the group into a bit array, to make manipulation easier\n        innerPolys.length = 0;\n        for (let k = 1; k < polyGroups[j].length; k++) {\n          const jj = polyGroups[j][k];\n          if (groupCount[jj] > 1) {\n            groupCount[jj] -= 2;\n            if (groupCount[jj] === 0) {\n              outerPolyStack.push(jj);\n            }\n          } else {\n            innerPolys[jj] = 1;\n            polyGroups[jj].length = 0;\n            if (!polyReversed[jj]) {\n              vtkCCSReversePoly(newPolys[jj], polyEdges[jj], originalEdges);\n              polyReversed[jj] = false;\n            }\n          }\n        }\n\n        // Use the bit array to recreate the polyGroup\n        polyGroups[j].length = 0;\n        polyGroups[j].push(j);\n        for (let jj = 0; jj < numNewPolys; jj++) {\n          if (innerPolys[jj]) {\n            polyGroups[j].push(jj);\n          }\n        }\n      }\n    }\n  } else {\n    // oriented\n    for (let j = 0; j < numNewPolys; j++) {\n      // Remove the groups for reversed polys\n      if (polyReversed[j]) {\n        polyGroups[j].length = 0;\n      }\n      // Polys inside the interior polys have their own groups, so remove\n      // them from this group\n      else if (polyGroups[j].length > 1) {\n        // Convert the group into a bit array, to make manipulation easier\n        innerPolys.length = 0;\n        for (let k = 1; k < polyGroups[j].length; k++) {\n          innerPolys[polyGroups[j][k]] = true;\n        }\n\n        // Look for non-reversed polys inside this one\n        for (let kk = 1; kk < polyGroups[j].length; kk++) {\n          // jj is the index of the inner poly\n          const jj = polyGroups[j][kk];\n          // If inner poly is not reversed then\n          if (!polyReversed[jj]) {\n            // Remove that poly and all polys inside of it from the group\n            for (let ii = 0; ii < polyGroups[jj].length; ii++) {\n              innerPolys[polyGroups[jj][ii]] = false;\n            }\n          }\n        }\n\n        // Use the bit array to recreate the polyGroup\n        polyGroups[j].length = 0;\n        polyGroups[j].push(j);\n        for (let jj = 0; jj < numNewPolys; jj++) {\n          if (innerPolys[jj]) {\n            polyGroups[j].push(jj);\n          }\n        }\n      }\n    }\n  }\n\n  // delete[] groupCount;\n}\n\n// ---------------------------------------------------\n/**\n * Check line segment with point Ids (i, j) to make sure that it\n * doesn't cut through the edges of any polys in the group.\n * Return value of zero means check failed and the cut is not\n * usable.\n *\n * @param {Array[]} polys\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @param {Array} polyGroup\n * @param {Number} outerPolyId\n * @param {Number} innerPolyId\n * @param {Number} outerIdx\n * @param {Number} innerIdx\n */\nfunction vtkCCSCheckCut(polys, points, normal, polyGroup, outerPolyId, innerPolyId, outerIdx, innerIdx) {\n  const ptId1 = polys[outerPolyId][outerIdx];\n  const ptId2 = polys[innerPolyId][innerIdx];\n  const tol = CCS_POLYGON_TOLERANCE;\n  const p1 = [];\n  const p2 = [];\n  points.getPoint(ptId1, p1);\n  points.getPoint(ptId2, p2);\n  const w = [];\n  subtract(p2, p1, w);\n  const l = normalize(w);\n\n  // Cuts between coincident points are good\n  if (l === 0) {\n    return true;\n  }\n\n  // Define a tolerance with units of distance squared\n  const tol2 = l * l * tol * tol;\n\n  // Check the sense of the cut: it must be pointing \"in\" for both polys.\n  let polyId = outerPolyId;\n  let polyIdx = outerIdx;\n  let r = p1;\n  const r1 = [];\n  let r2 = p2;\n  const r3 = [];\n  for (let ii = 0; ii < 2; ii++) {\n    const poly = polys[polyId];\n    const n = poly.length;\n    let prevIdx = n - polyIdx - 1;\n    let nextIdx = polyIdx + 1;\n    if (prevIdx >= n) {\n      prevIdx -= n;\n    }\n    if (nextIdx >= n) {\n      nextIdx -= n;\n    }\n    points.getPoint(poly[prevIdx], r1);\n    points.getPoint(poly[nextIdx], r3);\n    if (vtkCCSVectorProgression(r, r1, r2, r3, normal) > 0) {\n      return false;\n    }\n    polyId = innerPolyId;\n    polyIdx = innerIdx;\n    r = p2;\n    r2 = p1;\n  }\n\n  // Check for intersections of the cut with polygon edges.\n  // First, create a cut plane that divides space at the cut line.\n  const pc = [];\n  cross(normal, w, pc);\n  pc[3] = -dot(pc, p1);\n  for (let i = 0; i < polyGroup.length; i++) {\n    const poly = polys[polyGroup[i]];\n    const n = poly.length;\n    const q1 = [];\n    const q2 = [];\n    let qtId1 = poly[n - 1];\n    points.getPoint(qtId1, q1);\n    let v1 = pc[0] * q1[0] + pc[1] * q1[1] + pc[2] * q1[2] + pc[3];\n    let c1 = v1 > 0;\n    for (let j = 0; j < n; j++) {\n      const qtId2 = poly[j];\n      points.getPoint(qtId2, q2);\n      const v2 = pc[0] * q2[0] + pc[1] * q2[1] + pc[2] * q2[2] + pc[3];\n      const c2 = v2 > 0;\n\n      // If lines share an endpoint, they can't intersect,\n      // so don't bother with the check.\n      if (ptId1 !== qtId1 && ptId1 !== qtId2 && ptId2 !== qtId1 && ptId2 !== qtId2) {\n        // Check for intersection\n        if ((c1 ? !c2 : c2) || v1 * v1 < tol2 || v2 * v2 < tol2) {\n          subtract(q2, q1, w);\n          if (dot(w, w) > 0) {\n            const qc = [];\n            cross(w, normal, qc);\n            qc[3] = -dot(qc, q1);\n            const u1 = qc[0] * p1[0] + qc[1] * p1[1] + qc[2] * p1[2] + qc[3];\n            const u2 = qc[0] * p2[0] + qc[1] * p2[1] + qc[2] * p2[2] + qc[3];\n            const d1 = u1 > 0;\n            const d2 = u2 > 0;\n            if (d1 ? !d2 : d2) {\n              // One final check to make sure endpoints aren't coincident\n              let p = p1;\n              let q = q1;\n              if (v2 * v2 < v1 * v1) {\n                p = p2;\n              }\n              if (u2 * u2 < u1 * u1) {\n                q = q2;\n              }\n              if (distance2BetweenPoints(p, q) > tol2) {\n                return false;\n              }\n            }\n          }\n        }\n      }\n      qtId1 = qtId2;\n      q1[0] = q2[0];\n      q1[1] = q2[1];\n      q1[2] = q2[2];\n      v1 = v2;\n      c1 = c2;\n    }\n  }\n  return true;\n}\n\n// ---------------------------------------------------\n/**\n * Check the quality of a cut between an outer and inner polygon.\n * An ideal cut is one that forms a 90 degree angle with each\n * line segment that it joins to.  Smaller values indicate a\n * higher quality cut.\n *\n * @param {Array} outerPoly\n * @param {Array} innerPoly\n * @param {Number} i\n * @param {Number} j\n * @param {vtkPoints} points\n */\nfunction vtkCCSCutQuality(outerPoly, innerPoly, i, j, points) {\n  const n = outerPoly.length;\n  const m = innerPoly.length;\n  const a = i > 0 ? i - 1 : n - 1;\n  const b = i < n - 1 ? i + 1 : 0;\n  const c = j > 0 ? j - 1 : m - 1;\n  const d = j < m - 1 ? j + 1 : 0;\n  const p0 = [];\n  const p1 = [];\n  const p2 = [];\n  points.getPoint(outerPoly[i], p1);\n  points.getPoint(innerPoly[j], p2);\n  const v1 = [];\n  const v2 = [];\n  subtract(p2, p1, v1);\n  const l1 = dot(v1, v1);\n  let l2;\n  let qmax = 0;\n  let q;\n  points.getPoint(outerPoly[a], p0);\n  subtract(p0, p1, v2);\n  l2 = dot(v2, v2);\n  if (l2 > 0) {\n    q = dot(v1, v2);\n    q *= q / l2;\n    if (q > qmax) {\n      qmax = q;\n    }\n  }\n  points.getPoint(outerPoly[b], p0);\n  subtract(p0, p1, v2);\n  l2 = dot(v2, v2);\n  if (l2 > 0) {\n    q = dot(v1, v2);\n    q *= q / l2;\n    if (q > qmax) {\n      qmax = q;\n    }\n  }\n  points.getPoint(innerPoly[c], p0);\n  subtract(p2, p0, v2);\n  l2 = dot(v2, v2);\n  if (l2 > 0) {\n    q = dot(v1, v2);\n    q *= q / l2;\n    if (q > qmax) {\n      qmax = q;\n    }\n  }\n  points.getPoint(innerPoly[d], p0);\n  subtract(p2, p0, v2);\n  l2 = dot(v2, v2);\n  if (l2 > 0) {\n    q = dot(v1, v2);\n    q *= q / l2;\n    if (q > qmax) {\n      qmax = q;\n    }\n  }\n  if (l1 > 0) {\n    return qmax / l1; // also l1 + qmax, incorporates distance;\n  }\n  return Number.MAX_VALUE;\n}\n\n// ---------------------------------------------------\n/**\n * Find the two sharpest verts on an inner (i.e. inside-out) poly.\n *\n * @param {Array} poly\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @param {[Number, Number]} verts\n */\nfunction vtkCCSFindSharpestVerts(poly, points, normal, verts) {\n  const p1 = [];\n  const p2 = [];\n  const v1 = [];\n  const v2 = [];\n  const v = [];\n  let l1;\n  let l2;\n  const minVal = [0, 0];\n  verts[0] = 0;\n  verts[1] = 0;\n  const n = poly.length;\n  points.getPoint(poly[n - 1], p2);\n  points.getPoint(poly[0], p1);\n  subtract(p1, p2, v1);\n  l1 = Math.sqrt(dot(v1, v1));\n  for (let j = 0; j < n; j++) {\n    let k = j + 1;\n    if (k === n) {\n      k = 0;\n    }\n    points.getPoint(poly[k], p2);\n    subtract(p2, p1, v2);\n    l2 = Math.sqrt(dot(v2, v2));\n    cross(v1, v2, v);\n    const b = dot(v, normal);\n    if (b < 0 && l1 * l2 > 0) {\n      // Dot product is |v1||v2|cos(theta), range [-1, +1]\n      const val = dot(v1, v2) / (l1 * l2);\n      if (val < minVal[0]) {\n        minVal[1] = minVal[0];\n        minVal[0] = val;\n        verts[1] = verts[0];\n        verts[0] = j;\n      }\n    }\n\n    // Rotate to the next point\n    p1[0] = p2[0];\n    p1[1] = p2[1];\n    p1[2] = p2[2];\n    v1[0] = v2[0];\n    v1[1] = v2[1];\n    v1[2] = v2[2];\n    l1 = l2;\n  }\n}\n\n// ---------------------------------------------------\n/**\n * Find two valid cuts between outerPoly and innerPoly.\n * Used by vtkCCSCutHoleyPolys.\n *\n * @param {Array} polys\n * @param {Array} polyGroup\n * @param {Number} outerPolyId\n * @param {Number} innerPolyId\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @param {Array[]} cuts\n * @param {Boolean} exhaustive\n */\nfunction vtkCCSFindCuts(polys, polyGroup, outerPolyId, innerPolyId, points, normal, cuts, exhaustive) {\n  const outerPoly = polys[outerPolyId];\n  const innerPoly = polys[innerPolyId];\n  const innerSize = innerPoly.length;\n  // Find the two sharpest points on the inner poly\n  const verts = [];\n  vtkCCSFindSharpestVerts(innerPoly, points, normal, verts);\n\n  // A list of cut locations according to quality\n  const cutlist = [];\n  cutlist.length = outerPoly.length;\n\n  // Search for potential cuts (need to find two cuts)\n  let cutId = 0;\n  cuts[0][0] = 0;\n  cuts[0][1] = 0;\n  cuts[1][0] = 0;\n  cuts[1][1] = 0;\n  let foundCut = false;\n  for (cutId = 0; cutId < 2; cutId++) {\n    const count = exhaustive ? innerSize : 3;\n    for (let i = 0; i < count && !foundCut; i++) {\n      // Semi-randomize the search order\n      // TODO: Does this do the same as in C++?\n      // eslint-disable-next-line no-bitwise\n      let j = (i >> 1) + (i & 1) * (innerSize + 1 >> 1);\n      // Start at the best first point\n      j = (j + verts[cutId]) % innerSize;\n      for (let kk = 0; kk < outerPoly.length; kk++) {\n        const q = vtkCCSCutQuality(outerPoly, innerPoly, kk, j, points);\n        cutlist[kk] = [q, kk];\n      }\n      cutlist.sort((a, b) => a[0] - b[0]);\n      for (let lid = 0; lid < cutlist.length; lid++) {\n        const k = cutlist[lid][1];\n\n        // If this is the second cut, do extra checks\n        if (cutId > 0) {\n          // Make sure cuts don't share an endpoint\n          if (j === cuts[0][1] || k === cuts[0][0]) {\n            // eslint-disable-next-line no-continue\n            continue;\n          }\n\n          // Make sure cuts don't intersect\n          const p1 = [];\n          const p2 = [];\n          points.getPoint(outerPoly[cuts[0][0]], p1);\n          points.getPoint(innerPoly[cuts[0][1]], p2);\n          const q1 = [];\n          const q2 = [];\n          points.getPoint(outerPoly[k], q1);\n          points.getPoint(innerPoly[j], q2);\n          let u;\n          let v;\n          if (vtkLine.intersection(p1, p2, q1, q2, u, v) === vtkLine.IntersectionState.YES_INTERSECTION) {\n            // eslint-disable-next-line no-continue\n            continue;\n          }\n        }\n\n        // This check is done for both cuts\n        if (vtkCCSCheckCut(polys, points, normal, polyGroup, outerPolyId, innerPolyId, k, j)) {\n          cuts[cutId][0] = k;\n          cuts[cutId][1] = j;\n          foundCut = true;\n          break;\n        }\n      }\n    }\n    if (!foundCut) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// ---------------------------------------------------\n/**\n * Helper for vtkCCSCutHoleyPolys.  Change a polygon and a hole\n * into two separate polygons by making two cuts between them.\n *\n * @param {Array[]} polys\n * @param {Array} polyEdges\n * @param {Number} outerPolyId\n * @param {Number} innerPolyId\n * @param {vtkPoints} points\n * @param {Array[]} cuts\n */\nfunction vtkCCSMakeCuts(polys, polyEdges, outerPolyId, innerPolyId, points, cuts) {\n  const q = [];\n  const r = [];\n  for (let bb = 0; bb < 2; bb++) {\n    const ptId1 = polys[outerPolyId][cuts[bb][0]];\n    const ptId2 = polys[innerPolyId][cuts[bb][1]];\n    points.getPoint(ptId1, q);\n    points.getPoint(ptId2, r);\n  }\n  const outerPoly = polys[outerPolyId];\n  const innerPoly = polys[innerPolyId];\n  const outerEdges = polyEdges[outerPolyId];\n  const innerEdges = polyEdges[innerPolyId];\n\n  // Generate new polys from the cuts\n  const n = outerPoly.length;\n  const m = innerPoly.length;\n  let idx;\n\n  // Generate poly1\n  const n1 = n * (cuts[1][0] < cuts[0][0]) + cuts[1][0] - cuts[0][0] + 1;\n  const n2 = n1 + m * (cuts[0][1] < cuts[1][1]) + cuts[0][1] - cuts[1][1] + 1;\n  const poly1 = [];\n  poly1.length = n2;\n  const edges1 = new Array(n2);\n  idx = cuts[0][0];\n  for (let i1 = 0; i1 < n1; i1++) {\n    const k = idx++;\n    poly1[i1] = outerPoly[k];\n    edges1[i1] = outerEdges[k];\n    idx *= idx !== n;\n  }\n  edges1[n1 - 1] = -1;\n  idx = cuts[1][1];\n  for (let i2 = n1; i2 < n2; i2++) {\n    const k = idx++;\n    poly1[i2] = innerPoly[k];\n    edges1[i2] = innerEdges[k];\n    idx *= idx !== m;\n  }\n  edges1[n2 - 1] = -1;\n\n  // Generate poly2\n  const m1 = n * (cuts[0][0] < cuts[1][0]) + cuts[0][0] - cuts[1][0] + 1;\n  const m2 = m1 + m * (cuts[1][1] < cuts[0][1]) + cuts[1][1] - cuts[0][1] + 1;\n  const poly2 = [];\n  poly2.length = m2;\n  const edges2 = new Array(m2);\n  idx = cuts[1][0];\n  for (let j1 = 0; j1 < m1; j1++) {\n    const k = idx++;\n    poly2[j1] = outerPoly[k];\n    edges2[j1] = outerEdges[k];\n    idx *= idx !== n;\n  }\n  edges2[m1 - 1] = -1;\n  idx = cuts[0][1];\n  for (let j2 = m1; j2 < m2; j2++) {\n    const k = idx++;\n    poly2[j2] = innerPoly[k];\n    edges2[j2] = innerEdges[k];\n    idx *= idx !== m;\n  }\n  edges2[m2 - 1] = -1;\n\n  // Replace outerPoly and innerPoly with these new polys\n  polys[outerPolyId] = poly1;\n  polys[innerPolyId] = poly2;\n  polyEdges[outerPolyId] = edges1;\n  polyEdges[innerPolyId] = edges2;\n}\n\n// ---------------------------------------------------\n/**\n * After the holes have been identified, make cuts between the\n * outer poly and each hole.  Make two cuts per hole.  The only\n * strict requirement is that the cut must not intersect any\n * edges, but it's best to make sure that no really sharp angles\n * are created.\n *\n * @param {Array[]} polys\n * @param {vtkPoints} points\n * @param {Array[]} polyGroups\n * @param {Array} polyEdges\n * @param {Vector3} normal\n * @returns {boolean}\n */\nfunction vtkCCSCutHoleyPolys(polys, points, polyGroups, polyEdges, normal) {\n  let cutFailure = 0;\n\n  // Go through all groups and cut out the first inner poly that is\n  // found.  Every time an inner poly is cut out, the groupId counter\n  // is reset because cutting a poly creates a new group.\n  let groupId = 0;\n  while (groupId < polyGroups.length) {\n    const polyGroup = polyGroups[groupId];\n\n    // Only need to make a cut if the group size is greater than 1\n    if (polyGroup.length > 1) {\n      // The first member of the group is the outer poly\n      const outerPolyId = polyGroup[0];\n\n      // The second member of the group is the first inner poly\n      let innerPolyId = polyGroup[1];\n\n      // Sort the group by size, do largest holes first\n      let innerBySize = new Array(polyGroup.length);\n      for (let i = 1; i < polyGroup.length; i++) {\n        innerBySize[i] = [polys[polyGroup[i]].length, i];\n      }\n      innerBySize = [innerBySize[0], ...innerBySize.splice(1).sort((a, b) => a[0] - b[0])];\n      reverseElements(innerBySize, 1, innerBySize.length - 1);\n\n      // Need to check all inner polys in sequence, until one succeeds.\n      // Do a quick search first, then do an exhaustive search.\n      let madeCut = 0;\n      let inner = 0;\n      for (let exhaustive = 0; exhaustive < 2 && !madeCut; exhaustive++) {\n        for (let j = 1; j < polyGroup.length; j++) {\n          inner = innerBySize[j][1];\n          innerPolyId = polyGroup[inner];\n          const cuts = [];\n          if (vtkCCSFindCuts(polys, polyGroup, outerPolyId, innerPolyId, points, normal, cuts, exhaustive)) {\n            vtkCCSMakeCuts(polys, polyEdges, outerPolyId, innerPolyId, points, cuts);\n            madeCut = 1;\n            break;\n          }\n        }\n      }\n      if (madeCut) {\n        // Move successfully cut innerPolyId into its own group\n        polyGroup.splice(inner, 1);\n        // Only add if innerPolyId hasn't been set already.\n        // Having the same poly occur as both polyGroup and\n        // innerPoly would cause an infinite loop.\n        if (polyGroups[innerPolyId].length === 0) {\n          polyGroups[innerPolyId].push(innerPolyId);\n        }\n      } else {\n        // Remove all failed inner polys from the group\n        for (let k = 1; k < polyGroup.length; k++) {\n          innerPolyId = polyGroup[k];\n          // Only add if innerPolyId hasn't been set already.\n          // Having the same poly occur as both polyGroup and\n          // innerPoly would cause an infinite loop.\n          if (polyGroups[innerPolyId].length === 0) {\n            polyGroups[innerPolyId].push(innerPolyId);\n          }\n        }\n        polyGroup.length = 1;\n        cutFailure = 1;\n      }\n\n      // If there are other interior polys in the group, find out whether\n      // they are in poly1 or poly2\n      if (polyGroup.length > 1) {\n        const poly1 = polys[outerPolyId];\n        const pp = new Float64Array(3 * poly1.length);\n        const bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];\n        const tol2 = vtkCCSPrepareForPolyInPoly(poly1, points, pp, bounds);\n        let nextGroupId = groupId;\n        let ii = 1;\n        while (ii < polyGroup.length) {\n          if (vtkCCSPolyInPoly(poly1, polys[polyGroup[ii]], points, normal, pp, bounds, tol2)) {\n            // Keep this poly in polyGroup\n            ii++;\n          } else {\n            // Move this poly to poly2 group\n            polyGroups[innerPolyId].push(polyGroup[ii]);\n            polyGroup.splice(ii, 1);\n\n            // Reduce the groupId to ensure that this new group will get cut\n            if (innerPolyId < nextGroupId) {\n              nextGroupId = innerPolyId;\n            }\n          }\n        }\n\n        // Set the groupId for the next iteration\n        groupId = nextGroupId;\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n    }\n    // Increment to the next group\n    groupId++;\n  }\n  return !cutFailure;\n}\nexport { reverseElements, vtkCCSCheckCut, vtkCCSCheckPolygonSense, vtkCCSCutHoleyPolys, vtkCCSCutQuality, vtkCCSFindCuts, vtkCCSFindSharpestVerts, vtkCCSFindTrueEdges, vtkCCSInsertTriangle, vtkCCSJoinLooseEnds, vtkCCSMakeCuts, vtkCCSMakeHoleyPolys, vtkCCSMakePolysFromLines, vtkCCSPolyInPoly, vtkCCSPrepareForPolyInPoly, vtkCCSReversePoly, vtkCCSSplitAtPinchPoints, vtkCCSTriangleQuality, vtkCCSTriangulate, vtkCCSVectorProgression };","map":{"version":3,"names":["m","macro","vtkPoints","s","subtract","j","cross","d","dot","n","norm","e","distance2BetweenPoints","k","add","l","normalize","vtkLine","vtkPolygon","vtkIncrementalOctreePointLocator","VtkDataTypes","CCS_POLYGON_TOLERANCE","PolygonWithPointIntersectionState","vtkErrorMacro","reverseElements","arr","firstIdx","arguments","length","undefined","lastIdx","first","last","mid","Math","floor","i","vtkCCSTriangleQuality","p0","p1","p2","normal","u","v","w","area2","perim","sqrt","vtkCCSInsertTriangle","polys","poly","trids","polyEdges","originalEdges","nextVert","edgeCount","edgeLocs","vert","currId","edgeLoc","nextId","insertNextCell","edgePts","maxPoints","currSide","npts","pts","slice","prevSide","nextSide","prevNeeded","nextNeeded","tailPtIds","side","vtkCCSTriangulate","points","triangulationFailure","ppoint","point","npoint","verts","getPoint","concave","maxq","maxi","q","foundEar","Number","MIN_VALUE","jj","x","foundNegative","y","t","sside","intersection","IntersectionState","NO_INTERSECTION","splice","kk","kq","jq","vtkCCSMakePolysFromLines","polyData","firstLine","endLine","oriented","newPolys","incompletePolys","usedLines","Uint8Array","buildLinks","getPoints","getNumberOfPoints","numNewPolys","remainingLines","polyId","push","lineId","completePoly","getCellPoints","cellPointIds","noLinesMatch","npoly","lineEndPts","endPts","endIdx","matches","cells","getPointCells","icell","r","unshift","pit","ptsIt","ptsEnd","vtkCCSJoinLooseEnds","tol","removePolys","poly1","poly2","pt1","pt2","dMin","iMin","MAX_VALUE","pm","pc","badPoint","p","ptId","val","r2","pop","id2","sort","a","b","vtkCCSVectorProgression","p3","v1","v2","v3","w1","w2","s1","s2","sb1","sb2","c1","l1","c2","l2","ck","vtkCCSSplitAtPinchPoints","polyGroups","tryPoints","newInstance","dataType","DOUBLE","empty","locator","splitCount","bounds","getBounds","initialize","setTolerance","initPointInsertion","foundMatch","idx1","idx2","unique","success","pointIdx","insertUniquePoint","insertNextPoint","prevIdx","midIdx","nextIdx","oldPoly","oldEdges","newPoly1","newEdges1","newPoly2","Array","newEdges2","vtkCCSFindTrueEdges","atol2","newEdges","tol2","newPoly","cornerPointId","oldOriginalId","partialEdge","cellCount","c","pointId","countLocation","ii","vtkCCSReversePoly","edges","reverse","firstPtsIdx","vtkCCSCheckPolygonSense","pnormal","isNormalNotZero","sense","vtkCCSPolyInPoly","outerPoly","innerPoly","pp","q1","q2","intersectionState","pointInPolygon","FAILURE","OUTSIDE","pointOnEdge","distance","distanceToLine","vtkCCSPrepareForPolyInPoly","vtkCCSMakeHoleyPolys","polyReversed","innerPolys","groupCount","Int32Array","nmax","max","Float64Array","pg","includes","subarray","outerPolyStack","ll","vtkCCSCheckCut","polyGroup","outerPolyId","innerPolyId","outerIdx","innerIdx","ptId1","ptId2","polyIdx","r1","r3","qtId1","qtId2","qc","u1","u2","d1","d2","vtkCCSCutQuality","qmax","vtkCCSFindSharpestVerts","minVal","vtkCCSFindCuts","cuts","exhaustive","innerSize","cutlist","cutId","foundCut","count","lid","YES_INTERSECTION","vtkCCSMakeCuts","bb","outerEdges","innerEdges","idx","n1","n2","edges1","i1","i2","m1","m2","edges2","j1","j2","vtkCCSCutHoleyPolys","cutFailure","groupId","innerBySize","madeCut","inner","nextGroupId"],"sources":["/Users/yzy/Documents/Playground/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Filters/General/ContourTriangulator/helper.js"],"sourcesContent":["import { m as macro } from '../../../macros2.js';\nimport vtkPoints from '../../../Common/Core/Points.js';\nimport { s as subtract, j as cross, d as dot, n as norm, e as distance2BetweenPoints, k as add, l as normalize } from '../../../Common/Core/Math/index.js';\nimport vtkLine from '../../../Common/DataModel/Line.js';\nimport vtkPolygon from '../../../Common/DataModel/Polygon.js';\nimport vtkIncrementalOctreePointLocator from '../../../Common/DataModel/IncrementalOctreePointLocator.js';\nimport { VtkDataTypes } from '../../../Common/Core/DataArray/Constants.js';\nimport { CCS_POLYGON_TOLERANCE } from './Constants.js';\nimport { PolygonWithPointIntersectionState } from '../../../Common/DataModel/Polygon/Constants.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n/**\n * Reverse the elements between the indices firstIdx and lastIdx of the given array arr.\n *\n * @param {Array|TypedArray} arr\n * @param {Number} firstIdx\n * @param {Number} lastIdx\n */\nfunction reverseElements(arr) {\n  let firstIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  let lastIdx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  const first = firstIdx ?? 0;\n  const last = lastIdx ?? arr.length - 1;\n  const mid = first + Math.floor((last - first) / 2);\n  for (let i = first; i <= mid; ++i) {\n    [arr[i], arr[last - (i - first)]] = [arr[last - (i - first)], arr[i]];\n  }\n}\n\n// ---------------------------------------------------\n/**\n * Compute the quality of a triangle.\n *\n * @param {Vector3} p0\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {Vector3} normal\n * @returns {Number}\n */\nfunction vtkCCSTriangleQuality(p0, p1, p2, normal) {\n  const u = [];\n  const v = [];\n  const w = [];\n  subtract(p1, p0, u);\n  subtract(p2, p1, v);\n  subtract(p0, p2, w);\n  const area2 = (u[1] * v[2] - u[2] * v[1]) * normal[0] + (u[2] * v[0] - u[0] * v[2]) * normal[1] + (u[0] * v[1] - u[1] * v[0]) * normal[2];\n  let perim = Math.sqrt(u[0] * u[0] + u[1] * u[1] + u[2] * u[2]) + Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]) + Math.sqrt(w[0] * w[0] + w[1] * w[1] + w[2] * w[2]);\n  perim *= perim; // square the perimeter\n  perim = perim !== 0 ? perim : 1.0;\n\n  // use a normalization factor so equilateral quality is 1.0\n  return area2 / perim * 10.392304845413264;\n}\n\n// ---------------------------------------------------\n/**\n * Insert a triangle, and subdivide that triangle if one of\n * its edges originally had more than two points before\n * vtkCCSFindTrueEdges was called. Is called by vtkCCSTriangulate.\n *\n * @param {vtkCellArray} polys\n * @param {Array|TypedArray} poly\n * @param {Vector3} trids\n * @param {Array|TypedArray} polyEdges\n * @param {Array|TypedArray} originalEdges\n */\nfunction vtkCCSInsertTriangle(polys, poly, trids, polyEdges, originalEdges) {\n  const nextVert = [1, 2, 0];\n\n  // To store how many of originalEdges match\n  let edgeCount = 0;\n  const edgeLocs = [-1, -1, -1];\n\n  // Check for original edge matches\n  for (let vert = 0; vert < 3; vert++) {\n    const currId = trids[vert];\n    const edgeLoc = polyEdges[currId];\n    if (edgeLoc >= 0) {\n      let nextId = currId + 1;\n      if (nextId === poly.length) {\n        nextId = 0;\n      }\n\n      // Is the triangle edge a polygon edge?\n      if (nextId === trids[nextVert[vert]]) {\n        edgeLocs[vert] = edgeLoc;\n        edgeCount++;\n      }\n    }\n  }\n  if (edgeCount === 0) {\n    // No special edge handling, so just do one triangle\n    polys.insertNextCell([poly[trids[0]], poly[trids[1]], poly[trids[2]]]);\n  } else {\n    // Make triangle fans for edges with extra points\n    const edgePts = [[poly[trids[0]], poly[trids[1]]], [poly[trids[1]], poly[trids[2]]], [poly[trids[2]], poly[trids[0]]]];\n\n    // Find out which edge has the most extra points\n    let maxPoints = 0;\n    let currSide = 0;\n    for (let i = 0; i < 3; i++) {\n      if (edgeLocs[i] >= 0) {\n        const edgeLoc = edgeLocs[i];\n        const npts = originalEdges[edgeLoc];\n        const pts = originalEdges.slice(edgeLoc + 1, edgeLoc + 1 + npts);\n        if (!(edgePts[i][0] === pts[0] || edgePts[i][1] === pts[npts - 1])) {\n          vtkErrorMacro('assertion error in vtkCCSInsertTriangle');\n        }\n        if (npts > maxPoints) {\n          maxPoints = npts;\n          currSide = i;\n        }\n        edgePts[i] = pts;\n      }\n    }\n\n    // Find the edges before/after the edge with most points\n    const prevSide = (currSide + 2) % 3;\n    const nextSide = (currSide + 1) % 3;\n\n    // If other edges have only 2 points, nothing to do with them\n    const prevNeeded = edgePts[prevSide].length > 2;\n    const nextNeeded = edgePts[nextSide].length > 2;\n\n    // The tail is the common point in the triangle fan\n    const tailPtIds = [];\n    tailPtIds[prevSide] = edgePts[currSide][1];\n    tailPtIds[currSide] = edgePts[prevSide][0];\n    tailPtIds[nextSide] = edgePts[currSide][edgePts[currSide].length - 2];\n\n    // Go through the sides and make the fans\n    for (let side = 0; side < 3; side++) {\n      if ((side !== prevSide || prevNeeded) && (side !== nextSide || nextNeeded)) {\n        let m = 0;\n        let n = edgePts[side].length - 1;\n        if (side === currSide) {\n          m += prevNeeded;\n          n -= nextNeeded;\n        }\n        for (let k = m; k < n; k++) {\n          polys.insertNextCell([edgePts[side][k], edgePts[side][k + 1], tailPtIds[side]]);\n        }\n      }\n    }\n  }\n}\n\n// ---------------------------------------------------\n/**\n * Triangulate a polygon that has been simplified by FindTrueEdges.\n * This will re-insert the original edges.  The output triangles are\n * appended to \"polys\" and, for each stored triangle, \"color\" will\n * be added to \"scalars\".  The final two arguments (polygon and\n * triangles) are only for temporary storage.\n * The return value is true if triangulation was successful.\n *\n * @param {Array} poly\n * @param {vtkPoints} points\n * @param {Array} polyEdges\n * @param {Array} originalEdges\n * @param {vtkCellArray} polys\n * @param {Vector3} normal\n * @returns {boolean}\n */\nfunction vtkCCSTriangulate(poly, points, polyEdges, originalEdges, polys, normal) {\n  let n = poly.length;\n\n  // If the poly is a line, then skip it\n  if (n < 3) {\n    return true;\n  }\n\n  // If the poly is a triangle, then pass it\n  if (n === 3) {\n    const trids = [0, 1, 2];\n    vtkCCSInsertTriangle(polys, poly, trids, polyEdges, originalEdges);\n    return true;\n  }\n\n  // If the poly has 4 or more points, triangulate it\n  let triangulationFailure = false;\n  let ppoint = [];\n  let point = [];\n  let npoint = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  const verts = [];\n  verts.length = n;\n  for (i = 0; i < n; i++) {\n    verts[i] = [i, 0];\n  }\n\n  // compute the triangle quality for each vert\n  k = n - 2;\n  points.getPoint(poly[verts[k][0]], point);\n  i = n - 1;\n  points.getPoint(poly[verts[i][0]], npoint);\n  let concave = 0;\n  let maxq = 0;\n  let maxi = 0;\n  for (j = 0; j < n; j++) {\n    [ppoint, point, npoint] = [point, npoint, ppoint];\n    points.getPoint(poly[verts[j][0]], npoint);\n    const q = vtkCCSTriangleQuality(ppoint, point, npoint, normal);\n    if (q > maxq) {\n      maxi = i;\n      maxq = q;\n    }\n    concave += q < 0;\n    verts[i][1] = q;\n    i = j;\n  }\n  let foundEar;\n  // perform the ear-cut triangulation\n  for (;;) {\n    // if no potential ears were found, then fail\n    if (maxq <= Number.MIN_VALUE) {\n      triangulationFailure = true;\n      break;\n    }\n    i = maxi;\n    j = i + 1 !== n ? i + 1 : 0;\n    k = i !== 0 ? i - 1 : n - 1;\n    if (verts[i][1] > 0) {\n      foundEar = true;\n      points.getPoint(poly[verts[j][0]], npoint);\n      points.getPoint(poly[verts[k][0]], ppoint);\n\n      // only do ear check if there are concave vertices\n      if (concave) {\n        // get the normal of the split plane\n        const v = [];\n        const u = [];\n        subtract(npoint, ppoint, v);\n        cross(v, normal, u);\n        const d = dot(ppoint, u);\n        let jj = j + 1 !== n ? j + 1 : 0;\n        let x = [];\n        points.getPoint(poly[verts[jj][0]], x);\n        let side = dot(x, u) < d;\n        let foundNegative = side;\n\n        // check for crossings of the split plane\n        jj = jj + 1 !== n ? jj + 1 : 0;\n        let y = [];\n        const s = [];\n        const t = [];\n        for (; foundEar && jj !== k; jj = jj + 1 !== n ? jj + 1 : 0) {\n          [x, y] = [y, x];\n          points.getPoint(poly[verts[jj][0]], x);\n          const sside = dot(x, u) < d;\n          // XOR\n          if (side ? !sside : sside) {\n            side = !side;\n            foundNegative = true;\n            foundEar = vtkLine.intersection(ppoint, npoint, x, y, s, t) === vtkLine.IntersectionState.NO_INTERSECTION;\n          }\n        }\n        foundEar &&= foundNegative;\n      }\n      if (!foundEar) {\n        // don't try again until it is split\n        verts[i][1] = Number.MIN_VALUE;\n      } else {\n        // create a triangle from vertex and neighbors\n        const trids = [verts[i][0], verts[j][0], verts[k][0]];\n        vtkCCSInsertTriangle(polys, poly, trids, polyEdges, originalEdges);\n\n        // remove the vertex i\n        verts.splice(i, 1);\n        k -= i === 0;\n        j -= j !== 0;\n\n        // break if this was final triangle\n        if (--n < 3) {\n          break;\n        }\n\n        // re-compute quality of previous point\n        const kk = k !== 0 ? k - 1 : n - 1;\n        points.getPoint(poly[verts[kk][0]], point);\n        const kq = vtkCCSTriangleQuality(point, ppoint, npoint, normal);\n        concave -= verts[k][1] < 0 && kq >= 0;\n        verts[k][1] = kq;\n\n        // re-compute quality of next point\n        const jj = j + 1 !== n ? j + 1 : 0;\n        points.getPoint(poly[verts[jj][0]], point);\n        const jq = vtkCCSTriangleQuality(ppoint, npoint, point, normal);\n        concave -= verts[j][1] < 0 && jq >= 0;\n        verts[j][1] = jq;\n      }\n    }\n\n    // find the highest-quality ear candidate\n    maxi = 0;\n    maxq = verts[0][1];\n    for (i = 1; i < n; i++) {\n      const q = verts[i][1];\n      if (q > maxq) {\n        maxi = i;\n        maxq = q;\n      }\n    }\n  }\n  return !triangulationFailure;\n}\n\n// ---------------------------------------------------\n/**\n * Create polygons from line segments.\n *\n * @param {vtkPolyData} polyData\n * @param {Number} firstLine\n * @param {Number} endLine\n * @param {Boolean} oriented\n * @param {Array} newPolys\n * @param {Array} incompletePolys\n */\nfunction vtkCCSMakePolysFromLines(polyData, firstLine, endLine, oriented, newPolys, incompletePolys) {\n  let npts = 0;\n  let pts = [];\n\n  // Bitfield for marking lines as used\n  const usedLines = new Uint8Array(endLine - firstLine); // defaults to 0\n\n  // Require cell links to get lines from pointIds\n  polyData.buildLinks(polyData.getPoints().getNumberOfPoints());\n  let numNewPolys = 0;\n  let remainingLines = endLine - firstLine;\n  while (remainingLines > 0) {\n    // Create a new poly\n    const polyId = numNewPolys++;\n    const poly = [];\n    newPolys.push(poly);\n    let lineId = 0;\n    let completePoly = false;\n\n    // start the poly\n    for (lineId = firstLine; lineId < endLine; lineId++) {\n      if (!usedLines[lineId - firstLine]) {\n        pts = polyData.getCellPoints(lineId).cellPointIds;\n        npts = pts.length;\n        let n = npts;\n        if (npts > 2 && pts[0] === pts[npts - 1]) {\n          n = npts - 1;\n          completePoly = true;\n        }\n        poly.length = n;\n        for (let i = 0; i < n; i++) {\n          poly[i] = pts[i];\n        }\n        break;\n      }\n    }\n    usedLines[lineId - firstLine] = 1;\n    remainingLines--;\n    let noLinesMatch = remainingLines === 0 && !completePoly;\n    while (!completePoly && !noLinesMatch && remainingLines > 0) {\n      // This is cleared if a match is found\n      noLinesMatch = true;\n\n      // Number of points in the poly\n      const npoly = poly.length;\n      const lineEndPts = [];\n      const endPts = [poly[npoly - 1], poly[0]];\n\n      // For both open ends of the polygon\n      for (let endIdx = 0; endIdx < 2; endIdx++) {\n        const matches = [];\n        const cells = polyData.getPointCells(endPts[endIdx]);\n\n        // Go through all lines that contain this endpoint\n        for (let icell = 0; icell < cells.length; icell++) {\n          lineId = cells[icell];\n          if (lineId >= firstLine && lineId < endLine && !usedLines[lineId - firstLine]) {\n            pts = polyData.getCellPoints(lineId).cellPointIds;\n            npts = pts.length;\n            lineEndPts[0] = pts[0];\n            lineEndPts[1] = pts[npts - 1];\n\n            // Check that poly end matches line end\n            if (endPts[endIdx] === lineEndPts[endIdx] || !oriented && endPts[endIdx] === lineEndPts[1 - endIdx]) {\n              matches.push(lineId);\n            }\n          }\n        }\n        if (matches.length > 0) {\n          // Multiple matches mean we need to decide which path to take\n          if (matches.length > 1) {\n            // Remove double-backs\n            let k = matches.length;\n            do {\n              lineId = matches[--k];\n              pts = polyData.getCellPoints(lineId).cellPointIds;\n              npts = pts.length;\n              lineEndPts[0] = pts[0];\n              lineEndPts[1] = pts[npts - 1];\n              // check if line is reversed\n              const r = endPts[endIdx] !== lineEndPts[endIdx];\n              if (!r && (endIdx === 0 && poly[npoly - 2] === pts[1] || endIdx === 1 && poly[1] === pts[npts - 2]) || r && (endIdx === 0 && poly[npoly - 2] === pts[npts - 2] || endIdx === 1 && poly[1] === pts[1])) {\n                matches.splice(k, 1);\n              }\n            } while (k > 0 && matches.length > 1);\n\n            // If there are multiple matches due to intersections,\n            // they should be dealt with here.\n          }\n\n          lineId = matches[0];\n          pts = polyData.getCellPoints(lineId).cellPointIds;\n          npts = pts.length;\n          lineEndPts[0] = pts[0];\n          lineEndPts[1] = pts[npts - 1];\n\n          // Do both ends match?\n          if (endPts[endIdx] === lineEndPts[endIdx]) {\n            completePoly = endPts[1 - endIdx] === lineEndPts[1 - endIdx];\n          } else {\n            completePoly = endPts[1 - endIdx] === lineEndPts[endIdx];\n          }\n          if (endIdx === 0) {\n            for (let i = 1; i < npts - (completePoly ? 1 : 0); i++) {\n              poly.push(pts[i]);\n            }\n          } else {\n            for (let i = completePoly ? 1 : 0; i < npts - 1; i++) {\n              poly.unshift(pts[i]);\n            }\n          }\n          if (endPts[endIdx] !== lineEndPts[endIdx]) {\n            // reverse the ids in the added line\n            let pit = poly.length;\n            let ptsIt = completePoly ? 1 : 0;\n            let ptsEnd = npts - 1;\n            if (endIdx === 1) {\n              pit = npts - 1 - (completePoly ? 1 : 0);\n              ptsIt = pts + 1;\n              ptsEnd = pts + npts - (completePoly ? 1 : 0);\n            }\n            while (ptsIt !== ptsEnd) {\n              poly[--pit] = poly[ptsIt++];\n            }\n          }\n          usedLines[lineId - firstLine] = 1;\n          remainingLines--;\n          noLinesMatch = false;\n        }\n      }\n    }\n\n    // Check for incomplete polygons\n    if (noLinesMatch) {\n      incompletePolys.push(polyId);\n    }\n  }\n}\n\n// ---------------------------------------------------\n/**\n * Join polys that have loose ends, as indicated by incompletePolys.\n * Any polys created will have a normal opposite to the supplied normal,\n * and any new edges that are created will be on the hull of the point set.\n * Shorter edges will be preferred over long edges.\n *\n * @param {Array[]} polys\n * @param {Array} incompletePolys\n * @param {vtkPoints} points\n * @param {Vector3} normal\n */\nfunction vtkCCSJoinLooseEnds(polys, incompletePolys, points, normal) {\n  // Relative tolerance for checking whether an edge is on the hull\n  const tol = CCS_POLYGON_TOLERANCE;\n\n  // A list of polys to remove when everything is done\n  const removePolys = [];\n  const p1 = [];\n  const p2 = [];\n  let poly1;\n  let poly2;\n  let pt1;\n  let pt2;\n  let dMin;\n  let iMin;\n  let v;\n  let d;\n  let n = incompletePolys.length;\n  while (n !== 0) {\n    poly1 = polys[incompletePolys[n - 1]];\n    pt1 = poly1[poly1.length - 1];\n    points.getPoint(pt1, p1);\n    dMin = Number.MAX_VALUE;\n    iMin = 0;\n    for (let i = 0; i < n; i++) {\n      poly2 = polys[incompletePolys[i]];\n      pt2 = poly2[0];\n      points.getPoint(pt2, p2);\n\n      // The next few steps verify that edge [p1, p2] is on the hull\n      v = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n      d = norm(v);\n      if (d !== 0) {\n        v[0] /= d;\n        v[1] /= d;\n        v[2] /= d;\n      }\n\n      // Compute the midpoint of the edge\n      const pm = [0.5 * (p1[0] + p2[0]), 0.5 * (p1[1] + p2[1]), 0.5 * (p1[2] + p2[2])];\n\n      // Create a plane equation\n      const pc = [];\n      cross(normal, v, pc);\n      pc[3] = -dot(pc, pm);\n\n      // Check that all points are inside the plane.  If they aren't, then\n      // the edge is not on the hull of the pointset.\n      let badPoint = false;\n      const m = polys.length;\n      const p = [];\n      for (let j = 0; j < m && !badPoint; j++) {\n        const poly = polys[j];\n        const npts = poly.length;\n        for (let k = 0; k < npts; k++) {\n          const ptId = poly[k];\n          if (ptId !== pt1 && ptId !== pt2) {\n            points.getPoint(ptId, p);\n            const val = p[0] * pc[0] + p[1] * pc[1] + p[2] * pc[2] + pc[3];\n            const r2 = distance2BetweenPoints(p, pm);\n\n            // Check distance from plane against the tolerance\n            if (val < 0 && val * val > tol * tol * r2) {\n              badPoint = true;\n              break;\n            }\n          }\n        }\n\n        // If no bad points, then this edge is a candidate\n        if (!badPoint && d < dMin) {\n          dMin = d;\n          iMin = i;\n        }\n      }\n    }\n\n    // If a match was found, append the polys\n    if (dMin < Number.MAX_VALUE) {\n      // Did the poly match with itself?\n      if (iMin === n - 1) {\n        // Mark the poly as closed\n        incompletePolys.pop();\n      } else {\n        const id2 = incompletePolys[iMin];\n\n        // Combine the polys\n        // for (let i = 1; i < polys[id2].length; i++) {\n        //   poly1.push(polys[id2][i]);\n        // }\n        poly1.push(...polys[id2]);\n\n        // Erase the second poly\n        removePolys.push(id2);\n        incompletePolys.splice(iMin, 1);\n      }\n    } else {\n      // If no match, erase this poly from consideration\n      removePolys.push(incompletePolys[n - 1]);\n      incompletePolys.pop();\n    }\n    n = incompletePolys.length;\n  }\n\n  // Remove polys that couldn't be completed\n  removePolys.sort((a, b) => a - b);\n  let i = removePolys.length;\n  while (i > 0) {\n    // Remove items in reverse order\n    polys.splice(removePolys[--i], 1);\n  }\n\n  // Clear the incompletePolys vector, it's indices are no longer valid\n  incompletePolys.length = 0;\n}\n\n// ---------------------------------------------------\n/**\n * Given three vectors p.p1, p.p2, and p.p3, this routine\n * checks to see if progressing from p1 to p2 to p3 is a clockwise\n * or counterclockwise progression with respect to the normal.\n * The return value is -1 for clockwise, +1 for counterclockwise,\n * and 0 if any two of the vectors are coincident.\n *\n * @param {Vector3} p\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {Vector3} p3\n * @param {Vector3} normal\n * @returns {Number}\n */\nfunction vtkCCSVectorProgression(p, p1, p2, p3, normal) {\n  const v1 = [p1[0] - p[0], p1[1] - p[1], p1[2] - p[2]];\n  const v2 = [p2[0] - p[0], p2[1] - p[1], p2[2] - p[2]];\n  const v3 = [p3[0] - p[0], p3[1] - p[1], p3[2] - p[2]];\n  const w1 = [];\n  const w2 = [];\n  cross(v2, v1, w1);\n  cross(v2, v3, w2);\n  const s1 = dot(w1, normal);\n  const s2 = dot(w2, normal);\n  if (s1 !== 0 && s2 !== 0) {\n    const sb1 = s1 < 0;\n    const sb2 = s2 < 0;\n\n    // if sines have different signs\n    // XOR\n    if (sb1 ? !sb2 : sb2) {\n      // return -1 if s2 is -ve\n      return 1 - 2 * sb2;\n    }\n    const c1 = dot(v2, v1);\n    const l1 = norm(v1);\n    const c2 = dot(v2, v3);\n    const l2 = norm(v3);\n\n    // ck is the difference of the cosines, flipped in sign if sines are +ve\n    const ck = (c2 * l2 - c1 * l1) * (1 - sb1 * 2);\n    if (ck !== 0) {\n      // return the sign of ck\n      return 1 - 2 * (ck < 0);\n    }\n  }\n  return 0;\n}\n\n// ---------------------------------------------------\n/**\n * Check for self-intersection. Split the figure-eights.\n * This assumes that all intersections occur at existing\n * vertices, i.e. no new vertices will be created. Returns\n * the number of splits made.\n *\n * @param {Array[]} polys\n * @param {vtkPoints} points\n * @param {Array} polyGroups\n * @param {Array} polyEdges\n * @param {Vector3} normal\n * @param {Boolean} oriented\n */\nfunction vtkCCSSplitAtPinchPoints(polys, points, polyGroups, polyEdges, normal, oriented) {\n  const tryPoints = vtkPoints.newInstance({\n    dataType: VtkDataTypes.DOUBLE,\n    empty: true\n  });\n  const locator = vtkIncrementalOctreePointLocator.newInstance();\n  let splitCount = 0;\n  let poly;\n  let n;\n  let bounds;\n  let tol;\n  for (let i = 0; i < polys.length; i++) {\n    poly = polys[i];\n    n = poly.length;\n    bounds = [];\n    tol = CCS_POLYGON_TOLERANCE * Math.sqrt(vtkPolygon.getBounds(poly, points, bounds));\n    if (tol === 0) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    tryPoints.initialize();\n    locator.setTolerance(tol);\n    locator.initPointInsertion(tryPoints, bounds);\n    let foundMatch = false;\n    let idx1 = 0;\n    let idx2 = 0;\n    let unique = 0;\n    const point = [];\n    const p1 = [];\n    const p2 = [];\n    const p3 = [];\n    for (idx2 = 0; idx2 < n; idx2++) {\n      points.getPoint(poly[idx2], point);\n      const {\n        success,\n        pointIdx\n      } = locator.insertUniquePoint(point, 0);\n      if (!success) {\n        // Need vertIdx to match poly indices, so force point insertion\n        locator.insertNextPoint(point);\n\n        // Do the points have different pointIds?\n        idx1 = pointIdx;\n        unique = poly[idx2] !== poly[idx1];\n        if (idx2 > idx1 + 2 - unique && n + idx1 > idx2 + 2 - unique) {\n          if (oriented) {\n            // Make sure that splitting this poly won't create a hole poly\n            let prevIdx = n + idx1 - 1;\n            let midIdx = idx1 + 1;\n            let nextIdx = idx2 + 1;\n            if (prevIdx >= n) {\n              prevIdx -= n;\n            }\n            if (midIdx >= n) {\n              midIdx -= n;\n            }\n            if (nextIdx >= n) {\n              nextIdx -= n;\n            }\n            points.getPoint(poly[prevIdx], p1);\n            points.getPoint(poly[midIdx], p2);\n            points.getPoint(poly[nextIdx], p3);\n            if (vtkCCSVectorProgression(point, p1, p2, p3, normal) > 0) {\n              foundMatch = true;\n              break;\n            }\n          } else {\n            foundMatch = true;\n            break;\n          }\n        }\n      }\n    }\n    if (foundMatch) {\n      splitCount++;\n\n      // Split off a new poly\n      const m = idx2 - idx1;\n      const oldPoly = polys[i];\n      const oldEdges = polyEdges[i];\n      const newPoly1 = oldPoly.slice(idx1, idx1 + m + unique);\n      const newEdges1 = oldEdges.slice(idx1, idx1 + m + unique);\n      const newPoly2 = new Array(n - m + unique);\n      const newEdges2 = new Array(n - m + unique);\n      if (unique) {\n        newEdges1[m] = -1;\n      }\n\n      // The poly that is split off, which might have more intersections\n      for (let j = 0; j < idx1 + unique; j++) {\n        newPoly2[j] = oldPoly[j];\n        newEdges2[j] = oldEdges[j];\n      }\n      if (unique) {\n        newEdges2[idx1] = -1;\n      }\n      for (let k = idx2; k < n; k++) {\n        newPoly2[k - m + unique] = oldPoly[k];\n        newEdges2[k - m + unique] = oldEdges[k];\n      }\n      polys[i] = newPoly1;\n      polyEdges[i] = newEdges1;\n      polys.push(newPoly2);\n      polyEdges.push(newEdges2);\n\n      // Unless polygroup was clear (because poly was reversed),\n      // make a group with one entry for the new poly\n      polyGroups.length = polys.length;\n      if (polyGroups[i].length > 0) {\n        polyGroups[polys.length - 1].push(polys.length - 1);\n      }\n    }\n  }\n  return splitCount;\n}\n\n// ---------------------------------------------------\n/**\n * The polygons might have a lot of extra points, i.e. points\n * in the middle of the edges.  Remove those points, but keep\n * the original edges as polylines in the originalEdges array.\n * Only original edges with more than two points will be kept.\n *\n * @param {Array[]} polys\n * @param {vtkPoints} points\n * @param {Array} polyEdges\n * @param {Array} originalEdges\n */\nfunction vtkCCSFindTrueEdges(polys, points, polyEdges, originalEdges) {\n  // Tolerance^2 for angle to see if line segments are parallel\n  const atol2 = CCS_POLYGON_TOLERANCE * CCS_POLYGON_TOLERANCE;\n  const p0 = [];\n  const p1 = [];\n  const p2 = [];\n  const v1 = [];\n  const v2 = [];\n  let l1;\n  let l2;\n  for (let polyId = 0; polyId < polys.length; polyId++) {\n    const oldPoly = polys[polyId];\n    const n = oldPoly.length;\n    const newEdges = [];\n    polyEdges.push(newEdges);\n\n    // Only useful if poly has more than three sides\n    if (n < 4) {\n      newEdges[0] = -1;\n      newEdges[1] = -1;\n      newEdges[2] = -1;\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    // While we remove points, m keeps track of how many points are left\n    let m = n;\n\n    // Compute bounds for tolerance\n    const bounds = [];\n    const tol2 = vtkPolygon.getBounds(oldPoly, points, bounds) * atol2;\n\n    // The new poly\n    const newPoly = [];\n    let cornerPointId = 0;\n    let oldOriginalId = -1;\n\n    // Keep the partial edge from before the first corner is found\n    const partialEdge = [];\n    let cellCount = 0;\n    points.getPoint(oldPoly[n - 1], p0);\n    points.getPoint(oldPoly[0], p1);\n    subtract(p1, p0, v1);\n    l1 = dot(v1, v1);\n    for (let j = 0; j < n; j++) {\n      let k = j + 1;\n      if (k >= n) {\n        k -= n;\n      }\n      points.getPoint(oldPoly[k], p2);\n      subtract(p2, p1, v2);\n      l2 = dot(v2, v2);\n\n      // Dot product is |v1||v2|cos(theta)\n      const c = dot(v1, v2);\n      // sin^2(theta) = (1 - cos^2(theta))\n      // and   c*c = l1*l2*cos^2(theta)\n      const s2 = l1 * l2 - c * c;\n\n      // In the small angle approximation, sin(theta) == theta, so\n      // s2/(l1*l2) is the angle that we want to check, but it's not\n      // a valid check if l1 or l2 is very close to zero.\n\n      const pointId = oldPoly[j];\n\n      // Keep the point if:\n      // 1) removing it would create a 2-point poly OR\n      // 2) it's more than \"tol\" distance from the prev point AND\n      // 3) the angle is greater than atol:\n      if (m <= 3 || l1 > tol2 && (c < 0 || l1 < tol2 || l2 < tol2 || s2 > l1 * l2 * atol2)) {\n        // Complete the previous edge only if the final point count\n        // will be greater than two\n        if (cellCount > 1) {\n          if (pointId !== oldOriginalId) {\n            originalEdges.push(pointId);\n            cellCount++;\n          }\n          // Update the number of segments in the edge\n          const countLocation = originalEdges.length - cellCount - 1;\n          originalEdges[countLocation] = cellCount;\n          newEdges.push(countLocation);\n        } else if (cellCount === 0) {\n          partialEdge.push(pointId);\n        } else {\n          newEdges.push(-1);\n        }\n        newPoly.push(pointId);\n\n        // Start a new edge with cornerPointId as a \"virtual\" point\n        cornerPointId = pointId;\n        oldOriginalId = pointId;\n        cellCount = 1;\n\n        // Rotate to the next point\n        p0[0] = p2[0];\n        p0[1] = p2[1];\n        p0[2] = p2[2];\n        p1[0] = p2[0];\n        p1[1] = p2[1];\n        p1[2] = p2[2];\n        v1[0] = v2[0];\n        v1[1] = v2[1];\n        v1[2] = v2[2];\n        l1 = l2;\n      } else {\n        if (cellCount > 0 && pointId !== oldOriginalId) {\n          // First check to see if we have to add cornerPointId\n          if (cellCount === 1) {\n            originalEdges.push(1); // new edge\n            originalEdges.push(cornerPointId);\n          }\n          // Then add the new point\n          originalEdges.push(pointId);\n          oldOriginalId = pointId;\n          cellCount++;\n        } else {\n          // No corner yet, so save the point\n          partialEdge.push(pointId);\n        }\n\n        // Reduce the count\n        m--;\n\n        // Join the previous two segments, since the point was removed\n        p1[0] = p2[0];\n        p1[1] = p2[1];\n        p1[2] = p2[2];\n        subtract(p2, p0, v1);\n        l1 = dot(v1, v1);\n      }\n    }\n\n    // Add the partial edge to the end\n    for (let ii = 0; ii < partialEdge.length; ii++) {\n      const pointId = partialEdge[ii];\n      if (pointId !== oldOriginalId) {\n        if (cellCount === 1) {\n          originalEdges.push(1); // new edge\n          originalEdges.push(cornerPointId);\n        }\n        originalEdges.push(pointId);\n        oldOriginalId = pointId;\n        cellCount++;\n      }\n    }\n\n    // Finalize\n    if (cellCount > 1) {\n      // Update the number of segments in the edge\n      const countLocation = originalEdges.length - cellCount - 1;\n      originalEdges[countLocation] = cellCount;\n      newEdges.push(countLocation);\n    }\n    polys[polyId] = newPoly;\n  }\n}\n\n// ---------------------------------------------------\n/**\n * Reverse a cleaned-up polygon along with the info about\n * all of its original vertices.\n *\n * @param {Array} poly\n * @param {Array} edges\n * @param {Array} originalEdges\n */\nfunction vtkCCSReversePoly(poly, edges, originalEdges) {\n  reverseElements(poly, 1, poly.length - 1);\n  edges.reverse();\n  for (let i = 0; i < edges.length; i++) {\n    if (edges[i] >= 0) {\n      const firstPtsIdx = edges[i] + 1;\n      const npts = originalEdges[edges[i]];\n      reverseElements(originalEdges, firstPtsIdx, firstPtsIdx + npts - 1);\n    }\n  }\n}\n\n// ---------------------------------------------------\n/**\n * Check the sense of the polygon against the given normal. Returns\n * zero if the normal is zero.\n *\n * @param {Array} poly\n * @param {vtkPoints} points\n * @param {Vector3} normal\n */\nfunction vtkCCSCheckPolygonSense(poly, points, normal) {\n  // Compute the normal\n  const pnormal = [0.0, 0.0, 0.0];\n  const p0 = [];\n  const p1 = [];\n  const p2 = [];\n  const v1 = [];\n  const v2 = [];\n  const v = [];\n  points.getPoint(poly[0], p0);\n  points.getPoint(poly[1], p1);\n  subtract(p1, p0, v1);\n  for (let jj = 2; jj < poly.length; jj++) {\n    points.getPoint(poly[jj], p2);\n    subtract(p2, p0, v2);\n    cross(v1, v2, v);\n    add(pnormal, v, pnormal);\n    p1[0] = p2[0];\n    p1[1] = p2[1];\n    p1[2] = p2[2];\n    v1[0] = v2[0];\n    v1[1] = v2[1];\n    v1[2] = v2[2];\n  }\n\n  // Check the normal\n  const d = dot(pnormal, normal);\n  return {\n    isNormalNotZero: d !== 0,\n    sense: d > 0\n  };\n}\n\n// ---------------------------------------------------\n/**\n * Check whether innerPoly is inside outerPoly.\n * The normal is needed to verify the polygon orientation.\n * The values of pp, bounds, and tol2 must be precomputed\n * by calling vtkCCSPrepareForPolyInPoly() on outerPoly.\n *\n * @param {Array} outerPoly\n * @param {Array} innerPoly\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @param {Float64Array} pp\n * @param {Bounds} bounds\n * @param {Number} tol2\n */\nfunction vtkCCSPolyInPoly(outerPoly, innerPoly, points, normal, pp, bounds, tol2) {\n  // Find a vertex of poly \"j\" that isn't on the edge of poly \"i\".\n  // This is necessary or the PointInPolygon might return \"true\"\n  // based only on roundoff error.\n  const n = outerPoly.length;\n  const m = innerPoly.length;\n  const p = [];\n  const q1 = [];\n  const q2 = [];\n  for (let jj = 0; jj < m; jj++) {\n    // Semi-randomize the point order\n    // eslint-disable-next-line no-bitwise\n    const kk = (jj >> 1) + (jj & 1) * (m + 1 >> 1);\n    points.getPoint(innerPoly[kk], p);\n    const intersectionState = vtkPolygon.pointInPolygon(p, pp, bounds, normal);\n    if (intersectionState === PolygonWithPointIntersectionState.FAILURE) {\n      vtkErrorMacro('Error finding point in polygon in vtkCCSPolyInPoly');\n    }\n    if (intersectionState !== PolygonWithPointIntersectionState.OUTSIDE) {\n      let pointOnEdge = 0;\n      points.getPoint(outerPoly[n - 1], q1);\n      for (let ii = 0; ii < n; ii++) {\n        points.getPoint(outerPoly[ii], q2);\n        // This method returns distance squared\n        const {\n          distance\n        } = vtkLine.distanceToLine(p, q1, q2);\n        if (distance < tol2) {\n          pointOnEdge = 1;\n          break;\n        }\n        q1[0] = q2[0];\n        q1[1] = q2[1];\n        q1[2] = q2[2];\n      }\n      if (!pointOnEdge) {\n        // Good result, point is in polygon\n        return true;\n      }\n    }\n  }\n\n  // No matches found\n  return false;\n}\n\n// ---------------------------------------------------\n/**\n * Precompute values needed for the PolyInPoly check.\n * The values that are returned are as follows:\n * pp: an array of the polygon vertices\n * bounds: the polygon bounds\n * tol2: a tolerance value based on the size of the polygon\n * (note: pp must be pre-allocated to the 3*outerPoly.length)\n *\n * @param {Array} outerPoly\n * @param {vtkPoints} points\n * @param {Float64Array} pp\n * @param {Bounds} bounds\n */\nfunction vtkCCSPrepareForPolyInPoly(outerPoly, points, pp, bounds) {\n  const n = outerPoly.length;\n  if (n === 0) {\n    return 0.0; // to avoid false positive warning about uninitialized value\n  }\n\n  // Pull out the points\n  const point = [];\n  let j = 0;\n  for (let i = 0; i < n; i++) {\n    points.getPoint(outerPoly[i], point);\n    pp[j++] = point[0];\n    pp[j++] = point[1];\n    pp[j++] = point[2];\n  }\n\n  // Find the bounding box and tolerance for the polygon\n  return vtkPolygon.getBounds(outerPoly, points, bounds) * (CCS_POLYGON_TOLERANCE * CCS_POLYGON_TOLERANCE);\n}\n\n// ---------------------------------------------------\n/**\n * Check for polygons within polygons. Group the polygons\n * if they are within each other. Reverse the sense of\n * the interior \"hole\" polygons. A hole within a hole\n * will be reversed twice and will become its own group.\n *\n * @param {Array} newPolys\n * @param {vtkPoints} points\n * @param {Array} polyGroups\n * @param {Array} polyEdges\n * @param {Array} originalEdges\n * @param {Vector3} normal\n * @param {Boolean} oriented\n */\nfunction vtkCCSMakeHoleyPolys(newPolys, points, polyGroups, polyEdges, originalEdges, normal, oriented) {\n  const numNewPolys = newPolys.length;\n  if (numNewPolys <= 1) {\n    return;\n  }\n\n  // Use bit arrays to keep track of inner polys\n  const polyReversed = [];\n  const innerPolys = [];\n\n  // GroupCount is an array only needed for unoriented polys\n  let groupCount;\n  if (!oriented) {\n    groupCount = new Int32Array(numNewPolys);\n  }\n\n  // Find the maximum poly size\n  let nmax = 1;\n  for (let kk = 0; kk < numNewPolys; kk++) {\n    nmax = Math.max(nmax, newPolys[kk].length);\n  }\n\n  // These are some values needed for poly-in-poly checks\n  const pp = new Float64Array(3 * nmax);\n  const bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];\n  let tol2;\n\n  // Go through all polys\n  for (let i = 0; i < numNewPolys; i++) {\n    const n = newPolys[i].length;\n    if (n < 3) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    // Check if poly is reversed\n    const {\n      isNormalNotZero,\n      sense\n    } = vtkCCSCheckPolygonSense(newPolys[i], points, normal);\n    if (isNormalNotZero) {\n      polyReversed[i] = !sense;\n    }\n\n    // Precompute some values needed for poly-in-poly checks\n    tol2 = vtkCCSPrepareForPolyInPoly(newPolys[i], points, pp, bounds);\n\n    // Look for polygons inside of this one\n    for (let j = 0; j < numNewPolys; j++) {\n      if (j !== i && newPolys[j].length >= 3) {\n        // Make sure polygon i is not in polygon j\n        const pg = polyGroups[j];\n        if (!pg.includes(i)) {\n          if (vtkCCSPolyInPoly(newPolys[i], newPolys[j], points, normal, pp.subarray(3 * n), bounds, tol2)) {\n            // Add to group\n            polyGroups[i].push(j);\n            if (groupCount) {\n              groupCount[j] += 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  if (!oriented) {\n    // build a stack of polys that aren't inside other polys=\n    const outerPolyStack = [];\n    for (let ll = 0; ll < numNewPolys; ll++) {\n      if (groupCount[ll] === 0) {\n        outerPolyStack.push(ll);\n      }\n    }\n    let j;\n    while (outerPolyStack.length > 0) {\n      j = outerPolyStack.length - 1;\n      outerPolyStack.pop();\n      if (polyReversed[j]) {\n        vtkCCSReversePoly(newPolys[j], polyEdges[j], originalEdges);\n        polyReversed[j] = false;\n      }\n      if (polyGroups[j].length > 1) {\n        // Convert the group into a bit array, to make manipulation easier\n        innerPolys.length = 0;\n        for (let k = 1; k < polyGroups[j].length; k++) {\n          const jj = polyGroups[j][k];\n          if (groupCount[jj] > 1) {\n            groupCount[jj] -= 2;\n            if (groupCount[jj] === 0) {\n              outerPolyStack.push(jj);\n            }\n          } else {\n            innerPolys[jj] = 1;\n            polyGroups[jj].length = 0;\n            if (!polyReversed[jj]) {\n              vtkCCSReversePoly(newPolys[jj], polyEdges[jj], originalEdges);\n              polyReversed[jj] = false;\n            }\n          }\n        }\n\n        // Use the bit array to recreate the polyGroup\n        polyGroups[j].length = 0;\n        polyGroups[j].push(j);\n        for (let jj = 0; jj < numNewPolys; jj++) {\n          if (innerPolys[jj]) {\n            polyGroups[j].push(jj);\n          }\n        }\n      }\n    }\n  } else {\n    // oriented\n    for (let j = 0; j < numNewPolys; j++) {\n      // Remove the groups for reversed polys\n      if (polyReversed[j]) {\n        polyGroups[j].length = 0;\n      }\n      // Polys inside the interior polys have their own groups, so remove\n      // them from this group\n      else if (polyGroups[j].length > 1) {\n        // Convert the group into a bit array, to make manipulation easier\n        innerPolys.length = 0;\n        for (let k = 1; k < polyGroups[j].length; k++) {\n          innerPolys[polyGroups[j][k]] = true;\n        }\n\n        // Look for non-reversed polys inside this one\n        for (let kk = 1; kk < polyGroups[j].length; kk++) {\n          // jj is the index of the inner poly\n          const jj = polyGroups[j][kk];\n          // If inner poly is not reversed then\n          if (!polyReversed[jj]) {\n            // Remove that poly and all polys inside of it from the group\n            for (let ii = 0; ii < polyGroups[jj].length; ii++) {\n              innerPolys[polyGroups[jj][ii]] = false;\n            }\n          }\n        }\n\n        // Use the bit array to recreate the polyGroup\n        polyGroups[j].length = 0;\n        polyGroups[j].push(j);\n        for (let jj = 0; jj < numNewPolys; jj++) {\n          if (innerPolys[jj]) {\n            polyGroups[j].push(jj);\n          }\n        }\n      }\n    }\n  }\n\n  // delete[] groupCount;\n}\n\n// ---------------------------------------------------\n/**\n * Check line segment with point Ids (i, j) to make sure that it\n * doesn't cut through the edges of any polys in the group.\n * Return value of zero means check failed and the cut is not\n * usable.\n *\n * @param {Array[]} polys\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @param {Array} polyGroup\n * @param {Number} outerPolyId\n * @param {Number} innerPolyId\n * @param {Number} outerIdx\n * @param {Number} innerIdx\n */\nfunction vtkCCSCheckCut(polys, points, normal, polyGroup, outerPolyId, innerPolyId, outerIdx, innerIdx) {\n  const ptId1 = polys[outerPolyId][outerIdx];\n  const ptId2 = polys[innerPolyId][innerIdx];\n  const tol = CCS_POLYGON_TOLERANCE;\n  const p1 = [];\n  const p2 = [];\n  points.getPoint(ptId1, p1);\n  points.getPoint(ptId2, p2);\n  const w = [];\n  subtract(p2, p1, w);\n  const l = normalize(w);\n\n  // Cuts between coincident points are good\n  if (l === 0) {\n    return true;\n  }\n\n  // Define a tolerance with units of distance squared\n  const tol2 = l * l * tol * tol;\n\n  // Check the sense of the cut: it must be pointing \"in\" for both polys.\n  let polyId = outerPolyId;\n  let polyIdx = outerIdx;\n  let r = p1;\n  const r1 = [];\n  let r2 = p2;\n  const r3 = [];\n  for (let ii = 0; ii < 2; ii++) {\n    const poly = polys[polyId];\n    const n = poly.length;\n    let prevIdx = n - polyIdx - 1;\n    let nextIdx = polyIdx + 1;\n    if (prevIdx >= n) {\n      prevIdx -= n;\n    }\n    if (nextIdx >= n) {\n      nextIdx -= n;\n    }\n    points.getPoint(poly[prevIdx], r1);\n    points.getPoint(poly[nextIdx], r3);\n    if (vtkCCSVectorProgression(r, r1, r2, r3, normal) > 0) {\n      return false;\n    }\n    polyId = innerPolyId;\n    polyIdx = innerIdx;\n    r = p2;\n    r2 = p1;\n  }\n\n  // Check for intersections of the cut with polygon edges.\n  // First, create a cut plane that divides space at the cut line.\n  const pc = [];\n  cross(normal, w, pc);\n  pc[3] = -dot(pc, p1);\n  for (let i = 0; i < polyGroup.length; i++) {\n    const poly = polys[polyGroup[i]];\n    const n = poly.length;\n    const q1 = [];\n    const q2 = [];\n    let qtId1 = poly[n - 1];\n    points.getPoint(qtId1, q1);\n    let v1 = pc[0] * q1[0] + pc[1] * q1[1] + pc[2] * q1[2] + pc[3];\n    let c1 = v1 > 0;\n    for (let j = 0; j < n; j++) {\n      const qtId2 = poly[j];\n      points.getPoint(qtId2, q2);\n      const v2 = pc[0] * q2[0] + pc[1] * q2[1] + pc[2] * q2[2] + pc[3];\n      const c2 = v2 > 0;\n\n      // If lines share an endpoint, they can't intersect,\n      // so don't bother with the check.\n      if (ptId1 !== qtId1 && ptId1 !== qtId2 && ptId2 !== qtId1 && ptId2 !== qtId2) {\n        // Check for intersection\n        if ((c1 ? !c2 : c2) || v1 * v1 < tol2 || v2 * v2 < tol2) {\n          subtract(q2, q1, w);\n          if (dot(w, w) > 0) {\n            const qc = [];\n            cross(w, normal, qc);\n            qc[3] = -dot(qc, q1);\n            const u1 = qc[0] * p1[0] + qc[1] * p1[1] + qc[2] * p1[2] + qc[3];\n            const u2 = qc[0] * p2[0] + qc[1] * p2[1] + qc[2] * p2[2] + qc[3];\n            const d1 = u1 > 0;\n            const d2 = u2 > 0;\n            if (d1 ? !d2 : d2) {\n              // One final check to make sure endpoints aren't coincident\n              let p = p1;\n              let q = q1;\n              if (v2 * v2 < v1 * v1) {\n                p = p2;\n              }\n              if (u2 * u2 < u1 * u1) {\n                q = q2;\n              }\n              if (distance2BetweenPoints(p, q) > tol2) {\n                return false;\n              }\n            }\n          }\n        }\n      }\n      qtId1 = qtId2;\n      q1[0] = q2[0];\n      q1[1] = q2[1];\n      q1[2] = q2[2];\n      v1 = v2;\n      c1 = c2;\n    }\n  }\n  return true;\n}\n\n// ---------------------------------------------------\n/**\n * Check the quality of a cut between an outer and inner polygon.\n * An ideal cut is one that forms a 90 degree angle with each\n * line segment that it joins to.  Smaller values indicate a\n * higher quality cut.\n *\n * @param {Array} outerPoly\n * @param {Array} innerPoly\n * @param {Number} i\n * @param {Number} j\n * @param {vtkPoints} points\n */\nfunction vtkCCSCutQuality(outerPoly, innerPoly, i, j, points) {\n  const n = outerPoly.length;\n  const m = innerPoly.length;\n  const a = i > 0 ? i - 1 : n - 1;\n  const b = i < n - 1 ? i + 1 : 0;\n  const c = j > 0 ? j - 1 : m - 1;\n  const d = j < m - 1 ? j + 1 : 0;\n  const p0 = [];\n  const p1 = [];\n  const p2 = [];\n  points.getPoint(outerPoly[i], p1);\n  points.getPoint(innerPoly[j], p2);\n  const v1 = [];\n  const v2 = [];\n  subtract(p2, p1, v1);\n  const l1 = dot(v1, v1);\n  let l2;\n  let qmax = 0;\n  let q;\n  points.getPoint(outerPoly[a], p0);\n  subtract(p0, p1, v2);\n  l2 = dot(v2, v2);\n  if (l2 > 0) {\n    q = dot(v1, v2);\n    q *= q / l2;\n    if (q > qmax) {\n      qmax = q;\n    }\n  }\n  points.getPoint(outerPoly[b], p0);\n  subtract(p0, p1, v2);\n  l2 = dot(v2, v2);\n  if (l2 > 0) {\n    q = dot(v1, v2);\n    q *= q / l2;\n    if (q > qmax) {\n      qmax = q;\n    }\n  }\n  points.getPoint(innerPoly[c], p0);\n  subtract(p2, p0, v2);\n  l2 = dot(v2, v2);\n  if (l2 > 0) {\n    q = dot(v1, v2);\n    q *= q / l2;\n    if (q > qmax) {\n      qmax = q;\n    }\n  }\n  points.getPoint(innerPoly[d], p0);\n  subtract(p2, p0, v2);\n  l2 = dot(v2, v2);\n  if (l2 > 0) {\n    q = dot(v1, v2);\n    q *= q / l2;\n    if (q > qmax) {\n      qmax = q;\n    }\n  }\n  if (l1 > 0) {\n    return qmax / l1; // also l1 + qmax, incorporates distance;\n  }\n\n  return Number.MAX_VALUE;\n}\n\n// ---------------------------------------------------\n/**\n * Find the two sharpest verts on an inner (i.e. inside-out) poly.\n *\n * @param {Array} poly\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @param {[Number, Number]} verts\n */\nfunction vtkCCSFindSharpestVerts(poly, points, normal, verts) {\n  const p1 = [];\n  const p2 = [];\n  const v1 = [];\n  const v2 = [];\n  const v = [];\n  let l1;\n  let l2;\n  const minVal = [0, 0];\n  verts[0] = 0;\n  verts[1] = 0;\n  const n = poly.length;\n  points.getPoint(poly[n - 1], p2);\n  points.getPoint(poly[0], p1);\n  subtract(p1, p2, v1);\n  l1 = Math.sqrt(dot(v1, v1));\n  for (let j = 0; j < n; j++) {\n    let k = j + 1;\n    if (k === n) {\n      k = 0;\n    }\n    points.getPoint(poly[k], p2);\n    subtract(p2, p1, v2);\n    l2 = Math.sqrt(dot(v2, v2));\n    cross(v1, v2, v);\n    const b = dot(v, normal);\n    if (b < 0 && l1 * l2 > 0) {\n      // Dot product is |v1||v2|cos(theta), range [-1, +1]\n      const val = dot(v1, v2) / (l1 * l2);\n      if (val < minVal[0]) {\n        minVal[1] = minVal[0];\n        minVal[0] = val;\n        verts[1] = verts[0];\n        verts[0] = j;\n      }\n    }\n\n    // Rotate to the next point\n    p1[0] = p2[0];\n    p1[1] = p2[1];\n    p1[2] = p2[2];\n    v1[0] = v2[0];\n    v1[1] = v2[1];\n    v1[2] = v2[2];\n    l1 = l2;\n  }\n}\n\n// ---------------------------------------------------\n/**\n * Find two valid cuts between outerPoly and innerPoly.\n * Used by vtkCCSCutHoleyPolys.\n *\n * @param {Array} polys\n * @param {Array} polyGroup\n * @param {Number} outerPolyId\n * @param {Number} innerPolyId\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @param {Array[]} cuts\n * @param {Boolean} exhaustive\n */\nfunction vtkCCSFindCuts(polys, polyGroup, outerPolyId, innerPolyId, points, normal, cuts, exhaustive) {\n  const outerPoly = polys[outerPolyId];\n  const innerPoly = polys[innerPolyId];\n  const innerSize = innerPoly.length;\n  // Find the two sharpest points on the inner poly\n  const verts = [];\n  vtkCCSFindSharpestVerts(innerPoly, points, normal, verts);\n\n  // A list of cut locations according to quality\n  const cutlist = [];\n  cutlist.length = outerPoly.length;\n\n  // Search for potential cuts (need to find two cuts)\n  let cutId = 0;\n  cuts[0][0] = 0;\n  cuts[0][1] = 0;\n  cuts[1][0] = 0;\n  cuts[1][1] = 0;\n  let foundCut = false;\n  for (cutId = 0; cutId < 2; cutId++) {\n    const count = exhaustive ? innerSize : 3;\n    for (let i = 0; i < count && !foundCut; i++) {\n      // Semi-randomize the search order\n      // TODO: Does this do the same as in C++?\n      // eslint-disable-next-line no-bitwise\n      let j = (i >> 1) + (i & 1) * (innerSize + 1 >> 1);\n      // Start at the best first point\n      j = (j + verts[cutId]) % innerSize;\n      for (let kk = 0; kk < outerPoly.length; kk++) {\n        const q = vtkCCSCutQuality(outerPoly, innerPoly, kk, j, points);\n        cutlist[kk] = [q, kk];\n      }\n      cutlist.sort((a, b) => a[0] - b[0]);\n      for (let lid = 0; lid < cutlist.length; lid++) {\n        const k = cutlist[lid][1];\n\n        // If this is the second cut, do extra checks\n        if (cutId > 0) {\n          // Make sure cuts don't share an endpoint\n          if (j === cuts[0][1] || k === cuts[0][0]) {\n            // eslint-disable-next-line no-continue\n            continue;\n          }\n\n          // Make sure cuts don't intersect\n          const p1 = [];\n          const p2 = [];\n          points.getPoint(outerPoly[cuts[0][0]], p1);\n          points.getPoint(innerPoly[cuts[0][1]], p2);\n          const q1 = [];\n          const q2 = [];\n          points.getPoint(outerPoly[k], q1);\n          points.getPoint(innerPoly[j], q2);\n          let u;\n          let v;\n          if (vtkLine.intersection(p1, p2, q1, q2, u, v) === vtkLine.IntersectionState.YES_INTERSECTION) {\n            // eslint-disable-next-line no-continue\n            continue;\n          }\n        }\n\n        // This check is done for both cuts\n        if (vtkCCSCheckCut(polys, points, normal, polyGroup, outerPolyId, innerPolyId, k, j)) {\n          cuts[cutId][0] = k;\n          cuts[cutId][1] = j;\n          foundCut = true;\n          break;\n        }\n      }\n    }\n    if (!foundCut) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// ---------------------------------------------------\n/**\n * Helper for vtkCCSCutHoleyPolys.  Change a polygon and a hole\n * into two separate polygons by making two cuts between them.\n *\n * @param {Array[]} polys\n * @param {Array} polyEdges\n * @param {Number} outerPolyId\n * @param {Number} innerPolyId\n * @param {vtkPoints} points\n * @param {Array[]} cuts\n */\nfunction vtkCCSMakeCuts(polys, polyEdges, outerPolyId, innerPolyId, points, cuts) {\n  const q = [];\n  const r = [];\n  for (let bb = 0; bb < 2; bb++) {\n    const ptId1 = polys[outerPolyId][cuts[bb][0]];\n    const ptId2 = polys[innerPolyId][cuts[bb][1]];\n    points.getPoint(ptId1, q);\n    points.getPoint(ptId2, r);\n  }\n  const outerPoly = polys[outerPolyId];\n  const innerPoly = polys[innerPolyId];\n  const outerEdges = polyEdges[outerPolyId];\n  const innerEdges = polyEdges[innerPolyId];\n\n  // Generate new polys from the cuts\n  const n = outerPoly.length;\n  const m = innerPoly.length;\n  let idx;\n\n  // Generate poly1\n  const n1 = n * (cuts[1][0] < cuts[0][0]) + cuts[1][0] - cuts[0][0] + 1;\n  const n2 = n1 + m * (cuts[0][1] < cuts[1][1]) + cuts[0][1] - cuts[1][1] + 1;\n  const poly1 = [];\n  poly1.length = n2;\n  const edges1 = new Array(n2);\n  idx = cuts[0][0];\n  for (let i1 = 0; i1 < n1; i1++) {\n    const k = idx++;\n    poly1[i1] = outerPoly[k];\n    edges1[i1] = outerEdges[k];\n    idx *= idx !== n;\n  }\n  edges1[n1 - 1] = -1;\n  idx = cuts[1][1];\n  for (let i2 = n1; i2 < n2; i2++) {\n    const k = idx++;\n    poly1[i2] = innerPoly[k];\n    edges1[i2] = innerEdges[k];\n    idx *= idx !== m;\n  }\n  edges1[n2 - 1] = -1;\n\n  // Generate poly2\n  const m1 = n * (cuts[0][0] < cuts[1][0]) + cuts[0][0] - cuts[1][0] + 1;\n  const m2 = m1 + m * (cuts[1][1] < cuts[0][1]) + cuts[1][1] - cuts[0][1] + 1;\n  const poly2 = [];\n  poly2.length = m2;\n  const edges2 = new Array(m2);\n  idx = cuts[1][0];\n  for (let j1 = 0; j1 < m1; j1++) {\n    const k = idx++;\n    poly2[j1] = outerPoly[k];\n    edges2[j1] = outerEdges[k];\n    idx *= idx !== n;\n  }\n  edges2[m1 - 1] = -1;\n  idx = cuts[0][1];\n  for (let j2 = m1; j2 < m2; j2++) {\n    const k = idx++;\n    poly2[j2] = innerPoly[k];\n    edges2[j2] = innerEdges[k];\n    idx *= idx !== m;\n  }\n  edges2[m2 - 1] = -1;\n\n  // Replace outerPoly and innerPoly with these new polys\n  polys[outerPolyId] = poly1;\n  polys[innerPolyId] = poly2;\n  polyEdges[outerPolyId] = edges1;\n  polyEdges[innerPolyId] = edges2;\n}\n\n// ---------------------------------------------------\n/**\n * After the holes have been identified, make cuts between the\n * outer poly and each hole.  Make two cuts per hole.  The only\n * strict requirement is that the cut must not intersect any\n * edges, but it's best to make sure that no really sharp angles\n * are created.\n *\n * @param {Array[]} polys\n * @param {vtkPoints} points\n * @param {Array[]} polyGroups\n * @param {Array} polyEdges\n * @param {Vector3} normal\n * @returns {boolean}\n */\nfunction vtkCCSCutHoleyPolys(polys, points, polyGroups, polyEdges, normal) {\n  let cutFailure = 0;\n\n  // Go through all groups and cut out the first inner poly that is\n  // found.  Every time an inner poly is cut out, the groupId counter\n  // is reset because cutting a poly creates a new group.\n  let groupId = 0;\n  while (groupId < polyGroups.length) {\n    const polyGroup = polyGroups[groupId];\n\n    // Only need to make a cut if the group size is greater than 1\n    if (polyGroup.length > 1) {\n      // The first member of the group is the outer poly\n      const outerPolyId = polyGroup[0];\n\n      // The second member of the group is the first inner poly\n      let innerPolyId = polyGroup[1];\n\n      // Sort the group by size, do largest holes first\n      let innerBySize = new Array(polyGroup.length);\n      for (let i = 1; i < polyGroup.length; i++) {\n        innerBySize[i] = [polys[polyGroup[i]].length, i];\n      }\n      innerBySize = [innerBySize[0], ...innerBySize.splice(1).sort((a, b) => a[0] - b[0])];\n      reverseElements(innerBySize, 1, innerBySize.length - 1);\n\n      // Need to check all inner polys in sequence, until one succeeds.\n      // Do a quick search first, then do an exhaustive search.\n      let madeCut = 0;\n      let inner = 0;\n      for (let exhaustive = 0; exhaustive < 2 && !madeCut; exhaustive++) {\n        for (let j = 1; j < polyGroup.length; j++) {\n          inner = innerBySize[j][1];\n          innerPolyId = polyGroup[inner];\n          const cuts = [];\n          if (vtkCCSFindCuts(polys, polyGroup, outerPolyId, innerPolyId, points, normal, cuts, exhaustive)) {\n            vtkCCSMakeCuts(polys, polyEdges, outerPolyId, innerPolyId, points, cuts);\n            madeCut = 1;\n            break;\n          }\n        }\n      }\n      if (madeCut) {\n        // Move successfully cut innerPolyId into its own group\n        polyGroup.splice(inner, 1);\n        // Only add if innerPolyId hasn't been set already.\n        // Having the same poly occur as both polyGroup and\n        // innerPoly would cause an infinite loop.\n        if (polyGroups[innerPolyId].length === 0) {\n          polyGroups[innerPolyId].push(innerPolyId);\n        }\n      } else {\n        // Remove all failed inner polys from the group\n        for (let k = 1; k < polyGroup.length; k++) {\n          innerPolyId = polyGroup[k];\n          // Only add if innerPolyId hasn't been set already.\n          // Having the same poly occur as both polyGroup and\n          // innerPoly would cause an infinite loop.\n          if (polyGroups[innerPolyId].length === 0) {\n            polyGroups[innerPolyId].push(innerPolyId);\n          }\n        }\n        polyGroup.length = 1;\n        cutFailure = 1;\n      }\n\n      // If there are other interior polys in the group, find out whether\n      // they are in poly1 or poly2\n      if (polyGroup.length > 1) {\n        const poly1 = polys[outerPolyId];\n        const pp = new Float64Array(3 * poly1.length);\n        const bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];\n        const tol2 = vtkCCSPrepareForPolyInPoly(poly1, points, pp, bounds);\n        let nextGroupId = groupId;\n        let ii = 1;\n        while (ii < polyGroup.length) {\n          if (vtkCCSPolyInPoly(poly1, polys[polyGroup[ii]], points, normal, pp, bounds, tol2)) {\n            // Keep this poly in polyGroup\n            ii++;\n          } else {\n            // Move this poly to poly2 group\n            polyGroups[innerPolyId].push(polyGroup[ii]);\n            polyGroup.splice(ii, 1);\n\n            // Reduce the groupId to ensure that this new group will get cut\n            if (innerPolyId < nextGroupId) {\n              nextGroupId = innerPolyId;\n            }\n          }\n        }\n\n        // Set the groupId for the next iteration\n        groupId = nextGroupId;\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n    }\n    // Increment to the next group\n    groupId++;\n  }\n  return !cutFailure;\n}\n\nexport { reverseElements, vtkCCSCheckCut, vtkCCSCheckPolygonSense, vtkCCSCutHoleyPolys, vtkCCSCutQuality, vtkCCSFindCuts, vtkCCSFindSharpestVerts, vtkCCSFindTrueEdges, vtkCCSInsertTriangle, vtkCCSJoinLooseEnds, vtkCCSMakeCuts, vtkCCSMakeHoleyPolys, vtkCCSMakePolysFromLines, vtkCCSPolyInPoly, vtkCCSPrepareForPolyInPoly, vtkCCSReversePoly, vtkCCSSplitAtPinchPoints, vtkCCSTriangleQuality, vtkCCSTriangulate, vtkCCSVectorProgression };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}