import { volumeLoader, utilities as csUtils, eventTarget, } from '@cornerstonejs/core';
import { Events, SegmentationRepresentations } from '../../enums';
import addSegmentations from './addSegmentations';
import addSegmentationRepresentations from './addSegmentationRepresentations';
import { triggerSegmentationRender } from '../../utilities/segmentation';
import { getSegmentation, removeSegmentation } from './segmentationState';
import { triggerSegmentationDataModified } from './triggerSegmentationEvents';
async function convertStackToVolumeSegmentation({ segmentationId, options, }) {
    const segmentation = getSegmentation(segmentationId);
    const { toolGroupId } = options;
    const data = segmentation.representationData
        .LABELMAP;
    const imageIdReferenceMap = data.imageIdReferenceMap;
    const segmentationImageIds = Array.from(imageIdReferenceMap.values());
    const additionalDetails = {
        imageIdReferenceMap,
    };
    const volumeId = options?.volumeId;
    await volumeLoader.createAndCacheVolumeFromImages(volumeId, segmentationImageIds, {
        additionalDetails,
    });
    const newSegmentationId = options?.newSegmentationId ?? csUtils.uuidv4();
    if (options?.removeOriginal ?? true) {
        removeSegmentation(segmentationId);
    }
    await addSegmentations([
        {
            segmentationId: newSegmentationId,
            representation: {
                type: SegmentationRepresentations.Labelmap,
                data: {
                    volumeId,
                },
            },
        },
    ]);
    await addSegmentationRepresentations(toolGroupId, [
        {
            segmentationId: newSegmentationId,
            type: SegmentationRepresentations.Labelmap,
        },
    ]);
    triggerSegmentationRender(toolGroupId);
    eventTarget.addEventListenerOnce(Events.SEGMENTATION_RENDERED, () => triggerSegmentationDataModified(newSegmentationId));
}
export { convertStackToVolumeSegmentation };
//# sourceMappingURL=convertStackToVolumeSegmentation.js.map