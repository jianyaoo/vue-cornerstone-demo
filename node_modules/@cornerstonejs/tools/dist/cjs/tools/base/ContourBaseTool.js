"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContourBaseTool = exports.default = void 0;
const core_1 = require("@cornerstonejs/core");
const annotationState_1 = require("../../stateManagement/annotation/annotationState");
const drawingSvg_1 = require("../../drawingSvg");
const AnnotationTool_1 = __importDefault(require("./AnnotationTool"));
class ContourBaseTool extends AnnotationTool_1.default {
    constructor(toolProps, defaultToolProps) {
        super(toolProps, defaultToolProps);
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        let renderStatus = false;
        const { viewport } = enabledElement;
        const { element } = viewport;
        if (!viewport.getRenderingEngine()) {
            console.warn('Rendering Engine has been destroyed');
            return renderStatus;
        }
        let annotations = (0, annotationState_1.getAnnotations)(this.getToolName(), element);
        if (!(annotations === null || annotations === void 0 ? void 0 : annotations.length)) {
            return renderStatus;
        }
        annotations = this.filterInteractableAnnotationsForElement(element, annotations);
        if (!(annotations === null || annotations === void 0 ? void 0 : annotations.length)) {
            return renderStatus;
        }
        const targetId = this.getTargetId(viewport);
        const styleSpecifier = {
            toolGroupId: this.toolGroupId,
            toolName: this.getToolName(),
            viewportId: enabledElement.viewport.id,
        };
        for (let i = 0; i < annotations.length; i++) {
            const annotation = annotations[i];
            styleSpecifier.annotationUID = annotation.annotationUID;
            const annotationStyle = this.getAnnotationStyle({
                annotation,
                styleSpecifier,
            });
            if (!annotationStyle.visibility) {
                continue;
            }
            const annotationRendered = this.renderAnnotationInstance({
                enabledElement,
                targetId,
                annotation,
                annotationStyle,
                svgDrawingHelper,
            });
            renderStatus || (renderStatus = annotationRendered);
            annotation.invalidated = false;
        }
        return renderStatus;
    }
    createAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const { world: worldPos } = currentPoints;
        const enabledElement = (0, core_1.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const { viewPlaneNormal, viewUp } = camera;
        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
        return {
            highlighted: true,
            invalidated: true,
            metadata: {
                toolName: this.getToolName(),
                viewPlaneNormal: [...viewPlaneNormal],
                viewUp: [...viewUp],
                FrameOfReferenceUID,
                referencedImageId,
            },
            data: {
                handles: {
                    points: [],
                    activeHandleIndex: null,
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                },
                contour: {
                    polyline: [],
                    closed: false,
                },
            },
        };
    }
    addAnnotation(annotation, element) {
        return (0, annotationState_1.addAnnotation)(annotation, element);
    }
    cancelAnnotation(annotation) {
    }
    getPolylinePoints(annotation) {
        var _a, _b;
        return (_b = (_a = annotation.data.contour) === null || _a === void 0 ? void 0 : _a.polyline) !== null && _b !== void 0 ? _b : annotation.data.polyline;
    }
    renderAnnotationInstance(renderContext) {
        const { enabledElement, annotationStyle, svgDrawingHelper } = renderContext;
        const annotation = renderContext.annotation;
        const { annotationUID } = annotation;
        const { viewport } = enabledElement;
        const { worldToCanvas } = viewport;
        const polylineCanvasPoints = this.getPolylinePoints(annotation).map((point) => worldToCanvas(point));
        const { lineWidth, lineDash, color, fillColor, fillOpacity } = annotationStyle;
        (0, drawingSvg_1.drawPolyline)(svgDrawingHelper, annotationUID, 'contourPolyline', polylineCanvasPoints, {
            color,
            lineDash,
            lineWidth: Math.max(0.1, lineWidth),
            fillColor: fillColor,
            fillOpacity,
        });
        return true;
    }
}
exports.default = ContourBaseTool;
exports.ContourBaseTool = ContourBaseTool;
//# sourceMappingURL=ContourBaseTool.js.map