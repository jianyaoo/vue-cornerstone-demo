{"ast":null,"code":"import { mat4, vec4, vec3, quat } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport { r as radiansFromDegrees, k as add, j as cross } from '../../Common/Core/Math/index.js';\nconst {\n  vtkDebugMacro\n} = macro;\n\n/* eslint-disable new-cap */\n\n/*\n * Convenience function to access elements of a gl-matrix.  If it turns\n * out I have rows and columns swapped everywhere, then I'll just change\n * the order of 'row' and 'col' parameters in this function\n */\n// function getMatrixElement(matrix, row, col) {\n//   const idx = (row * 4) + col;\n//   return matrix[idx];\n// }\n\n// ----------------------------------------------------------------------------\n// vtkCamera methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCamera(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCamera');\n\n  // Set up private variables and methods\n  const origin = new Float64Array(3);\n  const dopbasis = new Float64Array([0.0, 0.0, -1.0]);\n  const upbasis = new Float64Array([0.0, 1.0, 0.0]);\n  const tmpMatrix = mat4.identity(new Float64Array(16));\n  const tmpMatrix2 = mat4.identity(new Float64Array(16));\n  const tmpvec1 = new Float64Array(3);\n  const tmpvec2 = new Float64Array(3);\n  const tmpvec3 = new Float64Array(3);\n  const rotateMatrix = mat4.identity(new Float64Array(16));\n  const trans = mat4.identity(new Float64Array(16));\n  const newPosition = new Float64Array(3);\n  const newFocalPoint = new Float64Array(3);\n\n  // Internal Functions that don't need to be public\n  function computeViewPlaneNormal() {\n    // VPN is -DOP\n    model.viewPlaneNormal[0] = -model.directionOfProjection[0];\n    model.viewPlaneNormal[1] = -model.directionOfProjection[1];\n    model.viewPlaneNormal[2] = -model.directionOfProjection[2];\n  }\n  publicAPI.orthogonalizeViewUp = () => {\n    const vt = publicAPI.getViewMatrix();\n    model.viewUp[0] = vt[4];\n    model.viewUp[1] = vt[5];\n    model.viewUp[2] = vt[6];\n    publicAPI.modified();\n  };\n  publicAPI.setPosition = (x, y, z) => {\n    if (x === model.position[0] && y === model.position[1] && z === model.position[2]) {\n      return;\n    }\n    model.position[0] = x;\n    model.position[1] = y;\n    model.position[2] = z;\n\n    // recompute the focal distance\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n  publicAPI.setFocalPoint = (x, y, z) => {\n    if (x === model.focalPoint[0] && y === model.focalPoint[1] && z === model.focalPoint[2]) {\n      return;\n    }\n    model.focalPoint[0] = x;\n    model.focalPoint[1] = y;\n    model.focalPoint[2] = z;\n\n    // recompute the focal distance\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n  publicAPI.setDistance = d => {\n    if (model.distance === d) {\n      return;\n    }\n    model.distance = d;\n    if (model.distance < 1e-20) {\n      model.distance = 1e-20;\n      vtkDebugMacro('Distance is set to minimum.');\n    }\n\n    // we want to keep the camera pointing in the same direction\n    const vec = model.directionOfProjection;\n\n    // recalculate FocalPoint\n    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  // This method must be called when the focal point or camera position changes\n  publicAPI.computeDistance = () => {\n    const dx = model.focalPoint[0] - model.position[0];\n    const dy = model.focalPoint[1] - model.position[1];\n    const dz = model.focalPoint[2] - model.position[2];\n    model.distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n    if (model.distance < 1e-20) {\n      model.distance = 1e-20;\n      vtkDebugMacro('Distance is set to minimum.');\n      const vec = model.directionOfProjection;\n\n      // recalculate FocalPoint\n      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    }\n    model.directionOfProjection[0] = dx / model.distance;\n    model.directionOfProjection[1] = dy / model.distance;\n    model.directionOfProjection[2] = dz / model.distance;\n    computeViewPlaneNormal();\n  };\n\n  //----------------------------------------------------------------------------\n  // Move the position of the camera along the view plane normal. Moving\n  // towards the focal point (e.g., > 1) is a dolly-in, moving away\n  // from the focal point (e.g., < 1) is a dolly-out.\n  publicAPI.dolly = amount => {\n    if (amount <= 0.0) {\n      return;\n    }\n\n    // dolly moves the camera towards the focus\n    const d = model.distance / amount;\n    publicAPI.setPosition(model.focalPoint[0] - d * model.directionOfProjection[0], model.focalPoint[1] - d * model.directionOfProjection[1], model.focalPoint[2] - d * model.directionOfProjection[2]);\n  };\n  publicAPI.roll = angle => {\n    const eye = model.position;\n    const at = model.focalPoint;\n    const up = model.viewUp;\n    const viewUpVec4 = new Float64Array([up[0], up[1], up[2], 0.0]);\n    mat4.identity(rotateMatrix);\n    const viewDir = new Float64Array([at[0] - eye[0], at[1] - eye[1], at[2] - eye[2]]);\n    mat4.rotate(rotateMatrix, rotateMatrix, radiansFromDegrees(angle), viewDir);\n    vec4.transformMat4(viewUpVec4, viewUpVec4, rotateMatrix);\n    model.viewUp[0] = viewUpVec4[0];\n    model.viewUp[1] = viewUpVec4[1];\n    model.viewUp[2] = viewUpVec4[2];\n    publicAPI.modified();\n  };\n  publicAPI.azimuth = angle => {\n    const fp = model.focalPoint;\n    mat4.identity(trans);\n\n    // translate the focal point to the origin,\n    // rotate about view up,\n    // translate back again\n    mat4.translate(trans, trans, fp);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);\n    mat4.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newPosition, model.position, trans);\n    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);\n  };\n  publicAPI.yaw = angle => {\n    const position = model.position;\n    mat4.identity(trans);\n\n    // translate the camera to the origin,\n    // rotate about axis,\n    // translate back again\n    mat4.translate(trans, trans, position);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);\n    mat4.translate(trans, trans, [-position[0], -position[1], -position[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newFocalPoint, model.focalPoint, trans);\n    publicAPI.setFocalPoint(newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]);\n  };\n  publicAPI.elevation = angle => {\n    const fp = model.focalPoint;\n\n    // get the eye / camera position from the viewMatrix\n    const vt = publicAPI.getViewMatrix();\n    const axis = [-vt[0], -vt[1], -vt[2]];\n    mat4.identity(trans);\n\n    // translate the focal point to the origin,\n    // rotate about view up,\n    // translate back again\n    mat4.translate(trans, trans, fp);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), axis);\n    mat4.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newPosition, model.position, trans);\n    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);\n  };\n  publicAPI.pitch = angle => {\n    const position = model.position;\n    const vt = publicAPI.getViewMatrix();\n    const axis = [vt[0], vt[1], vt[2]];\n    mat4.identity(trans);\n\n    // translate the camera to the origin,\n    // rotate about axis,\n    // translate back again\n    mat4.translate(trans, trans, position);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), axis);\n    mat4.translate(trans, trans, [-position[0], -position[1], -position[2]]);\n\n    // apply the transform to the focal point\n    vec3.transformMat4(newFocalPoint, model.focalPoint, trans);\n    publicAPI.setFocalPoint(...newFocalPoint);\n  };\n  publicAPI.zoom = factor => {\n    if (factor <= 0) {\n      return;\n    }\n    if (model.parallelProjection) {\n      model.parallelScale /= factor;\n    } else {\n      model.viewAngle /= factor;\n    }\n    publicAPI.modified();\n  };\n  publicAPI.translate = (x, y, z) => {\n    const offset = [x, y, z];\n    add(model.position, offset, model.position);\n    add(model.focalPoint, offset, model.focalPoint);\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n  publicAPI.applyTransform = transformMat4 => {\n    const vuOld = [...model.viewUp, 1.0];\n    const posNew = [];\n    const fpNew = [];\n    const vuNew = [];\n    vuOld[0] += model.position[0];\n    vuOld[1] += model.position[1];\n    vuOld[2] += model.position[2];\n    vec4.transformMat4(posNew, [...model.position, 1.0], transformMat4);\n    vec4.transformMat4(fpNew, [...model.focalPoint, 1.0], transformMat4);\n    vec4.transformMat4(vuNew, vuOld, transformMat4);\n    vuNew[0] -= posNew[0];\n    vuNew[1] -= posNew[1];\n    vuNew[2] -= posNew[2];\n    publicAPI.setPosition(...posNew.slice(0, 3));\n    publicAPI.setFocalPoint(...fpNew.slice(0, 3));\n    publicAPI.setViewUp(...vuNew.slice(0, 3));\n  };\n  publicAPI.getThickness = () => model.clippingRange[1] - model.clippingRange[0];\n  publicAPI.setThickness = thickness => {\n    let t = thickness;\n    if (t < 1e-20) {\n      t = 1e-20;\n      vtkDebugMacro('Thickness is set to minimum.');\n    }\n    publicAPI.setClippingRange(model.clippingRange[0], model.clippingRange[0] + t);\n  };\n  publicAPI.setThicknessFromFocalPoint = thickness => {\n    let t = thickness;\n    if (t < 1e-20) {\n      t = 1e-20;\n      vtkDebugMacro('Thickness is set to minimum.');\n    }\n    publicAPI.setClippingRange(model.distance - t / 2, model.distance + t / 2);\n  };\n\n  // Unimplemented functions\n  publicAPI.setRoll = angle => {}; // dependency on GetOrientation() and a model.ViewTransform object, see https://github.com/Kitware/VTK/blob/master/Common/Transforms/vtkTransform.cxx and https://vtk.org/doc/nightly/html/classvtkTransform.html\n  publicAPI.getRoll = () => {};\n  publicAPI.setObliqueAngles = (alpha, beta) => {};\n  publicAPI.getOrientation = () => {};\n  publicAPI.getOrientationWXYZ = () => {};\n  publicAPI.getFrustumPlanes = aspect => {\n    // Return array of 24 params (4 params for each of 6 plane equations)\n  };\n  publicAPI.getCameraLightTransformMatrix = matrix => {\n    mat4.copy(matrix, model.cameraLightTransform);\n    return matrix;\n  };\n  publicAPI.computeCameraLightTransform = () => {\n    // not sure if this is the correct transformation, based on the same funciton in VTK\n    mat4.copy(tmpMatrix, publicAPI.getViewMatrix());\n    mat4.invert(tmpMatrix, tmpMatrix);\n    mat4.fromScaling(tmpMatrix2, [model.distance, model.distance, model.distance]);\n    mat4.multiply(tmpMatrix, tmpMatrix, tmpMatrix2);\n    mat4.identity(model.cameraLightTransform);\n    mat4.translate(model.cameraLightTransform, tmpMatrix, [0.0, 0.0, -1.0]);\n  };\n  publicAPI.deepCopy = sourceCamera => {};\n  publicAPI.physicalOrientationToWorldDirection = ori => {\n    // push the x axis through the orientation quat\n    const oriq = quat.fromValues(ori[0], ori[1], ori[2], ori[3]);\n    const coriq = quat.create();\n    const qdir = quat.fromValues(0.0, 0.0, 1.0, 0.0);\n    quat.conjugate(coriq, oriq);\n\n    // rotate the z axis by the quat\n    quat.multiply(qdir, oriq, qdir);\n    quat.multiply(qdir, qdir, coriq);\n\n    // return the z axis in world coords\n    return [qdir[0], qdir[1], qdir[2]];\n  };\n  publicAPI.getPhysicalToWorldMatrix = result => {\n    publicAPI.getWorldToPhysicalMatrix(result);\n    mat4.invert(result, result);\n  };\n  publicAPI.getWorldToPhysicalMatrix = result => {\n    mat4.identity(result);\n\n    // now the physical to vtk world rotation tform\n    const physVRight = [3];\n    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);\n    result[0] = physVRight[0];\n    result[1] = physVRight[1];\n    result[2] = physVRight[2];\n    result[4] = model.physicalViewUp[0];\n    result[5] = model.physicalViewUp[1];\n    result[6] = model.physicalViewUp[2];\n    result[8] = -model.physicalViewNorth[0];\n    result[9] = -model.physicalViewNorth[1];\n    result[10] = -model.physicalViewNorth[2];\n    mat4.transpose(result, result);\n    vec3.set(tmpvec1, 1 / model.physicalScale, 1 / model.physicalScale, 1 / model.physicalScale);\n    mat4.scale(result, result, tmpvec1);\n    mat4.translate(result, result, model.physicalTranslation);\n  };\n  publicAPI.computeViewParametersFromViewMatrix = vmat => {\n    // invert to get view to world\n    mat4.invert(tmpMatrix, vmat);\n\n    // note with glmatrix operations happen in\n    // the reverse order\n    // mat.scale\n    // mat.translate\n    // will result in the translation then the scale\n    // mat.mult(a,b)\n    // results in perform the B transformation then A\n\n    // then extract the params position, orientation\n    // push 0,0,0 through to get a translation\n    vec3.transformMat4(tmpvec1, origin, tmpMatrix);\n    publicAPI.computeDistance();\n    const oldDist = model.distance;\n    publicAPI.setPosition(tmpvec1[0], tmpvec1[1], tmpvec1[2]);\n\n    // push basis vectors to get orientation\n    vec3.transformMat4(tmpvec2, dopbasis, tmpMatrix);\n    vec3.subtract(tmpvec2, tmpvec2, tmpvec1);\n    vec3.normalize(tmpvec2, tmpvec2);\n    publicAPI.setDirectionOfProjection(tmpvec2[0], tmpvec2[1], tmpvec2[2]);\n    vec3.transformMat4(tmpvec3, upbasis, tmpMatrix);\n    vec3.subtract(tmpvec3, tmpvec3, tmpvec1);\n    vec3.normalize(tmpvec3, tmpvec3);\n    publicAPI.setViewUp(tmpvec3[0], tmpvec3[1], tmpvec3[2]);\n    publicAPI.setDistance(oldDist);\n  };\n\n  // the provided matrix should include\n  // translation and orientation only\n  // mat is physical to view\n  publicAPI.computeViewParametersFromPhysicalMatrix = mat => {\n    // get the WorldToPhysicalMatrix\n    publicAPI.getWorldToPhysicalMatrix(tmpMatrix);\n\n    // first convert the physical -> view matrix to be\n    // world -> view\n    mat4.multiply(tmpMatrix, mat, tmpMatrix);\n    publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);\n  };\n  publicAPI.setViewMatrix = mat => {\n    model.viewMatrix = mat;\n    if (model.viewMatrix) {\n      mat4.copy(tmpMatrix, model.viewMatrix);\n      publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);\n      mat4.transpose(model.viewMatrix, model.viewMatrix);\n    }\n  };\n  publicAPI.getViewMatrix = () => {\n    if (model.viewMatrix) {\n      return model.viewMatrix;\n    }\n    mat4.lookAt(tmpMatrix, model.position,\n    // eye\n    model.focalPoint,\n    // at\n    model.viewUp // up\n    );\n    mat4.transpose(tmpMatrix, tmpMatrix);\n    const result = new Float64Array(16);\n    mat4.copy(result, tmpMatrix);\n    return result;\n  };\n  publicAPI.setProjectionMatrix = mat => {\n    model.projectionMatrix = mat;\n  };\n  publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {\n    const result = new Float64Array(16);\n    mat4.identity(result);\n    if (model.projectionMatrix) {\n      const scale = 1 / model.physicalScale;\n      vec3.set(tmpvec1, scale, scale, scale);\n      mat4.copy(result, model.projectionMatrix);\n      mat4.scale(result, result, tmpvec1);\n      mat4.transpose(result, result);\n      return result;\n    }\n    mat4.identity(tmpMatrix);\n\n    // FIXME: Not sure what to do about adjust z buffer here\n    // adjust Z-buffer range\n    // this->ProjectionTransform->AdjustZBuffer( -1, +1, nearz, farz );\n    const cWidth = model.clippingRange[1] - model.clippingRange[0];\n    const cRange = [model.clippingRange[0] + (nearz + 1) * cWidth / 2.0, model.clippingRange[0] + (farz + 1) * cWidth / 2.0];\n    if (model.parallelProjection) {\n      // set up a rectangular parallelipiped\n      const width = model.parallelScale * aspect;\n      const height = model.parallelScale;\n      const xmin = (model.windowCenter[0] - 1.0) * width;\n      const xmax = (model.windowCenter[0] + 1.0) * width;\n      const ymin = (model.windowCenter[1] - 1.0) * height;\n      const ymax = (model.windowCenter[1] + 1.0) * height;\n      mat4.ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);\n      mat4.transpose(tmpMatrix, tmpMatrix);\n    } else if (model.useOffAxisProjection) {\n      throw new Error('Off-Axis projection is not supported at this time');\n    } else {\n      const tmp = Math.tan(radiansFromDegrees(model.viewAngle) / 2.0);\n      let width;\n      let height;\n      if (model.useHorizontalViewAngle === true) {\n        width = model.clippingRange[0] * tmp;\n        height = model.clippingRange[0] * tmp / aspect;\n      } else {\n        width = model.clippingRange[0] * tmp * aspect;\n        height = model.clippingRange[0] * tmp;\n      }\n      const xmin = (model.windowCenter[0] - 1.0) * width;\n      const xmax = (model.windowCenter[0] + 1.0) * width;\n      const ymin = (model.windowCenter[1] - 1.0) * height;\n      const ymax = (model.windowCenter[1] + 1.0) * height;\n      const znear = cRange[0];\n      const zfar = cRange[1];\n      tmpMatrix[0] = 2.0 * znear / (xmax - xmin);\n      tmpMatrix[5] = 2.0 * znear / (ymax - ymin);\n      tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);\n      tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);\n      tmpMatrix[10] = -(znear + zfar) / (zfar - znear);\n      tmpMatrix[14] = -1.0;\n      tmpMatrix[11] = -2.0 * znear * zfar / (zfar - znear);\n      tmpMatrix[15] = 0.0;\n    }\n    mat4.copy(result, tmpMatrix);\n    return result;\n  };\n  publicAPI.getCompositeProjectionMatrix = (aspect, nearz, farz) => {\n    const vMat = publicAPI.getViewMatrix();\n    const pMat = publicAPI.getProjectionMatrix(aspect, nearz, farz);\n    // mats are transposed so the order is A then B\n    // we reuse pMat as it is a copy so we can do what we want with it\n    mat4.multiply(pMat, vMat, pMat);\n    return pMat;\n  };\n  publicAPI.setDirectionOfProjection = (x, y, z) => {\n    if (model.directionOfProjection[0] === x && model.directionOfProjection[1] === y && model.directionOfProjection[2] === z) {\n      return;\n    }\n    model.directionOfProjection[0] = x;\n    model.directionOfProjection[1] = y;\n    model.directionOfProjection[2] = z;\n    const vec = model.directionOfProjection;\n\n    // recalculate FocalPoint\n    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    computeViewPlaneNormal();\n  };\n\n  // used to handle convert js device orientation angles\n  // when you use this method the camera will adjust to the\n  // device orientation such that the physicalViewUp you set\n  // in world coordinates looks up, and the physicalViewNorth\n  // you set in world coorindates will (maybe) point north\n  //\n  // NOTE WARNING - much of the documentation out there on how\n  // orientation works is seriously wrong. Even worse the Chrome\n  // device orientation simulator is completely wrong and should\n  // never be used. OMG it is so messed up.\n  //\n  // how it seems to work on iOS is that the device orientation\n  // is specified in extrinsic angles with a alpha, beta, gamma\n  // convention with axes of Z, X, Y (the code below substitutes\n  // the physical coordinate system for these axes to get the right\n  // modified coordinate system.\n  publicAPI.setDeviceAngles = (alpha, beta, gamma, screen) => {\n    const physVRight = [3];\n    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);\n\n    // phone to physical coordinates\n    const rotmat = mat4.identity(new Float64Array(16));\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(alpha), model.physicalViewUp);\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(beta), physVRight);\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(gamma), model.physicalViewNorth);\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(-screen), model.physicalViewUp);\n    const dop = new Float64Array([-model.physicalViewUp[0], -model.physicalViewUp[1], -model.physicalViewUp[2]]);\n    const vup = new Float64Array(model.physicalViewNorth);\n    vec3.transformMat4(dop, dop, rotmat);\n    vec3.transformMat4(vup, vup, rotmat);\n    publicAPI.setDirectionOfProjection(dop[0], dop[1], dop[2]);\n    publicAPI.setViewUp(vup[0], vup[1], vup[2]);\n    publicAPI.modified();\n  };\n  publicAPI.setOrientationWXYZ = (degrees, x, y, z) => {\n    const quatMat = mat4.identity(new Float64Array(16));\n    if (degrees !== 0.0 && (x !== 0.0 || y !== 0.0 || z !== 0.0)) {\n      // convert to radians\n      const angle = radiansFromDegrees(degrees);\n      const q = quat.create();\n      quat.setAxisAngle(q, [x, y, z], angle);\n      mat4.fromQuat(quatMat, q);\n    }\n    const newdop = new Float64Array(3);\n    vec3.transformMat4(newdop, [0.0, 0.0, -1.0], quatMat);\n    const newvup = new Float64Array(3);\n    vec3.transformMat4(newvup, [0.0, 1.0, 0.0], quatMat);\n    publicAPI.setDirectionOfProjection(...newdop);\n    publicAPI.setViewUp(...newvup);\n    publicAPI.modified();\n  };\n  publicAPI.computeClippingRange = bounds => {\n    let vn = null;\n    let position = null;\n    vn = model.viewPlaneNormal;\n    position = model.position;\n    const a = -vn[0];\n    const b = -vn[1];\n    const c = -vn[2];\n    const d = -(a * position[0] + b * position[1] + c * position[2]);\n\n    // Set the max near clipping plane and the min far clipping plane\n    const range = [a * bounds[0] + b * bounds[2] + c * bounds[4] + d, 1e-18];\n\n    // Find the closest / farthest bounding box vertex\n    for (let k = 0; k < 2; k++) {\n      for (let j = 0; j < 2; j++) {\n        for (let i = 0; i < 2; i++) {\n          const dist = a * bounds[i] + b * bounds[2 + j] + c * bounds[4 + k] + d;\n          range[0] = dist < range[0] ? dist : range[0];\n          range[1] = dist > range[1] ? dist : range[1];\n        }\n      }\n    }\n    return range;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  position: [0, 0, 1],\n  focalPoint: [0, 0, 0],\n  viewUp: [0, 1, 0],\n  directionOfProjection: [0, 0, -1],\n  parallelProjection: false,\n  useHorizontalViewAngle: false,\n  viewAngle: 30,\n  parallelScale: 1,\n  clippingRange: [0.01, 1000.01],\n  windowCenter: [0, 0],\n  viewPlaneNormal: [0, 0, 1],\n  useOffAxisProjection: false,\n  screenBottomLeft: [-0.5, -0.5, -0.5],\n  screenBottomRight: [0.5, -0.5, -0.5],\n  screenTopRight: [0.5, 0.5, -0.5],\n  freezeFocalPoint: false,\n  projectionMatrix: null,\n  viewMatrix: null,\n  cameraLightTransform: mat4.create(),\n  // used for world to physical transformations\n  physicalTranslation: [0, 0, 0],\n  physicalScale: 1.0,\n  physicalViewUp: [0, 1, 0],\n  physicalViewNorth: [0, 0, -1]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['distance']);\n  macro.setGet(publicAPI, model, ['parallelProjection', 'useHorizontalViewAngle', 'viewAngle', 'parallelScale', 'useOffAxisProjection', 'freezeFocalPoint', 'physicalScale']);\n  macro.getArray(publicAPI, model, ['directionOfProjection', 'viewPlaneNormal', 'position', 'focalPoint']);\n  macro.setGetArray(publicAPI, model, ['clippingRange', 'windowCenter'], 2);\n  macro.setGetArray(publicAPI, model, ['viewUp', 'screenBottomLeft', 'screenBottomRight', 'screenTopRight', 'physicalTranslation', 'physicalViewUp', 'physicalViewNorth'], 3);\n\n  // Object methods\n  vtkCamera(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCamera');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCamera$1 = {\n  newInstance,\n  extend\n};\nexport { DEFAULT_VALUES, vtkCamera$1 as default, extend, newInstance };","map":{"version":3,"names":["mat4","vec4","vec3","quat","m","macro","r","radiansFromDegrees","k","add","j","cross","vtkDebugMacro","vtkCamera","publicAPI","model","classHierarchy","push","origin","Float64Array","dopbasis","upbasis","tmpMatrix","identity","tmpMatrix2","tmpvec1","tmpvec2","tmpvec3","rotateMatrix","trans","newPosition","newFocalPoint","computeViewPlaneNormal","viewPlaneNormal","directionOfProjection","orthogonalizeViewUp","vt","getViewMatrix","viewUp","modified","setPosition","x","y","z","position","computeDistance","setFocalPoint","focalPoint","setDistance","d","distance","vec","dx","dy","dz","Math","sqrt","dolly","amount","roll","angle","eye","at","up","viewUpVec4","viewDir","rotate","transformMat4","azimuth","fp","translate","yaw","elevation","axis","pitch","zoom","factor","parallelProjection","parallelScale","viewAngle","offset","applyTransform","vuOld","posNew","fpNew","vuNew","slice","setViewUp","getThickness","clippingRange","setThickness","thickness","t","setClippingRange","setThicknessFromFocalPoint","setRoll","getRoll","setObliqueAngles","alpha","beta","getOrientation","getOrientationWXYZ","getFrustumPlanes","aspect","getCameraLightTransformMatrix","matrix","copy","cameraLightTransform","computeCameraLightTransform","invert","fromScaling","multiply","deepCopy","sourceCamera","physicalOrientationToWorldDirection","ori","oriq","fromValues","coriq","create","qdir","conjugate","getPhysicalToWorldMatrix","result","getWorldToPhysicalMatrix","physVRight","physicalViewNorth","physicalViewUp","transpose","set","physicalScale","scale","physicalTranslation","computeViewParametersFromViewMatrix","vmat","oldDist","subtract","normalize","setDirectionOfProjection","computeViewParametersFromPhysicalMatrix","mat","setViewMatrix","viewMatrix","lookAt","setProjectionMatrix","projectionMatrix","getProjectionMatrix","nearz","farz","cWidth","cRange","width","height","xmin","windowCenter","xmax","ymin","ymax","ortho","useOffAxisProjection","Error","tmp","tan","useHorizontalViewAngle","znear","zfar","getCompositeProjectionMatrix","vMat","pMat","setDeviceAngles","gamma","screen","rotmat","dop","vup","setOrientationWXYZ","degrees","quatMat","q","setAxisAngle","fromQuat","newdop","newvup","computeClippingRange","bounds","vn","a","b","c","range","i","dist","DEFAULT_VALUES","screenBottomLeft","screenBottomRight","screenTopRight","freezeFocalPoint","extend","initialValues","arguments","length","undefined","Object","assign","obj","get","setGet","getArray","setGetArray","newInstance","vtkCamera$1","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/Core/Camera.js"],"sourcesContent":["import { mat4, vec4, vec3, quat } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport { r as radiansFromDegrees, k as add, j as cross } from '../../Common/Core/Math/index.js';\n\nconst {\n  vtkDebugMacro\n} = macro;\n\n/* eslint-disable new-cap */\n\n/*\n * Convenience function to access elements of a gl-matrix.  If it turns\n * out I have rows and columns swapped everywhere, then I'll just change\n * the order of 'row' and 'col' parameters in this function\n */\n// function getMatrixElement(matrix, row, col) {\n//   const idx = (row * 4) + col;\n//   return matrix[idx];\n// }\n\n// ----------------------------------------------------------------------------\n// vtkCamera methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCamera(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCamera');\n\n  // Set up private variables and methods\n  const origin = new Float64Array(3);\n  const dopbasis = new Float64Array([0.0, 0.0, -1.0]);\n  const upbasis = new Float64Array([0.0, 1.0, 0.0]);\n  const tmpMatrix = mat4.identity(new Float64Array(16));\n  const tmpMatrix2 = mat4.identity(new Float64Array(16));\n  const tmpvec1 = new Float64Array(3);\n  const tmpvec2 = new Float64Array(3);\n  const tmpvec3 = new Float64Array(3);\n  const rotateMatrix = mat4.identity(new Float64Array(16));\n  const trans = mat4.identity(new Float64Array(16));\n  const newPosition = new Float64Array(3);\n  const newFocalPoint = new Float64Array(3);\n\n  // Internal Functions that don't need to be public\n  function computeViewPlaneNormal() {\n    // VPN is -DOP\n    model.viewPlaneNormal[0] = -model.directionOfProjection[0];\n    model.viewPlaneNormal[1] = -model.directionOfProjection[1];\n    model.viewPlaneNormal[2] = -model.directionOfProjection[2];\n  }\n  publicAPI.orthogonalizeViewUp = () => {\n    const vt = publicAPI.getViewMatrix();\n    model.viewUp[0] = vt[4];\n    model.viewUp[1] = vt[5];\n    model.viewUp[2] = vt[6];\n    publicAPI.modified();\n  };\n  publicAPI.setPosition = (x, y, z) => {\n    if (x === model.position[0] && y === model.position[1] && z === model.position[2]) {\n      return;\n    }\n    model.position[0] = x;\n    model.position[1] = y;\n    model.position[2] = z;\n\n    // recompute the focal distance\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n  publicAPI.setFocalPoint = (x, y, z) => {\n    if (x === model.focalPoint[0] && y === model.focalPoint[1] && z === model.focalPoint[2]) {\n      return;\n    }\n    model.focalPoint[0] = x;\n    model.focalPoint[1] = y;\n    model.focalPoint[2] = z;\n\n    // recompute the focal distance\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n  publicAPI.setDistance = d => {\n    if (model.distance === d) {\n      return;\n    }\n    model.distance = d;\n    if (model.distance < 1e-20) {\n      model.distance = 1e-20;\n      vtkDebugMacro('Distance is set to minimum.');\n    }\n\n    // we want to keep the camera pointing in the same direction\n    const vec = model.directionOfProjection;\n\n    // recalculate FocalPoint\n    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  // This method must be called when the focal point or camera position changes\n  publicAPI.computeDistance = () => {\n    const dx = model.focalPoint[0] - model.position[0];\n    const dy = model.focalPoint[1] - model.position[1];\n    const dz = model.focalPoint[2] - model.position[2];\n    model.distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n    if (model.distance < 1e-20) {\n      model.distance = 1e-20;\n      vtkDebugMacro('Distance is set to minimum.');\n      const vec = model.directionOfProjection;\n\n      // recalculate FocalPoint\n      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    }\n    model.directionOfProjection[0] = dx / model.distance;\n    model.directionOfProjection[1] = dy / model.distance;\n    model.directionOfProjection[2] = dz / model.distance;\n    computeViewPlaneNormal();\n  };\n\n  //----------------------------------------------------------------------------\n  // Move the position of the camera along the view plane normal. Moving\n  // towards the focal point (e.g., > 1) is a dolly-in, moving away\n  // from the focal point (e.g., < 1) is a dolly-out.\n  publicAPI.dolly = amount => {\n    if (amount <= 0.0) {\n      return;\n    }\n\n    // dolly moves the camera towards the focus\n    const d = model.distance / amount;\n    publicAPI.setPosition(model.focalPoint[0] - d * model.directionOfProjection[0], model.focalPoint[1] - d * model.directionOfProjection[1], model.focalPoint[2] - d * model.directionOfProjection[2]);\n  };\n  publicAPI.roll = angle => {\n    const eye = model.position;\n    const at = model.focalPoint;\n    const up = model.viewUp;\n    const viewUpVec4 = new Float64Array([up[0], up[1], up[2], 0.0]);\n    mat4.identity(rotateMatrix);\n    const viewDir = new Float64Array([at[0] - eye[0], at[1] - eye[1], at[2] - eye[2]]);\n    mat4.rotate(rotateMatrix, rotateMatrix, radiansFromDegrees(angle), viewDir);\n    vec4.transformMat4(viewUpVec4, viewUpVec4, rotateMatrix);\n    model.viewUp[0] = viewUpVec4[0];\n    model.viewUp[1] = viewUpVec4[1];\n    model.viewUp[2] = viewUpVec4[2];\n    publicAPI.modified();\n  };\n  publicAPI.azimuth = angle => {\n    const fp = model.focalPoint;\n    mat4.identity(trans);\n\n    // translate the focal point to the origin,\n    // rotate about view up,\n    // translate back again\n    mat4.translate(trans, trans, fp);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);\n    mat4.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newPosition, model.position, trans);\n    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);\n  };\n  publicAPI.yaw = angle => {\n    const position = model.position;\n    mat4.identity(trans);\n\n    // translate the camera to the origin,\n    // rotate about axis,\n    // translate back again\n    mat4.translate(trans, trans, position);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);\n    mat4.translate(trans, trans, [-position[0], -position[1], -position[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newFocalPoint, model.focalPoint, trans);\n    publicAPI.setFocalPoint(newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]);\n  };\n  publicAPI.elevation = angle => {\n    const fp = model.focalPoint;\n\n    // get the eye / camera position from the viewMatrix\n    const vt = publicAPI.getViewMatrix();\n    const axis = [-vt[0], -vt[1], -vt[2]];\n    mat4.identity(trans);\n\n    // translate the focal point to the origin,\n    // rotate about view up,\n    // translate back again\n    mat4.translate(trans, trans, fp);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), axis);\n    mat4.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newPosition, model.position, trans);\n    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);\n  };\n  publicAPI.pitch = angle => {\n    const position = model.position;\n    const vt = publicAPI.getViewMatrix();\n    const axis = [vt[0], vt[1], vt[2]];\n    mat4.identity(trans);\n\n    // translate the camera to the origin,\n    // rotate about axis,\n    // translate back again\n    mat4.translate(trans, trans, position);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), axis);\n    mat4.translate(trans, trans, [-position[0], -position[1], -position[2]]);\n\n    // apply the transform to the focal point\n    vec3.transformMat4(newFocalPoint, model.focalPoint, trans);\n    publicAPI.setFocalPoint(...newFocalPoint);\n  };\n  publicAPI.zoom = factor => {\n    if (factor <= 0) {\n      return;\n    }\n    if (model.parallelProjection) {\n      model.parallelScale /= factor;\n    } else {\n      model.viewAngle /= factor;\n    }\n    publicAPI.modified();\n  };\n  publicAPI.translate = (x, y, z) => {\n    const offset = [x, y, z];\n    add(model.position, offset, model.position);\n    add(model.focalPoint, offset, model.focalPoint);\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n  publicAPI.applyTransform = transformMat4 => {\n    const vuOld = [...model.viewUp, 1.0];\n    const posNew = [];\n    const fpNew = [];\n    const vuNew = [];\n    vuOld[0] += model.position[0];\n    vuOld[1] += model.position[1];\n    vuOld[2] += model.position[2];\n    vec4.transformMat4(posNew, [...model.position, 1.0], transformMat4);\n    vec4.transformMat4(fpNew, [...model.focalPoint, 1.0], transformMat4);\n    vec4.transformMat4(vuNew, vuOld, transformMat4);\n    vuNew[0] -= posNew[0];\n    vuNew[1] -= posNew[1];\n    vuNew[2] -= posNew[2];\n    publicAPI.setPosition(...posNew.slice(0, 3));\n    publicAPI.setFocalPoint(...fpNew.slice(0, 3));\n    publicAPI.setViewUp(...vuNew.slice(0, 3));\n  };\n  publicAPI.getThickness = () => model.clippingRange[1] - model.clippingRange[0];\n  publicAPI.setThickness = thickness => {\n    let t = thickness;\n    if (t < 1e-20) {\n      t = 1e-20;\n      vtkDebugMacro('Thickness is set to minimum.');\n    }\n    publicAPI.setClippingRange(model.clippingRange[0], model.clippingRange[0] + t);\n  };\n  publicAPI.setThicknessFromFocalPoint = thickness => {\n    let t = thickness;\n    if (t < 1e-20) {\n      t = 1e-20;\n      vtkDebugMacro('Thickness is set to minimum.');\n    }\n    publicAPI.setClippingRange(model.distance - t / 2, model.distance + t / 2);\n  };\n\n  // Unimplemented functions\n  publicAPI.setRoll = angle => {}; // dependency on GetOrientation() and a model.ViewTransform object, see https://github.com/Kitware/VTK/blob/master/Common/Transforms/vtkTransform.cxx and https://vtk.org/doc/nightly/html/classvtkTransform.html\n  publicAPI.getRoll = () => {};\n  publicAPI.setObliqueAngles = (alpha, beta) => {};\n  publicAPI.getOrientation = () => {};\n  publicAPI.getOrientationWXYZ = () => {};\n  publicAPI.getFrustumPlanes = aspect => {\n    // Return array of 24 params (4 params for each of 6 plane equations)\n  };\n  publicAPI.getCameraLightTransformMatrix = matrix => {\n    mat4.copy(matrix, model.cameraLightTransform);\n    return matrix;\n  };\n  publicAPI.computeCameraLightTransform = () => {\n    // not sure if this is the correct transformation, based on the same funciton in VTK\n    mat4.copy(tmpMatrix, publicAPI.getViewMatrix());\n    mat4.invert(tmpMatrix, tmpMatrix);\n    mat4.fromScaling(tmpMatrix2, [model.distance, model.distance, model.distance]);\n    mat4.multiply(tmpMatrix, tmpMatrix, tmpMatrix2);\n    mat4.identity(model.cameraLightTransform);\n    mat4.translate(model.cameraLightTransform, tmpMatrix, [0.0, 0.0, -1.0]);\n  };\n  publicAPI.deepCopy = sourceCamera => {};\n  publicAPI.physicalOrientationToWorldDirection = ori => {\n    // push the x axis through the orientation quat\n    const oriq = quat.fromValues(ori[0], ori[1], ori[2], ori[3]);\n    const coriq = quat.create();\n    const qdir = quat.fromValues(0.0, 0.0, 1.0, 0.0);\n    quat.conjugate(coriq, oriq);\n\n    // rotate the z axis by the quat\n    quat.multiply(qdir, oriq, qdir);\n    quat.multiply(qdir, qdir, coriq);\n\n    // return the z axis in world coords\n    return [qdir[0], qdir[1], qdir[2]];\n  };\n  publicAPI.getPhysicalToWorldMatrix = result => {\n    publicAPI.getWorldToPhysicalMatrix(result);\n    mat4.invert(result, result);\n  };\n  publicAPI.getWorldToPhysicalMatrix = result => {\n    mat4.identity(result);\n\n    // now the physical to vtk world rotation tform\n    const physVRight = [3];\n    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);\n    result[0] = physVRight[0];\n    result[1] = physVRight[1];\n    result[2] = physVRight[2];\n    result[4] = model.physicalViewUp[0];\n    result[5] = model.physicalViewUp[1];\n    result[6] = model.physicalViewUp[2];\n    result[8] = -model.physicalViewNorth[0];\n    result[9] = -model.physicalViewNorth[1];\n    result[10] = -model.physicalViewNorth[2];\n    mat4.transpose(result, result);\n    vec3.set(tmpvec1, 1 / model.physicalScale, 1 / model.physicalScale, 1 / model.physicalScale);\n    mat4.scale(result, result, tmpvec1);\n    mat4.translate(result, result, model.physicalTranslation);\n  };\n  publicAPI.computeViewParametersFromViewMatrix = vmat => {\n    // invert to get view to world\n    mat4.invert(tmpMatrix, vmat);\n\n    // note with glmatrix operations happen in\n    // the reverse order\n    // mat.scale\n    // mat.translate\n    // will result in the translation then the scale\n    // mat.mult(a,b)\n    // results in perform the B transformation then A\n\n    // then extract the params position, orientation\n    // push 0,0,0 through to get a translation\n    vec3.transformMat4(tmpvec1, origin, tmpMatrix);\n    publicAPI.computeDistance();\n    const oldDist = model.distance;\n    publicAPI.setPosition(tmpvec1[0], tmpvec1[1], tmpvec1[2]);\n\n    // push basis vectors to get orientation\n    vec3.transformMat4(tmpvec2, dopbasis, tmpMatrix);\n    vec3.subtract(tmpvec2, tmpvec2, tmpvec1);\n    vec3.normalize(tmpvec2, tmpvec2);\n    publicAPI.setDirectionOfProjection(tmpvec2[0], tmpvec2[1], tmpvec2[2]);\n    vec3.transformMat4(tmpvec3, upbasis, tmpMatrix);\n    vec3.subtract(tmpvec3, tmpvec3, tmpvec1);\n    vec3.normalize(tmpvec3, tmpvec3);\n    publicAPI.setViewUp(tmpvec3[0], tmpvec3[1], tmpvec3[2]);\n    publicAPI.setDistance(oldDist);\n  };\n\n  // the provided matrix should include\n  // translation and orientation only\n  // mat is physical to view\n  publicAPI.computeViewParametersFromPhysicalMatrix = mat => {\n    // get the WorldToPhysicalMatrix\n    publicAPI.getWorldToPhysicalMatrix(tmpMatrix);\n\n    // first convert the physical -> view matrix to be\n    // world -> view\n    mat4.multiply(tmpMatrix, mat, tmpMatrix);\n    publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);\n  };\n  publicAPI.setViewMatrix = mat => {\n    model.viewMatrix = mat;\n    if (model.viewMatrix) {\n      mat4.copy(tmpMatrix, model.viewMatrix);\n      publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);\n      mat4.transpose(model.viewMatrix, model.viewMatrix);\n    }\n  };\n  publicAPI.getViewMatrix = () => {\n    if (model.viewMatrix) {\n      return model.viewMatrix;\n    }\n    mat4.lookAt(tmpMatrix, model.position,\n    // eye\n    model.focalPoint,\n    // at\n    model.viewUp // up\n    );\n\n    mat4.transpose(tmpMatrix, tmpMatrix);\n    const result = new Float64Array(16);\n    mat4.copy(result, tmpMatrix);\n    return result;\n  };\n  publicAPI.setProjectionMatrix = mat => {\n    model.projectionMatrix = mat;\n  };\n  publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {\n    const result = new Float64Array(16);\n    mat4.identity(result);\n    if (model.projectionMatrix) {\n      const scale = 1 / model.physicalScale;\n      vec3.set(tmpvec1, scale, scale, scale);\n      mat4.copy(result, model.projectionMatrix);\n      mat4.scale(result, result, tmpvec1);\n      mat4.transpose(result, result);\n      return result;\n    }\n    mat4.identity(tmpMatrix);\n\n    // FIXME: Not sure what to do about adjust z buffer here\n    // adjust Z-buffer range\n    // this->ProjectionTransform->AdjustZBuffer( -1, +1, nearz, farz );\n    const cWidth = model.clippingRange[1] - model.clippingRange[0];\n    const cRange = [model.clippingRange[0] + (nearz + 1) * cWidth / 2.0, model.clippingRange[0] + (farz + 1) * cWidth / 2.0];\n    if (model.parallelProjection) {\n      // set up a rectangular parallelipiped\n      const width = model.parallelScale * aspect;\n      const height = model.parallelScale;\n      const xmin = (model.windowCenter[0] - 1.0) * width;\n      const xmax = (model.windowCenter[0] + 1.0) * width;\n      const ymin = (model.windowCenter[1] - 1.0) * height;\n      const ymax = (model.windowCenter[1] + 1.0) * height;\n      mat4.ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);\n      mat4.transpose(tmpMatrix, tmpMatrix);\n    } else if (model.useOffAxisProjection) {\n      throw new Error('Off-Axis projection is not supported at this time');\n    } else {\n      const tmp = Math.tan(radiansFromDegrees(model.viewAngle) / 2.0);\n      let width;\n      let height;\n      if (model.useHorizontalViewAngle === true) {\n        width = model.clippingRange[0] * tmp;\n        height = model.clippingRange[0] * tmp / aspect;\n      } else {\n        width = model.clippingRange[0] * tmp * aspect;\n        height = model.clippingRange[0] * tmp;\n      }\n      const xmin = (model.windowCenter[0] - 1.0) * width;\n      const xmax = (model.windowCenter[0] + 1.0) * width;\n      const ymin = (model.windowCenter[1] - 1.0) * height;\n      const ymax = (model.windowCenter[1] + 1.0) * height;\n      const znear = cRange[0];\n      const zfar = cRange[1];\n      tmpMatrix[0] = 2.0 * znear / (xmax - xmin);\n      tmpMatrix[5] = 2.0 * znear / (ymax - ymin);\n      tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);\n      tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);\n      tmpMatrix[10] = -(znear + zfar) / (zfar - znear);\n      tmpMatrix[14] = -1.0;\n      tmpMatrix[11] = -2.0 * znear * zfar / (zfar - znear);\n      tmpMatrix[15] = 0.0;\n    }\n    mat4.copy(result, tmpMatrix);\n    return result;\n  };\n  publicAPI.getCompositeProjectionMatrix = (aspect, nearz, farz) => {\n    const vMat = publicAPI.getViewMatrix();\n    const pMat = publicAPI.getProjectionMatrix(aspect, nearz, farz);\n    // mats are transposed so the order is A then B\n    // we reuse pMat as it is a copy so we can do what we want with it\n    mat4.multiply(pMat, vMat, pMat);\n    return pMat;\n  };\n  publicAPI.setDirectionOfProjection = (x, y, z) => {\n    if (model.directionOfProjection[0] === x && model.directionOfProjection[1] === y && model.directionOfProjection[2] === z) {\n      return;\n    }\n    model.directionOfProjection[0] = x;\n    model.directionOfProjection[1] = y;\n    model.directionOfProjection[2] = z;\n    const vec = model.directionOfProjection;\n\n    // recalculate FocalPoint\n    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    computeViewPlaneNormal();\n  };\n\n  // used to handle convert js device orientation angles\n  // when you use this method the camera will adjust to the\n  // device orientation such that the physicalViewUp you set\n  // in world coordinates looks up, and the physicalViewNorth\n  // you set in world coorindates will (maybe) point north\n  //\n  // NOTE WARNING - much of the documentation out there on how\n  // orientation works is seriously wrong. Even worse the Chrome\n  // device orientation simulator is completely wrong and should\n  // never be used. OMG it is so messed up.\n  //\n  // how it seems to work on iOS is that the device orientation\n  // is specified in extrinsic angles with a alpha, beta, gamma\n  // convention with axes of Z, X, Y (the code below substitutes\n  // the physical coordinate system for these axes to get the right\n  // modified coordinate system.\n  publicAPI.setDeviceAngles = (alpha, beta, gamma, screen) => {\n    const physVRight = [3];\n    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);\n\n    // phone to physical coordinates\n    const rotmat = mat4.identity(new Float64Array(16));\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(alpha), model.physicalViewUp);\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(beta), physVRight);\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(gamma), model.physicalViewNorth);\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(-screen), model.physicalViewUp);\n    const dop = new Float64Array([-model.physicalViewUp[0], -model.physicalViewUp[1], -model.physicalViewUp[2]]);\n    const vup = new Float64Array(model.physicalViewNorth);\n    vec3.transformMat4(dop, dop, rotmat);\n    vec3.transformMat4(vup, vup, rotmat);\n    publicAPI.setDirectionOfProjection(dop[0], dop[1], dop[2]);\n    publicAPI.setViewUp(vup[0], vup[1], vup[2]);\n    publicAPI.modified();\n  };\n  publicAPI.setOrientationWXYZ = (degrees, x, y, z) => {\n    const quatMat = mat4.identity(new Float64Array(16));\n    if (degrees !== 0.0 && (x !== 0.0 || y !== 0.0 || z !== 0.0)) {\n      // convert to radians\n      const angle = radiansFromDegrees(degrees);\n      const q = quat.create();\n      quat.setAxisAngle(q, [x, y, z], angle);\n      mat4.fromQuat(quatMat, q);\n    }\n    const newdop = new Float64Array(3);\n    vec3.transformMat4(newdop, [0.0, 0.0, -1.0], quatMat);\n    const newvup = new Float64Array(3);\n    vec3.transformMat4(newvup, [0.0, 1.0, 0.0], quatMat);\n    publicAPI.setDirectionOfProjection(...newdop);\n    publicAPI.setViewUp(...newvup);\n    publicAPI.modified();\n  };\n  publicAPI.computeClippingRange = bounds => {\n    let vn = null;\n    let position = null;\n    vn = model.viewPlaneNormal;\n    position = model.position;\n    const a = -vn[0];\n    const b = -vn[1];\n    const c = -vn[2];\n    const d = -(a * position[0] + b * position[1] + c * position[2]);\n\n    // Set the max near clipping plane and the min far clipping plane\n    const range = [a * bounds[0] + b * bounds[2] + c * bounds[4] + d, 1e-18];\n\n    // Find the closest / farthest bounding box vertex\n    for (let k = 0; k < 2; k++) {\n      for (let j = 0; j < 2; j++) {\n        for (let i = 0; i < 2; i++) {\n          const dist = a * bounds[i] + b * bounds[2 + j] + c * bounds[4 + k] + d;\n          range[0] = dist < range[0] ? dist : range[0];\n          range[1] = dist > range[1] ? dist : range[1];\n        }\n      }\n    }\n    return range;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  position: [0, 0, 1],\n  focalPoint: [0, 0, 0],\n  viewUp: [0, 1, 0],\n  directionOfProjection: [0, 0, -1],\n  parallelProjection: false,\n  useHorizontalViewAngle: false,\n  viewAngle: 30,\n  parallelScale: 1,\n  clippingRange: [0.01, 1000.01],\n  windowCenter: [0, 0],\n  viewPlaneNormal: [0, 0, 1],\n  useOffAxisProjection: false,\n  screenBottomLeft: [-0.5, -0.5, -0.5],\n  screenBottomRight: [0.5, -0.5, -0.5],\n  screenTopRight: [0.5, 0.5, -0.5],\n  freezeFocalPoint: false,\n  projectionMatrix: null,\n  viewMatrix: null,\n  cameraLightTransform: mat4.create(),\n  // used for world to physical transformations\n  physicalTranslation: [0, 0, 0],\n  physicalScale: 1.0,\n  physicalViewUp: [0, 1, 0],\n  physicalViewNorth: [0, 0, -1]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['distance']);\n  macro.setGet(publicAPI, model, ['parallelProjection', 'useHorizontalViewAngle', 'viewAngle', 'parallelScale', 'useOffAxisProjection', 'freezeFocalPoint', 'physicalScale']);\n  macro.getArray(publicAPI, model, ['directionOfProjection', 'viewPlaneNormal', 'position', 'focalPoint']);\n  macro.setGetArray(publicAPI, model, ['clippingRange', 'windowCenter'], 2);\n  macro.setGetArray(publicAPI, model, ['viewUp', 'screenBottomLeft', 'screenBottomRight', 'screenTopRight', 'physicalTranslation', 'physicalViewUp', 'physicalViewNorth'], 3);\n\n  // Object methods\n  vtkCamera(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCamera');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCamera$1 = {\n  newInstance,\n  extend\n};\n\nexport { DEFAULT_VALUES, vtkCamera$1 as default, extend, newInstance };\n"],"mappings":"AAAA,SAASA,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAEC,IAAI,QAAQ,WAAW;AAClD,SAASC,CAAC,IAAIC,KAAK,QAAQ,kBAAkB;AAC7C,SAASC,CAAC,IAAIC,kBAAkB,EAAEC,CAAC,IAAIC,GAAG,EAAEC,CAAC,IAAIC,KAAK,QAAQ,iCAAiC;AAE/F,MAAM;EACJC;AACF,CAAC,GAAGP,KAAK;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,SAASQ,SAASA,CAACC,SAAS,EAAEC,KAAK,EAAE;EACnC;EACAA,KAAK,CAACC,cAAc,CAACC,IAAI,CAAC,WAAW,CAAC;;EAEtC;EACA,MAAMC,MAAM,GAAG,IAAIC,YAAY,CAAC,CAAC,CAAC;EAClC,MAAMC,QAAQ,GAAG,IAAID,YAAY,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC;EACnD,MAAME,OAAO,GAAG,IAAIF,YAAY,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;EACjD,MAAMG,SAAS,GAAGtB,IAAI,CAACuB,QAAQ,CAAC,IAAIJ,YAAY,CAAC,EAAE,CAAC,CAAC;EACrD,MAAMK,UAAU,GAAGxB,IAAI,CAACuB,QAAQ,CAAC,IAAIJ,YAAY,CAAC,EAAE,CAAC,CAAC;EACtD,MAAMM,OAAO,GAAG,IAAIN,YAAY,CAAC,CAAC,CAAC;EACnC,MAAMO,OAAO,GAAG,IAAIP,YAAY,CAAC,CAAC,CAAC;EACnC,MAAMQ,OAAO,GAAG,IAAIR,YAAY,CAAC,CAAC,CAAC;EACnC,MAAMS,YAAY,GAAG5B,IAAI,CAACuB,QAAQ,CAAC,IAAIJ,YAAY,CAAC,EAAE,CAAC,CAAC;EACxD,MAAMU,KAAK,GAAG7B,IAAI,CAACuB,QAAQ,CAAC,IAAIJ,YAAY,CAAC,EAAE,CAAC,CAAC;EACjD,MAAMW,WAAW,GAAG,IAAIX,YAAY,CAAC,CAAC,CAAC;EACvC,MAAMY,aAAa,GAAG,IAAIZ,YAAY,CAAC,CAAC,CAAC;;EAEzC;EACA,SAASa,sBAAsBA,CAAA,EAAG;IAChC;IACAjB,KAAK,CAACkB,eAAe,CAAC,CAAC,CAAC,GAAG,CAAClB,KAAK,CAACmB,qBAAqB,CAAC,CAAC,CAAC;IAC1DnB,KAAK,CAACkB,eAAe,CAAC,CAAC,CAAC,GAAG,CAAClB,KAAK,CAACmB,qBAAqB,CAAC,CAAC,CAAC;IAC1DnB,KAAK,CAACkB,eAAe,CAAC,CAAC,CAAC,GAAG,CAAClB,KAAK,CAACmB,qBAAqB,CAAC,CAAC,CAAC;EAC5D;EACApB,SAAS,CAACqB,mBAAmB,GAAG,MAAM;IACpC,MAAMC,EAAE,GAAGtB,SAAS,CAACuB,aAAa,CAAC,CAAC;IACpCtB,KAAK,CAACuB,MAAM,CAAC,CAAC,CAAC,GAAGF,EAAE,CAAC,CAAC,CAAC;IACvBrB,KAAK,CAACuB,MAAM,CAAC,CAAC,CAAC,GAAGF,EAAE,CAAC,CAAC,CAAC;IACvBrB,KAAK,CAACuB,MAAM,CAAC,CAAC,CAAC,GAAGF,EAAE,CAAC,CAAC,CAAC;IACvBtB,SAAS,CAACyB,QAAQ,CAAC,CAAC;EACtB,CAAC;EACDzB,SAAS,CAAC0B,WAAW,GAAG,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,KAAK;IACnC,IAAIF,CAAC,KAAK1B,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC,IAAIF,CAAC,KAAK3B,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC,IAAID,CAAC,KAAK5B,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC,EAAE;MACjF;IACF;IACA7B,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC,GAAGH,CAAC;IACrB1B,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC,GAAGF,CAAC;IACrB3B,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC,GAAGD,CAAC;;IAErB;IACA7B,SAAS,CAAC+B,eAAe,CAAC,CAAC;IAC3B/B,SAAS,CAACyB,QAAQ,CAAC,CAAC;EACtB,CAAC;EACDzB,SAAS,CAACgC,aAAa,GAAG,CAACL,CAAC,EAAEC,CAAC,EAAEC,CAAC,KAAK;IACrC,IAAIF,CAAC,KAAK1B,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,IAAIL,CAAC,KAAK3B,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,IAAIJ,CAAC,KAAK5B,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,EAAE;MACvF;IACF;IACAhC,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,GAAGN,CAAC;IACvB1B,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,GAAGL,CAAC;IACvB3B,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,GAAGJ,CAAC;;IAEvB;IACA7B,SAAS,CAAC+B,eAAe,CAAC,CAAC;IAC3B/B,SAAS,CAACyB,QAAQ,CAAC,CAAC;EACtB,CAAC;EACDzB,SAAS,CAACkC,WAAW,GAAGC,CAAC,IAAI;IAC3B,IAAIlC,KAAK,CAACmC,QAAQ,KAAKD,CAAC,EAAE;MACxB;IACF;IACAlC,KAAK,CAACmC,QAAQ,GAAGD,CAAC;IAClB,IAAIlC,KAAK,CAACmC,QAAQ,GAAG,KAAK,EAAE;MAC1BnC,KAAK,CAACmC,QAAQ,GAAG,KAAK;MACtBtC,aAAa,CAAC,6BAA6B,CAAC;IAC9C;;IAEA;IACA,MAAMuC,GAAG,GAAGpC,KAAK,CAACmB,qBAAqB;;IAEvC;IACAnB,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,GAAGhC,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC,GAAGO,GAAG,CAAC,CAAC,CAAC,GAAGpC,KAAK,CAACmC,QAAQ;IACjEnC,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,GAAGhC,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC,GAAGO,GAAG,CAAC,CAAC,CAAC,GAAGpC,KAAK,CAACmC,QAAQ;IACjEnC,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,GAAGhC,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC,GAAGO,GAAG,CAAC,CAAC,CAAC,GAAGpC,KAAK,CAACmC,QAAQ;IACjEpC,SAAS,CAACyB,QAAQ,CAAC,CAAC;EACtB,CAAC;;EAED;EACA;EACAzB,SAAS,CAAC+B,eAAe,GAAG,MAAM;IAChC,MAAMO,EAAE,GAAGrC,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,GAAGhC,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC;IAClD,MAAMS,EAAE,GAAGtC,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,GAAGhC,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC;IAClD,MAAMU,EAAE,GAAGvC,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,GAAGhC,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC;IAClD7B,KAAK,CAACmC,QAAQ,GAAGK,IAAI,CAACC,IAAI,CAACJ,EAAE,GAAGA,EAAE,GAAGC,EAAE,GAAGA,EAAE,GAAGC,EAAE,GAAGA,EAAE,CAAC;IACvD,IAAIvC,KAAK,CAACmC,QAAQ,GAAG,KAAK,EAAE;MAC1BnC,KAAK,CAACmC,QAAQ,GAAG,KAAK;MACtBtC,aAAa,CAAC,6BAA6B,CAAC;MAC5C,MAAMuC,GAAG,GAAGpC,KAAK,CAACmB,qBAAqB;;MAEvC;MACAnB,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,GAAGhC,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC,GAAGO,GAAG,CAAC,CAAC,CAAC,GAAGpC,KAAK,CAACmC,QAAQ;MACjEnC,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,GAAGhC,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC,GAAGO,GAAG,CAAC,CAAC,CAAC,GAAGpC,KAAK,CAACmC,QAAQ;MACjEnC,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,GAAGhC,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC,GAAGO,GAAG,CAAC,CAAC,CAAC,GAAGpC,KAAK,CAACmC,QAAQ;IACnE;IACAnC,KAAK,CAACmB,qBAAqB,CAAC,CAAC,CAAC,GAAGkB,EAAE,GAAGrC,KAAK,CAACmC,QAAQ;IACpDnC,KAAK,CAACmB,qBAAqB,CAAC,CAAC,CAAC,GAAGmB,EAAE,GAAGtC,KAAK,CAACmC,QAAQ;IACpDnC,KAAK,CAACmB,qBAAqB,CAAC,CAAC,CAAC,GAAGoB,EAAE,GAAGvC,KAAK,CAACmC,QAAQ;IACpDlB,sBAAsB,CAAC,CAAC;EAC1B,CAAC;;EAED;EACA;EACA;EACA;EACAlB,SAAS,CAAC2C,KAAK,GAAGC,MAAM,IAAI;IAC1B,IAAIA,MAAM,IAAI,GAAG,EAAE;MACjB;IACF;;IAEA;IACA,MAAMT,CAAC,GAAGlC,KAAK,CAACmC,QAAQ,GAAGQ,MAAM;IACjC5C,SAAS,CAAC0B,WAAW,CAACzB,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,GAAGE,CAAC,GAAGlC,KAAK,CAACmB,qBAAqB,CAAC,CAAC,CAAC,EAAEnB,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,GAAGE,CAAC,GAAGlC,KAAK,CAACmB,qBAAqB,CAAC,CAAC,CAAC,EAAEnB,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,GAAGE,CAAC,GAAGlC,KAAK,CAACmB,qBAAqB,CAAC,CAAC,CAAC,CAAC;EACrM,CAAC;EACDpB,SAAS,CAAC6C,IAAI,GAAGC,KAAK,IAAI;IACxB,MAAMC,GAAG,GAAG9C,KAAK,CAAC6B,QAAQ;IAC1B,MAAMkB,EAAE,GAAG/C,KAAK,CAACgC,UAAU;IAC3B,MAAMgB,EAAE,GAAGhD,KAAK,CAACuB,MAAM;IACvB,MAAM0B,UAAU,GAAG,IAAI7C,YAAY,CAAC,CAAC4C,EAAE,CAAC,CAAC,CAAC,EAAEA,EAAE,CAAC,CAAC,CAAC,EAAEA,EAAE,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;IAC/D/D,IAAI,CAACuB,QAAQ,CAACK,YAAY,CAAC;IAC3B,MAAMqC,OAAO,GAAG,IAAI9C,YAAY,CAAC,CAAC2C,EAAE,CAAC,CAAC,CAAC,GAAGD,GAAG,CAAC,CAAC,CAAC,EAAEC,EAAE,CAAC,CAAC,CAAC,GAAGD,GAAG,CAAC,CAAC,CAAC,EAAEC,EAAE,CAAC,CAAC,CAAC,GAAGD,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IAClF7D,IAAI,CAACkE,MAAM,CAACtC,YAAY,EAAEA,YAAY,EAAErB,kBAAkB,CAACqD,KAAK,CAAC,EAAEK,OAAO,CAAC;IAC3EhE,IAAI,CAACkE,aAAa,CAACH,UAAU,EAAEA,UAAU,EAAEpC,YAAY,CAAC;IACxDb,KAAK,CAACuB,MAAM,CAAC,CAAC,CAAC,GAAG0B,UAAU,CAAC,CAAC,CAAC;IAC/BjD,KAAK,CAACuB,MAAM,CAAC,CAAC,CAAC,GAAG0B,UAAU,CAAC,CAAC,CAAC;IAC/BjD,KAAK,CAACuB,MAAM,CAAC,CAAC,CAAC,GAAG0B,UAAU,CAAC,CAAC,CAAC;IAC/BlD,SAAS,CAACyB,QAAQ,CAAC,CAAC;EACtB,CAAC;EACDzB,SAAS,CAACsD,OAAO,GAAGR,KAAK,IAAI;IAC3B,MAAMS,EAAE,GAAGtD,KAAK,CAACgC,UAAU;IAC3B/C,IAAI,CAACuB,QAAQ,CAACM,KAAK,CAAC;;IAEpB;IACA;IACA;IACA7B,IAAI,CAACsE,SAAS,CAACzC,KAAK,EAAEA,KAAK,EAAEwC,EAAE,CAAC;IAChCrE,IAAI,CAACkE,MAAM,CAACrC,KAAK,EAAEA,KAAK,EAAEtB,kBAAkB,CAACqD,KAAK,CAAC,EAAE7C,KAAK,CAACuB,MAAM,CAAC;IAClEtC,IAAI,CAACsE,SAAS,CAACzC,KAAK,EAAEA,KAAK,EAAE,CAAC,CAACwC,EAAE,CAAC,CAAC,CAAC,EAAE,CAACA,EAAE,CAAC,CAAC,CAAC,EAAE,CAACA,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;;IAEtD;IACAnE,IAAI,CAACiE,aAAa,CAACrC,WAAW,EAAEf,KAAK,CAAC6B,QAAQ,EAAEf,KAAK,CAAC;IACtDf,SAAS,CAAC0B,WAAW,CAACV,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC;EACvE,CAAC;EACDhB,SAAS,CAACyD,GAAG,GAAGX,KAAK,IAAI;IACvB,MAAMhB,QAAQ,GAAG7B,KAAK,CAAC6B,QAAQ;IAC/B5C,IAAI,CAACuB,QAAQ,CAACM,KAAK,CAAC;;IAEpB;IACA;IACA;IACA7B,IAAI,CAACsE,SAAS,CAACzC,KAAK,EAAEA,KAAK,EAAEe,QAAQ,CAAC;IACtC5C,IAAI,CAACkE,MAAM,CAACrC,KAAK,EAAEA,KAAK,EAAEtB,kBAAkB,CAACqD,KAAK,CAAC,EAAE7C,KAAK,CAACuB,MAAM,CAAC;IAClEtC,IAAI,CAACsE,SAAS,CAACzC,KAAK,EAAEA,KAAK,EAAE,CAAC,CAACe,QAAQ,CAAC,CAAC,CAAC,EAAE,CAACA,QAAQ,CAAC,CAAC,CAAC,EAAE,CAACA,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;;IAExE;IACA1C,IAAI,CAACiE,aAAa,CAACpC,aAAa,EAAEhB,KAAK,CAACgC,UAAU,EAAElB,KAAK,CAAC;IAC1Df,SAAS,CAACgC,aAAa,CAACf,aAAa,CAAC,CAAC,CAAC,EAAEA,aAAa,CAAC,CAAC,CAAC,EAAEA,aAAa,CAAC,CAAC,CAAC,CAAC;EAC/E,CAAC;EACDjB,SAAS,CAAC0D,SAAS,GAAGZ,KAAK,IAAI;IAC7B,MAAMS,EAAE,GAAGtD,KAAK,CAACgC,UAAU;;IAE3B;IACA,MAAMX,EAAE,GAAGtB,SAAS,CAACuB,aAAa,CAAC,CAAC;IACpC,MAAMoC,IAAI,GAAG,CAAC,CAACrC,EAAE,CAAC,CAAC,CAAC,EAAE,CAACA,EAAE,CAAC,CAAC,CAAC,EAAE,CAACA,EAAE,CAAC,CAAC,CAAC,CAAC;IACrCpC,IAAI,CAACuB,QAAQ,CAACM,KAAK,CAAC;;IAEpB;IACA;IACA;IACA7B,IAAI,CAACsE,SAAS,CAACzC,KAAK,EAAEA,KAAK,EAAEwC,EAAE,CAAC;IAChCrE,IAAI,CAACkE,MAAM,CAACrC,KAAK,EAAEA,KAAK,EAAEtB,kBAAkB,CAACqD,KAAK,CAAC,EAAEa,IAAI,CAAC;IAC1DzE,IAAI,CAACsE,SAAS,CAACzC,KAAK,EAAEA,KAAK,EAAE,CAAC,CAACwC,EAAE,CAAC,CAAC,CAAC,EAAE,CAACA,EAAE,CAAC,CAAC,CAAC,EAAE,CAACA,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;;IAEtD;IACAnE,IAAI,CAACiE,aAAa,CAACrC,WAAW,EAAEf,KAAK,CAAC6B,QAAQ,EAAEf,KAAK,CAAC;IACtDf,SAAS,CAAC0B,WAAW,CAACV,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC;EACvE,CAAC;EACDhB,SAAS,CAAC4D,KAAK,GAAGd,KAAK,IAAI;IACzB,MAAMhB,QAAQ,GAAG7B,KAAK,CAAC6B,QAAQ;IAC/B,MAAMR,EAAE,GAAGtB,SAAS,CAACuB,aAAa,CAAC,CAAC;IACpC,MAAMoC,IAAI,GAAG,CAACrC,EAAE,CAAC,CAAC,CAAC,EAAEA,EAAE,CAAC,CAAC,CAAC,EAAEA,EAAE,CAAC,CAAC,CAAC,CAAC;IAClCpC,IAAI,CAACuB,QAAQ,CAACM,KAAK,CAAC;;IAEpB;IACA;IACA;IACA7B,IAAI,CAACsE,SAAS,CAACzC,KAAK,EAAEA,KAAK,EAAEe,QAAQ,CAAC;IACtC5C,IAAI,CAACkE,MAAM,CAACrC,KAAK,EAAEA,KAAK,EAAEtB,kBAAkB,CAACqD,KAAK,CAAC,EAAEa,IAAI,CAAC;IAC1DzE,IAAI,CAACsE,SAAS,CAACzC,KAAK,EAAEA,KAAK,EAAE,CAAC,CAACe,QAAQ,CAAC,CAAC,CAAC,EAAE,CAACA,QAAQ,CAAC,CAAC,CAAC,EAAE,CAACA,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;;IAExE;IACA1C,IAAI,CAACiE,aAAa,CAACpC,aAAa,EAAEhB,KAAK,CAACgC,UAAU,EAAElB,KAAK,CAAC;IAC1Df,SAAS,CAACgC,aAAa,CAAC,GAAGf,aAAa,CAAC;EAC3C,CAAC;EACDjB,SAAS,CAAC6D,IAAI,GAAGC,MAAM,IAAI;IACzB,IAAIA,MAAM,IAAI,CAAC,EAAE;MACf;IACF;IACA,IAAI7D,KAAK,CAAC8D,kBAAkB,EAAE;MAC5B9D,KAAK,CAAC+D,aAAa,IAAIF,MAAM;IAC/B,CAAC,MAAM;MACL7D,KAAK,CAACgE,SAAS,IAAIH,MAAM;IAC3B;IACA9D,SAAS,CAACyB,QAAQ,CAAC,CAAC;EACtB,CAAC;EACDzB,SAAS,CAACwD,SAAS,GAAG,CAAC7B,CAAC,EAAEC,CAAC,EAAEC,CAAC,KAAK;IACjC,MAAMqC,MAAM,GAAG,CAACvC,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;IACxBlC,GAAG,CAACM,KAAK,CAAC6B,QAAQ,EAAEoC,MAAM,EAAEjE,KAAK,CAAC6B,QAAQ,CAAC;IAC3CnC,GAAG,CAACM,KAAK,CAACgC,UAAU,EAAEiC,MAAM,EAAEjE,KAAK,CAACgC,UAAU,CAAC;IAC/CjC,SAAS,CAAC+B,eAAe,CAAC,CAAC;IAC3B/B,SAAS,CAACyB,QAAQ,CAAC,CAAC;EACtB,CAAC;EACDzB,SAAS,CAACmE,cAAc,GAAGd,aAAa,IAAI;IAC1C,MAAMe,KAAK,GAAG,CAAC,GAAGnE,KAAK,CAACuB,MAAM,EAAE,GAAG,CAAC;IACpC,MAAM6C,MAAM,GAAG,EAAE;IACjB,MAAMC,KAAK,GAAG,EAAE;IAChB,MAAMC,KAAK,GAAG,EAAE;IAChBH,KAAK,CAAC,CAAC,CAAC,IAAInE,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC;IAC7BsC,KAAK,CAAC,CAAC,CAAC,IAAInE,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC;IAC7BsC,KAAK,CAAC,CAAC,CAAC,IAAInE,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC;IAC7B3C,IAAI,CAACkE,aAAa,CAACgB,MAAM,EAAE,CAAC,GAAGpE,KAAK,CAAC6B,QAAQ,EAAE,GAAG,CAAC,EAAEuB,aAAa,CAAC;IACnElE,IAAI,CAACkE,aAAa,CAACiB,KAAK,EAAE,CAAC,GAAGrE,KAAK,CAACgC,UAAU,EAAE,GAAG,CAAC,EAAEoB,aAAa,CAAC;IACpElE,IAAI,CAACkE,aAAa,CAACkB,KAAK,EAAEH,KAAK,EAAEf,aAAa,CAAC;IAC/CkB,KAAK,CAAC,CAAC,CAAC,IAAIF,MAAM,CAAC,CAAC,CAAC;IACrBE,KAAK,CAAC,CAAC,CAAC,IAAIF,MAAM,CAAC,CAAC,CAAC;IACrBE,KAAK,CAAC,CAAC,CAAC,IAAIF,MAAM,CAAC,CAAC,CAAC;IACrBrE,SAAS,CAAC0B,WAAW,CAAC,GAAG2C,MAAM,CAACG,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC5CxE,SAAS,CAACgC,aAAa,CAAC,GAAGsC,KAAK,CAACE,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC7CxE,SAAS,CAACyE,SAAS,CAAC,GAAGF,KAAK,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAC3C,CAAC;EACDxE,SAAS,CAAC0E,YAAY,GAAG,MAAMzE,KAAK,CAAC0E,aAAa,CAAC,CAAC,CAAC,GAAG1E,KAAK,CAAC0E,aAAa,CAAC,CAAC,CAAC;EAC9E3E,SAAS,CAAC4E,YAAY,GAAGC,SAAS,IAAI;IACpC,IAAIC,CAAC,GAAGD,SAAS;IACjB,IAAIC,CAAC,GAAG,KAAK,EAAE;MACbA,CAAC,GAAG,KAAK;MACThF,aAAa,CAAC,8BAA8B,CAAC;IAC/C;IACAE,SAAS,CAAC+E,gBAAgB,CAAC9E,KAAK,CAAC0E,aAAa,CAAC,CAAC,CAAC,EAAE1E,KAAK,CAAC0E,aAAa,CAAC,CAAC,CAAC,GAAGG,CAAC,CAAC;EAChF,CAAC;EACD9E,SAAS,CAACgF,0BAA0B,GAAGH,SAAS,IAAI;IAClD,IAAIC,CAAC,GAAGD,SAAS;IACjB,IAAIC,CAAC,GAAG,KAAK,EAAE;MACbA,CAAC,GAAG,KAAK;MACThF,aAAa,CAAC,8BAA8B,CAAC;IAC/C;IACAE,SAAS,CAAC+E,gBAAgB,CAAC9E,KAAK,CAACmC,QAAQ,GAAG0C,CAAC,GAAG,CAAC,EAAE7E,KAAK,CAACmC,QAAQ,GAAG0C,CAAC,GAAG,CAAC,CAAC;EAC5E,CAAC;;EAED;EACA9E,SAAS,CAACiF,OAAO,GAAGnC,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC;EACjC9C,SAAS,CAACkF,OAAO,GAAG,MAAM,CAAC,CAAC;EAC5BlF,SAAS,CAACmF,gBAAgB,GAAG,CAACC,KAAK,EAAEC,IAAI,KAAK,CAAC,CAAC;EAChDrF,SAAS,CAACsF,cAAc,GAAG,MAAM,CAAC,CAAC;EACnCtF,SAAS,CAACuF,kBAAkB,GAAG,MAAM,CAAC,CAAC;EACvCvF,SAAS,CAACwF,gBAAgB,GAAGC,MAAM,IAAI;IACrC;EAAA,CACD;EACDzF,SAAS,CAAC0F,6BAA6B,GAAGC,MAAM,IAAI;IAClDzG,IAAI,CAAC0G,IAAI,CAACD,MAAM,EAAE1F,KAAK,CAAC4F,oBAAoB,CAAC;IAC7C,OAAOF,MAAM;EACf,CAAC;EACD3F,SAAS,CAAC8F,2BAA2B,GAAG,MAAM;IAC5C;IACA5G,IAAI,CAAC0G,IAAI,CAACpF,SAAS,EAAER,SAAS,CAACuB,aAAa,CAAC,CAAC,CAAC;IAC/CrC,IAAI,CAAC6G,MAAM,CAACvF,SAAS,EAAEA,SAAS,CAAC;IACjCtB,IAAI,CAAC8G,WAAW,CAACtF,UAAU,EAAE,CAACT,KAAK,CAACmC,QAAQ,EAAEnC,KAAK,CAACmC,QAAQ,EAAEnC,KAAK,CAACmC,QAAQ,CAAC,CAAC;IAC9ElD,IAAI,CAAC+G,QAAQ,CAACzF,SAAS,EAAEA,SAAS,EAAEE,UAAU,CAAC;IAC/CxB,IAAI,CAACuB,QAAQ,CAACR,KAAK,CAAC4F,oBAAoB,CAAC;IACzC3G,IAAI,CAACsE,SAAS,CAACvD,KAAK,CAAC4F,oBAAoB,EAAErF,SAAS,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC;EACzE,CAAC;EACDR,SAAS,CAACkG,QAAQ,GAAGC,YAAY,IAAI,CAAC,CAAC;EACvCnG,SAAS,CAACoG,mCAAmC,GAAGC,GAAG,IAAI;IACrD;IACA,MAAMC,IAAI,GAAGjH,IAAI,CAACkH,UAAU,CAACF,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,CAAC;IAC5D,MAAMG,KAAK,GAAGnH,IAAI,CAACoH,MAAM,CAAC,CAAC;IAC3B,MAAMC,IAAI,GAAGrH,IAAI,CAACkH,UAAU,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IAChDlH,IAAI,CAACsH,SAAS,CAACH,KAAK,EAAEF,IAAI,CAAC;;IAE3B;IACAjH,IAAI,CAAC4G,QAAQ,CAACS,IAAI,EAAEJ,IAAI,EAAEI,IAAI,CAAC;IAC/BrH,IAAI,CAAC4G,QAAQ,CAACS,IAAI,EAAEA,IAAI,EAAEF,KAAK,CAAC;;IAEhC;IACA,OAAO,CAACE,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC;EACpC,CAAC;EACD1G,SAAS,CAAC4G,wBAAwB,GAAGC,MAAM,IAAI;IAC7C7G,SAAS,CAAC8G,wBAAwB,CAACD,MAAM,CAAC;IAC1C3H,IAAI,CAAC6G,MAAM,CAACc,MAAM,EAAEA,MAAM,CAAC;EAC7B,CAAC;EACD7G,SAAS,CAAC8G,wBAAwB,GAAGD,MAAM,IAAI;IAC7C3H,IAAI,CAACuB,QAAQ,CAACoG,MAAM,CAAC;;IAErB;IACA,MAAME,UAAU,GAAG,CAAC,CAAC,CAAC;IACtBlH,KAAK,CAACI,KAAK,CAAC+G,iBAAiB,EAAE/G,KAAK,CAACgH,cAAc,EAAEF,UAAU,CAAC;IAChEF,MAAM,CAAC,CAAC,CAAC,GAAGE,UAAU,CAAC,CAAC,CAAC;IACzBF,MAAM,CAAC,CAAC,CAAC,GAAGE,UAAU,CAAC,CAAC,CAAC;IACzBF,MAAM,CAAC,CAAC,CAAC,GAAGE,UAAU,CAAC,CAAC,CAAC;IACzBF,MAAM,CAAC,CAAC,CAAC,GAAG5G,KAAK,CAACgH,cAAc,CAAC,CAAC,CAAC;IACnCJ,MAAM,CAAC,CAAC,CAAC,GAAG5G,KAAK,CAACgH,cAAc,CAAC,CAAC,CAAC;IACnCJ,MAAM,CAAC,CAAC,CAAC,GAAG5G,KAAK,CAACgH,cAAc,CAAC,CAAC,CAAC;IACnCJ,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC5G,KAAK,CAAC+G,iBAAiB,CAAC,CAAC,CAAC;IACvCH,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC5G,KAAK,CAAC+G,iBAAiB,CAAC,CAAC,CAAC;IACvCH,MAAM,CAAC,EAAE,CAAC,GAAG,CAAC5G,KAAK,CAAC+G,iBAAiB,CAAC,CAAC,CAAC;IACxC9H,IAAI,CAACgI,SAAS,CAACL,MAAM,EAAEA,MAAM,CAAC;IAC9BzH,IAAI,CAAC+H,GAAG,CAACxG,OAAO,EAAE,CAAC,GAAGV,KAAK,CAACmH,aAAa,EAAE,CAAC,GAAGnH,KAAK,CAACmH,aAAa,EAAE,CAAC,GAAGnH,KAAK,CAACmH,aAAa,CAAC;IAC5FlI,IAAI,CAACmI,KAAK,CAACR,MAAM,EAAEA,MAAM,EAAElG,OAAO,CAAC;IACnCzB,IAAI,CAACsE,SAAS,CAACqD,MAAM,EAAEA,MAAM,EAAE5G,KAAK,CAACqH,mBAAmB,CAAC;EAC3D,CAAC;EACDtH,SAAS,CAACuH,mCAAmC,GAAGC,IAAI,IAAI;IACtD;IACAtI,IAAI,CAAC6G,MAAM,CAACvF,SAAS,EAAEgH,IAAI,CAAC;;IAE5B;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACApI,IAAI,CAACiE,aAAa,CAAC1C,OAAO,EAAEP,MAAM,EAAEI,SAAS,CAAC;IAC9CR,SAAS,CAAC+B,eAAe,CAAC,CAAC;IAC3B,MAAM0F,OAAO,GAAGxH,KAAK,CAACmC,QAAQ;IAC9BpC,SAAS,CAAC0B,WAAW,CAACf,OAAO,CAAC,CAAC,CAAC,EAAEA,OAAO,CAAC,CAAC,CAAC,EAAEA,OAAO,CAAC,CAAC,CAAC,CAAC;;IAEzD;IACAvB,IAAI,CAACiE,aAAa,CAACzC,OAAO,EAAEN,QAAQ,EAAEE,SAAS,CAAC;IAChDpB,IAAI,CAACsI,QAAQ,CAAC9G,OAAO,EAAEA,OAAO,EAAED,OAAO,CAAC;IACxCvB,IAAI,CAACuI,SAAS,CAAC/G,OAAO,EAAEA,OAAO,CAAC;IAChCZ,SAAS,CAAC4H,wBAAwB,CAAChH,OAAO,CAAC,CAAC,CAAC,EAAEA,OAAO,CAAC,CAAC,CAAC,EAAEA,OAAO,CAAC,CAAC,CAAC,CAAC;IACtExB,IAAI,CAACiE,aAAa,CAACxC,OAAO,EAAEN,OAAO,EAAEC,SAAS,CAAC;IAC/CpB,IAAI,CAACsI,QAAQ,CAAC7G,OAAO,EAAEA,OAAO,EAAEF,OAAO,CAAC;IACxCvB,IAAI,CAACuI,SAAS,CAAC9G,OAAO,EAAEA,OAAO,CAAC;IAChCb,SAAS,CAACyE,SAAS,CAAC5D,OAAO,CAAC,CAAC,CAAC,EAAEA,OAAO,CAAC,CAAC,CAAC,EAAEA,OAAO,CAAC,CAAC,CAAC,CAAC;IACvDb,SAAS,CAACkC,WAAW,CAACuF,OAAO,CAAC;EAChC,CAAC;;EAED;EACA;EACA;EACAzH,SAAS,CAAC6H,uCAAuC,GAAGC,GAAG,IAAI;IACzD;IACA9H,SAAS,CAAC8G,wBAAwB,CAACtG,SAAS,CAAC;;IAE7C;IACA;IACAtB,IAAI,CAAC+G,QAAQ,CAACzF,SAAS,EAAEsH,GAAG,EAAEtH,SAAS,CAAC;IACxCR,SAAS,CAACuH,mCAAmC,CAAC/G,SAAS,CAAC;EAC1D,CAAC;EACDR,SAAS,CAAC+H,aAAa,GAAGD,GAAG,IAAI;IAC/B7H,KAAK,CAAC+H,UAAU,GAAGF,GAAG;IACtB,IAAI7H,KAAK,CAAC+H,UAAU,EAAE;MACpB9I,IAAI,CAAC0G,IAAI,CAACpF,SAAS,EAAEP,KAAK,CAAC+H,UAAU,CAAC;MACtChI,SAAS,CAACuH,mCAAmC,CAAC/G,SAAS,CAAC;MACxDtB,IAAI,CAACgI,SAAS,CAACjH,KAAK,CAAC+H,UAAU,EAAE/H,KAAK,CAAC+H,UAAU,CAAC;IACpD;EACF,CAAC;EACDhI,SAAS,CAACuB,aAAa,GAAG,MAAM;IAC9B,IAAItB,KAAK,CAAC+H,UAAU,EAAE;MACpB,OAAO/H,KAAK,CAAC+H,UAAU;IACzB;IACA9I,IAAI,CAAC+I,MAAM,CAACzH,SAAS,EAAEP,KAAK,CAAC6B,QAAQ;IACrC;IACA7B,KAAK,CAACgC,UAAU;IAChB;IACAhC,KAAK,CAACuB,MAAM,CAAC;IACb,CAAC;IAEDtC,IAAI,CAACgI,SAAS,CAAC1G,SAAS,EAAEA,SAAS,CAAC;IACpC,MAAMqG,MAAM,GAAG,IAAIxG,YAAY,CAAC,EAAE,CAAC;IACnCnB,IAAI,CAAC0G,IAAI,CAACiB,MAAM,EAAErG,SAAS,CAAC;IAC5B,OAAOqG,MAAM;EACf,CAAC;EACD7G,SAAS,CAACkI,mBAAmB,GAAGJ,GAAG,IAAI;IACrC7H,KAAK,CAACkI,gBAAgB,GAAGL,GAAG;EAC9B,CAAC;EACD9H,SAAS,CAACoI,mBAAmB,GAAG,CAAC3C,MAAM,EAAE4C,KAAK,EAAEC,IAAI,KAAK;IACvD,MAAMzB,MAAM,GAAG,IAAIxG,YAAY,CAAC,EAAE,CAAC;IACnCnB,IAAI,CAACuB,QAAQ,CAACoG,MAAM,CAAC;IACrB,IAAI5G,KAAK,CAACkI,gBAAgB,EAAE;MAC1B,MAAMd,KAAK,GAAG,CAAC,GAAGpH,KAAK,CAACmH,aAAa;MACrChI,IAAI,CAAC+H,GAAG,CAACxG,OAAO,EAAE0G,KAAK,EAAEA,KAAK,EAAEA,KAAK,CAAC;MACtCnI,IAAI,CAAC0G,IAAI,CAACiB,MAAM,EAAE5G,KAAK,CAACkI,gBAAgB,CAAC;MACzCjJ,IAAI,CAACmI,KAAK,CAACR,MAAM,EAAEA,MAAM,EAAElG,OAAO,CAAC;MACnCzB,IAAI,CAACgI,SAAS,CAACL,MAAM,EAAEA,MAAM,CAAC;MAC9B,OAAOA,MAAM;IACf;IACA3H,IAAI,CAACuB,QAAQ,CAACD,SAAS,CAAC;;IAExB;IACA;IACA;IACA,MAAM+H,MAAM,GAAGtI,KAAK,CAAC0E,aAAa,CAAC,CAAC,CAAC,GAAG1E,KAAK,CAAC0E,aAAa,CAAC,CAAC,CAAC;IAC9D,MAAM6D,MAAM,GAAG,CAACvI,KAAK,CAAC0E,aAAa,CAAC,CAAC,CAAC,GAAG,CAAC0D,KAAK,GAAG,CAAC,IAAIE,MAAM,GAAG,GAAG,EAAEtI,KAAK,CAAC0E,aAAa,CAAC,CAAC,CAAC,GAAG,CAAC2D,IAAI,GAAG,CAAC,IAAIC,MAAM,GAAG,GAAG,CAAC;IACxH,IAAItI,KAAK,CAAC8D,kBAAkB,EAAE;MAC5B;MACA,MAAM0E,KAAK,GAAGxI,KAAK,CAAC+D,aAAa,GAAGyB,MAAM;MAC1C,MAAMiD,MAAM,GAAGzI,KAAK,CAAC+D,aAAa;MAClC,MAAM2E,IAAI,GAAG,CAAC1I,KAAK,CAAC2I,YAAY,CAAC,CAAC,CAAC,GAAG,GAAG,IAAIH,KAAK;MAClD,MAAMI,IAAI,GAAG,CAAC5I,KAAK,CAAC2I,YAAY,CAAC,CAAC,CAAC,GAAG,GAAG,IAAIH,KAAK;MAClD,MAAMK,IAAI,GAAG,CAAC7I,KAAK,CAAC2I,YAAY,CAAC,CAAC,CAAC,GAAG,GAAG,IAAIF,MAAM;MACnD,MAAMK,IAAI,GAAG,CAAC9I,KAAK,CAAC2I,YAAY,CAAC,CAAC,CAAC,GAAG,GAAG,IAAIF,MAAM;MACnDxJ,IAAI,CAAC8J,KAAK,CAACxI,SAAS,EAAEmI,IAAI,EAAEE,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAEP,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC;MACnEtJ,IAAI,CAACgI,SAAS,CAAC1G,SAAS,EAAEA,SAAS,CAAC;IACtC,CAAC,MAAM,IAAIP,KAAK,CAACgJ,oBAAoB,EAAE;MACrC,MAAM,IAAIC,KAAK,CAAC,mDAAmD,CAAC;IACtE,CAAC,MAAM;MACL,MAAMC,GAAG,GAAG1G,IAAI,CAAC2G,GAAG,CAAC3J,kBAAkB,CAACQ,KAAK,CAACgE,SAAS,CAAC,GAAG,GAAG,CAAC;MAC/D,IAAIwE,KAAK;MACT,IAAIC,MAAM;MACV,IAAIzI,KAAK,CAACoJ,sBAAsB,KAAK,IAAI,EAAE;QACzCZ,KAAK,GAAGxI,KAAK,CAAC0E,aAAa,CAAC,CAAC,CAAC,GAAGwE,GAAG;QACpCT,MAAM,GAAGzI,KAAK,CAAC0E,aAAa,CAAC,CAAC,CAAC,GAAGwE,GAAG,GAAG1D,MAAM;MAChD,CAAC,MAAM;QACLgD,KAAK,GAAGxI,KAAK,CAAC0E,aAAa,CAAC,CAAC,CAAC,GAAGwE,GAAG,GAAG1D,MAAM;QAC7CiD,MAAM,GAAGzI,KAAK,CAAC0E,aAAa,CAAC,CAAC,CAAC,GAAGwE,GAAG;MACvC;MACA,MAAMR,IAAI,GAAG,CAAC1I,KAAK,CAAC2I,YAAY,CAAC,CAAC,CAAC,GAAG,GAAG,IAAIH,KAAK;MAClD,MAAMI,IAAI,GAAG,CAAC5I,KAAK,CAAC2I,YAAY,CAAC,CAAC,CAAC,GAAG,GAAG,IAAIH,KAAK;MAClD,MAAMK,IAAI,GAAG,CAAC7I,KAAK,CAAC2I,YAAY,CAAC,CAAC,CAAC,GAAG,GAAG,IAAIF,MAAM;MACnD,MAAMK,IAAI,GAAG,CAAC9I,KAAK,CAAC2I,YAAY,CAAC,CAAC,CAAC,GAAG,GAAG,IAAIF,MAAM;MACnD,MAAMY,KAAK,GAAGd,MAAM,CAAC,CAAC,CAAC;MACvB,MAAMe,IAAI,GAAGf,MAAM,CAAC,CAAC,CAAC;MACtBhI,SAAS,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG8I,KAAK,IAAIT,IAAI,GAAGF,IAAI,CAAC;MAC1CnI,SAAS,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG8I,KAAK,IAAIP,IAAI,GAAGD,IAAI,CAAC;MAC1CtI,SAAS,CAAC,CAAC,CAAC,GAAG,CAACmI,IAAI,GAAGE,IAAI,KAAKA,IAAI,GAAGF,IAAI,CAAC;MAC5CnI,SAAS,CAAC,CAAC,CAAC,GAAG,CAACsI,IAAI,GAAGC,IAAI,KAAKA,IAAI,GAAGD,IAAI,CAAC;MAC5CtI,SAAS,CAAC,EAAE,CAAC,GAAG,EAAE8I,KAAK,GAAGC,IAAI,CAAC,IAAIA,IAAI,GAAGD,KAAK,CAAC;MAChD9I,SAAS,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG;MACpBA,SAAS,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,GAAG8I,KAAK,GAAGC,IAAI,IAAIA,IAAI,GAAGD,KAAK,CAAC;MACpD9I,SAAS,CAAC,EAAE,CAAC,GAAG,GAAG;IACrB;IACAtB,IAAI,CAAC0G,IAAI,CAACiB,MAAM,EAAErG,SAAS,CAAC;IAC5B,OAAOqG,MAAM;EACf,CAAC;EACD7G,SAAS,CAACwJ,4BAA4B,GAAG,CAAC/D,MAAM,EAAE4C,KAAK,EAAEC,IAAI,KAAK;IAChE,MAAMmB,IAAI,GAAGzJ,SAAS,CAACuB,aAAa,CAAC,CAAC;IACtC,MAAMmI,IAAI,GAAG1J,SAAS,CAACoI,mBAAmB,CAAC3C,MAAM,EAAE4C,KAAK,EAAEC,IAAI,CAAC;IAC/D;IACA;IACApJ,IAAI,CAAC+G,QAAQ,CAACyD,IAAI,EAAED,IAAI,EAAEC,IAAI,CAAC;IAC/B,OAAOA,IAAI;EACb,CAAC;EACD1J,SAAS,CAAC4H,wBAAwB,GAAG,CAACjG,CAAC,EAAEC,CAAC,EAAEC,CAAC,KAAK;IAChD,IAAI5B,KAAK,CAACmB,qBAAqB,CAAC,CAAC,CAAC,KAAKO,CAAC,IAAI1B,KAAK,CAACmB,qBAAqB,CAAC,CAAC,CAAC,KAAKQ,CAAC,IAAI3B,KAAK,CAACmB,qBAAqB,CAAC,CAAC,CAAC,KAAKS,CAAC,EAAE;MACxH;IACF;IACA5B,KAAK,CAACmB,qBAAqB,CAAC,CAAC,CAAC,GAAGO,CAAC;IAClC1B,KAAK,CAACmB,qBAAqB,CAAC,CAAC,CAAC,GAAGQ,CAAC;IAClC3B,KAAK,CAACmB,qBAAqB,CAAC,CAAC,CAAC,GAAGS,CAAC;IAClC,MAAMQ,GAAG,GAAGpC,KAAK,CAACmB,qBAAqB;;IAEvC;IACAnB,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,GAAGhC,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC,GAAGO,GAAG,CAAC,CAAC,CAAC,GAAGpC,KAAK,CAACmC,QAAQ;IACjEnC,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,GAAGhC,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC,GAAGO,GAAG,CAAC,CAAC,CAAC,GAAGpC,KAAK,CAACmC,QAAQ;IACjEnC,KAAK,CAACgC,UAAU,CAAC,CAAC,CAAC,GAAGhC,KAAK,CAAC6B,QAAQ,CAAC,CAAC,CAAC,GAAGO,GAAG,CAAC,CAAC,CAAC,GAAGpC,KAAK,CAACmC,QAAQ;IACjElB,sBAAsB,CAAC,CAAC;EAC1B,CAAC;;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAlB,SAAS,CAAC2J,eAAe,GAAG,CAACvE,KAAK,EAAEC,IAAI,EAAEuE,KAAK,EAAEC,MAAM,KAAK;IAC1D,MAAM9C,UAAU,GAAG,CAAC,CAAC,CAAC;IACtBlH,KAAK,CAACI,KAAK,CAAC+G,iBAAiB,EAAE/G,KAAK,CAACgH,cAAc,EAAEF,UAAU,CAAC;;IAEhE;IACA,MAAM+C,MAAM,GAAG5K,IAAI,CAACuB,QAAQ,CAAC,IAAIJ,YAAY,CAAC,EAAE,CAAC,CAAC;IAClDnB,IAAI,CAACkE,MAAM,CAAC0G,MAAM,EAAEA,MAAM,EAAErK,kBAAkB,CAAC2F,KAAK,CAAC,EAAEnF,KAAK,CAACgH,cAAc,CAAC;IAC5E/H,IAAI,CAACkE,MAAM,CAAC0G,MAAM,EAAEA,MAAM,EAAErK,kBAAkB,CAAC4F,IAAI,CAAC,EAAE0B,UAAU,CAAC;IACjE7H,IAAI,CAACkE,MAAM,CAAC0G,MAAM,EAAEA,MAAM,EAAErK,kBAAkB,CAACmK,KAAK,CAAC,EAAE3J,KAAK,CAAC+G,iBAAiB,CAAC;IAC/E9H,IAAI,CAACkE,MAAM,CAAC0G,MAAM,EAAEA,MAAM,EAAErK,kBAAkB,CAAC,CAACoK,MAAM,CAAC,EAAE5J,KAAK,CAACgH,cAAc,CAAC;IAC9E,MAAM8C,GAAG,GAAG,IAAI1J,YAAY,CAAC,CAAC,CAACJ,KAAK,CAACgH,cAAc,CAAC,CAAC,CAAC,EAAE,CAAChH,KAAK,CAACgH,cAAc,CAAC,CAAC,CAAC,EAAE,CAAChH,KAAK,CAACgH,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5G,MAAM+C,GAAG,GAAG,IAAI3J,YAAY,CAACJ,KAAK,CAAC+G,iBAAiB,CAAC;IACrD5H,IAAI,CAACiE,aAAa,CAAC0G,GAAG,EAAEA,GAAG,EAAED,MAAM,CAAC;IACpC1K,IAAI,CAACiE,aAAa,CAAC2G,GAAG,EAAEA,GAAG,EAAEF,MAAM,CAAC;IACpC9J,SAAS,CAAC4H,wBAAwB,CAACmC,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,CAAC;IAC1D/J,SAAS,CAACyE,SAAS,CAACuF,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,CAAC;IAC3ChK,SAAS,CAACyB,QAAQ,CAAC,CAAC;EACtB,CAAC;EACDzB,SAAS,CAACiK,kBAAkB,GAAG,CAACC,OAAO,EAAEvI,CAAC,EAAEC,CAAC,EAAEC,CAAC,KAAK;IACnD,MAAMsI,OAAO,GAAGjL,IAAI,CAACuB,QAAQ,CAAC,IAAIJ,YAAY,CAAC,EAAE,CAAC,CAAC;IACnD,IAAI6J,OAAO,KAAK,GAAG,KAAKvI,CAAC,KAAK,GAAG,IAAIC,CAAC,KAAK,GAAG,IAAIC,CAAC,KAAK,GAAG,CAAC,EAAE;MAC5D;MACA,MAAMiB,KAAK,GAAGrD,kBAAkB,CAACyK,OAAO,CAAC;MACzC,MAAME,CAAC,GAAG/K,IAAI,CAACoH,MAAM,CAAC,CAAC;MACvBpH,IAAI,CAACgL,YAAY,CAACD,CAAC,EAAE,CAACzI,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,EAAEiB,KAAK,CAAC;MACtC5D,IAAI,CAACoL,QAAQ,CAACH,OAAO,EAAEC,CAAC,CAAC;IAC3B;IACA,MAAMG,MAAM,GAAG,IAAIlK,YAAY,CAAC,CAAC,CAAC;IAClCjB,IAAI,CAACiE,aAAa,CAACkH,MAAM,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAEJ,OAAO,CAAC;IACrD,MAAMK,MAAM,GAAG,IAAInK,YAAY,CAAC,CAAC,CAAC;IAClCjB,IAAI,CAACiE,aAAa,CAACmH,MAAM,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,EAAEL,OAAO,CAAC;IACpDnK,SAAS,CAAC4H,wBAAwB,CAAC,GAAG2C,MAAM,CAAC;IAC7CvK,SAAS,CAACyE,SAAS,CAAC,GAAG+F,MAAM,CAAC;IAC9BxK,SAAS,CAACyB,QAAQ,CAAC,CAAC;EACtB,CAAC;EACDzB,SAAS,CAACyK,oBAAoB,GAAGC,MAAM,IAAI;IACzC,IAAIC,EAAE,GAAG,IAAI;IACb,IAAI7I,QAAQ,GAAG,IAAI;IACnB6I,EAAE,GAAG1K,KAAK,CAACkB,eAAe;IAC1BW,QAAQ,GAAG7B,KAAK,CAAC6B,QAAQ;IACzB,MAAM8I,CAAC,GAAG,CAACD,EAAE,CAAC,CAAC,CAAC;IAChB,MAAME,CAAC,GAAG,CAACF,EAAE,CAAC,CAAC,CAAC;IAChB,MAAMG,CAAC,GAAG,CAACH,EAAE,CAAC,CAAC,CAAC;IAChB,MAAMxI,CAAC,GAAG,EAAEyI,CAAC,GAAG9I,QAAQ,CAAC,CAAC,CAAC,GAAG+I,CAAC,GAAG/I,QAAQ,CAAC,CAAC,CAAC,GAAGgJ,CAAC,GAAGhJ,QAAQ,CAAC,CAAC,CAAC,CAAC;;IAEhE;IACA,MAAMiJ,KAAK,GAAG,CAACH,CAAC,GAAGF,MAAM,CAAC,CAAC,CAAC,GAAGG,CAAC,GAAGH,MAAM,CAAC,CAAC,CAAC,GAAGI,CAAC,GAAGJ,MAAM,CAAC,CAAC,CAAC,GAAGvI,CAAC,EAAE,KAAK,CAAC;;IAExE;IACA,KAAK,IAAIzC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC1B,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QAC1B,KAAK,IAAIoL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;UAC1B,MAAMC,IAAI,GAAGL,CAAC,GAAGF,MAAM,CAACM,CAAC,CAAC,GAAGH,CAAC,GAAGH,MAAM,CAAC,CAAC,GAAG9K,CAAC,CAAC,GAAGkL,CAAC,GAAGJ,MAAM,CAAC,CAAC,GAAGhL,CAAC,CAAC,GAAGyC,CAAC;UACtE4I,KAAK,CAAC,CAAC,CAAC,GAAGE,IAAI,GAAGF,KAAK,CAAC,CAAC,CAAC,GAAGE,IAAI,GAAGF,KAAK,CAAC,CAAC,CAAC;UAC5CA,KAAK,CAAC,CAAC,CAAC,GAAGE,IAAI,GAAGF,KAAK,CAAC,CAAC,CAAC,GAAGE,IAAI,GAAGF,KAAK,CAAC,CAAC,CAAC;QAC9C;MACF;IACF;IACA,OAAOA,KAAK;EACd,CAAC;AACH;;AAEA;AACA;AACA;;AAEA,MAAMG,cAAc,GAAG;EACrBpJ,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACnBG,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACrBT,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACjBJ,qBAAqB,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EACjC2C,kBAAkB,EAAE,KAAK;EACzBsF,sBAAsB,EAAE,KAAK;EAC7BpF,SAAS,EAAE,EAAE;EACbD,aAAa,EAAE,CAAC;EAChBW,aAAa,EAAE,CAAC,IAAI,EAAE,OAAO,CAAC;EAC9BiE,YAAY,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;EACpBzH,eAAe,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAC1B8H,oBAAoB,EAAE,KAAK;EAC3BkC,gBAAgB,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC;EACpCC,iBAAiB,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC;EACpCC,cAAc,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC;EAChCC,gBAAgB,EAAE,KAAK;EACvBnD,gBAAgB,EAAE,IAAI;EACtBH,UAAU,EAAE,IAAI;EAChBnC,oBAAoB,EAAE3G,IAAI,CAACuH,MAAM,CAAC,CAAC;EACnC;EACAa,mBAAmB,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAC9BF,aAAa,EAAE,GAAG;EAClBH,cAAc,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACzBD,iBAAiB,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AAC9B,CAAC;;AAED;;AAEA,SAASuE,MAAMA,CAACvL,SAAS,EAAEC,KAAK,EAAE;EAChC,IAAIuL,aAAa,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;EAC1FG,MAAM,CAACC,MAAM,CAAC5L,KAAK,EAAEiL,cAAc,EAAEM,aAAa,CAAC;;EAEnD;EACAjM,KAAK,CAACuM,GAAG,CAAC9L,SAAS,EAAEC,KAAK,CAAC;EAC3BV,KAAK,CAACwM,GAAG,CAAC/L,SAAS,EAAEC,KAAK,EAAE,CAAC,UAAU,CAAC,CAAC;EACzCV,KAAK,CAACyM,MAAM,CAAChM,SAAS,EAAEC,KAAK,EAAE,CAAC,oBAAoB,EAAE,wBAAwB,EAAE,WAAW,EAAE,eAAe,EAAE,sBAAsB,EAAE,kBAAkB,EAAE,eAAe,CAAC,CAAC;EAC3KV,KAAK,CAAC0M,QAAQ,CAACjM,SAAS,EAAEC,KAAK,EAAE,CAAC,uBAAuB,EAAE,iBAAiB,EAAE,UAAU,EAAE,YAAY,CAAC,CAAC;EACxGV,KAAK,CAAC2M,WAAW,CAAClM,SAAS,EAAEC,KAAK,EAAE,CAAC,eAAe,EAAE,cAAc,CAAC,EAAE,CAAC,CAAC;EACzEV,KAAK,CAAC2M,WAAW,CAAClM,SAAS,EAAEC,KAAK,EAAE,CAAC,QAAQ,EAAE,kBAAkB,EAAE,mBAAmB,EAAE,gBAAgB,EAAE,qBAAqB,EAAE,gBAAgB,EAAE,mBAAmB,CAAC,EAAE,CAAC,CAAC;;EAE3K;EACAF,SAAS,CAACC,SAAS,EAAEC,KAAK,CAAC;AAC7B;;AAEA;;AAEA,MAAMkM,WAAW,GAAG5M,KAAK,CAAC4M,WAAW,CAACZ,MAAM,EAAE,WAAW,CAAC;;AAE1D;;AAEA,IAAIa,WAAW,GAAG;EAChBD,WAAW;EACXZ;AACF,CAAC;AAED,SAASL,cAAc,EAAEkB,WAAW,IAAIC,OAAO,EAAEd,MAAM,EAAEY,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}