"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@cornerstonejs/core");
const base_1 = require("../base");
const triggerSegmentationEvents_1 = require("../../stateManagement/segmentation/triggerSegmentationEvents");
const triggerAnnotationRenderForViewportIds_1 = __importDefault(require("../../utilities/triggerAnnotationRenderForViewportIds"));
const activeSegmentation_1 = require("../../stateManagement/segmentation/activeSegmentation");
const SegmentationRepresentations_1 = __importDefault(require("../../enums/SegmentationRepresentations"));
const segmentIndex_1 = require("../../stateManagement/segmentation/segmentIndex");
const segmentation_1 = require("../../utilities/segmentation");
const store_1 = require("../../store");
const SegmentationRepresentations_2 = __importDefault(require("../../enums/SegmentationRepresentations"));
class SegmentSelectTool extends base_1.BaseTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            hoverTimeout: 100,
            mode: SegmentSelectTool.SelectMode.Border,
            searchRadius: 6,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.mouseMoveCallback = (evt) => {
            if (this.hoverTimer) {
                clearTimeout(this.hoverTimer);
            }
            this.hoverTimer = setTimeout(() => {
                this._setActiveSegment(evt);
                this.hoverTimer = null;
            }, this.configuration.hoverTimeout);
            return true;
        };
        this.onSetToolEnabled = () => {
            this.onSetToolActive();
        };
        this.onSetToolActive = () => {
            this.hoverTimer = null;
        };
        this.onSetToolDisabled = () => {
            this.hoverTimer = null;
        };
        this.hoverTimer = null;
    }
    _setActiveSegment(evt = {}) {
        if (store_1.state.isInteractingWithTool) {
            return;
        }
        const { element, currentPoints } = evt.detail;
        const worldPoint = currentPoints.world;
        const enabledElement = (0, core_1.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        const { viewport } = enabledElement;
        const activeSegmentationReps = (0, activeSegmentation_1.getActiveSegmentationRepresentation)(this.toolGroupId);
        if (!activeSegmentationReps) {
            return;
        }
        const supportedTypes = [
            SegmentationRepresentations_1.default.Labelmap,
            SegmentationRepresentations_1.default.Contour,
        ];
        if (supportedTypes.includes(activeSegmentationReps.type)) {
            this._setActiveSegmentForType(activeSegmentationReps, worldPoint, viewport);
        }
        else {
            console.warn('SegmentSelectTool does not support the current segmentation type.');
        }
    }
    _setActiveSegmentForType(activeSegmentationReps, worldPoint, viewport) {
        const imageDataInfo = viewport.getImageData();
        if (!imageDataInfo) {
            return;
        }
        const { segmentationId, type } = activeSegmentationReps;
        let hoveredSegmentIndex;
        if (this.configuration.mode === SegmentSelectTool.SelectMode.Inside) {
            hoveredSegmentIndex = (0, segmentation_1.getSegmentAtWorldPoint)(segmentationId, worldPoint, {
                viewport,
            });
        }
        else {
            switch (type) {
                case SegmentationRepresentations_2.default.Labelmap:
                    hoveredSegmentIndex = (0, segmentation_1.getSegmentAtLabelmapBorder)(segmentationId, worldPoint, {
                        viewport,
                        searchRadius: this.configuration.searchRadius,
                    });
                    break;
                case SegmentationRepresentations_2.default.Contour:
                    hoveredSegmentIndex =
                        (0, segmentation_1.getHoveredContourSegmentationAnnotation)(segmentationId);
                    break;
            }
        }
        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {
            return;
        }
        (0, segmentIndex_1.setActiveSegmentIndex)(segmentationId, hoveredSegmentIndex);
        const renderingEngine = viewport.getRenderingEngine();
        const viewportIds = renderingEngine.getViewports().map((v) => v.id);
        (0, triggerSegmentationEvents_1.triggerSegmentationModified)(segmentationId);
        (0, triggerAnnotationRenderForViewportIds_1.default)(renderingEngine, viewportIds);
    }
}
SegmentSelectTool.SelectMode = {
    Inside: 'Inside',
    Border: 'Border',
};
SegmentSelectTool.toolName = 'SegmentSelectTool';
exports.default = SegmentSelectTool;
//# sourceMappingURL=SegmentSelectTool.js.map