{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkCellArrayBufferObject from './CellArrayBufferObject.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkVertexArrayObject from './VertexArrayObject.js';\nimport { Representation } from '../Core/Property/Constants.js';\nconst primTypes = {\n  Start: 0,\n  Points: 0,\n  Lines: 1,\n  Tris: 2,\n  TriStrips: 3,\n  TrisEdges: 4,\n  TriStripsEdges: 5,\n  End: 6\n};\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLHelper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLHelper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLHelper');\n  publicAPI.setOpenGLRenderWindow = win => {\n    model.context = win.getContext();\n    model.program.setContext(model.context);\n    model.VAO.setOpenGLRenderWindow(win);\n    model.CABO.setOpenGLRenderWindow(win);\n  };\n  publicAPI.releaseGraphicsResources = oglwin => {\n    model.VAO.releaseGraphicsResources();\n    model.CABO.releaseGraphicsResources();\n    model.CABO.setElementCount(0);\n  };\n  publicAPI.drawArrays = (ren, actor, rep, oglMapper) => {\n    // Are there any entries\n    if (model.CABO.getElementCount()) {\n      // are we drawing edges\n      const mode = publicAPI.getOpenGLMode(rep);\n      const wideLines = publicAPI.haveWideLines(ren, actor);\n      const gl = model.context;\n      const depthMask = gl.getParameter(gl.DEPTH_WRITEMASK);\n      if (model.pointPicking) {\n        gl.depthMask(false);\n      }\n      const drawingLines = mode === gl.LINES;\n      if (drawingLines && wideLines) {\n        publicAPI.updateShaders(ren, actor, oglMapper);\n        gl.drawArraysInstanced(mode, 0, model.CABO.getElementCount(), 2 * Math.ceil(actor.getProperty().getLineWidth()));\n      } else {\n        gl.lineWidth(actor.getProperty().getLineWidth());\n        publicAPI.updateShaders(ren, actor, oglMapper);\n        gl.drawArrays(mode, 0, model.CABO.getElementCount());\n        // reset the line width\n        gl.lineWidth(1);\n      }\n      const stride = (mode === gl.POINTS ? 1 : 0) || (mode === gl.LINES ? 2 : 3);\n      if (model.pointPicking) {\n        gl.depthMask(depthMask);\n      }\n      return model.CABO.getElementCount() / stride;\n    }\n    return 0;\n  };\n  publicAPI.getOpenGLMode = rep => {\n    if (model.pointPicking) {\n      return model.context.POINTS;\n    }\n    const type = model.primitiveType;\n    if (rep === Representation.POINTS || type === primTypes.Points) {\n      return model.context.POINTS;\n    }\n    if (rep === Representation.WIREFRAME || type === primTypes.Lines || type === primTypes.TrisEdges || type === primTypes.TriStripsEdges) {\n      return model.context.LINES;\n    }\n    return model.context.TRIANGLES;\n  };\n  publicAPI.haveWideLines = (ren, actor) => {\n    if (actor.getProperty().getLineWidth() > 1.0) {\n      // we have wide lines, but the OpenGL implementation may\n      // actually support them, check the range to see if we\n      // really need have to implement our own wide lines\n      if (model.CABO.getOpenGLRenderWindow()) {\n        if (model.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth() >= actor.getProperty().getLineWidth()) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  };\n  publicAPI.getNeedToRebuildShaders = (ren, actor, oglMapper) => {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // mapper modified (lighting complexity)\n    if (oglMapper.getNeedToRebuildShaders(publicAPI, ren, actor) || publicAPI.getProgram() === 0 || publicAPI.getShaderSourceTime().getMTime() < oglMapper.getMTime() || publicAPI.getShaderSourceTime().getMTime() < actor.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.updateShaders = (ren, actor, oglMapper) => {\n    // has something changed that would require us to recreate the shader?\n    if (publicAPI.getNeedToRebuildShaders(ren, actor, oglMapper)) {\n      const shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      oglMapper.buildShaders(shaders, ren, actor);\n\n      // compile and bind the program if needed\n      const newShader = model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);\n\n      // if the shader changed reinitialize the VAO\n      if (newShader !== publicAPI.getProgram()) {\n        publicAPI.setProgram(newShader);\n        // reset the VAO as the shader has changed\n        publicAPI.getVAO().releaseGraphicsResources();\n      }\n      publicAPI.getShaderSourceTime().modified();\n    } else {\n      model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(publicAPI.getProgram());\n    }\n    publicAPI.getVAO().bind();\n    oglMapper.setMapperShaderParameters(publicAPI, ren, actor);\n    oglMapper.setPropertyShaderParameters(publicAPI, ren, actor);\n    oglMapper.setCameraShaderParameters(publicAPI, ren, actor);\n    oglMapper.setLightingShaderParameters(publicAPI, ren, actor);\n    oglMapper.invokeShaderCallbacks(publicAPI, ren, actor);\n  };\n  publicAPI.setMapperShaderParameters = (ren, actor, size) => {\n    if (publicAPI.haveWideLines(ren, actor)) {\n      publicAPI.getProgram().setUniform2f('viewportSize', size.usize, size.vsize);\n      const lineWidth = parseFloat(actor.getProperty().getLineWidth());\n      const halfLineWidth = lineWidth / 2.0;\n      publicAPI.getProgram().setUniformf('lineWidthStepSize', lineWidth / Math.ceil(lineWidth));\n      publicAPI.getProgram().setUniformf('halfLineWidth', halfLineWidth);\n    }\n    if (model.primitiveType === primTypes.Points || actor.getProperty().getRepresentation() === Representation.POINTS) {\n      publicAPI.getProgram().setUniformf('pointSize', actor.getProperty().getPointSize());\n    } else if (model.pointPicking) {\n      publicAPI.getProgram().setUniformf('pointSize', publicAPI.getPointPickingPrimitiveSize());\n    }\n  };\n  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n\n    // Always set point size in case we need picking\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', ['//VTK::PositionVC::Dec', 'uniform float pointSize;']).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['//VTK::PositionVC::Impl', '  gl_PointSize = pointSize;'], false).result;\n\n    // for lines, make sure we add the width code\n    if (publicAPI.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES && publicAPI.haveWideLines(ren, actor)) {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', ['//VTK::PositionVC::Dec', 'uniform vec2 viewportSize;', 'uniform float lineWidthStepSize;', 'uniform float halfLineWidth;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['//VTK::PositionVC::Impl', ' if (halfLineWidth > 0.0)', '   {', '   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;', '   vec4 tmpPos = gl_Position;', '   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;', '   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];', '   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];', '   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);', '   }']).result;\n    }\n    shaders.Vertex = VSSource;\n  };\n  publicAPI.getPointPickingPrimitiveSize = () => {\n    if (model.primitiveType === primTypes.Points) {\n      return 2;\n    }\n    if (model.primitiveType === primTypes.Lines) {\n      return 4;\n    }\n    return 6;\n  };\n  publicAPI.getAllocatedGPUMemoryInBytes = () => publicAPI.getCABO().getAllocatedGPUMemoryInBytes();\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  program: null,\n  shaderSourceTime: null,\n  VAO: null,\n  attributeUpdateTime: null,\n  CABO: null,\n  primitiveType: 0,\n  pointPicking: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  model.shaderSourceTime = {};\n  macro.obj(model.shaderSourceTime);\n  model.attributeUpdateTime = {};\n  macro.obj(model.attributeUpdateTime);\n  macro.setGet(publicAPI, model, ['program', 'shaderSourceTime', 'VAO', 'attributeUpdateTime', 'CABO', 'primitiveType', 'pointPicking']);\n  model.program = vtkShaderProgram.newInstance();\n  model.VAO = vtkVertexArrayObject.newInstance();\n  model.CABO = vtkCellArrayBufferObject.newInstance();\n\n  // Object methods\n  vtkOpenGLHelper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkHelper = {\n  newInstance,\n  extend,\n  primTypes\n};\nexport { vtkHelper as default, extend, newInstance, primTypes };","map":{"version":3,"names":["m","macro","vtkCellArrayBufferObject","vtkShaderProgram","vtkVertexArrayObject","Representation","primTypes","Start","Points","Lines","Tris","TriStrips","TrisEdges","TriStripsEdges","End","vtkOpenGLHelper","publicAPI","model","classHierarchy","push","setOpenGLRenderWindow","win","context","getContext","program","setContext","VAO","CABO","releaseGraphicsResources","oglwin","setElementCount","drawArrays","ren","actor","rep","oglMapper","getElementCount","mode","getOpenGLMode","wideLines","haveWideLines","gl","depthMask","getParameter","DEPTH_WRITEMASK","pointPicking","drawingLines","LINES","updateShaders","drawArraysInstanced","Math","ceil","getProperty","getLineWidth","lineWidth","stride","POINTS","type","primitiveType","WIREFRAME","TRIANGLES","getOpenGLRenderWindow","getHardwareMaximumLineWidth","getNeedToRebuildShaders","getProgram","getShaderSourceTime","getMTime","shaders","Vertex","Fragment","Geometry","buildShaders","newShader","getShaderCache","readyShaderProgramArray","setProgram","getVAO","modified","readyShaderProgram","bind","setMapperShaderParameters","setPropertyShaderParameters","setCameraShaderParameters","setLightingShaderParameters","invokeShaderCallbacks","size","setUniform2f","usize","vsize","parseFloat","halfLineWidth","setUniformf","getRepresentation","getPointSize","getPointPickingPrimitiveSize","replaceShaderPositionVC","VSSource","substitute","result","getAllocatedGPUMemoryInBytes","getCABO","DEFAULT_VALUES","shaderSourceTime","attributeUpdateTime","extend","initialValues","arguments","length","undefined","Object","assign","obj","setGet","newInstance","vtkHelper","default"],"sources":["/root/vue-cornerstone-demo/node_modules/@kitware/vtk.js/Rendering/OpenGL/Helper.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkCellArrayBufferObject from './CellArrayBufferObject.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkVertexArrayObject from './VertexArrayObject.js';\nimport { Representation } from '../Core/Property/Constants.js';\n\nconst primTypes = {\n  Start: 0,\n  Points: 0,\n  Lines: 1,\n  Tris: 2,\n  TriStrips: 3,\n  TrisEdges: 4,\n  TriStripsEdges: 5,\n  End: 6\n};\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLHelper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLHelper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLHelper');\n  publicAPI.setOpenGLRenderWindow = win => {\n    model.context = win.getContext();\n    model.program.setContext(model.context);\n    model.VAO.setOpenGLRenderWindow(win);\n    model.CABO.setOpenGLRenderWindow(win);\n  };\n  publicAPI.releaseGraphicsResources = oglwin => {\n    model.VAO.releaseGraphicsResources();\n    model.CABO.releaseGraphicsResources();\n    model.CABO.setElementCount(0);\n  };\n  publicAPI.drawArrays = (ren, actor, rep, oglMapper) => {\n    // Are there any entries\n    if (model.CABO.getElementCount()) {\n      // are we drawing edges\n      const mode = publicAPI.getOpenGLMode(rep);\n      const wideLines = publicAPI.haveWideLines(ren, actor);\n      const gl = model.context;\n      const depthMask = gl.getParameter(gl.DEPTH_WRITEMASK);\n      if (model.pointPicking) {\n        gl.depthMask(false);\n      }\n      const drawingLines = mode === gl.LINES;\n      if (drawingLines && wideLines) {\n        publicAPI.updateShaders(ren, actor, oglMapper);\n        gl.drawArraysInstanced(mode, 0, model.CABO.getElementCount(), 2 * Math.ceil(actor.getProperty().getLineWidth()));\n      } else {\n        gl.lineWidth(actor.getProperty().getLineWidth());\n        publicAPI.updateShaders(ren, actor, oglMapper);\n        gl.drawArrays(mode, 0, model.CABO.getElementCount());\n        // reset the line width\n        gl.lineWidth(1);\n      }\n      const stride = (mode === gl.POINTS ? 1 : 0) || (mode === gl.LINES ? 2 : 3);\n      if (model.pointPicking) {\n        gl.depthMask(depthMask);\n      }\n      return model.CABO.getElementCount() / stride;\n    }\n    return 0;\n  };\n  publicAPI.getOpenGLMode = rep => {\n    if (model.pointPicking) {\n      return model.context.POINTS;\n    }\n    const type = model.primitiveType;\n    if (rep === Representation.POINTS || type === primTypes.Points) {\n      return model.context.POINTS;\n    }\n    if (rep === Representation.WIREFRAME || type === primTypes.Lines || type === primTypes.TrisEdges || type === primTypes.TriStripsEdges) {\n      return model.context.LINES;\n    }\n    return model.context.TRIANGLES;\n  };\n  publicAPI.haveWideLines = (ren, actor) => {\n    if (actor.getProperty().getLineWidth() > 1.0) {\n      // we have wide lines, but the OpenGL implementation may\n      // actually support them, check the range to see if we\n      // really need have to implement our own wide lines\n      if (model.CABO.getOpenGLRenderWindow()) {\n        if (model.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth() >= actor.getProperty().getLineWidth()) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  };\n  publicAPI.getNeedToRebuildShaders = (ren, actor, oglMapper) => {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // mapper modified (lighting complexity)\n    if (oglMapper.getNeedToRebuildShaders(publicAPI, ren, actor) || publicAPI.getProgram() === 0 || publicAPI.getShaderSourceTime().getMTime() < oglMapper.getMTime() || publicAPI.getShaderSourceTime().getMTime() < actor.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.updateShaders = (ren, actor, oglMapper) => {\n    // has something changed that would require us to recreate the shader?\n    if (publicAPI.getNeedToRebuildShaders(ren, actor, oglMapper)) {\n      const shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      oglMapper.buildShaders(shaders, ren, actor);\n\n      // compile and bind the program if needed\n      const newShader = model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);\n\n      // if the shader changed reinitialize the VAO\n      if (newShader !== publicAPI.getProgram()) {\n        publicAPI.setProgram(newShader);\n        // reset the VAO as the shader has changed\n        publicAPI.getVAO().releaseGraphicsResources();\n      }\n      publicAPI.getShaderSourceTime().modified();\n    } else {\n      model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(publicAPI.getProgram());\n    }\n    publicAPI.getVAO().bind();\n    oglMapper.setMapperShaderParameters(publicAPI, ren, actor);\n    oglMapper.setPropertyShaderParameters(publicAPI, ren, actor);\n    oglMapper.setCameraShaderParameters(publicAPI, ren, actor);\n    oglMapper.setLightingShaderParameters(publicAPI, ren, actor);\n    oglMapper.invokeShaderCallbacks(publicAPI, ren, actor);\n  };\n  publicAPI.setMapperShaderParameters = (ren, actor, size) => {\n    if (publicAPI.haveWideLines(ren, actor)) {\n      publicAPI.getProgram().setUniform2f('viewportSize', size.usize, size.vsize);\n      const lineWidth = parseFloat(actor.getProperty().getLineWidth());\n      const halfLineWidth = lineWidth / 2.0;\n      publicAPI.getProgram().setUniformf('lineWidthStepSize', lineWidth / Math.ceil(lineWidth));\n      publicAPI.getProgram().setUniformf('halfLineWidth', halfLineWidth);\n    }\n    if (model.primitiveType === primTypes.Points || actor.getProperty().getRepresentation() === Representation.POINTS) {\n      publicAPI.getProgram().setUniformf('pointSize', actor.getProperty().getPointSize());\n    } else if (model.pointPicking) {\n      publicAPI.getProgram().setUniformf('pointSize', publicAPI.getPointPickingPrimitiveSize());\n    }\n  };\n  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n\n    // Always set point size in case we need picking\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', ['//VTK::PositionVC::Dec', 'uniform float pointSize;']).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['//VTK::PositionVC::Impl', '  gl_PointSize = pointSize;'], false).result;\n\n    // for lines, make sure we add the width code\n    if (publicAPI.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES && publicAPI.haveWideLines(ren, actor)) {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', ['//VTK::PositionVC::Dec', 'uniform vec2 viewportSize;', 'uniform float lineWidthStepSize;', 'uniform float halfLineWidth;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['//VTK::PositionVC::Impl', ' if (halfLineWidth > 0.0)', '   {', '   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;', '   vec4 tmpPos = gl_Position;', '   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;', '   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];', '   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];', '   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);', '   }']).result;\n    }\n    shaders.Vertex = VSSource;\n  };\n  publicAPI.getPointPickingPrimitiveSize = () => {\n    if (model.primitiveType === primTypes.Points) {\n      return 2;\n    }\n    if (model.primitiveType === primTypes.Lines) {\n      return 4;\n    }\n    return 6;\n  };\n  publicAPI.getAllocatedGPUMemoryInBytes = () => publicAPI.getCABO().getAllocatedGPUMemoryInBytes();\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  program: null,\n  shaderSourceTime: null,\n  VAO: null,\n  attributeUpdateTime: null,\n  CABO: null,\n  primitiveType: 0,\n  pointPicking: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  model.shaderSourceTime = {};\n  macro.obj(model.shaderSourceTime);\n  model.attributeUpdateTime = {};\n  macro.obj(model.attributeUpdateTime);\n  macro.setGet(publicAPI, model, ['program', 'shaderSourceTime', 'VAO', 'attributeUpdateTime', 'CABO', 'primitiveType', 'pointPicking']);\n  model.program = vtkShaderProgram.newInstance();\n  model.VAO = vtkVertexArrayObject.newInstance();\n  model.CABO = vtkCellArrayBufferObject.newInstance();\n\n  // Object methods\n  vtkOpenGLHelper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkHelper = {\n  newInstance,\n  extend,\n  primTypes\n};\n\nexport { vtkHelper as default, extend, newInstance, primTypes };\n"],"mappings":";AAAA,SAASA,CAAC,IAAIC,KAAK,QAAQ,kBAAkB;AAC7C,OAAOC,wBAAwB,MAAM,4BAA4B;AACjE,OAAOC,gBAAgB,MAAM,oBAAoB;AACjD,OAAOC,oBAAoB,MAAM,wBAAwB;AACzD,SAASC,cAAc,QAAQ,+BAA+B;AAE9D,MAAMC,SAAS,GAAG;EAChBC,KAAK,EAAE,CAAC;EACRC,MAAM,EAAE,CAAC;EACTC,KAAK,EAAE,CAAC;EACRC,IAAI,EAAE,CAAC;EACPC,SAAS,EAAE,CAAC;EACZC,SAAS,EAAE,CAAC;EACZC,cAAc,EAAE,CAAC;EACjBC,GAAG,EAAE;AACP,CAAC;;AAED;AACA;AACA;;AAEA,SAASC,eAAeA,CAACC,SAAS,EAAEC,KAAK,EAAE;EACzC;EACAA,KAAK,CAACC,cAAc,CAACC,IAAI,CAAC,iBAAiB,CAAC;EAC5CH,SAAS,CAACI,qBAAqB,GAAGC,GAAG,IAAI;IACvCJ,KAAK,CAACK,OAAO,GAAGD,GAAG,CAACE,UAAU,CAAC,CAAC;IAChCN,KAAK,CAACO,OAAO,CAACC,UAAU,CAACR,KAAK,CAACK,OAAO,CAAC;IACvCL,KAAK,CAACS,GAAG,CAACN,qBAAqB,CAACC,GAAG,CAAC;IACpCJ,KAAK,CAACU,IAAI,CAACP,qBAAqB,CAACC,GAAG,CAAC;EACvC,CAAC;EACDL,SAAS,CAACY,wBAAwB,GAAGC,MAAM,IAAI;IAC7CZ,KAAK,CAACS,GAAG,CAACE,wBAAwB,CAAC,CAAC;IACpCX,KAAK,CAACU,IAAI,CAACC,wBAAwB,CAAC,CAAC;IACrCX,KAAK,CAACU,IAAI,CAACG,eAAe,CAAC,CAAC,CAAC;EAC/B,CAAC;EACDd,SAAS,CAACe,UAAU,GAAG,CAACC,GAAG,EAAEC,KAAK,EAAEC,GAAG,EAAEC,SAAS,KAAK;IACrD;IACA,IAAIlB,KAAK,CAACU,IAAI,CAACS,eAAe,CAAC,CAAC,EAAE;MAChC;MACA,MAAMC,IAAI,GAAGrB,SAAS,CAACsB,aAAa,CAACJ,GAAG,CAAC;MACzC,MAAMK,SAAS,GAAGvB,SAAS,CAACwB,aAAa,CAACR,GAAG,EAAEC,KAAK,CAAC;MACrD,MAAMQ,EAAE,GAAGxB,KAAK,CAACK,OAAO;MACxB,MAAMoB,SAAS,GAAGD,EAAE,CAACE,YAAY,CAACF,EAAE,CAACG,eAAe,CAAC;MACrD,IAAI3B,KAAK,CAAC4B,YAAY,EAAE;QACtBJ,EAAE,CAACC,SAAS,CAAC,KAAK,CAAC;MACrB;MACA,MAAMI,YAAY,GAAGT,IAAI,KAAKI,EAAE,CAACM,KAAK;MACtC,IAAID,YAAY,IAAIP,SAAS,EAAE;QAC7BvB,SAAS,CAACgC,aAAa,CAAChB,GAAG,EAAEC,KAAK,EAAEE,SAAS,CAAC;QAC9CM,EAAE,CAACQ,mBAAmB,CAACZ,IAAI,EAAE,CAAC,EAAEpB,KAAK,CAACU,IAAI,CAACS,eAAe,CAAC,CAAC,EAAE,CAAC,GAAGc,IAAI,CAACC,IAAI,CAAClB,KAAK,CAACmB,WAAW,CAAC,CAAC,CAACC,YAAY,CAAC,CAAC,CAAC,CAAC;MAClH,CAAC,MAAM;QACLZ,EAAE,CAACa,SAAS,CAACrB,KAAK,CAACmB,WAAW,CAAC,CAAC,CAACC,YAAY,CAAC,CAAC,CAAC;QAChDrC,SAAS,CAACgC,aAAa,CAAChB,GAAG,EAAEC,KAAK,EAAEE,SAAS,CAAC;QAC9CM,EAAE,CAACV,UAAU,CAACM,IAAI,EAAE,CAAC,EAAEpB,KAAK,CAACU,IAAI,CAACS,eAAe,CAAC,CAAC,CAAC;QACpD;QACAK,EAAE,CAACa,SAAS,CAAC,CAAC,CAAC;MACjB;MACA,MAAMC,MAAM,GAAG,CAAClB,IAAI,KAAKI,EAAE,CAACe,MAAM,GAAG,CAAC,GAAG,CAAC,MAAMnB,IAAI,KAAKI,EAAE,CAACM,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;MAC1E,IAAI9B,KAAK,CAAC4B,YAAY,EAAE;QACtBJ,EAAE,CAACC,SAAS,CAACA,SAAS,CAAC;MACzB;MACA,OAAOzB,KAAK,CAACU,IAAI,CAACS,eAAe,CAAC,CAAC,GAAGmB,MAAM;IAC9C;IACA,OAAO,CAAC;EACV,CAAC;EACDvC,SAAS,CAACsB,aAAa,GAAGJ,GAAG,IAAI;IAC/B,IAAIjB,KAAK,CAAC4B,YAAY,EAAE;MACtB,OAAO5B,KAAK,CAACK,OAAO,CAACkC,MAAM;IAC7B;IACA,MAAMC,IAAI,GAAGxC,KAAK,CAACyC,aAAa;IAChC,IAAIxB,GAAG,KAAK7B,cAAc,CAACmD,MAAM,IAAIC,IAAI,KAAKnD,SAAS,CAACE,MAAM,EAAE;MAC9D,OAAOS,KAAK,CAACK,OAAO,CAACkC,MAAM;IAC7B;IACA,IAAItB,GAAG,KAAK7B,cAAc,CAACsD,SAAS,IAAIF,IAAI,KAAKnD,SAAS,CAACG,KAAK,IAAIgD,IAAI,KAAKnD,SAAS,CAACM,SAAS,IAAI6C,IAAI,KAAKnD,SAAS,CAACO,cAAc,EAAE;MACrI,OAAOI,KAAK,CAACK,OAAO,CAACyB,KAAK;IAC5B;IACA,OAAO9B,KAAK,CAACK,OAAO,CAACsC,SAAS;EAChC,CAAC;EACD5C,SAAS,CAACwB,aAAa,GAAG,CAACR,GAAG,EAAEC,KAAK,KAAK;IACxC,IAAIA,KAAK,CAACmB,WAAW,CAAC,CAAC,CAACC,YAAY,CAAC,CAAC,GAAG,GAAG,EAAE;MAC5C;MACA;MACA;MACA,IAAIpC,KAAK,CAACU,IAAI,CAACkC,qBAAqB,CAAC,CAAC,EAAE;QACtC,IAAI5C,KAAK,CAACU,IAAI,CAACkC,qBAAqB,CAAC,CAAC,CAACC,2BAA2B,CAAC,CAAC,IAAI7B,KAAK,CAACmB,WAAW,CAAC,CAAC,CAACC,YAAY,CAAC,CAAC,EAAE;UAC1G,OAAO,KAAK;QACd;MACF;MACA,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd,CAAC;EACDrC,SAAS,CAAC+C,uBAAuB,GAAG,CAAC/B,GAAG,EAAEC,KAAK,EAAEE,SAAS,KAAK;IAC7D;IACA;IACA;IACA;IACA;IACA,IAAIA,SAAS,CAAC4B,uBAAuB,CAAC/C,SAAS,EAAEgB,GAAG,EAAEC,KAAK,CAAC,IAAIjB,SAAS,CAACgD,UAAU,CAAC,CAAC,KAAK,CAAC,IAAIhD,SAAS,CAACiD,mBAAmB,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,GAAG/B,SAAS,CAAC+B,QAAQ,CAAC,CAAC,IAAIlD,SAAS,CAACiD,mBAAmB,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,GAAGjC,KAAK,CAACiC,QAAQ,CAAC,CAAC,EAAE;MAClO,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd,CAAC;EACDlD,SAAS,CAACgC,aAAa,GAAG,CAAChB,GAAG,EAAEC,KAAK,EAAEE,SAAS,KAAK;IACnD;IACA,IAAInB,SAAS,CAAC+C,uBAAuB,CAAC/B,GAAG,EAAEC,KAAK,EAAEE,SAAS,CAAC,EAAE;MAC5D,MAAMgC,OAAO,GAAG;QACdC,MAAM,EAAE,IAAI;QACZC,QAAQ,EAAE,IAAI;QACdC,QAAQ,EAAE;MACZ,CAAC;MACDnC,SAAS,CAACoC,YAAY,CAACJ,OAAO,EAAEnC,GAAG,EAAEC,KAAK,CAAC;;MAE3C;MACA,MAAMuC,SAAS,GAAGvD,KAAK,CAACU,IAAI,CAACkC,qBAAqB,CAAC,CAAC,CAACY,cAAc,CAAC,CAAC,CAACC,uBAAuB,CAACP,OAAO,CAACC,MAAM,EAAED,OAAO,CAACE,QAAQ,EAAEF,OAAO,CAACG,QAAQ,CAAC;;MAEjJ;MACA,IAAIE,SAAS,KAAKxD,SAAS,CAACgD,UAAU,CAAC,CAAC,EAAE;QACxChD,SAAS,CAAC2D,UAAU,CAACH,SAAS,CAAC;QAC/B;QACAxD,SAAS,CAAC4D,MAAM,CAAC,CAAC,CAAChD,wBAAwB,CAAC,CAAC;MAC/C;MACAZ,SAAS,CAACiD,mBAAmB,CAAC,CAAC,CAACY,QAAQ,CAAC,CAAC;IAC5C,CAAC,MAAM;MACL5D,KAAK,CAACU,IAAI,CAACkC,qBAAqB,CAAC,CAAC,CAACY,cAAc,CAAC,CAAC,CAACK,kBAAkB,CAAC9D,SAAS,CAACgD,UAAU,CAAC,CAAC,CAAC;IAChG;IACAhD,SAAS,CAAC4D,MAAM,CAAC,CAAC,CAACG,IAAI,CAAC,CAAC;IACzB5C,SAAS,CAAC6C,yBAAyB,CAAChE,SAAS,EAAEgB,GAAG,EAAEC,KAAK,CAAC;IAC1DE,SAAS,CAAC8C,2BAA2B,CAACjE,SAAS,EAAEgB,GAAG,EAAEC,KAAK,CAAC;IAC5DE,SAAS,CAAC+C,yBAAyB,CAAClE,SAAS,EAAEgB,GAAG,EAAEC,KAAK,CAAC;IAC1DE,SAAS,CAACgD,2BAA2B,CAACnE,SAAS,EAAEgB,GAAG,EAAEC,KAAK,CAAC;IAC5DE,SAAS,CAACiD,qBAAqB,CAACpE,SAAS,EAAEgB,GAAG,EAAEC,KAAK,CAAC;EACxD,CAAC;EACDjB,SAAS,CAACgE,yBAAyB,GAAG,CAAChD,GAAG,EAAEC,KAAK,EAAEoD,IAAI,KAAK;IAC1D,IAAIrE,SAAS,CAACwB,aAAa,CAACR,GAAG,EAAEC,KAAK,CAAC,EAAE;MACvCjB,SAAS,CAACgD,UAAU,CAAC,CAAC,CAACsB,YAAY,CAAC,cAAc,EAAED,IAAI,CAACE,KAAK,EAAEF,IAAI,CAACG,KAAK,CAAC;MAC3E,MAAMlC,SAAS,GAAGmC,UAAU,CAACxD,KAAK,CAACmB,WAAW,CAAC,CAAC,CAACC,YAAY,CAAC,CAAC,CAAC;MAChE,MAAMqC,aAAa,GAAGpC,SAAS,GAAG,GAAG;MACrCtC,SAAS,CAACgD,UAAU,CAAC,CAAC,CAAC2B,WAAW,CAAC,mBAAmB,EAAErC,SAAS,GAAGJ,IAAI,CAACC,IAAI,CAACG,SAAS,CAAC,CAAC;MACzFtC,SAAS,CAACgD,UAAU,CAAC,CAAC,CAAC2B,WAAW,CAAC,eAAe,EAAED,aAAa,CAAC;IACpE;IACA,IAAIzE,KAAK,CAACyC,aAAa,KAAKpD,SAAS,CAACE,MAAM,IAAIyB,KAAK,CAACmB,WAAW,CAAC,CAAC,CAACwC,iBAAiB,CAAC,CAAC,KAAKvF,cAAc,CAACmD,MAAM,EAAE;MACjHxC,SAAS,CAACgD,UAAU,CAAC,CAAC,CAAC2B,WAAW,CAAC,WAAW,EAAE1D,KAAK,CAACmB,WAAW,CAAC,CAAC,CAACyC,YAAY,CAAC,CAAC,CAAC;IACrF,CAAC,MAAM,IAAI5E,KAAK,CAAC4B,YAAY,EAAE;MAC7B7B,SAAS,CAACgD,UAAU,CAAC,CAAC,CAAC2B,WAAW,CAAC,WAAW,EAAE3E,SAAS,CAAC8E,4BAA4B,CAAC,CAAC,CAAC;IAC3F;EACF,CAAC;EACD9E,SAAS,CAAC+E,uBAAuB,GAAG,CAAC5B,OAAO,EAAEnC,GAAG,EAAEC,KAAK,KAAK;IAC3D,IAAI+D,QAAQ,GAAG7B,OAAO,CAACC,MAAM;;IAE7B;IACA4B,QAAQ,GAAG7F,gBAAgB,CAAC8F,UAAU,CAACD,QAAQ,EAAE,wBAAwB,EAAE,CAAC,wBAAwB,EAAE,0BAA0B,CAAC,CAAC,CAACE,MAAM;IACzIF,QAAQ,GAAG7F,gBAAgB,CAAC8F,UAAU,CAACD,QAAQ,EAAE,yBAAyB,EAAE,CAAC,yBAAyB,EAAE,6BAA6B,CAAC,EAAE,KAAK,CAAC,CAACE,MAAM;;IAErJ;IACA,IAAIlF,SAAS,CAACsB,aAAa,CAACL,KAAK,CAACmB,WAAW,CAAC,CAAC,CAACwC,iBAAiB,CAAC,CAAC,CAAC,KAAK3E,KAAK,CAACK,OAAO,CAACyB,KAAK,IAAI/B,SAAS,CAACwB,aAAa,CAACR,GAAG,EAAEC,KAAK,CAAC,EAAE;MACnI+D,QAAQ,GAAG7F,gBAAgB,CAAC8F,UAAU,CAACD,QAAQ,EAAE,wBAAwB,EAAE,CAAC,wBAAwB,EAAE,4BAA4B,EAAE,kCAAkC,EAAE,8BAA8B,CAAC,CAAC,CAACE,MAAM;MAC/MF,QAAQ,GAAG7F,gBAAgB,CAAC8F,UAAU,CAACD,QAAQ,EAAE,yBAAyB,EAAE,CAAC,yBAAyB,EAAE,2BAA2B,EAAE,MAAM,EAAE,iFAAiF,EAAE,+BAA+B,EAAE,0CAA0C,EAAE,6FAA6F,EAAE,iGAAiG,EAAE,0DAA0D,EAAE,MAAM,CAAC,CAAC,CAACE,MAAM;IAC5jB;IACA/B,OAAO,CAACC,MAAM,GAAG4B,QAAQ;EAC3B,CAAC;EACDhF,SAAS,CAAC8E,4BAA4B,GAAG,MAAM;IAC7C,IAAI7E,KAAK,CAACyC,aAAa,KAAKpD,SAAS,CAACE,MAAM,EAAE;MAC5C,OAAO,CAAC;IACV;IACA,IAAIS,KAAK,CAACyC,aAAa,KAAKpD,SAAS,CAACG,KAAK,EAAE;MAC3C,OAAO,CAAC;IACV;IACA,OAAO,CAAC;EACV,CAAC;EACDO,SAAS,CAACmF,4BAA4B,GAAG,MAAMnF,SAAS,CAACoF,OAAO,CAAC,CAAC,CAACD,4BAA4B,CAAC,CAAC;AACnG;;AAEA;AACA;AACA;;AAEA,MAAME,cAAc,GAAG;EACrB/E,OAAO,EAAE,IAAI;EACbE,OAAO,EAAE,IAAI;EACb8E,gBAAgB,EAAE,IAAI;EACtB5E,GAAG,EAAE,IAAI;EACT6E,mBAAmB,EAAE,IAAI;EACzB5E,IAAI,EAAE,IAAI;EACV+B,aAAa,EAAE,CAAC;EAChBb,YAAY,EAAE;AAChB,CAAC;;AAED;;AAEA,SAAS2D,MAAMA,CAACxF,SAAS,EAAEC,KAAK,EAAE;EAChC,IAAIwF,aAAa,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;EAC1FG,MAAM,CAACC,MAAM,CAAC7F,KAAK,EAAEoF,cAAc,EAAEI,aAAa,CAAC;;EAEnD;EACAxG,KAAK,CAAC8G,GAAG,CAAC/F,SAAS,EAAEC,KAAK,CAAC;EAC3BA,KAAK,CAACqF,gBAAgB,GAAG,CAAC,CAAC;EAC3BrG,KAAK,CAAC8G,GAAG,CAAC9F,KAAK,CAACqF,gBAAgB,CAAC;EACjCrF,KAAK,CAACsF,mBAAmB,GAAG,CAAC,CAAC;EAC9BtG,KAAK,CAAC8G,GAAG,CAAC9F,KAAK,CAACsF,mBAAmB,CAAC;EACpCtG,KAAK,CAAC+G,MAAM,CAAChG,SAAS,EAAEC,KAAK,EAAE,CAAC,SAAS,EAAE,kBAAkB,EAAE,KAAK,EAAE,qBAAqB,EAAE,MAAM,EAAE,eAAe,EAAE,cAAc,CAAC,CAAC;EACtIA,KAAK,CAACO,OAAO,GAAGrB,gBAAgB,CAAC8G,WAAW,CAAC,CAAC;EAC9ChG,KAAK,CAACS,GAAG,GAAGtB,oBAAoB,CAAC6G,WAAW,CAAC,CAAC;EAC9ChG,KAAK,CAACU,IAAI,GAAGzB,wBAAwB,CAAC+G,WAAW,CAAC,CAAC;;EAEnD;EACAlG,eAAe,CAACC,SAAS,EAAEC,KAAK,CAAC;AACnC;;AAEA;;AAEA,MAAMgG,WAAW,GAAGhH,KAAK,CAACgH,WAAW,CAACT,MAAM,CAAC;;AAE7C;;AAEA,IAAIU,SAAS,GAAG;EACdD,WAAW;EACXT,MAAM;EACNlG;AACF,CAAC;AAED,SAAS4G,SAAS,IAAIC,OAAO,EAAEX,MAAM,EAAES,WAAW,EAAE3G,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}